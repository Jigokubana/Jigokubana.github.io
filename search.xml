<?xml version="1.0" encoding="utf-8"?>
<search>
    
    
    <entry>
        <title><![CDATA[编程规范]]></title>
        <url>http://blog.lsmg.xyz/2020/01/CPP-CPP%25E9%2587%258D%25E7%2582%25B9-%25E7%25BC%2596%25E7%25A8%258B%25E8%25A7%2584%25E8%258C%2583/</url>
        <content type="html"><![CDATA[<p><strong>第一点</strong><br>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure>

<p><strong>第二点</strong><br>局部变量应当声明和初始化同时进行, 推荐使用C++11的花括号</p>
<p><em>如果在循环中, 不要将对象的声明放入其中</em>, 每次进入作用域都会调用构造函数, 每次退出都会调用析构函数</p>
<p><strong>第三点-类相关</strong><br>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p>
<p>不要定义隐式类型转换. </p>
<p>对于转换运算符和单参数构造函数, 请使用 explicit 关键字.</p>
<ul>
<li>单参数构造函数有可能会被无意地用作隐式类型转换.</li>
</ul>
<p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p>
<ul>
<li>MyClass(const MyClass&amp;) = delete;<br>MyClass&amp; operator=(const MyClass&amp;) = delete;</li>
</ul>
<p>仅当<code>只有</code>数据成员的时候<code>struct</code>, <code>其他一律</code>使用class</p>
<p>使用组合常常比使用继承更合理</p>
<ul>
<li>所有的继承<code>必须是public</code>, </li>
</ul>
<p>多重继承(真正需要的时候很少)</p>
<ul>
<li>最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.</li>
</ul>
<p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量</p>
<ul>
<li>重载运算符, 容易造成代码混乱, 因为没有统一的重载规范</li>
</ul>
<p>数据成员都必须是私有的</p>
<p><strong>第四点-函数相关</strong></p>
<p>输入参数在先, 后跟输出参数.</p>
<p>编写简短函数</p>
<p>所有按引用传递的参数必须加上 const.</p>
<p>函数重载</p>
<ul>
<li>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,<br>而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</li>
<li>如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.</li>
</ul>
<p>省却参数</p>
<p>函数返回类型后置语法</p>
<ul>
<li><code>auto foo(int x) -&gt; int</code> 对于简单的类型, 优点体现不出</li>
<li>对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别?????.</li>
</ul>
<p><strong>杂项</strong><br>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p>
<p><strong>第五点命名-版本最多的地方</strong></p>
<p>文件命名</p>
<ul>
<li>全部小写包含<code>_</code>最好</li>
<li>C++ 文件要以 .cc 结尾, 头文件以 .h 结尾.</li>
</ul>
<p>类型名称 - 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数</p>
<ul>
<li>类型名称的每个单词首字母均大写, 不包含下划线<code>MyExcitingClass</code></li>
</ul>
<p>变量命名</p>
<ul>
<li>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾</li>
</ul>
<p>常量命名</p>
<ul>
<li>字母k开头</li>
<li>声明为 constexpr 或 const</li>
</ul>
<p>函数命名</p>
<ul>
<li>每个单词首字母大写, 没有下划线</li>
<li>首字母缩写的单词, 经常对其的第一个字母大写</li>
</ul>
<p>命名空间命名</p>
<ul>
<li>小写字母命名</li>
</ul>
<p>枚举命名</p>
<ul>
<li>枚举的命名应当和 常量 或 宏 一致: kEnumName</li>
</ul>
<p><strong>第六点-格式</strong></p>
<p>缩进两个空格</p>
<p>函数定义与声明</p>
<ul>
<li>左圆括号总是和函数名在同一行.(没有标准,,,,,,,,,, emmm 我想我还是换行吧 不过对于else换行挺难受的)</li>
<li>函数名和左圆括号间永远没有空格.</li>
<li>圆括号与参数间没有空格.</li>
</ul>
]]></content>
        
        <categories>
            
            <category> CPP </category>
            
            <category> CPP重点 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[游戏知识-杂谈-如何进入游戏开发行业]]></title>
        <url>http://blog.lsmg.xyz/2019/12/%25E6%25B8%25B8%25E6%2588%258F%25E7%259F%25A5%25E8%25AF%2586-%25E6%259D%2582%25E8%25B0%2588-%25E5%25A6%2582%25E4%25BD%2595%25E8%25BF%259B%25E5%2585%25A5%25E6%25B8%25B8%25E6%2588%258F%25E5%25BC%2580%25E5%258F%2591%25E8%25A1%258C%25E4%25B8%259A/</url>
        <content type="html"><![CDATA[<p>由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面<br><a href="https://gameinstitute.qq.com/course/detail/10156" target="_blank" rel="noopener">想做游戏吗？如何开始我的游戏开发职业生涯</a></p>
<a id="more"></a>
<p>做游戏不会重复做同样的工作, 项目不同</p>
]]></content>
        
        <categories>
            
            <category> 游戏知识 </category>
            
            <category> 杂谈 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[游戏知识-服务器-服务器通信]]></title>
        <url>http://blog.lsmg.xyz/2019/12/%25E6%25B8%25B8%25E6%2588%258F%25E7%259F%25A5%25E8%25AF%2586-%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8-%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8%25E9%2580%259A%25E4%25BF%25A1/</url>
        <content type="html"><![CDATA[<p>由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面<br><a href="https://gameinstitute.qq.com/course/detail/10096" target="_blank" rel="noopener">服务器通信</a></p>
<a id="more"></a>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>作业型-单纯多个client对一个server .. 比如我开始写过的聊天室程序</p>
<h1 id="CS通信"><a href="#CS通信" class="headerlink" title="CS通信"></a>CS通信</h1><p><img src="" alt="浏览器访问过程"><br>DNS协议-基于UDP协议</p>
<p>TCP<br>面向连接的可靠的有时序性的-流式协议<br>窗口管理<br>流量控制<br>数据确认<br>UDP<br>无连接不保证可靠性的无法保证时序-报文协议</p>
<p>QQ-CS<br>网络状况较好-UDP????-好吧还是处理了<br>网络状况差-TCP<br>大文件-TCP-TCP适合大文件交互, 因为他保持连接流式协议~</p>
<p>微信-CS<br>前台运行-TCP长连接<br>后台运行-TCP短连接<br>查看文章-HTTP(TCP短连接)</p>
<p>QQ-早期产品, 花最少的前~榨干性能<br>微信-腾讯后期产品</p>
<hr>
<p>字符串<br>自定义<br>Protobuf</p>
<p>序列化反序列化.</p>
<p>UDP协议-不要让单个包的数据量超过1K, 否则会由于分片等 导致一个大包一旦一个分片失败就都失败</p>
<p>存在的问题</p>
<ol>
<li>客户端和服务端数据一直对不上<br>可能是字节序的问题 - 字节序转换(网络字节数传送)</li>
<li>服务器发送的数据延迟-小包<br>NAGLE算法-小包并不是立即发送-等存多了在一起发送-可以禁用掉~~</li>
<li>数据较大或者网络波动<br>发送缓冲区慢了.. 适当加大发送缓冲区</li>
</ol>
<p>非阻塞IO<br>O_NONBLOCK<br>多路复用<br>select<br>poll<br>epoll</p>
<h1 id="SS通信"><a href="#SS通信" class="headerlink" title="SS通信"></a>SS通信</h1><p><img src="" alt="服务器间通信"><br>TCP-最常用<br>UDP-非关键数据-日志服务-内网通信网络状况好可以超过MTU<br>非SOCKET通信-进程间通信?-管道-信号-共享内存-信息队列-文件..</p>
]]></content>
        
        <categories>
            
            <category> 游戏知识 </category>
            
            <category> 服务器 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[Protobuf入门]]></title>
        <url>http://blog.lsmg.xyz/2019/11/CPP-Protobuf-Protobuf%25E5%2585%25A5%25E9%2597%25A8/</url>
        <content type="html"><![CDATA[<p>学习Protobuf来传输数据<br>依然是结合官方文档, 一方面锻炼自己英文文档阅读能力, 一方面就是学习了.<br>我将会在博客中翻译一部分原文内容, 方便自己日后参考</p>
<a id="more"></a>

<h1 id="为什么要用Protobuf"><a href="#为什么要用Protobuf" class="headerlink" title="为什么要用Protobuf"></a>为什么要用Protobuf</h1><p>官方先给出了一个简单的例子. 如何存储地址簿</p>
<ul>
<li>使用<code>raw in-memory data structures</code>(原始的内存数据结构,通过二进制存储)<br>这种方式的弊端非常明显, 他非常的脆弱, 收发的时候必须严格的按照规定的内存布局发送和接收.<br>一旦存储起来难以更改原先存储的数据</li>
<li>使用某种格式编码数据, 对于少量的书库编码和解码速度很快, 使用比较方便</li>
<li>将数据序列化为XML, 虽然XML利于阅读而且方便传输, 但是他会占用更多的空间<br>同时编码和解码的时候会消耗更多的资源.</li>
</ul>
<p>Protobuf是一个<code>flexible, efficient, automated solution</code>(灵活的, 有效的, 自动的方法)解决上述问题.<br>通过<code>protocol buffers</code>你可以定义一个<code>.proto</code>文件来描述数据的存储<br>其自动创建了一个类, 这个类以有效的二进制格式实现数据的编码和解析<br>提供了<code>getters</code>和<code>setters</code><br>以协议为单位来读写<br>重要的是PB支持随着时间来扩展格式同时数据仍可以读和编码通过旧格式</p>
<h1 id="定义协议格式"><a href="#定义协议格式" class="headerlink" title="定义协议格式"></a>定义协议格式</h1><p>目前2019年11月13日23:27:11 官网还没有C++的proto3的文档<br>先学习proto2的, 日后再改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto2&quot;;</span><br><span class="line"></span><br><span class="line">package tutorial;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">  required string name &#x3D; 1;</span><br><span class="line">  required int32 id &#x3D; 2;</span><br><span class="line">  optional string email &#x3D; 3;</span><br><span class="line"></span><br><span class="line">  enum PhoneType &#123;</span><br><span class="line">    MOBILE &#x3D; 0;</span><br><span class="line">    HOME &#x3D; 1;</span><br><span class="line">    WORK &#x3D; 2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  message PhoneNumber &#123;</span><br><span class="line">    required string number &#x3D; 1;</span><br><span class="line">    optional PhoneType type &#x3D; 2 [default &#x3D; HOME];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  repeated PhoneNumber phones &#x3D; 4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddressBook &#123;</span><br><span class="line">  repeated Person people &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
        
        <categories>
            
            <category> CPP </category>
            
            <category> Protobuf </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[指针]]></title>
        <url>http://blog.lsmg.xyz/2019/11/CPP-CPP%25E5%259F%25BA%25E7%25A1%2580-%25E6%258C%2587%25E9%2592%2588/</url>
        <content type="html"><![CDATA[<p>指针的话, 自己是要学会自己去理解各种组合. 首先只要定义复杂指针肯定会涉及到运算符优先级<br>根据运算符优先级判断这个定义的含义</p>
<h1 id="指针的定义识别"><a href="#指针的定义识别" class="headerlink" title="指针的定义识别"></a>指针的定义识别</h1><h2 id="由运算符优先级判断"><a href="#由运算符优先级判断" class="headerlink" title="由运算符优先级判断"></a>由运算符优先级判断</h2><p>下面列出常见到的运算符</p>
<p><code>[]</code>中括号这个的优先级最高, 跟括号并列.(排除域运算符).<br>    从左到右的结合性 -意味着<code>p[]</code>中<code>[]</code>会先跟<code>p结合</code>而不是中括号右边的内容<br><code>()</code>与之结合成为函数<br>    从左到右的结合性<br><code>*</code>其次是这个符号<br>    从右到左的结合性</p>
<p>两个大头<br><code>int *p[3]</code>和<code>int (*p)[3]</code><br>前者由于<code>[]</code>的优先级更高p与之结合说明p是<strong>数组*</strong>得到p本质是什么 数组OR指针*<br>再与<code>*</code>结合说明<strong>数组中的元素</strong>是<strong>指针*</strong>第二次结合 如果第一次是数组-则为数组中的内容, 第一次是指针-则为指针的指向*<br>再与int结合 说明数组中<strong>指针指向</strong>的是int</p>
<p>后者<code>*</code>先与p结合说明p是一个<strong>指针</strong><br>再与<code>[]</code>结合说明<strong>指针指向</strong>的内容是<strong>数组</strong><br>再与int结合说明<strong>数组中的内容</strong>是int</p>
<hr>
<p>本质上定义函数相关的也可以这样理解<br><code>int p(int)</code>和<code>int (*p)(int)</code><br>前者p先与<code>()</code>结合说明p是一个<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p>
<p>后者p先与<code>*</code>结合说明p是一个<strong>指针</strong><br>与<code>()</code>结合说明<strong>指针指向</strong>的是<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p>
<h2 id="判断指针的类型"><a href="#判断指针的类型" class="headerlink" title="判断指针的类型"></a>判断指针的类型</h2><p>去除指针声明语句中的指针名称, 剩下的部分就是指针的类型.<br><code>int* p</code>得到<code>int*</code>, 说明指针的类型是<code>int*</code><br><code>int (*p)[3]</code> 说明指针的类型是<code>int (*)[3]</code></p>
<h2 id="指针指向的类型"><a href="#指针指向的类型" class="headerlink" title="指针指向的类型"></a>指针指向的类型</h2><p>去除指针声明语句中的指针名称, 以及名称左边的指针声明符<em>, 剩下的部分是指针指向的类型<br>`int</em> p<code>得到</code>int<code>说明指针指向的类型就是</code>int<code></code>int (*p)[3]<code>得到</code>int()[3]<code>说明指针指向的类型就是</code>int()[3]`</p>
<h2 id="指针的值"><a href="#指针的值" class="headerlink" title="指针的值"></a>指针的值</h2><p>指针存储的即为指向一个内存区域的地址值</p>
]]></content>
        
        <categories>
            
            <category> CPP </category>
            
            <category> CPP基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[C++薄书整理]]></title>
        <url>http://blog.lsmg.xyz/2019/10/CPP-CPP%25E5%259F%25BA%25E7%25A1%2580-2/</url>
        <content type="html"><![CDATA[<h1 id="定义新量"><a href="#定义新量" class="headerlink" title="定义新量"></a>定义新量</h1><p>auto 自动根据初始值的类型进行自动类型推导.<br>decltype 根据表达式的类型定义对象</p>
<p>右值引用, 操纵右值对象<br><code>std::move()</code>, 可以将一个</p>
<p><strong>枚举</strong><br>不限定作用域的定义<br>enum color {red, green, blue};<br>限定在类型内部的作用域<br>enum class color {red, green, blue};<br><code>color a = color::red</code></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>数组传参的长度处理</p>
<ul>
<li>直接传递数组长度</li>
<li>使用C风格字符串(默认结尾有标志)</li>
<li>使用C++11的新函数begin()和end()同时传递首尾地址</li>
</ul>
<p>函数指针<br><code>bool (*pf)(int, int)</code> 可以指向<br><code>bool max(int a,int b)</code><br>调用 <code>pf(1, 1)</code>即可<br>常用于函数的参数是一个函数的返回值</p>
<p><strong>Lambda</strong><br><code>[]() -&gt; return type {statements}</code><br>中括号代表lambda引导, 其中的captures子句在同一作用域下lambda主体捕获(访问)哪些对象<br>以及如何捕获这些对象</p>
<ul>
<li>可以为空, 不会访问外围对象</li>
<li>[=] 代表用值捕获的方式</li>
<li>[&amp;] 代表引用捕获</li>
</ul>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p><strong>辅助函数</strong><br>定义辅助函数, 有点像Java里面的重写toString()函数(最常见的代表的例子)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	os &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>友元函数</strong><br>一个类的辅助函数从概念上可以看成类的接口, 虽然和类的关系很密切, 但并不是类的成员, 所以不能直接访问私有成员<br>C++ 中可以将该类函数声明为该类的友元.<br>这样就能访问到类的非公有成员.<br>在函数的前面加上<code>friend</code>关键字<br><strong>友元类</strong><br>如果A想访问B的私有成员, 可以在B内声明<code>friend class A</code>, 这样就可以在B内访问A的私有成员<br><em>友元关系是单向的, 不具有交换性, 同时也不具有传递性</em></p>
<p><strong>构造函数</strong><br>默认构造函数没有参数, 或者所有的参数都具有默认值<br>C++11允许在显示定义构造函数的情况下使用默认构造函数<br>需要在默认构造函数后面加上<code>= default</code><br><em>使用默认构造函数创建类对象时, 切忌在对象名后I使用圆括号, 成了一个函数声明</em></p>
<p><strong>初始值列表</strong><br>T(int a, int b):a_(a), b_(b){}<br>引用和const修饰的必须用初始值列表初始化, 初始的顺序取决于数据成员在类内的定义顺序,<br>而非初始值列表的顺序</p>
<p><strong>简化构造函数</strong><br>实际将自己的带参构造函数, 给定默认值, 这样就实现了默认构造函数和带参构造函数的合并</p>
<p><strong>复制构造函数</strong><br>参数为该类的引用</p>
<p><strong>委托构造函数</strong><br>减少构造函数代码量<br>实际就是一个构造函数后面加上<code>:</code>调用另一个构造函数, 同时传入参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> bar1_;</span><br><span class="line">	<span class="keyword">int</span> bar2_;</span><br><span class="line">	A(<span class="keyword">int</span> b1):A(b1, <span class="number">2</span>)&#123;&#125;</span><br><span class="line">	A(<span class="keyword">int</span> b1, <span class="keyword">int</span> b2):bar1_(b1), bar2_(b2)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>运算符重载</strong><br>T operator /(A, B);<br>双目运算符两个参数<br>单目运算符一个参数<br>对于二元运算符, 左侧运算对象传递给第一个参数, 右侧运算对象传递给第二个参数.</p>
<p>运算符重载的声明和定义的分离<br>放在类成员中的运算符重载, 需要算入默认的this指针参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>+(<span class="keyword">const</span> Test&amp; right);</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PrintAB</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a_;</span><br><span class="line">	<span class="keyword">int</span> b_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line">Test::Test(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    a_ = a;</span><br><span class="line">    b_ = b;</span><br><span class="line">&#125;</span><br><span class="line">Test&amp; Test::<span class="keyword">operator</span>+(<span class="keyword">const</span> Test&amp; right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Test <span class="title">test</span><span class="params">(<span class="keyword">this</span>-&gt;a_ + right.a_, <span class="keyword">this</span>-&gt;b_ + right.b_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test::PrintAB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a_, b_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">test1</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">test2</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    Test test = test1 + test2;</span><br><span class="line">    test.PrintAB();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ++ -- </span></span><br><span class="line">Test&amp; <span class="keyword">operator</span>++(); <span class="comment">// 前置版本</span></span><br><span class="line">Test <span class="keyword">operator</span>++(<span class="keyword">int</span>); <span class="comment">// 后置版本</span></span><br></pre></td></tr></table></figure>
<p><strong>类成员指针</strong><br><em>数据成员指针</em> (private不能通过指针访问)<br>其值是数据成员所在地址相对于对象起始地址的偏移值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A T::*p1 = &amp;T::x</span><br><span class="line"><span class="keyword">int</span> A::*p1 = &amp;A::value</span><br><span class="line">A a;</span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line">a.*p = ......................;</span><br></pre></td></tr></table></figure>
<p>p1指向T类中的 A类型的x数据成员<br><code>A T::</code>可以用<code>auto</code></p>
<p><em>成员函数指针</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (A::*pf)();</span><br><span class="line">pf = &amp;A::GetValue;</span><br><span class="line"><span class="comment">// 当然可以使用auto 来简化</span></span><br><span class="line"><span class="keyword">auto</span> pf2 = &amp;A::GetValue;</span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line">(a.*pf)();</span><br></pre></td></tr></table></figure>

<hr>
<p>统一初始化<br><code>X x1 = {0} 和 X x2 {0}</code> 这两种是不同的实现!!, 大多数情况下这两个是相通的, 然而当<br><code>explicit构造函数</code>存在的时候<code>前者的初始化是错误的</code></p>
<p><code>int x{0} int x= 0 int x(0)</code> 最后一个是错误的可能会和函数声明冲突</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">int</span> x;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">z</span><span class="params">(x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外还存在一个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; a1&#123;<span class="number">0</span>&#125;; <span class="comment">// OK</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; a3 = <span class="number">0</span>; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>这个错误的原因是copy-initialization引起的<br>这个copy-initialization发生在<code>T x = a</code>的声明, 下面我把原博客的部分重要英文替换成中文或代码描述<br><code>std::atomic&lt;int&gt; a3 = 0</code> 从<code>int类型</code>赋值到<code>可能是 cv-qualified</code>的<code>class type</code><br><a href="https://stackoverflow.com/questions/27527642/what-does-cv-qualified-mean" target="_blank" rel="noopener">cv-qualified</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ***cv-qualified***</span></span><br><span class="line"><span class="comment">// non cv_qualified</span></span><br><span class="line"><span class="keyword">int</span> first; </span><br><span class="line"><span class="keyword">char</span> *second; </span><br><span class="line"></span><br><span class="line"><span class="comment">// cv-qualified </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> third; </span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span> * fourth;</span><br></pre></td></tr></table></figure>
<p><code>std::atomic&lt;int&gt; a3 = 0</code> 满足了这个条件属于<code>copy-initialization</code><br><a href="https://www.quora.com/What-is-the-difference-between-copy-initialization-and-direct-initialization-of-objects-in-c++" target="_blank" rel="noopener">copy-initialization</a><br><a href="https://blog.csdn.net/ljianhui/article/details/9245661" target="_blank" rel="noopener">直接初始化和复制初始化的区别</a><br>直接初始化会直接用参数生成对象, 而复制初始化会<code>用参数生成临时对象, 然后将这个对象复制到正要创建的对象</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        A () &#123; &#125; <span class="comment">//直接初始化会调用这个构造函数</span></span><br><span class="line">        A (<span class="keyword">const</span> A&amp; a) &#123; &#125; <span class="comment">//复制初始化会调用这个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来需要通过<code>std::atomic&lt;int&gt;(int)</code>把0转换成成一个纯右值(prvalue)的临时对象<br><a href="https://zh.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener">纯右值</a><br><a href="https://www.cnblogs.com/zpcdbky/p/5275959.html" target="_blank" rel="noopener">纯右值</a><br>然后再将这个临时对象用直接初始化(调用复制构造函数), 然而<code>std::atomic&lt;int&gt;</code>把拷贝<br>构造函数给禁用了, 就会出错<br><code>std::atomic&lt;int&gt; a3 {0}</code>这个会直接调用接收int的构造函数</p>
<p>回到<code>X x1 = {0}</code>这里, 这个表达式是一个复制构造, 用一个braced-init-list(指的{0}).<br>这里有两个阶段<br>首先是会把单个参数的构造函数汇总起来(得到A-list)供选择, 如果其中没有合适的构造函数, 再将候选列表<br>转换为所有构造函数</p>
<p>如果如果A-list没有构造函数, 并且class T存在默认构造函数, 第一阶段就会被忽略<br>如果在一个使用<code>{}</code>的初始化, 并且选择到了<code>explicit 构造函数头上</code>就会报错</p>
<p><code>explicit</code>可以防止在调用某个成员函数的时候, 实参类型(通过构造函数之一)自动转换成相应参数,<br>但此时这个函数需要其他的成员变量参与到函数运行, 恰巧这时所需要的其他成员变量没有得到合适的初始化, 就会发生错误(没有得到合适初始化的原因就是, 自动调用了不合适的构造函数生成了这个函数所需要的参数(一般是对象))</p>
<p>@2019年10月26日21:25:58@算是第一次解决一个环环相扣的问题, 精力有点不足了<br><a href="https://zhuanlan.zhihu.com/p/21102748" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21102748</a> 后续会继续进行理解<br><a href="https://blog.csdn.net/spaceyqy/article/details/22730939" target="_blank" rel="noopener">这里还发现一个</a></p>
<h1 id="模板-泛型-动态内存-数据结构"><a href="#模板-泛型-动态内存-数据结构" class="headerlink" title="模板, 泛型 动态内存, 数据结构"></a>模板, 泛型 动态内存, 数据结构</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">GetMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; GetMax(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; GetMax&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 显示指定模板类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/C%2B%2B%E5%86%85%E5%AD%98.png" alt=""><br>C++堆的内存需要手动new和delete, 如果一个对象new出来没有在能被释放的时候释放就会造成–<strong>内存泄漏</strong>(需要及时delete不需要的对象)<br>一个指向动态内存的指针, 在动态内存被释放后, 指针依然指向原来的地址–<strong>空悬指针</strong>(释放内存后将相应的指针设置为nullptr)</p>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png" alt=""></p>
]]></content>
        
        <categories>
            
            <category> CPP </category>
            
            <category> CPP基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[牛客整理]]></title>
        <url>http://blog.lsmg.xyz/2019/10/CPP-CPP%25E5%259F%25BA%25E7%25A1%2580-%25E7%2589%259B%25E5%25AE%25A2/</url>
        <content type="html"><![CDATA[<h1 id="运算出结果类"><a href="#运算出结果类" class="headerlink" title="运算出结果类"></a>运算出结果类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">200</span>;</span><br><span class="line">a+=<span class="number">27</span>;sum+=a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br></pre></td></tr></table></figure>
<p>a为 -128~127<br> 127  = 0111 1111<br>“128”= 1000 0000 (-128的补码)</p>
<p>关于1000 0000代表-128 我偶然发现一个博客有种恍然大悟的感觉<br><a href="https://blog.csdn.net/daiyutage/article/details/8575248" target="_blank" rel="noopener">浅析为什么char类型的范围是 —128~+127</a><br>这个博客实在是写的太好了</p>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a,b,c,d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c,%c,%d,%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c,%c,%c,%c"</span>,a,b,c,d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>%c进行输入会进行转化后存入<br>输入 1 即认为输入 ‘1’ 转换成49存入</p>
<hr>
<h1 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h1><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。<br>凡是含有纯虚函数的类叫做 抽象类 。这种类不能声明对象，只是作为基类为派生类服务.<br>除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</p>
<h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><p>静态成员可以作为默认实参</p>
<h1 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h1><h1 id="基础中的基础"><a href="#基础中的基础" class="headerlink" title="基础中的基础"></a>基础中的基础</h1><p>这部分有些只保留题目, 不做解析 便于自己想象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> k = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">while</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	--k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面三个函数全部错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char array[MAX_CHAR+1],i; &#x2F;&#x2F; 这个函数在于MAX_CHAR可能会大于255导致i永远无法达到</span><br><span class="line">    for(i&#x3D;0;i&lt;&#x3D;MAX_CHAR;i++)&#123;</span><br><span class="line">        array[i]&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">char*test2()</span><br><span class="line">&#123;</span><br><span class="line">    char p[] &#x3D; &quot;hello world&quot;;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">char *p &#x3D;test2();</span><br><span class="line">void test3()&#123;</span><br><span class="line">    char str[10];</span><br><span class="line">    str++;</span><br><span class="line">    *str&#x3D;&#39;0&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="基础中的Api"><a href="#基础中的Api" class="headerlink" title="基础中的Api"></a>基础中的Api</h1><p>虽然自己还没用过, 但还是要积累</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">4</span>;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'#'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始看到这个题目, 为putchar是放到缓冲区中, 结果就是正常的输出</p>
]]></content>
        
        <categories>
            
            <category> CPP </category>
            
            <category> CPP基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[MongoDB]]></title>
        <url>http://blog.lsmg.xyz/2019/10/CPP-%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593-MongoDB-MongoDB%25E5%259F%25BA%25E6%259C%25AC%25E4%25BD%25BF%25E7%2594%25A8/</url>
        <content type="html"><![CDATA[<p><img src="https://docs.mongodb.com/images/mongodb-logo.png" alt=""></p>
<a id="more"></a>

<h1 id="服务器相关"><a href="#服务器相关" class="headerlink" title="服务器相关"></a>服务器相关</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>在mongodb中基本的概念是文档、集合、数据库</p>
<ul>
<li>数据库<br>一个mongodb中可以建立多个数据库。</li>
<li>集合<br>集合就是 MongoDB 文档组 集合处于数据库中 文档处于集合中</li>
<li>文档<br>文档是一组键值(key-value)对(即 BSON)<br>文档对应数据记录的行</li>
</ul>
<h2 id="安装驱动到Centos"><a href="#安装驱动到Centos" class="headerlink" title="安装驱动到Centos"></a>安装驱动到Centos</h2><p><strong>升级cmake</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget https://cmake.org/files/v3.6/cmake-3.6.2.tar.gz    </span><br><span class="line">tar xvf cmake-3.6.2.tar.gz &amp;&amp; cd cmake-3.6.2/</span><br><span class="line">./bootstrap</span><br><span class="line"></span><br><span class="line">gmake</span><br><span class="line">gmake install（需要在su命令下执行，或者直接使用root账户安装）</span><br><span class="line">/usr/local/bin/cmake --version</span><br><span class="line"></span><br><span class="line">yum remove cmake -y</span><br><span class="line">ln -s /usr/local/bin/cmake /usr/bin/</span><br><span class="line">cmake --version</span><br></pre></td></tr></table></figure>
<p><strong>安装</strong></p>
<p><a href="http://mongoc.org/libmongoc/current/installing.html" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="安装驱动到Centos-1"><a href="#安装驱动到Centos-1" class="headerlink" title="安装驱动到Centos"></a>安装驱动到Centos</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br><span class="line"></span><br><span class="line">yum install clang</span><br><span class="line"></span><br><span class="line"># 安装boost</span><br><span class="line">yum -y install gcc-c++ python-devel bzip2-devel zlib-devel</span><br><span class="line">tar zxvf 安装包</span><br><span class="line">sudo .&#x2F;bootstrap.sh --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;boost</span><br><span class="line">sudo .&#x2F;b2 install</span><br><span class="line">进入 目录下的tools&#x2F;build</span><br><span class="line">sudo .&#x2F;bootstrap.sh</span><br><span class="line">sudo .&#x2F;b2 install --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;boost</span><br><span class="line"></span><br><span class="line">wget https:&#x2F;&#x2F;cmake.org&#x2F;files&#x2F;v3.5&#x2F;cmake-3.5.2.tar.gz</span><br><span class="line">tar -zxvf cmake-3.5.2.tar.gz</span><br><span class="line">cd cmake-3.5.2</span><br><span class="line">.&#x2F;bootstrap</span><br><span class="line">gmake</span><br><span class="line">gmake install</span><br><span class="line"></span><br><span class="line"># 删除原来cmake版本，建立软连接，测试</span><br><span class="line">yum remove cmake -y</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;cmake &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">cmake --version</span><br><span class="line"></span><br><span class="line"># 安装pip</span><br><span class="line">yum install python-pip</span><br><span class="line">pip install --upgrade pip</span><br><span class="line"></span><br><span class="line"># 安装py3</span><br><span class="line">https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000015628625</span><br></pre></td></tr></table></figure>

<h2 id="安装到Ubuntu-18-04"><a href="#安装到Ubuntu-18-04" class="headerlink" title="安装到Ubuntu 18.04"></a>安装到Ubuntu 18.04</h2><p><a href="https://docs.mongodb.com/manual/administration/install-on-linux/" target="_blank" rel="noopener">整理自官方文档</a></p>
<ul>
<li>导入公共秘钥, 另你的系统”信任”下面的包<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -</span><br></pre></td></tr></table></figure>
这一步需要显示OK</li>
<li>导入第三方MongoDB源<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list</span><br></pre></td></tr></table></figure></li>
<li>导入源之后更新<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li>
<li>安装MongoDB稳定版本包(我安装的时候稳定版本为4.2)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y mongodb-org=4.2.0 mongodb-org-server=4.2.0 mongodb-org-shell=4.2.0 mongodb-org-mongos=4.2.0 mongodb-org-tools=4.2.0</span><br></pre></td></tr></table></figure></li>
<li>禁用apt-get自动更新MongoDB<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo "mongodb-org hold" | sudo dpkg --set-selections</span><br><span class="line">echo "mongodb-org-server hold" | sudo dpkg --set-selections</span><br><span class="line">echo "mongodb-org-shell hold" | sudo dpkg --set-selections</span><br><span class="line">echo "mongodb-org-mongos hold" | sudo dpkg --set-selections</span><br><span class="line">echo "mongodb-org-tools hold" | sudo dpkg --set-selections</span><br></pre></td></tr></table></figure>
<h2 id="基础shell操作"><a href="#基础shell操作" class="headerlink" title="基础shell操作"></a>基础shell操作</h2></li>
</ul>
<p><strong>启动 关闭 重启</strong><br><code>sudo service mongod start(stop\restart)</code></p>
<p><em>启动成功标志</em><br>日志文件<code>/var/log/mongodb/mongod.log</code>中显示<code>waiting for connections on port 27017</code></p>
<p><strong>进入交互式命令行</strong><br><code>mongo</code></p>
<p><strong>指定端口运行 默认27017</strong><br><code>mongo --port 28015</code></p>
<p><strong>非安装机通过shell连接安装机</strong><br><a href="https://docs.mongodb.com/manual/mongo/#mongodb-instance-on-a-remote-host" target="_blank" rel="noopener">直连</a><br><a href="https://docs.mongodb.com/manual/mongo/#mongodb-instance-with-authentication" target="_blank" rel="noopener">带登录验证</a></p>
<hr>
<p><strong>显示你正在使用的数据库</strong><br><code>db</code><br><strong>切换数据库</strong><br><code>use &lt;database&gt;</code></p>
<h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><p><strong>C</strong></p>
<p><em>插入一个文档</em><br><code>db.collection.insertOne()</code><br>这里的collection代指的一个集合, 集合的名字可以自定义如果集合并不存在你的数据库中 则自动创建这个集合.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.insertOne(</span><br><span class="line">   &#123; item: "canvas", qty: 100, tags: ["cotton"]&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<hr>
<p><em>插入多个文档</em><br><code>db.inventory.insertMany()</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.insertMany([</span><br><span class="line">   &#123; item: "journal", qty: 25, tags: ["blank", "red"]&#125;,</span><br><span class="line">   &#123; item: "mat", qty: 85, tags: ["gray"]&#125;,</span><br><span class="line">   &#123; item: "mousepad", qty: 25, tags: ["gel", "blue"]&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<hr>
<p><em>插入任意项的文档</em><br><code>db.collection.insert()</code></p>
<hr>
<p><em>_id项</em><br>每一个文档都有自己独一的id 如果插入文档的时候没有指定则会生成随机的<code>_id</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; "_id" : ObjectId("5da325520e80dfd9258a29be"), "x" : 1 &#125;</span><br></pre></td></tr></table></figure>
<p>可以通过在插入的时候指定<code>&quot;_id&quot;: xxxx</code>来自定义id</p>
<p><a href="https://docs.mongodb.com/manual/reference/insert-methods/#additional-methods-for-inserts" target="_blank" rel="noopener">额外的方法</a></p>
<p><strong>R</strong><br><code>db.collection.find({ item: &quot;canvas&quot; })</code><br><a href="https://docs.mongodb.com/manual/core/document/#document-query-filter" target="_blank" rel="noopener">拦截器-</a>在collection中查找含有<code>item: &quot;canvas&quot;</code>的文档, 并打印<br>如果不含<code>{ item: &quot;canvas&quot; }</code>则代表打印所有的文档</p>
<p><code>db.collection.find({status: {$in: [ &quot;A&quot;, &quot;D&quot; ]}})</code><br><code>status: {$in: [ &quot;A&quot;, &quot;D&quot; ]}</code>意为A, D不在此status中</p>
<p><code>db.inventory.find( { status: &quot;A&quot;, qty: { $lt: 30 } } )</code><br><code>qty: { $lt: 30 }</code>意为此qty的值少于30</p>
<p><code>db.inventory.find( { $or: [ { status: &quot;A&quot; }, { qty: { $lt: 30 } } ] } )</code><br><code>{$or: [{ status: &quot;A&quot; }, { qty: { $lt: 30 }}]}</code>符合二者之一</p>
<p><a href="https://docs.mongodb.com/manual/tutorial/query-embedded-documents/" target="_blank" rel="noopener">2019年10月13日21:58:24 - 开头</a></p>
<h1 id="C-Driver"><a href="#C-Driver" class="headerlink" title="C++ Driver"></a>C++ Driver</h1><p><a href="http://mongocxx.org/mongocxx-v3/installation/" target="_blank" rel="noopener">照着官方文档安装了下</a><br>期间遇到了两个坑一个是我没有安装Git导致提示无法克隆<br>还有就是最后阶段我没安装pkg-config 导致的无法找到头文件</p>
<p>接下来看一些简单的教程</p>
<h2 id="CRUD-1"><a href="#CRUD-1" class="headerlink" title="CRUD"></a>CRUD</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bsoncxx/json.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mongocxx/client.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mongocxx/stdx.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mongocxx/uri.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bsoncxx/builder/stream/helpers.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mongocxx/instance.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bsoncxx/builder/stream/document.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::stream::close_array;</span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::stream::close_document;</span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::stream::document;</span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::stream::finalize;</span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::stream::open_array;</span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::stream::open_document;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> builder = document&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	bsoncxx::document::value doc_value = builder</span><br><span class="line">			&lt;&lt; <span class="string">"name"</span> &lt;&lt; <span class="string">"Lsmg"</span></span><br><span class="line">			&lt;&lt; <span class="string">"type"</span> &lt;&lt; <span class="string">"Lemon"</span></span><br><span class="line">			&lt;&lt; <span class="string">"count"</span> &lt;&lt; <span class="number">1</span></span><br><span class="line">			&lt;&lt; <span class="string">"versions"</span> &lt;&lt; open_array</span><br><span class="line">			&lt;&lt; <span class="string">"v3.2"</span> &lt;&lt; <span class="string">"v3.0"</span> &lt;&lt; <span class="string">"v2.6"</span></span><br><span class="line">			&lt;&lt; close_array</span><br><span class="line">			&lt;&lt; <span class="string">"info"</span> &lt;&lt; open_document</span><br><span class="line">			&lt;&lt; <span class="string">"x"</span> &lt;&lt; <span class="number">203</span></span><br><span class="line">			&lt;&lt; <span class="string">"y"</span> &lt;&lt; <span class="number">102</span></span><br><span class="line">			&lt;&lt; close_document</span><br><span class="line">			&lt;&lt; finalize;</span><br><span class="line"></span><br><span class="line">	bsoncxx::document::view view_test = doc_value.view();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印插入内容制定key的value</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> name = view_test[<span class="string">"name"</span>].get_utf8().value.to_string();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取插入ID</span></span><br><span class="line">	<span class="keyword">auto</span> result = coll_test.insert_one(view_test);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> id1 = result-&gt;inserted_id().get_oid().value.to_string();</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; id1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_many</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 插入多个</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;bsoncxx::document::value&gt; documents;</span><br><span class="line">	documents.reserve(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		documents.push_back(document&#123;&#125; &lt;&lt; <span class="string">"i"</span> &lt;&lt; i &lt;&lt; finalize);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">auto</span> result = coll_test.insert_many(documents);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取多个的返回ID</span></span><br><span class="line">	<span class="keyword">auto</span> id_maps = result-&gt;inserted_ids();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> iter : id_maps)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.second.get_oid().value.to_string() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 查询</span></span><br><span class="line">	mongocxx::<span class="built_in">cursor</span> <span class="built_in">cursor</span> = coll_test.<span class="built_in">find</span>(&#123;&#125;);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> doc : <span class="built_in">cursor</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bsoncxx::to_json(doc) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_one</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	coll_test.update_one(document&#123;&#125; &lt;&lt; <span class="string">"i"</span> &lt;&lt; <span class="number">9</span> &lt;&lt; finalize,</span><br><span class="line">			document&#123;&#125; &lt;&lt; <span class="string">"$set"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class="line">			<span class="string">"i"</span> &lt;&lt; <span class="number">110</span> &lt;&lt; close_document &lt;&lt; finalize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_many</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	coll_test.update_many(document&#123;&#125; &lt;&lt; <span class="string">"i"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class="line">					           <span class="string">"$lt"</span> &lt;&lt; <span class="number">8</span> &lt;&lt; close_document &lt;&lt; finalize,</span><br><span class="line">			document&#123;&#125; &lt;&lt; <span class="string">"$inc"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class="line">					           <span class="string">"i"</span> &lt;&lt; <span class="number">100</span> &lt;&lt; close_document &lt;&lt; finalize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_one</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	coll_test.delete_one(document&#123;&#125; &lt;&lt; <span class="string">"i"</span> &lt;&lt; <span class="number">110</span> &lt;&lt; finalize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_many</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 删除存在 i： 0 的文档</span></span><br><span class="line">	coll_test.delete_many(document&#123;&#125; &lt;&lt; <span class="string">"i"</span> &lt;&lt; <span class="number">0</span> &lt;&lt; finalize);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * (&gt;) 大于 - $gt</span></span><br><span class="line"><span class="comment">	 * (&lt;) 小于 - $lt</span></span><br><span class="line"><span class="comment">	 * (&gt;=) 大于等于 - $gte</span></span><br><span class="line"><span class="comment">	 * (&lt;= ) 小于等于 - $lte</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除 i大于3小于8的文档</span></span><br><span class="line">	coll_test.delete_many(document&#123;&#125; &lt;&lt; <span class="string">"i"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class="line">	                                 <span class="string">"$gt"</span> &lt;&lt; <span class="number">0</span> &lt;&lt;</span><br><span class="line">	                                 <span class="string">"$lt"</span> &lt;&lt; <span class="number">200</span> &lt;&lt;</span><br><span class="line">	                                 close_document &lt;&lt; finalize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_index</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1 代表生序 -1代表降序</span></span><br><span class="line">	<span class="keyword">auto</span> index_specification = document&#123;&#125; &lt;&lt; <span class="string">"i"</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; finalize;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// move的本质就是帮助编译器选择重载函数, 告诉编译器"请尽量把此参数当做右值来处理"</span></span><br><span class="line">	coll_test.create_index(<span class="built_in">std</span>::<span class="built_in">move</span>(index_specification));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	mongocxx::instance instance&#123;&#125;;</span><br><span class="line">	mongocxx::client client&#123;mongocxx::uri&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">	mongocxx::database db = client[<span class="string">"mydb"</span>];</span><br><span class="line">	mongocxx::collection coll_test = db[<span class="string">"test"</span>];</span><br><span class="line"></span><br><span class="line">	create_index(coll_test);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">find</span>(coll_test);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线程安全相关"><a href="#线程安全相关" class="headerlink" title="线程安全相关"></a>线程安全相关</h2><p>不能同时对一个client的多个线程同时操作.<br>同时只能有一个线程对一个client操作, 包括对<code>mongocxx::client</code>的<code>mongocxx::client_session</code>, <code>mongocxx::database, mongocxx::collection</code>, and <code>mongocxx::cursor</code>同样如此</p>
<p>简单解决可以通过用同一个<code>mongocxx::uri</code>生成多个<code>mongocxx::client</code>来解决这个问题</p>
<p>最好的解决方法用<code>mongocxx::uri</code>生成一个<code>mongocxx::pool</code> 通过<code>mongocxx::pool</code>的<code>acquire()</code>来获取操作的client<br>官方demo如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mongocxx::instance instance&#123;&#125;;</span><br><span class="line">mongocxx::pool pool&#123;mongocxx::uri&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> threadfunc = [](mongocxx::client&amp; client, <span class="built_in">std</span>::<span class="built_in">string</span> dbname) &#123;</span><br><span class="line">  <span class="keyword">auto</span> col = client[dbname][<span class="string">"col"</span>].insert_one(&#123;&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Great! Using the pool allows the clients to be synchronized while sharing only one</span></span><br><span class="line"><span class="comment">// background monitoring thread.</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span> <span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">auto</span> c = pool.acquire();</span></span></span><br><span class="line"><span class="function"><span class="params">  threadfunc(*c, <span class="string">"db1"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  threadfunc(*c, <span class="string">"db2"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span> <span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">auto</span> c = pool.acquire();</span></span></span><br><span class="line"><span class="function"><span class="params">  threadfunc(*c, <span class="string">"db2"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  threadfunc(*c, <span class="string">"db1"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br></pre></td></tr></table></figure>

<p>关于fork的安全性<br><code>Neither a mongocxx::client or a mongocxx::pool can be safely copied when forking. Because of this, any client or pool must be created after forking, not before.</code></p>
<p>官方建议使用<code>mongocxx::pool</code>而不是<code>mongocxx::client</code> 即使你的应用只有一个线程<br><code>mongocxx::client</code> 每60S会检查一次自己监控的cluster, 使用前者会有专门的线程来进行检查而且是10S一次</p>
<p><code>mongocxx::pool</code>可以用于多线程中, 也能用来创建客户端. 然而每个<code>mongocxx::client</code>只能被一个线程使用<code>最大默认为100 最小默认为0</code></p>
<h2 id="BSON"><a href="#BSON" class="headerlink" title="BSON"></a>BSON</h2><p><strong>Document Builders</strong><br>一共提供了三个接口来创建文档<br>官网上提到<code>这三个接口会得到同样的结果, 选择哪个完全是由于美学</code></p>
<p><em>“One-off” builder functions</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> bsoncxx::builder::basic::kvp;</span><br><span class="line"><span class="comment">// &#123; "hello": "world" &#125;</span></span><br><span class="line">bsoncxx::document::value document = bsoncxx::builder::basic::make_document(kvp(<span class="string">"hello"</span>, <span class="string">"world"</span>));</span><br></pre></td></tr></table></figure>

<p><em>Basic builder</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> bsoncxx::builder::basic::kvp;</span><br><span class="line"><span class="comment">// &#123; "hello" : "world" &#125;</span></span><br><span class="line">bsoncxx::builder::basic::document basic_builder&#123;&#125;;</span><br><span class="line">basic_builder.append(kvp(<span class="string">"hello"</span>, <span class="string">"world"</span>));</span><br><span class="line">bsoncxx::document::value document = basic_builder.extract();</span><br><span class="line"></span><br><span class="line"><span class="comment">// basic::document builds a BSON document.</span></span><br><span class="line"><span class="keyword">auto</span> doc = builder::basic::document&#123;&#125;;</span><br><span class="line"><span class="comment">// 通过使用kvp(k, v) 来 append 键值对 to a document </span></span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::basic::kvp;</span><br><span class="line"></span><br><span class="line">doc.append(k, v); <span class="comment">// 插入一般的键值对</span></span><br><span class="line"><span class="comment">// 对于k一般为string</span></span><br><span class="line"><span class="comment">// 对于v则包含多种情况 可以使用 bsoncxx::types命名空间里的如下类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_eod</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_double</span>;</span> <span class="comment">// types::b_double&#123;3.14159&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_utf8</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_document</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_array</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_binary</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_undefined</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_oid</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_bool</span>;</span> <span class="comment">// types::b_bool&#123;false&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_date</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_null</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_regex</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_dbpointer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_code</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_symbol</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_codewscope</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_int32</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_timestamp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_int64</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_decimal128</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_minkey</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_maxkey</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入k v (v是数组)</span></span><br><span class="line">arr.append(<span class="string">"hello"</span>);</span><br><span class="line">arr.append(<span class="literal">false</span>, types::b_bool&#123;<span class="literal">true</span>&#125;, types::b_double&#123;<span class="number">1.234</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can get a view of the resulting bson by calling view()</span></span><br><span class="line"><span class="keyword">auto</span> v = doc.view();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use 'v' so we don't get compiler warnings.</span></span><br><span class="line"><span class="keyword">return</span> v.empty() ? EXIT_FAILURE : EXIT_SUCCESS;</span><br></pre></td></tr></table></figure>

<p><em>Stream builder</em><br>我现在最喜欢的方法, 不过官方不建议这样, 因为需要保持这个流不被重新初始化, 这样在跨行生成的时候有困难.<br>官方建议使用上面的两个方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; "hello" : "world" &#125;</span></span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::stream;</span><br><span class="line">bsoncxx::document::value document = stream::document&#123;&#125; &lt;&lt; <span class="string">"hello"</span> &lt;&lt; <span class="string">"world"</span> &lt;&lt; stream::finalize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此外还有</span></span><br><span class="line"><span class="keyword">using</span> builder::stream::open_document; <span class="comment">// &#123;</span></span><br><span class="line"><span class="keyword">using</span> builder::stream::close_document;<span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">using</span> builder::stream::open_array; <span class="comment">// [</span></span><br><span class="line"><span class="keyword">using</span> builder::stream::close_array;<span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<p><strong>Building arrays</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> elements = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> array_builder = bsoncxx::builder::basic::<span class="built_in">array</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element : elements) &#123;</span><br><span class="line">    array_builder.append(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过使用lambda来构建 k, v (v是数组)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; "foo" : [ 1, 2, 3 ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::basic::kvp;</span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::basic::sub_array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> elements = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> doc = bsoncxx::builder::basic::document&#123;&#125;;</span><br><span class="line">doc.append(kvp(<span class="string">"foo"</span>, [&amp;elements](sub_array child) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element : elements) &#123;</span><br><span class="line">        child.append(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>通过使用流来生成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; "subdocs" : [ &#123; "key" : 1 &#125;, &#123; "key" : 2 &#125;, &#123; "key" : 3 &#125; ], "another_key" : 42 &#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> bsoncxx;</span><br><span class="line"></span><br><span class="line">builder::stream::document builder&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> in_array = builder &lt;&lt; <span class="string">"subdocs"</span> &lt;&lt; builder::stream::open_array;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; e : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">    in_array = in_array &lt;&lt; builder::stream::open_document &lt;&lt; <span class="string">"key"</span> &lt;&lt; e</span><br><span class="line">                        &lt;&lt; builder::stream::close_document;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> after_array = in_array &lt;&lt; builder::stream::close_array;</span><br><span class="line"></span><br><span class="line">after_array &lt;&lt; <span class="string">"another_key"</span> &lt;&lt; <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">document::value doc = after_array &lt;&lt; builder::stream::finalize;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; to_json(doc) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
        
        <categories>
            
            <category> CPP </category>
            
            <category> 数据库 </category>
            
            <category> MongoDB </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[Linux-菜鸟入门]]></title>
        <url>http://blog.lsmg.xyz/2019/10/Linux-%25E8%258F%259C%25E9%25B8%259F%25E5%2585%25A5%25E9%2597%25A8/</url>
        <content type="html"><![CDATA[<p>如果写起来C++有点不想写的话, 就来学一点Linux 日常中也是能用到. 这次先选择一个简单的网址来学习了<br><a href="https://www.zhihu.com/question/30328004/answer/751243297" target="_blank" rel="noopener">网址推荐的知乎问答</a><br><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/01_use_man.html" target="_blank" rel="noopener">学习网页</a></p>
<a id="more"></a>

<h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><p>这部分是我之前整理的一些, 整合到这里</p>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">du -s .&#x2F;*	# 查看当前目录的占比</span><br><span class="line"></span><br><span class="line">		19M	.&#x2F;bin</span><br><span class="line">		4.0K	.&#x2F;etc</span><br><span class="line">		4.0K	.&#x2F;games</span><br><span class="line">		40K	.&#x2F;include</span><br><span class="line">		98M	.&#x2F;lib</span><br><span class="line">		55M	.&#x2F;lib64</span><br><span class="line">		7.8M	.&#x2F;libexec</span><br><span class="line">		132K	.&#x2F;local</span><br><span class="line">		24M	.&#x2F;sbin</span><br><span class="line">		182M	.&#x2F;share</span><br><span class="line">		12K	.&#x2F;src</span><br><span class="line">		0	.&#x2F;tmp</span><br></pre></td></tr></table></figure>
<p><strong>vi</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">打开文件</span><br><span class="line">vi /path/to/somefile</span><br><span class="line">vi +#4 :打开文件，并定位于第#4行 </span><br><span class="line">vi + 打开文件，定位至最后一行</span><br><span class="line">vi +/PATTERN : 打开文件，定位至第一次被PATTERN匹配到的行的行首</span><br><span class="line"></span><br><span class="line">关闭文件</span><br><span class="line">:q! 不保存并退出  动过了，后悔了</span><br><span class="line">shift + zz 或直接两个大写Z: 保存并退出   不需要冒号，编辑模式</span><br><span class="line"></span><br><span class="line">移动</span><br><span class="line">f b 翻屏</span><br><span class="line">n ? 查找上一个下一个	</span><br><span class="line">w 下一个单词词首</span><br><span class="line">0 绝对行首 $绝对行位 ^首字符</span><br></pre></td></tr></table></figure>
<p>** 限**</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useradd lsmg001</span><br><span class="line">groupadd lsmg</span><br><span class="line"></span><br><span class="line">chown root:lsmg share # chown + 拥有者 + : + 拥有组 + 目录</span><br><span class="line">chmod o-rx share # chmod u(用户)g(组)o(其他人) + wrx </span><br><span class="line">可以用数字代表 wrx 4 2 1 最多为7代表wrx</span><br></pre></td></tr></table></figure>

<p><strong>镜像更改</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;opsx.alibaba.com&#x2F;mirror?lang&#x3D;zh-CN</span><br></pre></td></tr></table></figure>

<h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><ol>
<li><code>etc/sysconfig/network-scripts/</code></li>
</ol>
<p>ifcfg-eth0 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0</span><br><span class="line"><span class="meta">#</span><span class="bash">HWADDR=00:0C:29:78:06:E4 <span class="comment"># 需要注释掉, 因为克隆虚拟机的时候mac地址会改变而文件不会改变, 导致两者不同</span></span></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">UUID=effa4a9a-0ca5-414b-95c1-516a3b9f1d5d</span><br><span class="line">ONBOOT=yes	# 默认此网卡为关闭状态, linux是能关的功能就是关闭的</span><br><span class="line">NM_CONTROLLED=yes</span><br><span class="line">BOOTPROTO=static # 更改为静态方式, 需要配置以下四个选项</span><br><span class="line">IPADDR=192.168.9.31 # 需要在vm的地址段内 编辑-映射虚拟-NAT模式-子网ip</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.9.2</span><br><span class="line">DNS1=114.114.114.114</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>在 <code>etc/sysconfig</code> 中有一个network文件, </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">HOSTNAME=node0001</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>/etc/</code>中的hosts文件可以修改映射</p>
</li>
<li><p>需要删除<code>/etc/udev/rules.d/70-persistent-net.rules</code>文件</p>
</li>
<li><p>关闭防火墙</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">servcie iptables stop                     --临时关闭防火墙</span><br><span class="line">chkconfig iptables off                    --永久关闭防火墙</span><br></pre></td></tr></table></figure></li>
<li><p><code>vi /etc/selinux/config</code> 将SELINUX改为disabled</p>
</li>
</ol>
]]></content>
        
        <categories>
            
            <category> Linux </category>
            
            <category> 入门学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[UNIX环境高级编程读书记录]]></title>
        <url>http://blog.lsmg.xyz/2019/09/CPP-Linux-UNIX%25E7%258E%25AF%25E5%25A2%2583%25E9%25AB%2598%25E7%25BA%25A7%25E7%25BC%2596%25E7%25A8%258B%25E8%25AF%25BB%25E4%25B9%25A6%25E8%25AE%25B0%25E5%25BD%2595/</url>
        <content type="html"><![CDATA[<h1 id="第一章-UNIX基础知识"><a href="#第一章-UNIX基础知识" class="headerlink" title="第一章-UNIX基础知识"></a>第一章-UNIX基础知识</h1><p>上一本书的学习暂时告一段落了. 剩下了框架多线程一级多进程部分<br>这些等我socket编程扎实后继续学习了</p>
<p>这本书浏览了一下目录, 前边是一些关于Linux的基础知识<br>然后是文件IO部分, 文件和目录<br>其次是讲解标准IO库<br>系统信息, 进程以及进程的控制进程的关系<br>信号<br>终端IO, 高级IO<br>精灵进程, 进程间通信, 高级进程间通信<br>后面的一些章节- 数据库, 打印机?, 一个demo拨号器, 伪终端</p>
<p>这本书感觉更加照顾了系统方面的基础知识以及讲解了IO部分, 接下来好几章介绍了进程间的操作<br>最后举出了例子</p>
<a id="more"></a>

<ul>
<li><p><strong>文件描述符</strong><br>  小的非负整数, 内核用以标识一个特定进程正在存访的文件</p>
</li>
<li><p><strong>标准输入输出和出错</strong><br>  新打开的程序存在这三个描述符分别是 0 1 2</p>
<p>  位于<code>unistd.h</code> 头文件中 定义了两个常数<code>STDIN_FILENO</code></p>
</li>
<li><p><strong>无缓存I/O</strong><br>  open, read, write, lseek, close 提供了不需要缓存的I/O, 均使用文件描述符工作</p>
</li>
</ul>
<p>类属指针<br>read和write的第二个参数都是<code>void*</code>  用来代替早期大部分的<code>char*</code></p>
<p>原始系统数据类型<br><code>POSIX</code>中的新规定, 以<code>_t</code>结尾的数据类型被称为<code>原始系统类型</code>, 通常在头文件 <code>&lt;sys/types.h&gt;</code>中</p>
<p>出错处理, 这里发现一个新的Api</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以前都是使用如下的, 将ERRNO转化为错误信息, 再打印</span></span><br><span class="line">strerror()</span><br><span class="line"><span class="comment">// 这个可以一步到位, 输出msg + ": " + errno对应的错误值</span></span><br><span class="line">perror(<span class="keyword">char</span>* msg)</span><br></pre></td></tr></table></figure>

<p>组ID<br>每个文件包含文件所有者的用户ID和组ID, 存放着两个只需要四个字节, 如果直接存储ID名称会需要更多的磁盘空间<br>所以存在一个口令文件, 包含登录名和用户ID之间的关系<br>存在组文件, 包含了组名和组ID直接的映射关系.<br>一个用户最多可属于16个另外的组</p>
<p>信号<br>处理信号的三种方式: 忽略, 按默认方法处理, 提供函数<br>信号的产生: 键盘中断键(Delete, Ctrl-C)和退出键(Ctrl-) 用于中断当前运行的进程</p>
<p>UNIX时间值</p>
<ul>
<li>日历时间, 自1970-1-1-00-00-00 以来的UTC所经过的秒数</li>
<li>进程时间, 以滴答时钟计算</li>
</ul>
<p>习题<br>1.1 <code>cd ..</code> 切换到父目录, <code>cd .</code>本目录, 无实际意义?</p>
<h1 id="第二章-UNIX标准化及实现"><a href="#第二章-UNIX标准化及实现" class="headerlink" title="第二章-UNIX标准化及实现"></a>第二章-UNIX标准化及实现</h1><h1 id="第三章-文件I-O"><a href="#第三章-文件I-O" class="headerlink" title="第三章-文件I/O"></a>第三章-文件I/O</h1><h2 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Open FILE and return a new file descriptor for it, or -1 on error.</span></span><br><span class="line"><span class="comment"> * OFLAG determines the type of access used.  </span></span><br><span class="line"><span class="comment"> * 0 - O_RDONLY - 只读打开</span></span><br><span class="line"><span class="comment"> * 1 - O_WRONLY - 只写打开</span></span><br><span class="line"><span class="comment"> * 2 - O_RDWR 读写打开</span></span><br><span class="line"><span class="comment"> * O_APPEND 每次写文件加到文件的尾端</span></span><br><span class="line"><span class="comment"> * O_CREAT 此文件不存在则创建</span></span><br><span class="line"><span class="comment"> * O_EXCL 如果同时指定了 O_CREAT, 且文件已经存在则会出错.如果不存在则创建此文件成为一个原子操作</span></span><br><span class="line"><span class="comment"> * O_TRUNC 如果文件存在, 而且为只读或只写成功打开, 则将其长度截断为0(测试了一下, 文件内容清空.....)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__file, <span class="keyword">int</span> __oflag, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 成功返回fd, 失败-1, 这个函数已经可以被open替换了*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__file, <span class="keyword">mode_t</span> __mode)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/* Close the file descriptor FD.*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> __fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* __whence的参数如下</span></span><br><span class="line"><span class="comment"> *  -SEEK_SET  __offset 为距离文件开始处的字节数</span></span><br><span class="line"><span class="comment"> *  -SEEK_CUR __offset 为距离当前字节 可正可负</span></span><br><span class="line"><span class="comment"> *  -SEEK_END __offset 为文件长度+offset 可正可负</span></span><br><span class="line"><span class="comment"> * 成功返回新的文件偏移量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function"><span class="keyword">__off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> __fd, <span class="keyword">__off_t</span> __offset, <span class="keyword">int</span> __whence)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> <span class="comment">/* Read NBYTES into BUF from FD.  Return the</span></span></span><br><span class="line"><span class="function"><span class="comment">  * number read, -1 for errors or 0 for EOF.</span></span></span><br><span class="line"><span class="function"><span class="comment">  * 可以一次读取/写入 65534个字节</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"> <span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> __fd, <span class="keyword">void</span> *__buf, <span class="keyword">size_t</span> __nbytes)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"> <span class="comment">/* Write N bytes of BUF to FD.  Return the number written, or -1.</span></span></span><br><span class="line"><span class="function"><span class="comment">  * 出错的常见原因, 磁盘已经写满, 或超出一个给定进程的文件长度限制</span></span></span><br><span class="line"><span class="function"><span class="comment">  * 从文件seek处开始</span></span></span><br><span class="line"><span class="function"><span class="comment">  */</span></span></span><br><span class="line"><span class="function"> <span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> __fd, <span class="keyword">const</span> <span class="keyword">void</span> *__buf, <span class="keyword">size_t</span> __n)</span></span></span><br></pre></td></tr></table></figure>
<p>@fcntl@</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cmd</span></span><br><span class="line"><span class="comment">//	- F_DUPED 复制一个现有的文件描述符</span></span><br><span class="line"><span class="comment">//	- F_GETFD F_SETFD</span></span><br><span class="line"><span class="comment">//	- F_GETFL F_SETFL 获得/设置文件状态标志</span></span><br><span class="line"><span class="comment">//	- F_GETOWN F_SETOWN 获得/设置异步I/O记录</span></span><br><span class="line"><span class="comment">//	- F_GETLK  F_SETLOCK F_SETLKW 获得/设置记录锁</span></span><br><span class="line"><span class="comment">// 操作出错返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="函数描述"><a href="#函数描述" class="headerlink" title="函数描述"></a>函数描述</h2><p><strong>read</strong></p>
<p>起初我的代码如下, 想要测试下文件的写和读, 结果发现无论如何也读不到内容, 然后 加入了新的open发现可以读到.<br>查阅了一番并没有找到结果, 发现在本书后方就讲述了 <code>lseek()</code> 函数才了解到<code>每个打开的文件都有一个相关联的&quot;当前文件位移量&quot;</code> 后来查阅了解到每次<code>read()</code>和<code>write()</code> 这个”指针”都会向后移动, 两函数共用同一个指针.</p>
<p>收获就是<code>理解不了的东西, 应该先记录下来, 多学学没准就回了</code>, 而且我在重新open之后文件能够正常读到内容.<br>问题就应该定位在<code>write()</code>修改了什么东西导致的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">open</span>(<span class="string">"/home/lsmg/CLionProjects/BookDemo/test001"</span>, O_RDWR);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* out = <span class="string">"Test0001\n"</span>;</span><br><span class="line"><span class="built_in">write</span>(ret, out, <span class="built_in">strlen</span>(out));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ret = open("/home/lsmg/CLionProjects/BookDemo/test001", O_RDWR);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lseek(ret, 0, SEEK_SET);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span>(ret, buf, <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>lseek</strong></p>
<p>函数开头的L字母代表表示长整型</p>
<p>可以用如下方式获得当前文件的偏移量位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span> currpos = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br></pre></td></tr></table></figure>
<p>这个方法还可以用来确定所涉及的文件是否可以设置偏移量, 如果fd是一个管道或FIFO则返 -1, <code>errno = EPIPE</code></p>
<p><strong>I/O的效率</strong></p>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E4%B8%8D%E5%90%8C%E7%BC%93%E5%AD%98%E9%95%BF%E5%BA%A6%E8%BF%9B%E8%A1%8C%E8%AF%BB%E6%93%8D%E4%BD%9C.png" alt=""></p>
<p><strong>文件共享</strong><br>UNIX支持在不同进程之间共享打开文件<br>内核使用了三种数据结构</p>
<ol>
<li>每个进程在进程表中都有一个记录项, 每个记录项中有一张<code>打开文件描述符表</code>, 与每个文件描述符相关联的是<ul>
<li>文件描述符标志(<code>只用于一个进程的一个描述符</code>)</li>
<li>指向一个文件表项的指针</li>
</ul>
</li>
<li>内核为所有打开文件维持一张文件表<ul>
<li>文件状态表(读 写 增写) (<code>用于指向该给定文件表项的任何进程的所有描述符</code>)</li>
<li>当前文件位移量</li>
<li>指向该文件V节点表项的指针</li>
</ul>
</li>
<li>每个打开文件(或设备)都有一个V节点结构. V节点结构包含了文件类型和对此文件进行各种操作的函数的指针信息.</li>
</ol>
<p>三者之间的关系<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt=""></p>
<p>这三张表的关系, 会用于不同进程间共享文件的方式.</p>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E4%B8%A4%E4%B8%AA%E7%8B%AC%E7%AB%8B%E8%BF%9B%E7%A8%8B%E5%90%84%E8%87%AA%E6%89%93%E5%BC%80%E5%90%8C%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6.png" alt=""></p>
<ul>
<li>进行<code>write()</code>操作后, 文件表项中的当前文件偏移量即增加所写的字节数.<br>如果这个操作使当前文件位移量超过了当前文件长度, 则在<code>I节点表项中的当前文件长度</code>被设置为<code>当前文件位移量</code>(也就是该文件加长了).</li>
<li>如果用O_APPEND打开了一个文件, 则相应标志也被设置到文件表项的<code>文件状态标志</code>(标记这个属性).<br>每次进行文件写操作, 文件表项中的<code>当前文件位移量</code>首先被设置为<code>i节点</code>表项的文件长度, 这样就写到了文件尾部</li>
<li><code>lseek()</code>只修改文件表中的<code>当前文件位移量</code> 没有进行I/O操作</li>
<li>若一个文件用<code>lseek</code>被定为到文件当前的尾端, 则<code>文件表项中</code>的<code>当前文件位移量</code>被设置为<code>i节点表项</code>中的<code>当前文件长度</code>.</li>
</ul>
<p>多个进程读一个文件可以正常工作<br>但是多个文件写同一个文件, 可能产生各种问题. 需要通过原子操作解决</p>
<p><strong>原子操作</strong><br>早期UNIX不支持OPEN的<code>O_APPEND</code><br>需要使用<code>lessk()</code>和<code>write</code>共同完成任务, 由于是两个函数, 可能会被分开执行<br>现在可以通过对<code>open</code>指定<code>O_APPEND</code>来实现</p>
<p><strong>@fcntl@</strong></p>
<ul>
<li>F_DUPFD<br>  复制文件描述符, 新文件描述符作为返回值返回. 返回值为尚未打开的文件描述符中 &gt;= 第三个参数 的最小值.<br>  新文件描述符与原fd共享同一个文件表项, 但文件描述符标志各自分离.</li>
<li>F_GETFD<br>  对应fd的文件描述符作为函数值返回</li>
<li>F_SETFD<br>  对fd设置文件描述符标志, 新标志未第三个参数设置</li>
<li>F_GETFL<br>  对应fd的文件状态标志作为函数值返回, 上文提到过文件状态标志(见open函数 的参数)</li>
<li>F_SETFL<br>  将文件状态标志位设置为第三个参数的值 (O_APPEND, O_NONBLOCK, O_SYNC和O_ASYNC)</li>
</ul>
<h1 id="第四章-文件和目录"><a href="#第四章-文件和目录" class="headerlink" title="第四章 文件和目录"></a>第四章 文件和目录</h1><h1 id="第五章-标准I-O库"><a href="#第五章-标准I-O库" class="headerlink" title="第五章 标准I/O库"></a>第五章 标准I/O库</h1><h2 id="Api-1"><a href="#Api-1" class="headerlink" title="Api"></a>Api</h2><p>@setbuf@<br>@setvbuf@</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 关闭或打开缓存机制, buf必须指向一个长度为BUFSIZ的缓存(定义在stdio.h的常量), 通常这样操作后该流</span></span><br><span class="line"><span class="comment">// 是全缓存, 但如果该流与一个终端设备相关, 也可以设置为行缓存.</span></span><br><span class="line"><span class="comment">// 如果需要关闭缓存可以将buf设置为NULL</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE* fp, <span class="keyword">char</span>* buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mode参数如下</span></span><br><span class="line"><span class="comment">// -_IOFBF 全缓存 </span></span><br><span class="line"><span class="comment">// -_IOLBF 行缓存</span></span><br><span class="line"><span class="comment">// -_IONBF 不带缓存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE* fp, <span class="keyword">char</span>* buf, <span class="keyword">int</span> mode, <span class="keyword">sizt_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/setbuf%E5%92%8Csetvbuf%E5%87%BD%E6%95%B0.png" alt=""></p>
<p>@fflush@</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入一个流并刷新这个流 如果传入NULL则会刷新所有的流</span></span><br><span class="line">fflush(FILE* fp);</span><br></pre></td></tr></table></figure>
<p>@fopen@@freopen@@fdopen@</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开由pathname指定的文件, 返回这个流</span></span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 流fp上打开pathname 指定的文件, 如果这个流已经带打开则会先关闭这个流. 一般用于将一个指定文件打开为一个预定义的流: 标准输入标准输入或标准出错.</span></span><br><span class="line"><span class="function">FILE* <span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* type, FILE* fp)</span></span>;</span><br><span class="line"><span class="comment">// 取一个现存的文件描述符, 并令一个标准的I/O流与之结合</span></span><br><span class="line"><span class="comment">// 常用于创建管道和网络通信通道函数获得的描述符, 因为这些特殊文件不能用fopen打开</span></span><br><span class="line"><span class="function">FILE* <span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type有15种取值</span></span><br><span class="line">r rb 只读</span><br><span class="line">w wb 使文件成为<span class="number">0</span>长, 或为写而创建</span><br><span class="line">a ab 为在文件尾写 或为写而创建</span><br><span class="line"></span><br><span class="line">r+ r+b rb+ 读和写</span><br><span class="line">w+ w+b wb+ 使文件成为<span class="number">0</span>长, 或为读和写而创建</span><br><span class="line">a+ a+b ab+ 为在文件尾读和写而创建或打开</span><br></pre></td></tr></table></figure>
<p>@exit@</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exit函数会刷新任何未写的数据, 然后关闭所有打开的流</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span> <span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="流的打开关闭和读写"><a href="#流的打开关闭和读写" class="headerlink" title="流的打开关闭和读写"></a>流的打开关闭和读写</h2><p><strong>流和FILE对象</strong><br>所有的I/O操作都是针对文件描述符的. 打开一个文件即返回一个文件描述符. </p>
<p>标准I\O提供了三种类型的缓存</p>
<ul>
<li>全缓存, 当标准I/O填满后才进行实际操作, 可以用刷新(<code>fflush()</code> 来刷新对应的流)</li>
<li>行缓存, 在输入和输入遇到换行符是执行IO操作<br>如果在遇到换行符前缓冲区已满则会进行IO操作<br>还有一个没读懂, 意思是行缓存可能被<code>fflush()</code>刷新 ????? 待试验</li>
<li>不带缓存, </li>
</ul>
<p><strong>流的打开和关闭</strong><br>在查看流的打开的源码的时候<br>发现两个东西记录一下吧</p>
<ul>
<li>下划线开头的命名<br>以单下划线 _ 表明是标准库的变量<br>双下划线 __ 开头表明是编译器的变量</li>
<li>restrict<br><a href="https://en.cppreference.com/w/c/language/restrict" target="_blank" rel="noopener">来自cppreference.com</a><br>用restrict修饰的说明这个指针指向的区域没有另一个指针指向</li>
</ul>
<p>指定w或a类型创建文件的时候 无法说明该文件的存取许可权位<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86IO%E6%B5%81%E7%9A%84%E5%85%AD%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%96%B9%E5%BC%8F.png" alt=""></p>
<p>可以使用<code>fclose(FILE* fp)</code>关闭一个打开的流</p>
<p><strong>读和写流</strong><br>流被打开之后, 可以从三种不同类型的非格式化I/O中进行选择, 对其进行读和写操作<br>(格式化I/O函数, printf和scanf)</p>
<ul>
<li>每次一个字符的I/O</li>
<li>每次一行的I/O fgets和fputs 一次读或者写一行 fgets需要说明最大的行长</li>
<li>直接I/O(又称为二进制I/O, 一次一个对象I/O 面向记录/结构的IO) fread和fwrite支持这种类型的I/O 常用与从二进制文件读或写一个结构</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下三个函数成功则返回读取到的字符, 如果读取到文件尾部或者出错则为EOF(一个定义好的常量)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是一个宏 工作效率更高</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="comment">// 是一个函数, 所以能得到函数的地址 所以可以将fgetc的地址作为参数传送给另一个函数</span></span><br><span class="line"><span class="comment">// 极大可能慢于getc, 函数调用慢于宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>由于上面三个函数在读取到文件尾部或者出错都为同一个返回值, 所以需要使用其他函数来区分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两个函数为真返回非0, 否则为0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="comment">// 大多数FILE对象, 每个流保持了两个标志 出错标志和文件结束标志</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在从一个流读取之后, 可以将字符送回流中<br>送回到流中的字符还可以再次读出, 但读出的字符顺序和送回的顺序相反<br>EOF不能回送 但读取到达文件尾部后仍可以回送一个字符, 下次读将返回这个字符 再次读则为EOF</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>输出函数 putc, fputc, putchar 三个函数相似三个输入函数</p>
<p><em>每次一行的I/O</em><br>I</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从标准读读入 不推荐使用, 无法指定最大长度 可能会造成缓冲区溢出. 缓冲区中不包含换行符</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">gets</span><span class="params">(<span class="keyword">char</span>* buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从指定流读入, 最大读取长度为 n-1(其中包含 换行符) 缓冲区中包含换行符</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fgets</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">int</span> n, FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>O    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">null符号 不等于 换行符</span><br><span class="line"><span class="comment">// 将一个以null符终止的字符串写到标准输出, 终止符不写出但是 此函数会自己写出一个换行符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, FILE* fp)</span></span>;</span><br><span class="line"><span class="comment">// 将一个以null符终止的字符串写到指定的流, 终止符不写出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>二进制I/O</strong></p>
<p><em>api</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>, FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// nobj为要写的对象数</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nobj, FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>写了一个例子 结果察看1文件的 二进制代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">birthday</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> year;</span><br><span class="line">	<span class="keyword">int</span> month;</span><br><span class="line">	<span class="keyword">int</span> day;</span><br><span class="line">	<span class="keyword">int</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	birthday b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">	FILE* fp = fopen(<span class="string">"/home/lsmg/1"</span>, <span class="string">"r+"</span>);</span><br><span class="line">	<span class="keyword">if</span> (fwrite(&amp;b, <span class="keyword">sizeof</span>(birthday), <span class="number">1</span>, fp) != <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"error\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0000000</span> <span class="number">0001</span> <span class="number">0000</span> <span class="number">0002</span> <span class="number">0000</span> <span class="number">0003</span> <span class="number">0000</span> <span class="number">0004</span> <span class="number">0000</span></span><br><span class="line"><span class="number">0000010</span></span><br></pre></td></tr></table></figure>
<p>可能存在的问题</p>
<ul>
<li>同一成员的偏移量可能不同</li>
<li>用来存储多字节整数和浮点值的二进制结构在不同系统中也可能不同</li>
</ul>
<p><strong>定位流</strong><br><em>定位标准I\O流</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功返回当前文件的位置指示</span></span><br><span class="line"><span class="comment">// 出错则返回 -1L</span></span><br><span class="line"><span class="comment">// 用于二进制文件的时候, 返回就是这种字节的位置</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0 出错则为非0</span></span><br><span class="line"><span class="comment">// whence的值, 类似于 lseek</span></span><br><span class="line"><span class="comment">// -SEEK_SET从文件的起始位置开始</span></span><br><span class="line"><span class="comment">// -SEEK_CUR从文件的当前位置</span></span><br><span class="line"><span class="comment">// -SEEK_END从文件的尾端</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE* fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span></span><br></pre></td></tr></table></figure>
<p><em>新的Api</em></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE* fp, <span class="keyword">fpos_t</span>* pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE* fp, <span class="keyword">const</span> <span class="keyword">fpos_t</span>* pos)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="格式化IO"><a href="#格式化IO" class="headerlink" title="格式化IO"></a>格式化IO</h2><p>执行格式化输出的三个printf函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面两个函数成功则返回输出的字符数, 出错则为负值.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE* fp, <span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将格式化的字符放入数组buf中 数组末尾会自动加一个null字节 但这个字节不会加入返回值中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>以上三个函数可以在前面加上字符v 构成另外三个三个函数<br>参数的… 变为arg(va_list)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE* fp, <span class="keyword">const</span> *format)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* buf, <span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>每个IO流都有一个相关联的文件描述符, 可以对fp调用fileno获得文件描述符<br><code>int fileno(FILE* fp)</code></p>
]]></content>
        
        <categories>
            
            <category> CPP </category>
            
            <category> 服务器编程-书籍记录 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[基础算法学习记录]]></title>
        <url>http://blog.lsmg.xyz/2019/08/Algorithm/</url>
        <content type="html"><![CDATA[<p>这篇博客, 记录下基础的算法. 当然不是仅仅的copy 答案了<br>记录一些以外的东西</p>
<a id="more"></a>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ul>
<li>哈希表 保持一个元素和一个元素的对应关系<br>保持数组中的每个元素与其下标相互对应的最好方法-哈希表<br>在C++中使用<code>hash_map</code> </li>
</ul>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><a href="https://leetcode-cn.com/explore/interview/card/top-interview-questions-easy/6/linked-list/41/" target="_blank" rel="noopener">删除链表中的节点</a></p>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.jpg" alt=""></p>
<p>这个题目, 跟课程上讲过的题目不太一样.<br>它的输入是需要删除的节点, 那么怎么获得前一个节点呢?<br>按照以往的思维是从头遍历, 但是这个没有给前面的节点.</p>
<p>所以想了下直接用<code>覆盖的方式删除节点</code>, 把待删除节点的next节点的val copy到待删除节点,<br>修改下待删除节点的next指向. 节点确实消失掉了.<br>既然要立志做游戏服务器, 考虑下, 丢掉的节点没有被删除掉, 还残留在内存中, 所以先保存删除节点的next节点的指针, 复制完毕后delete掉.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode* temp = node -&gt; next;</span><br><span class="line">        node -&gt; val = node -&gt; next -&gt; val;</span><br><span class="line">        node -&gt; next = node -&gt; next -&gt; next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>以后做题目 迁移到英文版力扣吧, 执行时间稳定, 也有新式的解法</strong></p>
<p><a href="https://leetcode.com/problems/x-of-a-kind-in-a-deck-of-cards/" target="_blank" rel="noopener">914. X of a Kind in a Deck of Cards</a></p>
<p>这道题目也算是没有理解透题目, 起初只想了简单的情况, 这点需要改进</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; deck)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> card[<span class="number">10000</span>] &#123;&#125;; <span class="comment">// C++ 11 新出部分</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num1 : deck) &#123; <span class="comment">// 利用二维数组 下标和值得两个对照</span></span><br><span class="line">            card[num1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">begin</span> = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(card[++<span class="built_in">begin</span>] == <span class="number">0</span>)&#123; <span class="comment">// 取到第一个卡牌数     </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a= card[<span class="built_in">begin</span>];</span><br><span class="line">        <span class="keyword">while</span>(card[++<span class="built_in">begin</span>] == <span class="number">0</span>)&#123; <span class="comment">// 取到第二个卡牌数</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="number">9999</span>) &#123; <span class="comment">// 如果整个输入 只有一种卡牌的情况</span></span><br><span class="line">                <span class="keyword">if</span>(a != <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> b = card[<span class="built_in">begin</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = maxNum(a, b);</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(card[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            temp = maxNum(card[i], temp);</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 辗转相除求最大公约数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = b;</span><br><span class="line">        <span class="keyword">while</span>(a % b != <span class="number">0</span>) &#123;</span><br><span class="line">            temp = a%b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.com/problems/long-pressed-name/" target="_blank" rel="noopener">925. Long Pressed Name</a><br>第一版自己写的 没有分离函数, 第二版把函数抽离了出来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isLongPressedName</span><span class="params">(<span class="built_in">string</span> name, <span class="built_in">string</span> typed)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> name_length = name.length();</span><br><span class="line">        <span class="keyword">int</span> typed_length = typed.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(typed_length &lt; name_length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> name_letter_times[name_length] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> name_letter[name_length] = &#123;name[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">int</span> name_letter_sub = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> typed_letterr_times[typed_length] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> typed_letter[typed_length] = &#123;typed[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">int</span> typed_letter_sub = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; name_length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name[i] != name_letter[name_letter_sub - <span class="number">1</span>]) &#123;</span><br><span class="line">                name_letter[name_letter_sub] = name[i];</span><br><span class="line">                name_letter_sub++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                name_letter_times[name_letter_sub <span class="number">-1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; typed_length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(typed[i] != typed_letter[typed_letter_sub - <span class="number">1</span>]) &#123;</span><br><span class="line">                typed_letter[typed_letter_sub] = typed[i];</span><br><span class="line">                typed_letter_sub++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                typed_letterr_times[typed_letter_sub <span class="number">-1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(name_letter_sub != typed_letter_sub) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; name_letter_sub; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name_letter_times[i] &gt; typed_letterr_times[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里遇到了问题, 起初我使用指针把数组传进去, 在函数里分配内存后 获得, 但是收到的是空.<br>后面改成了return 这个数组 成功取到了. 速度没有提升, 使用空间也变多了. 但是抽离出了一个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">getSimpleAndTime</span><span class="params">(<span class="built_in">string</span> input, <span class="keyword">int</span>* output_letter_length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> input_length = input.length();</span><br><span class="line">	<span class="keyword">int</span>* output_letter = <span class="keyword">new</span> <span class="keyword">int</span>[input_length];</span><br><span class="line">	output_letter[<span class="number">0</span>] = input[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span>* output_letter_times = <span class="keyword">new</span> <span class="keyword">int</span>[input_length];</span><br><span class="line">	output_letter_times[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; input_length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (input[i] != output_letter[*output_letter_length - <span class="number">1</span>]) &#123;</span><br><span class="line">			output_letter[*output_letter_length] = input[i];</span><br><span class="line">			(*output_letter_length)++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			output_letter_times[*output_letter_length - <span class="number">1</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> output_letter_times;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLongPressedName</span><span class="params">(<span class="built_in">string</span> name, <span class="built_in">string</span> typed)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>* name_letter_times = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> name_letter_sub = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>* typed_letterr_times = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> typed_letter_sub = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	name_letter_times = getSimpleAndTime(name, &amp;name_letter_sub);</span><br><span class="line">	typed_letterr_times = getSimpleAndTime(typed, &amp;typed_letter_sub);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (name_letter_sub != typed_letter_sub) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; name_letter_sub; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (name_letter_times[i] &gt; typed_letterr_times[i]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>察看了题解, 发现题解的算法更好, 虽然简单但却没有想到</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLongPressedName</span><span class="params">(<span class="built_in">string</span> name, <span class="built_in">string</span> typed)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p1=<span class="number">0</span>,p2=<span class="number">0</span>;   <span class="comment">// p1 for name string and p2 for typed</span></span><br><span class="line">	<span class="keyword">int</span> c=<span class="number">0</span>;                           <span class="comment">// counts number of matched char</span></span><br><span class="line">	<span class="keyword">while</span>(p2&lt;typed.length())&#123;                 <span class="comment">//loop until typed string gets over</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 这里直接用name字符串匹配typed字符串 只要 按顺序 在typed中找到所有name的字符即可</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">		<span class="keyword">if</span>(name[p1]==typed[p2])&#123;               <span class="comment">// if charachter matches move pointers ahead</span></span><br><span class="line">			p1++;                                               <span class="comment">//and increment the char count</span></span><br><span class="line">			p2++;</span><br><span class="line">			c++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125; </span><br><span class="line">		p2++;                                           <span class="comment">//else continue traversal</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c==name.length();                 <span class="comment">//finally if count matches the name length</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/two-sum/solution/" target="_blank" rel="noopener">两数之和, 多解</a><br>两队之和有最暴力的双层循环 <code>TO(n^2)</code>和<code>AO(1)</code><br>看题解有两个方法一遍哈希和两边哈希</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一遍哈希</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; the_map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            the_map.insert(make_pair(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (the_map.count(target - nums[i]) &gt; <span class="number">0</span> &amp;&amp; the_map[target - nums[i]] != i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, the_map[target - nums[i]] &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
        
        <categories>
            
            <category> 算法 </category>
            
            <category> 基础算法 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[Linux高性能服务器编程读书记录-高级部分]]></title>
        <url>http://blog.lsmg.xyz/2019/08/CPP-Linux-%25E9%25AB%2598%25E6%2580%25A7%25E8%2583%25BD%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8%25E7%25BC%2596%25E7%25A8%258B%25E8%25AF%25BB%25E4%25B9%25A6%25E8%25AE%25B0%25E5%25BD%2595%25E9%25AB%2598%25E7%25BA%25A7%25E9%2583%25A8%25E5%2588%2586/</url>
        <content type="html"><![CDATA[<p>第一个博客实在是太长了, 不方便建立目录这里将其拆开</p>
<a id="more"></a>
<h2 id="第九章-I-O复用"><a href="#第九章-I-O复用" class="headerlink" title="第九章 I/O复用"></a>第九章 I/O复用</h2><p>I/O复用使得程序能同时监听多个文件描述符.</p>
<ul>
<li>客户端程序需要同时处理多个socket 非阻塞connect技术</li>
<li>客户端程序同时处理用户输入和网络连接 聊天室程序</li>
<li>TCP服务器要同时处理监听socket和连接socket</li>
<li>同时处理TCP和UDP请求 - 回射服务器</li>
<li>同时监听多个端口, 或者处理多种服务 - xinetd服务器</li>
</ul>
<p>常用手段<code>select</code>, <code>poll</code>, <code>epoll</code></p>
<h3 id="Api-select-poll-epoll"><a href="#Api-select-poll-epoll" class="headerlink" title="Api - select, poll, epoll"></a>Api - select, poll, epoll</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="comment">// nfds - 被监听的文件描述符总数</span></span><br><span class="line"><span class="comment">// 后面三个分别指向 可读, 可写, 异常等事件对应的文件描述符集合</span></span><br><span class="line"><span class="comment">// timeval select超时时间 如果传递0 则为非阻塞, 设置为NULL则为阻塞</span></span><br><span class="line"><span class="comment">// 成功返回就绪(可读, 可写, 异常)文件描述符的总数, 没有则返回0 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作fd_set的宏</span></span><br><span class="line">FD_ZERO(fd_set* fdset);</span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set* fdset);</span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set* fdset);</span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd, fd_set* fdset);</span><br><span class="line"><span class="comment">// 设置 timeval 超时时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> tv_sec; <span class="comment">// 秒</span></span><br><span class="line">	<span class="keyword">long</span> tv_usec; <span class="comment">// 微秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// fds 结构体类型数组 指定我们感兴趣的文件描述符上发生的可读可写和异常事件\</span></span><br><span class="line"><span class="comment">// nfds 遍历结合大小</span></span><br><span class="line"><span class="comment">// timeout 单位为毫秒 -1 为阻塞 0 为立即返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	short events;  <span class="comment">//注册的事件, 告知poll监听fd上的哪些事件</span></span><br><span class="line">	short revents; <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// size 参数只是给内核一个提示, 事件表需要多大</span></span><br><span class="line"><span class="comment">// 函数返回其他所有epoll系统调用的第一个参数, 来指定要访问的内核事件表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epfd 为 epoll_create的返回值</span></span><br><span class="line"><span class="comment">// op为操作类型</span></span><br><span class="line"><span class="comment">// - EPOLL_CTL_ADD 向事件表中注册fd上的事件</span></span><br><span class="line"><span class="comment">// - EPOLL_CTL_MOD 修改fd上的注册事件</span></span><br><span class="line"><span class="comment">// - EPOLL_CTL_DEL 删除fd上的注册事件</span></span><br><span class="line"><span class="comment">// fd 为要操作的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">	<span class="keyword">_uint32_t</span> events; <span class="comment">// epoll事件</span></span><br><span class="line">	<span class="keyword">epoll_data_t</span> data; <span class="comment">// 用户数据 是一个联合体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">	<span class="keyword">void</span>* ptr; <span class="comment">// ptr fd 不能同时使用</span></span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">uint32_t</span> u32;</span><br><span class="line">	<span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="keyword">epoll_data_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// maxevents监听事件数 必须大于0</span></span><br><span class="line"><span class="comment">// timeout 为-1 表示阻塞</span></span><br><span class="line"><span class="comment">// 成功返回就绪的文件描述符个数 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="select-poll-epoll系统调用"><a href="#select-poll-epoll系统调用" class="headerlink" title="select, poll, epoll系统调用"></a>select, poll, epoll系统调用</h3><ul>
<li><strong>select</strong></li>
</ul>
<p>文件描述符就绪条件</p>
<ul>
<li><p>socket内核接收缓存区中的字节数大于或等于 其低水位标记</p>
</li>
<li><p>socket通信的对方关闭连接, 对socket的读操作返回0</p>
</li>
<li><p>监听socket上有新的连接请求</p>
</li>
<li><p>socket上有未处理的错误, 可以使用getsockopt来读取和清除错误</p>
</li>
<li><p>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记</p>
</li>
<li><p>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</p>
</li>
<li><p>socket使用非阻塞connect 连接成功或失败后</p>
</li>
<li><p><strong>poll</strong><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B1.png" alt=""><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B2.png" alt=""></p>
</li>
<li><p><strong>epoll</strong></p>
</li>
</ul>
<p>epoll是Linux特有的I/O复用函数, 实现上与select,poll有很大的差异</p>
<ul>
<li>epoll使用一组函数完成任务</li>
<li>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中</li>
<li>epoll无需每次调用都传入文件描述符集或事件集.</li>
</ul>
<p>有特定的文件描述符创建函数, 来标识这个事件表<code>epoll_create()</code><br><code>epoll_ctl()</code> 用来操作这个内核事件表<br><code>epoll_wait()</code> 为主要函数 成功返回就绪的文件描述符个数 失败返回-1<br>如果<code>epoll_wait()</code>函数检测到事件,就将所有就绪的事件从内核事件表(由第一个参数, epoll_create返回的结果) 中复制到第二个参数event指向的数组中, 这个数组只用于输出<code>epoll_wait</code>检测到的就绪事件.</p>
<p><em>event不同于select和poll的数组参数 既用于传入用户注册的事件, 又用于输出内核检测到的就绪事件, 提高了效率</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引poll返回的就绪文件描述符</span></span><br><span class="line"><span class="keyword">int</span> ret = poll(fds, MAX_EVENT_NUMBER - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class="line">	<span class="keyword">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">		<span class="keyword">int</span> sockfd = fds[i].fd;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引epoll返回的就绪文件描述符</span></span><br><span class="line"><span class="keyword">int</span> ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER,  <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">	<span class="comment">// sockfd 一定就绪 ?????</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LT和ET模式</strong><br>LT(电平触发, 默认的工作模式)<br>LT模式下的epoll相当于一个效率较高的poll<br>epoll_wait将会一只通知一个事件知道这个事件被处理</p>
<p>ET(边沿触发, epoll的高效工作模式)模式<br>当向epoll内核事件表中注册一个文件描述符上的EPOLLET事件的时候, epoll将用ET模式来操作这个<br>文件描述符<br>epoll_wait只会通知一次, 不论这个事件有没有完成</p>
<p>ET模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 123456789-123456789-123456789</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of content: 123456789</span><br><span class="line">get 9bytes of content: -12345678</span><br><span class="line">get 9bytes of content: 9-1234567</span><br><span class="line">get 4bytes of content: 89</span><br><span class="line">read later</span><br></pre></td></tr></table></figure>
<p>LT模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 123456789-123456789-123456789</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of contents: 123456789</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of contents: -12345678</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of contents: 9-1234567</span><br><span class="line">event trigger once</span><br><span class="line">get 4bytes of contents: 89</span><br></pre></td></tr></table></figure>
<p>ET模式有任务到来就必须做完, 因为后续将不会继续通知这个事件, 所以ET是epoll的高效工作模式<br>LT模式只要事件没被处理就会一直通知</p>
<h3 id="三种IO复用的比较"><a href="#三种IO复用的比较" class="headerlink" title="三种IO复用的比较"></a>三种IO复用的比较</h3><p><code>select</code>以及<code>poll</code>和<code>epoll</code><br>相同</p>
<ul>
<li>都能同时监听多个文件描述符, 都将等待timeout参数指定的超时时间, 直到一个或多个文件描述符上有事件发生.</li>
<li>返回值为就绪的文件描述符数量, 返回0则表示没有事件发生</li>
<li><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%B8%89%E7%A7%8DIO%E5%A4%8D%E7%94%A8%E6%AF%94%E8%BE%83.png" alt=""></li>
</ul>
<h3 id="I-O-复用的高级应用-非阻塞connect"><a href="#I-O-复用的高级应用-非阻塞connect" class="headerlink" title="I/O 复用的高级应用, 非阻塞connect"></a>I/O 复用的高级应用, 非阻塞connect</h3><p>connect出错的时候会返回一个errno值 EINPROGRESS - 表示对非阻塞socket调用connect, 连接又没有立即建立的时候, 这时可以调用select和poll函数来监听这个连接失败的socket上的可写事件.</p>
<p>当函数返回的时候, 可以用getsockopt来读取错误码, 并清楚该socket上的错误. 错误码为0表示成功</p>
<h2 id="第十章信号"><a href="#第十章信号" class="headerlink" title="第十章信号"></a>第十章信号</h2><h3 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h3><p>发送信号Api</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pid &gt; 0 发送给PID为pid标识的进程</span></span><br><span class="line"><span class="comment">//  0 发送给本进程组的其他进程</span></span><br><span class="line"><span class="comment">// -1 发送给进程以外的所有进程, 但发送者需要有对目标进程发送信号的权限</span></span><br><span class="line"><span class="comment">// &lt; -1 发送给组ID为 -pid 的进程组中的所有成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错信息 EINVAL 无效信号, EPERM 该进程没有权限给任何一个目标进程 ESRCH 目标进程(组) 不存在</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<p>接收信号Api</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">_sighandler_t</span>)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/signum.h&gt; // 此头文件中有所有的linux可用信号</span></span></span><br><span class="line"><span class="comment">// 忽略目标信号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_DFL ((_sighandler_t) 0)</span></span><br><span class="line"><span class="comment">// 使用信号的默认处理方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_IGN ((_sighandler_t) 1)</span></span><br></pre></td></tr></table></figure>
<p>常用信号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SIGHUP 控制终端挂起</span><br><span class="line">SIGPIPE 往读端被关闭的管道或者socket连接中写数据</span><br><span class="line">SIGURG socket连接上收到紧急数据</span><br><span class="line">SIGALRM 由alarm或setitimer设置的实时闹钟超时引起</span><br><span class="line">SIGCHLD 子进程状态变化</span><br></pre></td></tr></table></figure>
<p>信号函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为一个信号设置处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// _handler 指定sig的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">_sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">__sighandler_t</span> _handler)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> sig, struct sigaction* act, struct sigaction* oact)</span></span></span><br></pre></td></tr></table></figure>
<h3 id=""><a href="#" class="headerlink" title="??"></a>??</h3><p>信号是用户, 系统, 或者进程发送给目标进程的信息, 以通知目标进程某个状态的改变或者系统异常.<br>产生条件</p>
<ul>
<li>对于前台进程<br>用户可以通过输入特殊的终端字符来给它发送信号, CTRL+C 通常为一个中断信号 <code>SIGINT</code></li>
<li>系统异常<br>浮点异常和非法内存段的访问</li>
<li>系统状态变化<br>由alarm定时器到期将引起<code>SIGALRM</code>信号</li>
<li>运行kill命令或调用kill函数</li>
</ul>
<p><em>服务器必须处理(至少忽略) 一些常见的信号, 以免异常终止</em></p>
<p>中断系统调用?</p>
<h2 id="第十一章定时器"><a href="#第十一章定时器" class="headerlink" title="第十一章定时器"></a>第十一章定时器</h2><h3 id="Api-1"><a href="#Api-1" class="headerlink" title="Api"></a>Api</h3><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>网络程序需要处理的第三类事件是定时事件<br>定时 - 指在一段时间之后触发某段代码的机制</p>
<p>Linux提供了三种定时实现方法</p>
<ul>
<li>socket选项<code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code></li>
<li>SIGALRM信号</li>
<li>IO复用系统调用的超时参数</li>
</ul>
<p>第五章介绍了<code>SO_RCVTIMEO</code>和<code>SO_SNDTIMEO</code> 分别用来设置socket <code>接受数据超时时间</code> 和 <code>发送数据超时时间</code> 这两个选项对如下有效</p>
<p>复习一下设定函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">option_value在这里为 timeval 结构体</span><br><span class="line"></span><br><span class="line"><span class="comment">// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度</span></span><br><span class="line"><span class="comment">// 成功时返回0 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">void</span>* option_value, </span></span></span><br><span class="line"><span class="function"><span class="params">						<span class="keyword">socklen_t</span> <span class="keyword">restrict</span> option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">void</span>* option_value, </span></span></span><br><span class="line"><span class="function"><span class="params">						<span class="keyword">socklen_t</span> <span class="keyword">restrict</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/SO_RCVTIMEO%E5%92%8CSO_SNDTIMEO%E9%80%89%E9%A1%B9%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt=""></p>
<p>定时器的SIGALRM信号<br>有<code>alarm</code>和<code>setitimer</code>函数设置的闹钟超时 - 触发SIGALRM信号</p>
<h2 id="第十二章高性能IO框架库"><a href="#第十二章高性能IO框架库" class="headerlink" title="第十二章高性能IO框架库"></a>第十二章高性能IO框架库</h2><p>Linux服务器程序必须处理三类事件 IO事件, 信号, 和定时事件. 处理这三类事件需要考虑</p>
<ul>
<li>统一事件源<br>使代码简单易懂, 还能避免潜在的问题(我写我的项目的时候后来就这样重构了), 前面的例子使用IO复用</li>
</ul>
<p>来管理所有的事件</p>
<ul>
<li>可移植性</li>
<li>对并发编程的成支持</li>
</ul>
<h2 id="第十三章多进程编程"><a href="#第十三章多进程编程" class="headerlink" title="第十三章多进程编程"></a>第十三章多进程编程</h2><h3 id="exec系列系统调用"><a href="#exec系列系统调用" class="headerlink" title="exec系列系统调用"></a>exec系列系统调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 声明这个是外部函数或外部变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>** environ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻</span></span><br><span class="line"><span class="comment">// arg 和 argv用于向新的程序传递参数</span></span><br><span class="line"><span class="comment">// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量</span></span><br><span class="line"><span class="comment">// exec函数是不返回的, 除非出错</span></span><br><span class="line"><span class="comment">// 如果未报错则源程序被新的程序完全替换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* arg, ....)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">const</span> <span class="keyword">char</span>* arg, ..<span class="number">.0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* arg, ...., <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">char</span>* <span class="keyword">const</span> argv[], <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="fork系统调用"><a href="#fork系统调用" class="headerlink" title="fork系统调用"></a>fork系统调用</h3><p><strong>fork系统调用api</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0</span></span><br><span class="line"><span class="comment">// 次返回值用于区分是父进程还是子进程</span></span><br><span class="line"><span class="comment">// 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(viod)</span></span>;</span><br></pre></td></tr></table></figure>

<p><a name="13-1">fork系统调用</a><br>fork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项, 新的进程表项有很多的属性和原进程相同<br><code>堆指针``栈指针``标志寄存器的值</code>.<br>也存在不同的项目 该进程的PPID(父进程)被设置成原进程的PID,  信号位图被清除(原进程设置的信号处理函数对新进程无效)</p>
<p>子进程代码与父进程完全相同, 同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)了父进程的数据(堆数据, 栈数据, 静态数据)<br>创建子进程后, 父进程打开的文件描述符默认在子进程中也是打开的<br><code>文件描述符的引用计数</code>, <code>父进程的用户根目录, 当前工作目录等变量的引用计数</code> 均加1<br>(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)</p>
<h3 id="处理僵尸进程"><a href="#处理僵尸进程" class="headerlink" title="处理僵尸进程"></a>处理僵尸进程</h3><p><strong>处理僵尸进程API</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>* stat_loc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)</span></span><br><span class="line"><span class="comment">// options函数取值WNOHANG-waitpid立即返回</span></span><br><span class="line"><span class="comment">// 如果目标子进程正常退出, 则返回子进程的pid</span></span><br><span class="line"><span class="comment">// 如果还没有结束或意外终止, 则立即返回0</span></span><br><span class="line"><span class="comment">// 调用失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* stat_loc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line">WIFEXITED(stat_val); <span class="comment">// 子进程正常结束, 返回一个非0</span></span><br><span class="line">WEXITSTATUS(stat_val); <span class="comment">// 如果WIFEXITED 非0, 它返回子进程的退出码</span></span><br><span class="line">WIFSIGNALED(stat_val);<span class="comment">// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值</span></span><br><span class="line">WTERMSIG(stat_val);<span class="comment">// 如果WIFSIGNALED非0 返回一个信号值</span></span><br><span class="line">WIFSTOPPED(stat_val);<span class="comment">// 如果子进程意外终止, 它返回一个非0值</span></span><br><span class="line">WSTOPSIG(stat_val);<span class="comment">// 如果WIFSTOPED非0, 它返回一个信号值</span></span><br></pre></td></tr></table></figure>

<p>对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询</p>
<ul>
<li>在<code>子进程结束运行之后, 父进程读取其退出状态前</code>, 我们称该子进程处于<code>僵尸态</code></li>
<li>另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) <code>父进程结束运行之后, 子进程退出之前</code>, 处于<code>僵尸态</code></li>
</ul>
<p>以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.</p>
<p>waitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.<br>SIGCHLD信号- 子进程结束后将会给父进程发送此信号</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_child</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> stat;</span><br><span class="line">	<span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 善后处理emmmm</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="13-4">管道</a><br>管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证<br>父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].</p>
<p>可以用两个管道来实现双向传输数据, 也可以用<code>socketpair</code>来创建管道</p>
<h3 id="信号量-lt-sys-sem-h-gt"><a href="#信号量-lt-sys-sem-h-gt" class="headerlink" title="信号量-&lt;sys/sem.h&gt;"></a>信号量-&lt;sys/sem.h&gt;</h3><p><em>信号量原语</em><br>只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.<br>假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为</p>
<ul>
<li>P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行</li>
<li>V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png" alt=""></li>
</ul>
<p>创建信号量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semeget 系统调用</span></span><br><span class="line"><span class="comment">// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集</span></span><br><span class="line"><span class="comment">// key 参数是一个键值, 用来标识一个全局唯一的信号量级, 就像文件名全局唯一地标识一个文件一样.</span></span><br><span class="line"><span class="comment">// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0</span></span><br><span class="line"><span class="comment">// sem_flags指定一组标志, 与调用open函数的mode参数相同</span></span><br><span class="line"><span class="comment">// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错</span></span><br><span class="line"><span class="comment">// - 联合使用IPC_CREAT和IPC_EXCL来创建一组新的唯一额信号量集</span></span><br><span class="line"><span class="comment">// - 如果已经存在则会返回错误 errno = EEXIST</span></span><br><span class="line"><span class="comment">// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>semget成功时返回一个与之关联的内核结构体semid_ds</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> sem_nsems; <span class="comment">// 被设置为num_sems</span></span><br><span class="line">	<span class="keyword">time_t</span> sem_otime; <span class="comment">// 被设置为0</span></span><br><span class="line">	<span class="keyword">time_t</span> sem_ctime; <span class="comment">// 被设置为当前的系统时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用来描述权限</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">uid_t</span> uid; <span class="comment">// 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line">	<span class="keyword">gid_t</span> gid; <span class="comment">// 所有者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line">	<span class="keyword">uid_t</span> cuid; <span class="comment">// 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line">	<span class="keyword">gid_t</span> cgid; <span class="comment">// 创建者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line">	<span class="keyword">mode_t</span> mode;<span class="comment">// 访问权限, 背着只为sem_flags参数的最低9位.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>与semop信号量关联的一些重要的内核变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> short semval; <span class="comment">// 信号量的值</span></span><br><span class="line"><span class="keyword">unsigned</span> short semzcnt; <span class="comment">// 等待信号量值变为0的进程数量</span></span><br><span class="line"><span class="keyword">unsigned</span> short semncnt<span class="comment">// 等待信号量值增加的进程数量</span></span><br><span class="line"><span class="keyword">pid_t</span> sempid; <span class="comment">// 最后一次执行semop操作的进程ID</span></span><br></pre></td></tr></table></figure>
<p>操作信号量, 实际上就是对上面的内核变量操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> short <span class="keyword">int</span> sem_num;<span class="comment">// 信号量集中信号量的编号, 0表示信号量集中的第一个信号量</span></span><br><span class="line">	short <span class="keyword">int</span> sem_op; <span class="comment">// 指定操作类型,</span></span><br><span class="line">	short <span class="keyword">int</span> sem_flg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.</span></span><br><span class="line"><span class="comment">// sem_ops 参数指向一个sembuf结构体类型的数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> sem_id, struct sembuf* sem_ops, <span class="keyword">size_t</span> num_sem_ops)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sem_op 每种类型的操作行为又受到sem_flags成员的影响</span></span><br><span class="line"><span class="comment">// sem_flag 可选值是可选正整数 0 负整数. </span></span><br><span class="line"><span class="comment">// - IPC_NOWAIT(无论信号量操作是否成功, 都立即返回), </span></span><br><span class="line"><span class="comment">// - SEM_UNDO (当进程退出的时候, 取消正在进行的semop操作)</span></span><br><span class="line"><span class="comment">// -- sem_op &gt; 0</span></span><br><span class="line"><span class="comment">// -- 则semop将被操作的信号量的值semval增加sem_op, 要求调用进程对被操作的信号量集有写权限</span></span><br><span class="line"><span class="comment">// -- 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)</span></span><br><span class="line"><span class="comment">// -- sem_op = 0</span></span><br><span class="line"><span class="comment">// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限</span></span><br><span class="line"><span class="comment">// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0</span></span><br><span class="line"><span class="comment">// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN</span></span><br><span class="line"><span class="comment">// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生</span></span><br><span class="line"><span class="comment">// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1</span></span><br><span class="line"><span class="comment">// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM</span></span><br><span class="line"><span class="comment">// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1</span></span><br><span class="line"><span class="comment">// -- sem_op &lt; 0</span></span><br><span class="line"><span class="comment">// -- 表示对信号量的值进行减操作, 即期望获得信号量, 要求调用进程对被操作信号量集有写权限</span></span><br><span class="line"><span class="comment">// -- 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量</span></span><br><span class="line"><span class="comment">// -- 且semval -= abs(sem_op)</span></span><br><span class="line"><span class="comment">// -- 如果此时这定了SEM_UNDO的标志, 系统更新进程的semadj变量</span></span><br><span class="line"><span class="comment">// -- 如果semval &lt; abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN</span></span><br><span class="line"><span class="comment">// -- 如果没有指定则阻塞进程等待信号量可用, 且semzcnt +=1, 等到下面三种情况唤醒</span></span><br><span class="line"><span class="comment">// -- 1 发生semval &gt;= abs(sem_op), semzcnt-=1, semval -= abs(sem_op). 在SEM_UNDO设置时更新semadj</span></span><br><span class="line"><span class="comment">// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)</span></span><br><span class="line"><span class="comment">// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)</span></span><br><span class="line"><span class="comment">// num_sem_ops 指定要执行的操作个数, 即sem_ops数组中的元素个数, semop对sem_ops[] 中的每个成员按顺序操作,</span></span><br><span class="line"><span class="comment">// 并且是原子操作</span></span><br><span class="line"><span class="comment">// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semctl 系统调用</span></span><br><span class="line"><span class="comment">// sem_id 参数是由semget返回的信号量集标识符</span></span><br><span class="line"><span class="comment">// sen_num指定被操作的信号量在信号集中的编号</span></span><br><span class="line"><span class="comment">// command指定命令, 可以追加命令所需的参数, 不过有推荐格式</span></span><br><span class="line"><span class="comment">// 成功返回对应command的参数, 失败返回-1 errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> command, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>结构体<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/1.png" alt=""></p>
<p>command参数<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/semctl%E7%9A%84command%E5%8F%82%E6%95%B0.png" alt=""><br>除去GETALL以外的 其他GET都是操作的单个信号量, 由sem_id指定的第sem_num个信号量.<br>其他操作针对整个信号量集, 此时semctl的参数sem_num被忽略</p>
<p><em>特殊键值IPC_PRIVATE</em><br>semget的调用者可以给其key参数传递一个特殊的键值<code>IPC_PRIVATE</code>, 这样无论该信号量是否已经存在<br>semget都将创建一个新的信号量.</p>
<p><strong>总结PV使用方法</strong><br>使用<code>semget</code>获取到唯一的标识.<br>使用<code>semctl</code>的<code>SETVAL</code>传入初始化val的<code>sem_un</code>联合体.来初始化val<br>调用<code>semop</code> 传入唯一标识, <code>sem_op=-1</code>执行P(锁)操作<code>sem_op=1</code>执行V(开锁)操作<br>开关锁通过当<code>sem_op=-1,semval=0</code><br>且未指定<code>IPC_NOWAIT</code><br>等待<code>semval</code>被<code>sem_op=1</code>改为<code>semval=1</code></p>
<h3 id="共享内存-lt-sys-shm-h-gt"><a href="#共享内存-lt-sys-shm-h-gt" class="headerlink" title="共享内存-&lt;sys/shm.h&gt;"></a>共享内存-&lt;sys/shm.h&gt;</h3><p>最高效的IPC(进程间通信)机制<br>需要自己同步进程对其的访问, 否则会产生竞态条件</p>
<p><code>int shmget(key_t key, size_t size, int shmflg)</code><br>成功返回唯一标识, 失败返回-1 errno<br>key<br>与semget相同 标识一段全局唯一的共享内存<br>size 内存区域大小 单位字节<br>shmflg<br>shmflg的参数与semget相同, 同时多了两个额外的参数<br><code>SHM_HUGETLB</code>系统将使用”大页面”来为共享内存分配空间<br><code>SHM_NORESERVE</code>不为共享内存保留swap空间, 如果物理内存不足在执行写操作的<br>时候将会触发<code>SIGSEGV</code>信号</p>
<p>同时会创建对应的<code>shmid_ds</code>结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_per</span>;</span> <span class="comment">// 权限相关</span></span><br><span class="line">	<span class="keyword">size_t</span> shm_segsz; <span class="comment">// 共享内存大小 单位字节	size</span></span><br><span class="line">	<span class="keyword">__time_t</span> shm_atime; <span class="comment">// 对这段内存最后一次调用semat的时间 0</span></span><br><span class="line">	<span class="keyword">__time_t</span> shm_dtime; <span class="comment">// 对这段内存最后一次调用semdt的时间 0</span></span><br><span class="line">	<span class="keyword">__time_t</span> shm_ctime; <span class="comment">// 对这段内存最后一次调用semctl的时间 当前时间</span></span><br><span class="line">	<span class="keyword">__pid_t</span> shm_cpid; <span class="comment">// 创建者PID</span></span><br><span class="line">	<span class="keyword">__pid_t</span> lpid; <span class="comment">// 最后一次执行shmat或shmdt的进程PID</span></span><br><span class="line">	<span class="keyword">shmatt_t</span> shm_nattach <span class="comment">// 关联到此共享内存空间的进程数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>void* shmat(int shm_id, const void* shm_addr, int shmflg)</code><br>将共享内存关联到进程的地址空间<br>成功返回关联到的地址, 失败返回 (void<em>)-1 errno<br>shm_id<br>shmget返回的唯一标识<br>shm_addr<br>关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响<br>如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强<br>如果 shm_addr 非空,且没有<code>SHM_RND</code>标志 则关联到指定的地址处<br>如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写</em><br>shmflg<br>SHM_RDONLY 设置后内存内容变成只读<br>SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联<br>SHM_EXEC 有执行权限 = 读权限<br>调用成功之后, 修改shmid_ds的部分<br>shm_nattach +1<br>更新 shm_lpid和shm_atime设置为当前时间</p>
<p><code>int shmdt(const void* shm_addr)</code><br>将共享内存从进程地址空间中分离<br>成功返回0 失败返回-1 errno<br>成功后<br>shm_nattach -1<br>更新 shm_lpid和shm_dtime设置为当前时间</p>
<p><code>int shm_ctl(int shm_id, int command, struct shmid_ds* buf)</code><br>,目前还不清楚哪些实用, 所以暂时贴图了<br>成功返回相关值, 失败返回 -1 errno<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/shmctl.png" alt=""></p>
<h1 id="第十四章-多线程编程"><a href="#第十四章-多线程编程" class="headerlink" title="第十四章 多线程编程"></a>第十四章 多线程编程</h1><p>根据运行环境和调度者身份, 线程可以分为两种<br>内核线程<br>运行在内核空间, 由内核来调度.<br>用户线程<br>运行在用空间, 由线程库来调用</p>
<p>当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.</p>
<p>线程有三种实现方式</p>
<ul>
<li>完全在用户空间实现-无需内核支持<br>  创建和调度线程无需内核干预, 速度很快.<br>  不占用额外的内核资源, 对系统影响较小<br>  但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的</li>
<li>完全由内核调度<br>  创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理<br>  优缺点正好与上一个相反</li>
<li>双层调度<br>  结合了前两个的优点<br>  不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势</li>
</ul>
<p><strong>创建和结束线程</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/pthreadtypes.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">pthread_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* attr, <span class="keyword">void</span>* (*start_routine)(<span class="keyword">void</span>*), <span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0 失败返回错误码</span></span><br><span class="line"><span class="comment">// thread 用来唯一的标识一个新线程</span></span><br><span class="line"><span class="comment">// attr用来设置新县城的属性 传递NULL表示默认线程属性</span></span><br><span class="line"><span class="comment">// start_routine 指定新线程运行的函数</span></span><br><span class="line"><span class="comment">// arg指定函数的参数</span></span><br></pre></td></tr></table></figure>
<p><code>void pthread_exit(void* retval);</code><br>用来保证线程安全干净的退出, 线程函数最好结束时调用.<br>通过<code>retval</code>参数向线程的回收者传递其退出信息<br>执行后不会返回到调用者, 而且永远不会失败</p>
<p><code>int pthread_join(pthread_t thread, void** retval)</code><br>可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.<br>成功时返回0, 失败返回错误码<br>等待其他线程结束<br>thread 线程标识符<br>retval 目标线程的退出返回信息</p>
<p>错误码如下<br><code>EDEADLK</code>引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用<br><code>EINVAL</code>目标线程是不可回收的, 或是其他线程在回收目标线程<br><code>ESRCH</code>目标线程不存在</p>
<p><code>int pthread_cancel(pthread_t thread)</code><br>异常终止一个线程, 即为取消线程<br>成功返回0, 失败返回错误码</p>
<p>接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.<br>一下两个函数成功返回0 失败返回错误码<br><code>int pthread_setcancelstart(int state, int* oldstate)</code><br>第一个参数<br><code>PTHREAD_CANCEL_ENABLE</code> 允许线程被取消, 默认状态<br><code>PTHREAD_CANCEL_DISABLE</code> 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求指导<br>这个线程允许被取消<br>第二个参数 返回之前设定的状态</p>
<p><code>int pthread_setcanceltype(int type, int* oldtype)</code><br>第一个参数<br><code>PTHREAD_CANCEL_ASYNCHRONOUS</code> 线程可以随时被取消<br><code>PTHREAD_CANCEL_DEFERRED</code>允许目标现成推迟行动, 知道调用了下面几个所谓的取消点函数<br>最好使用<code>pthread_testcancel</code>函数设置取消点<br>设置取消类型(如何取消)<br>第二个参数<br>原来的取消类型</p>
<p><strong>线程属性</strong><br>这里的属性很多, 不清楚后面会不会用到暂时略过</p>
<p><strong>POSIX信号量</strong><br>多线程也必须考虑线程同步的问题.<br>虽然<code>pthread_join</code>可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求<br>比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.</p>
<p>以下函数成功返回0 失败返回-1 errno<br><code>int sem_init(sem_t* sem, int pshared, unsigned int value)</code><br>用于初始化一个未命名的信号量.<br>如果<code>pshared</code>为0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享<br><code>value</code>指定参数的初始值<br><em>初始化已经存在的信号量会导致无法预期的结果</em></p>
<p><code>int sem_destory(sem_t* sem)</code><br>销毁信号量, 释放其占用的系统资源<br><em>销毁正被其他线程等待的信号量, 将会导致无法预期的结果</em></p>
<p><code>int sem_wait(sem_t* sem)</code><br>以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞, 知道信号量具有非0值</p>
<p><code>int sem_trywait(sem_t* sem)</code><br>跟上面的函数相同不过不会阻塞. 信号量不为0 则 -1, 为0 则返回-1 errno</p>
<p><code>int sem_post(sem_t sem)</code><br>原子操作将信号量的值 +1</p>
]]></content>
        
        <categories>
            
            <category> CPP </category>
            
            <category> 服务器编程-书籍记录 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[Linux高性能服务器编程读书记录-初级部分]]></title>
        <url>http://blog.lsmg.xyz/2019/08/CPP-Linux-%25E9%25AB%2598%25E6%2580%25A7%25E8%2583%25BD%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8%25E7%25BC%2596%25E7%25A8%258B%25E8%25AF%25BB%25E4%25B9%25A6%25E8%25AE%25B0%25E5%25BD%2595%25E5%2588%259D%25E7%25BA%25A7%25E9%2583%25A8%25E5%2588%2586/</url>
        <content type="html"><![CDATA[<p>开头选了这本书, 看到这本书是他人总结三大本后自己写的, 先求个理解大概.<br>话说别人推荐的c++服务器咋都是c语言…..<br>2019年8月17日20:37:53</p>
<p>每学习一部分就写一个demo</p>
<a id="more"></a>

<p>分了三篇</p>
<h1 id="第一篇TCP-IP协议详解"><a href="#第一篇TCP-IP协议详解" class="headerlink" title="第一篇TCP/IP协议详解"></a>第一篇TCP/IP协议详解</h1><h2 id="第一章-TCP-IP协议族"><a href="#第一章-TCP-IP协议族" class="headerlink" title="第一章 TCP/IP协议族"></a>第一章 TCP/IP协议族</h2><h3 id="TCP-IP协议族体系结构和主要协议"><a href="#TCP-IP协议族体系结构和主要协议" class="headerlink" title="TCP/IP协议族体系结构和主要协议"></a>TCP/IP协议族体系结构和主要协议</h3><p>协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接</p>
<p>见得最多就是这四层结构了, 不过这本书写得更加详细一些<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<p>同样七层是osi参考模型, 简化后得到四层<br><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=3a1768f4c6fc1e17e9b284632bf99d66/0dd7912397dda144d48ab350bbb7d0a20df48655.jpg" alt=""><br>不同层次之间, 通过接口互相交流, 这样方便了各层次的修改</p>
<p><strong>应用层</strong><br>负责处理应用程序的逻辑</p>
<p><strong>表示层</strong><br>定义了数据的格式及加密</p>
<p><strong>会话层</strong><br>它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的</p>
<p><strong>传输层</strong><br>为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.<br>此层存在两大协议TCP协议和UDP协议<br><em>TCP协议</em><br>TCP协议(Transmission Control Protocol 传输控制协议) - 为应用层提供<code>可靠的, 面向连接, 基于流的服</code><br>通过<code>超时重传</code>和<code>数据确认</code>等确保数据正常送达.<br>TCP需要存储一些必要的状态, 可靠的协议<br><em>UDP协议</em><br>UPD协议(User Datagram Protocol 用户数据报协议) - 为应用层提供<code>不可靠的, 无连接的, 基于数据报的服务</code><br>一般需要自己处理<code>数据确认</code>和<code>超时重传</code>的问题<br>通信两者不存储状态, 每次发送都需要指定地址信息. <code>有自己的长度</code></p>
<p><strong>网络层</strong><br>实现了数据包的选路和转发.  只有数据包到不了目标地址, 就<code>下一跳</code>(hop by hop), 选择最近的.<br><em>IP协议(Internet Protocol)</em> 以及 <em>ICMP协议(Internet Control Message Protocol)</em><br>后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)</p>
<p><strong>数据链路层</strong><br>实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.<br>存在两个协议 <em>ARP协议(Address Resolve Protocol, 地址解析协议)</em>. 还有<em>RARP(Reverse ~, 逆地址解析协议)</em>.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议<strong>ARP欺骗, 可能与这个有关, 目前不去学习</strong></p>
<p><strong>封装</strong><br>上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.<br>被TCP封装的数据成为 <code>TCP报文段</code></p>
<ul>
<li>内核部分发送成功后删除数据</li>
</ul>
<p>被UDP封装的数据成为 <code>UDP数据报</code></p>
<ul>
<li>发送后即删除</li>
</ul>
<p>再经IP封装后成为<code>IP数据报</code><br>最后经过数据链路层封装后为 <code>帧</code></p>
<p>下面的操作都将在如下环境进行<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C.png" alt=""></p>
<p><strong>ARP</strong><br>ARP协议能实现任意网络层地址到任意物理地址的转换</p>
<h2 id="第二章-IP协议详解"><a href="#第二章-IP协议详解" class="headerlink" title="第二章 IP协议详解"></a>第二章 IP协议详解</h2><p>IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一<br>IP协议为上层协议提供无状态, 无连接, 不可靠的服务</p>
<h1 id="第二篇深入解析高性能服务器编程"><a href="#第二篇深入解析高性能服务器编程" class="headerlink" title="第二篇深入解析高性能服务器编程"></a>第二篇深入解析高性能服务器编程</h1><h2 id="第五章Linux网络编程基础API"><a href="#第五章Linux网络编程基础API" class="headerlink" title="第五章Linux网络编程基础API"></a>第五章Linux网络编程基础API</h2><p>socket基础api位于 <code>sys/socket.h</code> 头文件中<br>socket最开始的含义是 一个IP地址和端口对. 唯一的表示了TCP通信的一段<br>网络信息api <code>netdb.h</code>头文件中</p>
<h3 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h3><p>字节序分为 <code>大端字节序</code>和<code>小端字节序</code><br>由于大多数PC采用小端字节序(高位存在高地址处), 所以小端字节序又称为主机字节序</p>
<p>为了防止不同机器字节序不同导致的错乱问题. 规定传输的时候统一为 大端字节序(网络字节序).<br>这样主机会根据自己的情况决定 - 是否转换接收到的数据的字节序</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul>
<li><strong>基础连接</strong><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93.jpg" alt=""><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88%E5%9C%B0%E5%9D%80%E6%97%8F.jpg" alt=""><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主机序和网络字节序转换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>; <span class="comment">// host to network long</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="keyword">int</span> <span class="title">htons</span> <span class="params">(<span class="keyword">unsigned</span> short <span class="keyword">int</span> hostlong)</span></span>; <span class="comment">// host to network short</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="keyword">int</span> <span class="title">htons</span> <span class="params">(<span class="keyword">unsigned</span> short <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP地址转换函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONE</span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span>  <span class="title">inet_addr</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* strptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* cp, struct in_addr* inp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回一个静态变量地址值, 所以多次调用会导致覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族</span></span><br><span class="line"><span class="comment">// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> * src, <span class="keyword">void</span>* dst)</span></span>;</span><br><span class="line"><span class="comment">// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span>*  src, <span class="keyword">char</span>* dst, <span class="keyword">socklen_t</span> cnt)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 命名 监听 socket</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// domain指定使用那个协议族 PF_INET PF_INET6</span></span><br><span class="line"><span class="comment">// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)</span></span><br><span class="line"><span class="comment">// protocol设置为默认的0</span></span><br><span class="line"><span class="comment">// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket为socket文件描述符</span></span><br><span class="line"><span class="comment">// my_addr 为地址信息</span></span><br><span class="line"><span class="comment">// addrlen为socket地址长度</span></span><br><span class="line"><span class="comment">// 成功返回0 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">const</span> struct sockaddr* my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backlog表示队列最大的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// 接受连接 失败返回-1 成功时返回socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">socklen_t</span>* addrlen)</span></span></span><br></pre></td></tr></table></figure>
客户端<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起连接</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 第三个参数为 地址指定的长度</span></span><br><span class="line"><span class="comment">// 成功返回0 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr * serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数为保存的socket</span></span><br><span class="line"><span class="comment">// 并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才能关闭(需要查阅)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即关闭</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 第二个参数为可选值 </span></span><br><span class="line"><span class="comment">//	SHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃</span></span><br><span class="line"><span class="comment">//	SHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去</span></span><br><span class="line"><span class="comment">//	SHUT_RDWR 同时关闭读和写</span></span><br><span class="line"><span class="comment">// 成功返回0 失败为-1 设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span></span><br></pre></td></tr></table></figure></li>
<li><strong>基础TCP</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取sockfd的数据</span></span><br><span class="line"><span class="comment">// buf 指定读缓冲区的位置</span></span><br><span class="line"><span class="comment">// len 指定读缓冲区的大小</span></span><br><span class="line"><span class="comment">// flags 参数较多</span></span><br><span class="line"><span class="comment">// 成功的时候返回读取到的长度, 可能小于预期长度, 需要多次读取.   读取到0 通信对方已经关闭连接, 错误返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 发送</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<table>
<thead>
<tr>
<th>选项名</th>
<th>含义</th>
<th>可用于发送</th>
<th>可用于接收</th>
</tr>
</thead>
<tbody><tr>
<td>MSG_CONFIRM</td>
<td>指示链路层协议持续监听, 直到得到答复.(仅能用于SOCK_DGRAM和SOCK_RAW类型的socket)</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>MSG_DONTROUTE</td>
<td>不查看路由表, 直接将数据发送给本地的局域网络的主机(代表发送者知道目标主机就在本地网络中)</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>MSG_DONTWAIT</td>
<td>非阻塞</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_MORE</td>
<td>告知内核有更多的数据要发送, 等到数据写入缓冲区完毕后,一并发送.减少短小的报文提高传输效率</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>MSG_WAITALL</td>
<td>读操作一直等待到读取到指定字节后才会返回</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_PEEK</td>
<td>看一下内缓存数据, 并不会影响数据</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_OOB</td>
<td>发送或接收紧急数据</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>MSG_NOSIGNAL</td>
<td>向读关闭的管道或者socket连接中写入数据不会触发SIGPIPE信号</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>基础UDP</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.</span></span><br><span class="line"><span class="comment">// 不过recvfrom和sendto 也可以用于 面向STREAM的连接, 这样可以省略发送和接收端的socket地址</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr* src_addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, ing flags, <span class="keyword">const</span> struct sockaddr* dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通用读写函数</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inclued <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr* msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr* msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line"><span class="comment">/* socket address --- 指向socket地址结构变量, 对于TCP连接需要设置为NULL*/</span></span><br><span class="line">	<span class="keyword">void</span>* msg_name; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">socklen_t</span> msg_namelen;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 分散的内存块 --- 对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由</span></span><br><span class="line"><span class="comment">     * msg_iov指向的数组指定, 称为分散读(scatter read)  ---对于sendmsg而言, msg_iovlen块的分散内存中</span></span><br><span class="line"><span class="comment">     * 的数据将一并发送称为集中写(gather write);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>* <span class="title">msg_iov</span>;</span></span><br><span class="line">	<span class="keyword">int</span> msg_iovlen; <span class="comment">/* 分散内存块的数量*/</span></span><br><span class="line">	<span class="keyword">void</span>* msg_control; <span class="comment">/* 指向辅助数据的起始位置*/</span></span><br><span class="line">	<span class="keyword">socklen_t</span> msg_controllen; <span class="comment">/* 辅助数据的大小*/</span></span><br><span class="line">	<span class="keyword">int</span> msg_flags; <span class="comment">/* 复制函数的flags参数, 并在调用过程中更新*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span>* iov_base <span class="comment">/* 内存起始地址*/</span></span><br><span class="line">	<span class="keyword">size_t</span> iov_len <span class="comment">/* 这块内存长度*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>其他Api</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 用于判断 sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据, </span></span><br><span class="line"><span class="comment">// 是的话返回1, 不是返回0</span></span><br><span class="line"><span class="comment">// 这样就可以选择带MSG_OOB标志的recv调用来接收带外数据. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockatmark</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getsockname 获取sockfd对应的本端socket地址, 存入address指定的内存中, 长度存入address_len中 成功返回0失败返回-1</span></span><br><span class="line"><span class="comment">// getpeername 获取远端的信息, 同上</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下函数头文件均相同*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度</span></span><br><span class="line"><span class="comment">// 成功时返回0 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">void</span>* option_value, </span></span></span><br><span class="line"><span class="function"><span class="params">						<span class="keyword">socklen_t</span> <span class="keyword">restrict</span> option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">void</span>* option_value, </span></span></span><br><span class="line"><span class="function"><span class="params">						<span class="keyword">socklen_t</span> <span class="keyword">restrict</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<table>
<thead>
<tr>
<th>SO_REUSEADDR</th>
<th>重用本地地址</th>
<th>sock被设置此属性后, 即使sock在被bind()后处于TIME_WAIT状态, 此时与他绑定的socket地址依然能够立即重用来绑定新的sock</th>
</tr>
</thead>
<tbody><tr>
<td>SO_RCVBUF</td>
<td>TCP接收缓冲区大小</td>
<td>最小值为256字节. 设置完后系统会自动加倍你所设定的值. 多出来的一倍将用用作空闲缓冲区处理拥塞</td>
</tr>
<tr>
<td>SO_SNDBUF</td>
<td>TCP发送缓冲区大小</td>
<td>最小值为2048字节</td>
</tr>
<tr>
<td>SO_RCVLOWAT</td>
<td>接收的低水位标记</td>
<td>默认为1字节, 当TCP接收缓冲区中可读数据的总数大于其低水位标记时, IO复用系统调用将通知应用程序可以从对应的socket上读取数据</td>
</tr>
<tr>
<td>SO_SNDLOWAT</td>
<td>发送的高水位标记</td>
<td>默认为1字节, 当TCP发送缓冲区中空闲空间大于低水位标记的时候可以写入数据</td>
</tr>
<tr>
<td>SO_LINGER</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l_onoff <span class="comment">/* 开启非0, 关闭为0*/</span></span><br><span class="line">	<span class="keyword">int</span> l_linger; <span class="comment">/* 滞留时间*/</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	* 当onoff为0的时候此项不起作用, close调用默认行为关闭socket</span></span><br><span class="line"><span class="comment">	* 当onoff不为0 且linger为0, close将立即返回, TCP将丢弃发送缓冲区的残留数据, 同时发送一个复位报文段</span></span><br><span class="line"><span class="comment">	* 当onoff不为0 且linger大于0 . 当socket阻塞的时候close将会等待TCP模块发送完残留数据并得到确认后关 </span></span><br><span class="line"><span class="comment">	* 闭, 如果是处于非阻塞则立即关闭</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/socket%E9%80%89%E9%A1%B9.jpg" alt=""></p>
<ul>
<li><strong>网络信息API</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// 通过主机名查找ip</span></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ip获取主机完整信息 </span></span><br><span class="line"><span class="comment">// type为IP地址类型 AF_INET和AF_INET6</span></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>* h_name;</span><br><span class="line">	<span class="keyword">char</span> ** h_aliases;</span><br><span class="line">	<span class="keyword">int</span> h_addrtype;</span><br><span class="line">	<span class="keyword">int</span> h_length;</span><br><span class="line">	<span class="keyword">char</span>** h_addr_list; <span class="comment">/* 按网络字节序列出主机IP地址列表*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以下两个函数通过读取/etc/services文件 来获取服务信息<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// 根据名称获取某个服务的完整信息</span></span><br><span class="line"><span class="function">struct servent <span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据端口号获取服务信息</span></span><br><span class="line"><span class="function">struct servent <span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>* s_name; <span class="comment">/* 服务名称*/</span></span><br><span class="line">	<span class="keyword">char</span> ** s_aliases; <span class="comment">/* 服务的别名列表*/</span></span><br><span class="line">	<span class="keyword">int</span> s_port; <span class="comment">/* 端口号*/</span></span><br><span class="line">	<span class="keyword">char</span>* s_proto; <span class="comment">/* 服务类型, 通常为TCP或UDP*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// 内部使用的gethostbyname 和 getserverbyname</span></span><br><span class="line"><span class="comment">// hostname 用于接收主机名, 也可以用来接收字符串表示的IP地址(点分十进制, 十六进制字符串)</span></span><br><span class="line"><span class="comment">// service 用于接收服务名, 字符串表示的十进制端口号</span></span><br><span class="line"><span class="comment">// hints参数 对getaddrinfo的输出进行更准确的控制, 可以设置为NULL, 允许反馈各种有用的结果</span></span><br><span class="line"><span class="comment">// result 指向一个链表, 用于存储getaddrinfo的反馈结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hostname, <span class="keyword">const</span> <span class="keyword">char</span>* service, <span class="keyword">const</span> struct addrinfo* hints, struct addrinfo** result)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct addrinfo</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ai_flags;</span><br><span class="line">	<span class="keyword">int</span> ai_family;</span><br><span class="line">	<span class="keyword">int</span> ai_socktype; <span class="comment">/* 服务类型, SOCK_STREAM或者SOCK_DGRAM*/</span></span><br><span class="line">	<span class="keyword">int</span> ai_protocol;</span><br><span class="line">	<span class="keyword">socklen_t</span> ai_addrlen;</span><br><span class="line">	<span class="keyword">char</span>* ai_canonname; <span class="comment">/* 主机的别名*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>* <span class="title">ai_addr</span>;</span> <span class="comment">/* 指向socket地址*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>* <span class="title">ai_next</span>;</span> <span class="comment">/* 指向下一个结构体*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要手动的释放堆内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo* res)</span></span>;</span><br></pre></td></tr></table></figure>
<img src="https://ftp.bmp.ovh/imgs/2019/08/7ebedb14d8eedeac.png" alt=""></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// host 存储返回的主机名</span></span><br><span class="line"><span class="comment">// serv存储返回的服务名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr* sockaddr, <span class="keyword">socklen_t</span> addrlen, <span class="keyword">char</span>* host, <span class="keyword">socklen_t</span> hostlen, <span class="keyword">char</span>* serv</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">socklen_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://ftp.bmp.ovh/imgs/2019/08/bc7196e9a30d5152.png" alt=""></p>
<p>测试<br>使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet ip port #来连接服务器的此端口</span><br><span class="line">netstat -nt | grep port #来查看此端口的监听</span><br></pre></td></tr></table></figure>

<h2 id="第六章高级IO函数"><a href="#第六章高级IO函数" class="headerlink" title="第六章高级IO函数"></a>第六章高级IO函数</h2><p>Linux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件自然限制了他的使用频率<br><em>文件描述符</em><br>文件描述符在是一个非负整数。是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表。<br>STDOUT_FILENO(值为1)- 值为1的文件描述符为标准输出, 关闭STDOUT_FILENO后用dup即可返回最小可用值(目前为, 1) 这样输出就重定向到了调用dup的参数指向的文件</p>
<h3 id="创建文件描述符-pipe-dup-dup2-splice-select"><a href="#创建文件描述符-pipe-dup-dup2-splice-select" class="headerlink" title="创建文件描述符 - pipe dup dup2 splice select"></a>创建文件描述符 - pipe dup dup2 splice select</h3><p><strong>pipe函数</strong><br>这个函数可用于创建一个管道, 实现进程间的通信. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="comment">// 参数文件描述符数组 fd[0] 读出 fd[1]写入 单向管道</span></span><br><span class="line"><span class="comment">// 成功返回0, 并将一对打开的文件描述符填入其参数指向的数组</span></span><br><span class="line"><span class="comment">// 失败返回-1 errno</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向管道</span></span><br><span class="line"><span class="comment">// 第一个参数为 协议PF_UNIX(书上是AF_UNIX)感觉这里指明协议使用PF更好一些</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>学习了后面的内容了解到了进程间通信, 回来补上一个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, fds);</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> a[] = <span class="string">"123"</span>;</span><br><span class="line">        send(fds[<span class="number">1</span>], a, <span class="built_in">strlen</span>(a), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> b[<span class="number">20</span>] &#123;&#125;;</span><br><span class="line">        recv(fds[<span class="number">0</span>], b, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dup和dup2函数</strong><br>复制一个现有的文件描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回的文件描述符总是取系统当前可用的最小整数值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="comment">// 可以用newfd来制定新的文件描述符, 如果newfd已经被打开则先关闭</span></span><br><span class="line"><span class="comment">// 如果newfd==oldfd 则不关闭newfd直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>dup函数创建一个新的文件描述符, 新的文件描述符和原有的file_descriptor共同指向相同的目标.<br>回来补上例子, 这个例子由于关掉了<code>STDOUT_FILENO</code>dup最小的即为<code>STDOUT_FILENO</code>所以<br>标准输出都到了这个文件之中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> filefd = <span class="built_in">open</span>(<span class="string">"/home/lsmg/1.txt"</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line">    dup(filefd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"123\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读写数据-readv-writev-mmap-munmap"><a href="#读写数据-readv-writev-mmap-munmap" class="headerlink" title="读写数据 - readv writev mmap munmap"></a>读写数据 - readv writev mmap munmap</h3><p><strong>readv/writev</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="comment">// count 为 vector的长度, 即为有多少块内存</span></span><br><span class="line"><span class="comment">// 成功时返回写入\读取的长度 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* <span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* <span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span>* iov_base <span class="comment">/* 内存起始地址*/</span></span><br><span class="line">	<span class="keyword">size_t</span> iov_len <span class="comment">/* 这块内存长度*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回来补上一个使用例子, 这个例子将一个int的内存表示写入到了文件之中<br>使用hexdump查看这个文件<code>0000000 86a0 0001</code>可以看到<code>186a0</code>即为100000</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2020年1月7日16:52:11</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> file = <span class="built_in">open</span>(<span class="string">"/home/lsmg/1.txt"</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">100000</span>;</span><br><span class="line">    iovec temp_iovec&#123;&#125;;</span><br><span class="line">    temp_iovec.iov_base = &amp;temp;</span><br><span class="line">    temp_iovec.iov_len = <span class="keyword">sizeof</span>(temp);</span><br><span class="line">    writev(file, &amp;temp_iovec, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendfile函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="comment">// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span>* offset, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">O_RDONLY只读模式</span><br><span class="line">O_WRONLY只写模式</span><br><span class="line">O_RDWR读写模式</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(file_name, flag)</span></span>;</span><br></pre></td></tr></table></figure>
<p>stat结构体, 可用fstat生成, <strong>简直就是文件的身份证</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>       st_dev;     <span class="comment">/* ID of device containing file -文件所在设备的ID*/</span></span><br><span class="line">    <span class="keyword">ino_t</span>       st_ino;     <span class="comment">/* inode number -inode节点号*/</span></span><br><span class="line">    <span class="keyword">mode_t</span>      st_mode;    <span class="comment">/* protection -保护模式?*/</span></span><br><span class="line">    <span class="keyword">nlink_t</span>     st_nlink;   <span class="comment">/* number of hard links -链向此文件的连接数(硬连接)*/</span></span><br><span class="line">    <span class="keyword">uid_t</span>       st_uid;     <span class="comment">/* user ID of owner -user id*/</span></span><br><span class="line">    <span class="keyword">gid_t</span>       st_gid;     <span class="comment">/* group ID of owner - group id*/</span></span><br><span class="line">    <span class="keyword">dev_t</span>       st_rdev;    <span class="comment">/* device ID (if special file) -设备号，针对设备文件*/</span></span><br><span class="line">    <span class="keyword">off_t</span>       st_size;    <span class="comment">/* total size, in bytes -文件大小，字节为单位*/</span></span><br><span class="line">    <span class="keyword">blksize_t</span>   st_blksize; <span class="comment">/* blocksize for filesystem I/O -系统块的大小*/</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>    st_blocks;  <span class="comment">/* number of blocks allocated -文件所占块数*/</span></span><br><span class="line">    <span class="keyword">time_t</span>      st_atime;   <span class="comment">/* time of last access -最近存取时间*/</span></span><br><span class="line">    <span class="keyword">time_t</span>      st_mtime;   <span class="comment">/* time of last modification -最近修改时间*/</span></span><br><span class="line">    <span class="keyword">time_t</span>      st_ctime;   <span class="comment">/* time of last status change - */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>身份证</strong>生成函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数需要调用open生成文件描述符</span></span><br><span class="line"><span class="comment">// 下面其他两个为文件全路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> filedes, struct stat *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当路径指向为符号链接的时候, lstat为符号链接的信息. stat为符号链接指向文件信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* ln -s source dist  建立软连接, 类似快捷方式, 也叫符号链接</span></span><br><span class="line"><span class="comment">* ln source dist  建立硬链接, 同一个文件使用多个不同的别名, 指向同一个文件数据块, 只要硬链接不被完全</span></span><br><span class="line"><span class="comment">* 删除就可以正常访问</span></span><br><span class="line"><span class="comment">* 文件数据块 - 文件的真正数据是一个文件数据块, 打开的`文件`指向这个数据块, 就是说</span></span><br><span class="line"><span class="comment">* `文件`本身就类似快捷方式, 指向文件存在的区域.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p> <strong>mmap和munmap函数</strong></p>
<p><code>mmap</code>创建一块进程通讯共享的内存(可以将文件映射入其中), <code>munmap</code>释放这块内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start 内存起始位置, 如果为NULL则系统分配一个地址 length为长度</span></span><br><span class="line"><span class="comment">// port参数 PROT_READ(可读) PROT_WRITE(可写) PROT_EXEC(可执行), PROT_NONE(不可访问)</span></span><br><span class="line"><span class="comment">// flag参数 内存被修改后的行为</span></span><br><span class="line"><span class="comment">// - MAP_SHARED 进程间共享内存, 对内存的修改反映到映射文件中</span></span><br><span class="line"><span class="comment">// - MAP_PRIVATE 为调用进程私有, 对该内存段的修改不会反映到文件中</span></span><br><span class="line"><span class="comment">// - MAP_ANONUMOUS 不是从文件映射而来, 内容被初始化为0, 最后两个参数被忽略</span></span><br><span class="line"><span class="comment">// 成功返回区域指针, 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> port, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>splice函数</strong><br>用于在两个文件名描述符之间移动数据, 0拷贝操作<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// fd_in 为文件描述符, 如果为管道文件描述符则 off_in必须为NULL, 否则为读取开始偏移位置</span></span><br><span class="line"><span class="comment">// len为指定移动的数据长度, flags参数控制数据如何移动.</span></span><br><span class="line"><span class="comment">// - SPLICE_F_NONBLOCK 非阻塞splice操作, 但会受文件描述符自身的阻塞</span></span><br><span class="line"><span class="comment">// - SPLICE_F_MORE 给内核一个提示, 后续的splice调用将读取更多的数据???????</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="keyword">int</span> fd_in, <span class="keyword">loff_t</span>* off_in, <span class="keyword">int</span> fd_out, <span class="keyword">loff_t</span>* off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用splice函数  实现echo服务器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the parmerters is wrong\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the port is %d the ip is %s\n"</span>, port, ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd, (sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sockfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> clientfd&#123;&#125;;</span><br><span class="line">    sockaddr_in client_address&#123;&#125;;</span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"></span><br><span class="line">    clientfd = accept(sockfd, (sockaddr*)&amp;client_address, &amp;client_addrlen);</span><br><span class="line">    <span class="keyword">if</span> (clientfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"accept error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a new connection from %s:%d success\n"</span>, inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));</span><br><span class="line">        <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">        pipe(fds);</span><br><span class="line">        ret = splice(clientfd, <span class="literal">nullptr</span>, fds[<span class="number">1</span>], <span class="literal">nullptr</span>, <span class="number">32768</span>, SPLICE_F_MORE);</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ret = splice(fds[<span class="number">0</span>], <span class="literal">nullptr</span>, clientfd, <span class="literal">nullptr</span>, <span class="number">32768</span>, SPLICE_F_MORE);</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>select 函数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></span><br><span class="line"><span class="comment">// maxfdp 最大数 FD_SETSIZE</span></span><br><span class="line"><span class="comment">// struct fd_set 一个集合,可以存储多个文件描述符</span></span><br><span class="line"><span class="comment">// - FD_ZERO(&amp;fd_set) 清空 -FD_SET(fd, &amp;fd_set) 放入fd FD_CLR(fd, &amp;fd_set)从其中清除fd</span></span><br><span class="line"><span class="comment">// - FD_ISSET(fd, &amp;fd_set) 判断是否在其中</span></span><br><span class="line"><span class="comment">// readfds  需要监视的文件描述符读变化</span></span><br><span class="line"><span class="comment">// writefds 需要监视的文件描述符写变化</span></span><br><span class="line"><span class="comment">// errorfds 错误</span></span><br><span class="line"><span class="comment">// 返回值 负值为错误 0 为超时</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout)</span></span>; </span><br><span class="line"><span class="comment">// int result_select = select(FD_SETSIZE, &amp;testfds, (fd_set *)0, (fd_set *)0, (struct timeval*)0);</span></span><br></pre></td></tr></table></figure>
<h2 id="第七章Linux服务器程序规范"><a href="#第七章Linux服务器程序规范" class="headerlink" title="第七章Linux服务器程序规范"></a>第七章Linux服务器程序规范</h2><ul>
<li>Linux程序服务器 一般以后台进程形式运行.  后台进程又称为守护进程(daemon). 他没有控制终端, 因而不会意外的接收到用户输入. 守护进程的父进程通常都是init进程(PID为1的进程)</li>
<li>Linux服务器程序有一套日志系统, 他至少能输出日志到文件. 日志这东西太重要了,排错对比全靠它.</li>
<li>Linux服务器程序一般以某个专门的非root身份运行. 比如mysqld有自己的账户mysql.</li>
<li>Linux服务器程序一般都有自己的配置文件, 而不是把所有配置都写死在代码里面, 方便后续的更改.</li>
<li>Linux服务器程序通常在启动的时候生成一个PID文件并存入/var/run 目录中, 以记录改后台进程的PID.</li>
<li>Linux服务器程序通常需要考虑系统资源和限制, 预测自己的承受能力</li>
</ul>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service rsyslog restart // 启动守护进程</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="comment">// priority参数是所谓的设施值(记录日志信息来源, 默认为LOG_USER)与日志级别的按位或</span></span><br><span class="line"><span class="comment">// - 0 LOG_EMERG  /* 系统不可用*/</span></span><br><span class="line"><span class="comment">// - 1 LOG_ALERT   /* 报警需要立即采取行动*/</span></span><br><span class="line"><span class="comment">// - 2 LOG_CRIT /* 非常严重的情况*/</span></span><br><span class="line"><span class="comment">// - 3 LOG_ERR  /* 错误*/</span></span><br><span class="line"><span class="comment">// - 4 LOG_WARNING /* 警告*/</span></span><br><span class="line"><span class="comment">// - 5 LOG_NOTICE /* 通知*/</span></span><br><span class="line"><span class="comment">// - 6 LOG_INFO /* 信息*/</span></span><br><span class="line"><span class="comment">//  -7 LOG_DEBUG /* 调试*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span>* message, .....)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ident 位于日志的时间后 通常为名字</span></span><br><span class="line"><span class="comment">// logopt 对后续 syslog调用的行为进行配置</span></span><br><span class="line"><span class="comment">// -  0x01 LOG_PID  /* 在日志信息中包含程序PID*/</span></span><br><span class="line"><span class="comment">// -  0x02 LOG_CONS /* 如果信息不能记录到日志文件, 则打印到终端*/</span></span><br><span class="line"><span class="comment">// -  0x04 LOG_ODELAY /* 延迟打开日志功能直到第一次调用syslog*/</span></span><br><span class="line"><span class="comment">// -  0x08 LOG_NDELAY /* 不延迟打开日志功能*/</span></span><br><span class="line"><span class="comment">// facility参数可以修改syslog函数中的默认设施值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ident, <span class="keyword">int</span> logopt, <span class="keyword">int</span> facility)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maskpri 一共八位 0000-0000</span></span><br><span class="line"><span class="comment">// 如果将最后一个0置为1 表示 记录0级别的日志</span></span><br><span class="line"><span class="comment">// 如果将最后两个0都置为1 表示记录0和1级别的日志</span></span><br><span class="line"><span class="comment">// 可以通过LOG_MASK() 宏设定 比如LOG_MASK(LOG_CRIT) 表示将倒数第三个0置为1, 表示只记录LOG_CRIT</span></span><br><span class="line"><span class="comment">// 如果直接设置setlogmask(3); 3的二进制最后两个数均为1 则记录 0和1级别的日志</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭日志功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="用户信息-切换用户"><a href="#用户信息-切换用户" class="headerlink" title="用户信息, 切换用户"></a>用户信息, 切换用户</h3><p>UID - 真实用户ID<br>EUID - 有效用户ID - 方便资源访问<br>GID - 真实组ID<br>EGID - 有效组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> euid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以通过 <code>setuid</code>和<code>setgid</code>切换用户 <strong>root用户uid和gid均为0</strong></p>
<h3 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h3><p>PGID - 进程组ID(Linux下每个进程隶属于一个进程组)</p>
<p>#include &lt;unistd.h&gt;<br>pid_t getpgid(pid_t pid); 成功时返回pid所属的pgid 失败返回-1<br>int setpgid(pid_t pid, pid_t pgid);</p>
<p><strong>会话</strong><br>一些有关联的进程组将形成一个会话<br>略过</p>
<p><strong>查看进程关系</strong><br>ps和less</p>
<p><strong>资源限制</strong><br>略<br><strong>改变目录</strong><br>略</p>
<h2 id="第八章高性能服务器程序框架"><a href="#第八章高性能服务器程序框架" class="headerlink" title="第八章高性能服务器程序框架"></a>第八章高性能服务器程序框架</h2><ul>
<li><strong>服务器模型-CS模型</strong></li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>实现起来简单</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>服务器是通信的中心, 访问过大的时候会导致响应过慢</li>
</ul>
<p>模式图<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%BE8-2%20TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt=""></p>
<p>编写的demo 没有用到fork函数. 后续待完善</p>
<ul>
<li><strong>服务器框架 IO模型</strong></li>
</ul>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png" alt=""></p>
<p>这个模型大概能够理解, 自己也算是学了半年的Javaweb.</p>
<p>socket在创建的时候默认是阻塞的, 不过可以通过传<code>SOCK_NONBLOCK</code>参解决<br>非阻塞调用都会立即返回 但可能事件没有发生(recv没有接收到信息), 没有发生和出错都会<code>返回-1</code> 所以需要通过<code>errno</code>来区分这些错误.<br><strong>事件未发生</strong><br>accept, send,recv errno被设置为 <code>EAGAIN(再来一次)</code>或<code>EWOULDBLOCK(期望阻塞)</code><br>connect 被设置为 <code>EINPROGRESS(正在处理中)</code></p>
<p>需要在事件已经发生的情况下 去调用非阻塞IO, 才能提高性能</p>
<p>常用IO复用函数 <code>select</code> <code>poll</code> <code>epoll_wait</code> 将在第九章后面说明<br>信号将在第十章说明</p>
<ul>
<li><strong>两种高效的事件处理模式和并发模式</strong><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Reactor%E6%A8%A1%E5%BC%8F.png" alt=""></li>
</ul>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Proactor%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E7%94%A8%E5%90%8C%E6%AD%A5IO%E6%A8%A1%E6%8B%9F%E5%87%BA%E7%9A%84Proactor%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>程序分为计算密集型(CPU使用很多, IO资源使用很少)和IO密集型(反过来).<br>前者使用并发编程反而会降低效率, 后者则会提升效率<br>并发编程有多进程和多线程两种方式</p>
<p>并发模式 - IO单元和多个逻辑单元之间协调完成任务的方法.<br>服务器主要有两种并发模式</p>
<ul>
<li><p>半同步/半异步模式</p>
</li>
<li><p>领导者/追随者模式</p>
</li>
<li><p><strong>半同步/半异步模式</strong><br>在IO模型中, 异步和同步的区分是内核向应用程序通知的是何种IO事件(就绪事件还是完成事件), 以及由谁来完成IO读写(应用程序还是内核)</p>
</li>
</ul>
<p>而在这里(并发模式)<br>同步指的是完全按照代码序列的顺序执行 - 按照同步方式运行的线程称为同步线程<br>异步需要系统事件(中断, 信号)来驱动 - 按照异步方式运行的线程称为异步线程<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5.png" alt=""></p>
<p>服务器(需要较好的实时性且能同时处理多个客户请求) - 一般使用同步线程和异步线程来实现,即为半同步/半异步模式<br>同步线程 - 处理客户逻辑, 处理请求队列中的对象<br>异步线程 - 处理IO事件, 接收到客户请求后将其封装成请求对象并插入请求队列</p>
<p>半同步/半异步模式 存在变体 <code>半同步/半反应堆模式</code><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F.png" alt=""></p>
<p>异步线程 - 主线程 - 负责监听所有socket上的事件</p>
<p><strong>领导者/追随者模式</strong><br>略</p>
<p><strong>高效编程方法 - 有限状态机</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态独立的有限状态机</span></span><br><span class="line">STATE_MACHINE(Package _pack) &#123;</span><br><span class="line">	</span><br><span class="line">	PackageType _type = _pack.GetType();</span><br><span class="line">	<span class="keyword">switch</span>(_type) &#123;</span><br><span class="line">		<span class="keyword">case</span> type_A:</span><br><span class="line">			xxxx;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> type_B:</span><br><span class="line">			xxxx;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带状态转移的有限状态机</span></span><br><span class="line">STATE_MACHINE() &#123;</span><br><span class="line">	State cur_State = type_A;</span><br><span class="line">	<span class="keyword">while</span>(cur_State != type_C) &#123;</span><br><span class="line">	</span><br><span class="line">		Package _pack = getNewPackage();</span><br><span class="line">		<span class="keyword">switch</span>(cur_State) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">case</span> type_A:</span><br><span class="line">				process_package_state_A(_pack);</span><br><span class="line">				cur_State = type_B;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> type_B:</span><br><span class="line">				xxxx;</span><br><span class="line">				cur_State = type_C;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>花了小一个小时 终于一个字母一个字母的抄完了那个5000多字的代码<br>@2019年9月8日22:08:46@</p>
<h3 id="提高服务器性能的其他建议-池-数据复制-上下文切换和锁"><a href="#提高服务器性能的其他建议-池-数据复制-上下文切换和锁" class="headerlink" title="提高服务器性能的其他建议 池 数据复制 上下文切换和锁"></a>提高服务器性能的其他建议 池 数据复制 上下文切换和锁</h3><p><strong>池</strong> - 用空间换取时间<br>进程池和线程池</p>
<p><strong>数据复制</strong> - 高性能的服务器应该尽量避免不必要的复制</p>
<p><strong>上下文切换和锁</strong><br>减少<code>锁</code>的作用区域. 不应该创建太多的工作进程, 而是使用专门的业务逻辑线程.</p>
]]></content>
        
        <categories>
            
            <category> CPP </category>
            
            <category> 服务器编程-书籍记录 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[C++服务器学习大纲]]></title>
        <url>http://blog.lsmg.xyz/2019/08/CPP%25E6%259C%258D%25E5%258A%25A1%25E5%2599%25A8%25E5%25AD%25A6%25E4%25B9%25A0%25E5%25A4%25A7%25E7%25BA%25B2/</url>
        <content type="html"><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>先找本书入入门, 也算是为以后学习正课打打基础了. 第一本就是&lt;linux 高性能服务器编程&gt;<br>读书记录在另一篇博客中</p>
<p>首先得有linux环境使用了 vs + ssh连接ubuntu虚拟机的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep ssh &#x2F;&#x2F; 查看有无安装ssh服务器</span><br><span class="line">sudo apt-get install openssh-server &#x2F;&#x2F; 安装</span><br></pre></td></tr></table></figure>

<p>解决vi无效乱码问题</p>
<p>Ubuntu 预装的vi 对应的是vim-tiny 需要改成 vim-full</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#卸载</span><br><span class="line">sudo apt-get remove vim-common </span><br><span class="line">#安装</span><br><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure>

<p>解决Ubuntu ens33 网卡消失的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service network-manager stop  # 先停止服务</span><br><span class="line"># 删除文件</span><br><span class="line">sudo rm -rf &#x2F;var&#x2F;lib&#x2F;NetworkManager&#x2F;NetworkManager.state </span><br><span class="line">#重启服务器</span><br><span class="line">service network-manager start</span><br></pre></td></tr></table></figure>

<h1 id="操作系统-暂不考虑-大二下有课程-可以先了解些基础"><a href="#操作系统-暂不考虑-大二下有课程-可以先了解些基础" class="headerlink" title="操作系统 - 暂不考虑, 大二下有课程, 可以先了解些基础"></a>操作系统 - 暂不考虑, 大二下有课程, 可以先了解些基础</h1><h1 id="数据库-暂不考虑-大二下有课程-可以先了解些基础"><a href="#数据库-暂不考虑-大二下有课程-可以先了解些基础" class="headerlink" title="数据库 - 暂不考虑, 大二下有课程, 可以先了解些基础"></a>数据库 - 暂不考虑, 大二下有课程, 可以先了解些基础</h1><h1 id="网络基础知识-暂不考虑-大二下有课程-可以先了解些基础"><a href="#网络基础知识-暂不考虑-大二下有课程-可以先了解些基础" class="headerlink" title="网络基础知识 - 暂不考虑, 大二下有课程, 可以先了解些基础"></a>网络基础知识 - 暂不考虑, 大二下有课程, 可以先了解些基础</h1>]]></content>
        
        <categories>
            
            <category> CPP </category>
            
            <category> 学习计划 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 服务器编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[C++Primer学习]]></title>
        <url>http://blog.lsmg.xyz/2019/08/CPP-CPP%25E5%259F%25BA%25E7%25A1%2580-1/</url>
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="c-11-的-初始方式"><a href="#c-11-的-初始方式" class="headerlink" title="c++11 的{}初始方式"></a>c++11 的{}初始方式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++11 的初始化方式, 有助于防范类型转换错误.</span></span><br><span class="line"><span class="keyword">int</span> a1 = &#123; <span class="number">24</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> b1 = &#123;&#125;; <span class="comment">// 默认为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有 = 同样可以</span></span><br><span class="line"><span class="keyword">int</span> a2 &#123; <span class="number">24</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> b2 &#123;&#125;; <span class="comment">// 默认为0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>无符号的变量在 超出范围的时候对应变化<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%9A%84%E9%87%8D%E7%BD%AE%E7%82%B9.jpg" alt=""></p>
<h2 id="转义字符表"><a href="#转义字符表" class="headerlink" title="转义字符表"></a>转义字符表</h2><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/c%2B%2B%E8%BD%AC%E4%B9%89.jpg" alt=""></p>
<h2 id="char-在默认情况下-既不是有符号-也不是无符号"><a href="#char-在默认情况下-既不是有符号-也不是无符号" class="headerlink" title="char 在默认情况下, 既不是有符号. 也不是无符号."></a>char 在默认情况下, 既不是有符号. 也不是无符号.</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a; <span class="comment">// 此时a可能是 signed char 也可能是 unsigned char 可能会在不同系统之前产生错误</span></span><br><span class="line"><span class="comment">// 可以显式声明, 来确保不会出现此错误</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> a;</span><br></pre></td></tr></table></figure>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(name, <span class="number">10</span>); <span class="comment">// 可以读取换行符, 但不保存</span></span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(name, <span class="number">10</span>); <span class="comment">// 不读取换行符, 可能导致get到换行符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空行和超出长度问题 将在后面说明</span></span><br></pre></td></tr></table></figure>
<p>运算符优先级<br><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=59a3e1017d3e6709aa0d4dad5aaef458/63d9f2d3572c11df57c9a205612762d0f703c2f8.jpg" alt=""></p>
<h2 id="基础的数组"><a href="#基础的数组" class="headerlink" title="基础的数组"></a>基础的数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">// 下方由于 new 只是返回一个地址所以用 int* 接收 </span></span><br><span class="line"><span class="keyword">int</span>* b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(a + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="对指针解引用"><a href="#对指针解引用" class="headerlink" title="对指针解引用"></a>对指针解引用</h2><p>第一印象是 解除引用, 然而并不是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">"*"的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。也就是说，解引用是返回内存地址中保存的值。</span></span><br><span class="line"><span class="comment">比如int a=10; int *p=&amp;a;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;*p&lt;&lt;endl; 输出a的值，就是解引用操作。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="c-风格字符串相关"><a href="#c-风格字符串相关" class="headerlink" title="c 风格字符串相关"></a>c 风格字符串相关</h2><p>对字符数组的赋值, 不建议使用 = 赋值, 可能会导致内存覆盖<br>建议使用 <code>strncpy(目标位置, 字符串, 长度)</code> 然后手动在目标字符数组最后一位写入<code>\0</code><br>这样安全, 不过这是c风格的, 在c++中可以使用<strong>string来代替字符数组</strong></p>
<h2 id="自动变量-静态存储-动态存储"><a href="#自动变量-静态存储-动态存储" class="headerlink" title="自动变量 静态存储 动态存储"></a>自动变量 静态存储 动态存储</h2><p>自动变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">getInut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> temp[<span class="number">100</span>]; <span class="comment">// 局部变量(自动变量), 函数结束时自动释放 存入栈中</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">	<span class="keyword">char</span>* pn = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(temp) + <span class="number">1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(pn, temp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态存储 通过new 和 delete操作内存池(自由存储空间, 堆)</p>
<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>代码可以使用throw来抛出异常<br><em>大部分</em>可以指定msg来初始化异常<br>throw exception_type(“msg”)<br>表中exception不能指定msg, 来初始化, 除此外表中其他都需要msg初始</p>
<table>
<thead>
<tr>
<th>错误名称</th>
<th>对应原因</th>
</tr>
</thead>
<tbody><tr>
<td>exception</td>
<td>最常见的问题</td>
</tr>
<tr>
<td>runtime_error</td>
<td>只有运行的时候才能查到错误</td>
</tr>
<tr>
<td>range_error</td>
<td>运行时错误: 超范围</td>
</tr>
<tr>
<td>overflow_error</td>
<td>运行时错误: 上溢</td>
</tr>
<tr>
<td>underflow_error</td>
<td>运行时错误: 下溢</td>
</tr>
<tr>
<td>logic_error</td>
<td>程序逻辑错误</td>
</tr>
<tr>
<td>domain_error</td>
<td>程序逻辑错误: 参数对应的结果不存在</td>
</tr>
<tr>
<td>invalid_argument</td>
<td>程序逻辑错误: 无效参数</td>
</tr>
<tr>
<td>length_error</td>
<td></td>
</tr>
<tr>
<td>out_of_range</td>
<td>程序逻辑错误: 超范围</td>
</tr>
</tbody></table>
<h1 id="函数相关"><a href="#函数相关" class="headerlink" title="函数相关"></a>函数相关</h1><p><strong>默认参数</strong><br>函数可以设定默认参数.</p>
<p>在调用设置有默认参数的函数时只能省略右边的带默认值参数<br>如果一个参数设置了默认值, 则其右边的参数都需要设置默认值</p>
<p>如果一个函数在头文件中已经声明了默认参数, 实现的时候不能更该已经设定的默认参数</p>
<p>但可以将未设置默认参数的函数设置默认参数</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png" alt=""></p>
<p>使用unique_ptr的时候要注意</p>
<ol>
<li>不要再函数调用传参的括号中 使用临时变量 这样一旦函数调用完成就会被销毁<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span> ))</span> </span>; <span class="comment">// 引用 = 1</span></span><br><span class="line"><span class="built_in">process</span>(p); <span class="comment">// 拷贝 会递增它的引用计数 ;在 process 中引用计数位为2</span></span><br><span class="line"><span class="keyword">int</span> i = *p; <span class="comment">// 正确 引用计数为1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>; <span class="comment">// 危险 这是一个普通指针，不是一个智能指针</span></span><br><span class="line"><span class="built_in">process</span>(x) ; <span class="comment">// 错误 不能将 int* 转换为 一个 shared_ptr&lt;int&gt; </span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; (x)); <span class="comment">// 合法的，但内存会被释放! 因为临时对象会被销毁</span></span><br><span class="line"><span class="keyword">int</span> j =*x <span class="comment">//未定义的 是一个空悬指针!</span></span><br></pre></td></tr></table></figure></li>
<li>如果使用unique_ptr不要使用get函数初始化另一个智能指针或为其赋值<br>因为一旦新生成的智能指针离开作用域或者被释放, 会影响到原来的智能指针<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>); <span class="comment">// 不能将一个int* 赋值给shared_ptr&lt;int&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1;</span><br><span class="line">p1.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>)); <span class="comment">// 可以</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>))</span></span>; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用make_share来创建shared_ptr指针</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">auto</span> p4 = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// make_share不能用来创建unique_ptr</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d1</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>))</span></span>;</span><br></pre></td></tr></table></figure>
unique_ptr不支持普通的赋值和拷贝操作, 因为unique_ptr要独占所指向的对象</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d1</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span></span>; </span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">8</span>))</span></span>; </span><br><span class="line"></span><br><span class="line">d1.<span class="built_in">release</span>(); <span class="comment">// 释放原来所指向的对象</span></span><br><span class="line">d1.reset(d2.<span class="built_in">release</span>()); <span class="comment">// d2释放后由d1获取</span></span><br></pre></td></tr></table></figure>

<h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><p><strong>顺序访问</strong>: 访问元素的成本<em>(最常见的成本-时间成本)</em>与元素的位置<strong>有关</strong></p>
<p><strong>随机访问</strong>: 访问元素的成本<em>(最常见的成本-时间成本)</em>与元素的位置<strong>无关</strong></p>
<h2 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h2><p>以下三个成员从C++11加入,<br>emplace_front: 放在容器头部<br>emplace_back: 放在容器尾部<br>emplace: 放在容器的任意位置</p>
<p>与push_front insert push_back不同的是<br>新的三个成员通过传入参数构造 而原来的三个成员需要通过传入构造好的对象传入</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dialogue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">	<span class="keyword">int</span> phone_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Dialogue(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="keyword">int</span> &amp;phone):name_(name), phone_(phone)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Dialogue&gt; a&#123;&#125;;</span><br><span class="line">	a.push_back(Dialogue(<span class="string">"xiao"</span>, <span class="number">1</span>));</span><br><span class="line">	a.emplace_back(<span class="string">"xiao"</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
        
        <categories>
            
            <category> CPP </category>
            
            <category> CPP基础 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[IDEA基本使用记录]]></title>
        <url>http://blog.lsmg.xyz/2019/07/Java-IDEA/</url>
        <content type="html"><![CDATA[<div class="alert-red">目前主要记录一部分快捷键</div>
<a id="more"></a>

<h3 id="快捷编辑部分"><a href="#快捷编辑部分" class="headerlink" title="快捷编辑部分"></a>快捷编辑部分</h3><p>Ctrl + Y    删除光标所在行 或 删除选中的行 （必备）<br>剪切复制    默认都可以对本行操作<br>Ctrl + Delete    删除光标后面的单词或是中文句 （必备）<br>Ctrl + BackSpace    删除光标前面的单词或是中文句 （必备）</p>
<hr>
<p>Ctrl + Alt + Enter    光标所在行上空出一行，光标定位到新行 （必备）<br>Ctrl + Shift + Z    取消撤销 （必备）<br>Ctrl + Shift + Alt + V    无格式黏贴 （必备）</p>
<h3 id="快捷移动"><a href="#快捷移动" class="headerlink" title="快捷移动"></a>快捷移动</h3><p>Ctrl + <code>[</code>    移动光标到当前所在代码的花括号开始位置<br>Ctrl + <code>]</code>    移动光标到当前所在代码的花括号结束位置<br>Ctrl + F3    调转到所选中的词的下一个引用位置 （必备）</p>
<p>Ctrl + 左方向键    光标跳转到当前单词 / 中文句的左侧开头位置 （必备）<br>Ctrl + 右方向键    光标跳转到当前单词 / 中文句的右侧开头位置 （必备）<br>Ctrl + 前方向键    等效于鼠标滚轮向前效果 （必备）<br>Ctrl + 后方向键    等效于鼠标滚轮向后效果 （必备）</p>
<hr>
<p><em>Ctrl + Alt + 左方向键    退回到上一个操作的地方 （必备）<br>Ctrl + Alt + 右方向键    前进到上一个操作的地方 （必备）</em></p>
<h3 id="查找部分"><a href="#查找部分" class="headerlink" title="查找部分"></a>查找部分</h3><p>Ctrl + W    递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）<br>Ctrl + Shift + W    递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）</p>
<p>Ctrl + E    显示最近打开的文件记录列表 （必备）<br>Ctrl + N    根据输入的 类名 查找类文件 （必备）<br>Ctrl + U    前往当前光标所在的方法的父类的方法 / 接口定义 （必备）<br>Ctrl + B    进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击 （必备）</p>
<hr>
<p>Shift + F2    跳转到上一个高亮错误 或 警告位置</p>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>Ctrl + P    方法参数提示显示 （必备）<br>Ctrl + Q    光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容<br>Ctrl + +    展开代码<br>Ctrl + -    折叠代码</p>
<hr>
<h3 id="修改编码"><a href="#修改编码" class="headerlink" title="修改编码"></a>修改编码</h3><p>File -&gt; Settings -&gt; File Encodings -&gt; Default encoding for properties file -&gt; UTF-8<br>然后需要勾选<br><code>Transparent native-to-ascii conversion</code></p>
]]></content>
        
        <categories>
            
            <category> Java </category>
            
            <category> IDEA的使用 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[暑假学习记录与总结]]></title>
        <url>http://blog.lsmg.xyz/2019/07/%25E6%259A%2591%25E5%2581%2587%25E5%25AD%25A6%25E4%25B9%25A0%25E8%25AE%25B0%25E5%25BD%2595%25E4%25B8%258E%25E6%2580%25BB%25E7%25BB%2593/</url>
        <content type="html"><![CDATA[<div class="alert-red">では、ゲームを始(はじ)めましょう</div>

<p>自己与研究生无缘了, 不过嘛, 是好是坏我也不知道, 现在也只能多学点技术, 去工作了, 这个暑假很重要, 所以将会每天记录下.</p>
<p><a href="https://imgurl.org/" target="_blank" rel="noopener">在线图床</a><br><a href="https://blog.csdn.net/lovelion/article/details/17517213" target="_blank" rel="noopener">设计模式主要学习</a><br>设计模式次要补充 – head first java 设计模式</p>
<a id="more"></a>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/4.png" alt=""><br>总结一下这个暑假都干了什么, 马上就要开学了.<br>七月十三日到七月十九日, 这是第一周了.这一周伴随着到处参观, 收货很少了. 那时我还在主用Java, 主要的是学习了一些设计模式, 这一周的时间对我学习C++ 帮助也是有的. 暑假学习设计模式也是出于换语言的考虑.<br>第一天(七月十三日)可以说是看的最多的了解了什么是耦合和解耦, 一些简单的设计模式(简单工厂, 工厂方法, 抽象工厂, 单例模式).<br>第二天(七月十四日) 开始初步试验大创项目的实现, 当时遇到一个BUG, 我需要返回一个东西, 但我还是需要返回后将他删除, 首先就是将他”复制了一份”, 然后删除, 却发现返回去的都是空的,了解到了Java如何进行深拷贝.<br>七月十六日看了下Java编程思想的多态部分, 然后主要时间修改网络助手的开机启动设置, 这样开机启动设置就没有问题了.<br>七月十七日收拾家伙, 休息了休息准备回家, 结果虽然我确认了好几次自己有没有带全家伙, 鼠标笔记本都带上了,<br>七月十八日到达北京去我姐那里暂住了, 结果发现我…..光带回了一个鼠标, 鼠标的接收器还在USB分线器上(吐血) 然后开始了一个开源项目的阅读. 云收藏(SpringBoot框架). 发现了自己没有看懂的东西(Stirng …), 就去了解下JDK从5-8每次更新加入的内容,了解到那个叫做可变参数需要搭配增强for循环使用<br>七月十九日-七月二十日我终于实现了自己理想….怎么说呢北方最大的漫展依然没有我想象的大, 等我有机会既定要去一次南方</p>
<p>七月二十一日到七月二十七日写了个后端练手(一个失物招领) . 使用了丝袜哥写Api文档, SpringJpa作为持久层? 这几天放松了玩了几天游戏可惜了.<br>七月二十八日总结两个小项目比较靠近项目的地方, 统一返回类型, 预定义数据, SpringJpa.<br>.学习了 接口 内部类 持有对象. 通过查看源码解决了一个Bug,<br>七月二十九日到八月二日 编写二手交易后台.</p>
<p>想去了解下大数据相关内容<br>八月三日到八月九日 看了下关于大数据的内容, 并不是很感兴趣.<br>八月十日到八月十五日 主要是写算法题目, 然后寻找自己是佛要从事游戏服务器编程<br>八月十六日到八月二十四日 上午复习高数, 下午看C++<br>@2019年8月24日18:21:07@</p>
<h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><p>设计模式不求多, 但求会用, 极大概率调整设计模式的学习.<br>此外需要刷一些常用的算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">7.13-7.19</span><br><span class="line">&lt;复用类, 多态&gt;</span><br><span class="line">---六个创建型模式</span><br><span class="line">- 简单工厂模式</span><br><span class="line">- 工厂方法模式</span><br><span class="line">- 抽象工厂模式</span><br><span class="line">- 单例模式</span><br><span class="line">- 原型模式(略过)</span><br><span class="line">- 建造者模式(略过)</span><br><span class="line">7.20-7.26</span><br><span class="line">&lt;接口, 内部类, 持有对象&gt;</span><br><span class="line">---七个结构型模式</span><br><span class="line">- 适配器模式</span><br><span class="line">- 桥接模式</span><br><span class="line">- 组合模式</span><br><span class="line">- 外观模式</span><br><span class="line">7.27-8.02</span><br><span class="line">&lt;类型信息, 泛型&gt;</span><br><span class="line">- 装饰模式</span><br><span class="line">- 享元模式(略过)</span><br><span class="line">- 代理模式</span><br><span class="line">8.03-8.09</span><br><span class="line">&lt;数组, 容器深入研究&gt;</span><br><span class="line">---十一个行为型模式</span><br><span class="line">- 职责链模式</span><br><span class="line">- 命令模式</span><br><span class="line">- 解释器模式(略过)</span><br><span class="line">- 迭代器模式</span><br><span class="line">- 中介者模式(略过)</span><br><span class="line">- 备忘录模式(略过)</span><br><span class="line">- 观察者模式</span><br><span class="line">8.10-8.16</span><br><span class="line">&lt;IO, 枚举类型&gt;</span><br><span class="line">- 状态模式</span><br><span class="line">- 策略模式</span><br><span class="line">- 模板方法模式</span><br><span class="line">- 访问者模(略过)</span><br><span class="line">8.17-8.23</span><br><span class="line">&lt;注解, 并发&gt;</span><br></pre></td></tr></table></figure>
<h1 id="では、ゲームを始-はじ-めましょう"><a href="#では、ゲームを始-はじ-めましょう" class="headerlink" title="では、ゲームを始(はじ)めましょう"></a>では、ゲームを始(はじ)めましょう</h1><h2 id="7-13-7-19"><a href="#7-13-7-19" class="headerlink" title="7.13-7.19"></a>7.13-7.19</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">7.13-7.19</span><br><span class="line">&lt;复用类, 多态&gt;</span><br><span class="line">---六个创建型模式</span><br><span class="line">- 简单工厂模式</span><br><span class="line">- 工厂方法模式</span><br><span class="line">- 抽象工厂模式</span><br><span class="line">- 单例模式</span><br></pre></td></tr></table></figure>
<h3 id="7月13日"><a href="#7月13日" class="headerlink" title="7月13日"></a>7月13日</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 简单工厂模式</span><br><span class="line">- 工厂方法模式</span><br><span class="line">- 抽象工厂模式</span><br><span class="line">- 单例模式</span><br></pre></td></tr></table></figure>

<p>2019年7月13日12:21:17<br>上午参观参观参观…… 重置了下, 这个暑期表格.今天开始第一天的打卡.下午还有参观, 然后就可以开始学了</p>
<p>下午有b站血族直播<br>下午看了一个项目, 自己不会的还是太多,,,,,, 给了源码都看不太懂.<br>还是先继续看几个设计模式吧, 设计模式目前想的是, 了解大概, 等到时用到了再去详细学习</p>
<h4 id="耦合与解耦"><a href="#耦合与解耦" class="headerlink" title="耦合与解耦"></a>耦合与解耦</h4><p>耦合: 两个或两个以上的体系之间互相结合, 互相影响, 产生的一个联合起来解决问题的体系.<br>这种体系, 不利于修改, 修改一个体系可能会影响到另一个体系, 使得另一个体系需要做出修改.<br>解耦: 将体系之间的联系降到最低, 各司其职, 修改本身的时候, 不需要去动其他的体系</p>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简单工厂模式不属于GoF 23种设计模式<br>通过设计一个父类(产品类), 由他派生出多个子类(具体产品类), 通过一个工厂类, 提供给工厂类生产方法不同的参数, 由工厂类return相应的子类, 由父类接受.</p>
<p>解决问题: 通过工厂类, 只需要记住参数, 就可以产生相应的子类,<br>存在问题: 不符合开闭原则, 每次产生新的产品, 都需要去修改相应的工厂生产方法.</p>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>与简单工厂有些相似之处: 均存在一个产品父类和多个产品子类.<br>不同之处在于 工厂方法模式, 设置了工厂父类, 通过派生出不同的工厂子类来return相应的子类.</p>
<p>解决问题: 解决了简单工厂模式的开闭原则, 每次产生新的产品, 只需要派生一个相应的子类即可<br>存在问题: 系统中由于新产品的产生, 类的个数将会成对增加, 会有更多的类需要处理</p>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>抽象工厂模式解决了工厂方法模式某些情况下 导致的类成对增加情况<br>一个抽象工厂里包含了这个”工厂”的所有产品–这对应了一个产品族<br>可以派生出多个工厂来实现多品牌产品–形成了一个等级结构<br><img src="https://img-blog.csdn.net/20130713162941328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="引用自上文博客"></p>
<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>这个模式理解起来很容易, 但是效果却十分的不错, 之前用过一次所以详细写一下.<br><strong>饿汉式单例模式</strong><br>饿汉式单例模式 无延迟加载 不需要解决多线程问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> singletonpattern.Connect</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * 饿汉式单例模式 无延迟加载 不需要解决多线程问题</span></span><br><span class="line"><span class="comment"> * Author lsmg</span></span><br><span class="line"><span class="comment"> * Date 2019/5/21 13:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Connect instance = <span class="keyword">new</span> Connect();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connect <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>懒汉式单例模式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singletonpattern;</span><br><span class="line">懒汉式单例模式 实现了延迟加载,但需要解决多线程问题</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> singletonpattern.Connect1_2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式 实现了延迟加载,但需要解决多线程问题</span></span><br><span class="line"><span class="comment"> * Author lsmg</span></span><br><span class="line"><span class="comment"> * Date 2019/5/21 13:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Connect1_2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connect1_2  connect1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Connect1_2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种方式会造成多线程访问的时候实例化多个对象</span></span><br><span class="line"><span class="comment">//    public  static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class="line"><span class="comment">//        if(connect1_2 == null)&#123;</span></span><br><span class="line"><span class="comment">//            connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        return connect1_2;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种方式虽然确保了只有一个线程进入, 但是降低了多线程的性能</span></span><br><span class="line"><span class="comment">//    public synchronized static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class="line"><span class="comment">//        if(connect1_2 == null)&#123;</span></span><br><span class="line"><span class="comment">//            connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        return connect1_2;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种方式需要在private "volatile" static singletonpattern.Connect1_2 connect1_2 这样同样降低效率</span></span><br><span class="line"><span class="comment">//    public synchronized static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class="line"><span class="comment">//        if(connect1_2 == null)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            synchronized (singletonpattern.Connect1_2.class)&#123;</span></span><br><span class="line"><span class="comment">//                if(connect1_2 == null)&#123;</span></span><br><span class="line"><span class="comment">//                    connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        return connect1_2;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>使用IoDH方法结合二者优点</strong><br>由于静态单例对象没有作为Singleton的成员变量直接初始化, 当调用<code>getInstance()</code>方法的时候, 会加载内部类HolderClass, 其中的static 由Java虚拟机保证线程安全性, 这样就结合了<code>饿汉式单例模式的线程安全</code>和<code>懒汉式单例模式的延迟加载</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Initialization on Demand Holder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderClass</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> HolderClass.instance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">	    Singleton s1, s2; </span><br><span class="line">        s1 = Singleton.getInstance();</span><br><span class="line">	    s2 = Singleton.getInstance();</span><br><span class="line">	    System.out.println(s1==s2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@2019年7月13日19:07:46 设计模式暂时到这里, 去写写代码吧@</p>
<h3 id="7月14日"><a href="#7月14日" class="headerlink" title="7月14日"></a>7月14日</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">复用类看了一部分, 目前还差final部分</span><br></pre></td></tr></table></figure>
<p>@2019年7月14日09:43:46@</p>
<p>下午看了看大创项目的实现, 选择了高德地图api. 中午的时候太困了 搞得我没有仔细看<br>目前决定采用<a href="https://lbs.amap.com/api/amap-ui/demos/amap-ui-pathsimplifier/expand-path" target="_blank" rel="noopener">动态延展路径</a>  解决问题, path由ajax 异步获取更新.</p>
<h4 id="小插曲-Java-List深浅拷贝"><a href="#小插曲-Java-List深浅拷贝" class="headerlink" title="小插曲-Java List深浅拷贝"></a>小插曲-Java List深浅拷贝</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(<span class="string">"droneStatusService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DroneStatusServiceImpl</span> <span class="keyword">implements</span> <span class="title">DroneStatusService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(DroneStatusServiceImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;DroneStatus&gt; droneStatusList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">/**删除其他代码**/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DroneStatus&gt; <span class="title">listDroneStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;DroneStatus&gt; theDroneStatusList = droneStatusList;</span><br><span class="line">		droneStatusList.clear(); <span class="comment">/**这样导致了我的return list一直为空**/</span></span><br><span class="line">        logger.info(<span class="string">"清除一次信息list共"</span>+theDroneStatusList.size()+<span class="string">"条"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> theDroneStatusList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一印象这样写, 排查方法就是想到了关于Java引用的部分.<br>对于list的拷贝 <code>遍历循环复制</code>和<code>List的构造方法</code>和<code>list.addAll()</code>以及<code>System.arraycopy()</code> 这些全部是<code>浅复制</code>他们指向了同一片内存区域</p>
<p>深复制的实现方法另实体类 实现Cloneable接口 重写clone方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Entity entity = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		entity = (Entity)  <span class="keyword">super</span>.clone();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我写了一个工具类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Entity&gt; <span class="title">deepCopy</span><span class="params">(List&lt;Entity&gt; originList)</span> </span>&#123;</span><br><span class="line">	List&lt;Entity&gt; entityList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span>(Entity entity : originList) &#123;</span><br><span class="line">		entityList.add((Entity) entity.clone());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> entityList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个工具类实现深复制</p>
<p> <code>IDEA CTRL+ALT+T</code>收获这个快捷键<br><img src="https://i.bmp.ovh/imgs/2019/07/9fe10225fe9a52a5.png" alt=""><br>@2019年7月14日17:47:23@</p>
<p>大创先告一段落了, 等和他们对接吧, 基本功能显示路径已经做好了.<br>@2019年7月14日20:29:30@<br>复用类看完了<br>@2019年7月14日21:14:12@</p>
<h3 id="7月15日"><a href="#7月15日" class="headerlink" title="7月15日"></a>7月15日</h3><p>把GGO通关了, 游戏就告一段落了.</p>
<h3 id="7月16日"><a href="#7月16日" class="headerlink" title="7月16日"></a>7月16日</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多态</span><br></pre></td></tr></table></figure>
<p>把编程思想-多态看一下吧</p>
<p>多态这里怎么说呢, 重要的是思想吧, 自己没用过太多, 都是一些框架需要<br>@2019年7月16日08:42:35@</p>
<p>把书里的内容过了一遍, 怎么感觉不是很实用. 但是也说了一些小问题. 继承这种东西, 自己代码里都没有用太多.<br>@2019年7月16日09:25:47@</p>
<p>改了一部分BUG, 小软件的开机启动设置修改了下, 貌似可以了.<br>@2019年7月16日17:39:40@</p>
<h3 id="7月17日"><a href="#7月17日" class="headerlink" title="7月17日"></a>7月17日</h3><p>上午收拾了下,  下午的话休息了休息, 晚上去吃了顿好的, 收拾回家的东西</p>
<h3 id="7月18日"><a href="#7月18日" class="headerlink" title="7月18日"></a>7月18日</h3><p>上午坐了一上午的车, 下午到了北京, 然后把电脑的内存条换上了(现在是16G的内存了, 够用了). <strong>难受的是, 光带了鼠标没有带鼠标的接收器!!!!!!!(我以为插件可以代替接收器, 结果插线也得要接收器… 算了吧)</strong></p>
<h4 id="下午继续看了一部分-云收藏的源码看到了这个下面一个函数"><a href="#下午继续看了一部分-云收藏的源码看到了这个下面一个函数" class="headerlink" title="下午继续看了一部分 云收藏的源码看到了这个下面一个函数"></a>下午继续看了一部分 云收藏的源码看到了这个下面一个函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(getMessage(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String template, String... keys)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	StringBuilder templateBuilder = <span class="keyword">new</span> StringBuilder(template);</span><br><span class="line">	<span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">		templateBuilder.append(key);</span><br><span class="line">	&#125;</span><br><span class="line">	template = templateBuilder.toString();</span><br><span class="line">	<span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点不是函数的功能, 而是<code>String...</code>这不是写错了. 我去网上查了下, 这样这个函数就可以接受多个参数了<br><code>getMessage(&quot;template&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code> 接受参数后用 增强for循环以此取出就好</p>
<p><code>是从Java 5开始，Java语言对方法参数支持一种新写法，叫可变长度参数列表</code></p>
<p>正好在这里去搜集下每次Java更新, 所提供的新特性</p>
<h4 id="JDK5-新特性"><a href="#JDK5-新特性" class="headerlink" title="JDK5 新特性"></a>JDK5 新特性</h4><p>#自动装箱与拆箱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">10</span>); </span><br><span class="line"><span class="comment">//这个问题不大</span></span><br><span class="line">Integer b = <span class="number">100</span>; <span class="comment">//这里就把一个int自动转成了 integer类型(自动装箱)</span></span><br><span class="line"><span class="comment">//这里用到了 Integer的 valueOf()方法 实现的自动装箱</span></span><br><span class="line">b += <span class="number">100</span>; <span class="comment">//b = b + 100; 用intValue()来自动拆箱</span></span><br><span class="line"><span class="comment">//实现方式 b = Integer.valueOf(b.intValue() + 200);</span></span><br></pre></td></tr></table></figure>

<p>#枚举类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> </span><br><span class="line"><span class="comment">// switch可以 switch枚举类型</span></span><br></pre></td></tr></table></figure>

<p>#静态导入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.pow; </span><br><span class="line"><span class="comment">//静态导入的必须是静态方法</span></span><br><span class="line">System.out.println(Math.pow(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">//未使用静态导入</span></span><br><span class="line">System.out.println(pow(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">//使用静态导入</span></span><br></pre></td></tr></table></figure>

<p>#可变参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以在方法参数的类型中 加入三个`...`, 这样在方法体内可以使用for的增强循环来获得传入的多个参数.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(getMessage(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMessage</span><span class="params">(String template, String... keys)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	StringBuilder templateBuilder = <span class="keyword">new</span> StringBuilder(template);</span><br><span class="line">	<span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">		templateBuilder.append(key);</span><br><span class="line">	&#125;</span><br><span class="line">	template = templateBuilder.toString();</span><br><span class="line">	<span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>#增强for循环<br>#泛型 (Generic Type)<br>#内省</p>
<h4 id="JDK6-新特性"><a href="#JDK6-新特性" class="headerlink" title="JDK6 新特性"></a>JDK6 新特性</h4><p>#Desktop类和SystemTray类<br>第一个<code>Desktop</code>类<br>可以用来打开系统默认浏览器浏览指定的URL<br>打开系统默认邮件客户端给指定的邮箱发邮件<br>用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件)<br>用系统默认的打印机打印文档<br>第二个<code>SystemTray</code>类<br>可以用来在系统托盘区创建一个托盘程序.<br>Java的UI方面就不写太多了</p>
<p>@2019年7月18日20:47:07@</p>
<h4 id="Springboot配置文件"><a href="#Springboot配置文件" class="headerlink" title="Springboot配置文件"></a>Springboot配置文件</h4><p>在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式<br>其中{profile}对应你的环境标识</p>
<p>下面列举三个文件<br><code>application-dev.properties</code>：开发环境<br><code>application-test.properties</code>：测试环境<br><code>application-prod.properties</code>：生产环境<br>至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。<br><code>spring.profiles.active=dev</code></p>
<h3 id="7月19日"><a href="#7月19日" class="headerlink" title="7月19日"></a>7月19日</h3><p>今天的话在北京待了一天, 去看了看北方最大的漫展IDO, 怎么说呢比我想象的要小一点, 不过比徐州那个好太多了. 以后有机会的话就去南方了.</p>
<h2 id="7-20-7-26"><a href="#7-20-7-26" class="headerlink" title="7.20-7.26"></a>7.20-7.26</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;接口, 内部类, 持有对象&gt;</span><br><span class="line">---七个结构型模式</span><br><span class="line">- 适配器模式</span><br><span class="line">- 桥接模式</span><br><span class="line">- 组合模式</span><br><span class="line">- 外观模式</span><br></pre></td></tr></table></figure>

<h3 id="7月20日"><a href="#7月20日" class="headerlink" title="7月20日"></a>7月20日</h3><p>今天还是胳膊有些疼, 昨天拿的东西不少, 背的也不少.走的路也不少…..<br>@2019年7月20日19:39:08@</p>
<p>现在来看一些东西吧. 上个寒假在家里留了一本Java编程思想.</p>
<h3 id="7月21日"><a href="#7月21日" class="headerlink" title="7月21日"></a>7月21日</h3><p>写了个新的小项目, 正好来练练手. 新项目单独列出一篇博客.</p>
<h3 id="7月22日"><a href="#7月22日" class="headerlink" title="7月22日"></a>7月22日</h3><p>在家里午觉睡不着我凑, 改下小项目的问题.<br>@去看一下设计模式吧@</p>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>这个设计模式怎么说呢, 挺简单的.<br>就是 新建一个适配器类Adapter  引用一个需要适配的类Adaptee 这个类实现客户端的接口Target</p>
<p>这样客户端直接调用接口 相关转换工作在接口中完成.</p>
<h2 id="7-27-8-02"><a href="#7-27-8-02" class="headerlink" title="7.27-8.02"></a>7.27-8.02</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型信息, 泛型&gt;</span><br><span class="line">- 装饰模式</span><br><span class="line">- 享元模式(略过)</span><br><span class="line">- 代理模式</span><br></pre></td></tr></table></figure>

<h3 id="7月28日"><a href="#7月28日" class="headerlink" title="7月28日"></a>7月28日</h3><p>从7.23-7.25 写了个小项目, 失物招领的后端.<br>总的来说有 </p>
<h4 id="统一反应类型"><a href="#统一反应类型" class="headerlink" title="统一反应类型"></a>统一反应类型</h4><p>将所有的返回结果, 写在一个类中</p>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951.png" alt=""></p>
<p>预先定义的异常信息, 则使用了enum</p>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952.png" alt=""></p>
<p>封装反回数据, 使用Object</p>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953.png" alt=""></p>
<p>这样处理后就可以</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ResponseData(ExceptionMsg.DEL_FAILED);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ResponseData(ExceptionMsg.DEL_FAILED);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  <span class="keyword">new</span> ResponseData(ExceptionMsg.SUCCESS, lostAndFoundInfo);</span><br></pre></td></tr></table></figure>

<p>来统一返回类型</p>
<h4 id="Spring-Jpa的方便"><a href="#Spring-Jpa的方便" class="headerlink" title="Spring Jpa的方便"></a>Spring Jpa的方便</h4><p>配置完毕后, 去编写相应的实体类</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/lostandfound?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class="line"><span class="string">spring.datasource.username=root</span></span><br><span class="line"><span class="string">spring.datasource.password=root</span></span><br><span class="line"><span class="string">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="string">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create：只要每次加载 Hibernate 时就都会删除上一次生成的表，然后根据 model 类再重新来生成新表. </span></span><br><span class="line"><span class="comment"># create-drop：每次加载 Hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭，表就自动删除。</span></span><br><span class="line"><span class="comment"># update：最常用的属性，第一次加载 Hibernate 时根据 model 类会自动建立起表的结构（前提是先建立# # 好数据库），以后加载 Hibernate 时根据 model 类自动更新表结构，即使表结构改变了，但表中的行仍然存在，不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。</span></span><br><span class="line"><span class="comment">#validate ：每次加载 Hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</span></span><br><span class="line"><span class="string">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span> <span class="comment">//这里可以通过value属性指定表名, 如果不指定则为类名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span> <span class="comment">//默认情况下会创建新表来存储id位置, 如果指定 strategy= GenerationType.IDENTITY 则会在一张表中存储位置id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>， unique = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>， unique = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">true</span>， unique = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> String regTime;</span><br><span class="line">    <span class="comment">//省略 getter settet 方法、构造方法  在这里getter setter 影响 Controller 的 return的内容. 有get方法才会在json中含有该项, 如果不想让该项出现在json中 则不需要写对应的get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后编写实体类对应的repository接口 继承 JpaRepository&lt;model, Long&gt;</p>
<p>就可使用自带的一些方法.</p>
<h4 id="去继续学习吧"><a href="#去继续学习吧" class="headerlink" title="去继续学习吧"></a>去继续学习吧</h4><p>&lt;接口, 内部类, 持有对象&gt;</p>
<p>重写Readable导致的bug.<br>再Main方法里产生随机单词, 导致异常<code>BufferOverflowException</code> , 首先思考的是每次调用<code>read()</code>方法应该会传入一个新的<code>CharBuffer</code>吧(实际并不是, 后面说)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Scanner scanner = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> RandomWords(<span class="number">100000</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">		System.out.println(scanner.next());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RandomWords.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomWords</span> <span class="keyword">implements</span> <span class="title">Readable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] CAPITALS =</span><br><span class="line">			<span class="string">"ABCDEFGHIGKLMNOPQRSTUVWXYZ"</span>.toCharArray();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] LOWERS =</span><br><span class="line">			<span class="string">"abcdefghigklmnopqrstuvwxyz"</span>.toCharArray();</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RandomWords</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count = count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(CharBuffer cb)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(count-- == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cb.append(CAPITALS[random.nextInt(CAPITALS.length)]);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> maxCount = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxCount; i++) &#123;</span><br><span class="line">			cb.append(LOWERS[random.nextInt(LOWERS.length)]);</span><br><span class="line"></span><br><span class="line">			<span class="comment">//System.out.println(cb.limit() + " - " + cb.position());</span></span><br><span class="line">			cb.append(CAPITALS[random.nextInt(CAPITALS.length)]);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cb.append(<span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来到报错位置, 这一段是CharBuffer源码里的部分, 发现是由于position &gt;= limit导致的异常, 然后查找得到这两个值得获取方法position()和limit();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nextPutIndex</span><span class="params">()</span> </span>&#123;                          <span class="comment">// package-private</span></span><br><span class="line">	<span class="keyword">if</span> (position &gt;= limit)</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BufferOverflowException();</span><br><span class="line">	<span class="keyword">return</span> position++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在RandomWords.java代码加入 <code>System.out.println(cb.limit() + &quot; - &quot; + cb.position());</code> 位置见上文注释代码</p>
<p>经过打印发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AyAvFkNuM</span><br><span class="line">1024 - 1002</span><br><span class="line">1024 - 1004</span><br><span class="line">1024 - 1006</span><br><span class="line">1024 - 1008</span><br><span class="line">RcEsZqFwO</span><br><span class="line">1024 - 1012</span><br><span class="line">1024 - 1014</span><br><span class="line">1024 - 1016</span><br><span class="line">1024 - 1018</span><br><span class="line">HxEsXaStX</span><br><span class="line">1024 - 1022</span><br><span class="line">1024 - 1024</span><br></pre></td></tr></table></figure>
<p>position属性并没有随着每次调用read() 方法重置, 所以每次调用read()方法传入的是同一个 <code>CharBuffer</code>. 回到Scanner源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Scanner.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过查找找到调用read()方法的地方</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (buf.limit() == buf.capacity())</span><br><span class="line">            makeSpace();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Prepare to receive data</span></span><br><span class="line">        <span class="keyword">int</span> p = buf.position();</span><br><span class="line">        buf.position(buf.limit());</span><br><span class="line">        buf.limit(buf.capacity());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">//这里调用了source.read()  source就是构造方法传入的在RandomWords对象</span></span><br><span class="line">            n = source.read(buf);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            lastException = ioe;</span><br><span class="line">            n = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">            sourceClosed = <span class="keyword">true</span>;</span><br><span class="line">            needInput = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            needInput = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Restore current position and limit for reading</span></span><br><span class="line">        buf.limit(buf.position());</span><br><span class="line">        buf.position(p);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>发现其传入了<code>buf</code>参数, 查找<code>buf</code>来到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Scanner</span><span class="params">(Readable source, Pattern pattern)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">assert</span> source != <span class="keyword">null</span> : <span class="string">"source should not be null"</span>;</span><br><span class="line">	<span class="keyword">assert</span> pattern != <span class="keyword">null</span> : <span class="string">"pattern should not be null"</span>;</span><br><span class="line">	<span class="keyword">this</span>.source = source;</span><br><span class="line">	delimPattern = pattern;</span><br><span class="line">	buf = CharBuffer.allocate(BUFFER_SIZE);</span><br><span class="line">	buf.limit(<span class="number">0</span>);</span><br><span class="line">	matcher = delimPattern.matcher(buf);</span><br><span class="line">	matcher.useTransparentBounds(<span class="keyword">true</span>);</span><br><span class="line">	matcher.useAnchoringBounds(<span class="keyword">false</span>);</span><br><span class="line">	useLocale(Locale.getDefault(Locale.Category.FORMAT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现是这个构造方法 对buf进行的赋值, 而    <code>Scanner(Readable source)</code>这个构造方法也只是调用的上一个构造方法.</p>
<p>所以问题解决了, 由于我是在一开始就实例化了一个<code>Scanner对象</code>. 导致传入<code>read()</code>方法的<code>buf</code>都是同一个 才导致的上文报错.</p>
<p>@2019年7月28日19:18:23@</p>
<p>囫囵吞枣的看完了接口<br>看了一部分内部类. 感觉很没有实感..<br>联系的太少了, 对他所说的没有感到<code>原来如此</code></p>
<h3 id="7月29日-8月2日"><a href="#7月29日-8月2日" class="headerlink" title="7月29日-8月2日"></a>7月29日-8月2日</h3><p>又写了一个二手交易的后台, 马上今天是八月二号, 这个假期也过了小一半了. </p>
<p>最近也看了看大数据相关的, 等这几天多看看关于大数据的, 也许我会选大数据专业emmm<br>@2019年8月2日20:22:20@<br>去看看ElasticSearch吧, 二手交易还差一个搜索</p>
<p>设置ip地址<br>关闭防火墙<br>关闭保护<br>删除映射管理文件<br>关机–&gt;克隆四台电脑<br>@2019年8月2日23:42:36@</p>
<h2 id="8-3-8-9"><a href="#8-3-8-9" class="headerlink" title="8.3-8.9"></a>8.3-8.9</h2><h3 id="8月3日"><a href="#8月3日" class="headerlink" title="8月3日"></a>8月3日</h3><p>大数据相关的删掉了, 移动到了单独的一篇博客</p>
<h3 id="8月4日"><a href="#8月4日" class="headerlink" title="8月4日"></a>8月4日</h3><p>大数据相关的删掉了, 移动到了单独的一篇博客</p>
<h3 id="8月8日"><a href="#8月8日" class="headerlink" title="8月8日"></a>8月8日</h3><p>继续学习大数据相关内容, 刷了一道算法题.待会看看Java IO流</p>
<p><em>暑期计划就到此了, 自己对于将来从事什么, 还是有些迷茫, 还是多去刷刷算法题目, 找找自己的路再走吧</em></p>
]]></content>
        
        <categories>
            
            <category> Java </category>
            
            <category> 第一个暑假学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 大学的第一个暑假 </tag>
            
            <tag> 暑假学习的大纲 </tag>
            
            <tag> 记录每天假期干了什么 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[校园网络助手更新]]></title>
        <url>http://blog.lsmg.xyz/2019/06/%25E5%25B0%258F%25E9%25A1%25B9%25E7%259B%25AE-%25E6%25A0%25A1%25E5%259B%25AD%25E7%25BD%2591%25E7%25BB%259C%25E5%258A%25A9%25E6%2589%258B%25E6%259B%25B4%25E6%2596%25B0/</url>
        <content type="html"><![CDATA[<p>这个星期把校园网络助手更新了一下, 连接部分重写了, 还有就是增加了问题反馈和其他内容<br><strong>未解决问题, 均与jvm虚拟机有关 首先是平台编码指定问题 再者为System.getProperty(“user.dir”)会得到system32文件夹</strong></p>
<a id="more"></a>
<h2 id="信息发送类"><a href="#信息发送类" class="headerlink" title="信息发送类"></a>信息发送类</h2><h3 id="信息的加入"><a href="#信息的加入" class="headerlink" title="信息的加入"></a>信息的加入</h3><p><strong>收获则为分离了 信息发送, 抽象为一个类 并使用队列存储信息</strong><br>这次的信息发送没有分开请求不同的URL 而是统一到了一个类中. 这个类中有个static的 队列<br>通过<code>addMessageToQue(String msg)</code>函数把要发送的信息 生成<code>Message</code>对象 加入队列之中.<br>有个<code>Message</code>类其中的<code>setMsg(String msg)</code>会自动生成信息发送的时间, 加入发送信息的ID.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addMessageToQue</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        DatabaseMessage databaseMessage = <span class="keyword">new</span> DatabaseMessage();</span><br><span class="line">        databaseMessage.setMsg(msg);</span><br><span class="line">        databaseMessageQueue.offer(databaseMessage);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="信息的发送"><a href="#信息的发送" class="headerlink" title="信息的发送"></a>信息的发送</h3><p>信息的发送由一个定时器控制, 每间隔一段时间判断队列是否为空.<br>如果队列不为空, 且当前存在网络则会进行信息的发送</p>
<h2 id="判断网络链接"><a href="#判断网络链接" class="headerlink" title="判断网络链接"></a>判断网络链接</h2><p>这次更改判断逻辑为 存在网络为主, 登录页面信息为辅的判断逻辑.<br>由于可能不存在网络, 直接<code>url.openStream()</code> 时间可能会非常之久才会抛出异常<br>更改代码为.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">URLConnection conn = url.openConnection();</span><br><span class="line">conn.setConnectTimeout(<span class="number">1000</span>);</span><br><span class="line">conn.setReadTimeout(<span class="number">1000</span>);</span><br><span class="line">conn.connect();</span><br><span class="line">conn.getInputStream();</span><br></pre></td></tr></table></figure>
<p>这样可以限制时间, 不过最佳的设置时间, 并没有进行测试为1S.</p>
<h2 id="判断登录页面信息"><a href="#判断登录页面信息" class="headerlink" title="判断登录页面信息"></a>判断登录页面信息</h2><p>登录页面直接爬取的话无法获取到相应的信息, 最后偶然发现, 登录请求的时候就有信息, 直接获取json即可.</p>
<p>json获取到后需要判断当前是否自动的登录, 如果是则判断状态码, 状态码不同则显示信息, 手动的话则一律显示.<br>对获取到的信息 经过函数处理得到相应的提示信息, 加入队列, 并且提示.</p>
<h2 id="对所有的msg加密"><a href="#对所有的msg加密" class="headerlink" title="对所有的msg加密"></a>对所有的msg加密</h2><p><strong>涉及到编码问题, 要注意指定编码, 出现乱码则要进行转换</strong><br>由于为了简单的得到加密 使用了固定秘钥的DES加密, 这其中出现了插曲.<br>未打成jar包前一切正常, 达成jar后乱码.经过排查最后锁定在了加密工具类中<br>其中有个<code>getBytes()</code>引起了我的注意</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Encodes this &#123;<span class="doctag">@code</span> String&#125; into a sequence of bytes using the</span></span><br><span class="line"><span class="comment">  * platform's default charset, storing the result into a new byte array.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * &lt;p&gt; The behavior of this method when this string cannot be encoded in</span></span><br><span class="line"><span class="comment">  * the default charset is unspecified.  The &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">  * java.nio.charset.CharsetEncoder&#125; class should be used when more control</span></span><br><span class="line"><span class="comment">  * over the encoding process is required.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span>  The resultant byte array</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span>      JDK1.1</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
<p>这里的注释明确说明了, 未指定的话则为平台默认的编码, 这个平台默认编码, 暂不清楚 //TODO</p>
<h2 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h2><p>最魔性的则为设置开机启动<br>由于管理员权限问题 最后使用了bat文件</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">cd</span> /d "%~dp0"</span><br><span class="line"><span class="built_in">cacls</span>.exe "<span class="variable">%SystemDrive%</span>\System Volume Information" &gt;<span class="built_in">nul</span> <span class="number">2</span>&gt;<span class="built_in">nul</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable">%errorlevel%</span>==<span class="number">0</span> <span class="keyword">goto</span> Admin</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">exist</span> "<span class="variable">%temp%</span>\getadmin.vbs" <span class="built_in">del</span> /f /q "<span class="variable">%temp%</span>\getadmin.vbs"</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">Set</span> RequestUAC = CreateObject^("Shell.Application"^)&gt;"<span class="variable">%temp%</span>\getadmin.vbs"</span><br><span class="line"><span class="built_in">echo</span> RequestUAC.ShellExecute "%~s0","","","runas",<span class="number">1</span> &gt;&gt;"<span class="variable">%temp%</span>\getadmin.vbs"</span><br><span class="line"><span class="built_in">echo</span> WScript.Quit &gt;&gt;"<span class="variable">%temp%</span>\getadmin.vbs"</span><br><span class="line">"<span class="variable">%temp%</span>\getadmin.vbs" /f</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">exist</span> "<span class="variable">%temp%</span>\getadmin.vbs" <span class="built_in">del</span> /f /q "<span class="variable">%temp%</span>\getadmin.vbs"</span><br><span class="line"><span class="keyword">exit</span></span><br><span class="line"></span><br><span class="line">:Admin</span><br><span class="line">reg delete HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run /v NetWork /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run /v NetWork /t reg_sz /d "%~dp0校园网络助手.exe"</span><br></pre></td></tr></table></figure>
<p>通过这个bat文件来实现获取管理员权限后 加入注册表<br>把这个文件放在exe外面, 感觉不是特别美观, 直接放在jar包里无法使用file来操作位置<br>最后通过获取流来写到硬盘解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeStartBat</span><span class="params">( )</span></span>&#123;</span><br><span class="line">    InputStream inputStream = classLoader.getResourceAsStream(<span class="string">"start.bat"</span>);</span><br><span class="line">    writeToLocal(path, inputStream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeToLocal</span><span class="params">(String destination, InputStream input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        FileOutputStream downloadFile = <span class="keyword">new</span> FileOutputStream(destination);</span><br><span class="line">        <span class="keyword">while</span> ((index = input.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            downloadFile.write(bytes, <span class="number">0</span>, index);</span><br><span class="line">            downloadFile.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        downloadFile.close();</span><br><span class="line">        input.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;e.printStackTrace();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图片同样可以 这样写入后吗加载完毕删除</p>
<p>不过还有一个问题在开机的时候 <code>System.getProperty(&quot;user.dir&quot;)</code> 这样会得到 system32文件夹!!!!!<br>这个问题还未搜索</p>
]]></content>
        
        <categories>
            
            <category> 项目制作 </category>
            
            <category> 中等项目 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 校园网络助手1.5 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[纯洁的微笑Gitchat 课程笔记2]]></title>
        <url>http://blog.lsmg.xyz/2019/06/Java-Springboot%25E5%259F%25BA%25E7%25A1%2580%25E7%259F%25A5%25E8%25AF%25862/</url>
        <content type="html"><![CDATA[<p>在Gitchat上 买了一个多月的 纯洁的微笑的SpringBoot讲解 这次来慢慢看看吧一共42讲 <a href="https://gitbook.cn/gitchat/column/5b86228ce15aa17d68b5b55a" target="_blank" rel="noopener">GitChat链接,不妨给一杯咖啡</a></p>
<a id="more"></a>

<p><strong>首先是约定优于配置, springboot已经定义好了大部分东西, 只有在不符合约定的时候, 才需要手动去配置相关文件</strong></p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>这个注解等于<code>@ResponseBody ＋ @Controller</code><br>返回json数据的便捷注解</p>
<h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p><code>@RequestMapping(name=&quot;/getUser&quot;, method= RequestMethod.POST)</code></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="MockMVC"><a href="#MockMVC" class="headerlink" title="MockMVC"></a>MockMVC</h3><p>MockMVC 可以进行POST GET 模拟请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="comment">//`@Before`注解的方法 在启动测试后首先执行, 来进行资源的初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc = MockMvcBuilders.standaloneSetup(<span class="keyword">new</span> HelloController()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">"/hello"</span>)</span><br><span class="line">          .accept(MediaType.APPLICATION_JSON_UTF8)).andDo(print());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p><a href="https://blog.lsmg.xyz/2019/05/18/dataInteraction/">之前的一篇博客, 传送门</a></p>
<h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><p>控制器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(name = <span class="string">"/saveUser"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(@Valid User user, BindingResult result)</span> </span>&#123; <span class="comment">//@Valid 代表对这个参数进行校验 BindingResult 用于存储校验结果</span></span><br><span class="line">    <span class="keyword">if</span>(result.hasErrors()) &#123;</span><br><span class="line">        List&lt;ObjectError&gt; list = result.getAllErrors();</span><br><span class="line">        <span class="keyword">for</span> (ObjectError error : list) &#123;</span><br><span class="line">            System.out.println(error.getCode()+ <span class="string">"-"</span> + error.getDefaultMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实体类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotEmpty</span>(message = <span class="string">"姓名不能为空"</span>)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@Max</span>(value = <span class="number">100</span>, message = <span class="string">"年龄不能大于100岁"</span>)</span><br><span class="line"><span class="meta">@Min</span>(value= <span class="number">0</span> ,message= <span class="string">"年龄必须大于0岁！"</span> )</span><br><span class="line"><span class="keyword">private</span> String sex;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure>
<p>对应的测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">"/saveUser"</span>)</span><br><span class="line">            .param(<span class="string">"name"</span>,<span class="string">""</span>)</span><br><span class="line">            .param(<span class="string">"age"</span>, <span class="string">"101"</span>)</span><br><span class="line">            .param(<span class="string">"sex"</span>, <span class="string">"男"</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Min-年龄必须大于0岁！</span></span><br><span class="line"><span class="comment">  NotEmpty-姓名不能为空</span></span><br><span class="line"><span class="comment">  Max-年龄不能大于100岁*/</span></span><br></pre></td></tr></table></figure>
<h3 id="校验的注解汇总"><a href="#校验的注解汇总" class="headerlink" title="校验的注解汇总"></a>校验的注解汇总</h3><table>
<thead>
<tr>
<th>注解</th>
<th>应用对象</th>
<th>检查内容</th>
</tr>
</thead>
<tbody><tr>
<td>@Length(min=, max=)</td>
<td>用于String对象</td>
<td>检查字符串长度</td>
</tr>
<tr>
<td>@Max(value=)</td>
<td></td>
<td>最大值</td>
</tr>
<tr>
<td>@Min(value=)</td>
<td></td>
<td>最小值</td>
</tr>
<tr>
<td>@NotNull</td>
<td></td>
<td>不为空</td>
</tr>
<tr>
<td>@Past</td>
<td>date 或 calendar</td>
<td>时间是过去吗?</td>
</tr>
<tr>
<td>@Future</td>
<td>date 或 calendar</td>
<td>时间是将来吗?</td>
</tr>
<tr>
<td>@Email</td>
<td>String</td>
<td>格式是邮箱吗?</td>
</tr>
</tbody></table>
<h2 id="配置文件的使用"><a href="#配置文件的使用" class="headerlink" title="配置文件的使用"></a>配置文件的使用</h2><h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//application.properties --&gt;neo.title=lsmg</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;neo.title&#125;"</span>) <span class="comment">//使用注解来获取内容</span></span><br><span class="line"><span class="keyword">private</span> String title;</span><br></pre></td></tr></table></figure>
<h2 id="thymeleaf"><a href="#thymeleaf" class="headerlink" title="thymeleaf"></a>thymeleaf</h2><p>引入命令空间<br><code>&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code></p>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><h4 id="字符串赋值拼接"><a href="#字符串赋值拼接" class="headerlink" title="字符串赋值拼接"></a>字符串赋值拼接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"$&#123;属性名&#125;"</span></span><br><span class="line"><span class="string">"'这是固定部分' + $&#123;变化部分属性名&#125;"</span></span><br><span class="line"></span><br><span class="line">简写形式</span><br><span class="line"><span class="string">"|固定部分$&#123;变化部分属性名&#125;|"</span> <span class="comment">//直接混合</span></span><br></pre></td></tr></table></figure>

<h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if只有内容为真才会显示, unless内容为假才会显示</span></span><br><span class="line">th:<span class="keyword">if</span>=<span class="string">"$&#123;flag == 'yes'&#125;"</span></span><br><span class="line">th:unless=<span class="string">"$&#123;flag == 'yes'&#125;"</span></span><br></pre></td></tr></table></figure>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>  <span class="attr">th:each</span>=<span class="string">"user,iterStat : $&#123;users&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.name&#125;"</span>&gt;</span>neo<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;iterStat.index&#125;"</span>&gt;</span>index<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>iterStat 属性值</strong><br>index，当前迭代对象的 index（从 0 开始计算）；<br>count，当前迭代对象的 index（从 1 开始计算）；<br>size，被迭代对象的大小；<br>current，当前迭代变量；<br>even/odd，布尔值，当前循环是否是偶数/奇数（从 0 开始计算）；<br>first，布尔值，当前循环是否是第一个；<br>last，布尔值，当前循环是否是最后一个。</p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p><code>th:href=&quot;@{http://www.lsmg.xyz/{id}(id=${id})}&quot;</code><br><strong>如果需要 Thymeleaf 对 URL 进行渲染，那么务必使用 th:href、th:src 等属性</strong></p>
<div th:style="'background:url(' + @{${img url}} + ');'">
`{id}(id=${id})` 这部分方便了阅读

<h4 id="三目运算"><a href="#三目运算" class="headerlink" title="三目运算"></a>三目运算</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$&#123;age gt <span class="number">30</span> ? <span class="string">'中年'</span>:<span class="string">'年轻'</span>&#125;</span><br><span class="line"></span><br><span class="line">gt：great than（大于）</span><br><span class="line">ge：great equal（大于等于）</span><br><span class="line">eq：equal（等于）</span><br><span class="line">lt：less than（小于）</span><br><span class="line">le：less equal（小于等于）</span><br><span class="line">ne：not equal（不等于）</span><br></pre></td></tr></table></figure>
<h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:switch</span>=<span class="string">"$&#123;sex&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">"'woman'"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">"'man'"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- *: case的默认的选项 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">"*"</span>&gt;</span>蓝<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="高阶使用"><a href="#高阶使用" class="headerlink" title="高阶使用"></a>高阶使用</h3><h4 id="内联"><a href="#内联" class="headerlink" title="内联[[]]"></a>内联<code>[[]]</code></h4><p>如果要使用内联方式 需要在标签或者父标签 甚至是在body中加入 <code>th:inline=&quot;text/javascript/none&quot;</code><br>进行激活</p>
<p><strong>看了下官方文档<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html" target="_blank" rel="noopener">传送门</a></strong><br><code>th:inline=&quot;none&quot;</code>代表不显示,其中的<code>[[]]</code>不会被thymeleaf识别</p>
<p><code>th:inline=&quot;javascript&quot;</code> 代表在js中使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;script th:inline=<span class="string">"javascript"</span>&gt;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> username = [[$&#123;session.user.name&#125;]];</span><br><span class="line">    ...</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script th:inline="javascript"&gt;</span></span><br><span class="line"><span class="regexp">    ...</span></span><br><span class="line"><span class="regexp">    var username = "Sebastian \"Fruity\" Applejuice";</span></span><br><span class="line"><span class="regexp">    ...</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script th:inline=<span class="string">"javascript"</span>&gt;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> username = [($&#123;session.user.name&#125;)];  <span class="comment">// [()] 类似于 th:utext</span></span><br><span class="line">    ...</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script th:inline="javascript"&gt;</span></span><br><span class="line"><span class="regexp">    ...</span></span><br><span class="line"><span class="regexp">    var username = Sebastian "Fruity" Applejuice;</span></span><br><span class="line"><span class="regexp">    ...</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<p>上面的方式会 让它在静态显示时出现错误。<br>一般需要加上注释 /**/ 来包裹<code>[[]]</code></p>
<p>thymeleaf支持多种格式</p>
<ul>
<li>Strings</li>
<li>Numbers</li>
<li>Booleans</li>
<li>Arrays</li>
<li>Collections</li>
<li>Maps</li>
<li>Beans (objects with getter and setter methods)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*&lt;![CDATA[*/</span></span><br><span class="line">  <span class="comment">//这里说一下经常看到的</span></span><br><span class="line">  <span class="comment">//XHTML解析器会把CDATA中的内容当作纯文本处理，</span></span><br><span class="line">  <span class="comment">//里面的 &lt; &amp; 不会被js翻译而是直接显示</span></span><br><span class="line"><span class="comment">/*]]&gt;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&lt;![CDATA[</span></span><br><span class="line">  <span class="comment">//相同效果</span></span><br><span class="line"><span class="comment">//*]]&gt;*</span></span><br></pre></td></tr></table></figure>

<h4 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ctx：上下文对象</span><br><span class="line">#vars：上下文变量</span><br><span class="line">#locale：区域对象</span><br><span class="line">#request：（仅 Web 环境可用）HttpServletRequest 对象</span><br><span class="line">#response：（仅 Web 环境可用）HttpServletResponse 对象 &#x2F;&#x2F;常用</span><br><span class="line">#session：（仅 Web 环境可用）HttpSession 对象 &#x2F;&#x2F;常用</span><br><span class="line">#servletContext：（仅 Web 环境可用）ServletContext 对象</span><br></pre></td></tr></table></figure>
<h4 id="内嵌变量"><a href="#内嵌变量" class="headerlink" title="内嵌变量"></a>内嵌变量</h4><p><a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#inlining" target="_blank" rel="noopener">文档地址, 内容太多, 贴不过来了</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--格式化时间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.format(date, 'yyyy-MM-dd HH:mm:ss')&#125;"</span>&gt;</span>neo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--创建当前时间 精确到天--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.createToday()&#125;"</span>&gt;</span>neo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--创建当前时间 精确到秒--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.createNow()&#125;"</span>&gt;</span>neo<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--判断是否为空--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#strings.isEmpty(userName)&#125;"</span>&gt;</span>userName<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--判断 list 是否为空--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#strings.listIsEmpty(users)&#125;"</span>&gt;</span>userName<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--输出字符串长度--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#strings.length(userName)&#125;"</span>&gt;</span>userName<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--拼接字符串--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#strings.concat(userName,userName,userName)&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--创建自定长度的字符串--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#strings.randomAlphanumeric(count)&#125;"</span>&gt;</span>userName<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="springboot和thymeleaf上传文件"><a href="#springboot和thymeleaf上传文件" class="headerlink" title="springboot和thymeleaf上传文件"></a>springboot和thymeleaf上传文件</h2><h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><p>常用部分</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#支持的最大文件</span><br><span class="line">spring.servlet.multipart.max-file-size=100MB</span><br><span class="line">#文件请求最大限制</span><br><span class="line">spring.servlet.multipart.max-request-size=100MB</span><br></pre></td></tr></table></figure>
<p>其他常用设置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.servlet.multipart.enabled=true，是否支持 multipart 上传文件</span><br><span class="line">spring.servlet.multipart.file-size-threshold=0，支持文件写入磁盘</span><br><span class="line">spring.servlet.multipart.location=，上传文件的临时目录</span><br><span class="line">spring.servlet.multipart.max-file-size=10Mb，最大支持文件大小</span><br><span class="line">spring.servlet.multipart.max-request-sizee=10Mb，最大支持请求大小</span><br><span class="line">spring.servlet.multipart.resolve-lazily=false，是否支持 multipart 上传文件时懒加载</span><br></pre></td></tr></table></figure>

<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>解决上传文件大于 10M 出现连接重置的问题<br><strong>终于去看了看  表达式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Tomcat large file upload connection reset</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TomcatServletWebServerFactory <span class="title">tomcatEmbedded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TomcatServletWebServerFactory tomcat = <span class="keyword">new</span> TomcatServletWebServerFactory();</span><br><span class="line">    tomcat.addConnectorCustomizers((TomcatConnectorCustomizer) connector -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> ((connector.getProtocolHandler() <span class="keyword">instanceof</span> AbstractHttp11Protocol&lt;?&gt;)) &#123;</span><br><span class="line">            <span class="comment">//-1 means unlimited</span></span><br><span class="line">            ((AbstractHttp11Protocol&lt;?&gt;) connector.getProtocolHandler()).setMaxSwallowSize(-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> tomcat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前端网页</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"/upload"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>补充 enctype属性<br>| 值                                | 描述                                                        |<br>| ——————————— | ———————————————————– |<br>| application/x-www-form-urlencoded | 在发送前编码所有字符（默认）                                |<br>| multipart/form-data               | 不对字符编码 在使用包含文件上传控件的表单时，必须使用该值。 |<br>| text/plain                        | 空格转换为 “+” 加号，但不对特殊字符编码。                   |</p>
<p><strong>RedirectAttributes</strong><br>RedirectAttributes attr</p>
<p><strong>attr.addAttribute(“param”, value);</strong><br>attr.addAttribute(“name”, “user”);<br>attr.addAttribute(“success”, “ok”);<br>return “redirect:/index”;<br>这种方式相当于系统自动的拼接了url 仍然会暴露信息</p>
<p><strong>attr.addFlashAttribute(“param”, value);</strong><br>attr.addFlashAttribute(“status”,”999”);<br>attr.addFlashAttribute(“message”,”登录失败”);<br>return “redirect:/toLogin”;<br>这种方式通过session传递, session在跳转到页面后就是马上移除对象, 刷新后即消失</p>
<p><strong>上传控制器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/upload"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">singleFileUpload</span><span class="params">(@RequestParam(<span class="string">"file"</span>)</span> MultipartFile file,</span></span><br><span class="line"><span class="function">                             RedirectAttributes redirectAttributes) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (file.isEmpty()) &#123;</span><br><span class="line">      redirectAttributes.addFlashAttribute(<span class="string">"message"</span>, <span class="string">"Please select a file to upload"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"redirect:uploadStatus"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Get the file and save it somewhere</span></span><br><span class="line">      <span class="keyword">byte</span>[] bytes = file.getBytes();</span><br><span class="line">      <span class="comment">// UPLOADED_FOLDER 文件本地存储地址</span></span><br><span class="line">      Path path = Paths.get(UPLOADED_FOLDER + file.getOriginalFilename());</span><br><span class="line">      Files.write(path, bytes);</span><br><span class="line"></span><br><span class="line">      redirectAttributes.addFlashAttribute(<span class="string">"message"</span>,</span><br><span class="line">              <span class="string">"You successfully uploaded '"</span> + file.getOriginalFilename() + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"redirect:/uploadStatus"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"POST"</span> <span class="attr">action</span>=<span class="string">"/uploadMore"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    文件1： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    文件2： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    文件3： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>控制器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/uploadMore"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">moreFileUpload</span><span class="params">(@RequestParam(<span class="string">"file"</span>)</span> MultipartFile[] files,</span></span><br><span class="line"><span class="function">                               RedirectAttributes redirectAttributes) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (files.length==<span class="number">0</span>) &#123;</span><br><span class="line">        redirectAttributes.addFlashAttribute(<span class="string">"message"</span>, <span class="string">"Please select a file to upload"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:uploadStatus"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(MultipartFile file:files)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = file.getBytes();</span><br><span class="line">            Path path = Paths.get(UPLOADED_FOLDER + file.getOriginalFilename());</span><br><span class="line">            Files.write(path, bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    redirectAttributes.addFlashAttribute(<span class="string">"message"</span>, <span class="string">"You successfully uploaded all"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:/uploadStatus"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Restful-api"><a href="#Restful-api" class="headerlink" title="Restful api"></a>Restful api</h2><p>使用 swagger2 构建restful api</p>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><h3 id="使用注解方式"><a href="#使用注解方式" class="headerlink" title="使用注解方式"></a>使用注解方式</h3><p>启动类 加上注解 <code>@EnableScheduling</code> 然后在<br>实现类上要有组件的注解@Component<br>要定时的方法上加上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scheduled</span>(fixedRate = <span class="number">1000</span>) <span class="comment">//单位为秒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   System.out.println(df.format(<span class="keyword">new</span> Date())+<span class="string">" "</span>+count);</span><br><span class="line">   <span class="keyword">return</span> ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> @Scheduled(cron = “*/6 * * * * *”) 的cron属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The pattern is a list of six single space-separated fields: representing second, minute, hour, day, month, weekday. Month and weekday names can be given as the first three letters of the English names.</span></span><br><span class="line"><span class="comment">6个由空格间隔的单独的数字  分别代表 xxxxx 月份和工作日可以用英文前三个字母代替</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>星花和斜杠含义</strong></p>
<p>*/10 * * * * * = every ten seconds.  */10<br>这四个字符(由于第一位代表秒 *为通配符任意秒 /为每隔 10与/组合意味每十秒 */10意为 从任意秒开始每10S执行<br>末尾的 * * * * * 意味任意的 分钟小时……</p>
<p><em>可以结合下面这个看</em><br>10 * * * * *<br>这个意思为 任意的分钟小时…… 当秒为10的时候 触发</p>
<p><strong>再来一个例子</strong><br>0 0/30 8-10 * * *<br>后三个星花表示任意的 天月和工作日<br>第一个0表示 0S时<br>第二个 0/30 表示从0Min开始每隔30Min<br>第三个 <code>-</code> 表示8H和9H和10H<br>如果第三个 <code>-</code> 换为<code>,</code> 则为8H和10H</p>
]]></content>
        
        <categories>
            
            <category> Java </category>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[纯洁的微笑Gitchat 课程笔记1]]></title>
        <url>http://blog.lsmg.xyz/2019/06/Java-Springboot%25E5%259F%25BA%25E7%25A1%2580%25E7%259F%25A5%25E8%25AF%25861/</url>
        <content type="html"><![CDATA[<p>这篇博客主要是想整理下 纯洁的微笑博客的观后感 <a href="http://www.ityouknow.com/springboot/2016/02/03/spring-boot-web.html" target="_blank" rel="noopener">传送门</a>. 针对所列的框架, 自己再去丰富内容</p>
<a id="more"></a>

<h2 id="Web-开发"><a href="#Web-开发" class="headerlink" title="Web 开发"></a>Web 开发</h2><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><p>Filter在servlet被调用前 截获request. 检查request, 可以进行request的修改(request头和request数据).<br>在离开response后处理response.</p>
<p><strong>一种方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfigure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RemoteIpFilter <span class="title">remoteIpFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RemoteIpFilter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">testFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建过滤器注册类</span></span><br><span class="line">        FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        <span class="comment">//将自己的过滤器添加</span></span><br><span class="line">        registrationBean.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">        <span class="comment">//设置过滤器的URL模式</span></span><br><span class="line">        registrationBean.addUrlPatterns(<span class="string">"/*"</span>);</span><br><span class="line">        <span class="comment">//初始化Filter参数</span></span><br><span class="line">        registrationBean.addInitParameter(<span class="string">"paramName"</span>, <span class="string">"paramValue"</span>);</span><br><span class="line">        registrationBean.setName(<span class="string">"MyFilter"</span>);</span><br><span class="line">        registrationBean.setOrder(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现Filter的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">            HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">            System.out.println(<span class="string">"拦截器: "</span> + request.getRequestURI());</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>推荐的方式</strong> 不过这种方式虽然简单 但不能定义优先级</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动类加上 @ServletComponentScan 注解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这种方式通过filterName来控制优先级......</span></span><br><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"secondFilter"</span>, urlPatterns = <span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">        System.out.println(<span class="string">"拦截器2: "</span> + request.getRequestURI());</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//删除部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
        
        <categories>
            
            <category> Java </category>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[2019年5月30日]]></title>
        <url>http://blog.lsmg.xyz/2019/05/Linux-Ubuntu%25E7%259A%2584%25E5%25AE%2589%25E8%25A3%2585%25E4%25BB%25A5%25E5%258F%258A%25E7%25BE%258E%25E5%258C%2596/</url>
        <content type="html"><![CDATA[<p>由于自己的电脑配置太低了。 没想到8G内存都不够netty项目吃的 CPU每次运行飙升。<br>所以来试一试Ubuntu<br>我把我整块硬盘格式化了 重装了win10系统 然后安装了ubuntu18.04STL 版本</p>
<a id="more"></a>
<h3 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h3><p>安装的时候出现了好多问题弄得我 重新装了一次。<br>出现的问题就是root文件夹里没有相关的启动项目， 无奈只能重新安装。<br>    —自己找了个U盘做了个启动盘才安装上。<br>最后选择的是共存， 使用Ubuntu来引导Win10 还可以吧就这样</p>
<p><a href="https://www.sysgeek.cn/speed-up-ubuntu-linux-top-10/" target="_blank" rel="noopener">一些优化操作</a></p>
<h3 id="既然用了Ubuntu怎么能没有界面的美化"><a href="#既然用了Ubuntu怎么能没有界面的美化" class="headerlink" title="既然用了Ubuntu怎么能没有界面的美化"></a>既然用了Ubuntu怎么能没有界面的美化</h3><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/Ubuntu1.png" alt=""><br>先上一张图片 就是这样子<br>之前用过黑苹果就安装了苹果的主题<br>参考的博客也挺多的</p>
<p><a href="https://zhuanlan.zhihu.com/p/37314255" target="_blank" rel="noopener">Ubuntu 18.04 LTS 安装、美化</a></p>
<p><a href="https://www.jianshu.com/p/4fb9f91a5866" target="_blank" rel="noopener">Ubuntu18.04美化主题(mac主题)</a></p>
<p><a href="https://blog.csdn.net/zyqblog/article/details/80152016" target="_blank" rel="noopener">Gnome-shell Extensions安装 这个是好多的基础操作</a></p>
<p><a href="https://blog.csdn.net/qq_32447361/article/details/85946268" target="_blank" rel="noopener">其中一个主题</a></p>
<p><a href="https://jasongrass.gitee.io/2018-06-mac%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BE%8E%E5%8C%96/" target="_blank" rel="noopener">怎么能少的了命令行</a><br><img src="./2019n5y30r/zsh.png" alt=""></p>
<p><a href="https://blog.csdn.net/tecn14/article/details/24489031" target="_blank" rel="noopener">实时显示网速插件</a></p>
<h3 id="怎么能少的了梯子"><a href="#怎么能少的了梯子" class="headerlink" title="怎么能少的了梯子?"></a>怎么能少的了梯子?</h3><p><a href="https://www.jianshu.com/p/9fd29c00d881" target="_blank" rel="noopener">作者的Github关闭了, 这是备份</a><br>开始用了各种办法, 最后还是找到了这个备份解决的问题 默默的fork一份</p>
<h3 id="一些常用的软件"><a href="#一些常用的软件" class="headerlink" title="一些常用的软件"></a>一些常用的软件</h3><p>没想到 有搜狗输入法 不爽的是没有QQ和微信… 只能使用网页版微信来传输文件了. 目前有办法安装QQ不过还没有去查看</p>
<p>IDEA 全家桶没想到也有Linux版本的 现在是通过命令行启动 等我以后找找有没有其他的便捷方式</p>
<h3 id="一些小的问题"><a href="#一些小的问题" class="headerlink" title="一些小的问题"></a>一些小的问题</h3><p>比如文件夹 桌面 这类中文的改成了英文, 中文的话不太好打出来</p>
<p><a href="https://www.cnblogs.com/vincent-hv/p/3348920.html" target="_blank" rel="noopener">【原】中文Ubuntu主目录下的文档文件夹改回英文</a></p>
<p>打开终端，在终端中输入命令:<br>export LANG=en_US<br>xdg-user-dirs-gtk-update<br>在弹出的窗口中询问是否将目录转化为英文路径,同意并关闭.<br>在终端中输入命令:<br>export LANG=zh_CN<br>关闭终端,并注销或重启.下次进入系统,系统会提示是否把转化好的目录改回中文.选择不许要并且勾上不再提示,并取消修改.主目录的中文转英文就完成了~</p>
<p>markdown编辑器使用了atom 这个编辑器喜欢上了,</p>
<h3 id="一个神奇的网站"><a href="#一个神奇的网站" class="headerlink" title="一个神奇的网站"></a>一个神奇的网站</h3><p>可以无损放大图片!!!!</p>
<p><a href="http://waifu2x.udp.jp/index.zh-CN.html" target="_blank" rel="noopener">中文网页</a></p>
<p>本程序使用卷积神经网络对动漫风格的图片进行放大操作（支持照片）。<br>…咋也不懂啥是 卷积神经网络</p>
<p><img src="http://wx1.sinaimg.cn/large/0066wpcPly1g29v0exyslj306o06o3yo.jpg" alt=""></p>
<h3 id="Ubuntu-快捷方式制作"><a href="#Ubuntu-快捷方式制作" class="headerlink" title="Ubuntu 快捷方式制作"></a>Ubuntu 快捷方式制作</h3><p>2019年05月30日21:51:14</p>
<p>[Desktop Entry]<br>Encoding=UTF-8<br>Version=1.0<br>Name=图标名称<br>GenericName=Java IDE<br>Comment= 这里是描述<br>Exec=sh /home/lsmg/software/idea-IU-191.7479.19/bin/idea.sh<br>Icon=/home/lsmg/software/idea-IU-191.7479.19/bin/idea.png<br>Terminal=false<br>Type=Application<br>StartupNotify=true<br>StartupWMClass=jetbrains-idea<br>Categories=Development;IDE</p>
<p>Exec后写sh完整路径<br>Icon后写完整图标路径<br>StartupWMClass 这个设置正确则会显示小点 而不是显示多个图标</p>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/Ubuntu2.png" alt=""></p>
]]></content>
        
        <categories>
            
            <category> Linux </category>
            
            <category> Ubuntu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 使用Ubuntu </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[Java设计模式]]></title>
        <url>http://blog.lsmg.xyz/2019/05/Java-%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F/</url>
        <content type="html"><![CDATA[<div class="alert-red">Java设计模式</div>
<div class="alert-blue"></div>
<div class="alert-green"></div>
<a id="more"></a>
## 大神文章
[自己是看的作者的书](https://blog.csdn.net/lovelion/article/details/17517213)

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>使用单例模式可以确保一个类只有一个实例化的对象</p>
<h3 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h3><p> 饿汉式单例模式 无延迟加载 不需要解决多线程问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> singletonpattern.Connect</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * 饿汉式单例模式 无延迟加载 不需要解决多线程问题</span></span><br><span class="line"><span class="comment"> * Author lsmg</span></span><br><span class="line"><span class="comment"> * Date 2019/5/21 13:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Connect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Connect instance = <span class="keyword">new</span> Connect();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Connect</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connect <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singletonpattern;</span><br><span class="line">懒汉式单例模式 实现了延迟加载,但需要解决多线程问题</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> singletonpattern.Connect1_2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * 懒汉式单例模式 实现了延迟加载,但需要解决多线程问题</span></span><br><span class="line"><span class="comment"> * Author lsmg</span></span><br><span class="line"><span class="comment"> * Date 2019/5/21 13:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Connect1_2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connect1_2  connect1_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Connect1_2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种方式会造成多线程访问的时候实例化多个对象</span></span><br><span class="line"><span class="comment">//    public  static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class="line"><span class="comment">//        if(connect1_2 == null)&#123;</span></span><br><span class="line"><span class="comment">//            connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        return connect1_2;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种方式虽然确保了只有一个线程进入, 但是降低了多线程的性能</span></span><br><span class="line"><span class="comment">//    public synchronized static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class="line"><span class="comment">//        if(connect1_2 == null)&#123;</span></span><br><span class="line"><span class="comment">//            connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        return connect1_2;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种方式需要在private "volatile" static singletonpattern.Connect1_2 connect1_2 这样同样降低效率</span></span><br><span class="line"><span class="comment">//    public synchronized static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class="line"><span class="comment">//        if(connect1_2 == null)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            synchronized (singletonpattern.Connect1_2.class)&#123;</span></span><br><span class="line"><span class="comment">//                if(connect1_2 == null)&#123;</span></span><br><span class="line"><span class="comment">//                    connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        return connect1_2;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用IoDH 方法</span></span><br><span class="line">    <span class="comment">//建立一个静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldeClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Connect1_2 instance = <span class="keyword">new</span> Connect1_2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connect1_2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HoldeClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
        
        <categories>
            
            <category> Java </category>
            
            <category> Java设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java设计模式 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[Springboot数据交互]]></title>
        <url>http://blog.lsmg.xyz/2019/05/Java-Springboot%25E6%2595%25B0%25E6%258D%25AE%25E4%25BA%25A4%25E4%25BA%2592/</url>
        <content type="html"><![CDATA[<div class="alert-red"></div>
<div class="alert-blue"></div>
<div class="alert-green"></div>
<a id="more"></a>
## 后端向前端传送

<p>这种方式需要注意 编写html的时候 提示根据return的 页面决定 return了对应的页面对应的页面就会有提示 这种方法重定向无法传递</p>
<p>###</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">	map.put(<span class="string">"username"</span>,<span class="string">"123"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="json报文-来源"><a href="#json报文-来源" class="headerlink" title="json报文 来源"></a>json报文 <a href="https://blog.csdn.net/chinrui/article/details/70832310" target="_blank" rel="noopener">来源</a></h3><p>返回的格式为json格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	hashMap.put(<span class="string">"msg"</span>, <span class="string">"登录成功"</span>);</span><br><span class="line">	<span class="keyword">return</span> hashMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面的代码来说，还可以做进一步的优化，由于所有的 Restful 接口都只是返回数据，所以我们可以直接在类级别上添加 @ResponseBody 注解。<br>而大多数情况下，@Controller 与 @ResponseBody 又会一起使用，所以我们使用 @RestController 注解来替换掉它们，从而更加简洁地实现功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/sys/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"login"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Map&lt;String, String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		hashMap.put(<span class="string">"msg"</span>, <span class="string">"登录成功"</span>);</span><br><span class="line">		<span class="keyword">return</span> hashMap;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解决重定向传参问题"><a href="#解决重定向传参问题" class="headerlink" title="解决重定向传参问题"></a>解决重定向传参问题</h3><p><strong>RedirectAttributes</strong><br>RedirectAttributes attr</p>
<p><strong>attr.addAttribute(“param”, value);</strong><br>attr.addAttribute(“name”, “user”);<br>attr.addAttribute(“success”, “ok”);<br>return “redirect:/index”;<br>这种方式相当于系统自动的拼接了url 仍然会暴露信息</p>
<p><strong>attr.addFlashAttribute(“param”, value);</strong><br>attr.addFlashAttribute(“status”,”999”);<br>attr.addFlashAttribute(“message”,”登录失败”);<br>return “redirect:/toLogin”;<br>这种方式通过session传递, session在跳转到页面后就是马上移除对象, 刷新后即消失</p>
<h2 id="前端向后短传送"><a href="#前端向后短传送" class="headerlink" title="前端向后短传送"></a>前端向后短传送</h2><h3 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">	type: <span class="string">"POST"</span>,</span><br><span class="line">	dataType: <span class="string">"json"</span>,</span><br><span class="line">	url: <span class="string">"/login"</span>,</span><br><span class="line">	data: $(<span class="string">'#loginForm'</span>).serialize(),</span><br><span class="line"></span><br><span class="line">	success: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(result.info===<span class="string">"登录失败"</span>)&#123;</span><br><span class="line">			<span class="built_in">document</span>.getElementById(<span class="string">"info"</span>).innerText=<span class="string">"账号不存在或密码错误"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="模拟表单"><a href="#模拟表单" class="headerlink" title="模拟表单"></a>模拟表单</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toMain</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> input1 = $(<span class="string">"&lt;input&gt;"</span>);</span><br><span class="line">input1.attr(<span class="string">"type"</span>, <span class="string">"hidden"</span>);</span><br><span class="line">input1.attr(<span class="string">"name"</span>, <span class="string">"key"</span>);</span><br><span class="line">input1.attr(<span class="string">"value"</span>, key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $form = $(<span class="string">'&lt;form method="POST"&gt;&lt;/form&gt;'</span>);</span><br><span class="line">$form.attr(<span class="string">'action'</span>, <span class="string">"/toMain"</span>);</span><br><span class="line">$form.appendTo($(<span class="string">'body'</span>));</span><br><span class="line">$form.append(input1);</span><br><span class="line">$form.submit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="@RequestParam注解"></a>@RequestParam注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index1</span><span class="params">(@RequestParam(value = <span class="string">"username"</span>)</span>String name)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PathVariable注解-使用url-额外文本传参数"><a href="#PathVariable注解-使用url-额外文本传参数" class="headerlink" title="@PathVariable注解 使用url+额外文本传参数"></a>@PathVariable注解 使用url+额外文本传参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RequestMapping(<span class="string">"user/get/mac/&#123;macAddress&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getByMacAddress</span><span class="params">(@PathVariable String macAddress)</span></span>&#123;</span><br><span class="line">　　<span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对应的直接传递"><a href="#对应的直接传递" class="headerlink" title="对应的直接传递"></a>对应的直接传递</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getByMacAddress</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">　　对应表单直接赋值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"login"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(@RequestBody @Valid UserModel userModel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"用户名不能为空"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"密码不能为空"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正则表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotBlank</span>(message = <span class="string">"用户名不能为空"</span>)</span><br><span class="line"><span class="meta">@Pattern</span>(</span><br><span class="line">        regexp = <span class="string">"1(([38]\\d)|(5[^4&amp;&amp;\\d])|(4[579])|(7[0135678]))\\d&#123;8&#125;"</span>,</span><br><span class="line">        message = <span class="string">"手机号格式不合法"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
        
        <categories>
            
            <category> Java </category>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot数据交互 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[Springboot日志操作]]></title>
        <url>http://blog.lsmg.xyz/2019/05/Java-Springboot%25E6%2597%25A5%25E5%25BF%2597%25E6%2593%258D%25E4%25BD%259C/</url>
        <content type="html"><![CDATA[<div class="alert-red">springboot</div>
<div class="alert-blue">日志</div>
<div class="alert-green"></div>
<a id="more"></a>

<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">logger.trace();</span><br><span class="line">logger.debug();</span><br><span class="line">logger.info();</span><br><span class="line">logger.warn();</span><br><span class="line">logger.error();</span><br><span class="line"></span><br><span class="line">springboot 默认日志级别为info及以上</span><br></pre></td></tr></table></figure>

<h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># com.xyz 下日志级别</span><br><span class="line">logging.level.com.xyz=trace</span><br><span class="line"># 设置root级别 设置默认级别</span><br><span class="line">logging.level.root=debug</span><br><span class="line"></span><br><span class="line">#输出到当前项目根路径下的 springboot.log 文件中</span><br><span class="line">#logging.file=springboot.log</span><br><span class="line">#输出到当前项目所在磁盘根路径下的 /springboot/log目录中的 spring.log 文件中,</span><br><span class="line">logging.path=springboot/log</span><br></pre></td></tr></table></figure>
<h3 id="更改输出格式"><a href="#更改输出格式" class="headerlink" title="更改输出格式"></a>更改输出格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 日志输出格式说明：</span><br><span class="line"># %d 输出日期时间，</span><br><span class="line"># %thread 输出当前线程名，</span><br><span class="line"># %-5level 输出日志级别，左对齐5个字符宽度</span><br><span class="line"># %logger&#123;50&#125; 输出全类名最长50个字符，超过按照句点分割</span><br><span class="line"># %msg 日志信息</span><br><span class="line"># %n 换行符</span><br><span class="line"># 修改控制台输出的日志格式</span><br><span class="line">logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-<span class="number">5l</span>evel %logger&#123;<span class="number">50</span>&#125; - %msg%n</span><br><span class="line"># 修改文件中输出的日志格式</span><br><span class="line">logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; &gt;&gt;&gt; [%thread] &gt;&gt;&gt; %-<span class="number">5l</span>evel &gt;&gt;&gt;</span><br><span class="line">%logger&#123;<span class="number">50</span>&#125; &gt;&gt;&gt; %msg%n</span><br></pre></td></tr></table></figure>]]></content>
        
        <categories>
            
            <category> Java </category>
            
            <category> springboot </category>
            
        </categories>
        
        
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 日志 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[2019年4月19日]]></title>
        <url>http://blog.lsmg.xyz/2019/04/%25E5%25B0%258F%25E9%25A1%25B9%25E7%259B%25AE-%25E8%2587%25AA%25E5%258A%25A8%25E6%259F%25A5%25E8%25AF%25A2%25E9%25A2%2598%25E5%25BA%2593/</url>
        <content type="html"><![CDATA[<div class="alert-red">自动查询题库</div>
<div class="alert-blue"></div>
<div class="alert-green">springboot复健</div>
<a id="more"></a>

<p><strong>只是为了自己以后查阅方便 =_=</strong><br><strong>继续自己的爬虫去了</strong></p>
<h3 id="SpringBoot部分"><a href="#SpringBoot部分" class="headerlink" title="SpringBoot部分"></a>SpringBoot部分</h3><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/inquire"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">find</span><span class="params">(HttpSession session, @RequestParam(<span class="string">"quesion"</span>)</span>String quesionText)</span>&#123;</span><br><span class="line">	String[] line = quesionText.split(<span class="string">"\\r?\\n"</span>);  <span class="comment">//对字符串切割 使用换行切割</span></span><br><span class="line">	startInquire startInquire = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		startInquire=<span class="keyword">new</span> startInquire(line);</span><br><span class="line">	&#125;<span class="keyword">catch</span> (Exception e)&#123;e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	String answer = startInquire.getAnswer();</span><br><span class="line">	session.setAttribute(<span class="string">"answer"</span>,answer);</span><br><span class="line"></span><br><span class="line">	Clear clear = <span class="keyword">new</span> Clear(session);</span><br><span class="line">	clear.start();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"redirect:/"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><p>参考文章 <a href="https://segmentfault.com/a/1190000009162306" target="_blank" rel="noopener">正则表达式</a></p>
<h4 id="视图控制器"><a href="#视图控制器" class="headerlink" title="视图控制器"></a>视图控制器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMvc</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"index"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:method</span>=<span class="string">"post"</span> <span class="attr">th:action</span>=<span class="string">"@&#123;/inquire&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>欢迎来到本站~~~~ 目前题库只有校史比赛 =_=! 后续待学校是否出新的<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"inputTextBorder"</span>&gt;</span><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"inputArea"</span> <span class="attr">name</span>=<span class="string">"quesion"</span>&gt;</span>题目粘贴到此处</span><br><span class="line">        注意只需要在试题页面按 CTRL+A CTRL+C 粘贴到这里即可</span><br><span class="line">        经测试谷歌浏览器正常使用 火狐暂不支持</span><br><span class="line">    <span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"hestoryButton"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>查询校史题库---&gt;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"outputTextBorder"</span>&gt;</span><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"outputArea"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;session.answer==''?'答案将会显示在这里哦':session.answer&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>outputArea–&gt; 能回车的输入框</p>
<p>post方法 不限制参数长度<br>get方法限制参数长度<br><code>${session.answer==&#39;&#39;? &#39;答案将会显示在这里哦&#39;:session.answer}</code> 三目运算符</p>
<h3 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h3><p>后端的代码改了好久匹配的算法 好吧最后感觉收益不是特别的高 目前删除了部分代码</p>
<h4 id="读取问题"><a href="#读取问题" class="headerlink" title="读取问题"></a>读取问题</h4><p>这里的代码通用性 很差具体修改等以后放出新的试题 感觉问题不大(指易班网)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ReadQuesion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * 读取题目 存入list中</span></span><br><span class="line"><span class="comment"> * Author lsmg</span></span><br><span class="line"><span class="comment"> * Date 2019/4/16 18:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadQuesion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Quesion&gt; originQuesions;</span><br><span class="line">    <span class="keyword">private</span> Quesion originQuesion;</span><br><span class="line">    <span class="keyword">private</span> String[] quesion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> lsmg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> //TODO </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 22:53 2019/4/19</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> quesion 控制器传入的前段问题数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    ReadQuesion(String[] quesion)&#123;</span><br><span class="line">        originQuesions = <span class="keyword">new</span> ArrayList&lt;Quesion&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> quesionStart=<span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.quesion = quesion;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=quesion.length-<span class="number">1</span>;i+=(quesionStart?<span class="number">5</span>:<span class="number">1</span>))&#123;</span><br><span class="line">            String line = quesion[i];</span><br><span class="line">            <span class="comment">//除去开头多余行数</span></span><br><span class="line">            <span class="keyword">if</span>(!quesionStart)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!line.contains(<span class="string">"1【单选】"</span>))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    quesionStart=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//去除EF选项</span></span><br><span class="line">            <span class="keyword">if</span>(line.contains(<span class="string">"E. E"</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(quesion[i+<span class="number">1</span>].contains(<span class="string">"F. F"</span>))&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断结尾</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">40</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">4</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(quesion[i+j].contains(<span class="string">"立即交卷"</span>))&#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//五行为一个题目</span></span><br><span class="line">            String []result=<span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">            result[<span class="number">0</span>]=quesion[i];</span><br><span class="line">            result[<span class="number">1</span>]=quesion[i+<span class="number">1</span>];</span><br><span class="line">            result[<span class="number">2</span>]=quesion[i+<span class="number">2</span>];</span><br><span class="line">            result[<span class="number">3</span>]=quesion[i+<span class="number">3</span>];</span><br><span class="line">            result[<span class="number">4</span>]=quesion[i+<span class="number">4</span>];</span><br><span class="line">            stringProcess(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Quesion&gt; <span class="title">getOriginQuesions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originQuesions;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> lsmg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> //TODO </span></span><br><span class="line"><span class="comment">     * 将每个题目的数组转成对象放入list中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 22:54 2019/4/19</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string 每个题目组成的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stringProcess</span><span class="params">(String[] string)</span></span>&#123;</span><br><span class="line">        originQuesion = <span class="keyword">new</span> Quesion();</span><br><span class="line"></span><br><span class="line">        originQuesion.setQuesionText(string[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=string.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            originQuesion.setChoiceText(string[i],i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        originQuesions.add(originQuesion);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        originQuesion=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读取题库"><a href="#读取题库" class="headerlink" title="读取题库"></a>读取题库</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadAnswer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//题库路径</span></span><br><span class="line">    String[] QuesionBank;</span><br><span class="line">    Quesion quesion;</span><br><span class="line">    List&lt;Quesion&gt; quesionList;</span><br><span class="line"></span><br><span class="line">    ReadAnswer() <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        quesion = <span class="keyword">new</span> Quesion();</span><br><span class="line">        quesionList=<span class="keyword">new</span> ArrayList&lt;Quesion&gt;();</span><br><span class="line">		</span><br><span class="line"><span class="comment">//题库路径部分 方便以后添加题库</span></span><br><span class="line">        String[] dirName = <span class="keyword">new</span> String[]&#123;<span class="string">"校史"</span>&#125;;</span><br><span class="line">        String parentPath = System.getProperty(<span class="string">"user.dir"</span>)+File.separator+dirName[<span class="number">0</span>]+File.separator;</span><br><span class="line">        System.out.println(parentPath);</span><br><span class="line">        QuesionBank = <span class="keyword">new</span> String[]&#123;parentPath+<span class="string">"单项选择题库.txt"</span>,parentPath+<span class="string">"单项选择题库补充.txt"</span>,parentPath+<span class="string">"多项选择题库.txt"</span>,parentPath+<span class="string">"长知识点.txt"</span>&#125;;<span class="comment">//,parentPath+"短知识点.txt"</span></span><br><span class="line"></span><br><span class="line">        readStringFromBank();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> lsmg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> //TODO</span></span><br><span class="line"><span class="comment">     * 用于从题库读取字符串 传入处理函数处理字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 16:52 2019/4/17</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readStringFromBank</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String path :QuesionBank)&#123;</span><br><span class="line">            FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(path));</span><br><span class="line">            InputStreamReader in = <span class="keyword">new</span> InputStreamReader(fileInputStream,<span class="string">"GB2312"</span>);</span><br><span class="line">            BufferedReader bf = <span class="keyword">new</span> BufferedReader(in);</span><br><span class="line"></span><br><span class="line">            String line=<span class="string">""</span>;</span><br><span class="line">            <span class="keyword">while</span>((line = bf.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                processString(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processString</span><span class="params">(String pendingProcessString)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断字符串第一个是否为数字 为数字且包含.则为题干 生成一个题目对象</span></span><br><span class="line">        <span class="keyword">if</span>(pendingProcessString.charAt(<span class="number">0</span>)&lt;<span class="number">57</span> &amp;&amp;pendingProcessString.contains(<span class="string">"."</span>))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(quesion != <span class="keyword">null</span>)&#123;</span><br><span class="line">                quesionList.add(quesion);</span><br><span class="line">                quesion = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            quesion = <span class="keyword">new</span> Quesion();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成新对象后加入到对象题干中</span></span><br><span class="line">            quesion.setQuesionText(pendingProcessString);</span><br><span class="line">            addQuesionAnswer(pendingProcessString);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        addQuesionAnswer(pendingProcessString);</span><br><span class="line">        <span class="comment">//判断是否为选项是则 加入选项</span></span><br><span class="line">        <span class="keyword">if</span>(pendingProcessString.charAt(<span class="number">0</span>)&gt;=<span class="string">'A'</span> &amp;&amp; pendingProcessString.charAt(<span class="number">0</span>)&lt;=<span class="string">'E'</span>)&#123;</span><br><span class="line">            addQuesionAnswerText(pendingProcessString);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//都不符合则为剩余题干</span></span><br><span class="line">        quesion.setQuesionText(quesion.getQuesionText()+pendingProcessString);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQuesionAnswerText</span><span class="params">(String answerText)</span></span>&#123;</span><br><span class="line">        quesion.setChoiceText(answerText, answerText.charAt(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQuesionAnswer</span><span class="params">(String line)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = line.indexOf(<span class="string">"（"</span>)+<span class="number">1</span>;i &lt;= line.indexOf(<span class="string">"）"</span>)-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            quesion.setAnswerText(quesion.getAnswerText()+line.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Quesion&gt; <span class="title">getQuesionList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quesionList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quesion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String QuesionText;</span><br><span class="line">    <span class="keyword">private</span> String[] ChoiceText;</span><br><span class="line">    <span class="keyword">private</span> String AnswerText;</span><br><span class="line">    Quesion()&#123;</span><br><span class="line">        QuesionText=<span class="string">""</span>;</span><br><span class="line">        ChoiceText = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">        AnswerText =<span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getQuesionText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QuesionText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuesionText</span><span class="params">(String quesionText)</span> </span>&#123;</span><br><span class="line">        QuesionText = quesionText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getChoiceText() &#123;</span><br><span class="line">        <span class="keyword">return</span> ChoiceText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChoiceText</span><span class="params">(String choiceText,<span class="keyword">char</span> choice)</span> </span>&#123;</span><br><span class="line">        ChoiceText[choice-<span class="number">65</span>] = choiceText;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChoiceText</span><span class="params">(String choiceText,<span class="keyword">int</span> choice)</span> </span>&#123;</span><br><span class="line">        ChoiceText[choice-<span class="number">1</span>] = choiceText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAnswerText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> AnswerText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnswerText</span><span class="params">(String answerText)</span> </span>&#123;</span><br><span class="line">        AnswerText = answerText;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTrueAnswerText</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String answer=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(AnswerText.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> QuesionText;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;=AnswerText.length();i++)&#123;</span><br><span class="line">            answer += ChoiceText[AnswerText.charAt(i-<span class="number">1</span>)-<span class="number">65</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小功能部分"><a href="#小功能部分" class="headerlink" title="小功能部分"></a>小功能部分</h3><h4 id="删除多余字符"><a href="#删除多余字符" class="headerlink" title="删除多余字符"></a>删除多余字符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">deleteTexts</span><span class="params">(String line)</span></span>&#123;</span><br><span class="line">	String []deleteText = &#123;<span class="string">"哪"</span>,<span class="string">"几项"</span>,<span class="string">"指的是"</span>,<span class="string">"下列哪一项为正确选项"</span>,<span class="string">"正确"</span>,<span class="string">"【单选】"</span>,<span class="string">"【多选】"</span>,<span class="string">"、"</span>,<span class="string">"《"</span>,<span class="string">"》"</span>,<span class="string">"_"</span>,<span class="string">"所"</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(String string : deleteText)&#123;</span><br><span class="line">		line=line.replace(string,<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> line;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
        
        <categories>
            
            <category> 项目制作 </category>
            
            <category> 小项目 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 自动查询题库 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[2019年4月15日 java爬虫入门]]></title>
        <url>http://blog.lsmg.xyz/2019/04/Java-%25E7%2588%25AC%25E8%2599%25AB/</url>
        <content type="html"><![CDATA[<div class="alert-red">java爬虫</div>
<div class="alert-blue">maven项目 下载和文件流</div>
<div class="alert-green">IDEA配置</div>
<a id="more"></a>

<p>这篇博客不知道为啥被覆盖了 哎还要从新写一次</p>
<h3 id="maven项目"><a href="#maven项目" class="headerlink" title="maven项目"></a>maven项目</h3><p>通过maven项目 不需要像java项目一样去下载第三方jar包了</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        所用到的httpclient包--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>r05<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        Jsoup是一款Java的HTML解析器，可以直接解析某个URL地址，也可以解析HTML内容。其主要的功能包括解析HTM--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        L页面，通过DOM或者CSS选择器来查找、提取数据，可以更改HTML内容--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="下载类"><a href="#下载类" class="headerlink" title="下载类"></a>下载类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span> Download</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment">* Author lsmg</span></span><br><span class="line"><span class="comment">* Date 2019/4/15 18:03</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment">* 来自 https://www.cnblogs.com/lichenwei/p/4610298.html</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Download</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lsmg</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 23:36 2019/4/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> imgUrl 图片url地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> extension 图片的后缀名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">imgDownload</span><span class="params">(String imgUrl, String extension)</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="comment">//获取输入流</span></span><br><span class="line">		BufferedInputStream in = <span class="keyword">new</span> BufferedInputStream((<span class="keyword">new</span> URL(imgUrl).openStream()));</span><br><span class="line"></span><br><span class="line">		<span class="comment">//文件名</span></span><br><span class="line">		SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH时mm分ss秒SSS毫秒"</span>);</span><br><span class="line">		<span class="comment">//创建文件流</span></span><br><span class="line">		File file = <span class="keyword">new</span> File(<span class="string">"D:\\Pictures\\miku\\"</span>+df.format(<span class="keyword">new</span> Date())+<span class="string">"."</span>+extension);</span><br><span class="line">		System.out.println(file.getAbsolutePath());</span><br><span class="line"></span><br><span class="line">		FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">		BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(fileOutputStream);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//缓冲字节流</span></span><br><span class="line">		<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> ((length = in.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">			out.write(data,<span class="number">0</span>,length); <span class="comment">//这里划重点 这是修改后的代码没啥问题了 每次写入的长度不一定为1024 而应该是真实长度</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"正在下载图片 :"</span>+imgUrl);</span><br><span class="line">		in.close();</span><br><span class="line">		out.close();</span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>使用了多线程传入参数i 作用在后边说明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">		Thread t =<span class="keyword">new</span> FindImg(i);</span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="java爬虫"><a href="#java爬虫" class="headerlink" title="java爬虫"></a>java爬虫</h3><p>这个网页带有分页 每次切换页数url只有页数发生了变化 干脆加入了多线程 一个线程负责一页</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> lsmg</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> //TODO 找到select的更好表示方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 23:42 2019/4/15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Find</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//建立一个请求客户端</span></span><br><span class="line">	CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">	String url=<span class="string">"http://pic.netbian.com/e/search/result/index.php?page="</span>+index+<span class="string">"&amp;searchid=122"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用HttpGet方式请求网址</span></span><br><span class="line">	HttpGet httpGet = <span class="keyword">new</span> HttpGet(url);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取网址返回结果</span></span><br><span class="line">	CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;                     <span class="comment">//....执行</span></span><br><span class="line">		response = httpClient.execute(httpGet);</span><br><span class="line">	&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取返回结构中的实体</span></span><br><span class="line">	HttpEntity entity = response.getEntity();</span><br><span class="line"></span><br><span class="line">	String html = <span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//将返回实体输出</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		html= EntityUtils.toString(entity);</span><br><span class="line">		<span class="comment">//System.out.println(html);</span></span><br><span class="line">		EntityUtils.consume(entity);</span><br><span class="line">	&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解析html到一个document</span></span><br><span class="line">	Document document = Jsoup.parse(html);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//提取内容</span></span><br><span class="line">	Elements imgJpg = document.select(<span class="string">"img[src$=.jpg]"</span>); <span class="comment">//select选择器 下边说明 由于返回多个结果使用Elements存储</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//下载对象</span></span><br><span class="line">	Download download = <span class="keyword">new</span> Download();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (Element element : imgJpg)&#123;</span><br><span class="line">		download.imgDownload(<span class="string">"http://pic.netbian.com"</span>+element.attr(<span class="string">"src"</span>),<span class="string">"jpg"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Jsoup-Java的HTML解析器"><a href="#Jsoup-Java的HTML解析器" class="headerlink" title="Jsoup-Java的HTML解析器"></a>Jsoup-Java的HTML解析器</h3><p>这个功能强大记录两条常用的<br><strong><a href="http://www.voidcn.com/article/p-qdzdjxky-p.html" target="_blank" rel="noopener">来自</a></strong></p>
<p>[attr^=value] 利用匹配属性值开头<br>[attr$=value] 利用匹配属性值结尾<br>[attr<em>=value]包含属性值来查找元素，比如：[href</em>=/path/]<br>还有<br>a[href] 带有herf内=内容的a标签<br>a[class=xxx] 带有xxxclass的a标签</p>
<p>element.attr(“src”) 找到src的内容</p>
<h3 id="自己的方法注释"><a href="#自己的方法注释" class="headerlink" title="自己的方法注释"></a>自己的方法注释</h3><p><a href="https://blog.csdn.net/qq_34533072/article/details/80830738" target="_blank" rel="noopener">https://blog.csdn.net/qq_34533072/article/details/80830738</a></p>
]]></content>
        
        <categories>
            
            <category> Java </category>
            
            <category> java爬虫 </category>
            
            <category> java爬虫初步 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java爬虫 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[java输入输出流]]></title>
        <url>http://blog.lsmg.xyz/2019/04/Java-%25E8%25BE%2593%25E5%2585%25A5%25E8%25BE%2593%25E5%2587%25BA%25E6%25B5%2581/</url>
        <content type="html"><![CDATA[<div class="alert-red">java输入输出流</div>
<div class="alert-blue">知识整理</div>
<div class="alert-green">IO流</div>
<a id="more"></a>

<h2 id="输入输出的区别"><a href="#输入输出的区别" class="headerlink" title="输入输出的区别"></a>输入输出的区别</h2><p><img src="https://blog.lsmg.xyz/2019/04/11/4y11r/1.png" alt=""></p>
<h3 id="InputStream、OutputStream"><a href="#InputStream、OutputStream" class="headerlink" title="InputStream、OutputStream"></a>InputStream、OutputStream</h3><p>处理字节流的抽象类<br>InputStream 是字节输入流的所有类的超类,一般我们使用它的子类,如FileInputStream等.<br>OutputStream是字节输出流的所有类的超类,一般我们使用它的子类,如FileOutputStream等.</p>
<h3 id="InputStreamReader-OutputStreamWriter"><a href="#InputStreamReader-OutputStreamWriter" class="headerlink" title="InputStreamReader  OutputStreamWriter"></a>InputStreamReader  OutputStreamWriter</h3><p>处理字符流的抽象类<br>InputStreamReader 是字节流通向字符流的桥梁,它将字节流转换为字符流. <strong>同时可以解决乱码问</strong>题<br>OutputStreamWriter是字符流通向字节流的桥梁，它将字符流转换为字节流.<strong>同时可以解决乱码问题</strong></p>
<h3 id="BufferedReader-BufferedWriter"><a href="#BufferedReader-BufferedWriter" class="headerlink" title="BufferedReader BufferedWriter"></a>BufferedReader BufferedWriter</h3><p>BufferedReader 由Reader类扩展而来，提供通用的缓冲方式文本读取，readLine读取一个文本行，<br>从字符输入流中读取文本，缓冲各个字符，从而提供字符、数组和行的高效读取。<br>BufferedWriter  由Writer 类扩展而来，提供通用的缓冲方式文本写入， newLine使用平台自己的行分隔符，<br>将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。</p>
<h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><h3 id="BufferedInputStream-带有缓冲区域的InputStream-来自"><a href="#BufferedInputStream-带有缓冲区域的InputStream-来自" class="headerlink" title="BufferedInputStream-带有缓冲区域的InputStream 来自"></a>BufferedInputStream-带有缓冲区域的InputStream <a href="https://blog.csdn.net/niyingxunzong/article/details/33335485" target="_blank" rel="noopener">来自</a></h3><p>InputStream<br>|–FilterInputStream<br>|—-BufferedInputStream</p>
<ol>
<li>BufferedInputStream对外提供滑动读取的功能实现，通过预先读入一整段原始输入流数据至缓冲区中。</li>
<li>外界对BufferedInputStream的读取操作实际上是在缓冲区上进行。</li>
<li>如果读取的数据超过了缓冲区的范围，那么BufferedInputStream负责重新从原始输入流中载入下一截数据填充缓冲区，然后外界继续通过缓冲区进行数据读取。<br>这样的设计的好处是：避免了大量的磁盘网络IO，因为原始的InputStream类实现的read是即时读取的，即每一次读取都会是一次IO操作（哪怕只读取了1个字节的数据），可想而知，如果数据量巨大，这样的磁盘网络消耗非常可怕。而通过缓冲区的实现，读取可以读取缓冲区中的内容，当读取超过缓冲区的内容后再进行一次IO，载入一段数据填充缓冲，那么下一次读取一般情况下就直接可以从缓冲区读取，减少了IO操作。</li>
</ol>
<h2 id="OutStream"><a href="#OutStream" class="headerlink" title="OutStream"></a>OutStream</h2><h3 id="flush操作"><a href="#flush操作" class="headerlink" title="flush操作"></a>flush操作</h3><p>当写文件需要flush()的效果时，需要<br>FileOutputStream fos = new FileOutputStream(“c:\a.txt”);<br>BufferedOutputStream bos = new BufferedOutputStream(fos);<br>也就是说，需要将FileOutputStream作为BufferedOutputStream构造函数的参数传入，然后对BufferedOutputStream进行写入操作，才能利用缓冲及flush()。</p>
<p>查看BufferedOutputStream的源代码，发现所谓的buffer其实就是一个byte[]。<br><strong>BufferedOutputStream的每一次write其实是将内容写入byte[]，当buffer容量到达上限时，会触发真正的磁盘写入.</strong><br>而另一种触发磁盘写入的办法就是调用<code>flush()</code>了。</p>
<p><code>BufferedOutputStream</code>在<code>close()</code>时会自动<code>flush ()</code></p>
<h3 id="输出时创建中间目录"><a href="#输出时创建中间目录" class="headerlink" title="输出时创建中间目录"></a>输出时创建中间目录</h3><p>只是创建一个文件对象不会在文件系统上创建相应的文件或目录。<br><code>File.mkdir()</code>和<code>File.mkdirs()</code>之间的区别是，后者将创建任何中间目录，如果它不存在。</p>
<h2 id="关闭流-来自"><a href="#关闭流-来自" class="headerlink" title="关闭流 来自"></a>关闭流 <a href="https://blog.csdn.net/zhaoyanjun6/article/details/54894451" target="_blank" rel="noopener">来自</a></h2><p>close（）方法的作用<br>1、关闭输入流，并且释放系统资源<br>2、BufferedInputStream装饰一个 InputStream 使之具有缓冲功能，is要关闭只需要调用最终被装饰出的对象的 close()方法即可，因为它最终会调用真正数据源对象的 close()方法。因此，可以只调用外层流的close方法关闭其装饰的内层流。</p>
]]></content>
        
        <categories>
            
            <category> Java </category>
            
            <category> 知识整理 </category>
            
            <category> IO流 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java输入输出流 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[2019年4月13日 FASTJson解析json]]></title>
        <url>http://blog.lsmg.xyz/2019/04/Java-SDK-Fastjson%25E7%259A%2584%25E4%25BD%25BF%25E7%2594%25A8/</url>
        <content type="html"><![CDATA[<div class="alert-red"> FASTJson 解析json</div>
<div class="alert-blue"></div>
<div class="alert-green"></div>
<a id="more"></a>

<h3 id="调用api部分"><a href="#调用api部分" class="headerlink" title="调用api部分"></a>调用api部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String u = <span class="string">"http://route.showapi.com/341-1?showapi_appid=搞了好久A&amp;showapi_sign=搞了好久B"</span>;</span><br><span class="line">URL url = <span class="keyword">new</span> URL(u);</span><br><span class="line">HttpURLConnection connection = (HttpURLConnection)url.openConnection();</span><br><span class="line">connection.connect();</span><br><span class="line"></span><br><span class="line">InputStreamReader in = <span class="keyword">new</span> InputStreamReader(connection.getInputStream());</span><br><span class="line">BufferedReader bf = <span class="keyword">new</span> BufferedReader(in);</span><br><span class="line">String stringJsonbf=<span class="keyword">null</span>; <span class="comment">//暂时存储</span></span><br><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> ((stringJsonbf= bf.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	stringBuffer.append(stringJsonbf);</span><br><span class="line">&#125;</span><br><span class="line">String stringJson=stringBuffer.toString(); <span class="comment">//得到json数据转为String</span></span><br><span class="line">System.out.println(stringJson);</span><br></pre></td></tr></table></figure>

<h3 id="json解析部分"><a href="#json解析部分" class="headerlink" title="json解析部分"></a>json解析部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;类&gt; happies = <span class="keyword">new</span> ArrayList&lt;类&gt;(); <span class="comment">//类为json中所需要对象的对应类</span></span><br><span class="line">JSONObject jsonObject1 = <span class="keyword">new</span> JSONObject(stringJson); <span class="comment">//string转换为json对象</span></span><br><span class="line">JSONObject jsonObject2 = jsonObject1.getJSONObject(<span class="string">"showapi_res_body"</span>);<span class="comment">//这个对象中还有个对象用jsonObject1.getJSONObject获取</span></span><br><span class="line">JSONArray jsonArray =jsonObject2.getJSONArray(<span class="string">"contentlist"</span>);<span class="comment">//获取后的对象里有数组获取数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;jsonArray.length();i++)&#123;</span><br><span class="line">	JSONObject jsTempt = jsonArray.getJSONObject(i);</span><br><span class="line">	String title = jsTempt.getString(<span class="string">"title"</span>);</span><br><span class="line">	String text = jsTempt.getString(<span class="string">"text"</span>);</span><br><span class="line">	String ct = jsTempt.getString(<span class="string">"ct"</span>);</span><br><span class="line">	Happy 对象 = <span class="keyword">new</span> 类(title,text,ct);</span><br><span class="line">	happies.add(对象);<span class="comment">//加入list中</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(happies);</span><br></pre></td></tr></table></figure>
<h3 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h3><h4 id="搞了好久A和搞了好久B"><a href="#搞了好久A和搞了好久B" class="headerlink" title="搞了好久A和搞了好久B"></a>搞了好久A和搞了好久B</h4><p><img src="./2019n4y12r/2.png" alt=""><br>这里的appid和sign<strong>不是这个应用的id</strong>=, =而是你账号里的<br><img src="./2019n4y12r/1.png" alt=""><br>好吧………………生成sign的方式官方有</p>
<ol>
<li><p>您首先需要设置除了showapi_sign之外的所有必传参数，例如：<br><code>?title=足球&amp;page=1&amp;pag=for_test&amp;showapi_appid=123</code></p>
</li>
<li><p>对上述参数key进行排序按照字典序(a-z)，请注意byte[]类型的参数不参与排序和计算签名，比如上传的文件；空值的参数也不参与排序和计算签名。排序后以key+value方式拼装字符串如下：<br>pagfor_testpage1showapi_appid123title足球</p>
</li>
</ol>
<p><strong>请注意上述的pag字段排在page字段之前</strong></p>
<ol start="3">
<li>String str=”pagfor_testpage1showapi_appid123title足球”<br>str=str+secret<br>也就是str=str+”006513e01bd344fca03610d1fd0145f0” //secret用小写<br>最后str=”pagfor_testpage1showapi_appid123title足球006513e01bd344fca03610d1fd0145f0”<br>注意在签名计算时,中文依然是中文,并没有被urlencode<br>String sign=DigestUtils.md5Hex(str.getBytes(“utf-8”))<br>最后得到 sign=”030554F4F9375B4DCFEF5ECEC4488737”</li>
</ol>
<p>不得不说这个代码表示真的好</p>
<h4 id="还有个json解析问题"><a href="#还有个json解析问题" class="headerlink" title="还有个json解析问题"></a>还有个json解析问题</h4><p><code>JSONObject jsonObject2 = new JSONObject(jsonObject1.getJSONObject(&quot;showapi_res_body&quot;))</code><br>好吧开始是这样的结果一直报错/……..具体原因先留个坑吧<br>2019年4月13日00:07:54</p>
<h3 id="FASTJson-解析json"><a href="#FASTJson-解析json" class="headerlink" title="FASTJson 解析json"></a>FASTJson 解析json</h3><p>文章学习来源 <a href="https://blog.csdn.net/xingfei_work/article/details/76572550" target="_blank" rel="noopener">声明出处</a><br>从这里我学会了解析json 自己也点写笔记</p>
<p><code>String json1 = &quot;{&#39;id&#39;:1,&#39;name&#39;:&#39;JAVAEE-1703&#39;,&#39;stus&#39;:[{&#39;id&#39;:101,&#39;name&#39;:&#39;刘铭&#39;,&#39;age&#39;:16}]}&quot;;</code><br>待解析json数据<br>构建对应的类</p>
<h3 id="解析对象"><a href="#解析对象" class="headerlink" title="解析对象"></a>解析对象</h3><h4 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Grade</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Student&gt; stus;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Grade</span><span class="params">(<span class="keyword">int</span> id, String name, ArrayList&lt;Student&gt; stus)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.stus = stus;</span><br><span class="line">	&#125;<span class="comment">//这个构造方法对应了json数据 由于json数据中有数组 所以写了链表存储数组</span></span><br><span class="line">	<span class="comment">//省略若干get和set以及toString的重写(用于打印对象)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">//省略若干get和set以及toString的重写(用于打印对象)</span></span><br><span class="line">&#125;<span class="comment">//这里同样对应了json数组中的数据</span></span><br></pre></td></tr></table></figure>
<h4 id="主要部分"><a href="#主要部分" class="headerlink" title="主要部分"></a>主要部分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String json1 = <span class="string">"&#123;'id':1,'name':'JAVAEE-1703','stus':[&#123;'id':101,'name':'刘铭','age':16&#125;]&#125;"</span>;</span><br><span class="line">Grade grade = JSON.parseObject(json1,Grade<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(grade);</span><br></pre></td></tr></table></figure>

<p>不得不说阿里的这个简化了太多了疯狂扣6</p>
<h3 id="解析数组"><a href="#解析数组" class="headerlink" title="解析数组"></a>解析数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String json2 = <span class="string">"['北京','天津','杭州']"</span>;</span><br><span class="line">List&lt;String&gt; list=JSON.parseArray(json2, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>]]></content>
        
        <categories>
            
            <category> Java </category>
            
            <category> SDK </category>
            
            <category> FASTJson </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[4月11日 java文件操作]]></title>
        <url>http://blog.lsmg.xyz/2019/04/Java-%25E6%2596%2587%25E4%25BB%25B6%25E6%2593%258D%25E4%25BD%259C/</url>
        <content type="html"><![CDATA[<div class="alert-red">java文件操作</div>
<div class="alert-blue">#$%&^*%^&%$</div>
<div class="alert-green"></div>
<a id="more"></a>

<p><a href="https://blog.csdn.net/yhl_jxy/article/details/79272792" target="_blank" rel="noopener">博客来源</a></p>
<p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/Java%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C.png" alt="来源"></p>
<p>Java IO读写文件的IO流分为两大类，字节流和字符流，<br>基于字节流的读写基类: InputStream和OutputStream<br>基于字符流的读写基类: Reader和Writer</p>
<p>如果是二进制文件，使用FileInputStream读取；如果是文本文件，使用FileReader读取；<br>这两个类允许我们从文件开始至文件结尾一个字节或字符的读取文件，或者将读取的文件写入字节数组或字符数组。<br>如果我们想随机的读取文件内容，可以使用RandomAccessFile。</p>
<h3 id="简单的文件读写"><a href="#简单的文件读写" class="headerlink" title="简单的文件读写"></a>简单的文件读写</h3><p><strong>File file = new File(“123.txt”);</strong></p>
<h4 id="字节流读取文件"><a href="#字节流读取文件" class="headerlink" title="字节流读取文件"></a>字节流读取文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (InputStream is = <span class="keyword">new</span> FileInputStream(file))&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] dataB=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	is.read(dataB);</span><br><span class="line">	System.out.println(<span class="string">"字节文件内容:"</span> + <span class="keyword">new</span> String(dataB));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字节流写文件"><a href="#字节流写文件" class="headerlink" title="字节流写文件"></a>字节流写文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(OutputStream os = <span class="keyword">new</span> FileOutputStream(file))&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] dataB = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	String str = <span class="string">"1234567890abcdef"</span>;</span><br><span class="line">	dataB = str.getBytes();</span><br><span class="line">	os.write(dataB);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符流读取文件"><a href="#字符流读取文件" class="headerlink" title="字符流读取文件"></a>字符流读取文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"123.txt"</span>);</span><br><span class="line"><span class="keyword">try</span> (Reader reader = <span class="keyword">new</span> FileReader(file))&#123;</span><br><span class="line">	<span class="keyword">char</span>[] dataC = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">	reader.read(dataC);</span><br><span class="line">	System.out.println(<span class="string">"字符文件内容:"</span>+<span class="keyword">new</span> String(dataC));</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字符流写文件"><a href="#字符流写文件" class="headerlink" title="字符流写文件"></a>字符流写文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Writer writer = <span class="keyword">new</span> FileWriter(file))&#123;</span><br><span class="line">	<span class="keyword">char</span>[] dataC = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">	String str=<span class="string">"@@@@1234567890abcdef"</span>;</span><br><span class="line">	dataC=str.toCharArray();</span><br><span class="line">	writer.write(dataC);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简单的写文件-指定位置"><a href="#简单的写文件-指定位置" class="headerlink" title="简单的写文件-指定位置"></a>简单的写文件-指定位置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>)) &#123;</span><br><span class="line">	<span class="comment">//获取RandomAccessFile对象文件指针的位置，初始位置是0</span></span><br><span class="line">	System.out.println(<span class="string">"RandomAccessFile文件指针的初始位置:"</span>+raf.getFilePointer());</span><br><span class="line">	<span class="comment">//移动文件指针位置</span></span><br><span class="line">	raf.seek(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">byte</span>[]  buff=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="comment">//用于保存实际读取的字节数</span></span><br><span class="line">	<span class="keyword">int</span> hasRead=<span class="number">0</span>;</span><br><span class="line">	<span class="comment">//循环读取</span></span><br><span class="line">	<span class="keyword">while</span>((hasRead=raf.read(buff))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">//打印读取的内容,并将字节转为字符串输入</span></span><br><span class="line">		System.out.println(<span class="keyword">new</span> String(buff,<span class="number">0</span>,hasRead));</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
        
        <categories>
            
            <category> Java </category>
            
            <category> 知识整理 </category>
            
            <category> 文件操作 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java文件操作 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[windows终端设置]]></title>
        <url>http://blog.lsmg.xyz/2019/04/Windows-%25E7%25BB%2588%25E7%25AB%25AF%25E4%25BD%25BF%25E7%2594%25A8/</url>
        <content type="html"><![CDATA[<div class="alert-red">今天和明天重装了系统配置电脑ing</div>
<div class="alert-blue">wsl-terminal终端的使用</div>
<div class="alert-green"></div>
<a id="more"></a>

<p>先放两张完成图噗噗噗<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/Windows%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A81.png" alt=""><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/Windows%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A82.png" alt=""></p>
<h4 id="windows一直没有一个好用的终端-昨天苦苦查找终于找到了下面是从零开始的配置"><a href="#windows一直没有一个好用的终端-昨天苦苦查找终于找到了下面是从零开始的配置" class="headerlink" title="windows一直没有一个好用的终端 昨天苦苦查找终于找到了下面是从零开始的配置"></a>windows一直没有一个好用的终端 昨天苦苦查找终于找到了下面是从零开始的配置</h4><p><a href="https://goreliu.github.io/wsl-terminal/README.zh_CN.html" target="_blank" rel="noopener">来源</a><br>从<a href="https://github.com/goreliu/wsl-terminal/releases" target="_blank" rel="noopener">这里</a>下载最新版本并解压</p>
<p>运行 open-wsl.exe 可以在当前目录打开一个 WSL 终端模拟器 *<em>没错你会发现你怎么都打不开2333333333 *</em></p>
<p>运行 tools/1-add-open-wsl-terminal-here-menu.js (帮助) 来添加一个 Open wsl-terminal Here 右键菜单到资源管理器上 (运行 tools/1-remove-open-wsl-terminal-here-menu.js 可以将其删除）</p>
<hr>
<p><a href="https://www.jianshu.com/p/b147735ff3f2" target="_blank" rel="noopener">来源</a></p>
<h4 id="设置-gt-搜索启用或关闭Windows功能-gt-在选项中勾上使用于Linux的Windows子系统"><a href="#设置-gt-搜索启用或关闭Windows功能-gt-在选项中勾上使用于Linux的Windows子系统" class="headerlink" title="设置-&gt;搜索启用或关闭Windows功能-&gt;在选项中勾上使用于Linux的Windows子系统:"></a>设置-&gt;搜索启用或关闭Windows功能-&gt;在选项中勾上使用于Linux的Windows子系统:</h4><p><img src="http://ww1.sinaimg.cn/mw690/7de3675bgy1fg9pi8iighj20bx0bt3zb.jpg" alt=""><br>重启电脑</p>
<h4 id="安装WSL"><a href="#安装WSL" class="headerlink" title="安装WSL"></a>安装WSL</h4><p>打开Win10应用商店，搜索Ubuntu，进行安装。安装成功后，在开始菜单中输入Ubuntu即可启动linux终端。<br><img src="https://upload-images.jianshu.io/upload_images/12990480-38923fd90957cbb0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/493/format/webp" alt=""><br>等上小10分钟 输入账号密码 安装成功</p>
<p>等你安装完就会发现上边下载的可以打开了 意不意外.</p>
<p>不行我要美化他</p>
<h3 id="美化设置"><a href="#美化设置" class="headerlink" title="美化设置"></a>美化设置</h3><p><a href="https://www.jianshu.com/p/b147735ff3f2" target="_blank" rel="noopener">来源</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure>
<p>要让我们的终端变得更加漂亮，要配置两个部分：zsh主题（zsh theme）和终端的颜色主题（Color Theme）</p>
<h4 id="zsh主题（zsh-theme"><a href="#zsh主题（zsh-theme" class="headerlink" title="zsh主题（zsh theme)"></a>zsh主题（zsh theme)</h4><p>由于使用了oh-my-zsh，修改zsh的主题很容易，只要编辑~/.zshrc(直接输入 vim ~/.zshrc)文件，找到ZSH_THEME一行，改为agnoster即可<br><img src="https://upload-images.jianshu.io/upload_images/12990480-56f8f82cfbae3959.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/319/format/webp" alt=""></p>
<h4 id="终端的颜色主题（Color-Theme）"><a href="#终端的颜色主题（Color-Theme）" class="headerlink" title="终端的颜色主题（Color Theme）"></a>终端的颜色主题（Color Theme）</h4><p>但是Windows默认终端的Color Theme改起来比较费劲，需要使用一个叫做colortool的工具。他是微软自带的一个修改终端配色方案的工具<br>首先在<a href="https://github.com/Microsoft/console/releases" target="_blank" rel="noopener">这里</a> 下载压缩包</p>
<p>下载<code>colortool.zip</code>并解压后，进入文件夹，按住<code>shift并点击右键</code>选择在此处打开Powershell窗口<br>输入</p>
<pre><code>.\colortool.exe -d solarized_dark</code></pre><p>回到wsl输入</p>
<pre><code>source ~/.zshrc</code></pre><h4 id="这个字体要安装上"><a href="#这个字体要安装上" class="headerlink" title="这个字体要安装上"></a>这个字体要安装上</h4><p><a href="https://raw.githubusercontent.com/tonsky/FiraCode/master/distr/ttf/FiraCode-Retina.ttf" target="_blank" rel="noopener">下载</a><br><img src="https://upload-images.jianshu.io/upload_images/12990480-d8d28bcfb8e54925.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/889/format/webp" alt=""></p>
<p>安装好右键wsl的标题栏 选项 文本 选择(选择刚才的FiraCode-Retina)</p>
<h4 id="插件篇"><a href="#插件篇" class="headerlink" title="插件篇"></a>插件篇</h4><p>插件repo<br><a href="https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md#oh-my-zsh" target="_blank" rel="noopener">https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md#oh-my-zsh</a><br><a href="https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md" target="_blank" rel="noopener">https://github.com/zsh-users/zsh-autosuggestions/blob/master/INSTALL.md</a><br>这两个插件可以让你在终端输入命令时有语法高亮和自动补全。</p>
<p>自动补全了后面的路径<br><img src="https://upload-images.jianshu.io/upload_images/12990480-9c4aa71dfe25f4da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/793/format/webp" alt=""><br>错误的命令会显示成红色<br><img src="https://upload-images.jianshu.io/upload_images/12990480-e011eb347ba2215d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/677/format/webp" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<p>完毕后输入 vim ~/.zshrc<br>找到plugins=(git)这一行 改为<br>plugins=(git colored-man-pages zsh-autosuggestions zsh-syntax-highlighting)</p>
<h3 id="修改完了设置wsl启动后默认zsh"><a href="#修改完了设置wsl启动后默认zsh" class="headerlink" title="修改完了设置wsl启动后默认zsh"></a>修改完了设置wsl启动后默认zsh</h3><p>输入<br>vim ~/.bashrc<br>然后加入 <code>bash -c zsh</code><br>重新启动wsl吧</p>
<h3 id="问题处理篇"><a href="#问题处理篇" class="headerlink" title="问题处理篇"></a>问题处理篇</h3><h4 id="如果你上边配置完了-重启发现多了好多字符提示你权限问题"><a href="#如果你上边配置完了-重启发现多了好多字符提示你权限问题" class="headerlink" title="如果你上边配置完了 重启发现多了好多字符提示你权限问题"></a>如果你上边配置完了 重启发现多了好多字符提示你权限问题</h4><p>chmod 755 问题路径 就可以了</p>
<h4 id="方向键和滑轮乱码"><a href="#方向键和滑轮乱码" class="headerlink" title="方向键和滑轮乱码"></a>方向键和滑轮乱码</h4><p><a href="https://blog.csdn.net/as82984895ok/article/details/52067948" target="_blank" rel="noopener">来源</a></p>
<p>sudo vim /etc/vim/vimrc.tiny<br>set compatible–&gt;改为 set nocompatible<br>在下面加上 set backspace=2</p>
<p>就好了</p>
<p>sudo chmod 777 /etc/vim/vimrc<br>修改权限</p>
]]></content>
        
        <categories>
            
            <category> Windows </category>
            
            <category> 终端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows终端设置 </tag>
            
            <tag> 大量的此终端优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
        <title><![CDATA[隐藏dos窗口]]></title>
        <url>http://blog.lsmg.xyz/2019/03/Windows-%25E9%259A%2590%25E8%2597%258FDos%25E7%25AA%2597%25E5%258F%25A3/</url>
        <content type="html"><![CDATA[<a id="more"></a>

<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> "%<span class="number">1</span>"=="hide" <span class="keyword">goto</span> CmdBegin</span><br><span class="line">	<span class="built_in">start</span> mshta vbscript:createobject("wscript.shell").run("""%~<span class="number">0</span>"" hide",<span class="number">0</span>)(window.close)&amp;&amp;<span class="keyword">exit</span></span><br><span class="line">:CmdBegin</span><br></pre></td></tr></table></figure>
<p>bat开头加上这段可以 隐藏dos窗口</p>
<p>jre\bin\java -jar Demo.jar 用这种方式就可以独立的jar运行了</p>
<p>完整代码</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> "%<span class="number">1</span>"=="hide" <span class="keyword">goto</span> CmdBegin</span><br><span class="line">	<span class="built_in">start</span> mshta vbscript:createobject("wscript.shell").run("""%~<span class="number">0</span>"" hide",<span class="number">0</span>)(window.close)&amp;&amp;<span class="keyword">exit</span></span><br><span class="line">:CmdBegin</span><br><span class="line">jre\bin\java -jar Demo.jar</span><br></pre></td></tr></table></figure>]]></content>
        
        <categories>
            
            <category> Windows </category>
            
            <category> Dos </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
        <title><![CDATA[Git的使用]]></title>
        <url>http://blog.lsmg.xyz/2019/03/Git-%25E5%259F%25BA%25E7%25A1%2580%25E6%2593%258D%25E4%25BD%259C/</url>
        <content type="html"><![CDATA[<p>之前的Git博客 写的终于是自己都看不下去了. 所以打算来重新写一个博客<br>这篇博客主要还是参照的廖雪峰大佬的Git博客<br>自己只做整理方便自己察看</p>
<a id="more"></a>
<h1 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &lt;message&gt;</span><br><span class="line">git remote add origin  # origin 意为远程库的名字, git的默认叫法</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">git diff</span><br><span class="line">git log</span><br><span class="line">git log --pretty&#x3D;oneline # </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git checkout -- &lt;filename&gt; # 恢复工作区, 可用于恢复修改和恢复勿删文件</span><br><span class="line">git reset HEAD &lt;file&gt; # 恢复暂存区</span><br><span class="line">git reset HEAD^ # 恢复版本库</span><br><span class="line">git reflog # 所有版本日志</span><br><span class="line"></span><br><span class="line">git rm 从版本库中删除文件</span><br><span class="line"></span><br><span class="line">git push -u origin master # 带上 -u 以后提交就不需要加入origin master, 类似记忆功能</span><br></pre></td></tr></table></figure>

<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>首先把Git的三个区说明一下吧 自己后来慢慢感觉这些理论还是很重要的<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/Git%E4%B8%89%E5%A4%A7%E5%88%86%E5%8C%BA.png" alt=""><br>工作区<br>顾名思义, 你当前在IDE直接修改的代码全部都是位于工作区的代码<br>暂存区<br>暂时存取的区域, 你每次使用add提交的文件全部在这个区域中, 这些文件等待你的commit<br>版本库<br>这里存放的是若干个版本, 你每次的commit就是将暂存区的文件作为一个版本提交到版本库, 同时相应的文件被提交后 暂存区的文件被清除</p>
<h1 id="基础的操作"><a href="#基础的操作" class="headerlink" title="基础的操作"></a>基础的操作</h1><p><strong>你的第一次提交</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &lt;message&gt;</span><br></pre></td></tr></table></figure>
<p><code>git init</code><br>在你命令所执行的文件夹生成版本库<br><code>git add &lt;file&gt;</code><br>将指定文件从工作区添加到暂存区<br>如果<code>&lt;file&gt;</code>用 <code>.</code> 代替则为所有相对上一次commit修改过的文件<br><code>git commit -m &lt;message&gt;</code><br>提交暂存区的文件到版本库中成为一个版本 message为这个版本(提交)的描述</p>
<p><strong>好了你已经成功完成了一次提交, 继续去写代码了</strong><br>好你又写完了一堆代码 这时你想知道你工作区的状态是啥-你修改了哪些文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$git status</span><br><span class="line">-------提示如下-----------</span><br><span class="line">位于分支 master</span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line"></span><br><span class="line">	修改：     test.txt</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和&#x2F;或 &quot;git commit -a&quot;）</span><br></pre></td></tr></table></figure>
<p><code>git status</code>告诉你 你修改了test.txt文件, 但是你想知道你怎么修改了这些文件, 做了什么改动<br>这时候就需要<code>git diff</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$git diff</span><br><span class="line">-------提示如下-----------</span><br><span class="line">diff --git a&#x2F;test.txt b&#x2F;test.txt</span><br><span class="line">index 0858ae8..8c14912 100644</span><br><span class="line">--- a&#x2F;test.txt</span><br><span class="line">+++ b&#x2F;test.txt</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> 111111111111111</span><br><span class="line"> 222222222222222</span><br><span class="line"> 333333333333333</span><br><span class="line">+444444444444444</span><br></pre></td></tr></table></figure>
<p><strong>现在你知道你进行了什么修改, 又进行了一次提交</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line">	修改：     test.txt</span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和&#x2F;或 &quot;git commit -a&quot;）</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git add test.txt </span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 &quot;git reset HEAD &lt;文件&gt;...&quot; 以取消暂存）</span><br><span class="line">	修改：     test.txt</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git commit -m &quot;ver 0.02&quot;</span><br><span class="line">[master ee4400f] ver 0.02</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br></pre></td></tr></table></figure>

<h1 id="时光穿梭机"><a href="#时光穿梭机" class="headerlink" title="时光穿梭机"></a>时光穿梭机</h1><p>我感觉廖雪峰大佬的博客, 生动诙谐, 其中用到了很多形象的比喻.<br>自己由于是为了方便日后察看 所以省略了这些内容, 感兴趣的可以去看看<br><strong>在commit之间切换</strong><br>Git还可以在不同commit间切换, 当然你必须知道进行过哪些commit, 你不能自己都记在脑子里吧, 所以也存在相关的命令<code>git log</code>来查看你的commit记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lsmg@ubuntu:~&#x2F;temp$ git log</span><br><span class="line">commit ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master)</span><br><span class="line">Author: ***********</span><br><span class="line">Date:   Sat Dec 7 21:06:42 2019 -0800</span><br><span class="line">    ver 0.02</span><br><span class="line"></span><br><span class="line">commit 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class="line">Author: ***********</span><br><span class="line">Date:   Sat Dec 7 20:57:58 2019 -0800</span><br><span class="line">    ver 0.01</span><br><span class="line"></span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git log --pretty&#x3D;oneline # 简洁显示</span><br><span class="line">ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master) ver 0.02</span><br><span class="line">603260e28ac0cc8fb8e4243120eb00bca83585d2 ver 0.01</span><br></pre></td></tr></table></figure>
<p>上面的<code>HEAD</code>代表当前版本, 上一个版本为<code>HEAD^</code>, 上上一个版本为<code>HEAD^^</code>如此类推<br>回到前N个版本<code>HEAD~N</code><br><code>git reset --hard HEAD^</code> 回到上一个版本.<br>这时你当前版本将会丢失, 使用<code>git log</code>也不会查看到原来的版本信息<br>这时使用<code>git reflog</code>来查看你的所有版本日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lsmg@ubuntu:~&#x2F;temp$ git reset --hard 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class="line">HEAD 现在位于 603260e ver 0.01</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git log</span><br><span class="line">commit 603260e28ac0cc8fb8e4243120eb00bca83585d2 (HEAD -&gt; master)</span><br><span class="line">Author: rjd67441 &lt;rjd67441@hotmail.com&gt;</span><br><span class="line">Date:   Sat Dec 7 20:57:58 2019 -0800</span><br><span class="line"></span><br><span class="line">    ver 0.01</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git reflog </span><br><span class="line">603260e (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class="line">ee4400f HEAD@&#123;1&#125;: commit: ver 0.02</span><br><span class="line">603260e (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): ver 0.01</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git reset --hard ee4400f</span><br><span class="line">HEAD 现在位于 ee4400f ver 0.02</span><br></pre></td></tr></table></figure>

<p><strong>撤销修改</strong><br>工作区中的撤销<br><code>git checkout -- &lt;filename&gt;</code><br>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。<br>暂存区中的撤销<br><code>git reset HEAD &lt;file&gt;</code><br>版本库的撤销<br><code>git reset HEAD^</code> 乖乖回退一次</p>
<p><strong>删除文件</strong><br>删除本地文件后<br>确实需要从版本库中删除<br><code>git rm</code>删除然后<code>git commit</code>提交即可<br>误删除需要使用<code>git chechout -- &lt;filename&gt;</code>来恢复</p>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p><code>git checkout -b dev</code>相当于一下两条命令<br><code>git branch dev</code> 分支创建<br><code>git branch -d dev</code> 分支删除<br><code>git checkout dev</code> 分支切换</p>
<p><code>git branch</code> 查看当前所有分支</p>
<p><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p>
<p><strong>冲突解决</strong><br><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 111111111111111</span><br><span class="line">2 222222222222222</span><br><span class="line">3 333333333333333</span><br><span class="line">4 444444444444444</span><br><span class="line">5 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  # 我在master分支下添加了6666666 并提交</span><br><span class="line">6 6666666</span><br><span class="line">7 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">8 7777777</span><br><span class="line">9 &gt;&gt;&gt;&gt;&gt;&gt;&gt; deb # 我在deb分支下添加了7777777 并提交</span><br></pre></td></tr></table></figure>
<p>  最后需要我手动修改这个文件为自己需要的内容 然后提交即可</p>
<p>  <strong>分支管理</strong><br>  通常Git会使用<code>Fast forward</code>模式 这样删除分支后会丢失分支的信息<br>  可以再merge的时候加入<code>--no-ff</code>这样就能解决问题<br>  <code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>  由于禁用<code>Fast forward</code>后<br>  会生成新的commit所以需要加入<code>-m &quot;merge with no-ff&quot;</code></p>
<p>  <code>git stash</code> 可以储存当前的工作区 继续其他的工作<br>  <code>git stash list</code> 查看储存的工作区列表<br>  <code>git stash apply stash@{0}</code> 恢复指定的储存<br>  <code>git stash pop</code> 恢复并drop最近的存储</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt # stash前</span><br><span class="line">111111</span><br><span class="line">$ vim test.txt </span><br><span class="line">$ cat test.txt # 进行了修改</span><br><span class="line">111111</span><br><span class="line">222222</span><br><span class="line">333333</span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">	修改：     test.txt</span><br><span class="line">$ git stash # stash</span><br><span class="line">保存工作目录和索引状态 WIP on master: 854b710 1</span><br><span class="line">$ cat test.txt </span><br><span class="line">111111</span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br><span class="line">$ git stash pop</span><br><span class="line">位于分支 master</span><br><span class="line">	修改：     test.txt</span><br><span class="line">$ cat test.txt </span><br><span class="line">111111</span><br><span class="line">222222</span><br><span class="line">333333</span><br></pre></td></tr></table></figure>]]></content>
        
        <categories>
            
            <category> 必备技能 </category>
            
            <category> Git操作 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git操作 </tag>
            
        </tags>
        
    </entry>
    
    
    
</search>
