<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="keywords" content="hexo,个人博客,blog" />
  <meta name="description" content="彼岸鱼的个人博客" />
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="dns-prefetch" href="https://busuanzi.ibruce.info">
  <link rel="dns-prefetch" href="https://at.alicdn.com">
  
  <link rel="dns-prefetch" href="https://widget.daovoice.io">
  <link rel="dns-prefetch" href="https://widget-static-cdn.daovoice.io">
  <link rel="dns-prefetch" href="https://im.daovoice.io">
  
  
  <link rel="dns-prefetch" href="https://hm.baidu.com/">
  
  
  <link rel="stylesheet" type="text/css" href="/./style/main.css">
	<link rel="shortcut icon" href="/favicon.ico" title="Favicon">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
	<title>UNP记录</title>
  
  <script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?378fe7f014810dc29a0702bf27d8b278";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();
  </script>
  
  
    <script>(function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/9c4ca997.js","daovoice");daovoice('init',{app_id: "9c4ca997"});daovoice('update');
  </script>
  
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Lsmg的大学之路" type="application/atom+xml">
</head>
<body>
  <canvas id="pattern-placeholder" height="230"></canvas>
<div class="navbar-header">
  <a class="blog-title" href="/">Lsmg的大学之路</a>
  <a class="face-img" href="/">
    <img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/theme/tx.jpg">
  </a>
</div>
<main>
  <div class="article-title">
    
  
  <h1 class="title">
    UNP记录
  </h1>
  


    <ul class="article-info">
      <li>
        发布
        <time datetime="2020-10-06T04:17:39.000Z" itemprop="datePublished">2020-10-06</time>
      </li>
      <li>
        
    更新 <time datetime="2020-12-05T02:31:35.586Z" itemprop="dateUpdated">2020-12-05</time>

      </li>
      <li id="busuanzi_container_page_pv">
        阅读 <span id="busuanzi_value_page_pv"></span>
      </li>
    </ul>
  </div>
  <div class="container">
    <div class="article">
      <div class="content">
        
        <p>由于已经在Linux高性能服务器开发中详细说明过绝大部分系统函数</p>
<p>Linux高性能服务器开发的重叠部分, 我会将新的点补充到原博客中, 这里仅作部分简单的说明</p>
<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>通过定义<code>包裹函数</code>可以缩短程序. 在muduo框架中就存在包裹函数 将系统函数进行包装</p>
<p>函数中进行错误处理, 这样外部使用<code>包裹函数</code>包装好的系统函数的时候可以简化错误处理</p>
<p><strong>daytimecpclient-domain.cpp</strong><br>第一个样例程序稍作修改 可以解析域名  inet_addr没有请求网络 速度快 而gethostbyname会请求域名<br>服务器速度可能慢</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in server_addr&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> ((server_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>])) == INADDR_NONE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>* <span class="title">hostptr</span> = <span class="title">gethostbyname</span>(<span class="title">argv</span>[1]);</span></span><br><span class="line">    <span class="keyword">if</span> (!hostptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"invalid input %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    server_addr.sin_addr.s_addr = *((<span class="keyword">unsigned</span> <span class="keyword">long</span>*)hostptr-&gt;h_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代服务器: 对于每个客户连接都执行迭代一次<br>并发服务器: 同时处理多个客户连接</p>
<h1 id="第二章-传输层"><a href="#第二章-传输层" class="headerlink" title="第二章 传输层"></a>第二章 传输层</h1><p>客户端 主动调用close之后 发送了FIN包</p>
<p>服务端 接收到FIN包后read返回0</p>
<p>服务器 read返回0之后调用close函数 发送FIN包</p>
<p>客户端 接收服务器的FIN包</p>
<p><strong>@@35 P TCP状态转换图@@</strong></p>
<p><strong>@@36 P TCP状态转换和Socket函数间的联系@@</strong></p>
<p>多宿主计算机  可能插有多块网卡</p>
<p>通过bind到INADDR_ANY来监听多个接口的同一个端口</p>
<h1 id="第三章-套接字编程简介"><a href="#第三章-套接字编程简介" class="headerlink" title="第三章 套接字编程简介"></a>第三章 套接字编程简介</h1><p>大多数套接字函数 都需要一个指向<code>套接字地址结构</code>的指针作为参数. 每个协议簇都定义了他自己的<code>套接字地址结构</code>. 这些结构的名字均<code>以sockaddr_开头</code></p>
<p><strong>@@61 P 不同套接字地址结构的比较@@</strong></p>
<h1 id="第四章-基本TCP套接字编程"><a href="#第四章-基本TCP套接字编程" class="headerlink" title="第四章 基本TCP套接字编程"></a>第四章 基本TCP套接字编程</h1><p><strong>connect函数</strong></p>
<p>ETIMEDOUT: 客户端没有收到SYN的回应 尝试几次后如果依然没有收到回应则返回错误</p>
<p>ECONNREFUSED: 服务器在指定端口上没有进程等待与之连接导致收到了RST回复  之后立即返回错误</p>
<p>connect失败之后 此套接字无法继续使用 需要close当前套接字后重新调用socket</p>
<p><strong>bind函数</strong></p>
<p>如果调用listen或者connect前没有调用bind则操作系统会分配一个临时端口. 对于客户端来说可以接受临时端口, 然而服务器一般都是需要指定端口 供外接连接. </p>
<p>如果指定的端口为0 则认为没有指定端口 会分配临时端口. 如果地址指定为0(INADDR_ANY) 则系统选择IP地址</p>
<p>RPC服务器可以使用临时端口, 但必须将临时端口注册到端口映射器, 这样客户端才能得到对应的临时端口, 之后进行连接</p>
<p>可以使用getsockname获取到系统临时分配的地址和端口</p>
<p><strong>listen函数</strong></p>
<p>socket函数创建的套接字默认被认为是主动套接字(准备调用connect) 使用listen函数将一个<code>未连接</code>的套接字转换成一个被动套接字</p>
<p>内核为一个监听的系统套接字维护两个队列</p>
<ul>
<li>未完成队列 已经收到了SYN但还未完成三次握手</li>
<li>已完成队列 已经进行了三次握手<code>等待accept从队列中取走</code> 已建立的连接 如果<code>此队列为空, accept阻塞</code></li>
</ul>
<p>未完成队列+已完成队列的总长度 即为listen函数的第二个参数backlog</p>
<p>connect函数调用 -&gt; 服务器收到了SYN包 -&gt; 在未完成队列创建相关内容 -&gt; 创建完毕后返回SYN和ACK -&gt; 客户端返回ACK -&gt; 从未完成队列移动到已完成队列队尾</p>
<p><a href="https://blog.csdn.net/yangbodong22011/article/details/60399728" target="_blank" rel="noopener">https://blog.csdn.net/yangbodong22011/article/details/60399728</a></p>
<p>实际用Centos(内核为4.18版本)测试后, 实际情况为上方博客的情况. 即backlog是已完成队列大小, 而且会存在+1</p>
<p>看到这里后想到之前遇到的一个BUG, 注册入<code>epollfd</code>中的<code>listenfd</code>没有设置成<code>ENONBLOCK</code>, <code>epoll_wait不会返回, 进而去调用accept</code>, 然而客户端<code>connect</code>函数返回显示已经建立连接.  –也就是connect返回说明连接建立, 发生在accpet函数调用前.</p>
<p>当客户端发送FIN后服务器read类函数返回0</p>
<p><strong>@@91 P exec函数之间的关系@@</strong></p>
<p><strong>accept函数</strong><br>accpet函数的第一个参数必须是 被动套接字 即调用过listen, 否则返回EINVAL错误</p>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p>正常启动 正常终止时程序的表现与TCP协议的关系</p>
<p>慢系统调用: 适用于那些可能永远阻塞的系统调用, accpet(没有新连接就一直阻塞), read(读取不到一直阻塞)等等.</p>
<p>EINTR: 当阻塞于某个慢系统调用的进程, 捕获某个信号且相应信号处理函数返回时, 慢系统调用<code>可能</code>返回一个EINTR错误</p>
<p>诸如read, write, select等来说可以忽略EINTR, 如下方这个常见的代码片段. <strong>但是connect则不行, 否则立即返回错误??</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> result = <span class="built_in">read</span>(fd, <span class="built_in">buffer</span>, <span class="keyword">sizeof</span> <span class="built_in">buffer</span>);</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果同时有N个SIGCHLD信号到达, 信号处理函数极可能执行不够N次.</p>
<ul>
<li>UNIX信号没有排队概念</li>
<li>问题导致的结果不确定, 即不确定调用多少次</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">int</span> stat;</span><br><span class="line">  <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">process</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用waitpid来获取所有已终止进程状态, 并且指定了<code>WNOHANG</code>防止不必要的阻塞.</p>
<p>而wait则不能在这里替换waitpid, 因为wait只能阻塞</p>
<p><strong>第五章 正常启动 正常终止 accept返回前终止 服务器进程终止 服务主机崩溃 主机崩溃后重启 主机关机</strong></p>
<h1 id="第六章-I-O-复用-select和poll函数"><a href="#第六章-I-O-复用-select和poll函数" class="headerlink" title="第六章 I/O 复用 select和poll函数"></a>第六章 I/O 复用 select和poll函数</h1><p>进程需要一种预先告知内核的能力, 使得内核一旦发现进程指定的一个或多个I/O条件就绪, 他就通知进程. –IO复用</p>
<p>UNIX可用的五种IO模型</p>
<ul>
<li>阻塞式I/O</li>
<li>非阻塞式I/O</li>
<li>I/O复用</li>
<li>信号驱动式I/O(SIGIO)</li>
<li>异步I/O(POSIX的aio_系列函数)</li>
</ul>
<p>前四种都是同步IO, 因为他们在真正的IO阶段read,readfrom等导致了阻塞<br>只有异步IO模型才是异步IO</p>
<p><strong>@@低水位标记 ?@@</strong></p>
<h2 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h2><p>尽管timeval允许指定一个微秒级的分辨率, 但是真实的分辨率吗…… 部分实现的粗糙一些. 并且还有<code>调度延迟(定时器结束后, 内核还需要花时间调度相应进程运行)</code></p>
<p>struct fd_set 一个集合,可以存储多个文件描述符<br>内部是一个32位整数的数组, 数组第一个元素对应0<del>31描述符 一个二进制位代表一个描述符<br>数组第二个元素对应32</del>63 以此类推</p>
<p>可读条件</p>
<ul>
<li>socket内核接收缓存区中的字节数大于或等于 其低水位标记</li>
<li>socket通信的对方关闭连接 读半连接关闭, 对socket的读操作返回0</li>
<li>监听socket上有新的连接请求</li>
<li>socket上有未处理的错误, 可以使用getsockopt的SO_ERROR来读取和清除错误 套接字的读操作不阻塞 并返回-1</li>
</ul>
<p>可写条件</p>
<ul>
<li>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记, <strong>且套接字已经连接, 或套接字不需要连接UDP</strong></li>
<li>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</li>
<li>socket使用非阻塞connect 连接成功或失败后</li>
<li>socket上有未处理的错误 套接字的写操作不阻塞 并返回-1</li>
</ul>
<p>异常条件</p>
<ul>
<li>发送带外数据</li>
</ul>
<p>当select返回可读事件后 如果不进行处理 则下次select调用会继续返回</p>
<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><ol>
<li>close会将引用计数-1 等到为0时才关闭套接字. shutdown则可以无视此, 激发TCP的正常连接终止序列</li>
<li>close会终止读和写两个方向的数据传送, 但由于TCP全双工有时需要告知对方我方发送已经完毕</li>
</ol>

      </div>
        <!--
            <div class="like ">
              <div class="like-button">
                <a id="like-note" href="">
                  <i class="icon-heart"></i>喜欢
                </a>
              </div>
              <span id="likes-count">256</span>
            </div>
        -->
        <div class="otherLink">
          <div class="previous">
          </div>
          <div class="next">
          </div>
        </div>
        <div class="comments" id="comments">
          

        </div>
      </div>
    </div>
   </div>
</main>
<div class="footer">
  <div class="info">
    <p>
    <a href="https://hexo.io" target="_blank" rel="noopener"> Hexo </a> 强力驱动 |
      <a href="https://github.com/Youthink/hexo-themes-yearn" target="_blank" rel="noopener"> Yearn </a>
      主题
    </p>
    <p>&copy;2018-2020 彼岸鱼的博客</p>
  </div>
</div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<script>//console
  var consoleConfig = '\n欢迎访问 https://hufangyun.com ，围观小猿大圣的博客(づ｡◕‿‿◕｡)づ！\n,\n本博客使用 %cHexo%c 搭建，博客主题为小猿大圣开发的 %chexo-themes-yearn%c ~~~ 🎉🎉🎉 \n\n源码 https://github.com/Youthink/hexo-themes-yearn \n\n如果喜欢可以 star 支持一下 ❤️~\n,\n扫描下面的二维码，在手机上查看博客！\n,https://static.hufangyun.com/blog-url-qrcode-180-180.png,\n 想知道这个效果如何实现的？博客内搜索 console 彩蛋 🚀 ！\n'.split(',');
  var canConsole = false;
  var consoleInfo = (function(consoleConfig) {
  if (!canConsole || !consoleConfig || consoleConfig.length < 1) {
    return;
  }
  var consoleColor = '#6190e8';
  var _console;
  var backgroundTextStyle = 'padding: 1px 5px;color: #fff;background: ' + consoleColor + ';'
  var textStyle = 'color: ' + consoleColor + ';';

  consoleConfig.map(o => {
    var num = (o.match(/%c/g) || []).length;
    if(/^http(s)?:\/\//.test(o)) {
      console.log('%c     ', 'background: url(' + o + ') no-repeat left center;font-size: 180px;');
      return;
    }
    if (num > 0) {
      var logArguments = [];
      for (var i = 0; i < num; i++) {
        if (i % 2 === 0) {
          logArguments.push(backgroundTextStyle);
        } else {
          logArguments.push(textStyle);
        }
      }
      (_console = console).log.apply(_console, ['%c' + o, textStyle].concat(logArguments));
      return;
    }
    console.log('%c' + o, textStyle);
  });
}(consoleConfig));</script><script type="text/javascript" src="/./js/main.js"></script>

  <script src="//at.alicdn.com/t/font_159214_mvtxvg9me9.js"></script>
</body>
</html>
