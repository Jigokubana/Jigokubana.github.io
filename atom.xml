<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lsmg的大学之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lsmg.xyz/"/>
  <updated>2020-03-20T04:20:31.293Z</updated>
  <id>http://blog.lsmg.xyz/</id>
  
  <author>
    <name>Lsmg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Send返回值引出的(非)阻塞IO</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-Send%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8E%A2%E6%9E%90/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-Send%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8E%A2%E6%9E%90/</id>
    <published>2020-03-20T03:14:20.000Z</published>
    <updated>2020-03-20T04:20:31.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现存疑问"><a href="#现存疑问" class="headerlink" title="现存疑问"></a>现存疑问</h1><ol><li>WNOWAIT和O_NONBLOCK 的关系?</li><li>当非阻塞send时, 返回值与什么有关? 本地socket发送缓冲区空余还是对端空余?</li><li>对端接收缓冲区满了会发生什么?</li><li>暂且认为send返回值是拷贝到缓冲区中的字节数, 如果这些数据没有成功发送呢?</li><li>send函数发送的字节数 超出了recv端的接受能力 会发生什么?</li></ol><p>最近这两天在实战一个http服务器的编写.</p><p>遇到了一个问题: send的返回值小于传入的len, 因为我仅调用一次send函数 导致页面一直显示加载</p><p>然后找了下为什么? 什么时候? send返回值会小于len;</p><h1 id="send"><a href="#send" class="headerlink" title="send"></a>send</h1><p><a href="https://stackoverflow.com/questions/14700906/socket-programming-send-return-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/14700906/socket-programming-send-return-value</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In practice, send() in blocking mode sends all the data, regardless of what the documentation says, unless there was an error, in which case nothing is sent.</span><br><span class="line">实战中, send() 处于阻塞状态会发送所有的数据, 除非发生错误 但这会导致数据没有发送</span><br><span class="line"></span><br><span class="line">In non-blocking mode, it sends whatever will fit into the socket send buffer and returns that length if &gt; 0. If the socket send buffer is full, it returns -1 with errno &#x3D; EWOULDBLOCK&#x2F;EAGAIN.</span><br><span class="line">在非阻塞模式下, 只要能放入socket发送缓冲区 就返回放入的长度 如果缓冲区满了就返回-1 设置EWOULDBLOCK&#x2F;EAGAIN</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247486643&idx=1&sn=9db678398f390759ff81b354ef056000&chksm=fc70f75fcb077e49363b087ba45609fdfbcba286338e70c2d4c7092e83e2d3feac56455e02a2&scene=27#wechat_redirect" target="_blank" rel="noopener">非阻塞模式下 send 和 recv 函数的返回值</a></p><p>这篇博客里也说明了这个问题. 下面是原博客的代码稍作修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐的方式二：在一个循环里面根据偏移量发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* buf , <span class="keyword">int</span> buf_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//已发送的字节数目</span></span><br><span class="line">    <span class="keyword">int</span> sent_bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = send(fd, buf + sent_bytes, buf_length - sent_bytes, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;             </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//认为对端关闭了连接</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sent_bytes += ret;</span><br><span class="line">        <span class="keyword">if</span> (sent_bytes == buf_length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//稍稍降低 CPU 的使用率</span></span><br><span class="line">        usleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;现存疑问&quot;&gt;&lt;a href=&quot;#现存疑问&quot; class=&quot;headerlink&quot; title=&quot;现存疑问&quot;&gt;&lt;/a&gt;现存疑问&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;WNOWAIT和O_NONBLOCK 的关系?&lt;/li&gt;
&lt;li&gt;当非阻塞send时, 返回值与什么有关? 本地
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="Socket理论" scheme="http://blog.lsmg.xyz/categories/CPP/Socket%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux的使用</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-17T04:29:20.000Z</published>
    <updated>2020-03-17T04:56:16.103Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>cp -r</td><td>复制目录</td></tr><tr><td>cd -</td><td>切换到上一个工作目录</td></tr></tbody></table><table><thead><tr><th>查找</th><th>功能</th></tr></thead><tbody><tr><td>find ./ -name “core*”</td><td>xargs file</td></tr><tr><td>find ./ -name ‘*.o’</td><td>查找目标文件夹是否有obj文件</td></tr><tr><td>find ./ -name “*.o” | xargs rm -f</td><td>递归删除当前目录所有obj文件</td></tr></tbody></table><table><thead><tr><th>查看文件内容</th><th>功能</th><th>一般用法</th></tr></thead><tbody><tr><td>cat -n</td><td>显示的同时显示行号</td><td>使用管道 ls | cat -n</td></tr><tr><td>head -10 filename</td><td>查看前十行</td><td></td></tr><tr><td>tail -10 failname</td><td>查看后十行</td><td></td></tr><tr><td>diff file1 file2</td><td>查看文件差别</td><td></td></tr><tr><td>tail -f filename</td><td>动态显示文本的最新信息</td><td></td></tr></tbody></table><p>| 给文件增加别名 | 功能 |<br>| ln a b | 创建硬链接, 删除一个另一个仍能使用 |<br>| ln -s a b | 创建符号链接(软连接) 删除源后另一个无法使用 |</p><p>命令行快捷键<br>Ctl-U   删除光标到行首的所有字符 <code>$ 1111 222  --&gt; $</code><br>Ctl-W   删除光标到前边最近一个空格之间的字符 <code>$ 1111 222 --&gt; $ 1111</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;cp -r&lt;/td&gt;
&lt;td&gt;复制目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cd -&lt;/td&gt;
&lt;td&gt;切换到上一个工作目录
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>UNP卷二读书记录</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95115-UNP%E5%8D%B7%E4%BA%8C/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95115-UNP%E5%8D%B7%E4%BA%8C/</id>
    <published>2020-03-15T03:16:20.000Z</published>
    <updated>2020-03-20T15:19:49.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h1><h2 id="管道和有名管道FIFO"><a href="#管道和有名管道FIFO" class="headerlink" title="管道和有名管道FIFO"></a>管道和有名管道FIFO</h2><p><strong>popen pclose</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 成功返回文件指针, 出错为NULL</span></span><br><span class="line"><span class="function">FILE* <span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line">FILE* fp = popen(command, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功为shell终止状态, 出错则为 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">pclose(fp);</span><br></pre></td></tr></table></figure><p>popen创建一个管道并启动另外一个进程 创建者要么从管道读出标准输入, 要么将标准输出写到管道<br>返回的文件指针作用<br>通过type参数控制<br>type = “r” 创建者 通过文件指针读入command命令产生的标准输出<br>type = “w” 创建者 通过文件指针为command命令提供标准输入</p><p>pclose 关闭这个标准IO流</p><p><strong>FIFO 先进先出(first in, first out)</strong></p><p>又称为有名管道(named pipe) 单向(半双工)数据流, 每个FIFO都有一个路径名与之对应.<br>从而允许无亲缘关系的进程访问同一个FIFO</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回 0 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> FIFO1 = <span class="string">"/tmp/fifo.1"</span>;</span><br><span class="line">mkfifo(FIFO1, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建之后需要打开来进行读或者写 可以使用open也可以使用其他标准IO打开函数</span></span><br><span class="line"><span class="keyword">int</span> writefd = <span class="built_in">open</span>(FIFO1, O_WRONLY, <span class="number">0</span>); <span class="comment">/* 在父进程中打开 父进程写 */</span></span><br><span class="line"><span class="keyword">int</span> readfd = <span class="built_in">open</span>(FIFO1, O_RDONLY, <span class="number">0</span>); <span class="comment">/* 在子进程中打开 子进程读 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有调用unlink才能从文件系统删除文件名字</span></span><br><span class="line">unlink(FIFO1);</span><br></pre></td></tr></table></figure><p>mkfifo 隐含已经指定 O_CREAT | O_EXCL<br>要么不存在创建一个新的, 要么返回 errno=EEXIST(所指定名字的FIFO已经存在)</p><p>如果想要打开已经存在的FIFO可以使用open函数.<br>可以判断 如果返回-1 并且errno=EEXIST 就调用open函数打开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子进程</span></span><br><span class="line">readfd = <span class="built_in">open</span>(FIFO1, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">writefd = <span class="built_in">open</span>(FIFO2, O_WRONLY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程</span></span><br><span class="line">writefd = <span class="built_in">open</span>(FIFO1, O_WRONLY, <span class="number">0</span>);</span><br><span class="line">readfd = <span class="built_in">open</span>(FIFO2, O_RDONLY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程 这样会阻塞</span></span><br><span class="line">readfd = <span class="built_in">open</span>(FIFO2, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">writefd = <span class="built_in">open</span>(FIFO1, O_WRONLY, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果调换父进程的两行代码 程序就会进入死锁<br>因为如果当前没有任何进程<code>打开某个FIFO来写</code>, 打开这个<code>FIFO来读</code>的进程将会<code>阻塞</code></p><p>当对一个管道或者FIFO的最终close发生的时候, 该管道或FIFO中的任何残余数据都将被丢弃</p><p>即使在A主机上能够访问到B主机的目录, 即使不同主机上的两个进程都能够通过NFS打开同一个FIFO<br>他们之间也不能通过FIFO从一个进程到另一个进程发送数据</p><p>拒绝服务型攻击Dos<br>如果是单进程可能会让服务器处于阻塞状态, 多进程也可能会由于一个恶意客户发送大量独立请求<br>导致服务器子进程数达到上限, 使得后续的fork失败</p><p><strong>其他</strong><br>从字节流中获取完整的单个信息</p><ul><li>带特殊终止序列<br>许多UNIX应用使用换行分割 因特尔应用程序使用回车符加上一个换行符</li><li>显式长度<br>将长度增加在请求中</li><li>每次连接一个记录<br>应用通过关闭对端连接指示一个记录结束. HTTP1.0使用的这一技术</li></ul><p>标准IO函数fdopen可以将标准IO流与pipe返回的文件描述符相关联’</p><p><strong>限制</strong><br>系统加在管道和FIFO的唯一限制是</p><ul><li>OPEN_MAX<br>一个进程在任意时刻打开的最大描述符数量 &gt;=16</li><li>PIPE_BUF<br>可以原子性的写入一个管道或FIFO的最大数据量 &gt;= 512</li></ul><p><strong>习题练习</strong></p><ol><li>父进程终止的时候, 如果子进程的fd[1]仍处于打开状态, 则子进程对fd[0]的read 不会返回文件结束符,<br>因为fd[1]虽然在父进程中关闭了, 但是在子进程中依然打开. 如果关闭子进程fd[1], 则父进程一旦关闭,<br>他的所有文件描述符即关闭, 子进程对fd[0]的read就会返回0.(想到了自己写的服务器, 客户端断开连接就会read出一个0长度的内容)</li><li>从 不存在即创建, 存在-&gt;打开 变成 存在-&gt;打开, 不存在即创建. 可能会在open打开失败后 创建fifo之前<br>被其他进程抢先创建fifo, 导致本进程的mkfifo调用失败</li><li>出错信息写到了标准错误输出</li><li>可以把第一个open调用设置成非阻塞, 但是为了避免readline返回错误, 标志必须在readline之前去除</li><li>死锁</li><li>读进程关闭管道或者FIFO后给写进程一个信号(往关闭的管道写会产生SIGPIPE信号),<br>写进程关闭管道或者FIFO后将文件结束符发送给读进程(读进程读到长度为0的文件结束符)</li></ol><h2 id="POSIX消息队列"><a href="#POSIX消息队列" class="headerlink" title="POSIX消息队列"></a>POSIX消息队列</h2><p><strong>mqueue创建和删除</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// oflag O_RDONLY O_WRONLY O_RDWR 可以加上O_CREAT和O_EXCL或者O_NONBLOCK</span></span><br><span class="line"><span class="comment">// 创建一个新队列的时候(制定了O_CREAT且消息队列不存在)后两个参数都需要</span></span><br><span class="line"><span class="comment">// 权限位 和 指定某些属性 nullptr则使用默认属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回消息队列 fd 失败 -1</span></span><br><span class="line"><span class="function"><span class="keyword">mqd_t</span> <span class="title">mq_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="comment">/*mode_t mode, struct mq_attr *attr*/</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>注意<br>消息队列文件描述符不必是(而且很可能不是)像文件描述符或者socket文件描述符那样的短整数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭消息队列 引用计数 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_close</span><span class="params">(<span class="keyword">mqd_t</span> mqdes)</span></span>;</span><br></pre></td></tr></table></figure><p>类似close函数, 调用进程可以不再使用该文件描述符, 但是其消息队列并不会从系统中删除</p><p>当一个进程终止的时候, 所有打开着的消息队列都将关闭, 就像自动调用了mq_close</p><p>如果要从系统中删除<code>mq_open</code>第一个参数<code>name</code> 必须调用下面的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用计数 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><p>每个消息队列有一个保存着当前打开描述符数的引用计数器</p><p>当消息队列的引用计数仍大于0时, 其name就能删除<br>但是队列的析构会在<code>引用计数为0</code>的时候自动析构.</p><p>第一个demo敲完之后 一直是errno=13.<br>在<code>man mq_overview</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">On Linux, message queues are created in a virtual filesystem.   (Other  implementa‐</span><br><span class="line">tions may also provide such a feature, but the details are likely to differ.)  This</span><br><span class="line">filesystem can be mounted (by the superuser) using the following commands:</span><br><span class="line"></span><br><span class="line"># mkdir &#x2F;dev&#x2F;mqueue</span><br><span class="line"># mount -t mqueue none &#x2F;dev&#x2F;mqueue</span><br><span class="line"></span><br><span class="line">The sticky bit is automatically enabled on the mount directory.</span><br></pre></td></tr></table></figure><p>而且 name参数的格式是<code>/somename</code> 这个是相对挂载目录的</p><p><strong>属性设置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mq_flags; <span class="comment">/* 0, O_NONBLOCK */</span></span><br><span class="line">    <span class="keyword">long</span> mq_maxmsg; <span class="comment">/* max number */</span></span><br><span class="line">    <span class="keyword">long</span> mq_msgsize; <span class="comment">/* max size of a msg in bytes */</span></span><br><span class="line">    <span class="keyword">long</span> mq_curmsgs; <span class="comment">/* number of message currently on queue */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_getattr</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, struct mq_attr *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 的时候 只有mq_attr中的mq_flags起作用 设置取消O_NONBLOCK</span></span><br><span class="line"><span class="comment">// 最大消息数和最大字节数 只能在创建队列的时候设置</span></span><br><span class="line"><span class="comment">// 队列中房钱消息数 只能获取不能设置</span></span><br><span class="line"><span class="comment">// 第三个参数 不为nullptr则返回之前的属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_setattr</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> struct mq_attr *attr, struct mq_attr *oattr)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>发送接收信息</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prio 优先级 必须 &lt;= MQ_PRIO_MAX</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_send</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> prio)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// len 必须 &gt;= mq_attr.mq_msgsize 如果小于则 errno = EMSGSIZE</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">mq_receive</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> *priop)</span></span>;</span><br></pre></td></tr></table></figure><p>如果不使用优先级 发送的时候可以将 mq_send的 prio 设置为0<br>接受的时候 mq_receive priop 设置为 nullptr</p><p><strong>消息队列的限制</strong></p><ul><li>mq_maxmsg 队列中最大消息数</li><li>mq_msgsize单个消息的最大字节</li><li>MQ_OPEN_MAX 一个进程同时打开消息队列的最大数目</li><li>MQ_PRIO_MAX 最大优先级+1</li></ul><p><strong>异步事件通知</strong></p><ul><li>产生信号</li><li>创建一个线程执行一个指定的函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为指定队列建立或者删除异步事件通知.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回 0 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_notify</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, struct sigevent *nofification)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sival_int;</span><br><span class="line">    <span class="keyword">void</span> *sival_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sigev_notify; <span class="comment">// SIGEV_NONE SIGEV_SIGNAL SIGEV_THREAD</span></span><br><span class="line">    <span class="keyword">int</span> sigev_signo; <span class="comment">// signal number if SIGEV_SIGNAL</span></span><br><span class="line">    <span class="keyword">union</span> sigval sigev_value; <span class="comment">// passed to signal handler pr thread</span></span><br><span class="line">    <span class="comment">// 下面两个用于 SIGEV_THREAD</span></span><br><span class="line">    <span class="keyword">void</span> (*sigev_notify_function)(<span class="keyword">union</span> sigval);</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> *sigev_notify_attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>如果 notification != nullptr<br>当前进程希望 在有一个消息 到达所指定的 先前为空的队列 时得到通知<br>我们说 该进程被注册为接收该队列的通知</p></li><li><p>如果 notification == nullptr<br>如果 该进程被注册为 接受所指定队列通知 则取消它</p></li><li><p>任何时刻只有一个进程可以被注册为 接收某个队列的通知</p></li><li><p>当一个消息到达某个空队列, 而且已经注册, 那么只有当<br>没有因为调用mq_reveive导致的阻塞 的时候才会发出通知</p></li><li><p>通知发出后 注册立即被撤销.. 需要重新注册???</p></li></ol><p>Unix信号产生后会复位成默认行为.<br>信号处理程序通常第一个调用signal函数, 用于重新建立处理程序<br>这时会产生一个空窗时期(信号产生 与 当前进程重建信号处理程序之间)<br>空窗时期再次产生同一信号 可能终止当前进程</p><p>初看起来, mq_notify可能也有这个问题.<br>不过在消息队列<code>为空前</code> <code>通知不会再次产生</code><br>所以不要在<code>读出消息后</code>重新注册<br>而应该在<code>读出消息前</code>重新注册</p><p><code>volatile sig_atomic_t mqflag = 0;</code><br>sig_atomic_t 即使缺少信号所做的异步中断，亦能作为原子实体访问的整数类型。<br>volatile 标记可能会随时改变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;消息传递&quot;&gt;&lt;a href=&quot;#消息传递&quot; class=&quot;headerlink&quot; title=&quot;消息传递&quot;&gt;&lt;/a&gt;消息传递&lt;/h1&gt;&lt;h2 id=&quot;管道和有名管道FIFO&quot;&gt;&lt;a href=&quot;#管道和有名管道FIFO&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>GDB调试</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-GDB%E8%B0%83%E8%AF%95/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-GDB%E8%B0%83%E8%AF%95/</id>
    <published>2020-03-14T07:09:20.000Z</published>
    <updated>2020-03-17T08:39:20.200Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p><p>对多线程的支持<br>set follow-fork-mode [parent|child]<br>set detach-on-fork [on|off]</p><table><thead><tr><th>follow-fork-mode</th><th>detach-on-fork</th><th>说明</th></tr></thead><tbody><tr><td>parent</td><td>on</td><td>只调试主进程</td></tr><tr><td>child</td><td>on</td><td>只调试子进程</td></tr><tr><td>parent</td><td>off</td><td>同时调试父子进程, gdb跟踪父进程, 子进程阻塞在fork位置</td></tr><tr><td>child</td><td>off</td><td>同上 gdb跟踪子进程, 父进程阻塞</td></tr></tbody></table><p>进程间切换<br>| 命令 | 功能 |<br>| — | — |<br>| info inferiors | 查询正在调试的进程 |<br>| inferior &lt;number&gt; | 切换进程 |</p><table><thead><tr><th>运行命令</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>run</td><td>r</td><td>运行程序</td></tr><tr><td>continue</td><td>c</td><td>继续执行到下有一个断点处</td></tr><tr><td>next</td><td>n</td><td>单步跟踪, 不进入函数</td></tr><tr><td>step</td><td>s</td><td>会进入函数</td></tr><tr><td>until</td><td></td><td>运行程序直到退出循环体</td></tr><tr><td>until + 行号</td><td></td><td>运行至某行</td></tr><tr><td>finish</td><td></td><td>运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回以及参数等信息</td></tr><tr><td>call 函数(参数)</td><td></td><td>调试程序中的可见参数, 并传递参数</td></tr><tr><td>quit</td><td>q</td><td>退出</td></tr></tbody></table><table><thead><tr><th>设置断点</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>break n</td><td>b n</td><td>在第n行设置断点, b xx.cpp:500(xx.cpp文件第500行)</td></tr><tr><td>b fn if a&gt;b</td><td></td><td>在函数f 或者行号n 设置条件断点</td></tr><tr><td>break func</td><td>b func</td><td>在函数func()的入口处设置断点</td></tr><tr><td>delete 断点号n</td><td></td><td>删除第n个断点</td></tr><tr><td>disable 断点号n</td><td></td><td>暂停第n个断点</td></tr><tr><td>enable 断点号n</td><td></td><td>开始第n的断点</td></tr><tr><td>clear 行号n</td><td></td><td>清除第n行的断点</td></tr><tr><td>info b</td><td></td><td>显示断点设置情况</td></tr><tr><td>delete breakpoints</td><td></td><td>清除所有断点</td></tr></tbody></table><table><thead><tr><th>查看源代码</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>默认显示10行</td></tr><tr><td>list 行号</td><td></td><td>以行号为中心的前后十行代码</td></tr><tr><td>list 函数名</td><td></td><td>列出函数名所在函数的代码</td></tr><tr><td>list</td><td></td><td>不带参数, 接着上一次的list命令输出下边的内容</td></tr></tbody></table><table><thead><tr><th>打印表达式</th><th>功能</th></tr></thead><tbody><tr><td>print p</td><td></td></tr><tr><td>p a</td><td>显示a的值</td></tr><tr><td>p ++a</td><td>a的值</td></tr><tr><td>p func(22)</td><td>以整数22作为参数调用 后打印</td></tr><tr><td>p func(a)</td><td>将变量a作为参数</td></tr><tr><td>display 表达式</td><td>每次单步运行后就打印表达式的值</td></tr><tr><td>watch 表达式</td><td>设置检视点, 一旦被监视的表达式值改变就强行终止正在被调试的程序</td></tr><tr><td>whatis</td><td>查询变量或函数</td></tr><tr><td>info function</td><td>查询函数</td></tr><tr><td>info local</td><td>显示当前堆栈页的所有变量</td></tr></tbody></table><table><thead><tr><th>查询运行信息</th><th>功能</th></tr></thead><tbody><tr><td>where/bt</td><td>当前运行的堆栈列表</td></tr><tr><td>bt backtrace</td><td>显示当前的调用堆栈</td></tr><tr><td>up/down</td><td>改变堆栈的显示深度</td></tr><tr><td>set args [args]</td><td>指定程序运行参数</td></tr><tr><td>show args</td><td>查看程序参数</td></tr><tr><td>info program</td><td>查看程序是否运行, 进程号, 被暂停原因</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://linuxtools-rst.readthed
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="GDB调试" scheme="http://blog.lsmg.xyz/tags/GDB%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>csapp笔记</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-csapp/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-csapp/</id>
    <published>2020-03-14T07:09:20.000Z</published>
    <updated>2020-03-14T10:15:31.077Z</updated>
    
    <content type="html"><![CDATA[<p>选择性阅读</p><h1 id="第十二章-并发编程"><a href="#第十二章-并发编程" class="headerlink" title="第十二章 并发编程"></a>第十二章 并发编程</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;选择性阅读&lt;/p&gt;
&lt;h1 id=&quot;第十二章-并发编程&quot;&gt;&lt;a href=&quot;#第十二章-并发编程&quot; class=&quot;headerlink&quot; title=&quot;第十二章 并发编程&quot;&gt;&lt;/a&gt;第十二章 并发编程&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="csapp" scheme="http://blog.lsmg.xyz/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>权限管理</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3/</id>
    <published>2020-03-14T07:09:20.000Z</published>
    <updated>2020-03-14T10:14:04.755Z</updated>
    
    <content type="html"><![CDATA[<p><code>drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs</code><br>档案权限类型<br>连接数<br>档案拥有者<br>档案所属群组<br>档案容量<br>档案最后被修改时间<br>档名</p><p>文件类型和权限<br><code>drwxr-xr-x</code></p><p>第一位 d 表明档案类型是 目录</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>d</td><td>目录</td></tr><tr><td>-</td><td>文件</td></tr><tr><td>|</td><td>链接文件</td></tr><tr><td>b</td><td>设备文件中可供存储的周边设备, 可随机读取设备</td></tr><tr><td>c</td><td>序列号设备, 如键盘鼠标, 一次性读取设备</td></tr></tbody></table><p>后面每三位一组 为<code>rwx</code>的组合 分别代表 <code>读</code>, <code>写</code>, <code>执行</code><br>三组 第一组<code>文件拥有者权限</code> 第二组<code>群组中账号权限</code> 第三组<code>非本人且没有加入本群组的其他账号权限</code></p><p>第三部分表示这个文件的<code>拥有者账号</code><br>第四部分表示这个文件<code>所属群组</code></p><p>相关命令<br>-chgrp 改变文件所属群组<br>-chown 改变文件拥有者<br>-chmod 改变文件权限</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs&lt;/code&gt;&lt;br&gt;档案权限类型&lt;br&gt;连接数&lt;br&gt;档案拥有者&lt;br&gt;档案所属群组&lt;br&gt;档案容量&lt;br&gt;档案最后被修改时间&lt;br&gt;档名&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="权限管理" scheme="http://blog.lsmg.xyz/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>UE4TCP数据传输</title>
    <link href="http://blog.lsmg.xyz/2020/03/UE4-%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"/>
    <id>http://blog.lsmg.xyz/2020/03/UE4-%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/</id>
    <published>2020-03-08T08:38:28.000Z</published>
    <updated>2020-03-09T13:36:52.520Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下UE4 Tcp传输数据的客户端代码<br>方便日后使用</p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>#include “Networking.h”</p><p>// 添加 Networking 和 Sockets<br>PublicDependencyModuleNames.AddRange(new string[] { “Core”, “CoreUObject”, “Engine”, “InputCore”, “Networking”, “Sockets”});</p><h1 id="用到的数据结构"><a href="#用到的数据结构" class="headerlink" title="用到的数据结构"></a>用到的数据结构</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">FMsgType</span>:</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">EROOM_ENTER,</span><br><span class="line">EROOM_EXIT,</span><br><span class="line">EPLAYER_READY,</span><br><span class="line">EPLAYER_CANCEL_READY,</span><br><span class="line">EGAME_START,</span><br><span class="line">EROOM_PLAY_DATA,</span><br><span class="line">EGAME_OVER</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">FMsgVersion</span> :</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">VERSION0 = <span class="number">0</span>,</span><br><span class="line">VERSION1 = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoHead</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FMsgType MsgType;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    FMsgVersion MsgVer;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    int32 BodyLen;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoBody</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    <span class="keyword">bool</span> Result;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    int32 MsgId;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    TArray&lt;int32&gt; DataArray;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoMsg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    FProtoHead Header;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    FProtoBody Body;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="socket管理"><a href="#socket管理" class="headerlink" title="socket管理"></a>socket管理</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span>;</span><br><span class="line"></span><br><span class="line">FIPv4Address Ip;</span><br><span class="line">FSocket* ClientFd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将字符串ip转换为点分十进制ip</span></span><br><span class="line">    FIPv4Address::Parse(IPStr, Ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将十进制ip 转化成网络地址</span></span><br><span class="line">    TSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();</span><br><span class="line">    addr-&gt;SetIp(Ip.Value);</span><br><span class="line">    addr-&gt;SetPort(Port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP Socket 文件描述符</span></span><br><span class="line">    ClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class="string">"TCP SOCKET"</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ClientFd-&gt;Connect(*addr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据发送和接收"><a href="#数据发送和接收" class="headerlink" title="数据发送和接收"></a>数据发送和接收</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendMsg</span><span class="params">(FProtoMsg Msg)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RecvMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::SendMsg</span><span class="params">(FProtoMsg Msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Len;</span><br><span class="line"><span class="keyword">int</span> Send;</span><br><span class="line">uint8* data;</span><br><span class="line">data = Encode(Msg, &amp;Len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ClientFd-&gt;Send(data, Len, Send))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::RecvMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ClientFd != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">uint8 Buffer[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">uint32 Size = <span class="number">0</span>;</span><br><span class="line">int32 Read = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ClientFd-&gt;HasPendingData(Size))</span><br><span class="line">&#123;</span><br><span class="line">ClientFd-&gt;Recv(Buffer, <span class="number">1024</span>, Read);</span><br><span class="line"><span class="keyword">return</span> Decode(Buffer, Read);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据序列化"><a href="#数据序列化" class="headerlink" title="数据序列化"></a>数据序列化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="function">uint8* <span class="title">Encode</span><span class="params">(FProtoMsg Msg, int32* Len)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> HEADER_SIZE = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function">uint8* <span class="title">AGameNetwork::Encode</span><span class="params">(FProtoMsg Msg, int32* Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Msg.Header.BodyLen = Msg.Body.DataArray.Num() * Msg.Body.DataArray.GetTypeSize() + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">*Len = Msg.Header.BodyLen + HEADER_SIZE;</span><br><span class="line"><span class="comment">// HEADER</span></span><br><span class="line"><span class="keyword">auto</span> data = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[*Len];</span><br><span class="line">    <span class="keyword">auto</span> pdata = data;</span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, *Len);</span><br><span class="line"></span><br><span class="line">*pdata = (uint8)Msg.Header.MsgType;</span><br><span class="line">pdata++;</span><br><span class="line"></span><br><span class="line">*pdata = (uint8)Msg.Header.MsgVer;</span><br><span class="line">pdata++;</span><br><span class="line"></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)pdata = Msg.Header.BodyLen;</span><br><span class="line">pdata += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BODY</span></span><br><span class="line">pdata++;</span><br><span class="line">*(<span class="keyword">uint32_t</span>*)pdata = Msg.Body.MsgId;</span><br><span class="line">pdata += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(pdata, Msg.Body.DataArray.GetData(), Msg.Header.BodyLen - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据反序列化"><a href="#数据反序列化" class="headerlink" title="数据反序列化"></a>数据反序列化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Decode</span><span class="params">(uint8* data, int32 len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParseHeader</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParseBody</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseStatus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PARSE_INIT,</span><br><span class="line">    PARSE_HEAD,</span><br><span class="line">    PARSE_BODY</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TArray&lt;uint8&gt; ReservedData;</span><br><span class="line">FProtoMsg* CurrentMsg;</span><br><span class="line">ParseStatus ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class="line">TArray&lt;FProtoMsg&gt; MsgArray;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::Decode</span><span class="params">(uint8* data, int32 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 防止沾包 直接将受到的数据全部按顺序存储</span></span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ReservedData.Push(data[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int32 r_len = ReservedData.Num();</span><br><span class="line">uint8* r_data = ReservedData.GetData();</span><br><span class="line">int32 parse_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (r_len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (ParseStatus)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_INIT:</span><br><span class="line">CurrentMsg = <span class="keyword">new</span> FProtoMsg();</span><br><span class="line">ParseStatus = ParseStatus::PARSE_HEAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_HEAD:</span><br><span class="line"><span class="keyword">if</span> (!ParseHeader(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_BODY:</span><br><span class="line"><span class="keyword">if</span> (!ParseBody(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CurrentMsg != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">MsgArray.Push(*CurrentMsg);</span><br><span class="line">&#125;</span><br><span class="line">CurrentMsg = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; parse_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ReservedData.Pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::ParseHeader</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*reserved_len &lt; HEADER_SIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8* data = *r_data;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.MsgType = StaticCast&lt;FMsgType&gt;(*data);</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.MsgVer = StaticCast&lt;FMsgVersion&gt;(*data);</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.BodyLen = *(uint32*)data;</span><br><span class="line"></span><br><span class="line">*reserved_len -= HEADER_SIZE;</span><br><span class="line">*parse_len += HEADER_SIZE;</span><br><span class="line">*r_data += HEADER_SIZE;</span><br><span class="line"></span><br><span class="line">ParseStatus = ParseStatus::PARSE_BODY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::ParseBody</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*reserved_len &lt; CurrentMsg-&gt;Header.BodyLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8* data = *r_data;</span><br><span class="line"><span class="comment">// current_msg-&gt;body = data;</span></span><br><span class="line">CurrentMsg-&gt;Body.Result = (*data) == <span class="number">1</span>;</span><br><span class="line">data++;</span><br><span class="line">CurrentMsg-&gt;Body.MsgId = *(int32*)data;</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ((CurrentMsg-&gt;Header.BodyLen - <span class="number">5</span>) / <span class="keyword">sizeof</span>(int32)); ++i)</span><br><span class="line">&#123;</span><br><span class="line">CurrentMsg-&gt;Body.DataArray.Add(*(int32*)data);</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*reserved_len -= CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line">*parse_len += CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line">*r_data += CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line"></span><br><span class="line">ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line">    <span class="function">FProtoMsg <span class="title">Front</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line">    <span class="function">TArray&lt;FProtoMsg&gt; <span class="title">PopBackAllMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::IsEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MsgArray.Num() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FProtoMsg <span class="title">AGameNetwork::Front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MsgArray.Top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AGameNetwork::Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// MsgArray.Pop();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TArray&lt;FProtoMsg&gt; <span class="title">AGameNetwork::PopBackAllMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TArray&lt;FProtoMsg&gt; MsgArrayTemp = MsgArray;</span><br><span class="line">MsgArray.Empty();</span><br><span class="line"><span class="keyword">return</span> MsgArrayTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整代码-继承自GameStateBase"><a href="#完整代码-继承自GameStateBase" class="headerlink" title="完整代码-继承自GameStateBase"></a>完整代码-继承自GameStateBase</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CoreMinimal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GameFramework/GameStateBase.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Networking.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GameNetwork.generated.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">FMsgType</span>:</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">EROOM_ENTER,</span><br><span class="line">EROOM_EXIT,</span><br><span class="line">EPLAYER_READY,</span><br><span class="line">EPLAYER_CANCEL_READY,</span><br><span class="line">EGAME_START,</span><br><span class="line">EROOM_PLAY_DATA,</span><br><span class="line">EGAME_OVER</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">FMsgVersion</span> :</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">VERSION0 = <span class="number">0</span>,</span><br><span class="line">VERSION1 = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoHead</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FMsgType MsgType;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FMsgVersion MsgVer;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">int32 BodyLen;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoBody</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line"><span class="keyword">bool</span> Result;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">int32 MsgId;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">TArray&lt;int32&gt; DataArray;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoMsg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FProtoHead Header;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FProtoBody Body;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PACMAN_API</span> <span class="title">AGameNetwork</span> :</span> <span class="keyword">public</span> AGameStateBase</span><br><span class="line">&#123;</span><br><span class="line">GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendMsg</span><span class="params">(FProtoMsg Msg)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RecvMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function">FProtoMsg <span class="title">Front</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function">TArray&lt;FProtoMsg&gt; <span class="title">PopBackAllMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">FIPv4Address Ip;</span><br><span class="line"></span><br><span class="line">FSocket* ClientFd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseStatus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">PARSE_INIT,</span><br><span class="line">PARSE_HEAD,</span><br><span class="line">PARSE_BODY</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Decode</span><span class="params">(uint8* data, int32 len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">uint8* <span class="title">Encode</span><span class="params">(FProtoMsg Msg, int32* Len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> HEADER_SIZE = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">TArray&lt;uint8&gt; ReservedData;</span><br><span class="line"></span><br><span class="line">FProtoMsg* CurrentMsg;</span><br><span class="line"></span><br><span class="line">ParseStatus ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class="line"></span><br><span class="line">TArray&lt;FProtoMsg&gt; MsgArray;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParseHeader</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParseBody</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GameNetwork.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将字符串ip转换为点分十进制ip</span></span><br><span class="line">FIPv4Address::Parse(IPStr, Ip);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十进制ip 转化成网络地址</span></span><br><span class="line">TSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();</span><br><span class="line">addr-&gt;SetIp(Ip.Value);</span><br><span class="line">addr-&gt;SetPort(Port);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建TCP Socket 文件描述符</span></span><br><span class="line">ClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class="string">"TCP SOCKET"</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ClientFd-&gt;Connect(*addr))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::SendMsg</span><span class="params">(FProtoMsg Msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Len;</span><br><span class="line"><span class="keyword">int</span> Send;</span><br><span class="line">uint8* data;</span><br><span class="line">data = Encode(Msg, &amp;Len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ClientFd-&gt;Send(data, Len, Send))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::RecvMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ClientFd != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">uint8 Buffer[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">uint32 Size = <span class="number">0</span>;</span><br><span class="line">int32 Read = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ClientFd-&gt;HasPendingData(Size))</span><br><span class="line">&#123;</span><br><span class="line">ClientFd-&gt;Recv(Buffer, <span class="number">1024</span>, Read);</span><br><span class="line"><span class="keyword">return</span> Decode(Buffer, Read);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::Decode</span><span class="params">(uint8* data, int32 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 防止沾包 直接将受到的数据全部按顺序存储</span></span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ReservedData.Push(data[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int32 r_len = ReservedData.Num();</span><br><span class="line">uint8* r_data = ReservedData.GetData();</span><br><span class="line">int32 parse_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (r_len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (ParseStatus)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_INIT:</span><br><span class="line">CurrentMsg = <span class="keyword">new</span> FProtoMsg();</span><br><span class="line">ParseStatus = ParseStatus::PARSE_HEAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_HEAD:</span><br><span class="line"><span class="keyword">if</span> (!ParseHeader(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_BODY:</span><br><span class="line"><span class="keyword">if</span> (!ParseBody(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CurrentMsg != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">MsgArray.Push(*CurrentMsg);</span><br><span class="line">&#125;</span><br><span class="line">CurrentMsg = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; parse_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ReservedData.Pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint8* <span class="title">AGameNetwork::Encode</span><span class="params">(FProtoMsg Msg, int32* Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Msg.Header.BodyLen = Msg.Body.DataArray.Num() * Msg.Body.DataArray.GetTypeSize() + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">*Len = Msg.Header.BodyLen + HEADER_SIZE;</span><br><span class="line"><span class="comment">// HEADER</span></span><br><span class="line"><span class="keyword">auto</span>* data = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[*Len];</span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, *Len);</span><br><span class="line"></span><br><span class="line">*data = (uint8)Msg.Header.MsgType;</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">*data = (uint8)Msg.Header.MsgVer;</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)data = Msg.Header.BodyLen;</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BODY</span></span><br><span class="line">data++;</span><br><span class="line">*(<span class="keyword">uint32_t</span>*)data = Msg.Body.MsgId;</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(data, Msg.Body.DataArray.GetData(), Msg.Header.BodyLen - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回退增加的部分</span></span><br><span class="line"><span class="keyword">return</span> data - HEADER_SIZE - <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::ParseHeader</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*reserved_len &lt; HEADER_SIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8* data = *r_data;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.MsgType = StaticCast&lt;FMsgType&gt;(*data);</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.MsgVer = StaticCast&lt;FMsgVersion&gt;(*data);</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.BodyLen = *(uint32*)data;</span><br><span class="line"></span><br><span class="line">*reserved_len -= HEADER_SIZE;</span><br><span class="line">*parse_len += HEADER_SIZE;</span><br><span class="line">*r_data += HEADER_SIZE;</span><br><span class="line"></span><br><span class="line">ParseStatus = ParseStatus::PARSE_BODY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::ParseBody</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*reserved_len &lt; CurrentMsg-&gt;Header.BodyLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8* data = *r_data;</span><br><span class="line"><span class="comment">// current_msg-&gt;body = data;</span></span><br><span class="line">CurrentMsg-&gt;Body.Result = (*data) == <span class="number">1</span>;</span><br><span class="line">data++;</span><br><span class="line">CurrentMsg-&gt;Body.MsgId = *(int32*)data;</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ((CurrentMsg-&gt;Header.BodyLen - <span class="number">5</span>) / <span class="keyword">sizeof</span>(int32)); ++i)</span><br><span class="line">&#123;</span><br><span class="line">CurrentMsg-&gt;Body.DataArray.Add(*(int32*)data);</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*reserved_len -= CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line">*parse_len += CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line">*r_data += CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line"></span><br><span class="line">ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::IsEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MsgArray.Num() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FProtoMsg <span class="title">AGameNetwork::Front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MsgArray.Top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AGameNetwork::Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// MsgArray.Pop();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TArray&lt;FProtoMsg&gt; <span class="title">AGameNetwork::PopBackAllMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TArray&lt;FProtoMsg&gt; MsgArrayTemp = MsgArray;</span><br><span class="line">MsgArray.Empty();</span><br><span class="line"><span class="keyword">return</span> MsgArrayTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一下UE4 Tcp传输数据的客户端代码&lt;br&gt;方便日后使用&lt;/p&gt;
&lt;h1 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;headerlink&quot; title=&quot;头文件&quot;&gt;&lt;/a&gt;头文件&lt;/h1&gt;&lt;p&gt;#include “Networking.h”&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="UE4" scheme="http://blog.lsmg.xyz/categories/UE4/"/>
    
      <category term="网络" scheme="http://blog.lsmg.xyz/categories/UE4/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器-理论部分</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9599-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9599-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/</id>
    <published>2020-03-06T14:53:00.000Z</published>
    <updated>2020-03-17T12:09:12.437Z</updated>
    
    <content type="html"><![CDATA[<p>距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.<br>半年后开始准备补上这四章</p><h1 id="第一章-TCP-IP协议族"><a href="#第一章-TCP-IP协议族" class="headerlink" title="第一章 TCP/IP协议族"></a>第一章 TCP/IP协议族</h1><h2 id="TCP-IP协议族体系结构和主要协议"><a href="#TCP-IP协议族体系结构和主要协议" class="headerlink" title="TCP/IP协议族体系结构和主要协议"></a>TCP/IP协议族体系结构和主要协议</h2><p>协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg" alt=""></p><p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=3a1768f4c6fc1e17e9b284632bf99d66/0dd7912397dda144d48ab350bbb7d0a20df48655.jpg" alt=""></p><p>同样七层是osi参考模型, 简化后得到四层<br>不同层次之间, 通过接口互相交流, 这样方便了各层次的修改</p><p><strong>应用层</strong><br>负责处理应用程序的逻辑</p><p><strong>表示层</strong><br>定义了数据的格式及加密</p><p><strong>会话层</strong><br>它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的</p><p><strong>传输层</strong><br>为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.<br>此层存在两大协议TCP协议和UDP协议<br>TCP协议(Transmission Control Protocol 传输控制协议)</p><ul><li>为应用层提供<code>可靠的, 面向连接, 基于流的服务</code></li><li>通过<code>超时重传</code>和<code>数据确认</code>等确保数据正常送达.</li><li>TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器<br>UPD协议(User Datagram Protocol 用户数据报协议)</li><li>为应用层提供<code>不可靠的, 无连接的, 基于数据报的服务</code></li><li>一般需要自己处理<code>数据确认</code>和<code>超时重传</code>的问题</li><li>通信两者不存储状态, 每次发送都需要指定地址信息. <code>有自己的长度</code></li></ul><p><strong>网络层</strong><br>实现了数据包的选路和转发.  只有数据包到不了目标地址, 就<code>下一跳</code>(hop by hop), 选择最近的.<br><em>IP协议(Internet Protocol)</em> 以及 <em>ICMP协议(Internet Control Message Protocol)</em><br>后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)</p><p><strong>数据链路层</strong><br>实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.<br>存在两个协议 <em>ARP协议(Address Resolve Protocol, 地址解析协议)</em>. 还有<em>RARP(Reverse ~, 逆地址解析协议)</em>.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议<em>ARP欺骗, 可能与这个有关, 目前不去学习</em></p><p><strong>封装</strong><br>上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.<br>被TCP封装的数据成为 <code>TCP报文段</code></p><ul><li>内核部分发送成功后删除数据</li></ul><p>被UDP封装的数据成为 <code>UDP数据报</code></p><ul><li>发送后即删除</li></ul><p>再经IP封装后成为<code>IP数据报</code><br>最后经过数据链路层封装后为 <code>帧</code></p><p>以太网最大数据帧1518字节 抛去14头部 帧尾4校验<br>MTU: 帧的最大传输单元 一般为1500字节<br>MSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头-20TCP头 还有额外的40字节可选部分</p><p><strong>ARP</strong><br>ARP协议能实现任意网络层地址到任意物理地址的转换</p><h1 id="第二章-IP协议详解"><a href="#第二章-IP协议详解" class="headerlink" title="第二章 IP协议详解"></a>第二章 IP协议详解</h1><p>IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一<br>IP协议为上层协议提供无状态, 无连接, 不可靠的服务</p><p>IP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制</p><p>当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png" alt=""></p><p>路由机制</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png" alt=""></p><p>给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤</p><ul><li>查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步</li><li>查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到……. 否则下一步</li><li>选择默认路由项, 通常意味着下一跳路由是网关</li></ul><h1 id="第三章-TCP协议详解"><a href="#第三章-TCP协议详解" class="headerlink" title="第三章 TCP协议详解"></a>第三章 TCP协议详解</h1><p>Tcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.</p><p>UDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断</p><p>ISN-初始序号值<br>32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移<br>32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答</p><p>ACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为<code>确认报文段</code><br>PSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间<br>RST标志: 要求对方重新建立连接 携带……<code>复位报文段</code><br>SYN标志: 标志请求建立一个连接 携带……<code>同步报文段</code><br>FIN标志: 通知对方本端连接要关闭了, 携带..<code>结束报文段</code></p><p>16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据<br>16位校验和: <code>可靠传输的重要保障</code>发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验<code>TCP头部</code>和<code>数据部分</code></p><p><strong>TCP连接的建立和关闭</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 三次握手</span><br><span class="line"># 客户端发送请求连接 ISN&#x3D;seq + 0 &#x3D; 3683340920</span><br><span class="line"># mss 最大数据载量1460</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [S], seq 3683340920, win 64240, </span><br><span class="line">options [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0</span><br><span class="line"></span><br><span class="line"># 同意客户端连接</span><br><span class="line"># ack &#x3D; 客户端发送 seq + 1</span><br><span class="line"># 同时发送服务端的seq</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [S.], seq 938535101, ack 3683340921, win 64240, </span><br><span class="line">options [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0</span><br><span class="line"></span><br><span class="line"># 虽然这个报文段没有字节 但由于是同步报文段 需要占用一个序号值</span><br><span class="line"># 这里是tcpdump的处理 ack显示相对值 即 3683340921 - 3683340920 &#x3D; 1</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [.], ack 938535102, win 4106, length 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 包含FIN标志 说明要求结束连接 也需要占用一个序号值</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [F.], seq 1, ack 1, win 4106, length 0</span><br><span class="line"></span><br><span class="line"># 服务端确认关闭连接</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [.], ack 2, win 502, length 0</span><br><span class="line"></span><br><span class="line"># 服务端发送关闭连接</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [F.], seq 1, ack 2, win 4105, length 0</span><br><span class="line"></span><br><span class="line"># 客户端确认</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [.], ack 2, win 503, length 0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.&lt;br&gt;半年后开始准备补上这四章&lt;/p&gt;
&lt;h1 id=&quot;第一章-TCP-IP协议族&quot;&gt;&lt;a href=&quot;#第一章-TCP-IP协议族&quot; class=&quot;headerlink&quot; title=&quot;第一章 TC
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>分支管理和实际应用</title>
    <link href="http://blog.lsmg.xyz/2020/03/Git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/Git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</id>
    <published>2020-03-06T11:34:25.000Z</published>
    <updated>2020-03-12T07:48:44.746Z</updated>
    
    <content type="html"><![CDATA[<p>2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄… 来更新下</p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p><code>git checkout -b dev</code>相当于一下两条命令<br><code>git branch dev</code> 分支创建<br><code>git checkout dev</code> 分支切换</p><p><code>git branch -d dev</code> 分支删除</p><p><code>git branch</code> 查看当前所有分支</p><p><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p><p><strong>冲突解决</strong><br><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 111111111111111</span><br><span class="line">2 222222222222222</span><br><span class="line">3 333333333333333</span><br><span class="line">4 444444444444444</span><br><span class="line">5 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  # 我在master分支下添加了6666666 并提交</span><br><span class="line">6 6666666</span><br><span class="line">7 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">8 7777777</span><br><span class="line">9 &gt;&gt;&gt;&gt;&gt;&gt;&gt; deb # 我在deb分支下添加了7777777 并提交</span><br></pre></td></tr></table></figure><p>最后需要我手动修改这个文件为自己需要的内容 然后提交即可</p><p><strong>分支管理</strong><br>通常Git会使用<code>Fast forward</code>模式 这样删除分支后会丢失分支的信息<br>可以再merge的时候加入<code>--no-ff</code>这样就能解决问题<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>由于禁用<code>Fast forward</code>后<br>会生成新的commit所以需要加入<code>-m &quot;merge with no-ff&quot;</code></p><p>git stash 可以储存当前的工作区 继续其他的工作<br>git stash list 查看储存的工作区列表<br>git stash apply stash@{0} 恢复指定的储存<br>git stash pop 恢复并drop最近的存储 慎用这个 建议使用上边的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt # stash前</span><br><span class="line">111111</span><br><span class="line">$ vim test.txt </span><br><span class="line">$ cat test.txt # 进行了修改</span><br><span class="line">111111</span><br><span class="line">222222</span><br><span class="line">333333</span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">修改：     test.txt</span><br><span class="line">$ git stash # stash</span><br><span class="line">保存工作目录和索引状态 WIP on master: 854b710 1</span><br><span class="line">$ cat test.txt </span><br><span class="line">111111</span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br><span class="line">$ git stash pop</span><br><span class="line">位于分支 master</span><br><span class="line">修改：     test.txt</span><br><span class="line">$ cat test.txt </span><br><span class="line">111111</span><br><span class="line">222222</span><br><span class="line">333333</span><br></pre></td></tr></table></figure><h1 id="实际工作中分支的应用"><a href="#实际工作中分支的应用" class="headerlink" title="实际工作中分支的应用"></a>实际工作中分支的应用</h1><p><a href="https://zhuanlan.zhihu.com/p/38772378" target="_blank" rel="noopener">主要参考</a><br><strong>主分支</strong></p><ul><li><strong>master</strong>: 这个分支最稳定, 相当于放的可发布版本</li><li><strong>develop</strong>: 开发分支, 平行于master分支, 负责合并各种<code>用于开发子功能</code>的分支</li></ul><p><strong>支持分支</strong>:解决某个问题, 结束后合并回<code>master</code>或<code>develop</code>分支</p><ul><li><strong>feature</strong>功能分支, 用于开发一个个子功能, 来自<code>develop</code>合并到<code>develop</code>去</li><li><strong>release</strong>:发布分支, 用于修改版本号等小修改, 来自<code>develop</code>分支合并到<code>master</code>分支</li><li><strong>hotfixes</strong>:紧急修复bug分支, 从<code>master</code>创建, 合并回<code>develop</code>分支和<code>master</code>分支<br><img src="https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg" alt=""></li></ul><p><a href="https://juejin.im/post/5d82e1f3e51d4561d044cd88#heading-14" target="_blank" rel="noopener">Git 分支管理规范</a></p><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">Git 基础 - 打标签</a></p><p><strong>develop分支完成了操作, 准备发布新的版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从 develop 分支上创建 release 分支:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命名规则如下 release-事件-版本</span></span><br><span class="line">git checkout –b release-20190919-v1.0.0 develop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修复完release的bug后再次提交修改:</span></span><br><span class="line">git checkout release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交本地修改, 如果没有修改bug 可以跳过</span></span><br><span class="line">git add .</span><br><span class="line">git commit –m “提交日志”</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送 release 分支</span></span><br><span class="line">git push origin release-20190919-v1.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发布新版本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并 release 分支到 master 分支:</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并 release 分支到 develop 分支:</span></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 master 分支上创建标签:</span></span><br><span class="line">git tag tag-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地 release 分支:</span></span><br><span class="line">git branch –d release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程 release 分支:</span></span><br><span class="line">git push origin :release-20190919-v1.0.0</span><br></pre></td></tr></table></figure><p>新版本完成之后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推送master分支</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意上边打的tag需要手动提交 默认push不会提交tag</span></span><br><span class="line">git push origin [tag name]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以给push增加参数</span></span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h1 id="本地和远程分支和tag的删除"><a href="#本地和远程分支和tag的删除" class="headerlink" title="本地和远程分支和tag的删除"></a>本地和远程分支和tag的删除</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 本地</span></span><br><span class="line">git tag -d xxx</span><br><span class="line">git branch -d xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 远程</span></span><br><span class="line">git push origin :refs/tags/xxx</span><br><span class="line">git push origin :xxx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄… 来更新下&lt;/p&gt;
&lt;h1 id=&quot;分支管理&quot;&gt;&lt;a href=&quot;#分支管理&quot; class=&quot;headerlink&quot; title=&quot;分支管理&quot;&gt;&lt;/a&gt;分支管理&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git 
      
    
    </summary>
    
    
      <category term="必备技能" scheme="http://blog.lsmg.xyz/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
      <category term="Git操作" scheme="http://blog.lsmg.xyz/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/Git%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="Git操作" scheme="http://blog.lsmg.xyz/tags/Git%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>循环判断中使用无符号类型</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-CPP%E9%87%87%E5%9D%91-%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%AD%E4%B9%8B%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-CPP%E9%87%87%E5%9D%91-%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%AD%E4%B9%8B%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-03-06T09:37:08.000Z</published>
    <updated>2020-03-06T12:18:05.173Z</updated>
    
    <content type="html"><![CDATA[<p>下面的代码 会产生错误.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无符号类型的数值和有符号类型的数值进行运算(包括算数逻辑运算等)会将有符号类型的数值转换成无符号类型的数值.</p><p>但是对于char short等小于int的数值运算的时候 会转换成int 纯正的int<br>对于unsigned char在转换成int时，无论最高位是0还是1，都补0<br>signed char的则高位时1补1 0补0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0*23 1</span></span><br><span class="line"><span class="comment">// 1*23 0</span></span><br><span class="line"><span class="comment">// 1*24 本来是int 但被当作了 无符号int 所以输出</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) <span class="comment">// 逻辑运算也转换了</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a &lt; b"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4294967295</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//   11111111 11111111 11111111 11111111</span></span><br><span class="line"><span class="comment">//   00000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">// 1 00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> c = <span class="number">2</span>; <span class="comment">// 0*22 1 0</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">-1</span>; <span class="comment">// 1*24</span></span><br><span class="line"><span class="keyword">if</span> (c &lt; d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c &lt; d"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c + d &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1   直接把高位的1溢出了 留下了0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2*23 1</span></span><br><span class="line"><span class="comment">// 1*23 0</span></span><br><span class="line"><span class="comment">// 1*24 被转换成了int 所以输出-1</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> e = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> f = <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">if</span> (e &lt; f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"e &lt; f"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 没有输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e + f &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> g = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> h = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (g &lt; h)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"g &lt; h"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 未输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g + h &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面的代码 会产生错误.&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP踩坑" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E8%B8%A9%E5%9D%91/"/>
    
    
      <category term="CPP踩坑记" scheme="http://blog.lsmg.xyz/tags/CPP%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Mysql基本使用</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql-Mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql-Mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-06T07:25:28.000Z</published>
    <updated>2020-03-06T07:59:36.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>Ubuntu18.04 安装 mysql5.7</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><p>安装完毕后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开shell管理程序</span></span><br><span class="line">sudo mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 123456 换成你自己的密码</span></span><br><span class="line">ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 刷新一下</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出</span></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录测试</span></span><br><span class="line">mysql -uroot -p # 回车 后输入自己的密码再次回车</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装和配置&quot;&gt;&lt;a href=&quot;#安装和配置&quot; class=&quot;headerlink&quot; title=&quot;安装和配置&quot;&gt;&lt;/a&gt;安装和配置&lt;/h1&gt;&lt;p&gt;Ubuntu18.04 安装 mysql5.7&lt;/p&gt;
&lt;figure class=&quot;highlight shell
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://blog.lsmg.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://blog.lsmg.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://blog.lsmg.xyz/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>球球</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AD%A6%E9%99%A2-%E7%90%83%E7%90%83/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AD%A6%E9%99%A2-%E7%90%83%E7%90%83/</id>
    <published>2020-03-05T13:50:02.000Z</published>
    <updated>2020-03-05T14:42:14.972Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://gameinstitute.qq.com/course/detail/10110" target="_blank" rel="noopener">休闲: 球球</a></p><p>P2P 模式…….. 好吧没有采用基本模式<br>采用了变种, 从客户端中选取主客户端 局域网游戏会采用</p><p><strong>状态同步</strong><br>MMO用的多, 断线重连简单 直接返回状态</p><p>收到命令集 计算后 返回结果 防作弊 服务器压力大 包量大</p><p>预表现emm</p><p><strong>帧同步</strong><br>服务器广播客户端发送的指令集, 断线重连需要补上丢失的帧</p><p>预表现emm</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E8%AF%BE%E5%A0%82/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AF%B9%E6%AF%94.png" alt=""></p><p>航标<br>终于知道游戏瞬移是怎么回事了</p><p>影子追随</p><p>心跳包矫正时间 获取延迟等等</p><p>王者 帧同步.</p><p>守望先锋 16ms一个包</p><p>RTT网络延迟</p><p>预表现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://gameinstitute.qq.com/course/detail/10110&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;休闲: 球球&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P2P 模式…….. 好吧没有采用基本模式&lt;br&gt;采用了变
      
    
    </summary>
    
    
      <category term="游戏知识" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="服务器" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="腾讯游戏学院" scheme="http://blog.lsmg.xyz/tags/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AD%A6%E9%99%A2/"/>
    
  </entry>
  
  <entry>
    <title>操作系统点带面</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%82%B9%E5%B8%A6%E9%9D%A2/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%82%B9%E5%B8%A6%E9%9D%A2/</id>
    <published>2020-03-03T10:41:28.000Z</published>
    <updated>2020-03-14T10:41:26.689Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构指针简答应用</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9590-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9590-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</id>
    <published>2020-03-03T02:38:28.000Z</published>
    <updated>2020-03-19T09:01:15.798Z</updated>
    
    <content type="html"><![CDATA[<p>为了压缩长度. 所有空行都删掉了</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="哈希表建立快速索引-一遍和两遍哈希的使用"><a href="#哈希表建立快速索引-一遍和两遍哈希的使用" class="headerlink" title="哈希表建立快速索引, 一遍和两遍哈希的使用"></a>哈希表建立快速索引, 一遍和两遍哈希的使用</h2><p><a href="https://leetcode.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum</a><br>题目很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><p>不是最差… 也差不多了 最简单粗暴的形式 O(n2) O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 答案肯定是一个小数和一个大数 相加, 直接往后找 测试用例应该是排好序的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, j&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两遍哈希 由于需要更快的找到 vector中某个元素的下标, 非常适合哈希表来做<br>先放入哈希表中, 再寻找自己所需要的值是否存在以及下标 O(n) O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; the_map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">the_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> search = the_map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line"><span class="comment">// unordered_map&lt;int, int&gt;::iterator search = the_map.find(target - nums[i]);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (search != the_map.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (search-&gt;second == i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, search-&gt;second&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一遍哈希, 既然是要在表中查找到需要数 还需要判断是否同一个数<br>干脆直接在插入前就进行查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; the_map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> search = the_map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line"><span class="keyword">if</span> (search != the_map.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, search-&gt;second&#125;;</span><br><span class="line">&#125;</span><br><span class="line">the_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flag的使用"><a href="#flag的使用" class="headerlink" title="flag的使用"></a>flag的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</span><br><span class="line"></span><br><span class="line">在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">假设字符串的长度不会超过 1010。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure><p>这个开始我这样写的, 因为需要<br>在有奇数字母个数的时候 需要额外 结果+1<br>没有奇数字母个数 结果不需要额外 +1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> letter[<span class="number">68</span>]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">letter[s[i] - <span class="number">65</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> oddnum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">68</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> num = letter[i];</span><br><span class="line">sum += num;</span><br><span class="line"><span class="keyword">if</span> (num %<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">oddnum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum -= oddnum;</span><br><span class="line"><span class="comment">// 通过额外的一个if判断 是否存在奇数</span></span><br><span class="line"><span class="keyword">if</span> (oddnum &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> oddnum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 设置这个flag 代码少了一个if 实际用途有没有.... 感觉这个思想是可以的</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">68</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> num = letter[i];</span><br><span class="line">sum += num;</span><br><span class="line"><span class="keyword">if</span> (num %<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">oddnum++;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum -= oddnum;</span><br><span class="line"><span class="keyword">return</span> sum + flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针操作"><a href="#双指针操作" class="headerlink" title="双指针操作"></a>双指针操作</h1><h2 id="双指针左右逼近-数学问题"><a href="#双指针左右逼近-数学问题" class="headerlink" title="双指针左右逼近-数学问题"></a>双指针左右逼近-数学问题</h2><p><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode.com/problems/container-with-most-water/</a></p><p>存水量 = a(宽) * b(长);</p><p>从a最大的时候开始, 如果想要获得更大的存水量, 只能减少a, 增加b</p><p>使用两个指针 一个指向最左边 一个指向最右边</p><p>这就有了移动哪个指针的问题, 为了得到更长的b 只能移动指向较短b的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;   </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator left = <span class="built_in">height</span>.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator right = <span class="built_in">height</span>.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">min</span>(*left, *right) * (right - left);</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; <span class="built_in">max</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">max</span> = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移动较短边</span></span><br><span class="line">        <span class="keyword">if</span> (*left &lt;= *right)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并排序数组-双指针操作-拷贝到临时数组和直接写到原数组"><a href="#合并排序数组-双指针操作-拷贝到临时数组和直接写到原数组" class="headerlink" title="合并排序数组-双指针操作 拷贝到临时数组和直接写到原数组"></a>合并排序数组-双指针操作 拷贝到临时数组和直接写到原数组</h2><p><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sorted-merge-lcci/</a><br>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。<br>初始化 A 和 B 的元素数量分别为 m 和 n。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">B = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>第一次太惨了, 看来我算法需要加倍的联系啊. 先不说考虑很久</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 这里的 m + n就有点问题, 后面会空转 改为m + temp合适</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (A.at(i) &lt; B.at(temp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">A.insert(A.<span class="built_in">begin</span>() + i, B.at(temp++));</span><br><span class="line"><span class="keyword">if</span> (temp == n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">A.insert(A.<span class="built_in">begin</span>() + m + temp, B.<span class="built_in">begin</span>() + temp, B.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line">A.erase(A.<span class="built_in">begin</span>() + n + m, A.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用插入再删除, 本身这个方法就不是很好. 后来看题解有双指针, 就去试了下. 这样需要额外的空间<br>如果直接正序的修改A的值, 可能会导致A的值被覆盖掉.<br>那么倒序呢? 倒序放上最大的值 就不会覆盖掉A中未读取的值了 继续修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sorted[m + n];</span><br><span class="line"><span class="keyword">auto</span> a = A.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> b = B.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index != m + n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a - A.<span class="built_in">begin</span>() == m)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b - B.<span class="built_in">begin</span>() == n)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*a &lt; *b)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*a == *b)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *a++;</span><br><span class="line">sorted[index++] = *b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *b++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">A[i] = sorted[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改正后的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = m + n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a = m - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (index &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = B[b--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = A[a--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A[a] &gt; B[b])</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = A[a--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A[a] == B[b])</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = A[a--];</span><br><span class="line">A[index--] = B[b--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">A[index--] = B[b--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Plus-One-临时插入-如果无效则删除"><a href="#Plus-One-临时插入-如果无效则删除" class="headerlink" title="Plus One-临时插入 如果无效则删除"></a>Plus One-临时插入 如果无效则删除</h2><p><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">https://leetcode.com/problems/plus-one/</a><br>给定一个数组, [1, 2, 3]代表123 给这个数字+1 返回数组形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">Explanation: The <span class="built_in">array</span> represents the integer <span class="number">123.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// insert zero in case of like this [9]</span></span><br><span class="line">digits.insert(digits.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">end</span> = digits.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">*<span class="built_in">end</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(*<span class="built_in">end</span> == <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">*<span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">*(--<span class="built_in">end</span>) += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if the zero is useless delete it</span></span><br><span class="line"><span class="keyword">if</span> (digits[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">digits.erase(digits.<span class="built_in">begin</span>(), digits.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谨记无符号踩坑"><a href="#谨记无符号踩坑" class="headerlink" title="谨记无符号踩坑"></a>谨记无符号踩坑</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p><p>这个的代码就不贴出来了, 我也没有偷懒 没有!!!</p><p>这个主要是记录下 无符号值的使用</p><p>充实了我的CPP踩坑记的文章</p><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h2><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘,<br>return the length of last word (last word means the last appearing word if we loop from left to right) in the string.<br>If the last word does not exist, return 0.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"Hello World"</span></span><br><span class="line">Output: <span class="number">5</span></span><br></pre></td></tr></table></figure><p>…出了问题 这个题目刚才写的解析全没了…… 只能保存下改正完的答案了<br>赶紧下载了一个vscode来用用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sub = s.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((sub &gt;= <span class="number">0</span>) &amp;&amp; (s[sub] == <span class="string">' '</span>))</span><br><span class="line">&#123;</span><br><span class="line">sub--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (sub &gt;= <span class="number">0</span> &amp;&amp; (s[sub] != <span class="string">' '</span>))</span><br><span class="line">&#123;</span><br><span class="line">sub--;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> it = s.rbegin(), piv = s.rbegin();</span><br><span class="line"><span class="keyword">for</span>(;it != s.rend() &amp;&amp; *it == <span class="string">' '</span>; it++, piv = it);</span><br><span class="line"><span class="keyword">for</span>(;it != s.rend() &amp;&amp; *it != <span class="string">' '</span>; it++);</span><br><span class="line"><span class="keyword">return</span> it - piv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="a-a-b-b"><a href="#a-a-b-b" class="headerlink" title="a^a^b = b"></a>a^a^b = b</h2><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>这个题目上来寻找单独的数字, 我直接就sort然后遍历一次, 找到单个的数字.<br>我以为这样就很快了, 结果看了下排名. 啪啪啪的打脸</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; i = i + <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] != nums[i + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然打败了40%的人, 就去看看更快的解法把. 首先我看到了就是这个<br>我只想说…. 位运算6666, 没想到异或可以这样用<br><code>a^0 = a</code>  <code>a^a = 0</code> <code>a^a^b = b</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">&#123;</span><br><span class="line">ret ^= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有哈希表做法, 应该是利用的哈希表快速索引, 我也是才知道map范围for循环是pair不是iter auto不能用太多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[n]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; n : <span class="built_in">map</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n.second == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> n.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="链表环判断双指针赛跑-单一体现key-set"><a href="#链表环判断双指针赛跑-单一体现key-set" class="headerlink" title="链表环判断双指针赛跑 单一体现key-set"></a>链表环判断双指针赛跑 单一体现key-set</h2><p><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle/</a><br><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/</a></p><p>大意就是判断一个链表是否有环, 因为之前在那本小灰上看到过. 脑子中首先想的两个指针赛跑.</p><p>快的指针一次走两步, 慢的一次走一步. 快的终将会追上慢的, 如果碰到了nullptr就返回false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode *walk = head;</span><br><span class="line">        ListNode *<span class="built_in">run</span> = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">run</span>-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            walk = walk-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">run</span>-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">run</span> = <span class="built_in">run</span>-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (walk == <span class="built_in">run</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改了一下, 感觉下面的代码要好一些?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="keyword">if</span> ((head == <span class="literal">nullptr</span>) || (head-&gt;next == <span class="literal">nullptr</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *walk = head;</span><br><span class="line">ListNode *<span class="built_in">run</span> = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (walk != <span class="built_in">run</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">run</span> == <span class="literal">nullptr</span>) || (<span class="built_in">run</span>-&gt;next == <span class="literal">nullptr</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">walk = walk-&gt;next;</span><br><span class="line"><span class="built_in">run</span> = <span class="built_in">run</span>-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是要保证访问过的单一, 就是用set了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">set</span>&lt;ListNode*&gt; hashset&#123;&#125;;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hashset.count(head) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">hashset.insert(head);</span><br><span class="line"></span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了压缩长度. 所有空行都删掉了&lt;/p&gt;
&lt;h1 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h1&gt;&lt;h2 id=&quot;哈希表建立快速索引-一遍和两遍哈希的使用&quot;&gt;&lt;a href=&quot;#哈希表建立
      
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题记录" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9591-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9591-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-03T02:38:28.000Z</published>
    <updated>2020-03-19T08:44:16.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="贪心-动态规划"><a href="#贪心-动态规划" class="headerlink" title="贪心 动态规划"></a>贪心 动态规划</h2><p><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game/</a></p><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.<br>Each element in the array represents your maximum jump length at that position.<br>Determine if you are able to reach the last index.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">1</span>:</span><br><span class="line">Input: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: Jump <span class="number">1</span> <span class="built_in">step</span> from index <span class="number">0</span> to <span class="number">1</span>, then <span class="number">3</span> steps to the last index.</span><br><span class="line"></span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="literal">false</span></span><br><span class="line">Explanation: You will always arrive at index <span class="number">3</span> no matter what. Its maximum</span><br><span class="line">             jump length is <span class="number">0</span>, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure><p>这是我LeetCode第一道中等难度算法, 刚上来不知道怎么做. 然后瞟了一眼题解说是动态规划问题.我就去查了下动态规划的问题解法</p><p><a href="https://www.zhihu.com/question/23995189/answer/613096905" target="_blank" rel="noopener">什么是动态规划（Dynamic Programming）？动态规划的意义是什么？ - 阮行止的回答 - 知乎</a></p><p><strong>贪心</strong><br>这样算是有了个初步了解, 不过我上来先用了贪心… 因为简单一些, 动态规划暂时没有想到怎么解.<br>结果运行时间超过 11%的人好吧 最坏的时间复杂度应该是O(n!)… 最优O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum_step = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> now_sub = sum_step - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> min_sub = now_sub;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> jumpout = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = now_sub - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= (now_sub - i))</span><br><span class="line">            &#123;</span><br><span class="line">                min_sub = i;</span><br><span class="line">                jumpout = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        now_sub = min_sub;</span><br><span class="line">        <span class="keyword">if</span> (jumpout)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> now_sub == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        jumpout = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我看了下题解的贪婪算法… 我的应该也是贪婪的一种. 不过题解的贪婪更加快.<br>我的想法是从顶开始 每次遍历找到<code>最低的能跳过来的一层</code> 然后再从<code>最低的能跳过来的一层</code>遍历.直到到不能再跳就返回当前是不是底层</p><p>题解的解法粗略看就是差在了第一个if的判断条件, 我判断的当前的层, 题解判断的<code>最低的能跳过来的一层</code>题解的解法是<code>能跳则跳</code> 我的解法是<code>跳最少的次数</code> 实际上针对此题<code>能跳则跳</code>就好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now_sub = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> min_sub = now_sub;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = now_sub - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + i &gt;= min_sub)</span><br><span class="line">        &#123;</span><br><span class="line">            min_sub = i;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> min_sub == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我猜测绝对有一道题输出最少的跳跃次数, 没想到真有. 结果试了下时间超限…..<br>理论上我第一种解法能够完成emmm, 不过先不管那道题目了.</p><p><strong>递归回溯</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJumpFromPosition</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">position</span> == nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_position = <span class="built_in">min</span>(<span class="built_in">position</span> + nums[<span class="built_in">position</span>], (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// for (int i = max_position; i &gt; position; --i)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">position</span> + <span class="number">1</span>; i &lt;= max_position; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (canJumpFromPosition(i, nums))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canJumpFromPosition(<span class="number">0</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方法思考起来简单些, 你只要知道递归的条件是什么</p><p>递归到什么时候返回值来回溯</p><p>这个题目, 你只要在当前位置不断跳到所有能去的位置, 然后递归下去. 直到你的位置到了尾部就返回true, 或者你不能再跳返回false. 自然时间超限了</p><p>上面的解法, 还有优化的空间. 因为这个是从左到右依次进行, 然而实际上从越远的地方进行更容易到达尾部. 所以可以修改for的判断条件在图中注释部分</p><p><strong>动态规划 自上而下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Index &#123;UNKNOW, GOOD, BAD&#125;;</span><br><span class="line">Index *memo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJumpFromPosition</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memo[<span class="built_in">position</span>] != UNKNOW)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[<span class="built_in">position</span>] == GOOD;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_position = <span class="built_in">min</span>(<span class="built_in">position</span> + nums[<span class="built_in">position</span>], (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = max_position; i &gt; <span class="built_in">position</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (canJumpFromPosition(i, nums))</span><br><span class="line">        &#123;</span><br><span class="line">            memo[<span class="built_in">position</span>] = GOOD;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    memo[<span class="built_in">position</span>] = BAD;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    memo = <span class="keyword">new</span> Index[nums.<span class="built_in">size</span>()]&#123;&#125;;</span><br><span class="line">    memo[nums.<span class="built_in">size</span>() - <span class="number">1</span>] = GOOD;</span><br><span class="line">    <span class="keyword">return</span> canJumpFromPosition(<span class="number">0</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前的方法中, 仔细想想就会发现 会有很多的下标被多次调用, 尽管那个下标是无法到达结尾的. 怎么解决呢? 当然是保存状态了, 每次递归结束后就标记当前的下标能不能到达. 之后遇到被标记的下标就能直接返回</p><p>然而现在的时间复杂度依然高达 O(n^2)</p><p><strong>自下而上的动态规划</strong></p><p>通过消除递归的方式, 消除递归的一个好方法就是颠倒顺序. 上面那是从左到右向右跳, 这次我们从右向左向右跳, 就能更容易的知道知道某个下标是<code>GOOD</code>还是<code>BAD</code>了, 因为离最右端更近了.</p><p>时间复杂度依然是O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Index &#123;UNKNOW, GOOD, BAD&#125;;</span><br><span class="line">Index *memo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    memo = <span class="keyword">new</span> Index[nums.<span class="built_in">size</span>()]&#123;&#125;;</span><br><span class="line">    memo[nums.<span class="built_in">size</span>() - <span class="number">1</span>] = GOOD;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> furthest_jump = <span class="built_in">min</span>(nums[i] + i, (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= furthest_jump; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (memo[j] == GOOD)</span><br><span class="line">            &#123;</span><br><span class="line">                memo[i] = GOOD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[<span class="number">0</span>] == GOOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h2 id=&quot;贪心-动态规划&quot;&gt;&lt;a href=&quot;#贪心-动态规划&quot; class=&quot;headerlink&quot; title=&quot;贪心 
      
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题记录" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法分类学习</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9592-%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA-%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9592-%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA-%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-03-03T02:38:28.000Z</published>
    <updated>2020-03-17T03:56:20.086Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法理论" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>STL与实现记录</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-CPP%E9%87%8D%E7%82%B9-STL%E8%AE%B0%E5%BD%95/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-CPP%E9%87%8D%E7%82%B9-STL%E8%AE%B0%E5%BD%95/</id>
    <published>2020-03-01T02:26:55.000Z</published>
    <updated>2020-03-10T07:08:24.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容器库"><a href="#容器库" class="headerlink" title="容器库"></a>容器库</h1><table><thead><tr><th>顺序容器</th><th>按序访问</th></tr></thead><tbody><tr><td>array</td><td>静态的连续数组</td></tr><tr><td>vector</td><td>动态的连续数组</td></tr><tr><td>deque</td><td>双端队列</td></tr><tr><td>forward_list</td><td>单链表</td></tr><tr><td>list</td><td>双链表</td></tr></tbody></table><table><thead><tr><th>关联容器</th><th>能实现快速查找O(logn)</th></tr></thead><tbody><tr><td>set</td><td>唯一key的集合, 按照key排序</td></tr><tr><td>map</td><td>k v集合, 按照k排序, k是唯一的</td></tr><tr><td>multiset</td><td>key的集合 按照key排序</td></tr><tr><td>multimap</td><td>k v的集合, 按照key排序</td></tr></tbody></table><table><thead><tr><th>无序关联容器</th><th>快速查找均摊O(1)最坏O(n)的无序(哈希)数据结构</th></tr></thead><tbody><tr><td>unordered_set</td><td>唯一key的集合, 按照key生成散列</td></tr><tr><td>unordered_map</td><td>唯一key, k v的集合, 按照key生成散列</td></tr><tr><td>unordered_multiset</td><td>key的集合, 按照key生成散列</td></tr><tr><td>unordered_multimap</td><td>k v的集合, 按照key生成散列</td></tr></tbody></table><table><thead><tr><th>容器适配器</th><th>提供顺序容器的不同接口</th></tr></thead><tbody><tr><td>stack</td><td>适配一个容器提供栈</td></tr><tr><td>queue</td><td>适配一个容器提供队列</td></tr><tr><td>priority_queue</td><td>适配一个容器提供优先级队列</td></tr></tbody></table><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h2 id="lower-bound-和-upper-bound"><a href="#lower-bound-和-upper-bound" class="headerlink" title="lower_bound()和 upper_bound()"></a>lower_bound()和 upper_bound()</h2><p><strong>lower_bound(const Key&amp; key)</strong><br><a href="https://zh.cppreference.com/w/cpp/container/map/lower_bound" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/container/map/lower_bound</a><br>返回指向首个不小于 key 的元素的迭代器。若找不到这种元素，则返回尾后迭代器</p><p><strong>upper_bound()</strong><br>返回指向首个大于 key 的元素的迭代器。</p><h1 id="vertor"><a href="#vertor" class="headerlink" title="vertor"></a>vertor</h1><table><thead><tr><th>函数名称</th><th>使用详解</th></tr></thead><tbody><tr><td>at []</td><td>获取指定位置的元素 有边界检查</td></tr><tr><td>insert</td><td>在指定位置的前面插入, 可以插入单项, vector和数组</td></tr><tr><td>max_size</td><td>理论最大容量</td></tr><tr><td>capacity</td><td>实际最大容量</td></tr></tbody></table><h1 id="图片Warn"><a href="#图片Warn" class="headerlink" title="图片Warn"></a>图片Warn</h1><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8.png" alt=""></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8.png" alt=""></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8.png" alt=""></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;容器库&quot;&gt;&lt;a href=&quot;#容器库&quot; class=&quot;headerlink&quot; title=&quot;容器库&quot;&gt;&lt;/a&gt;容器库&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;顺序容器&lt;/th&gt;
&lt;th&gt;按序访问&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbod
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>Jsoncpp代码阅读</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Jsoncpp%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Jsoncpp%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2020-03-01T02:26:55.000Z</published>
    <updated>2020-03-04T07:52:44.944Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Json::Value root;</span><br><span class="line">root[<span class="string">"action"</span>] = <span class="string">"run"</span>;</span><br></pre></td></tr></table></figure><p>首先是 <code>[]运算符重载</code> , 统一不同的重载类型<br>调用<code>resolveReference()</code>进行统一的添加<code>k</code>操作</p><p>首先会进行 校验参数, 然后将key封装成一个对象CZString (封装过程为将传入指针保存到 CZString对象中的cstr_)<br>封装完成后再保存<code>k v</code>的<code>map&lt;CZString, Value&gt;</code>中查找有无相同的CZString(key)有的话返回Value引用,<br>没有则创建新的&lt;CZStrng, 空Value&gt;存入map并返回Value的引用</p><p>然后是<code>=运算符重载</code>, “run”自动转换成Value对象<br>转换过程中, 通过<code>duplicateAndPrefixStringValue()</code>将”run”进行了封装<br><code>char* string_; // if allocated_, ptr to { unsigned, char[] }.</code><br>将长度封装到了一个char指针中, 有点类似自己设计tcp协议…</p><p><code>=运算符重载</code>函数将<code>[]运算符重载</code>返回的对象引用 中的相关值<code>swap()</code>成新的Value对象中的相关值</p><p>到这里理解了在Jsoncpp中 一切都是Value 包括&lt;K, V&gt;键值对也是在Value对象中存储<br>每一个&lt;k, v&gt;都可以作为一个Value对象, 这样既实现了复杂嵌套Json中 v为对象的情况 妙啊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个Value对象中都维护一个union</span></span><br><span class="line"><span class="keyword">union</span> ValueHolder &#123;</span><br><span class="line">    LargestInt int_;</span><br><span class="line">    LargestUInt uint_;</span><br><span class="line">    <span class="keyword">double</span> real_;</span><br><span class="line">    <span class="keyword">bool</span> bool_;</span><br><span class="line">    <span class="keyword">char</span>* string_; <span class="comment">// if allocated_, ptr to &#123; unsigned, char[] &#125;.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有的存贮着key的CZString保存起来</span></span><br><span class="line"><span class="comment">//  typedef std::map&lt;CZString, Value&gt; ObjectValues; // std::map&lt;CZString, Value&gt; 键值对</span></span><br><span class="line">    ObjectValues* map_;</span><br><span class="line">  &#125; value_;</span><br></pre></td></tr></table></figure><p>下面的switch的这个type 会在很多地方被修改掉.<br>起初 使用默认构造函数的value type是nullxxx<br>然后调用<code>[]运算符重载</code>的时候会修改掉 type 为 objectValue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归调用 进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuiltStyledStreamWriter::writeValue</span><span class="params">(Value <span class="keyword">const</span>&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (value.type()) &#123;</span><br><span class="line">  <span class="keyword">case</span> nullValue:</span><br><span class="line">    pushValue(nullSymbol_);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> intValue:</span><br><span class="line">    pushValue(valueToString(value.asLargestInt()));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> uintValue:</span><br><span class="line">    pushValue(valueToString(value.asLargestUInt()));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> realValue:</span><br><span class="line">    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,</span><br><span class="line">                            precisionType_));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> stringValue: &#123;</span><br><span class="line">    <span class="comment">// Is NULL is possible for value.string_? No.</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* str;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">bool</span> ok = value.getString(&amp;str, &amp;<span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">if</span> (ok)</span><br><span class="line">      pushValue(valueToQuotedStringN(str, <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(<span class="built_in">end</span> - str),</span><br><span class="line">                                     emitUTF8_));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      pushValue(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> booleanValue:</span><br><span class="line">    pushValue(valueToString(value.asBool()));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> arrayValue:</span><br><span class="line">    writeArrayValue(value);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> objectValue: &#123;</span><br><span class="line">    <span class="function">Value::Members <span class="title">members</span><span class="params">(value.getMemberNames())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (members.empty())</span><br><span class="line">      pushValue(<span class="string">"&#123;&#125;"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      writeWithIndent(<span class="string">"&#123;"</span>);</span><br><span class="line">      indent();</span><br><span class="line">      <span class="keyword">auto</span> it = members.<span class="built_in">begin</span>();</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">String</span> <span class="keyword">const</span>&amp; name = *it;</span><br><span class="line">        Value <span class="keyword">const</span>&amp; childValue = value[name];</span><br><span class="line">        writeCommentBeforeValue(childValue);</span><br><span class="line">        writeWithIndent(valueToQuotedStringN(</span><br><span class="line">            name.data(), <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(name.length()), emitUTF8_));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// :</span></span><br><span class="line">        *sout_ &lt;&lt; colonSymbol_;</span><br><span class="line">        writeValue(childValue);</span><br><span class="line">        <span class="keyword">if</span> (++it == members.<span class="built_in">end</span>()) &#123;</span><br><span class="line">          writeCommentAfterValueOnSameLine(childValue);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *sout_ &lt;&lt; <span class="string">","</span>;</span><br><span class="line">        writeCommentAfterValueOnSameLine(childValue);</span><br><span class="line">      &#125;</span><br><span class="line">      unindent();</span><br><span class="line">      writeWithIndent(<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次是根据下面的例子分析的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Json::Value root;</span><br><span class="line">  Json::Value data;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">bool</span> shouldUseOldWay = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 左侧返回Value的引用</span></span><br><span class="line">  root[<span class="string">"action"</span>] = <span class="string">"run"</span>;</span><br><span class="line">  data[<span class="string">"number"</span>] = <span class="number">1</span>;</span><br><span class="line">  root[<span class="string">"data"</span>] = data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldUseOldWay) &#123;</span><br><span class="line">    Json::FastWriter writer;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> json_file = writer.<span class="built_in">write</span>(root);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; json_file &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 配置文件也是Value对象, 我用我自己.jpg</span></span><br><span class="line">    Json::StreamWriterBuilder builder;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> json_file = Json::writeString(builder, root);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; json_file &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算是了解到了这个库的大概工作流程了. 能学到的部分 吃完午饭继续写.<br>吃完饭试了试家里的显示器, 家里的显示器还是太老了…… 八年的显示器了 看得我眼花<br>还是继续用笔记本吧</p><ol><li><p>首先我很喜欢这种运算符重载的使用形式, 用起来非常的舒服, 需要重载两个运算符 <code>[]</code>和<code>=</code> 而且<br><code>=运算符</code>重载使用的swap交换需要的属性, 感觉不错<br>(后来我看了EffectiveC++ 发现这是<code>=运算符处理自我赋值</code>太巧了)</p></li><li><p>针对需要加载配置文件的类 使用了工厂模式</p></li><li><p>writeValue使用了递归处理.</p></li><li><p>统一处理, k v都是Value对象</p></li><li><p>将用户的string 拷贝到新的<code>char*</code>中 同时在开头增加了长度, 尾部补了0, 没有使用额外的变量去存储<code>char*</code>的长度<br>不太清楚这样做有什么好处</p></li><li><p>常量全部用的 <code>static constexpr</code>修饰</p></li><li><p>恰当的对象嵌套</p></li></ol><hr><p>看完了从 Value到Json 接下来看看从Json到Value</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> rawJson = <span class="string">R"(&#123;"Age": 20, "Name": "colin"&#125;)"</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> rawJsonLength = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(rawJson.length());</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">bool</span> shouldUseOldWay = <span class="literal">false</span>;</span><br><span class="line">  JSONCPP_STRING err;</span><br><span class="line">  Json::Value root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldUseOldWay) &#123;</span><br><span class="line">    Json::Reader reader;</span><br><span class="line">    reader.parse(rawJson, root);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 默认构造函数 使用默认的配置</span></span><br><span class="line">    Json::CharReaderBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据builder的配置生成CharReader类</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Json::CharReader&gt; <span class="title">reader</span><span class="params">(builder.newCharReader())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!reader-&gt;parse(rawJson.c_str(), rawJson.c_str() + rawJsonLength, &amp;root,</span><br><span class="line">                       &amp;err)) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> name = root[<span class="string">"Name"</span>].asString();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> age = root[<span class="string">"Age"</span>].asInt();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析的关键在于<code>parse()</code>函数 传入字符串的首尾指针, 和一个Value引用<br>进入函数后将传入的变量保存到了自己的成员变量中.</p><p>慢慢发现 这个库将很多的默认类型 起了别名 可能是为了统一类型 类似UE4也是自己搞了一套</p><p>主要是<code>OurReader</code>这个负责解析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了大量的using</span></span><br><span class="line"><span class="keyword">using</span> Char = <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> Location = <span class="keyword">const</span> Char*;</span><br></pre></td></tr></table></figure><p>解析逻辑就是<code>parse()</code>调用<code>readValue()</code><br><code>readValue()</code>负责 获取下一次数据类型type_ -&gt;switch(type_) 根据分支决定是否递归再次调用<code>readValue</code><br>总算把逻辑看懂了, 代码依然认为很赞<br><code>readToken()</code>这个函数贯穿整个解析, 通过这个函数获取到下一次的数据是什么类型, 同时移动相关的状态指针<br><code>readToken()</code> 内部大量调用下面的函数 修改当前指针 同时返回字符, 然后switch这个字符判断下一次的数据类型<br>比如遇到<code>{</code>就是一个对象的开始设置好type并返回 遇到<code>}</code>就是对象的结束…..</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取current_指向的字符 并自增</span></span><br><span class="line"><span class="function">OurReader::Char <span class="title">OurReader::getNextChar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current_ == end_)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> *current_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般第一次调用type_会被设置为对象类型, 然后<code>readValue()</code>进入<code>case 对象分支</code><br><code>case对象分支中</code><br>先进行了一次<code>readToken()</code>获取到了k的类型, 然后根据k类型分支 将k的值转换成对应的value<br>之后又是一次<code>readToken()</code>判断是否存在<code>:</code>不存在就是错误<br>在之后使用这个方法, 保存<code>k</code>的vallue获取<code>v</code>的value再次调用<code>readValue()</code>填充值 返回后继续走</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里保存了name 这个k 将name的 v放入了顶层</span></span><br><span class="line">Value&amp; value = currentValue()[name];</span><br><span class="line">nodes_.push(&amp;value);</span><br><span class="line"><span class="keyword">bool</span> ok = readValue();</span><br></pre></td></tr></table></figure><p>读取完<code>v</code>的value之后必定是<code>,</code>或者<code>}</code>又是一次判断 成功判断后一个<code>k v</code>就获取完毕了</p><p><code>using Nodes = std::stack&lt;Value*&gt;</code><br>后面解析的代码更加的妙不可言, 使用<code>Nodes nodes_{}</code>存储当前的value 实现函数之间的操作</p><p>代码合理的组织<br>比如<code>case 对象分支</code>必定是一个<code>k</code>一个<code>:</code>一个<code>v</code> 然后一个分隔符<code>,</code>或<code>}</code> 这些放入了一个函数</p><p>然后获取到<code>k</code>之后使用<code>Value&amp; value = currentValue()[name]</code>获取<code>v</code></p><p>最后依然是递归的使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;t
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="源码学习" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>定义与声明详解</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-27T02:38:08.000Z</published>
    <updated>2020-02-27T03:26:16.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量声明和变量定义"><a href="#变量声明和变量定义" class="headerlink" title="变量声明和变量定义"></a>变量声明和变量定义</h1><p>变量声明: 用于向程序表明变量的类型和名字<br>变量定义: 用于为变量<em>分配存储空间</em>, 同时可为变量指定初始值</p><p>定义时会自动声明, 变量只能被定义一次, 却可以声明多次<br>extern声明不是定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// 声明i 但没有定义i</span></span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">// 定义且声明i</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">10</span>; <span class="comment">// 定义并声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果再函数体内部试图初始化一个由extern标记的变量,会引发错误</span></span><br></pre></td></tr></table></figure><h1 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h1><p>只有extern声明位于函数外部的时候,才能被初始化</p><p><strong>在C++中 可以用来声明全局变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="keyword">int</span> global_int = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> global_int;</span><br><span class="line"><span class="comment">// 后面可以直接使用 global_int, 因为他在其他地方定义了</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;变量声明和变量定义&quot;&gt;&lt;a href=&quot;#变量声明和变量定义&quot; class=&quot;headerlink&quot; title=&quot;变量声明和变量定义&quot;&gt;&lt;/a&gt;变量声明和变量定义&lt;/h1&gt;&lt;p&gt;变量声明: 用于向程序表明变量的类型和名字&lt;br&gt;变量定义: 用于为变量&lt;em&gt;分配
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective读书记录</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95110-Effective%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95110-Effective%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/</id>
    <published>2020-02-26T13:43:46.000Z</published>
    <updated>2020-03-06T14:15:24.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款02-尽量用const-enum-inline-替换-define"><a href="#条款02-尽量用const-enum-inline-替换-define" class="headerlink" title="条款02 尽量用const, enum, inline 替换#define"></a>条款02 尽量用const, enum, inline 替换#define</h2><p>前言 我目前自己做的框架中大量用了#define…. 因为用enum涉及到转换才能到int. 来学习下这条</p><p><strong>使用 const 常量来替换 #define</strong><br>谨防机号表出错, 特殊情况下 还能减少字量</p><p>#define无法限定作用域, 这点我已经感受到了</p><p>定义C风格常量字符串<br>const char* const NAME = “lsmg”; 防止指向和指向内容改变<br>定义C++风格常量字符串<br>const std::string NAME = “lsmg”;</p><p>class专属常量, 使用如下方式. 可以限定作用域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_ROOM = <span class="number">10000</span>; <span class="comment">// 常量声明式 - 常量且只有一份</span></span><br><span class="line">Gameroom* rooms[MAX_ROOM];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要获取class专属常量的地址, 或者需要定义式. 则需要在<code>实现文件</code>而非<code>头文件</code>, 如下声明<br><code>const int Game::MAX_ROOM</code> - 未给定初值<br>由于class常量已经在声明时获得初值, 所以不用在给定初值</p><p>这里我发现一件事情, 这本书 不能只读一遍, 最少两边完整的<br>前面就已经开始使用后面的条款了, 先着重本条款, 跨条款的等第二遍</p><h2 id="条款03-尽可能使用const"><a href="#条款03-尽可能使用const" class="headerlink" title="条款03 尽可能使用const"></a>条款03 尽可能使用const</h2><p><strong>总结</strong></p><ul><li>将某些东西声明为const可帮助编译器探测到错误用法<br>const可以用作在任何作用域内的对象, 函数参数, 函数返回类型, 成员函数本体</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = greeting;</span><br><span class="line"><span class="comment">// const 在 * 左边 被指物是常量 在右边自己是常量 两边都是常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = greeting; <span class="comment">// 指针指向可以变, 指向的值不能变</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">// 指针指向不可以变, 指向的值可以变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">// 都不可以变</span></span><br></pre></td></tr></table></figure><p><strong>const 参数, 可你帮你检查 == 被写成=的情况</strong><br>这本书看来挺有意思的2333333</p><p><strong>const 函数, 这里看不太懂 没有原来如此的感觉</strong></p><h2 id="条款04-确定对象使用前已经被初始化"><a href="#条款04-确定对象使用前已经被初始化" class="headerlink" title="条款04 确定对象使用前已经被初始化"></a>条款04 确定对象使用前已经被初始化</h2><p><strong>总结</strong></p><ul><li>为内置型对象进行手工初始化.</li><li>构造函数对号食用成员初值列, 不要在构造函数中赋值. 初值列次数应该与声明次序相同</li><li>为了免除 跨编译单元的初始化次数问题, 用<code>local static</code>对象替换<code>non-local static</code>对象</li></ul><p>永远在使用对象前, 进行初始化.<br>在构造函数中, 对所有值进行初始化<br>构造函数使用<code>成员初始列</code>进行<code>初始化操作</code>而非<code>赋值操作</code></p><p><strong>减少default构造函数不必要的调用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; &amp;room_list);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; room_list_;</span><br><span class="line"><span class="keyword">int</span> roomnum_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class="line">&#123;</span><br><span class="line">name_ = name; <span class="comment">// 这些都是赋值 不是初始化</span></span><br><span class="line">room_list_ = room_list;</span><br><span class="line">roomnum_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++规定 对象的 成员变量  初始化动作  发生在  进入构造函数本体  之前</span></span><br><span class="line"><span class="comment">// name_  room_list_  两个在构造函数中被赋值, 而初始化在进入构造函数之前</span></span><br><span class="line"><span class="comment">// ---发生在这些成员的default构造函数被调用的时候, (发生在进入构造函数前)</span></span><br><span class="line"><span class="comment">// ---roomnum_例外 int属于内置类型</span></span><br></pre></td></tr></table></figure><p>上面的初始化方式, 浪费了default的构造函数 所以推荐使用下面的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A::A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class="line">:name_(name), room_list_(room_list), roomnum_(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然最终结果相同, 但没有浪费default构造函数. 前两个调用的copy构造函数.</p><p><strong>还可以使用成员初值列 来default构造一个成员变量.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A::A()</span><br><span class="line">:name_(), room_list_(), roomnum_(<span class="number">0</span>)</span><br><span class="line">&#123; <span class="comment">// 前两个全部调用的default构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const reference 内置类型(初始化与赋值等成本) 一定成员初始值列</strong></p><p><strong>初始值列总是使用 声明次序进行初始化, 而非写的顺序, 所以最好按声明次序列出</strong></p><p><strong>不同编译单元内定义之 non-local static对象 的初始化 次序</strong><br>static对象: 虚构函数会在main() 结束时被自动调用<br>local static对象: 函数内的static对象<br>non-local对象: 其他static对象</p><p>编译单元: 产出单一目标文件的那些源码, 基本是单一源码文件和他包含的头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filesystem.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">GetNum</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> FIieSystem tfs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// directory.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Directory(params);</span><br><span class="line">&#125;</span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> num = tfs.GetNum(); <span class="comment">// 使用tfs对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function">Directory <span class="title">temp_dir</span><span class="params">(params)</span></span>;</span><br></pre></td></tr></table></figure><p>只有当 tfs在temp_dir初始化之前被初始化 才能得到正确的结果. 否则会调用未初始化的对象</p><p>但是这个次序无法保证<br>因为C++ 对这种情况没有明确定义</p><p>如何解决这个问题呢??<br>将每个<code>non-local static</code>对象搬到自己的专属函数内(该对象在此函数内被声明为static)<br>函数返回一个reference对象他所包含的对象<br>用户调用这个函数而不是直接调用对象</p><p>解决的原因呢?<br>C++ 保证函数内的<code>local static</code>对象 会在<code>函数被调用期间</code>, <code>首次遇到该对象的定义式</code>被初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filesystem.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">GetNum</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">FileSystem</span>&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">FileSystem</span> fs;</span><br><span class="line"><span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// directory.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Directory(params);</span><br><span class="line">&#125;</span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> num = tfs().GetNum(); <span class="comment">// 使用tfs对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">temp_dir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> Directory td;</span><br><span class="line"><span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造析构赋值运算"><a href="#构造析构赋值运算" class="headerlink" title="构造析构赋值运算"></a>构造析构赋值运算</h1><h2 id="条款0506-了解C-默认编写并调用哪些函数-并适当拒绝"><a href="#条款0506-了解C-默认编写并调用哪些函数-并适当拒绝" class="headerlink" title="条款0506 了解C++默认编写并调用哪些函数 并适当拒绝"></a>条款0506 了解C++默认编写并调用哪些函数 并适当拒绝</h2><p><strong>夹带如下私货-public-inline</strong></p><ul><li>一个构造函数(如果你没有任何构造函数)</li><li>一个拷贝构造函数</li><li>一个析构函数</li><li>一个拷贝</li></ul><p>拷贝构造函数和拷贝运算符 自动生成的只是单纯的将来源对象的每一个<code>non-static</code>成员变量<br>拷贝到目标对象</p><p><strong>遇到const 和 引用成员 默认的拷贝无法工作, 编译器会发出警告</strong></p><p><strong>将不需要的成员函数声明为private, 并且不实现</strong></p><h2 id="条款07-为多态基类声明virtual析构函数"><a href="#条款07-为多态基类声明virtual析构函数" class="headerlink" title="条款07 为多态基类声明virtual析构函数"></a>条款07 为多态基类声明virtual析构函数</h2><p>返回指向子类的 父类型指针.<br>如果delete这个指针, 在父类析构函数不是virtual的情况下, 很可能会导致<br>父类的成分被销毁, 然而子类多出来的部分不被销毁. 造成局部销毁!!</p><p><strong>防止局部销毁很简单, 将父类的析构函数声明为virtual</strong></p><p><strong>任何class 只要带有virtual函数 几乎确定应该有一个virtual析构函数</strong></p><p><strong>无端的声明virtual函数是错误的</strong><br>如果class不含virtual函数, 通常表示这个class 不是想做为父类, 这时如果将其析构函数声明为virual<br>是一个馊主意………….</p><p><em>class类的大小 = 成员变量占据大小 + vptr(vitual table pointer)指针大小(4~8 字节)</em></p><p>每一个带有virtual函数的class都有对应的vtbl</p><p>当对象调用某一vitual函数的时候, 实际调用的函数取决于<br>vptr(vitual table pointer)指针指向的vtbl(vitual table)</p><p>无端的使用virtual函数 会导致占用空间的增大</p><h2 id="条款08-别让异常逃离析构函数"><a href="#条款08-别让异常逃离析构函数" class="headerlink" title="条款08 别让异常逃离析构函数"></a>条款08 别让异常逃离析构函数</h2><p><strong>总结</strong></p><ul><li>析构函数绝对不要抛出异常, 如果被析构函数调用的函数可能抛出异常, 析构函数应该捕获所有异常<br>然后吞下它们, 或者结束程序</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应, class应该提供一个普通函数(而非在析构函数中)<br>执行操作</li></ul><p><strong>析构函数不要抛出异常</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">~Widget() &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Widget&gt; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>v</code>被销毁的时候, Widget的析构函数第一次抛出异常C++还能接受?<br>第二次就会造成不明确行为</p><h2 id="条款09-绝不在构造函数和析构过程中调用virtual函数"><a href="#条款09-绝不在构造函数和析构过程中调用virtual函数" class="headerlink" title="条款09: 绝不在构造函数和析构过程中调用virtual函数"></a>条款09: 绝不在构造函数和析构过程中调用virtual函数</h2><p><strong>总结</strong></p><ul><li>在构造和析构期间不要调用virtual函数, 因为这类调用从不下降到<code>子类</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Transaction();</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">LogTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">Transaction::Transaction()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">LogTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">LogTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTransaction</span>:</span> <span class="keyword">public</span> Transaction</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">LogTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure><p>BuyTransaction的构造函数会被调用, 但是父类的构造函数会更显被调用.<br>然后父类构造函数调用<code>LogTransaction()</code>的版本是<code>父类</code>的版本!!! 不是子类的版本</p><p>析构函数也是同样的道理, 当<code>子类</code>的析构函数执行后, <code>子类</code>中的属性值就成为未定义状态<br>进入<code>父类</code>后对象就成为一个<code>父类</code>对象</p><p>本例子中既然无法实现使用<code>virtual</code>函数从<code>父类</code>向下调用, 可以再构造期间, 将<br><code>子类</code>必要的构造信息向上传给<code>父类</code>的构造函数</p><h2 id="条款10-另operator-返回一个reference-to-this"><a href="#条款10-另operator-返回一个reference-to-this" class="headerlink" title="条款10: 另operator= 返回一个reference to *this"></a>条款10: 另operator= 返回一个reference to *this</h2><p>注意这只是一个协议, 并无强制性. 如果不遵守代码依然可以通过编译, 然而这份 协议被所有内置类型<br>和标准程序库提供的类型共同遵守.<br>因此除非你有一个标新立异的好理由, 不然还是随众吧</p><h2 id="条款11-在operator-中处理”自我赋值”"><a href="#条款11-在operator-中处理”自我赋值”" class="headerlink" title="条款11: 在operator= 中处理”自我赋值”"></a>条款11: 在operator= 中处理”自我赋值”</h2><p><strong>总结</strong></p><ul><li>确保当对象自我赋值时operator=有良好的的行为. 其中技术包括比较”来源对象”<br>和”目标对象”的地址, 精心周到的语句顺序, 以及copy-and-swap</li><li>确认任何函数如果操作一个以上的对象, 而其中多个对象是同一个对象的时候, 进行仍未正确</li></ul><p><strong>自我赋值是什么</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>...&#125;;</span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line">w=w; <span class="comment">// 什么这个看起来不可能, 那下面呢?</span></span><br><span class="line"></span><br><span class="line">a[i] = a[j]; <span class="comment">// 这个怎么样?  潜在的自我赋值</span></span><br><span class="line">*px = *py <span class="comment">// 这个呢? 潜在的自我赋值</span></span><br></pre></td></tr></table></figure><p><strong>会出现的问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gameroom</span>&#123;</span>....&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Gameroom* room_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator=的实现代码</span></span><br><span class="line">Game&amp; Game::<span class="keyword">operator</span>=(<span class="keyword">const</span> Game&amp; ths)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> room_;</span><br><span class="line">room_ = <span class="keyword">new</span> Gameroom(*ths.room_);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码 如果 this和ths指向同一个对象就会造成 <code>room_</code>构造失败<br>因为被<code>delete</code>的<code>room_</code>就是要传入的</p><p>如何解决这个问题呢?<br><em>比较来源对象 整同测试</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Game&amp; Game::<span class="keyword">operator</span>=(<span class="keyword">const</span> Game&amp; ths)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;ths)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> room_;</span><br><span class="line">room_ = <span class="keyword">new</span> Gameroom(*ths.room_);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果 <code>new Gameroom(*ths.room_)</code>错误, 导致room_指向不安全的内存<br>使用下面的代码, 可以导出异常安全, 以及自我赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Game&amp; Game::<span class="keyword">operator</span>=(<span class="keyword">const</span> Game&amp; ths)</span><br><span class="line">&#123;</span><br><span class="line">Gameroom* p_room = room_;</span><br><span class="line">room_ = <span class="keyword">new</span> Gameroom(*ths.room_);</span><br><span class="line"><span class="keyword">delete</span> p_room;</span><br><span class="line">retutn *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在如果<code>new Gameroom</code>抛出异常, room_还可以保持原状.<br>同时也能处理自我赋值</p><p><em>copy and swap</em><br>这一段描述我看完之后, 突然想到了上午看的Jsoncpp里面的代码!!!!! 就有这个<br>下面的代码更加高效 但是牺牲了清晰性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Game&amp; rhs)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Game&amp; Game::<span class="keyword">operator</span>=(<span class="keyword">const</span> Game&amp; ths)</span><br><span class="line">&#123;</span><br><span class="line">Game temp(<span class="keyword">this</span>);</span><br><span class="line">swap(temp);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款12-复制对象时勿忘其每一个成分"><a href="#条款12-复制对象时勿忘其每一个成分" class="headerlink" title="条款12: 复制对象时勿忘其每一个成分"></a>条款12: 复制对象时勿忘其每一个成分</h2><h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><h2 id="条款19-设计class犹如设计type"><a href="#条款19-设计class犹如设计type" class="headerlink" title="条款19: 设计class犹如设计type"></a>条款19: 设计class犹如设计type</h2><p>如何设计高效的classes呢?</p><ul><li>新class的对象该如何被创建和销毁? 这会影响到构造析构函数内存分配释放函数</li><li>对象的初始化和对象的赋值有什么样的差别? 决定构造函数和赋值运算符的行为.<br>搞清初始化和赋值</li><li>注意class对象被值传递 拷贝构造函数会被调用用来生成临时对象</li><li>什么是新class的合法值? <code>setter</code>函数需要进行的范围检查</li><li>你的新class需要配合某个继承图系吗? // TODO</li><li>你的新class需要什么样的转换? 如果需要类型转换需要在class中编写<code>类型转换函数</code></li><li>什么样的操作运算符和函数对此class而言是合理的? 决定你为class声明哪些函数(条款 23 24 46)</li><li>将需要驳回的标准函数设置为private</li><li>你的新type有多么一般化? 或许应该定义一整个class家族. 也许模板能帮你</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;让自己习惯C&quot;&gt;&lt;a href=&quot;#让自己习惯C&quot; class=&quot;headerlink&quot; title=&quot;让自己习惯C++&quot;&gt;&lt;/a&gt;让自己习惯C++&lt;/h1&gt;&lt;h2 id=&quot;条款02-尽量用const-enum-inline-替换-define&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
</feed>
