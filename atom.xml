<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lsmg的大学之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lsmg.xyz/"/>
  <updated>2020-12-04T00:29:00.272Z</updated>
  <id>http://blog.lsmg.xyz/</id>
  
  <author>
    <name>Lsmg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>力扣12.3-N1143.最长公共子序列</title>
    <link href="http://blog.lsmg.xyz/2020/12/%E5%8A%9B%E6%89%A312.3-N1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://blog.lsmg.xyz/2020/12/%E5%8A%9B%E6%89%A312.3-N1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2020-12-03T08:25:02.000Z</published>
    <updated>2020-12-04T00:29:00.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p><p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p><p>若这两个字符串没有公共子序列，则返回 0。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0。</span><br></pre></td></tr></table></figure><p>提示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&#x3D; text1.length &lt;&#x3D; 1000</span><br><span class="line">1 &lt;&#x3D; text2.length &lt;&#x3D; 1000</span><br><span class="line">输入的字符串只含有小写英文字符。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-common-subsequence" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; text1, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; text2, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> text1_sub, <span class="keyword">int</span> text2_sub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (text1_sub &gt;= text1.length() || text2_sub &gt;= text2.length())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (text1[text1_sub] == text2[text2_sub])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + longest(text1, text2, text1_sub + <span class="number">1</span>, text2_sub + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(longest(text1, text2, text1_sub + <span class="number">1</span>, text2_sub), </span><br><span class="line">                    longest(text1, text2, text1_sub, text2_sub + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> longest(text1, text2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简单的思路 然而会超时</p><h2 id="代码2-动态规划"><a href="#代码2-动态规划" class="headerlink" title="代码2 动态规划"></a>代码2 动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result[<span class="number">1005</span>][<span class="number">1005</span>]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; text1.length(); ++i1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i2 = <span class="number">0</span>; i2 &lt; text2.length(); ++i2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i1] == text2[i2])</span><br><span class="line">                &#123;</span><br><span class="line">                    result[i1 + <span class="number">1</span>][i2 + <span class="number">1</span>] = result[i1][i2] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    result[i1 + <span class="number">1</span>][i2 + <span class="number">1</span>] = <span class="built_in">max</span>(result[i1][i2 + <span class="number">1</span>], result[i1 + <span class="number">1</span>][i2]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[text1.length()][text2.length()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>设text1和text2的解是T</p><ul><li>如果text1和text2的最后两个字符相等, 则T的最后一个字符也是这个字符</li></ul><p>这样 text1和text2分别去掉最后一个字符后, T去掉最后一个字符后的T1 是前面两个新字符串的最长公共子序列</p><ul><li>如果最后两个字符不同, 则T可能是text1去掉最后一个字符后和text2的最长公共子序列 也可能是text2去掉最后一个字符后和text1的最长公共子序列</li></ul><p>这个可以循环下去, 直到最后两个字符相等 转入上方过程</p><p>由于存在多种可能便需要设置result数组存储中间结果<code>result[i][j]</code>是text1前i个字符和text2前j个字符的最长公共子序列长度</p><p>数组填充方式 为上方描述的逆过程. </p><ul><li><p>如果i1 i2所指字符相同 <code>result[i][j]</code>结果是<code>result[i - 1][j - 1] + 1</code><br>表示的是text1前i-1字符和text2前j-1字符最长公共子序列 加上 这个相同的字符 得到前i和前j的最长公共子序列</p></li><li><p>如果所指字符不同则<code>result[i][j]</code>可能是<code>result[i][j - 1]</code> 也可能是<code>result[i][j - 1]</code>取最大值<br>表示的是前ij的最长公共子序列是 text1前i字符和text2前j-1字符最长公共子序列 或者是 前i-1和前j的最长公共子序列</p></li></ul><p>最终得到结果<code>result[text1.length()][text2.length()]</code> 表示前length1和前length2的最长公共子序列</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最长公共子序列&quot;&gt;&lt;a href=&quot;#最长公共子序列&quot; class=&quot;headerlink&quot; title=&quot;最长公共子序列&quot;&gt;&lt;/a&gt;最长公共子序列&lt;/h1&gt;&lt;p&gt;给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://blog.lsmg.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>P2P直播平台</title>
    <link href="http://blog.lsmg.xyz/2020/12/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-P2P%E7%9B%B4%E6%92%AD%E5%B9%B3%E5%8F%B0/"/>
    <id>http://blog.lsmg.xyz/2020/12/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-P2P%E7%9B%B4%E6%92%AD%E5%B9%B3%E5%8F%B0/</id>
    <published>2020-12-02T04:50:02.000Z</published>
    <updated>2020-12-02T11:11:25.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h1><p><strong>当前进度 支持多个RTMP推流者推流 支持多个HTTP-FLV拉流者拉取对应的流观看</strong></p><p><strong>使用C++17标准 Windows和Centos平台均使用gcc编译通过正常使用</strong></p><p><strong>运行后在两个推流者四个观看者情况下 Linux占用内存6MB Windows占用内存1MB CPU使用极低</strong></p><p><strong>支持IPV4和IPV6</strong></p><p>服务器端代码量 包含网络部分 5000余行</p><p>HttpFlv拉流的播放器目前测试通过PotPlayer, VLC, flv.js</p><p>RTMP推流播放器仅测试过Obs</p><p>网络部分学习自 <a href="https://github.com/chenshuo/muduo" target="_blank" rel="noopener">https://github.com/chenshuo/muduo</a></p><p>跨平台支持学习自 <a href="https://github.com/balloonwj/flamingo" target="_blank" rel="noopener">https://github.com/balloonwj/flamingo</a></p><p>HTTP包装 RTMP解析 FLV解析 参考自网络相关文档</p><h1 id="项目规划"><a href="#项目规划" class="headerlink" title="项目规划"></a>项目规划</h1><p>开发轻量级跨Windows和Linux的可用于P2P直播的<code>服务器端</code>和<code>观看客户端</code></p><p>项目不打算开发UI方面的功能, 视频将使用第三方的支持HttpFlv拉流的播放器来播放(如PotPlayer)</p><h2 id="开发进度"><a href="#开发进度" class="headerlink" title="开发进度"></a>开发进度</h2><p>支持多个RTMP推流者推流(已完成)</p><p>支持多个HTTP-FLV拉流者拉取对应的流观看(已完成)</p><p>开发<code>观看客户端</code>主要用于从<code>服务器端</code>接收FLV数据 本地转化成HttpFlv格式 供<code>HttpFlv拉流软件本地拉取</code> (未开发)</p><p><code>观看者客户端</code>可以从<code>服务器端</code>获取数据也可以通过P2P技术与其他<code>观看者客户端</code>进行共享 (未开发)</p><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><p>主播使用<code>RTMP推流软件(如Obs)</code>将RTMP流发送到<code>服务器端</code> <code>服务器端</code>将Rtmp流解析生成FLV数据包装在HTTP中推送给观看者</p><p>观看者直接使用<code>服务器端</code>生成的HTTPFLV地址 拉流观看</p><h2 id="P2P版本-未开发"><a href="#P2P版本-未开发" class="headerlink" title="P2P版本 (未开发)"></a>P2P版本 (未开发)</h2><h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><p><strong>编译执行文件</strong><br>下载源代码后在Windows平台或者Linux平台编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/HiganFish/LiveBroadcast.git</span><br><span class="line"></span><br><span class="line">cd LiveBroadcast/LiveBroadcastServer/</span><br><span class="line"></span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line"></span><br><span class="line">cmake ..</span><br><span class="line"></span><br><span class="line">make -j4</span><br></pre></td></tr></table></figure><p>生成运行文件<code>LiveBroadcastServer</code></p><p><strong>运行服务器</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./LiveBroadcastServer 4000 4100 # 4000 Rtmp推流端口 4100 HTTP-FLV拉流端口</span><br></pre></td></tr></table></figure><p><strong>Obs推流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置-&gt;推流-&gt;服务器</span></span><br><span class="line">rtmp://[::1]:4000/test-push  # 注意 rtmp和http链接的对应关系 默认是相同的路径为同一个房间</span><br><span class="line">rtmp://127.0.0.1:4000/test-push # 可以在main.cpp中修改映射关系</span><br></pre></td></tr></table></figure><p><strong>HTTP-FLV拉流</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://[::1]:4000/test-push # 注意 rtmp和http链接的对应关系 默认是相同的路径为同一个房间</span><br><span class="line">http://127.0.0.1:4000/test-push # 可以在main.cpp中修改映射关系</span><br></pre></td></tr></table></figure><h1 id="项目所需技术"><a href="#项目所需技术" class="headerlink" title="项目所需技术"></a>项目所需技术</h1><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><h3 id="FLV"><a href="#FLV" class="headerlink" title="FLV"></a>FLV</h3><p>FLV文件由一个FileHeader起头 后面为若干个FileTag 直到文件结束前四个字节<br>最后四个字节是上一个FileTag的大小减去4</p><p>FLV文件格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class FileHeader</span><br><span class="line">&#123;</span><br><span class="line">char flv[3]; &#x2F;&#x2F; FLV</span><br><span class="line">uint8_t version; &#x2F;&#x2F; 1</span><br><span class="line">uint8_t type_flags; &#x2F;&#x2F; 5</span><br><span class="line">uint32_t header_length; &#x2F;&#x2F; 9</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class FileTag</span><br><span class="line">&#123;</span><br><span class="line">uint32_t previous_tag_size; &#x2F;&#x2F; 不含previous_tag_size  sizeof 上一个Tag - 4</span><br><span class="line">uint8_t tag_type; &#x2F;&#x2F; 音频 8 视频 9 scripts 18</span><br><span class="line">uint8_t data_size[3]; &#x2F;&#x2F; AudioTag VideoTag 的数据长度 从stream_id后开始算起</span><br><span class="line">uint8_t timestamp[3];</span><br><span class="line">uint8_t timestamp_extend;</span><br><span class="line">uint8_t stream_id[3]; &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">char* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前三个Tag可以认为有特殊作用 所以单独说一下</p><p>以后的所有Tag均为音视频数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileHeader file_header; &#x2F;&#x2F; 每次开始都要发送一次</span><br><span class="line">FileTag info_tag; &#x2F;&#x2F; 每次开始都要发送一次</span><br><span class="line">FileTag sps_pps_tag; &#x2F;&#x2F; 每次开始都要发送一次 第一个视频tag存储编码信息</span><br><span class="line">FileTag audio_tag; &#x2F;&#x2F; 每次开始都要发送一次 第一个音频tag存储编码信息</span><br><span class="line"></span><br><span class="line">FileTag data[N]; &#x2F;&#x2F; 真正的数据部分</span><br></pre></td></tr></table></figure><p>每次有<code>观看者客户端</code>连接的时候 都要发送一次<code>file_header</code>,<code>info_tag</code>和<code>sps_pps_tag</code> 以及<code>audio_tag</code>之后便是数据部分</p><h3 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h3><h4 id="RTMP握手协议"><a href="#RTMP握手协议" class="headerlink" title="RTMP握手协议"></a>RTMP握手协议</h4><p>Obs客户端首先会发送C1 服务器端直接将C1作为S1发送回去, Obs会发送C2 服务端继续发送C1作为S2 握手成功</p><p>商定窗口大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--&gt;</span><br><span class="line">connect</span><br><span class="line"></span><br><span class="line">&lt;-- Window Acknowledgement Size 5000000</span><br><span class="line">[02 00 00 00 00 00 04 05 00 00 00 00 00 4c 4b 40]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;-- Set Peer Bandwidth 5000000,Dynamic|Set Chunk Size 4096|_result(&#39;NetConnection.Connect.Success&#39;)</span><br><span class="line">[02 00 00 00 00 00 05 06 00 00 00 00 00 4c 4b 40 02]</span><br><span class="line">[02 00 00 00 00 00 04 01 00 00 00 00 00 00 10 00]</span><br><span class="line">[03 00 00 00 00 00 be 14 00 00 00 00 02 00 07 5f 72 65 73 75 6c 74 00 3f f0 00 00 00 00 00 00 03 00 06 66 6d 73 56 65 72 02 00 0d 46 4d 53 2f 33 2c 30 2c 31 2c 31 32 33 00 0c 63 61 70 61 62 69 6c 69 74 69 65 73 00 40 3f 00 00 00 00 00 00 00 00 09 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74 75 73 00 04 63 6f 64 65 02 00 1d 4e 65 74 43 6f 6e 6e 65 63 74 69 6f 6e 2e 43 6f 6e 6e 65 63 74 2e 53 75 63 63 65 73 73 00 0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 15 43 6f 6e 6e 65 63 74 69 6f 6e 20 73 75 63 63 65 65 64 65 64 2e 00 0e 6f 62 6a 65 63 74 45 6e 63 6f 64 69 6e 67 00 00 00 00 00 00 00 00 00 00 00 09]</span><br></pre></td></tr></table></figure><p>建立流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--&gt;</span><br><span class="line">releaseStream</span><br><span class="line">FCPublish</span><br><span class="line">createStream</span><br><span class="line">&lt;-- _result()</span><br><span class="line">[03 00 00 00 00 00 1d 14 00 00 00 00 02 00 07 5f 72 65 73 75 6c 74 00 40 10 00 00 00 00 00 00 05 00 3f f0 00 00 00 00 00 00]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line">publish</span><br><span class="line">&lt;-- onStatus(&#39;NetStream.Publish.Start&#39;)</span><br><span class="line">[05 00 00 00 00 00 69 14 01 00 00 00 02 00 08 6f 6e 53 74 61 74 75 73 00 00 00 00 00 00 00 00 00 05 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74 75 73 00 04 63 6f 64 65 02 00 17 4e 65 74 53 74 72 65 61 6d 2e 50 75 62 6c 69 73 68 2e 53 74 61 72 74 00 0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 10 53 74 61 72 74 20 70 75 62 6c 69 73 68 69 6e 67 00 00 09]</span><br></pre></td></tr></table></figure><p>至此连接建立完毕, Obs开始推流</p><h4 id="RTMP推流协议部分"><a href="#RTMP推流协议部分" class="headerlink" title="RTMP推流协议部分"></a>RTMP推流协议部分</h4><p>RTMP的消息单元称为Message单个Message太大被拆分为多块 包装在Message Chunk中发送</p><p>所以服务器端需要从TCP流中获取Message Chunk组装出Message 再从Message中获取到音视频数据</p><h5 id="Message-Chunk"><a href="#Message-Chunk" class="headerlink" title="Message Chunk"></a>Message Chunk</h5><p><code>Message Chunk</code> = <code>Message Chunk Header</code> + <code>Chunk Data</code></p><p><code>Message Chunk Header</code> = <code>Basic Header</code> + <code>Message Header</code> + <code>extern timestamp</code></p><p>如以下例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000   04 00 00 00 00 00 31 09 01 00 00 00 17 00 00 00</span><br><span class="line">0010   00 01 64 00 28 ff e1 00 1d 67 64 00 28 ac d9 40</span><br><span class="line">0020   78 02 27 e5 9a 80 80 80 a0 00 00 03 00 20 00 00</span><br><span class="line">0030   07 91 e3 06 32 c0 01 00 04 68 ef bc b0</span><br></pre></td></tr></table></figure><p><strong>Basic Header</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">04 &#x3D; 00  00 0100&#x2F;&#x2F; fmt &#x3D; 0 csid &#x3D; 4</span><br></pre></td></tr></table></figure><p>1字节 初期只关注csid为4的数据部分, 因为csid为4时对应音视频数据</p><p><strong>Message Header</strong></p><p>fmt = 0 11字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 &#x2F;&#x2F; timestamp</span><br><span class="line">00 00 31 &#x2F;&#x2F; msglength</span><br><span class="line">09 &#x2F;&#x2F; typeid 9视频</span><br><span class="line">01 00 00 00 &#x2F;&#x2F; 小端存储  message stream id</span><br></pre></td></tr></table></figure><p>fmt = 1 7字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 &#x2F;&#x2F; timestamp 前一个块时间戳与当前块时间戳的差值，即相对时间戳</span><br><span class="line">00 00 31 &#x2F;&#x2F; msglength</span><br><span class="line">09 &#x2F;&#x2F; typeid 9视频</span><br><span class="line">&#x2F;&#x2F; 不含 message stream id 此时块与之前的块取相同的消息流ID</span><br></pre></td></tr></table></figure><p>fmt = 2 3字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 &#x2F;&#x2F; timestamp 前一个块时间戳与当前块时间戳的差值，即相对时间戳</span><br><span class="line">&#x2F;&#x2F; 不含 msglength 与前一个相同</span><br><span class="line">&#x2F;&#x2F; 09 不含typeid 9视频</span><br><span class="line">&#x2F;&#x2F; 不含 message stream id 此时块与之前的块取相同的消息流ID</span><br></pre></td></tr></table></figure><p>fmt = 3 0字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不含头 一个消息被分成多个的时候 使用这个类型</span><br></pre></td></tr></table></figure><p>至于<code>Chunk Data</code>就是Flv的data部分</p><p>Obs发送<code>@SetDataFrame()</code>其中Data为info_tag的data部分<br>Obs发送<code>Audio Data</code>其中Data为audio_tag的data部分  音频数据包<br>Obs发送<code>Video Data</code>其中Data为sps_pps_tag的data部分  视频数据包</p><p>之后便是正常画面声音的Flv数据发送.</p><h1 id="文件介绍"><a href="#文件介绍" class="headerlink" title="文件介绍"></a>文件介绍</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">├── main.cpp</span><br><span class="line">├── network # 网络部分学习自muduo</span><br><span class="line">│   ├── Acceptor.cpp</span><br><span class="line">│   ├── Acceptor.h</span><br><span class="line">│   ├── Callback.h</span><br><span class="line">│   ├── Channel.cpp</span><br><span class="line">│   ├── Channel.h</span><br><span class="line">│   ├── EventLoop.cpp</span><br><span class="line">│   ├── EventLoop.h</span><br><span class="line">│   ├── InetAddress.cpp</span><br><span class="line">│   ├── InetAddress.h</span><br><span class="line">│   ├── multiplexing</span><br><span class="line">│   │   ├── Epoll.cpp</span><br><span class="line">│   │   ├── Epoll.h</span><br><span class="line">│   │   ├── MultiplexingBase.cpp</span><br><span class="line">│   │   ├── MultiplexingBase.h</span><br><span class="line">│   │   ├── Select.cpp</span><br><span class="line">│   │   └── Select.h</span><br><span class="line">│   ├── PlatformNetwork.cpp # 网络跨平台相关学习自flamingo</span><br><span class="line">│   ├── PlatformNetwork.h # 网络跨平台相关学习自flamingo</span><br><span class="line">│   ├── protocol # 将Rtmp推流者和HTTPFlv拉流者的TCP连接包装</span><br><span class="line">│   │   ├── RtmpClientConnection.cpp</span><br><span class="line">│   │   ├── RtmpClientConnection.h</span><br><span class="line">│   │   ├── RtmpServerConnection.cpp</span><br><span class="line">│   │   └── RtmpServerConnection.h</span><br><span class="line">│   ├── Socket.cpp</span><br><span class="line">│   ├── Socket.h</span><br><span class="line">│   ├── SocketOps.cpp</span><br><span class="line">│   ├── SocketOps.h</span><br><span class="line">│   ├── TcpConnection.cpp</span><br><span class="line">│   ├── TcpConnection.h</span><br><span class="line">│   ├── TcpServer.cpp</span><br><span class="line">│   ├── TcpServer.h</span><br><span class="line">│   └── test</span><br><span class="line">│       └── TcpServerTest.cpp</span><br><span class="line">└── utils</span><br><span class="line">    ├── Buffer.cpp</span><br><span class="line">    ├── Buffer.h</span><br><span class="line">    ├── codec</span><br><span class="line">    │   ├── FlvCodec.cpp # FLV解析</span><br><span class="line">    │   ├── FlvCodec.h</span><br><span class="line">    │   ├── FlvManager.cpp # 管理FLV的解析 保存重要的几个Tag</span><br><span class="line">    │   ├── FlvManager.h</span><br><span class="line">    │   ├── RtmpCodec.cpp # Rtmp解析</span><br><span class="line">    │   ├── RtmpCodec.h</span><br><span class="line">    │   ├── RtmpManager.cpp # 管理Rtmp解析 将Rtmp数据部分转换成FlvTag</span><br><span class="line">    │   ├── RtmpManager.h</span><br><span class="line">    │   └── test</span><br><span class="line">    │       ├── FlvManagerTest.cpp</span><br><span class="line">    │       └── RtmpManagerTest.cpp</span><br><span class="line">    ├── File.cpp # 文件读写工具类</span><br><span class="line">    ├── File.h</span><br><span class="line">    ├── Format.cpp # 字符串格式化</span><br><span class="line">    ├── Format.h</span><br><span class="line">    ├── Logger.cpp # 简易低性能日志</span><br><span class="line">    ├── Logger.h</span><br><span class="line">    ├── PlatformBase.cpp # 基础部分跨平台代码</span><br><span class="line">    ├── PlatformBase.h</span><br><span class="line">    ├── test</span><br><span class="line">    │   └── LoggerTest.cpp</span><br><span class="line">    ├── Timestamp.cpp</span><br><span class="line">    └── Timestamp.h</span><br><span class="line"></span><br><span class="line">8 directories, 55 files</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;项目说明&quot;&gt;&lt;a href=&quot;#项目说明&quot; class=&quot;headerlink&quot; title=&quot;项目说明&quot;&gt;&lt;/a&gt;项目说明&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;当前进度 支持多个RTMP推流者推流 支持多个HTTP-FLV拉流者拉取对应的流观看&lt;/strong&gt;&lt;/p
      
    
    </summary>
    
    
      <category term="项目制作" scheme="http://blog.lsmg.xyz/categories/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣12.1-N5.最长回文子串</title>
    <link href="http://blog.lsmg.xyz/2020/12/%E5%8A%9B%E6%89%A312.1-N5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://blog.lsmg.xyz/2020/12/%E5%8A%9B%E6%89%A312.1-N5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2020-12-01T08:25:02.000Z</published>
    <updated>2020-12-03T04:38:41.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="代码1-中心扩散法"><a href="#代码1-中心扩散法" class="headerlink" title="代码1 - 中心扩散法"></a>代码1 - 中心扩散法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/* 开头老套路 先处理了最简单的输入*/</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 记录最大长度*/</span></span><br><span class="line">        <span class="keyword">int</span> max_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 记录最大长度子串的开始下标 用于return时的substr 解决拷贝问题*/</span></span><br><span class="line">        <span class="keyword">int</span> result_begin_sub = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l_begin = i, r_begin = i;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 从当前下标开始 找到最长的相同字符子串*/</span></span><br><span class="line">            <span class="comment">/* lbegin指向此子串的开始字符 rbegin指向结尾字符*/</span></span><br><span class="line">            <span class="keyword">while</span> (r_begin &lt; s.length() - <span class="number">1</span> &amp;&amp; s[r_begin + <span class="number">1</span>] == s[i])</span><br><span class="line">            &#123;</span><br><span class="line">                r_begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* 更新下标 减少循环次数*/</span></span><br><span class="line">            i = r_begin + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 向左右两侧遍历 相同字符则 向左移动lbegin 向右移动rbegin*/</span></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                l_begin--;</span><br><span class="line">                r_begin++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (l_begin &gt;=<span class="number">0</span> &amp;&amp; r_begin &lt; s.length() &amp;&amp; s[l_begin] == s[r_begin]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/* 更新最大长度*/</span></span><br><span class="line">            <span class="keyword">int</span> len = r_begin - l_begin - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; max_len)</span><br><span class="line">            &#123;</span><br><span class="line">                max_len = len;</span><br><span class="line">                result_begin_sub = l_begin + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substr(result_begin_sub, max_len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>遍历字符串 从当前循环开始下标找到最长的相同字符子串 如a 或 bb 或 ccc</p><p>然后向左右两侧遍历 如果左右字符相同 继续遍历 最终得到两个下标</p><p>左下标指向当前最大回文子串的左边一个字符 右下标指向右边一个字符</p><p>这样就得到了子串的开始下标和长度 更新最大长度 继续遍历</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最长回文子串&quot;&gt;&lt;a href=&quot;#最长回文子串&quot; class=&quot;headerlink&quot; title=&quot;最长回文子串&quot;&gt;&lt;/a&gt;最长回文子串&lt;/h1&gt;&lt;p&gt;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。&lt;/p&gt;
&lt;p&gt;示例
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="中心扩散" scheme="http://blog.lsmg.xyz/tags/%E4%B8%AD%E5%BF%83%E6%89%A9%E6%95%A3/"/>
    
  </entry>
  
  <entry>
    <title>由muduo tie引出的 delete this</title>
    <link href="http://blog.lsmg.xyz/2020/11/%E9%87%87%E5%9D%91%E8%AE%B0-delete%20this/"/>
    <id>http://blog.lsmg.xyz/2020/11/%E9%87%87%E5%9D%91%E8%AE%B0-delete%20this/</id>
    <published>2020-11-26T09:37:08.000Z</published>
    <updated>2020-11-26T11:23:57.152Z</updated>
    
    <content type="html"><![CDATA[<p>在半个多月以前 看完了深度探索C++对象模型, 然而只是粗略的过了一遍. 并没有结合具体的例子去深刻的理解下</p><p>如果delete this 不会遇到 那这样呢?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        bar_ = <span class="number">111111</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Foo()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"~Foo()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Bar1()\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Delete();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"bar: %d\n"</span>, bar_);</span><br><span class="line">        Bar1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bar_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo* foo = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">bool</span> del = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!del)</span><br><span class="line">    &#123;</span><br><span class="line">        del = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">delete</span> foo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo = <span class="keyword">new</span> Foo;</span><br><span class="line">    foo-&gt;Bar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    foo-&gt;Bar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序安然的结束了, 但是发现 成员变量bar的值已经被初始化了, 由于delete释放了内存.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~Foo()</span><br><span class="line">bar: 0</span><br><span class="line">Bar1()</span><br><span class="line"></span><br><span class="line">bar: 0</span><br><span class="line">Bar1()</span><br></pre></td></tr></table></figure><p>同时delete是两步操作</p><ol><li>调用对象的析构函数 (析构函数中调用 会导致递归)</li><li>释放相关空间</li></ol><p><a href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this" target="_blank" rel="noopener">官方解释</a></p><p><strong>成员变量指针类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bar_)</span><br><span class="line">        &#123;</span><br><span class="line">            bar_();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        bar_();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; bar_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo* foo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintfBar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Bar\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo = <span class="keyword">new</span> Foo;</span><br><span class="line">    foo-&gt;bar_ = PrintfBar;</span><br><span class="line"></span><br><span class="line">    foo-&gt;Bar1(); <span class="comment">// Bar</span></span><br><span class="line">    foo-&gt;Bar2(); <span class="comment">// Bar</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> foo;</span><br><span class="line"></span><br><span class="line">    foo-&gt;Bar1(); <span class="comment">// Segmentation fault (core dumped)</span></span><br><span class="line"></span><br><span class="line">    foo-&gt;Bar2();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试后所有对指针型成员变量的 解引用操作都会导致<code>Segmentation fault (core dumped)</code> 所以下面的代码也有了解释</p><p>一个困扰我很久的BUG 即为程序会在HandleEvent触发<code>Segmentation fault (core dumped)</code>的原因找到了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Channel::HandleEvent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lock增加TcpConnectionPtr的引用计数 防止从TcpServer中erase后 直接销毁TcpConnection</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 否则如果不增加引用计数 当TcpConnection被销毁后, 所管理的Channel也将会被销毁</span></span><br><span class="line"><span class="comment"> * 在这之后 不能再使用TcpConnection和Channel的任何 成员函数和成员变量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 有点类似于在一个 new出来的对象的成员函数中 delete自己</span></span><br><span class="line"><span class="comment"> * 详见 https://stackoverflow.com/questions/7039597/what-will-happen-if-you-do-delete-this-in-a-member-function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 经过查阅后自己对深度探索C++对象模型 有了更深得理解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span>&gt; guard = tie_.lock();</span><br><span class="line"><span class="keyword">if</span> (!guard)</span><br><span class="line">&#123;</span><br><span class="line">LOG_WARN(<span class="string">"connection: %s is closed"</span>, connection_name.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (event_ &amp; XEPOLLIN)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (readable_callback_)</span><br><span class="line">        &#123;</span><br><span class="line">            readable_callback_();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在半个多月以前 看完了深度探索C++对象模型, 然而只是粗略的过了一遍. 并没有结合具体的例子去深刻的理解下&lt;/p&gt;
&lt;p&gt;如果delete this 不会遇到 那这样呢?&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="采坑记" scheme="http://blog.lsmg.xyz/categories/%E9%87%87%E5%9D%91%E8%AE%B0/"/>
    
    
      <category term="采坑记" scheme="http://blog.lsmg.xyz/tags/%E9%87%87%E5%9D%91%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>力扣11.26-H23.合并K个升序链表</title>
    <link href="http://blog.lsmg.xyz/2020/11/%E5%8A%9B%E6%89%A311.26-H23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://blog.lsmg.xyz/2020/11/%E5%8A%9B%E6%89%A311.26-H23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</id>
    <published>2020-11-26T08:25:02.000Z</published>
    <updated>2020-12-03T04:39:21.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h1><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><p>示例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists &#x3D; [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists" target="_blank" rel="noopener">https://leetcode-cn.com/problems/merge-k-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (right - left == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* node1 = lists[left];</span><br><span class="line">            ListNode* node2 = lists[left + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!node1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> node2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!node2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> node1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ListNode* head = <span class="keyword">new</span> ListNode;</span><br><span class="line">            ListNode* node = head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;val &lt;= node2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                head-&gt;val = node1-&gt;val;</span><br><span class="line">                node1 = node1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                head-&gt;val = node2-&gt;val;</span><br><span class="line">                node2 = node2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (node1 != <span class="literal">nullptr</span> || node2 != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!node1 || (node2 &amp;&amp; node2-&gt;val &lt;= node1-&gt;val))</span><br><span class="line">                &#123;</span><br><span class="line">                    node-&gt;next = <span class="keyword">new</span> ListNode(node2-&gt;val);</span><br><span class="line">                    node = node-&gt;next;</span><br><span class="line">                    node2 = node2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node2 == <span class="literal">nullptr</span> || (node1 &amp;&amp; node1-&gt;val &lt; node2-&gt;val))</span><br><span class="line">                &#123;</span><br><span class="line">                    node-&gt;next = <span class="keyword">new</span> ListNode(node1-&gt;val);</span><br><span class="line">                    node = node-&gt;next;</span><br><span class="line">                    node1 = node1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            ListNode* node1 = Merge(lists, left, mid);</span><br><span class="line">            ListNode* node2 = Merge(lists, mid, right);</span><br><span class="line">            ListNode* result = Merge(&#123; node1, node2 &#125;, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Merge(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路的话比较简单 使用分治和递归. 将若干个<code>ListNode*</code>的合并的最终分解为 两两合并. 然后将合并结果再两两合并</p><p>第一版代码 我甚至没有delete临时用的指针… 有内存泄漏的问题  最终提交后 <code>Time-33%</code>…. 好吧</p><p>仔细想了下部分地方不需要这么多的拷贝 直接复用已有的<code>ListNode*</code>就行</p><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (right - left == <span class="number">2</span>) <span class="comment">// 主要改动从这里开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* node1 = lists[left];</span><br><span class="line">            ListNode* node2 = lists[left + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!node1)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> node2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!node2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> node1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ListNode* head;</span><br><span class="line">            <span class="keyword">if</span> (node1-&gt;val &lt;= node2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                head = node1;</span><br><span class="line">                node1 = node1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                head = node2;</span><br><span class="line">                node2 = node2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ListNode* node = head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (node1 != <span class="literal">nullptr</span> || node2 != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!node1) <span class="comment">// 同时在`node1`或`node2`为空的时候 直接append 避免额外的扫描</span></span><br><span class="line">                &#123;</span><br><span class="line">                    node-&gt;next = node2;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!node2)</span><br><span class="line">                &#123;</span><br><span class="line">                    node-&gt;next = node1;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node2-&gt;val &lt;= node1-&gt;val)</span><br><span class="line">                    &#123;</span><br><span class="line">                        node-&gt;next = node2;</span><br><span class="line">                        node = node-&gt;next;</span><br><span class="line"></span><br><span class="line">                        node2 = node2-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        node-&gt;next = node1;</span><br><span class="line">                        node = node-&gt;next;</span><br><span class="line"></span><br><span class="line">                        node1 = node1-&gt;next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            ListNode* node1 = Merge(lists, left, mid);</span><br><span class="line">            ListNode* node2 = Merge(lists, mid, right);</span><br><span class="line">            ListNode* result = Merge(&#123; node1, node2 &#125;, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Merge(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这次改动去掉了所有的new 因为直接复用已有的ListNode即可 同时在<code>node1</code>或<code>node2</code>为空的时候 直接append 避免额外的扫描</p><p>从<code>Time-33%</code>变化到了<code>Time-67%</code>  </p><h2 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 合并两个有序链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* p1, ListNode* p2)</span></span>&#123; <span class="comment">// 合并</span></span><br><span class="line">        <span class="keyword">if</span>(!p1) <span class="keyword">return</span> p2;</span><br><span class="line">        <span class="keyword">if</span>(!p2) <span class="keyword">return</span> p1;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val &lt;= p2-&gt;val)&#123;</span><br><span class="line">            p1-&gt;next = merge(p1-&gt;next, p2);</span><br><span class="line">            <span class="keyword">return</span> p1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p2-&gt;next = merge(p1, p2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> p2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123; <span class="comment">// 负责拆分和合并</span></span><br><span class="line">        <span class="keyword">if</span>(start == <span class="built_in">end</span>) <span class="keyword">return</span> lists[start];</span><br><span class="line">        <span class="keyword">int</span> mid = (start + <span class="built_in">end</span>) / <span class="number">2</span>;</span><br><span class="line">        ListNode* l1 = merge(lists, start, mid);</span><br><span class="line">        ListNode* l2 = merge(lists, mid+<span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">        <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这代码太精简了…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;合并K个升序链表&quot;&gt;&lt;a href=&quot;#合并K个升序链表&quot; class=&quot;headerlink&quot; title=&quot;合并K个升序链表&quot;&gt;&lt;/a&gt;合并K个升序链表&lt;/h1&gt;&lt;p&gt;给你一个链表数组，每个链表都已经按升序排列。&lt;/p&gt;
&lt;p&gt;请你将所有链表合并到一个升序链表
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="递归分治" scheme="http://blog.lsmg.xyz/tags/%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>力扣11.25-N34.在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="http://blog.lsmg.xyz/2020/11/%E5%8A%9B%E6%89%A311.25-N34.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <id>http://blog.lsmg.xyz/2020/11/%E5%8A%9B%E6%89%A311.25-N34.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</id>
    <published>2020-11-25T10:50:02.000Z</published>
    <updated>2020-12-03T04:39:21.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="N34-在排序数组中查找元素的第一个和最后一个位置"><a href="#N34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="N34.在排序数组中查找元素的第一个和最后一个位置"></a>N34.在排序数组中查找元素的第一个和最后一个位置</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sub = (right + left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[sub])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l_sub, r_sub;</span><br><span class="line">                <span class="keyword">for</span> (l_sub = sub - <span class="number">1</span>; l_sub &gt;=<span class="number">0</span> &amp;&amp; nums[l_sub] == target; --l_sub)</span><br><span class="line">                &#123;</span><br><span class="line">                   </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (r_sub = sub + <span class="number">1</span>; r_sub &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[r_sub] == target; ++r_sub)</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> &#123;l_sub + <span class="number">1</span>, r_sub - <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[sub])</span><br><span class="line">            &#123;</span><br><span class="line">                right = sub;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = sub + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路使用二分搜索找到目标元素 然后想左右扩散寻找边界</p><h1 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I</h1><p>统计一个数字在排序数组中出现的次数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sub = (right + left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[sub])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l_sub = sub - <span class="number">1</span>; l_sub &gt;=<span class="number">0</span> &amp;&amp; nums[l_sub] == target; --l_sub)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++result;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r_sub = sub + <span class="number">1</span>; r_sub &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[r_sub] == target; ++r_sub)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++result;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[sub])</span><br><span class="line">            &#123;</span><br><span class="line">                right = sub;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = sub + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路同上, 返回值不同</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;N34-在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;a href=&quot;#N34-在排序数组中查找元素的第一个和最后一个位置&quot; class=&quot;headerlink&quot; title=&quot;N34.在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;/a&gt;N34.在排序数组中查
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="递归分治" scheme="http://blog.lsmg.xyz/tags/%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>力扣11.24-N3.无重复字符的最长子串</title>
    <link href="http://blog.lsmg.xyz/2020/11/%E5%8A%9B%E6%89%A311.24-N3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://blog.lsmg.xyz/2020/11/%E5%8A%9B%E6%89%A311.24-N3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2020-11-24T10:50:02.000Z</published>
    <updated>2020-12-03T04:39:02.436Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> char_flag[<span class="number">128</span>]; <span class="comment">// 记录字符是否出现过</span></span><br><span class="line">    <span class="keyword">int</span> char_sub[<span class="number">128</span>]; <span class="comment">// 记录字符下标</span></span><br><span class="line">    <span class="built_in">memset</span>(char_flag, <span class="literal">false</span>, <span class="keyword">sizeof</span> char_flag);</span><br><span class="line">    <span class="keyword">int</span> max_result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> begin_sub = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sub = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sub &lt; s.length())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> current_char = s[sub];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (char_flag[current_char])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sub - begin_sub &gt; max_result)</span><br><span class="line">            &#123;</span><br><span class="line">                max_result = sub - begin_sub;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = begin_sub; i &lt; char_sub[current_char]; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                char_flag[s[i]] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            begin_sub = char_sub[current_char] + <span class="number">1</span>;</span><br><span class="line">            char_sub[current_char] = sub;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            char_sub[current_char] = sub;</span><br><span class="line">            char_flag[current_char] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sub++;</span><br><span class="line">        <span class="keyword">if</span> (sub == s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sub - begin_sub &gt; max_result)</span><br><span class="line">            &#123;</span><br><span class="line">                max_result = sub - begin_sub;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路是按顺序读取char, 如果没有出现过则标记出现记录下标.</p><p>如果出现了则用当前下标减去开始下标判断是否更长来记录, 同时更新开始下标为重复字符的下标后一个字符下标.</p><p>移动开始下标后 需要取消 新开始标记和旧开始标记之前的char标记</p><h1 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> heap[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            heap[s[j]]++; <span class="comment">// 标记字符出现</span></span><br><span class="line">            <span class="keyword">while</span>(heap[s[j]] &gt; <span class="number">1</span>) <span class="comment">// 再次出现</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">              开始符号标记下标 向前滑动 1 将开始下标的字符滑动出去</span></span><br><span class="line"><span class="comment">              如果滑出去的字符是本次遇到的重复字符 则继续 否则一直滑动到重复字符位置</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">                heap[s[i]]--;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先看上去 代码就非常的短 我的写了40行而这个仅有10行</p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p>我的虽然不是一次滑动一个字符 而是滑动一步到位. 但是仍需要一个for循环来去掉滑出的字符. 所以同样例代码思想.</p><p>所以没有必要一次滑动到位, 反正for循环需要执行就在for之中慢慢滑动. <code>这样可以省去记录字符出现的下标</code></p><p>我字符出现记录使用的bool数组然而使用<code>int数组却能包含更多的信息</code>.</p><p>我原版代码需要额外判定一次是否到了尾部, 当最后一个字符没有重复的时候 循环就结束了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="递归分治" scheme="http://blog.lsmg.xyz/tags/%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>HTTP框架底层原理实现</title>
    <link href="http://blog.lsmg.xyz/2020/11/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-HTTP%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.lsmg.xyz/2020/11/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-HTTP%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</id>
    <published>2020-11-01T14:45:39.000Z</published>
    <updated>2020-11-07T07:12:14.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>后端组使用各种框架</p><ul><li>Java的Springboot</li><li>Python的Django</li></ul><p>框架的底层原理是什么? 当然涉及原理性的东西太多了, 我这里指的是为什么客户端的几次简单点击 最终会转化成了后端的函数调用?</p><p>Springboot针对某一个URL能Get Post等等设置对应的方法. 还能得到指定的参数?</p><p>客户端的几下简单的点击就能够将数据传送到后端 从后端拿回数据然后进行显示</p><p>后端也只要在相关的函数后处理接收到的数据</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>要解释上面的问题需要用到计算机学院几门专业课的只是 &lt;操作系统&gt; &lt;计算机组成原理 跳过&gt; &lt;计算机网络&gt;</p><p>基础知识我要不要学? HTTP协议? DNS怎么发挥的作用?</p><p>GET POST 有什么区别? 为什么GET有参数长度限制(自己本以为是RFC规定 然而是浏览器规定的而且是URL长度限制而不是参数限制) 而POST没有参数长度限制<br>新了解到了</p><p>无法访问网页怎么办? 可以根据浏览器访问流程进行排查</p><p>校园网断网跳转怎么实现的? DNS污染又是什么? <em>返回错误的IP</em></p><p>favicon? 如何实现的自动加载 <em>GET /favicon.ico HTTP/1.1</em></p><p>抓包的原理</p><h1 id="浏览器访问流程"><a href="#浏览器访问流程" class="headerlink" title="浏览器访问流程"></a>浏览器访问流程</h1><p>当你输入一个网址, 按下回车后 首先会向DNS服务器发送DNS请求将域名转换成IP. <em>DNS污染</em></p><p>然后向 IP+端口号 <strong>建立连接 强调!</strong> 发送HTTP请求 (HTTP默认是80端口) 接收HTTP回应 进行解析HTML 然后请求相关的JS文件等</p><p>然而收发HTTP并不是 操作系统提供的基础API的功能 那是怎么来的?</p><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>协议是什么?</p><p>文本协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">GET  HTTP&#x2F;1.1</span><br><span class="line">Host: 10.2.5.251</span><br><span class="line">Connection: keep-alive</span><br><span class="line">DNT: 1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.183 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">DNT: 1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.183 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Sec-Fetch-Site: none</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class="line">Cookie: BIDUPSID&#x3D;275AD930CBDC20F9C9E074230710B72E; PSTM&#x3D;1602485007; BAIDUID&#x3D;93E8E77E51A5F22CA01131559BA8666A:FG&#x3D;1; BD_UPN&#x3D;12314753; BDUSS&#x3D;BjRVJYdFQ5TEJKWWNPck1ZcWdOVklMT0JHMHhQMUx3UGxDZjhNMVVhRmdqcXRmSVFBQUFBJCQAAAAAAAAAAAEAAADZQdlRcmpkNjc0NDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGABhF9gAYRfM3; BDUSS_BFESS&#x3D;BjRVJYdFQ5TEJKWWNPck1ZcWdOVklMT0JHMHhQMUx3UGxDZjhNMVVhRmdqcXRmSVFBQUFBJCQAAAAAAAAAAAEAAADZQdlRcmpkNjc0NDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGABhF9gAYRfM3; BAIDUID_BFESS&#x3D;F500721F63FBCA4EDC7DA170AE314FEE:FG&#x3D;1; BDORZ&#x3D;B490B5EBF6F3CD402E515D22BCDA1598; COOKIE_SESSION&#x3D;332523_0_8_0_3_6_1_0_7_4_42_0_332523_0_6_0_1604291277_0_1604291271%7C8%230_0_1604291271%7C1; sug&#x3D;3; sugstore&#x3D;0; ORIGIN&#x3D;0; bdime&#x3D;0; ZD_ENTRY&#x3D;google</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST http:&#x2F;&#x2F;202.119.196.6:8080&#x2F;Self&#x2F;login&#x2F;verify HTTP&#x2F;1.1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Origin: http:&#x2F;&#x2F;202.119.196.6:8080</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">DNT: 1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.111 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Referer: http:&#x2F;&#x2F;202.119.196.6:8080&#x2F;Self&#x2F;login&#x2F;?302&#x3D;LI</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class="line">Host: 202.119.196.6:8080</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Content-Length: 60</span><br><span class="line">Cookie: JSESSIONID&#x3D;E56420ED06E0ABE922C5A904DBB9C944</span><br><span class="line"></span><br><span class="line">foo&#x3D;&amp;bar&#x3D;&amp;checkcode&#x3D;1234&amp;account&#x3D;08180000&amp;password&#x3D;md5&amp;code&#x3D;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Sat, 31 Dec 2005 23:59:59 GMT</span><br><span class="line">Content-Type: text&#x2F;html;charset&#x3D;ISO-8859-1</span><br><span class="line">Content-Length: 122</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Wrox Homepage&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- body goes here --&gt;</span><br><span class="line">HTTP&#x2F;1.1 200 OK Date: Sat</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>根据这个格式<em>描述一下格式</em> 请求方法 请求路径 HTTP版本</p><p>HEADER部分 需要什么HEADER加入什么</p><p>BODY部分 放入数据</p><p>所根据的这个格式 这个规定就叫做协议 HTTP的规定就是HTTP协议</p><p>所以说你在手机上查询电费也好 电脑上浏览网页也罢 前端调用后端也是如此 只要是HTTP的API 都会将数据按照这个格式进行打包</p><ol><li><strong>建立连接后</strong>   Fiddler监听拦截的数据, 你知道了这个包的数据都有什么 然后自己建立连接发送同样的包 效果是一样的</li><li>发送打包的数据 </li><li>接收服务器返回的结果</li><li>所以可以抓包后模拟请求这就这么来的</li></ol><h1 id="从TCP看HTTP"><a href="#从TCP看HTTP" class="headerlink" title="从TCP看HTTP"></a>从TCP看HTTP</h1><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E4%B8%83%E5%B1%82%E5%92%8C%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE.png" alt=""></p><p><em>将根据这张图说一说, 经常让了解的 七层和四层协议.  (网络访问(链接)层)</em></p><p>上边面说的建立连接建立的实际是TCP连接</p><p>TCP连接是通过 IP和端口号建立的 正好使用的上面的IP和端口号</p><p>TCP连接干什么?  连接就是传输数据 这就涉及到了读写操作  全双工</p><p>两个套接字之间的通信 客户端持有一个套接字 服务器持有一个套接字 然后客户端的数据发送和服务器端的数据接收就是转化为了针对套接字的读写</p><p>套接字你可以理解为 两个电话互相通话</p><p>套接字的建立和管理都比较复杂, 但是流程极为固定 干脆将这些代码包装起来 对外界提供一个简单的函数即可 内部帮你管理建立TCP连接</p><p>客户端指的就是你的浏览器也好, 你的应用也好 套接字这个核心的东西被包装了起来</p><p>所以输入网址也好, 使用form标签也罢. 最终都是根据HTTP协议包装你想要发送或者接受的数据. 建立TCP连接 然后将包装好的数据发送到套接字 对方从套接字接受 (流, 流水 按顺序流入)</p><p><em>nc 命令 演示演示?</em></p><p>所以你可以没有域名 照样可以使用HTTP协议 照样访问网页.</p><p>因为HTTP交互的核心就是 根据HTTP协议包装数据 经由TCP连接收发数据 TCP连接使用的是 IP和端口号 而非域名</p><p>域名就没有用了吗? 除了便于记忆? <em>域名 区分作用</em></p><h1 id="HTTP框架"><a href="#HTTP框架" class="headerlink" title="HTTP框架"></a>HTTP框架</h1><p>上面说了HTTP交互细节. 本质就是的收发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;api?a&#x3D;1&amp;b&#x3D;2 HTTP&#x2F;1.1</span><br><span class="line">Host: 10.2.5.251</span><br><span class="line">Connection: keep-alive</span><br><span class="line">DNT: 1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.183 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Sat, 31 Dec 2005 23:59:59 GMT</span><br><span class="line">Content-Type: text&#x2F;html;charset&#x3D;ISO-8859-1</span><br><span class="line">Content-Length: 122</span><br><span class="line"></span><br><span class="line">＜html＞</span><br><span class="line">＜head＞</span><br><span class="line">＜title＞Wrox Homepage＜&#x2F;title＞</span><br><span class="line">＜&#x2F;head＞</span><br><span class="line">＜body＞</span><br><span class="line">＜!-- body goes here --＞</span><br><span class="line">＜&#x2F;body＞</span><br><span class="line">＜&#x2F;html＞</span><br></pre></td></tr></table></figure><p>服务器端从套接字 接收到数据后 大家没有见过上面的东西吧</p><p>那就是框架接受之后 把它们作为字符串存了起来 然后按照HTTP的固定协议格式 将内容解析</p><p>必须解析的一般有 Get /api?a=1&amp;b=2  然后得知了这是一个GET请求 请求的URL是 /api 有两个参数 叫什么 值是多少</p><p>然后根据你服务器代码设定的找到一个对应的函数, 框架调用这个函数 传入参数 你就可以处理相应的逻辑了.</p><h1 id="库和框架"><a href="#库和框架" class="headerlink" title="库和框架?"></a>库和框架?</h1><p>库是帮你提供某些功能的包装, 单个库一般并不能开发完整的应用, 只是作为一部分功能函数. curl库 线程库</p><p>框架可以理解为库的升级版, 你使用一个框架提供的函数 就能开发完整的应用, 大多数框架还能方便的引入其他的库来供自己使用.</p><h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx?"></a>nginx?</h1><p>nginx大家用过没有?</p><p>一般逻辑都是设置一个域名 然后指向一个端口 是不是?</p><p>域名这个东西就藏在了HTTPRequest的 header里 他同样从TCP连接接收数据 解析 便知道了域名 然后根据配置转发即可</p><h1 id="要不要学基础知识"><a href="#要不要学基础知识" class="headerlink" title="要不要学基础知识?"></a>要不要学基础知识?</h1><p>端口 计算机网络 组装nas计网</p><p>网线到内核 操作系统和计算机组成原理</p><h1 id="自学能力"><a href="#自学能力" class="headerlink" title="自学能力"></a>自学能力</h1><p>我大一来的工作室 来的时候是远爷带我学的JavaWeb. </p><p>随便找了本Java书给划一下看哪里</p><p>给我指明了一个框架, 然后呢? 去学呗</p><p>百度-&gt;谷歌中文-&gt;谷歌英文 <a href="https://translate.google.cn/" target="_blank" rel="noopener">https://translate.google.cn/</a></p><p>知乎 百度 谷歌 Github StackOverflow 等等</p><p>遇到问题先百度</p><ul><li>视频?</li><li>看书?</li><li>文档?</li></ul><p>大二转LinuxC++ 全部都是从零开始 没有人带我</p><h1 id="大学生"><a href="#大学生" class="headerlink" title="大学生"></a>大学生</h1><p>垃圾xxxA4 我就是不想学.</p><p>写博客?</p><p>人外有人天外有天</p><p>让自己一天比一天更加优秀 提升自己</p><p>平衡自己时间  爆肝程序<br>社交 我用大二上的社交换到了Linux入门 我退出了xxxx</p><p>大三上减肥(身高), 参加活动, 锻炼身体, 找对象? 规律作息</p><p>穿搭</p><p>多多质疑 乳酸菌饮料?</p><p>不要被轻易带节奏 12:55秒 <a href="https://www.bilibili.com/video/BV1jV411o7VV" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1jV411o7VV</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; title=&quot;框架&quot;&gt;&lt;/a&gt;框架&lt;/h1&gt;&lt;p&gt;后端组使用各种框架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java的Springboot&lt;/li&gt;
&lt;li&gt;Python的Django&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
    
      <category term="分享会" scheme="http://blog.lsmg.xyz/categories/%E5%88%86%E4%BA%AB%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>远程连接宿舍电脑</title>
    <link href="http://blog.lsmg.xyz/2020/10/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%AE%BF%E8%88%8D%E7%94%B5%E8%84%91/"/>
    <id>http://blog.lsmg.xyz/2020/10/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%AE%BF%E8%88%8D%E7%94%B5%E8%84%91/</id>
    <published>2020-10-29T08:40:39.000Z</published>
    <updated>2020-10-28T09:16:59.234Z</updated>
    
    <content type="html"><![CDATA[<p>学校机房电脑配置低? 卡慢?</p><p>学习机房电脑没有自己电脑环境用着顺手?</p><p>你还在担心使用机房电脑后需要拷贝代码到U盘或者QQ吗?</p><p><del>机房电脑玩大型游戏?</del></p><p>使用远程连接吧!</p><h1 id="向日葵等"><a href="#向日葵等" class="headerlink" title="向日葵等"></a>向日葵等</h1><p>优点: 不需要公网IP就能使用, 安装使用非常方便<br>缺点: 由于数据交互经过了向日葵的服务器导致延迟较高?</p><h1 id="Win10自带远程连接"><a href="#Win10自带远程连接" class="headerlink" title="Win10自带远程连接"></a>Win10自带远程连接</h1><p>优点: 内网使用延迟极低, 就像直接操作远在其他地方的笔记本一样<br>缺点: 需要内网使用, 配置较为繁琐.</p><p>针对内网这一问题, 学校机房, 学校stuwifi, 宿舍网线都是同一内网(得益于三网通一, 没想到这货还有这样的好处), 所以最大的问题解决了.</p><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>必须确保电脑为专业版  最好是正版专业版盗版可能会有账户配置等问题 自行查阅.</p><p>任务栏左下角Win10图标右击, 打开设置 –&gt; 更新和安全 –&gt; 选择激活  确保显示的为专业版<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E4%B8%93%E4%B8%9A%E7%89%88.png" alt=""></p><p>可惜大部分笔记本都是家庭版, 我这里只推荐一种方法家庭版升级专业版. 其他方法自行百度尝试</p><p>去淘宝购买<strong>家庭版升级专业版Win10密钥</strong>注意不是简单的专业版就行了必须写着<strong>升级</strong>, 详细咨询客服吧</p><p>大概15软妹币左右即可拥有正版Win10专业版, 而且不需要重装系统C盘不会动.</p><p>购买密钥后 在更新和安全的激活那里选择<strong>更改产品密钥</strong> 输入确认即可.</p><h2 id="自己电脑开启远程连接"><a href="#自己电脑开启远程连接" class="headerlink" title="自己电脑开启远程连接"></a>自己电脑开启远程连接</h2><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.png" alt=""></p><p>桌面我的电脑(此电脑) 右击选择属性-&gt;远程设置-&gt;勾选图示三个对勾.</p><h2 id="确认电脑IP"><a href="#确认电脑IP" class="headerlink" title="确认电脑IP"></a>确认电脑IP</h2><p>cmd输入ipconfig记录好自己的IPV4地址和IPV6地址 IPV6不要记录临时地址</p><p>IPV6地址永远不会变,  且<strong>无论电脑是否登录都能使用</strong>, 但是机房电脑没有IPV6</p><p>IPV4地址可能会改变, 需要<strong>10.2.5.251电脑登录后</strong>才能使用 推荐设置静态IPV4地址或者每次使用记录下IPV4</p><h2 id="机房电脑设置"><a href="#机房电脑设置" class="headerlink" title="机房电脑设置"></a>机房电脑设置</h2><p>机房电脑任务栏左下角的Win10图标右侧的搜索(放大镜标志) –&gt; 输入<strong>远程</strong>二字-&gt;选择弹出来的<strong>远程桌面连接</strong>-&gt;输入<strong>IPV4</strong>地址</p><p>确保宿舍电脑联网的情况下 点击连接就提示让你输入账号密码.  账号和密码是你Win10账户的账号和密码. 输入账号密码就连接成功了.</p><h2 id="其他建议选项"><a href="#其他建议选项" class="headerlink" title="其他建议选项"></a>其他建议选项</h2><ol><li>宿舍建议直插网线, 宿舍电脑使用Wifi可能有延迟感觉</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学校机房电脑配置低? 卡慢?&lt;/p&gt;
&lt;p&gt;学习机房电脑没有自己电脑环境用着顺手?&lt;/p&gt;
&lt;p&gt;你还在担心使用机房电脑后需要拷贝代码到U盘或者QQ吗?&lt;/p&gt;
&lt;p&gt;&lt;del&gt;机房电脑玩大型游戏?&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;使用远程连接吧!&lt;/p&gt;
&lt;h1 id=&quot;向日葵
      
    
    </summary>
    
    
      <category term="分享会" scheme="http://blog.lsmg.xyz/categories/%E5%88%86%E4%BA%AB%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>蓝图与C++交互</title>
    <link href="http://blog.lsmg.xyz/2020/10/UE4-%E8%93%9D%E5%9B%BEC++%E4%BA%A4%E4%BA%92/"/>
    <id>http://blog.lsmg.xyz/2020/10/UE4-%E8%93%9D%E5%9B%BEC++%E4%BA%A4%E4%BA%92/</id>
    <published>2020-10-11T12:31:22.000Z</published>
    <updated>2020-10-11T13:55:41.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蓝图Widget与C-代码交互-反射"><a href="#蓝图Widget与C-代码交互-反射" class="headerlink" title="蓝图Widget与C++代码交互-反射"></a>蓝图Widget与C++代码交互-反射</h1><ol><li>创建UserWidget的C++子类 MyUserWidget<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于初始化</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Initialize</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">// 绑定到按钮的点击事件</span></span><br><span class="line">UFUNCTION() <span class="comment">// 必须加不然会导致无反应 日志报错</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ButtonLoginEvent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射获取实例 需要名称保持一致</span></span><br><span class="line">UPROPERTY(Meta = (BindWidget))</span><br><span class="line">UButton* ButtonLogin;</span><br><span class="line">UPROPERTY(Meta = (BindWidget))</span><br><span class="line">UTextBlock* TextBlockUsername; <span class="comment">// 一个文本框</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UMyUserWidget::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Super::Initialize()) <span class="comment">// 会报错提示不存在 无影响</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行点击函数绑定</span></span><br><span class="line">    ButtonLogin-&gt;OnClicked.__Internal_AddDynamic(<span class="keyword">this</span>, &amp;UMyUserWidget::ButtonLoginEvent, FName(<span class="string">"ButtonLoginEvent"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并显示 文本框文字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyUserWidget::ButtonLoginEvent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (GEngine)</span><br><span class="line">    &#123;</span><br><span class="line">        FString Username = TextBlockUsername-&gt;GetText().ToString();</span><br><span class="line"></span><br><span class="line">        GEngine-&gt;AddOnScreenDebugMessage(<span class="number">-1</span>, <span class="number">20</span>, FColor::Yellow, Username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>创建需要绑定的蓝图NewWidgetBlueprint</li><li>打开蓝图后点击File-&gt;Reparent Blueprint选择MyUserWidget作为父类</li><li>添加名为ButtonLogin的按钮和TextBlockUsername的文本框 用于反射</li><li>创建HUD的C++子类MyHud</li><li>创建MyHud的蓝图BP_MuHud</li><li>将MyHud的蓝图设置为 GameMode的HUDClass, 这样启动的时候就能创建MuHud蓝图的实例<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从BP_MuHud中选择 NewWidgetBlueprint蓝图</span></span><br><span class="line">UPROPERTY(EditAnywhere, Category = <span class="string">"UserWidget"</span>)</span><br><span class="line">TSubclassOf&lt;<span class="class"><span class="keyword">class</span> <span class="title">UMUserWidget</span>&gt; <span class="title">WidgetClass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动时创建蓝图实例并显示 设置输入方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyHUD::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::BeginPlay();</span><br><span class="line"></span><br><span class="line">    UUserWidget* Widget = CreateWidget&lt;UMyUserWidget&gt;(GetWorld(), WidgetClass);</span><br><span class="line">    <span class="keyword">if</span> (Widget != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Widget-&gt;AddToViewport();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    APlayerController* MyPlayerController = Cast&lt;APlayerController&gt;(UGameplayStatics::GetPlayerController(GetWorld(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入只对UI</span></span><br><span class="line">    <span class="keyword">if</span> (MyPlayerController != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MyPlayerController-&gt;bShowMouseCursor = <span class="literal">true</span>;</span><br><span class="line">        FInputModeUIOnly InputMode;</span><br><span class="line">        MyPlayerController-&gt;SetInputMode(InputMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;蓝图Widget与C-代码交互-反射&quot;&gt;&lt;a href=&quot;#蓝图Widget与C-代码交互-反射&quot; class=&quot;headerlink&quot; title=&quot;蓝图Widget与C++代码交互-反射&quot;&gt;&lt;/a&gt;蓝图Widget与C++代码交互-反射&lt;/h1&gt;&lt;ol&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="UE4" scheme="http://blog.lsmg.xyz/categories/UE4/"/>
    
    
      <category term="蓝图与C++交互" scheme="http://blog.lsmg.xyz/tags/%E8%93%9D%E5%9B%BE%E4%B8%8EC-%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>UNP记录</title>
    <link href="http://blog.lsmg.xyz/2020/10/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95150-UNP/"/>
    <id>http://blog.lsmg.xyz/2020/10/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95150-UNP/</id>
    <published>2020-10-06T04:17:39.000Z</published>
    <updated>2020-10-31T07:41:43.077Z</updated>
    
    <content type="html"><![CDATA[<p>由于已经在Linux高性能服务器开发中详细说明过绝大部分系统函数</p><p>Linux高性能服务器开发的重叠部分, 我会将新的点补充到原博客中, 这里仅作部分简单的说明</p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>通过定义<code>包裹函数</code>可以缩短程序. 在muduo框架中就存在包裹函数 将系统函数进行包装</p><p>函数中进行错误处理, 这样外部使用<code>包裹函数</code>包装好的系统函数的时候可以简化错误处理</p><p><strong>daytimecpclient-domain.cpp</strong><br>第一个样例程序稍作修改 可以解析域名  inet_addr没有请求网络 速度快 而gethostbyname会请求域名<br>服务器速度可能慢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in server_addr&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> ((server_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>])) == INADDR_NONE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>* <span class="title">hostptr</span> = <span class="title">gethostbyname</span>(<span class="title">argv</span>[1]);</span></span><br><span class="line">    <span class="keyword">if</span> (!hostptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"invalid input %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    server_addr.sin_addr.s_addr = *((<span class="keyword">unsigned</span> <span class="keyword">long</span>*)hostptr-&gt;h_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代服务器: 对于每个客户连接都执行迭代一次<br>并发服务器: 同时处理多个客户连接</p><h1 id="第二章-传输层"><a href="#第二章-传输层" class="headerlink" title="第二章 传输层"></a>第二章 传输层</h1><p>客户端 主动调用close之后 发送了FIN包</p><p>服务端 接收到FIN包后read返回0</p><p>服务器 read返回0之后调用close函数 发送FIN包</p><p>客户端 接收服务器的FIN包</p><p><strong>@@35 P TCP状态转换图@@</strong></p><p><strong>@@36 P TCP状态转换和Socket函数间的联系@@</strong></p><p>多宿主计算机  可能插有多块网卡</p><p>通过bind到INADDR_ANY来监听多个接口的同一个端口</p><h1 id="第三章-套接字编程简介"><a href="#第三章-套接字编程简介" class="headerlink" title="第三章 套接字编程简介"></a>第三章 套接字编程简介</h1><p>大多数套接字函数 都需要一个指向<code>套接字地址结构</code>的指针作为参数. 每个协议簇都定义了他自己的<code>套接字地址结构</code>. 这些结构的名字均<code>以sockaddr_开头</code></p><p><strong>@@61 P 不同套接字地址结构的比较@@</strong></p><h1 id="第四章-基本TCP套接字编程"><a href="#第四章-基本TCP套接字编程" class="headerlink" title="第四章 基本TCP套接字编程"></a>第四章 基本TCP套接字编程</h1><p><strong>connect函数</strong></p><p>ETIMEDOUT: 客户端没有收到SYN的回应 尝试几次后如果依然没有收到回应则返回错误</p><p>ECONNREFUSED: 服务器在指定端口上没有进程等待与之连接导致收到了RST回复  之后立即返回错误</p><p>connect失败之后 此套接字无法继续使用 需要close当前套接字后重新调用socket</p><p><strong>bind函数</strong></p><p>如果调用listen或者connect前没有调用bind则操作系统会分配一个临时端口. 对于客户端来说可以接受临时端口, 然而服务器一般都是需要指定端口 供外接连接. </p><p>如果指定的端口为0 则认为没有指定端口 会分配临时端口. 如果地址指定为0(INADDR_ANY) 则系统选择IP地址</p><p>RPC服务器可以使用临时端口, 但必须将临时端口注册到端口映射器, 这样客户端才能得到对应的临时端口, 之后进行连接</p><p>可以使用getsockname获取到系统临时分配的地址和端口</p><p><strong>listen函数</strong></p><p>socket函数创建的套接字默认被认为是主动套接字(准备调用connect) 使用listen函数将一个<code>未连接</code>的套接字转换成一个被动套接字</p><p>内核为一个监听的系统套接字维护两个队列</p><ul><li>未完成队列 已经收到了SYN但还未完成三次握手</li><li>已完成队列 已经进行了三次握手<code>等待accept从队列中取走</code> 已建立的连接 如果<code>此队列为空, accept阻塞</code></li></ul><p>未完成队列+已完成队列的总长度 即为listen函数的第二个参数backlog</p><p>connect函数调用 -&gt; 服务器收到了SYN包 -&gt; 在未完成队列创建相关内容 -&gt; 创建完毕后返回SYN和ACK -&gt; 客户端返回ACK -&gt; 从未完成队列移动到已完成队列队尾</p><p><a href="https://blog.csdn.net/yangbodong22011/article/details/60399728" target="_blank" rel="noopener">https://blog.csdn.net/yangbodong22011/article/details/60399728</a></p><p>实际用Centos(内核为4.18版本)测试后, 实际情况为上方博客的情况. 即backlog是已完成队列大小, 而且会存在+1</p><p>看到这里后想到之前遇到的一个BUG, 注册入<code>epollfd</code>中的<code>listenfd</code>没有设置成<code>ENONBLOCK</code>, <code>epoll_wait不会返回, 进而去调用accept</code>, 然而客户端<code>connect</code>函数返回显示已经建立连接.  –也就是connect返回说明连接建立, 发生在accpet函数调用前.</p><p>当客户端发送FIN后服务器read类函数返回0</p><p><strong>@@91 P exec函数之间的关系@@</strong></p><p><strong>accept函数</strong><br>accpet函数的第一个参数必须是 被动套接字 即调用过listen, 否则返回EINVAL错误</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p>正常启动 正常终止时程序的表现与TCP协议的关系</p><p>慢系统调用: 适用于那些可能永远阻塞的系统调用, accpet(没有新连接就一直阻塞), read(读取不到一直阻塞)等等.</p><p>EINTR: 当阻塞于某个慢系统调用的进程, 捕获某个信号且相应信号处理函数返回时, 慢系统调用<code>可能</code>返回一个EINTR错误</p><p>诸如read, write, select等来说可以忽略EINTR, 如下方这个常见的代码片段. <strong>但是connect则不行, 否则立即返回错误??</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> result = <span class="built_in">read</span>(fd, <span class="built_in">buffer</span>, <span class="keyword">sizeof</span> <span class="built_in">buffer</span>);</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同时有N个SIGCHLD信号到达, 信号处理函数极可能执行不够N次.</p><ul><li>UNIX信号没有排队概念</li><li>问题导致的结果不确定, 即不确定调用多少次</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">int</span> stat;</span><br><span class="line">  <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">process</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用waitpid来获取所有已终止进程状态, 并且指定了<code>WNOHANG</code>防止不必要的阻塞.</p><p>而wait则不能在这里替换waitpid, 因为wait只能阻塞</p><p><strong>第五章 正常启动 正常终止 accept返回前终止 服务器进程终止 服务主机崩溃 主机崩溃后重启 主机关机</strong></p><h1 id="第六章-I-O-复用-select和poll函数"><a href="#第六章-I-O-复用-select和poll函数" class="headerlink" title="第六章 I/O 复用 select和poll函数"></a>第六章 I/O 复用 select和poll函数</h1><p>进程需要一种预先告知内核的能力, 使得内核一旦发现进程指定的一个或多个I/O条件就绪, 他就通知进程. –IO复用</p><p>UNIX可用的五种IO模型</p><ul><li>阻塞式I/O</li><li>非阻塞式I/O</li><li>I/O复用</li><li>信号驱动式I/O(SIGIO)</li><li>异步I/O(POSIX的aio_系列函数)</li></ul><p>前四种都是同步IO, 因为他们在真正的IO阶段read,readfrom等导致了阻塞<br>只有异步IO模型才是异步IO</p><p><strong>@@低水位标记 ?@@</strong></p><h2 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h2><p>尽管timeval允许指定一个微秒级的分辨率, 但是真实的分辨率吗…… 部分实现的粗糙一些. 并且还有<code>调度延迟(定时器结束后, 内核还需要花时间调度相应进程运行)</code></p><p>struct fd_set 一个集合,可以存储多个文件描述符<br>内部是一个32位整数的数组, 数组第一个元素对应0<del>31描述符 一个二进制位代表一个描述符<br>数组第二个元素对应32</del>63 以此类推</p><p>可读条件</p><ul><li>socket内核接收缓存区中的字节数大于或等于 其低水位标记</li><li>socket通信的对方关闭连接 读半连接关闭, 对socket的读操作返回0</li><li>监听socket上有新的连接请求</li><li>socket上有未处理的错误, 可以使用getsockopt的SO_ERROR来读取和清除错误 套接字的读操作不阻塞 并返回-1</li></ul><p>可写条件</p><ul><li>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记, <strong>且套接字已经连接, 或套接字不需要连接UDP</strong></li><li>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</li><li>socket使用非阻塞connect 连接成功或失败后</li><li>socket上有未处理的错误 套接字的写操作不阻塞 并返回-1</li></ul><p>异常条件</p><ul><li>发送带外数据</li></ul><p>当select返回可读事件后 如果不进行处理 则下次select调用会继续返回</p><h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><ol><li>close会将引用计数-1 等到为0时才关闭套接字. shutdown则可以无视此, 激发TCP的正常连接终止序列</li><li>close会终止读和写两个方向的数据传送, 但由于TCP全双工有时需要告知对方我方发送已经完毕</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于已经在Linux高性能服务器开发中详细说明过绝大部分系统函数&lt;/p&gt;
&lt;p&gt;Linux高性能服务器开发的重叠部分, 我会将新的点补充到原博客中, 这里仅作部分简单的说明&lt;/p&gt;
&lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>深度探索C++对象模型</title>
    <link href="http://blog.lsmg.xyz/2020/09/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95130-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    <id>http://blog.lsmg.xyz/2020/09/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95130-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-09-15T07:17:39.000Z</published>
    <updated>2020-11-26T09:33:09.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-关于对象"><a href="#第一章-关于对象" class="headerlink" title="第一章 关于对象"></a>第一章 关于对象</h1><p>加上封装之后的成本增加了吗?</p><p>并没有增加成本, C++在布局以及存取时间上主要的额外负担是由virtual引起的</p><ul><li>virtual func机制 用来支持一个有效率的执行期绑定</li><li>virtual base class 用来实现多次出现在继承体系中的base class, 有一个单一而被共享的实例</li></ul><p>C++ 有两种成员变量<code>static</code>和<code>nonstatic</code><br>三种成员函数<code>static</code>, <code>nonstatic</code>和<code>virtual</code></p><h1 id="第三章Data语义学"><a href="#第三章Data语义学" class="headerlink" title="第三章Data语义学"></a>第三章Data语义学</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo foo;</span><br></pre></td></tr></table></figure><p><code>sizeof foo = ?</code>答案是1， 这是为了防止不同的对象却有相同的地址</p><p>同时class也存在<code>字节对齐</code>现象</p><p>在针对虚拟继承问题的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D对象的内存结构  从低地址开始</span><br><span class="line"></span><br><span class="line">D对象数据部分  《- D类对象指针 dptr 指向这里 可以从vptr指向的表中获取A对象数据部分的偏移量 offset</span><br><span class="line">C对象数据部分</span><br><span class="line">B对象数据部分</span><br><span class="line">A对象数据部分  《- dptr + offset 则实现了 子类指针向父类指针的转化</span><br></pre></td></tr></table></figure><p>A 派生出 B C。 B C派生出D  如何保证在BC对象中都有A对象， 而在D对象中只有一个A对象？</p><p>一种方法是 </p><p>先安排派生类的部分 再后接基类的部分， 这样派生类D的对象指针就是指向自己数据部分的指针</p><p>如果想要实现子类向父类转换呢？</p><p>在vtpr指向的表中的 -1 位置放置偏移量， 由于D类对象的指针是内存开始位置 如果要转换成A类指针</p><p>则从D类对象的vptr指向的表中获取A类数据部分的偏移量 这样就实现了子类向父类转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;Foo::x = %p\n"</span>, &amp;Foo::x);  <span class="comment">// 0x0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;Foo::y = %p\n"</span>, &amp;Foo::y); <span class="comment">// 0x4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;Foo::z = %p\n"</span>, &amp;Foo::z); <span class="comment">// 0x8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果x， y， z定义为protected或者private则会报错。public得到的是其在类内的偏移地址</p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><p>name-mangling</p><p>不要将mangling之后的结果显示给用户看，这样用户会疑惑哪里来的这个函数（大体来说 我们采纳了他的建议）</p><p>static member func 并不是比 nonstatic member func效率高 后者也会转换成类似前者的调用。 </p><p>static member func的主要特征就是他没有<code>this指针</code> </p><ul><li>所以它不能存取nonstatic member </li><li>不能被声明为const 因为const成员函数最终转化成了 const修饰的this指针</li><li>不需要通过对象来调用， 因为他不需要this指针</li></ul><p>C++中多态表示以一个public base class的指针（或reference）寻址出一个derived class object。这样就实现了多态的函数调用机制</p><p>三目运算符搭配逗号运算符</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p>vptr的初始化发生在 base class constructor调用之后，程序员提供的代码之前</p><p>不要再vurtual base class中声明数据</p><p>vptr会随着构造函数从基类到子类的一层层调用被改变<br>同样 析构函数会逆操作 这个指针</p><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><p>一般情况下 程序的构造函数我们都知道他在那里调用。 然而，析构函数呢？答案是析构函数会在函数结束的时候被调用（针对局部对象）。所以析构函数的调用代码会被穿插入每一个return 前（对象被构造后的return 被构造前的则没有必要） 尽管某些return不会被调用</p><p>new运算符只有一个步骤？ 不不不 会被扩充为 1. 先分配内存 2. 设定初值</p><p>delete运算符 则会进行检测 delete nullptr 则不会有任何效果</p><p>针对对象使用new则会在分配内存后通过调用构造函数设定初始值， 而delete则会在检测nullptr后调用析构函数然后将内存归还</p><p>NRV优化</p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><p>template， exception handling（EH）， runtime type identification（RTTI， EH的副作用？）</p><p>模板类的错误发现 会直到被实例化的时候才会被发现 延迟了错误的发现时机</p><p>目前的编译器，面对一个template声明，在它被一组实际参数实例化之前，只能施行有限的错误检查。template中那些与语法无关的错误，程序员可能认为十分明显，编译器却让他通过了，只有在特定实例被定义之后，运行时。才会产生错误。</p><p>dynamic_cast 运算符可以在执行期间决定真正的类型。 如果downcast是安全的这个运算符会传回适当转换过的指针。如果是不安全的则返回0<br>dynamic_cast同样可以对引用进行操作，成功后返回转换后的引用，失败后只能抛出异常（因为没有办法像指针那样指定nullptr表示错误）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-关于对象&quot;&gt;&lt;a href=&quot;#第一章-关于对象&quot; class=&quot;headerlink&quot; title=&quot;第一章 关于对象&quot;&gt;&lt;/a&gt;第一章 关于对象&lt;/h1&gt;&lt;p&gt;加上封装之后的成本增加了吗?&lt;/p&gt;
&lt;p&gt;并没有增加成本, C++在布局以及存取时间上主要
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CPP入门分享</title>
    <link href="http://blog.lsmg.xyz/2020/09/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-%E6%8A%93%E5%8F%96%E6%8E%A5%E5%8F%A3/"/>
    <id>http://blog.lsmg.xyz/2020/09/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-%E6%8A%93%E5%8F%96%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-09-09T02:40:39.000Z</published>
    <updated>2020-10-28T08:55:57.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>Fiddler 截获HTTP请求包<br>Postman 测试接口与生成代码<br>Chrome+SwitchyOmega插件</p><p>安装见视频</p><h1 id="配置Fiddler"><a href="#配置Fiddler" class="headerlink" title="配置Fiddler"></a>配置Fiddler</h1><p>Tools-&gt;Options-&gt;HTTPS 勾选Decrypt HTTPS traffic 确认安装证书</p><p>Tools-&gt;Options-&gt;Connections 勾选Allow remote computer xxxx</p><p>记下 Connections中的端口号 默认为8888</p><h1 id="配置SwitchyOmega插件"><a href="#配置SwitchyOmega插件" class="headerlink" title="配置SwitchyOmega插件"></a>配置SwitchyOmega插件</h1><p>新增情景模式-&gt;选择代理服务器</p><p>代理协议HTTP 代理服务器 127.0.0.1 端口 8888</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h1&gt;&lt;p&gt;Fiddler 截获HTTP请求包&lt;br&gt;Postman 测试接口与生成代码&lt;br&gt;Chrome+SwitchyOmega插件&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="分享会" scheme="http://blog.lsmg.xyz/categories/%E5%88%86%E4%BA%AB%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>CPP入门分享</title>
    <link href="http://blog.lsmg.xyz/2020/08/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-cpp%E5%85%A5%E9%97%A8/"/>
    <id>http://blog.lsmg.xyz/2020/08/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-cpp%E5%85%A5%E9%97%A8/</id>
    <published>2020-08-28T02:40:39.000Z</published>
    <updated>2020-10-28T08:55:57.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h1><h2 id="为什么选择的是CPP"><a href="#为什么选择的是CPP" class="headerlink" title="为什么选择的是CPP"></a>为什么选择的是CPP</h2><p>学校开设</p><ul><li>Python</li><li>CPP</li><li>xxx</li></ul><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>课堂讲的肯定比我讲的要好 不过我打算侧重在更加详细的讲某些基础内容 然后主要的是每周的答疑maybe</p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>每周五六日中一天 以计算机专业的CPP课本进度 提前讲一部分下周的内容</p><p>下一周你遇到的问题的问题私聊我 下周五六日中一天直播的时候讲解</p><h2 id="独立解决问题的能力"><a href="#独立解决问题的能力" class="headerlink" title="独立解决问题的能力"></a>独立解决问题的能力</h2><p>善用搜索引擎<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%B4%A0%E8%B4%A8%E4%BA%94%E8%BF%9E.jpg" alt=""></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E7%99%BE%E5%BA%A6Or%E9%97%AE%E4%BA%BA.jpg" alt=""></p><p>当然也不是 所有都要自己找 不去问别人</p><p>当你一个问题考虑很久的时候 xxx</p><h2 id="编程难在哪里"><a href="#编程难在哪里" class="headerlink" title="编程难在哪里?"></a>编程难在哪里?</h2><p>什么是关键字?</p><p><a href="https://www.runoob.com/w3cnote/cpp-keyword-intro.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/cpp-keyword-intro.html</a></p><p><img src="https://www.runoob.com/wp-content/uploads/2018/06/20130806104900234.jpg" alt="C++关键字"></p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>if</td><td>else</td><td>while</td><td>for</td><td>switch</td><td>case</td></tr><tr><td>break</td><td>continue</td><td>return</td><td></td><td></td><td></td></tr><tr><td>int</td><td>short</td><td>char</td><td>double</td><td>long</td><td>float</td></tr><tr><td>const</td><td>static</td><td></td><td></td><td></td><td></td></tr><tr><td>delete</td><td>new</td><td></td><td></td><td></td><td></td></tr><tr><td>enum</td><td>struct</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>思想</p><p>有限的关键字 “无穷” 的组合</p><h2 id="分享-gt-私人QQ群"><a href="#分享-gt-私人QQ群" class="headerlink" title="分享-&gt;私人QQ群"></a>分享-&gt;私人QQ群</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一次&quot;&gt;&lt;a href=&quot;#第一次&quot; class=&quot;headerlink&quot; title=&quot;第一次&quot;&gt;&lt;/a&gt;第一次&lt;/h1&gt;&lt;h2 id=&quot;为什么选择的是CPP&quot;&gt;&lt;a href=&quot;#为什么选择的是CPP&quot; class=&quot;headerlink&quot; title=&quot;为
      
    
    </summary>
    
    
      <category term="分享会" scheme="http://blog.lsmg.xyz/categories/%E5%88%86%E4%BA%AB%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>EPOLLET丢失新连接事件</title>
    <link href="http://blog.lsmg.xyz/2020/08/%E9%87%87%E5%9D%91%E8%AE%B0-EPOLLET%E4%B8%A2%E5%A4%B1%E6%96%B0%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6/"/>
    <id>http://blog.lsmg.xyz/2020/08/%E9%87%87%E5%9D%91%E8%AE%B0-EPOLLET%E4%B8%A2%E5%A4%B1%E6%96%B0%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6/</id>
    <published>2020-08-03T15:03:08.000Z</published>
    <updated>2020-08-03T15:55:56.702Z</updated>
    
    <content type="html"><![CDATA[<p>谨以此文献给我, 两次踩坑.</p><p>第一次是根据muduo写我的mongo</p><p>第二次则是后来我又根据muduo写higan. <del>框架名字不是重点</del></p><h1 id="症状描述"><a href="#症状描述" class="headerlink" title="症状描述"></a>症状描述</h1><ol><li>最首先的症状就是使用ab压测的时候, 压测会在快结束的时候卡住 而且压测过程中也会出现卡顿<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\XXX&gt; ab -n 1000 -c 94 -k  http:&#x2F;&#x2F;10.4.160.96:1022&#x2F;hello</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 1874286 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http:&#x2F;&#x2F;www.zeustech.net&#x2F;</span><br><span class="line">Licensed to The Apache Software Foundation, http:&#x2F;&#x2F;www.apache.org&#x2F;</span><br><span class="line"></span><br><span class="line">Benchmarking 10.4.160.96 (be patient)</span><br><span class="line">Completed 100 requests</span><br><span class="line">Completed 200 requests</span><br><span class="line">Completed 300 requests</span><br><span class="line">Completed 400 requests</span><br><span class="line">Completed 500 requests</span><br><span class="line">Completed 600 requests</span><br><span class="line">Completed 700 requests</span><br><span class="line">Completed 800 requests</span><br><span class="line">Completed 900 requests</span><br><span class="line">apr_pollset_poll: The timeout specified has expired (70007)</span><br><span class="line">Total of 996 requests completed</span><br></pre></td></tr></table></figure></li><li>这时候已经建立的连接不受影响 却无法建立新的连接 debug的时候发现会出现建立已经关闭的连接</li><li>上面的问题发生与不发生 跟我是否开多线程有关, 如果我不建立额外的EventLoopThread就不会出现这个问题</li></ol><h1 id="第一波排查-线程之间互相影响"><a href="#第一波排查-线程之间互相影响" class="headerlink" title="第一波排查 线程之间互相影响"></a>第一波排查 线程之间互相影响</h1><p>因为问题出现与否 与我是否设置多线程有关, 我就开始排查线程之间的影响.<br>重点放在了muduo的RunInLoop函数. 因为这个函数我一直不是明白怎么回事.<br>最终根据muduo的设计思想 一个EventLoop对应一个Thread.<br>结合RunInLoop就可以达到谁的事件谁处理的效果</p><p>举个例子, 连接中断后, 子线程返回相应的事件 要去调用TcpServer的RemoveConnection将自己移除, 如果不使用RunInLoop<br>当有多个子线程 同时触发同样的事件 同时去对map进行删除操作 必然需要加锁. 况且连接连接的时候也要对map进行插入操作.<br>使用RunInLoop判断后得知是子线程在调用RunInLoop而非对应的线程, 就将任务存储到了相关的EventLoop中. 而EventLoop中存储的任务只有其所属的Thread才能处理.<br>所以实现了统一所有子线程的移除连接操作到了主线程中, 而连接的建立也是主线程操作, 最终避免了加锁.</p><p>然后那个swap命令处理任务度列减少加锁的时间也很赞</p><p>最终我加上了几处重要的RunInLoop, 不过并没有解决问题………….</p><h1 id="第二波排查-到底返回了多少事件"><a href="#第二波排查-到底返回了多少事件" class="headerlink" title="第二波排查 到底返回了多少事件?"></a>第二波排查 到底返回了多少事件?</h1><p>我在Acceptor等多个可读事件回调的位置加了计数器, 这时候最先发现的就是连接建立数量不对.</p><p>上边996个完成请求缺了4个, 并且正好连接建立了90个连接, 而非设置的并发94, 也是少了4个.</p><p>我先怀疑是否是ab压测的处理, 我试了下muduo多线程下94个连接 higan单线程94连接,多线程90连接, 排除了ab的问题</p><p>少的链接去了哪里? 我使用netstat命令发现 正好是四个CLOSE_WAIT 我去看了下ab的包正好是114字节 说明了少的四个链接的位置<br>而且这四个端口号正好是从本该是第91个连接的端口号开始的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@fish ~]# netstat -an | grep 1022</span><br><span class="line">tcp        4      0 0.0.0.0:1022            0.0.0.0:*               LISTEN     </span><br><span class="line">tcp      114      0 10.4.160.96:1022        10.4.160.95:8785        CLOSE_WAIT </span><br><span class="line">tcp      114      0 10.4.160.96:1022        10.4.160.95:8787        CLOSE_WAIT </span><br><span class="line">tcp      114      0 10.4.160.96:1022        10.4.160.95:8786        CLOSE_WAIT </span><br><span class="line">tcp      114      0 10.4.160.96:1022        10.4.160.95:8784        CLOSE_WAIT</span><br></pre></td></tr></table></figure><p>其实netstat不对劲早就发现了, 然而并不理解netstat命令 没有重视问题.</p><p>使用Man命令察看了 第二列是Recv-Q 对于CLOSE_WAIT来说是未接收的字节数 对于LISTEN则是未接收的连接数</p><h1 id="第三波排查-为什么这四个连接没有被接受"><a href="#第三波排查-为什么这四个连接没有被接受" class="headerlink" title="第三波排查 为什么这四个连接没有被接受"></a>第三波排查 为什么这四个连接没有被接受</h1><p>首先我发现了我这行代码写的有问题, 而我的epoll_events_是一个vector 后面的代码有扩容逻辑 难道是因为max_event太小导致的ET模式漏掉事件?<br>并不是, 未被返回的事件是不会被忽略的 只有你从内核中将事件接收出来, 下次才不会提醒</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码为 int event_num = epoll_wait(epollfd_, &amp;*epoll_events_.begin(), 一个常数, timeout);</span></span><br><span class="line"><span class="comment">// 修改后为 int event_num = epoll_wait(epollfd_, &amp;*epoll_events_.begin(), static_cast&lt;int&gt;(epoll_events_.size()), timeout);</span></span><br></pre></td></tr></table></figure><p>只能继续排查了, 因为知道了Recv-Q的存在 直接搜索几个关键字 找到了这个网页</p><p><a href="https://www.cnblogs.com/cxt-janson/p/9273440.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxt-janson/p/9273440.html</a></p><p>最后我尝试将EPOLLET模式改为EPOLLLT正常了!!!!!!</p><h1 id="仍存在的问题"><a href="#仍存在的问题" class="headerlink" title="仍存在的问题"></a>仍存在的问题</h1><p>为什么只有我在启用多线程的时候才会发生丢失连接的现象? 这个问题目前还没找到.</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>我最先排查的重点是线程之间的影响, 我对于muduo的多线程处理机制还是不熟悉, 自以为是了某些地方. </p><p>连接建立的数量不对的时候虽然发现了Recv-Q以及CLOSE_WAIT 但由于对Tcp连接状态的理解以及netstat命令的不熟悉, 导致走了弯路.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;谨以此文献给我, 两次踩坑.&lt;/p&gt;
&lt;p&gt;第一次是根据muduo写我的mongo&lt;/p&gt;
&lt;p&gt;第二次则是后来我又根据muduo写higan. &lt;del&gt;框架名字不是重点&lt;/del&gt;&lt;/p&gt;
&lt;h1 id=&quot;症状描述&quot;&gt;&lt;a href=&quot;#症状描述&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="采坑记" scheme="http://blog.lsmg.xyz/categories/%E9%87%87%E5%9D%91%E8%AE%B0/"/>
    
    
      <category term="采坑记" scheme="http://blog.lsmg.xyz/tags/%E9%87%87%E5%9D%91%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>网络配置</title>
    <link href="http://blog.lsmg.xyz/2020/07/Linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.lsmg.xyz/2020/07/Linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</id>
    <published>2020-07-18T09:39:20.000Z</published>
    <updated>2020-07-18T09:50:25.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务器双网卡配置"><a href="#服务器双网卡配置" class="headerlink" title="服务器双网卡配置"></a>服务器双网卡配置</h1><p>内网访问外网</p><p>外网接在了校园网上, 不过我的路由器不支持Ipv6, 有没有多余的lan口 只能接在服务器的lan口上</p><p>需要设置内网网卡开机启动 固定的Ip地址10.5.1.2 以及子网掩码255.255.255.0<br>然后路由器设置固定Ip地址10.5.1.3 子网掩码255.255.255.0 与内网网卡同网段</p><p>然后使用<code>firewall-cmd --add-masquerade --permanent</code></p><p>Masquerading is useful if the machine is a router and machines connected over an interface in another zone should be able to use the first connection.<br>通过另一个区域(zone)的接口 使用默认zone的接口上网</p><p><a href="https://www.server-world.info/en/note?os=CentOS_7&amp;p=firewalld&amp;f=2" target="_blank" rel="noopener">https://www.server-world.info/en/note?os=CentOS_7&amp;p=firewalld&amp;f=2</a><br>配置完才发现的神网址…. 好吧 写得非常清楚</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;服务器双网卡配置&quot;&gt;&lt;a href=&quot;#服务器双网卡配置&quot; class=&quot;headerlink&quot; title=&quot;服务器双网卡配置&quot;&gt;&lt;/a&gt;服务器双网卡配置&lt;/h1&gt;&lt;p&gt;内网访问外网&lt;/p&gt;
&lt;p&gt;外网接在了校园网上, 不过我的路由器不支持Ipv6, 有没有多余
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="网络配置" scheme="http://blog.lsmg.xyz/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>算法四</title>
    <link href="http://blog.lsmg.xyz/2020/07/%E7%AE%97%E6%B3%9592-%E7%AE%97%E6%B3%95%E5%9B%9B/"/>
    <id>http://blog.lsmg.xyz/2020/07/%E7%AE%97%E6%B3%9592-%E7%AE%97%E6%B3%95%E5%9B%9B/</id>
    <published>2020-07-17T07:51:28.000Z</published>
    <updated>2020-11-04T14:30:35.474Z</updated>
    
    <content type="html"><![CDATA[<p>来之不易的暑期留校, 一半献给算法.</p><h1 id="第二章-排序"><a href="#第二章-排序" class="headerlink" title="第二章 排序"></a>第二章 排序</h1><p>选择排序</p><ul><li>运行时间和输入的数据无关, 仅和数量有关.<br>不会利用输入的初始状态</li><li>数据移动是最少的<br>我们将研究的其他任何算法 都不具备这个特性…..</li></ul><p>插入排序</p><ul><li>适合小规模数组</li><li>对于部分有序的数组, 处理起来很有效</li><li>倒置的数量很少时, 插入排序很可能比其他算法还要快</li></ul><p>希尔排序</p><ul><li>插入排序对于大规模乱序数组很慢, 因为它只会交换相邻元素, 因此为了改进插入排序的局部性,提出了希尔排序</li><li>希尔排序交换不相邻的元素以对数组的局部性进行排序, 最终用插入排序调整局部有序的数组</li></ul><p>归并排序</p><ul><li>原地归并排序</li><li>自顶向下 递归实现 分治思想</li><li>自底向上 从归并微型数组到整体归并</li></ul><p>快速排序</p><ul><li>分治排序算法</li></ul><p>堆排序</p><ul><li>只能说妙啊.. 这本书先讲的优先队列如何实现, 然后紧接着就用sink方法完成了堆排序</li></ul><p><strong>稳定性</strong></p><p>某地在某时下雨 时间和地点存在对应关系.<br>按照时间排序后, 再按照地点排序 单个地点的时间排序就很可能被打乱</p><p>稳定, 则时间排序没有被打乱. 不稳定, 很可能时间排序被打乱</p><table><thead><tr><th>算法</th><th>是否稳定</th><th>是否为原地排序</th><th>时间复杂度</th><th>空间复杂度</th><th>备注</th></tr></thead><tbody><tr><td>选择排序</td><td>否</td><td>是</td><td>N^2</td><td>1</td><td>最简单粗暴的方式, 交换次数最少</td></tr><tr><td>插入排序</td><td>是</td><td>是</td><td>介于N与N^2</td><td>1</td><td>很大程度取决输入元素的排列情况, 如果倒置元素很少则性能可能超过快排</td></tr><tr><td>希尔排序</td><td>否</td><td>是</td><td></td><td>1</td><td>插入排序的改良版, 改善了插入排序过于局限</td></tr><tr><td>快速排序</td><td>否</td><td>是</td><td>NlogN</td><td>lgN</td><td>分治, 运行效率由概率保证</td></tr><tr><td>归并排序</td><td>是</td><td>否</td><td>NlogN</td><td>N</td><td>自顶向下(递归 分治)和自底向上(从局部到整体) 两种方法</td></tr><tr><td>堆排序</td><td>否</td><td>是</td><td>NlogN</td><td>1</td><td>学完后突然想到了如果在很多的数字中找到最大的多少个数这种问题</td></tr></tbody></table><p><strong>2.4 优先队列</strong></p><p>需要支持两种操作, 删除最大元素和插入元素  - 优先级队列</p><ol><li>数组实现(无序) - 插入快 删除慢</li></ol><p>Insert方法 直接将元素插入尾部, 类似栈的push方法</p><p>DelMax方法 使用一个内部循环找出最大的元素和边界元素交换 然后删除边界元素, 删除的时候类似pop方法</p><ol start="2"><li>数组实现(有序) - 插入慢 删除快</li></ol><p>Insert方法 中进行排序, 插入新的元素的时候将较大元素向右移动一格位置, 然后插入新的元素</p><p>DelMax方法 直接删除右侧元素, 类似栈的pop方法</p><ol start="3"><li>链表表示法</li></ol><p>无序序列是解决问题的惰性方法, 仅在必要的时候才会采取行动 找出最大元素</p><p>有序序列是解决问题的积极方法, 尽可能的未雨绸缪, 使得找出最大元素高效</p><ol start="4"><li><code>二叉堆</code>表示法 - 插入和删除都为线性对数级别</li></ol><p>Insert方法 将新元素添加到数组末端, 增加了堆的大小 将新元素<code>上浮</code>到合适的位置</p><p>DelMax方法 删除顶部元素 将数组的最后一个元素放到顶部 将其<code>下沉</code>到合适的位置 减小了堆的大小 将</p><p><strong>堆</strong></p><p>二叉堆: 每个元素都要保证小于等于(大于等于)另外两个特定位置的元素. 其根节点是最小(最大)元素</p><ol><li>二叉堆的指针表示法</li></ol><p>需要使用三个指针, 指向父节点和两个子节点</p><ol start="2"><li>使用数组</li></ol><p>完全二叉树可以使用数组表示 不使用数组的0位置元素 从1开始 k的子节点分别在2k和2k+1</p><p><strong>堆的有序化</strong></p><p>以最大堆为例</p><ol><li>由下至上的堆有序化 <code>上浮</code></li></ol><p>堆的有序状态因为 某个节点比他的父节点更大 被打破.</p><p>需要与父节点交换, 不断向上直到遇到一个更大的父节点 或者到了顶部</p><ol start="2"><li>由上至下的堆有序化 <code>下浮</code></li></ol><p>堆的有序状态因为 某个父节点比 他的两个子节点或其中之一子节点 小 被打破.</p><p>将父节点与子节点中较大的一个进行交换直到它的子节点都比它小 获得到了底部</p><h1 id="第三章-查找"><a href="#第三章-查找" class="headerlink" title="第三章 查找"></a>第三章 查找</h1><p>符号表: 最主要的目的是是将<code>one key</code>和<code>one value</code>联系起来, 是一种存储键值对的数据结构, 支持插入和查找</p><table><thead><tr><th>使用的数据结构</th><th>实现</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>链表(顺序查找)</td><td>SequentialSearchST</td><td>适用于小型问题</td><td>对于大型表很慢</td></tr><tr><td>有序数组(二分)</td><td>BinarySearchST</td><td>最优的查找和空间需求, 能够进行有序性相关的操作</td><td>插入操作很慢</td></tr><tr><td>二叉查找树</td><td>BST</td><td>实现简单, 能够进行有序性相关的操作</td><td>没有性能上界的保证, 链接需要额外的空间</td></tr><tr><td>平衡二叉树</td><td>RedBlackBST</td><td>最优的查找和插入效率, 能够进行有序性相关的操作</td><td>链接需要额外的空间</td></tr><tr><td>散列表</td><td>SeparateChainHashST LinearProbingHashST</td><td>能够快速的查找和插入常见的数据类型</td><td>需要计算散列, 无法进行有序性相关操作, 链接和空节点需要额外的空间</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来之不易的暑期留校, 一半献给算法.&lt;/p&gt;
&lt;h1 id=&quot;第二章-排序&quot;&gt;&lt;a href=&quot;#第二章-排序&quot; class=&quot;headerlink&quot; title=&quot;第二章 排序&quot;&gt;&lt;/a&gt;第二章 排序&lt;/h1&gt;&lt;p&gt;选择排序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时间和输入的数据
      
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>VIM(spf-13)使用</title>
    <link href="http://blog.lsmg.xyz/2020/07/Linux-VIM%E6%8A%98%E8%85%BEspf13/"/>
    <id>http://blog.lsmg.xyz/2020/07/Linux-VIM%E6%8A%98%E8%85%BEspf13/</id>
    <published>2020-07-05T12:31:22.000Z</published>
    <updated>2020-10-27T01:04:01.740Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html" target="_blank" rel="noopener">https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html</a> vim分屏</p><h1 id="乱码解决"><a href="#乱码解决" class="headerlink" title="乱码解决"></a>乱码解决</h1><p>中文乱码</p><p>修改locale.conf确实解决了 但我想要的是阿里云那种显示英文中文却不是乱码</p><p>最终<code>vim /etc/vconsole.conf</code>将cn改为us就解决了….</p><p>中间也尝试安装语言包, 记得是已经安装 最终是修改上面那个之后就好了</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">R           进入替换模式</span><br><span class="line"></span><br><span class="line">e           光标后移一个单词 连续的符号也算一个单词 &lt;&lt;</span><br><span class="line">E           光标后移一个单词 无视符号</span><br><span class="line"></span><br><span class="line">b           光标前移一个单词 连续的符号也算一个单词 &lt;&lt;</span><br><span class="line">B           光标前移一个单词 无视符号</span><br><span class="line"></span><br><span class="line">yy或Y       复制整行          </span><br><span class="line">p           光标之后粘贴</span><br><span class="line">P大写           光标之前粘贴</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2020年7月30日10:14:18</span></span><br><span class="line">ctrl+r      重做撤销内容</span><br><span class="line">u           撤销</span><br><span class="line"></span><br><span class="line">^           本行第一个非空格字符</span><br><span class="line"><span class="meta">$</span><span class="bash">           本行最后一个非空格字符</span></span><br><span class="line">G           文件尾</span><br><span class="line">gg          文件头</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2020年10月27日08:51:36</span></span><br><span class="line">V选中行后</span><br><span class="line">SHIFT + . 缩进</span><br><span class="line">SHIFT + , 取消缩进</span><br><span class="line"></span><br><span class="line">:1,10&gt; 1~10行缩进</span><br><span class="line">:1,10&lt; 1~10行取消缩进</span><br></pre></td></tr></table></figure><h1 id="注释-NERDCommenter"><a href="#注释-NERDCommenter" class="headerlink" title="注释 NERDCommenter"></a>注释 NERDCommenter</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">,c&lt;space&gt;   当前行注释和切换注释</span><br><span class="line"></span><br><span class="line">,cs         块注释当前选中或当前行</span><br><span class="line">v           小写v进入多字符选择模式</span><br><span class="line">V           大写V进入多行选择</span><br></pre></td></tr></table></figure><h1 id="文件导航工具-NERDTree"><a href="#文件导航工具-NERDTree" class="headerlink" title="文件导航工具 NERDTree"></a>文件导航工具 NERDTree</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ctrl + e    打开文件导航</span><br><span class="line">o           打开文件, 目录, 标签</span><br><span class="line">go          打开文件, 目录, 标签, 但光标仍位于导航栏</span><br><span class="line"></span><br><span class="line">R           刷新根目录下所有文件</span><br><span class="line">r           刷新当前目录下文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2020年7月30日16:22:01</span></span><br><span class="line">--------------------------------------</span><br><span class="line">t           在新tab中打开选中节点书签</span><br><span class="line">T           同上 但焦点仍在当前tab</span><br><span class="line"></span><br><span class="line">gt, gT      在tab之间切换</span><br><span class="line"></span><br><span class="line">:tabc       关闭当前tab</span><br><span class="line">:tabo       关闭其他tab</span><br><span class="line">:tabs       查看所有打开的tab</span><br><span class="line">-----------------------------------------</span><br><span class="line">i           在新的split中打开选择文件 两个部分水平切割</span><br><span class="line">gi          同上 焦点仍位于导航栏</span><br><span class="line">s           在新的split中打开选择文件 垂直切割</span><br><span class="line">gs          同上 焦点仍位于导航栏</span><br><span class="line"></span><br><span class="line">ctrl+w w    顺序切换, 两个窗口的时候非常方便</span><br><span class="line">ctrl+w hjkl 对应左 下 上 有</span><br><span class="line"></span><br><span class="line">ctrl+w c    关闭当前split</span><br><span class="line">ctrl+w o    关闭其他split</span><br><span class="line">-----------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tab         补全菜单向下移动</span><br><span class="line">space       补全为当前单词 附带一个空格</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/fl
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="spf-13" scheme="http://blog.lsmg.xyz/tags/spf-13/"/>
    
  </entry>
  
  <entry>
    <title>大二暑假学习规划与记录</title>
    <link href="http://blog.lsmg.xyz/2020/07/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87/"/>
    <id>http://blog.lsmg.xyz/2020/07/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87/</id>
    <published>2020-07-04T14:08:32.000Z</published>
    <updated>2020-07-30T02:12:14.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><p><strong>2020年7月4日22:09:19</strong><br>C++Primer从头到尾看一遍 做习题.  16章+3章.<br>两天一章, 力求看透, 看足.  整理笔记.</p><p><strong>2020年7月4日22:11:54</strong><br>微信公众号运营, 整理自己发过的博客.</p><p><strong>2020年7月4日22:11:59</strong><br>算法学习, 较快的看完数据结构与算法. 奈何大一下没有好好学.  欠的总归要还<br><a href="https://next.xuetangx.com/learn/THU08091000384/THU08091000384/1516243/article/1387079" target="_blank" rel="noopener">https://next.xuetangx.com/learn/THU08091000384/THU08091000384/1516243/article/1387079</a></p><p><a href="https://next.xuetangx.com/learn/THU08091002048/THU08091002048/1515966/article/1373713" target="_blank" rel="noopener">https://next.xuetangx.com/learn/THU08091002048/THU08091002048/1515966/article/1373713</a></p><p><strong>2020年7月4日22:26:56</strong><br>晚上看操作系统<br><a href="https://www.bilibili.com/video/BV1iW411d7hd" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1iW411d7hd</a></p><p>大概时间规划大概如下.  上午C++基础或与之相关 下午算法 晚上操作系统或与之相关. 具体要等暑假开始实行调整.  最后一个暑假,<del>彼岸鱼你可长点心吧</del></p><p><strong>2020年7月14日23:52:20</strong><br>留校有点麻烦, 哎.  尽全力想法留校吧.</p><p>学习具体的时间安排.</p><p><strong>2020年7月17日15:31:42</strong><br>激动人心的一刻!!! 留校申请过了, 感谢老师的帮助. 我还有什么理由不更好好利用暑假呢??</p><p>算法最终选择了算法四教材</p><h1 id="2020年7月27日-2020年8月2日"><a href="#2020年7月27日-2020年8月2日" class="headerlink" title="2020年7月27日 - 2020年8月2日"></a>2020年7月27日 - 2020年8月2日</h1><p><strong>2020年7月30日00:31:57</strong><br>没想到第一次记录都是这个时间点了…..<br>原因是使用了更高级的方式… 记录了自己每个时间段干了什么emm</p><p>这里用来写总结吧, 最终每个星期插一张图片=, =</p><p><strong>2020年7月30日10:11:52</strong></p><p>详细了解并使用exec系列函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;规划&quot;&gt;&lt;a href=&quot;#规划&quot; class=&quot;headerlink&quot; title=&quot;规划&quot;&gt;&lt;/a&gt;规划&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;2020年7月4日22:09:19&lt;/strong&gt;&lt;br&gt;C++Primer从头到尾看一遍 做习题.  16章+3章.&lt;b
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>小方说知识星球</title>
    <link href="http://blog.lsmg.xyz/2020/06/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%B0%8F%E6%96%B9%E8%AF%B4%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83/"/>
    <id>http://blog.lsmg.xyz/2020/06/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%B0%8F%E6%96%B9%E8%AF%B4%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83/</id>
    <published>2020-06-16T11:29:20.000Z</published>
    <updated>2020-07-17T12:38:50.735Z</updated>
    
    <content type="html"><![CDATA[<p>这里并不做过多的记录, 记录一些tips吧</p><p>lsof 能用做文件删除恢复. 仅限于文件虽然被删除但依然被某个进程打开.</p><p>bind函数<br>地址可以指定 INADDR_ANY<br>那么端口呢?  测试了下如果端口为0确实是 bind到了随机端口</p><p>bind到一个已经bind的端口会出错. 然而如果端口为0 随机的端口则没有被bind过</p><p>客户端connect前调用bind能够以指定端口号连接, 这个在高性能服务器见过 不过一直没有用过</p><p>异步connect? 非阻塞connect</p><p>connect尝试次数? 尝试间隔? </p><table><thead><tr><th>函数名称</th><th>返回值</th><th>阻塞</th><th>非阻塞</th></tr></thead><tbody><tr><td>recv</td><td>-1</td><td>出错</td><td>判断是否为EWOULDBLOCK(数据已经收完, ET模式收完数据的标志) 或者 EINTR(信号中断)</td></tr><tr><td>recv</td><td>0</td><td>对端关闭</td><td>对端关闭</td></tr><tr><td>send</td><td>-1</td><td>出错</td><td>EWOULDBLOCK(数据无法继续发出) EAGAIN</td></tr></tbody></table><p>LT 想收多少收多少 收不完就提醒<br>ET 爱收不收 过了这村没这店</p><p>老大让你开发一个邮件服务器, 大多数人像Springboot使用者. 第一时间就会去找库<br>然而大多数HTTP协议实现都比较简单, 在自己公司所用框架的网络基础上, 很简单就能写出.8</p><p>2020年7月17日20:30:06<br>理论-&gt;常用Api-&gt;知晓如何组织底层Api<br>网络编程重难点解析直播录像及课件, 终于看完了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里并不做过多的记录, 记录一些tips吧&lt;/p&gt;
&lt;p&gt;lsof 能用做文件删除恢复. 仅限于文件虽然被删除但依然被某个进程打开.&lt;/p&gt;
&lt;p&gt;bind函数&lt;br&gt;地址可以指定 INADDR_ANY&lt;br&gt;那么端口呢?  测试了下如果端口为0确实是 bind到了随机端口
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="肉疼" scheme="http://blog.lsmg.xyz/tags/%E8%82%89%E7%96%BC/"/>
    
      <category term="小方说" scheme="http://blog.lsmg.xyz/tags/%E5%B0%8F%E6%96%B9%E8%AF%B4/"/>
    
  </entry>
  
</feed>
