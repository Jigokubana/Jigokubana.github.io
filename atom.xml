<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lsmg的大学之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lsmg.xyz/"/>
  <updated>2020-08-03T15:55:56.702Z</updated>
  <id>http://blog.lsmg.xyz/</id>
  
  <author>
    <name>Lsmg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EPOLLET丢失新连接事件</title>
    <link href="http://blog.lsmg.xyz/2020/08/%E9%87%87%E5%9D%91%E8%AE%B0-EPOLLET%E4%B8%A2%E5%A4%B1%E6%96%B0%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6/"/>
    <id>http://blog.lsmg.xyz/2020/08/%E9%87%87%E5%9D%91%E8%AE%B0-EPOLLET%E4%B8%A2%E5%A4%B1%E6%96%B0%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6/</id>
    <published>2020-08-03T15:03:08.000Z</published>
    <updated>2020-08-03T15:55:56.702Z</updated>
    
    <content type="html"><![CDATA[<p>谨以此文献给我, 两次踩坑.</p><p>第一次是根据muduo写我的mongo</p><p>第二次则是后来我又根据muduo写higan. <del>框架名字不是重点</del></p><h1 id="症状描述"><a href="#症状描述" class="headerlink" title="症状描述"></a>症状描述</h1><ol><li>最首先的症状就是使用ab压测的时候, 压测会在快结束的时候卡住 而且压测过程中也会出现卡顿<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\XXX&gt; ab -n 1000 -c 94 -k  http:&#x2F;&#x2F;10.4.160.96:1022&#x2F;hello</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 1874286 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http:&#x2F;&#x2F;www.zeustech.net&#x2F;</span><br><span class="line">Licensed to The Apache Software Foundation, http:&#x2F;&#x2F;www.apache.org&#x2F;</span><br><span class="line"></span><br><span class="line">Benchmarking 10.4.160.96 (be patient)</span><br><span class="line">Completed 100 requests</span><br><span class="line">Completed 200 requests</span><br><span class="line">Completed 300 requests</span><br><span class="line">Completed 400 requests</span><br><span class="line">Completed 500 requests</span><br><span class="line">Completed 600 requests</span><br><span class="line">Completed 700 requests</span><br><span class="line">Completed 800 requests</span><br><span class="line">Completed 900 requests</span><br><span class="line">apr_pollset_poll: The timeout specified has expired (70007)</span><br><span class="line">Total of 996 requests completed</span><br></pre></td></tr></table></figure></li><li>这时候已经建立的连接不受影响 却无法建立新的连接 debug的时候发现会出现建立已经关闭的连接</li><li>上面的问题发生与不发生 跟我是否开多线程有关, 如果我不建立额外的EventLoopThread就不会出现这个问题</li></ol><h1 id="第一波排查-线程之间互相影响"><a href="#第一波排查-线程之间互相影响" class="headerlink" title="第一波排查 线程之间互相影响"></a>第一波排查 线程之间互相影响</h1><p>因为问题出现与否 与我是否设置多线程有关, 我就开始排查线程之间的影响.<br>重点放在了muduo的RunInLoop函数. 因为这个函数我一直不是明白怎么回事.<br>最终根据muduo的设计思想 一个EventLoop对应一个Thread.<br>结合RunInLoop就可以达到谁的事件谁处理的效果</p><p>举个例子, 连接中断后, 子线程返回相应的事件 要去调用TcpServer的RemoveConnection将自己移除, 如果不使用RunInLoop<br>当有多个子线程 同时触发同样的事件 同时去对map进行删除操作 必然需要加锁. 况且连接连接的时候也要对map进行插入操作.<br>使用RunInLoop判断后得知是子线程在调用RunInLoop而非对应的线程, 就将任务存储到了相关的EventLoop中. 而EventLoop中存储的任务只有其所属的Thread才能处理.<br>所以实现了统一所有子线程的移除连接操作到了主线程中, 而连接的建立也是主线程操作, 最终避免了加锁.</p><p>然后那个swap命令处理任务度列减少加锁的时间也很赞</p><p>最终我加上了几处重要的RunInLoop, 不过并没有解决问题………….</p><h1 id="第二波排查-到底返回了多少事件"><a href="#第二波排查-到底返回了多少事件" class="headerlink" title="第二波排查 到底返回了多少事件?"></a>第二波排查 到底返回了多少事件?</h1><p>我在Acceptor等多个可读事件回调的位置加了计数器, 这时候最先发现的就是连接建立数量不对.</p><p>上边996个完成请求缺了4个, 并且正好连接建立了90个连接, 而非设置的并发94, 也是少了4个.</p><p>我先怀疑是否是ab压测的处理, 我试了下muduo多线程下94个连接 higan单线程94连接,多线程90连接, 排除了ab的问题</p><p>少的链接去了哪里? 我使用netstat命令发现 正好是四个CLOSE_WAIT 我去看了下ab的包正好是114字节 说明了少的四个链接的位置<br>而且这四个端口号正好是从本该是第91个连接的端口号开始的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@fish ~]# netstat -an | grep 1022</span><br><span class="line">tcp        4      0 0.0.0.0:1022            0.0.0.0:*               LISTEN     </span><br><span class="line">tcp      114      0 10.4.160.96:1022        10.4.160.95:8785        CLOSE_WAIT </span><br><span class="line">tcp      114      0 10.4.160.96:1022        10.4.160.95:8787        CLOSE_WAIT </span><br><span class="line">tcp      114      0 10.4.160.96:1022        10.4.160.95:8786        CLOSE_WAIT </span><br><span class="line">tcp      114      0 10.4.160.96:1022        10.4.160.95:8784        CLOSE_WAIT</span><br></pre></td></tr></table></figure><p>其实netstat不对劲早就发现了, 然而并不理解netstat命令 没有重视问题.</p><p>使用Man命令察看了 第二列是Recv-Q 对于CLOSE_WAIT来说是未接收的字节数 对于LISTEN则是未接收的连接数</p><h1 id="第三波排查-为什么这四个连接没有被接受"><a href="#第三波排查-为什么这四个连接没有被接受" class="headerlink" title="第三波排查 为什么这四个连接没有被接受"></a>第三波排查 为什么这四个连接没有被接受</h1><p>首先我发现了我这行代码写的有问题, 而我的epoll_events_是一个vector 后面的代码有扩容逻辑 难道是因为max_event太小导致的ET模式漏掉事件?<br>并不是, 未被返回的事件是不会被忽略的 只有你从内核中将事件接收出来, 下次才不会提醒</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码为 int event_num = epoll_wait(epollfd_, &amp;*epoll_events_.begin(), 一个常数, timeout);</span></span><br><span class="line"><span class="comment">// 修改后为 int event_num = epoll_wait(epollfd_, &amp;*epoll_events_.begin(), static_cast&lt;int&gt;(epoll_events_.size()), timeout);</span></span><br></pre></td></tr></table></figure><p>只能继续排查了, 因为知道了Recv-Q的存在 直接搜索几个关键字 找到了这个网页</p><p><a href="https://www.cnblogs.com/cxt-janson/p/9273440.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxt-janson/p/9273440.html</a></p><p>最后我尝试将EPOLLET模式改为EPOLLLT正常了!!!!!!</p><h1 id="仍存在的问题"><a href="#仍存在的问题" class="headerlink" title="仍存在的问题"></a>仍存在的问题</h1><p>为什么只有我在启用多线程的时候才会发生丢失连接的现象? 这个问题目前还没找到.</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>我最先排查的重点是线程之间的影响, 我对于muduo的多线程处理机制还是不熟悉, 自以为是了某些地方. </p><p>连接建立的数量不对的时候虽然发现了Recv-Q以及CLOSE_WAIT 但由于对Tcp连接状态的理解以及netstat命令的不熟悉, 导致走了弯路.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;谨以此文献给我, 两次踩坑.&lt;/p&gt;
&lt;p&gt;第一次是根据muduo写我的mongo&lt;/p&gt;
&lt;p&gt;第二次则是后来我又根据muduo写higan. &lt;del&gt;框架名字不是重点&lt;/del&gt;&lt;/p&gt;
&lt;h1 id=&quot;症状描述&quot;&gt;&lt;a href=&quot;#症状描述&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="采坑记" scheme="http://blog.lsmg.xyz/categories/%E9%87%87%E5%9D%91%E8%AE%B0/"/>
    
    
      <category term="采坑记" scheme="http://blog.lsmg.xyz/tags/%E9%87%87%E5%9D%91%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>网络配置</title>
    <link href="http://blog.lsmg.xyz/2020/07/Linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.lsmg.xyz/2020/07/Linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</id>
    <published>2020-07-18T09:39:20.000Z</published>
    <updated>2020-07-18T09:50:25.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务器双网卡配置"><a href="#服务器双网卡配置" class="headerlink" title="服务器双网卡配置"></a>服务器双网卡配置</h1><p>内网访问外网</p><p>外网接在了校园网上, 不过我的路由器不支持Ipv6, 有没有多余的lan口 只能接在服务器的lan口上</p><p>需要设置内网网卡开机启动 固定的Ip地址10.5.1.2 以及子网掩码255.255.255.0<br>然后路由器设置固定Ip地址10.5.1.3 子网掩码255.255.255.0 与内网网卡同网段</p><p>然后使用<code>firewall-cmd --add-masquerade --permanent</code></p><p>Masquerading is useful if the machine is a router and machines connected over an interface in another zone should be able to use the first connection.<br>通过另一个区域(zone)的接口 使用默认zone的接口上网</p><p><a href="https://www.server-world.info/en/note?os=CentOS_7&amp;p=firewalld&amp;f=2" target="_blank" rel="noopener">https://www.server-world.info/en/note?os=CentOS_7&amp;p=firewalld&amp;f=2</a><br>配置完才发现的神网址…. 好吧 写得非常清楚</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;服务器双网卡配置&quot;&gt;&lt;a href=&quot;#服务器双网卡配置&quot; class=&quot;headerlink&quot; title=&quot;服务器双网卡配置&quot;&gt;&lt;/a&gt;服务器双网卡配置&lt;/h1&gt;&lt;p&gt;内网访问外网&lt;/p&gt;
&lt;p&gt;外网接在了校园网上, 不过我的路由器不支持Ipv6, 有没有多余
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="网络配置" scheme="http://blog.lsmg.xyz/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>算法四</title>
    <link href="http://blog.lsmg.xyz/2020/07/%E7%AE%97%E6%B3%9592-%E7%AE%97%E6%B3%95%E5%9B%9B/"/>
    <id>http://blog.lsmg.xyz/2020/07/%E7%AE%97%E6%B3%9592-%E7%AE%97%E6%B3%95%E5%9B%9B/</id>
    <published>2020-07-17T07:51:28.000Z</published>
    <updated>2020-08-02T07:02:35.436Z</updated>
    
    <content type="html"><![CDATA[<p>来之不易的暑期留校, 一半献给算法.</p><h1 id="第二章-排序"><a href="#第二章-排序" class="headerlink" title="第二章 排序"></a>第二章 排序</h1><p>选择排序</p><ul><li>运行时间和输入的数据无关, 仅和数量有关.<br>不会利用输入的初始状态</li><li>数据移动是最少的<br>我们将研究的其他任何算法 都不具备这个特性…..</li></ul><p>插入排序</p><ul><li>适合小规模数组</li><li>对于部分有序的数组, 处理起来很有效</li><li>倒置的数量很少时, 插入排序很可能比其他算法还要快</li></ul><p>希尔排序</p><ul><li>插入排序对于大规模乱序数组很慢, 因为它只会交换相邻元素, 因此为了改进插入排序的局部性,提出了希尔排序</li><li>希尔排序交换不相邻的元素以对数组的局部性进行排序, 最终用插入排序调整局部有序的数组</li></ul><p>归并排序</p><ul><li>原地归并排序</li><li>自顶向下 递归实现 分治思想</li><li>自底向上 从归并微型数组到整体归并</li></ul><p>快速排序</p><ul><li>分治排序算法</li></ul><p>堆排序</p><ul><li>只能说妙啊.. 这本书先讲的优先队列如何实现, 然后紧接着就用sink方法完成了堆排序</li></ul><p><strong>稳定性</strong></p><p>某地在某时下雨 时间和地点存在对应关系.<br>按照时间排序后, 再按照地点排序 单个地点的时间排序就很可能被打乱</p><p>稳定, 则时间排序没有被打乱. 不稳定, 很可能时间排序被打乱</p><table><thead><tr><th>算法</th><th>是否稳定</th><th>是否为原地排序</th><th>时间复杂度</th><th>空间复杂度</th><th>备注</th></tr></thead><tbody><tr><td>选择排序</td><td>否</td><td>是</td><td>N^2</td><td>1</td><td>最简单粗暴的方式, 交换次数最少</td></tr><tr><td>插入排序</td><td>是</td><td>是</td><td>介于N与N^2</td><td>1</td><td>很大程度取决输入元素的排列情况, 如果倒置元素很少则性能可能超过快排</td></tr><tr><td>希尔排序</td><td>否</td><td>是</td><td></td><td>1</td><td>插入排序的改良版, 改善了插入排序过于局限</td></tr><tr><td>快速排序</td><td>否</td><td>是</td><td>NlogN</td><td>lgN</td><td>分治, 运行效率由概率保证</td></tr><tr><td>归并排序</td><td>是</td><td>否</td><td>NlogN</td><td>N</td><td>自顶向下(递归 分治)和自底向上(从局部到整体) 两种方法</td></tr><tr><td>堆排序</td><td>否</td><td>是</td><td>NlogN</td><td>1</td><td>学完后突然想到了如果在很多的数字中找到最大的多少个数这种问题</td></tr></tbody></table><p><strong>2.4 优先队列</strong></p><p>需要支持两种操作, 删除最大元素和插入元素  - 优先级队列</p><ol><li>数组实现(无序) - 插入快 删除慢</li></ol><p>Insert方法 直接将元素插入尾部, 类似栈的push方法</p><p>DelMax方法 使用一个内部循环找出最大的元素和边界元素交换 然后删除边界元素, 删除的时候类似pop方法</p><ol start="2"><li>数组实现(有序) - 插入慢 删除快</li></ol><p>Insert方法 中进行排序, 插入新的元素的时候将较大元素向右移动一格位置, 然后插入新的元素</p><p>DelMax方法 直接删除右侧元素, 类似栈的pop方法</p><ol start="3"><li>链表表示法</li></ol><p>无序序列是解决问题的惰性方法, 仅在必要的时候才会采取行动 找出最大元素</p><p>有序序列是解决问题的积极方法, 尽可能的未雨绸缪, 使得找出最大元素高效</p><ol start="4"><li><code>二叉堆</code>表示法 - 插入和删除都为线性对数级别</li></ol><p>Insert方法 将新元素添加到数组末端, 增加了堆的大小 将新元素<code>上浮</code>到合适的位置</p><p>DelMax方法 删除顶部元素 将数组的最后一个元素放到顶部 将其<code>下沉</code>到合适的位置 减小了堆的大小 将</p><p><strong>堆</strong></p><p>二叉堆: 每个元素都要保证小于等于(大于等于)另外两个特定位置的元素. 其根节点是最小(最大)元素</p><ol><li>二叉堆的指针表示法</li></ol><p>需要使用三个指针, 指向父节点和两个子节点</p><ol start="2"><li>使用数组</li></ol><p>完全二叉树可以使用数组表示 不使用数组的0位置元素 从1开始 k的子节点分别在2k和2k+1</p><p><strong>堆的有序化</strong></p><p>以最大堆为例</p><ol><li>由下至上的堆有序化 <code>上浮</code></li></ol><p>堆的有序状态因为 某个节点比他的父节点更大 被打破.</p><p>需要与父节点交换, 不断向上直到遇到一个更大的父节点 或者到了顶部</p><ol start="2"><li>由上至下的堆有序化 <code>下浮</code></li></ol><p>堆的有序状态因为 某个父节点比 他的两个子节点或其中之一子节点 小 被打破.</p><p>将父节点与子节点中较大的一个进行交换直到它的子节点都比它小 获得到了底部</p><h1 id="第三章-查找"><a href="#第三章-查找" class="headerlink" title="第三章 查找"></a>第三章 查找</h1><p>符号表: 一种存储键值对的数据结构, 支持两种操作. </p><ul><li>插入(PUT, 我还去查了下insert和put单词意思的差别…) 将一组新的键值对存入表中</li><li>查找(get), 根据给定的键得到相应的值</li></ul><p>无序链表</p><ul><li>插入和查找效率低  与数据量成正比</li><li>使用链表</li></ul><p>有序数组中的二分查找</p><ul><li>使用两个平行数组</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来之不易的暑期留校, 一半献给算法.&lt;/p&gt;
&lt;h1 id=&quot;第二章-排序&quot;&gt;&lt;a href=&quot;#第二章-排序&quot; class=&quot;headerlink&quot; title=&quot;第二章 排序&quot;&gt;&lt;/a&gt;第二章 排序&lt;/h1&gt;&lt;p&gt;选择排序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时间和输入的数据
      
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>spf-13</title>
    <link href="http://blog.lsmg.xyz/2020/07/Linux-VIM%E6%8A%98%E8%85%BEspf13/"/>
    <id>http://blog.lsmg.xyz/2020/07/Linux-VIM%E6%8A%98%E8%85%BEspf13/</id>
    <published>2020-07-05T12:31:22.000Z</published>
    <updated>2020-08-02T07:57:48.277Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html" target="_blank" rel="noopener">https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html</a> vim分屏</p><h1 id="乱码解决"><a href="#乱码解决" class="headerlink" title="乱码解决"></a>乱码解决</h1><p>中文乱码</p><p>修改locale.conf确实解决了 但我想要的是阿里云那种显示英文中文却不是乱码</p><p>最终<code>vim /etc/vconsole.conf</code>将cn改为us就解决了….</p><p>中间也尝试安装语言包, 记得是已经安装 最终是修改上面那个之后就好了</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">R           进入替换模式</span><br><span class="line"></span><br><span class="line">e           光标后移一个单词 连续的符号也算一个单词 &lt;&lt;</span><br><span class="line">E           光标后移一个单词 无视符号</span><br><span class="line"></span><br><span class="line">b           光标前移一个单词 连续的符号也算一个单词 &lt;&lt;</span><br><span class="line">B           光标前移一个单词 无视符号</span><br><span class="line"></span><br><span class="line">yy或Y       复制整行          </span><br><span class="line">p           光标之后粘贴</span><br><span class="line">P大写           光标之前粘贴</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2020年7月30日10:14:18</span></span><br><span class="line">ctrl+r      重做撤销内容</span><br><span class="line">u           撤销</span><br><span class="line"></span><br><span class="line">^           本行第一个非空格字符</span><br><span class="line"><span class="meta">$</span><span class="bash">           本行最后一个非空格字符</span></span><br><span class="line">G           文件尾</span><br><span class="line">gg          文件头</span><br></pre></td></tr></table></figure><h1 id="注释-NERDCommenter"><a href="#注释-NERDCommenter" class="headerlink" title="注释 NERDCommenter"></a>注释 NERDCommenter</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">,c&lt;space&gt;   当前行注释和切换注释</span><br><span class="line"></span><br><span class="line">,cs         块注释当前选中或当前行</span><br><span class="line">v           小写v进入多字符选择模式</span><br><span class="line">V           大写V进入多行选择</span><br></pre></td></tr></table></figure><h1 id="文件导航工具-NERDTree"><a href="#文件导航工具-NERDTree" class="headerlink" title="文件导航工具 NERDTree"></a>文件导航工具 NERDTree</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ctrl + e    打开文件导航</span><br><span class="line">o           打开文件, 目录, 标签</span><br><span class="line">go          打开文件, 目录, 标签, 但光标仍位于导航栏</span><br><span class="line"></span><br><span class="line">R           刷新根目录下所有文件</span><br><span class="line">r           刷新当前目录下文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2020年7月30日16:22:01</span></span><br><span class="line">--------------------------------------</span><br><span class="line">t           在新tab中打开选中节点书签</span><br><span class="line">T           同上 但焦点仍在当前tab</span><br><span class="line"></span><br><span class="line">gt, gT      在tab之间切换</span><br><span class="line"></span><br><span class="line">:tabc       关闭当前tab</span><br><span class="line">:tabo       关闭其他tab</span><br><span class="line">:tabs       查看所有打开的tab</span><br><span class="line">-----------------------------------------</span><br><span class="line">i           在新的split中打开选择文件 两个部分水平切割</span><br><span class="line">gi          同上 焦点仍位于导航栏</span><br><span class="line">s           在新的split中打开选择文件 垂直切割</span><br><span class="line">gs          同上 焦点仍位于导航栏</span><br><span class="line"></span><br><span class="line">ctrl+w w    顺序切换, 两个窗口的时候非常方便</span><br><span class="line">ctrl+w hjkl 对应左 下 上 有</span><br><span class="line"></span><br><span class="line">ctrl+w c    关闭当前split</span><br><span class="line">ctrl+w o    关闭其他split</span><br><span class="line">-----------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tab         补全菜单向下移动</span><br><span class="line">space       补全为当前单词 附带一个空格</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/fl
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="spf-13" scheme="http://blog.lsmg.xyz/tags/spf-13/"/>
    
  </entry>
  
  <entry>
    <title>大二暑假学习规划与记录</title>
    <link href="http://blog.lsmg.xyz/2020/07/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87/"/>
    <id>http://blog.lsmg.xyz/2020/07/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87/</id>
    <published>2020-07-04T14:08:32.000Z</published>
    <updated>2020-07-30T02:12:14.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><p><strong>2020年7月4日22:09:19</strong><br>C++Primer从头到尾看一遍 做习题.  16章+3章.<br>两天一章, 力求看透, 看足.  整理笔记.</p><p><strong>2020年7月4日22:11:54</strong><br>微信公众号运营, 整理自己发过的博客.</p><p><strong>2020年7月4日22:11:59</strong><br>算法学习, 较快的看完数据结构与算法. 奈何大一下没有好好学.  欠的总归要还<br><a href="https://next.xuetangx.com/learn/THU08091000384/THU08091000384/1516243/article/1387079" target="_blank" rel="noopener">https://next.xuetangx.com/learn/THU08091000384/THU08091000384/1516243/article/1387079</a></p><p><a href="https://next.xuetangx.com/learn/THU08091002048/THU08091002048/1515966/article/1373713" target="_blank" rel="noopener">https://next.xuetangx.com/learn/THU08091002048/THU08091002048/1515966/article/1373713</a></p><p><strong>2020年7月4日22:26:56</strong><br>晚上看操作系统<br><a href="https://www.bilibili.com/video/BV1iW411d7hd" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1iW411d7hd</a></p><p>大概时间规划大概如下.  上午C++基础或与之相关 下午算法 晚上操作系统或与之相关. 具体要等暑假开始实行调整.  最后一个暑假,<del>彼岸鱼你可长点心吧</del></p><p><strong>2020年7月14日23:52:20</strong><br>留校有点麻烦, 哎.  尽全力想法留校吧.</p><p>学习具体的时间安排.</p><p><strong>2020年7月17日15:31:42</strong><br>激动人心的一刻!!! 留校申请过了, 感谢老师的帮助. 我还有什么理由不更好好利用暑假呢??</p><p>算法最终选择了算法四教材</p><h1 id="2020年7月27日-2020年8月2日"><a href="#2020年7月27日-2020年8月2日" class="headerlink" title="2020年7月27日 - 2020年8月2日"></a>2020年7月27日 - 2020年8月2日</h1><p><strong>2020年7月30日00:31:57</strong><br>没想到第一次记录都是这个时间点了…..<br>原因是使用了更高级的方式… 记录了自己每个时间段干了什么emm</p><p>这里用来写总结吧, 最终每个星期插一张图片=, =</p><p><strong>2020年7月30日10:11:52</strong></p><p>详细了解并使用exec系列函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;规划&quot;&gt;&lt;a href=&quot;#规划&quot; class=&quot;headerlink&quot; title=&quot;规划&quot;&gt;&lt;/a&gt;规划&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;2020年7月4日22:09:19&lt;/strong&gt;&lt;br&gt;C++Primer从头到尾看一遍 做习题.  16章+3章.&lt;b
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>小方说知识星球</title>
    <link href="http://blog.lsmg.xyz/2020/06/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%B0%8F%E6%96%B9%E8%AF%B4%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83/"/>
    <id>http://blog.lsmg.xyz/2020/06/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%B0%8F%E6%96%B9%E8%AF%B4%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83/</id>
    <published>2020-06-16T11:29:20.000Z</published>
    <updated>2020-07-17T12:38:50.735Z</updated>
    
    <content type="html"><![CDATA[<p>这里并不做过多的记录, 记录一些tips吧</p><p>lsof 能用做文件删除恢复. 仅限于文件虽然被删除但依然被某个进程打开.</p><p>bind函数<br>地址可以指定 INADDR_ANY<br>那么端口呢?  测试了下如果端口为0确实是 bind到了随机端口</p><p>bind到一个已经bind的端口会出错. 然而如果端口为0 随机的端口则没有被bind过</p><p>客户端connect前调用bind能够以指定端口号连接, 这个在高性能服务器见过 不过一直没有用过</p><p>异步connect? 非阻塞connect</p><p>connect尝试次数? 尝试间隔? </p><table><thead><tr><th>函数名称</th><th>返回值</th><th>阻塞</th><th>非阻塞</th></tr></thead><tbody><tr><td>recv</td><td>-1</td><td>出错</td><td>判断是否为EWOULDBLOCK(数据已经收完, ET模式收完数据的标志) 或者 EINTR(信号中断)</td></tr><tr><td>recv</td><td>0</td><td>对端关闭</td><td>对端关闭</td></tr><tr><td>send</td><td>-1</td><td>出错</td><td>EWOULDBLOCK(数据无法继续发出) EAGAIN</td></tr></tbody></table><p>LT 想收多少收多少 收不完就提醒<br>ET 爱收不收 过了这村没这店</p><p>老大让你开发一个邮件服务器, 大多数人像Springboot使用者. 第一时间就会去找库<br>然而大多数HTTP协议实现都比较简单, 在自己公司所用框架的网络基础上, 很简单就能写出.8</p><p>2020年7月17日20:30:06<br>理论-&gt;常用Api-&gt;知晓如何组织底层Api<br>网络编程重难点解析直播录像及课件, 终于看完了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里并不做过多的记录, 记录一些tips吧&lt;/p&gt;
&lt;p&gt;lsof 能用做文件删除恢复. 仅限于文件虽然被删除但依然被某个进程打开.&lt;/p&gt;
&lt;p&gt;bind函数&lt;br&gt;地址可以指定 INADDR_ANY&lt;br&gt;那么端口呢?  测试了下如果端口为0确实是 bind到了随机端口
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="肉疼" scheme="http://blog.lsmg.xyz/tags/%E8%82%89%E7%96%BC/"/>
    
      <category term="小方说" scheme="http://blog.lsmg.xyz/tags/%E5%B0%8F%E6%96%B9%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络笔记</title>
    <link href="http://blog.lsmg.xyz/2020/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>http://blog.lsmg.xyz/2020/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</id>
    <published>2020-06-16T00:50:22.000Z</published>
    <updated>2020-07-14T08:01:25.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title="?"></a>?</h1><p>物理层-以太网帧<br>数据链路层-MAC帧-添加了首部和尾部-FCS校验<br>网络层-IP数据报-首部校验和<br>传输层-报文,流 </p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p><strong>封装成帧</strong><br>帧首部SOH, 01H<br>帧尾部EOT, 04H</p><p><strong>透明传输</strong><br>数据部分出现 01H和04H以及1BH  在前面增加转义字符ESC 1BH</p><p><strong>差错检测</strong><br>CRC校验<br>FCS冗余码</p><p><strong>PPP协议</strong><br>7EH 帧首帧尾</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层-数据报<br>数据链路层-MAC帧</p><p>网络层向上只提供 简单灵活的 无连接的 尽最大努力交付 的 <code>数据报</code>服务</p><p>地址解析协议ARP<br>网际控制报文协议 ICMP<br>网际组管理协议 IGMP</p><p>转发器-物理层使用的中间设备<br>网桥或桥接器-数据链路层使用的中间设备<br>路由器-网络层中间设备<br>网关-网络层以上使用的中间设备</p><p>一个路由器互联的多个局域网网络中-<code>网络层及以上高层协议必须相同</code> 而物理层和数据链路层则可不同(p116)<br>IP地址<code>用于网络层及以上高层</code> MAC地址用于<code>数据链路层和物理层</code></p><p>路由器转发的时候 源和目的MAC都<code>会</code>变化, 然而源和目的IP<code>不</code>变化 p118 p123</p><p>互联网名字和数字分配机构ICANN进行分配</p><p><strong>IP地址编址的三个阶段</strong></p><ul><li>分类的IP地址<br>IP地址由<code>网络号-主机号</code>构成</li></ul><table><thead><tr><th>类别</th><th>范围</th><th>网络号固定部分</th><th>总网络号位数</th><th>主机号位数</th></tr></thead><tbody><tr><td>A类</td><td>1-126</td><td>0</td><td>7+1位</td><td>主机号24位</td></tr><tr><td>B类</td><td>128-191</td><td>10</td><td>2+14位</td><td>主机号16位</td></tr><tr><td>C类</td><td>192-223</td><td>110</td><td>3+21位</td><td>主机号8位</td></tr><tr><td>D类</td><td>224-239</td><td>1110</td><td>多播地址</td><td></td></tr><tr><td>E类</td><td>240-255</td><td>1111</td><td>保留</td><td></td></tr></tbody></table><p>A类</p><p>2^7-2</p><p>网络号全0 表示本网络<br>网络号 0111 1111 127 代表本地换环回(你压根没被当做网络地址, 上表中跳过了127)</p><p>2^24-2</p><p>主机号全0 表示本主机连接的网络地址<br>主机号全1 代表该网络上的所有主机</p><p>B类</p><p>2^14-1</p><p>扣除了128.0.0.0 从128.1.0.0开始</p><p>2^16-2</p><p>抛去主机号全0和全1 原因同上</p><p>C类</p><p>2^21-1</p><p>扣除了192.0.0.0 从192.0.1.0开始</p><p>2^8-2</p><p>扣除全0和全1原因同上</p><p>其他特殊IP<br><code>10.*.*.*</code> <code>172.16.*.*-172.31.*.*</code> <code>192.168.*.*</code> - 三个私有地址网段 用于私网</p><ul><li>子网的划分<br>将B类地址主机号前面几个字作为子网号 划分子网 将二级地址转化为三级地址<br>现有B类地址<code>145.13.0.0</code>取八位作为子网<code>145.13.1.0</code>为一个子网 主机号剩下8位</li></ul><p>子网掩码<br>当<code>145.13.1.3</code>到达路由器<code>145.13.0.0</code>(描述不恰当)后 如何将其转发到子网<code>145.13.1.0</code><br>使用子网掩码AND运算得到网络地址<br>子网掩码子网数子网主机数p138</p><p><em>@划分子网情况下分组转发算法p140@</em></p><ul><li>构成超网<br>变长子网掩码VLSM(Variable Length Subnet Mask)<br>在其基础上研究出无分类编址方法-无分类域间路由选择CIDR(Classless Inter-domain Routing)</li></ul><p>128.14.35.7/20 表明前20位是网络前缀<br>成为/20地址块<br><em>@变长子网掩码划分子网@</em></p><p>用CIDR地址块来查找目的网络 这种地址的聚合常称为<code>聚合路由</code>也称为<code>构成超网</code></p><p>从匹配结果总选择具有最长网络前缀的路由-<code>最长前缀匹配</code></p><hr><p>ARP略</p><hr><p>IP数据报格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         Identification        |Flags|      Fragment Offset    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       Source Address                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Destination Address                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>IHL: 首部长度 最大 2^4-1 = 15 <code>单位四字节</code><br>最小是5 即最小首部为20字节<br>最大15  即最大为60字节</p><p>Total Length: 总长度 最大 2^16-1 = 65535 <code>单位一字节</code><br>以太网最大数据帧 1518 抛去14头部 4字节校验 剩余1500即为<code>MTU</code>  数据<code>帧</code>(链路层)的<code>数据字段</code>最大长度</p><p>flags: 标识<br>第一位MF MF=1标识<code>还有分片</code> DF=1标识<code>不能分片</code></p><p>Fragment Offset: 片偏移 <code>单位八字节</code><br>13位  </p><p><em>@分片计算 p129@</em></p><p>Time to Live: 生存时间<br><code>先减1</code>再判断是否为0, 为0则丢弃</p><p>Protocol: 协议<br>常用 TCP-6 UDP-17</p><p>Header Checksum: <code>首部校验和</code> 不包括数据部分<br>每次经过路由器都可能变化 生存时间标志片偏移可能变化</p><hr><p>首部分为很多16位字的序列 先将原校验和清零 在将所有序列求反码相加 再求反码写入校验和<br>接收方将所有序列 求反码相加(这里不将校验和清零) 得到的和取反码 必须为零 </p><p>IP数据报的可选部分无分隔符 最后需要用全0的字段补齐为 <code>四的整数倍</code></p><p><code>分组转发算法</code><br><em>@路由器路径 与路由表下一跳地址 p132@</em></p><p>同页特定主机路由和默认路由 下一页分组转发算法</p><p>ICMP略</p><p>互联网路由选择协议</p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p>网络层为<code>主机</code>之间提供逻辑通信, 而传输层为应用程序之间提供<code>端到端</code>的逻辑通信</p><p>熟知端口号 - 0<del>1023 - 服务器端<br>登记端口号 - 1024</del>49151 - 提供给没有熟知端口号使用<br>短暂端口号 - 客户端</p><p>复用分用的关键 对下使用了IP数据报头部的字段Protocol 以及 对上端口号的使用</p><p>UDP数据报 TCP报文段<br>UDP是无连接的, 不可靠的, 基于数据报<br>TCP是面向连接的, 可靠的, 基于流的服务<br>(可靠 无差错, 不丢失, 不重复, 按序到达)</p><h2 id="用户数据报协议-UDP-User-Datagram-Protocol"><a href="#用户数据报协议-UDP-User-Datagram-Protocol" class="headerlink" title="用户数据报协议 UDP User Datagram Protocol"></a>用户数据报协议 UDP User Datagram Protocol</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0      7 8     15 16    23 24    31</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|          source address           |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|        destination address        |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|  zero  |protocol|   UDP length    |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0      7 8     15 16    23 24    31</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|     Source      |   Destination   |</span><br><span class="line">|      Port       |      Port       |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|                 |                 |</span><br><span class="line">|     Length      |    Checksum     |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|</span><br><span class="line">|          data octets ...</span><br><span class="line">+---------------- ...</span><br><span class="line"></span><br><span class="line">    User Datagram Header Format</span><br></pre></td></tr></table></figure><p>UDP length 同 Length: 最小值为8（仅包含首部 无数据）<br>Checksum: 校验和 使用 <code>伪首部</code> <code>首部</code> <code>数据</code> 计算出<br>校验了源和目的端口和地址</p><p>protocol： udp为17 tcp为6</p><p>伪首部12字节, 既不向下传递, 也不向上递交 仅仅为了计算校验和</p><p><em>@校验和计算 p210@</em><br><em>@TCP和UDP交付IP层的分片@</em><br>同样16B一组 </p><h2 id="传输控制协议-TCP-Transmission-Control-Protocol"><a href="#传输控制协议-TCP-Transmission-Control-Protocol" class="headerlink" title="传输控制协议 TCP Transmission Control Protocol"></a>传输控制协议 TCP Transmission Control Protocol</h2><p>为了传输的可靠性使用了下面的协议<br><strong>自动重传请求ARQ</strong><br>超时重传：每次发送完设置超时计时器， 超时之前收到确认就取消定时器， 否则到期后重发，并重置定时器。</p><p><code>收到重复报文</code>：A发送后B的回复丢失，A重发报文。丢弃重复的报文， 并向对方发送确认，而不能认为之前发送过就不发送了。<br><code>收到迟到的确认报文</code>：丢弃， 什么也不做。</p><p><strong><del>停止等待协议</del> 流水线传输协议</strong><br>使用流水线传输协议 就要使用 连续ARQ协议 和 滑动窗口协议</p><p><strong>连续ARQ协议</strong><br>可以连续发送五个连续分组 而不需要对方的确认</p><p>每收到一个确认，发送窗口就向前滑动。如果原来发送了五个分组就可以发送第六个分组了。<br>累计确认： 对按序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都收到了。<br>GO-back-N：如果中间第三个分组丢失，接收方只能发送前两个分组的确认，发送方需要发送后面三个分组。</p><p><strong>滑动窗口协议</strong></p><p> <strong>拥塞控制</strong><br><em>@p232 拥塞控制方法 画图和慢开始 拥塞避免 快恢复@</em></p><p><strong>超时重传时间确认</strong></p><p>报文往返时间RTTS<br>新的RTTS = (1-a) x 旧RTTS + a x 新RTTS<br>a = 0.125</p><p>超时重传时间<br>RTO = RTTS + 4 x RTTD</p><p>RTTD = (1 - b) x 旧RTTD + b x | RTTS - 新的RTT |<br>b = 0,25</p><p>karn算法 只要报文段重传就不采用其往返时间<br>修正 每重传一次新的时间为旧的2倍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>seq: 序号<br><em>报文的序号和ack的对应关系</em></p><p>ack: 确认号<br>确认号为N 表明, 到序号N-1的所有数据都收到</p><p>数据偏移: 单位是四字节<br>头部长度 最少是20字节 最大是60字节 所以该项最少为5</p><p>URG: 紧急标识<br>如果TCP发送缓冲区有很多数据, 但需要紧急发送某个命令. 正常情况下会加在缓冲区位<br>如果设置了标识, 则插入到最前边</p><p>ACK: 确认号<br>TCP规定, 建立连接后所有的报文段ACK都设置为1<br><strong>可以携带数据 不携带数据则不会消耗 报文号</strong></p><p>PSH: 推送<br>接收方收到该标识后 将数据尽快提交到应用程序, 而不是等缓冲满了提交</p><p>RST: 复位<br>说明TCP连接出现严重差错  必须重新建立连接</p><p>SYN: 同步<br>连接建立时用来同步序号<br>含有此标记 不能携带数据 但<strong>仍要消耗一个序列号</strong></p><p>FIN: 终止连接</p><p>窗口:<br>发送本报文段一方的接收窗口</p><p>检验和:<br>需要加上12字节的伪首部<br><em>检验和计算</em></p><p>紧急指针:<br>指明报文段中紧急数据的字节数</p><p>MSS: 最大报文段长度, 指的是数据字段的最大长度</p><p><em>@tcp连接的建立和断开 p238@</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;?&quot;&gt;&lt;/a&gt;?&lt;/h1&gt;&lt;p&gt;物理层-以太网帧&lt;br&gt;数据链路层-MAC帧-添加了首部和尾部-FCS校验&lt;br&gt;网络层-IP数据报-首部校验和&lt;br&gt;传输层-报文,流 &lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://blog.lsmg.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="自底向上?" scheme="http://blog.lsmg.xyz/tags/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A/"/>
    
  </entry>
  
  <entry>
    <title>csapp笔记</title>
    <link href="http://blog.lsmg.xyz/2020/06/Linux-csapp140/"/>
    <id>http://blog.lsmg.xyz/2020/06/Linux-csapp140/</id>
    <published>2020-06-07T01:09:20.000Z</published>
    <updated>2020-07-30T03:10:10.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h1><p><img src="http://lsmg-img.oss-cn-beijing.aliyuncs.com/csapp/1-3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F.png" alt=""></p><p>预处理-&gt;编译-&gt;汇编-&gt;链接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1111</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, PI);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预处理<br>宏替换和注释消失 但是空行还在<br><code>g++ -E hello.cpp -o hello.i</code><br><code>tail -9 hello.i</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">5</span> <span class="string">"hello.cpp"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译 生成汇编<br><code>g++ -S hello.i</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        .file   &quot;hello.cpp&quot;</span><br><span class="line">        .text</span><br><span class="line">        .section        .rodata</span><br><span class="line">.LC1:</span><br><span class="line">        .string &quot;%f\n&quot;</span><br><span class="line">.LC2:</span><br><span class="line">        .string &quot;hello, world!&quot;</span><br><span class="line">        .text</span><br><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        subq    $16, %rsp</span><br><span class="line">        movq    .LC0(%rip), %rax</span><br><span class="line">        movq    %rax, -8(%rbp)</span><br><span class="line">        movsd   -8(%rbp), %xmm0</span><br><span class="line">        leaq    .LC1(%rip), %rdi</span><br><span class="line">        movl    $1, %eax</span><br><span class="line">        call    printf@PLT</span><br><span class="line">        leaq    .LC2(%rip), %rdi</span><br><span class="line">        call    puts@PLT</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        leave</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .section        .rodata</span><br><span class="line">        .align 8</span><br><span class="line">.LC0:</span><br><span class="line">        .long   1374389535</span><br><span class="line">        .long   1074339512</span><br><span class="line">        .ident  &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;</span><br><span class="line">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>汇编 生成 可重定位二进制目标程序<br>gcc编译器 -c参数 起到的作用是编译和汇编 -S参数 仅仅是编译<br><code>g++ -c hello.s</code></p><p>链接 生成执行文件<br><code>g++ hello.o -o hello</code></p><p>在不同进程间切换 交错执行的执行-上下文切换<br>操作系统保持进程运行所需的所有状态信息 这种状态-上下文</p><p>线程共享代码和全局数据</p><h1 id="第一部分-程序结构和执行"><a href="#第一部分-程序结构和执行" class="headerlink" title="第一部分 程序结构和执行"></a>第一部分 程序结构和执行</h1><h2 id="第二章-信息存储"><a href="#第二章-信息存储" class="headerlink" title="第二章 信息存储"></a>第二章 信息存储</h2><p>孤立地讲,单个位不是非常有用. 然而, 当把位组合在一起, 再加上某种解释,即赋予不同可能位组合不同的含义, 我们就能表示任何有限集合的元素.</p><h1 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h1><h2 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h2><p>编写高效的程序</p><ul><li>选择一组适当的算法和数据结构</li><li>编写出编译器能够有效优化以转变为高效的可执行程序的源代码</li><li>大项目的并行计算</li></ul><p>整数运算使用乘法的结合律和交换律, 当溢出的时候, 结果依然是一致的.<br>但是浮点数使用结合律和交换律的时候, 在溢出时, 结果却不是一致的.</p><p>整数的表示虽然只能编码一个相对较小的数值范围, 但是这种标识是精确地<br>浮点数能编码一个较大的数值范围, 但是这种表示只是近似的.</p><h2 id="第六章-存储器层次结构"><a href="#第六章-存储器层次结构" class="headerlink" title="第六章 存储器层次结构"></a>第六章 存储器层次结构</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-计算机系统漫游&quot;&gt;&lt;a href=&quot;#第一章-计算机系统漫游&quot; class=&quot;headerlink&quot; title=&quot;第一章 计算机系统漫游&quot;&gt;&lt;/a&gt;第一章 计算机系统漫游&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://lsmg-img.oss-cn-b
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="csapp" scheme="http://blog.lsmg.xyz/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>陀螺球</title>
    <link href="http://blog.lsmg.xyz/2020/06/%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C-%E9%99%80%E8%9E%BA%E7%90%83/"/>
    <id>http://blog.lsmg.xyz/2020/06/%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C-%E9%99%80%E8%9E%BA%E7%90%83/</id>
    <published>2020-06-02T04:50:02.000Z</published>
    <updated>2020-06-07T13:43:38.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础设计"><a href="#基础设计" class="headerlink" title="基础设计"></a>基础设计</h1><h2 id="基本玩法"><a href="#基本玩法" class="headerlink" title="基本玩法"></a>基本玩法</h2><p>使用手机陀螺仪控制圆形小球的移动.  存在各种关卡组件以及小球装备 从初始点最终到达目的地</p><p>首先考虑制作出地图编辑器<br>玩家可以下载并游玩其他人创建的地图</p><p>其次增加双人联机的功能 双人共同通关?</p><p>包含计时以及通关星数 通过碰撞获得两颗星 关卡时间一颗星</p><h2 id="关卡组件"><a href="#关卡组件" class="headerlink" title="关卡组件"></a>关卡组件</h2><table><thead><tr><th>物品代码</th><th>物品名称</th><th>物品描述</th></tr></thead><tbody><tr><td>10001</td><td>基础方块</td><td>提供基础阻挡功能</td></tr><tr><td>10002</td><td>出生点</td><td></td></tr><tr><td>10003</td><td>终点</td><td></td></tr><tr><td>10004</td><td>关卡星星</td><td>用于增加通关星数</td></tr><tr><td>10100</td><td>加速</td><td>提供一个方向的瞬时力</td></tr></tbody></table><h3 id="基础方块"><a href="#基础方块" class="headerlink" title="基础方块"></a>基础方块</h3><p>均使用int</p><p>| 10001 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z | 物品缩放X | 物品缩放Y | 物品缩放Z |</p><h3 id="出生点"><a href="#出生点" class="headerlink" title="出生点"></a>出生点</h3><p>| 10002 | 位置X | 位置Y | 位置Z |</p><h3 id="终点"><a href="#终点" class="headerlink" title="终点"></a>终点</h3><p>| 10003 | 位置X | 位置Y | 位置Z |</p><h3 id="关卡星星"><a href="#关卡星星" class="headerlink" title="关卡星星"></a>关卡星星</h3><p>| 10004 | 位置X | 位置Y | 位置Z |</p><p>增加一颗通关星1</p><p>| 10005 | 位置X | 位置Y | 位置Z |</p><p>增加一颗通关星2</p><h3 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h3><p>| 10100 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z |</p><p>提供方块对向的瞬时力</p><ul><li>用于改善体验</li><li>用于所短时间完成要求</li></ul><h3 id="传送"><a href="#传送" class="headerlink" title="传送"></a>传送</h3><p>| 10101 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z | 颜色代码 |</p><h2 id="小球装备"><a href="#小球装备" class="headerlink" title="小球装备"></a>小球装备</h2><h2 id="地图设计"><a href="#地图设计" class="headerlink" title="地图设计"></a>地图设计</h2><h1 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h1><p>创建基础方块父类</p><p>父类必要组件</p><ul><li>Static Mesh</li></ul><p>父类函数</p><ul><li>Serialize(TArray<int32>&amp; Data);</li></ul><p>必要成员变量</p><ul><li>物品代码</li><li>物品参数数量</li></ul><h2 id="地图保存"><a href="#地图保存" class="headerlink" title="地图保存"></a>地图保存</h2><p>调用各个组件的Serialize将各自的数据保存入Data</p><h2 id="地图加载"><a href="#地图加载" class="headerlink" title="地图加载"></a>地图加载</h2><p>struct Component<br>{<br>  TSubclassOf&lt;组件父类&gt; Obj<br>  int Nums 生成此组件需要的参数数量<br>}</p><p>TMap&lt;int32, Component&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础设计&quot;&gt;&lt;a href=&quot;#基础设计&quot; class=&quot;headerlink&quot; title=&quot;基础设计&quot;&gt;&lt;/a&gt;基础设计&lt;/h1&gt;&lt;h2 id=&quot;基本玩法&quot;&gt;&lt;a href=&quot;#基本玩法&quot; class=&quot;headerlink&quot; title=&quot;基本玩法&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="游戏制作" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"/>
    
    
      <category term="陀螺球" scheme="http://blog.lsmg.xyz/tags/%E9%99%80%E8%9E%BA%E7%90%83/"/>
    
  </entry>
  
  <entry>
    <title>代码大全</title>
    <link href="http://blog.lsmg.xyz/2020/05/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95130-%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    <id>http://blog.lsmg.xyz/2020/05/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95130-%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/</id>
    <published>2020-05-13T13:19:39.000Z</published>
    <updated>2020-08-02T04:37:31.212Z</updated>
    
    <content type="html"><![CDATA[<p>距离上次什么时候写博客已经记不清了, 看了眼GitHub备份记录 已经25天了. 这25天我咕了吗? 咕是不可能咕的. 这段时间我终于做出了第一个UE4比较完善的联机游戏.<br>学习了更多的muduo自己的mongo也更加完善. 只看书写博客不写代码可不行.</p><p>技术类书籍慢慢开始看了, mongo写的时间不短了.  代码大全听说是神书? 来粗读看看吧</p><h1 id="第-部分"><a href="#第-部分" class="headerlink" title="第?部分"></a>第?部分</h1><h2 id="第六章-可以工作的类"><a href="#第六章-可以工作的类" class="headerlink" title="第六章 可以工作的类"></a>第六章 可以工作的类</h2><p>使用ADT 可以实现隐藏细节, 改动不会影响到整个程序.</p><p>这点感受还是有些的. 前两天自己写VPN(目前项目暂停了)的时候, 有个Buffer类, Buffer类的核心是libevent的evbuff, 我直接使用Get方法Get到这个evbuff的指针, 然后在外部进行操作.<br>起初这样只是图简单吧, 也想到了这样会写出烂代码. 后面改动核心evbuff的时候, 发现太麻烦了, 最终改成了几个简单的接口 Append Clear等, 对外隐藏了内部是什么缓冲结构</p><p>has a  —- 组合 包含<br>is a —- 集成 epoll(select) is a mutiplexing</p><p>只有一个实例的类是值得怀疑的, 同样只有一个派生类的基类也是值得怀疑的</p><p>拷贝对象优先使用深拷贝</p><p>创建类的原因</p><ul><li>为现实世界中的对象建模</li><li>为抽象的对象建模 形状类是抽象的 不过圆 正方形等都是真实存在的</li><li>降低复杂度 一个类创建结束后, 你就可以忘掉其中的细节 使用接口即可</li><li>隔离复杂度</li><li>隐藏实现细节 限制变动的影响范围 隐藏全局数据</li><li>让参数传递更加舒畅 成员变量 </li><li>复用代码</li></ul><h2 id="第七章-高质量的子程序"><a href="#第七章-高质量的子程序" class="headerlink" title="第七章 高质量的子程序"></a>第七章 高质量的子程序</h2><p>创建子程序的正当理由</p><ul><li>降低复杂度<br>一个子程序编写完毕后, 应该可以忘记其中的细节</li><li>引入中间,易懂的抽象<br>避免代码重复  从大块的代码中抽取子程序</li><li>隐藏顺序 如果某两行代码有特定的执行顺序, 可以考虑抽取出来. 感觉这里可以推广到Mutex lock后忘记unlock 或者 Buffer中读取数据后 忘记移动指针?</li><li>提高可移植性 这点看项目了</li></ul><p>似乎过于简单没有必要写成子程序, 当然也要看情况了</p><ul><li>这里我感觉最深的还是 两行或者三行经常调用的程序, 如果重复写多次 最终告知你需要修改的时候 那可真是灾难性的消息. 实例的话: 增加参数校验等等</li></ul><p>准确的使用对仗词</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>add</td><td>remove</td></tr><tr><td>begin</td><td>end</td></tr><tr><td>create</td><td>destory</td></tr><tr><td>next</td><td>previous</td></tr><tr><td>start</td><td>stop</td></tr></tbody></table><p>如何使用子程序参数</p><ul><li>按照输入-修改-输出的顺序排列参数</li><li>如果几个子程序都是用了类似的一些参数, 应该让这些参数的排列顺序一致</li><li>使用所有的参数, 删去未使用到的参数</li><li>不要把子程序的参数用做工作变量</li></ul><p>设置函数的返回值</p><ul><li>检查所有可能的返回路径, 在函数开头设置默认返回 一个不错的选择(muduo中见到了)</li><li>老生常谈的不要返回局部对象的引用或者指针</li></ul><p>少使用宏吧 inline和typedef 不香吗, 不是肉包子也是好吃的素包子了</p><h2 id="第八章-防御式编程"><a href="#第八章-防御式编程" class="headerlink" title="第八章 防御式编程"></a>第八章 防御式编程</h2><p><del>防御式编程并不是说让你在编程时保持 “防备批评或攻击” 的态度</del></p><p>子程序不应该因为传入错误数据而被破坏</p><ul><li>检查所有源自外部数据的值</li><li>检查子程序所有输入参数的值</li><li>决定如何处理错误的输入数据</li></ul><p>使用错误处理代码来处理与其发生的状况, 使用断言来处理绝不应该发生的状况</p><p>错误处理技术 其他感觉… 用不到吧 现在不记录了</p><ul><li>返回中立值 最简单的方法, 继续执行操作并简单的返回一个没有危害的数值. 数值计算-返回0 字符串返回空串 指针返回空指针</li><li>日志打印</li><li>关闭程序</li></ul><p>隔离程序<br>两块相对独立的代码块 在交互函数见进行参数校验 过滤掉一个模块传来的非法参数</p><p>辅助调试的代码…..<br>我现在就遇到一个bug 还不知道怎么修改 与多线程有关的问题 排查真难-2020年5月18日13:11:43<br>2020年6月18日23:50:44 排查掉了 今天看到了这段话 补充上吧</p><p>决定产品最终发布的时候应该保留多少防御内容<br>防御内容越多消耗的性能越多</p><h2 id="第九章-伪代码的编程过程"><a href="#第九章-伪代码的编程过程" class="headerlink" title="第九章 伪代码的编程过程"></a>第九章 伪代码的编程过程</h2><p>原则</p><ul><li>用类似英语的句子来准确描述特定的操作</li><li>便面使用目标编程语言中的特定语法元素</li><li>在本意的层面上编写伪代码. 用伪代码描述解决问题的方法意图, 而不是去写如何用目标语言实现这个方法</li><li>在一个足够低的层次上编写伪代码, 以便近乎自动的生成代码, 如果层次过高则会隐藏细节问题</li></ul><ol><li>定义子程序要解决的问题</li></ol><ul><li>子程序将要隐藏的信息</li><li>传给子程序的各项输入, 得到的输出</li><li>调用子程序前确保相关前条件成立. 输入数据的范围正确 流已经初始化 文件已经打开或关闭</li><li>在子程序将控制权交回调用方程序之前, 确保其后条件成立. 多线程问题居多</li></ul><ol start="2"><li>为子程序命名</li><li>决定如何测试子程序</li><li>在标准库中搜寻可用的功能</li><li>考虑错误处理和效率问题</li></ol><h1 id="第三部分-变量variables"><a href="#第三部分-变量variables" class="headerlink" title="第三部分 变量variables"></a>第三部分 变量variables</h1><h2 id="第十章-使用变量的一般事项"><a href="#第十章-使用变量的一般事项" class="headerlink" title="第十章 使用变量的一般事项"></a>第十章 使用变量的一般事项</h2><p>这本书还教你做人…  分数不可能很高 因为有的概念是杜撰的!!<br>(请读第33章 个人性格 诚实一节)</p><p>位图<br>B-树<br>堆<br>栈<br>文字量<br>查找表<br>引用完整性<br>树<br>共用体<br>变体</p><ul><li>在声明的时候就进行初始化</li><li>在理想的情况下, 在靠近第一次使用变量的位置声明和定义变量</li><li>多多使用const 吧</li><li>注意计数器和累加器. 这里很久前遇到一个坑 无符号自减可能会下溢</li><li>构造函数中进行初始化</li><li>检查是否需要重新初始化</li><li>检查输入的合法性</li><li>初始化指针建议初始化为 0, 一旦你看到为0的指针越界就知道是没有赋值</li></ul><h2 id="第十一章-变量名的力量"><a href="#第十一章-变量名的力量" class="headerlink" title="第十一章 变量名的力量"></a>第十一章 变量名的力量</h2><ol><li>为循环下标 临时变量命名</li><li>bool变量<br>done-&gt;事情已经完成<br>error-&gt;有错误发生<br>found-&gt;找到<br>success/ok -&gt;某操作已经成功 不是很具体<br>Is前缀可以用在模糊不清的词前, 不过这样也会导致最终表达模糊不清</li><li>标识全局变量 使用 <code>g_</code> 前缀</li><li>标识类型声明 <code>T</code> 前缀</li><li>避免在名字中使用1 2 后缀file_1 file_2</li></ol><h2 id="第十二章-基本数据类型"><a href="#第十二章-基本数据类型" class="headerlink" title="第十二章 基本数据类型"></a>第十二章 基本数据类型</h2><ol><li>避免使用神秘数值 突然出现某个数值 这样一方面不便于修改所有值 一方面防止忘记数值含义</li><li>除零 的发生</li><li>防止溢出 这里最常见的就是循环体中了 更尤其是unsigned变量自减的时候</li><li>防范数组越界</li><li>C风格字符串的长度声明为 <code>CONSTANT+1</code>, CONSTANT是长度. 防止到时候你分不清长度是该+1还是-1还是就是本身</li></ol><p><code>if(chosen_color = 1)</code>和<code>if(chose_color = Color_Red)</code>后者枚举的使用更清楚.<br>枚举示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">  COLOR_RED,</span><br><span class="line">  COLOR_BLUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单点控制(single-pointcontrol)让程序真正软了起来, 将一个量保存在变量中. 程序中使用变量名替换这个量</p><h2 id="第十三章-不常见的数据类型"><a href="#第十三章-不常见的数据类型" class="headerlink" title="第十三章 不常见的数据类型"></a>第十三章 不常见的数据类型</h2><p>p318</p><p>引用必须总是引用一个对象, 而指针则可以指向空值.<br>引用所指向的对象在改引用初始化后不能改变</p><p>全局变量应该加以说明</p><p>全局数据隐藏到类中, 使用static</p><p>不应该吧所有数据放在一个大对象中到处传递</p><p>不要实用全局变量存放中间结果</p><h1 id="第四部分语句"><a href="#第四部分语句" class="headerlink" title="第四部分语句"></a>第四部分语句</h1><h2 id="第十四章-组织直线型代码"><a href="#第十四章-组织直线型代码" class="headerlink" title="第十四章 组织直线型代码"></a>第十四章 组织直线型代码</h2><ul><li>设法组织代码, 使依赖关系变得非常明显<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = ReadData();</span><br><span class="line">result = CalculateResultsFromData(data);</span><br><span class="line">PrintResult(result);</span><br></pre></td></tr></table></figure>这段代码看起来很舒服, 逻辑清理, 命名到位. 明显的表明了函数间的依赖关系</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revenue.ComputeMonthly();</span><br><span class="line">revenue.ComputeQuarterly();</span><br><span class="line">revenue.ComputeAnnual();</span><br></pre></td></tr></table></figure><p>这段代码, 前后依赖关系没有表现出来. 实际上计算季度收入需要先计算月收入 计算年收入需要季度收入</p><ul><li>使子程序名能凸显依赖关系</li><li>使用子程序参数明确显示依赖关系</li></ul><p>几个函数连续使用相同的参数, 说明之间极可能存在依赖关系.<br>几个函数使用不同的参数, 说明之间极可能不存在依赖关系</p><ul><li>对逻辑不清晰的代码 进行注释说明</li><li>使用断言或者错误来处理错误的调用顺序</li></ul><h2 id="第十五章-使用条件语句"><a href="#第十五章-使用条件语句" class="headerlink" title="第十五章 使用条件语句"></a>第十五章 使用条件语句</h2><p>if 语句</p><ul><li>首先写正常的代码路径, 再处理不常见的情况. 使得正确情况的执行路径在代码中是清晰的.</li><li>确保对于等量的分支是正确的(最好不要用&gt;替换&gt;= &lt;替换&lt;=) 防止off-by-one偏差一的错误. 这点emm</li><li>把正常情况的处理放在if后面 不要放在else后面 (看了眼示例代码, 对于嵌套if非常重要)</li><li><del>通用汽车公司做的分析发现 有五到八成的if语句都需要配有else语句</del></li><li>确保考虑到所有的情况, 一串if elseif之后应该加上一个else检查其他情况, 防止有未考虑到的情况</li></ul><p>case语句</p><ul><li>default语句只用来检查真正的默认情况, 而不是用来处理你认为的最后一种情况. 否则<br>你将失去case语句的标号(label)所提供的自动说明功能, 也丧失了default子句检错的能力</li><li>利用default语句来检错</li><li>case语句后没有break应该注释说明</li></ul><h2 id="第十六章-控制循环"><a href="#第十六章-控制循环" class="headerlink" title="第十六章 控制循环"></a>第十六章 控制循环</h2><ul><li>不要滥用循环下标<br>最好不要在循环体外 使用 依赖于循环下标最终取值的代码 可能会因为循环异常退出或者循环结束, 得到的下标并不是你想要的下标. 应该使用合适的变量用来标记在循环中是否遇到了你想要的情况</li><li>考虑在while循环中使用break而不是布尔标记</li><li>不要使用浮点数作为边界</li><li>使用有意义的下标变量名, 防止下标串话.</li><li>不要在循环中修改下标值</li></ul><p>下面的代码就是下标串话, 本来第二个循环应该使用j. 这种bug可能不是很容易排查出来, i和j乍一看很像.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; xxx; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  xxxx</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; j &lt;xxx; ++j)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>低效的程序员会随意做一些试验, 直到他们找到了一种看上去能工作的组合. 如果某个循环没有按照想象工作,低效的程序员可能会把<code>&lt;</code>改为<code>&lt;=</code>. 如果还不行可能把下标<code>+1</code>或者<code>-1</code>. 这样最终可能碰出正确组合, 也有可能把原来的错误改成了另一个更微妙的错误. 即使这样随意的开发过程能够产生正确的程序, 这些程序员也不明白为什么这个程序是正确的.</p><h2 id="第十七章-不常见的控制结构"><a href="#第十七章-不常见的控制结构" class="headerlink" title="第十七章 不常见的控制结构"></a>第十七章 不常见的控制结构</h2><p>递归前两天正好用过, 如果用的恰当的话 感觉很不错</p><p>我也不想去用…… =, =</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;距离上次什么时候写博客已经记不清了, 看了眼GitHub备份记录 已经25天了. 这25天我咕了吗? 咕是不可能咕的. 这段时间我终于做出了第一个UE4比较完善的联机游戏.&lt;br&gt;学习了更多的muduo自己的mongo也更加完善. 只看书写博客不写代码可不行.&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="软件开发" scheme="http://blog.lsmg.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书记录" scheme="http://blog.lsmg.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>编程规范</title>
    <link href="http://blog.lsmg.xyz/2020/05/CPP-CPP%E9%87%8D%E7%82%B9-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <id>http://blog.lsmg.xyz/2020/05/CPP-CPP%E9%87%8D%E7%82%B9-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</id>
    <published>2020-05-02T09:03:25.194Z</published>
    <updated>2020-03-05T13:58:34.793Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一点</strong><br>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><p><strong>第二点</strong><br>局部变量应当声明和初始化同时进行, 推荐使用C++11的花括号</p><p><em>如果在循环中, 不要将对象的声明放入其中</em>, 每次进入作用域都会调用构造函数, 每次退出都会调用析构函数</p><p><strong>第三点-类相关</strong><br>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p><p>不要定义隐式类型转换. </p><p>对于转换运算符和单参数构造函数, 请使用 explicit 关键字.</p><ul><li>单参数构造函数有可能会被无意地用作隐式类型转换.</li></ul><p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p><ul><li>MyClass(const MyClass&amp;) = delete;</li><li>MyClass&amp; operator=(const MyClass&amp;) = delete;</li></ul><p>仅当<code>只有</code>数据成员的时候<code>struct</code>, <code>其他一律</code>使用class</p><p>使用组合常常比使用继承更合理</p><ul><li>所有的继承<code>必须是public</code>, </li></ul><p>多重继承(真正需要的时候很少)</p><ul><li>最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.</li></ul><p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量</p><ul><li>重载运算符, 容易造成代码混乱, 因为没有统一的重载规范</li></ul><p>数据成员都必须是私有的</p><p><strong>第四点-函数相关</strong></p><p>输入参数在先, 后跟输出参数.</p><p>编写简短函数</p><p>所有按引用传递的参数必须加上 const.</p><p>函数重载</p><ul><li>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,<br>而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</li><li>如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.</li></ul><p>省却参数</p><p>函数返回类型后置语法</p><ul><li><code>auto foo(int x) -&gt; int</code> 对于简单的类型, 优点体现不出</li><li>对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别?????.</li></ul><p><strong>杂项</strong><br>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p><p><strong>第五点命名-版本最多的地方</strong></p><p>文件命名</p><ul><li>全部小写包含<code>_</code>最好</li><li>C++ 文件要以 .cc 结尾, 头文件以 .h 结尾.</li></ul><p>类型名称 - 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数</p><ul><li>类型名称的每个单词首字母均大写, 不包含下划线<code>MyExcitingClass</code></li></ul><p>变量命名</p><ul><li>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾</li></ul><p>常量命名</p><ul><li>全部大写</li><li>声明为 constexpr 或 const</li></ul><p>函数命名</p><ul><li>每个单词首字母大写, 没有下划线</li><li>首字母缩写的单词, 经常对其的第一个字母大写</li></ul><p>命名空间命名</p><ul><li>小写字母命名</li></ul><p>枚举命名</p><ul><li>枚举的命名应当和 常量 或 宏 一致</li></ul><p><strong>第六点-格式</strong></p><p>缩进四个空格</p><p>函数定义与声明</p><ul><li>左圆括号总是和函数名在同一行.(没有标准,,,,,,,,,, emmm 我想我还是换行吧)</li><li>函数名和左圆括号间永远没有空格.</li><li>圆括号与参数间没有空格.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;第一点&lt;/strong&gt;&lt;br&gt;有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. &lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题点带面</title>
    <link href="http://blog.lsmg.xyz/2020/04/CPP-Socket%E7%90%86%E8%AE%BA-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%82%B9%E5%B8%A6%E9%9D%A2/"/>
    <id>http://blog.lsmg.xyz/2020/04/CPP-Socket%E7%90%86%E8%AE%BA-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%82%B9%E5%B8%A6%E9%9D%A2/</id>
    <published>2020-04-11T03:00:20.000Z</published>
    <updated>2020-07-28T16:53:02.701Z</updated>
    
    <content type="html"><![CDATA[<p>马上步入四月中旬了, 自己对于socket理论知识知道的还是不多, 于是想了下可以整理下面试题.</p><p>单纯整理”正确答案”怎么行. 我相信大部分面试题代表的都是某个知识点 某个知识面 或有他的重要实际应用</p><p>部分题目是我自己凭空想出来的, 单独开一篇博客又不是内容足够, 索性放在一起</p><h1 id="基础api相关"><a href="#基础api相关" class="headerlink" title="基础api相关"></a>基础api相关</h1><h2 id="send发送的时候会自动转换字节序"><a href="#send发送的时候会自动转换字节序" class="headerlink" title="send发送的时候会自动转换字节序??"></a>send发送的时候会自动转换字节序??</h2><p>作为开篇问题, 我选了这个. 这个问题也算是困扰了一段时间.<br>网上的解答自然已经有了<br><a href="https://stackoverflow.com/questions/23106938/do-recv-and-send-convert-the-messages-in-network-order-format-automatically" target="_blank" rel="noopener">https://stackoverflow.com/questions/23106938/do-recv-and-send-convert-the-messages-in-network-order-format-automatically</a></p><p>最先接触到socket字节序转换相信大多是<code>htons()</code><br>这个说明是将主机字节序转换成网络字节序, 我使用的自然是小端 将小端转换成大端 反转链表就好<br>而在大端上 头文件自动选择了<code>htons()</code>空命令版本</p><p>起初我使用send发送全是 类似string的东西 char*保存, 单字节数据自然不会受字节序影响</p><p>但是最近学习了moduo后发现了发送数字的实际应用<br>对于一个 <code>int32_t</code>类型的数字需要调用<code>htobe32()</code>转换成<code>大端序</code>然后<code>std::copy</code>到buffer中<br>接收端读取出四个字节 <code>std::copy</code>到<code>int32_t</code>中, 需要调用下<code>be32toh()</code>转换成<code>小端序</code> 这就涉及到了字节序转换</p><p>总结下就是单字节数据比如发送一个字符串 是不会收到字节序影响<br>而如果你直接发送数字比如<code>int32_t</code> 就会受到影响</p><h2 id="SIGPIPE信号触发原因和防治"><a href="#SIGPIPE信号触发原因和防治" class="headerlink" title="SIGPIPE信号触发原因和防治"></a>SIGPIPE信号触发原因和防治</h2><p>client与server建立连接后 在server发送信息给client的时候, 由于client已经退出,<br>client方会向server发送RST. 此时server向已经接收到RST的client的socket继续写入数据 会导致SIGPIPE信号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listen_fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">listen_address</span>&#123;</span>&#125;;</span><br><span class="line">    listen_address.sin_family = AF_INET;</span><br><span class="line">    listen_address.sin_port = htons(<span class="number">9123</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(listen_fd, (struct sockaddr*)&amp;listen_address,</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> listen_address));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(listen_fd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line">    <span class="keyword">socklen_t</span> client_address_len = <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> client_address);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> client_fd = accept(listen_fd, (struct sockaddr*)&amp;client_address,</span><br><span class="line">            &amp;client_address_len);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">char</span> msg_first[<span class="number">20</span>] = &#123;<span class="string">"first message\n"</span>&#125;;</span><br><span class="line">    send(client_fd, msg_first, <span class="built_in">strlen</span>(msg_first), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 第一条信息发送后收到RST</span></span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">char</span> msg_second[<span class="number">20</span>] = &#123;<span class="string">"second message\n"</span>&#125;;</span><br><span class="line">    send(client_fd, msg_second, <span class="built_in">strlen</span>(msg_second), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 第二次信息发送后出现SIGPIPE</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如上 运行nc 127.0.0.1 9123后立刻按下Ctrl+C杀死client  截获的所有数据包如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[root@fish ~]# tcpdump -i lo -Xx tcp port 9123</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">00:26:27.780746 IP localhost.40580 &gt; localhost.grcp: Flags [S], seq 2027132643, win 43690, options [mss 65495,sackOK,TS val 1567772563 ecr 0,nop,wscale 7], length 0</span><br><span class="line">0x0000:  4500 003c db97 4000 4006 6122 7f00 0001  E..&lt;..@.@.a&quot;....</span><br><span class="line">0x0010:  7f00 0001 9e84 23a3 78d3 96e3 0000 0000  ......#.x.......</span><br><span class="line">0x0020:  a002 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........</span><br><span class="line">0x0030:  5d72 4f93 0000 0000 0103 0307            ]rO.........</span><br><span class="line">00:26:27.780802 IP localhost.grcp &gt; localhost.40580: Flags [S.], seq 2570863062, ack 2027132644, win 43690, options [mss 65495,sackOK,TS val 1567772563 ecr 1567772563,nop,wscale 7], length 0</span><br><span class="line">0x0000:  4500 003c 0000 4000 4006 3cba 7f00 0001  E..&lt;..@.@.&lt;.....</span><br><span class="line">0x0010:  7f00 0001 23a3 9e84 993c 41d6 78d3 96e4  ....#....&lt;A.x...</span><br><span class="line">0x0020:  a012 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........</span><br><span class="line">0x0030:  5d72 4f93 5d72 4f93 0103 0307            ]rO.]rO.....</span><br><span class="line">00:26:27.780839 IP localhost.40580 &gt; localhost.grcp: Flags [.], ack 1, win 342, options [nop,nop,TS val 1567772563 ecr 1567772563], length 0</span><br><span class="line">0x0000:  4500 0034 db98 4000 4006 6129 7f00 0001  E..4..@.@.a)....</span><br><span class="line">0x0010:  7f00 0001 9e84 23a3 78d3 96e4 993c 41d7  ......#.x....&lt;A.</span><br><span class="line">0x0020:  8010 0156 fe28 0000 0101 080a 5d72 4f93  ...V.(......]rO.</span><br><span class="line">0x0030:  5d72 4f93                                ]rO.</span><br><span class="line"></span><br><span class="line">三次握手结束后 由于立刻按下了Ctrl+C 客户端连接异常结束 发送FIN</span><br><span class="line"></span><br><span class="line">00:26:27.969734 IP localhost.40580 &gt; localhost.grcp: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 1567772752 ecr 1567772563], length 0</span><br><span class="line">0x0000:  4500 0034 db99 4000 4006 6128 7f00 0001  E..4..@.@.a(....</span><br><span class="line">0x0010:  7f00 0001 9e84 23a3 78d3 96e4 993c 41d7  ......#.x....&lt;A.</span><br><span class="line">0x0020:  8011 0156 fe28 0000 0101 080a 5d72 5050  ...V.(......]rPP</span><br><span class="line">0x0030:  5d72 4f93                                ]rO.</span><br><span class="line"></span><br><span class="line">服务端回复收到FIN</span><br><span class="line"></span><br><span class="line">00:26:27.970294 IP localhost.grcp &gt; localhost.40580: Flags [.], ack 2, win 342, options [nop,nop,TS val 1567772753 ecr 1567772752], length 0</span><br><span class="line">0x0000:  4500 0034 8f0d 4000 4006 adb4 7f00 0001  E..4..@.@.......</span><br><span class="line">0x0010:  7f00 0001 23a3 9e84 993c 41d7 78d3 96e5  ....#....&lt;A.x...</span><br><span class="line">0x0020:  8010 0156 fe28 0000 0101 080a 5d72 5051  ...V.(......]rPQ</span><br><span class="line">0x0030:  5d72 5050                                ]rPP</span><br><span class="line"></span><br><span class="line">第一次写入信息</span><br><span class="line"></span><br><span class="line">00:26:32.781104 IP localhost.grcp &gt; localhost.40580: Flags [P.], seq 1:15, ack 2, win 342, options [nop,nop,TS val 1567777564 ecr 1567772752], length 14</span><br><span class="line">0x0000:  4500 0042 8f0e 4000 4006 ada5 7f00 0001  E..B..@.@.......</span><br><span class="line">0x0010:  7f00 0001 23a3 9e84 993c 41d7 78d3 96e5  ....#....&lt;A.x...</span><br><span class="line">0x0020:  8018 0156 fe36 0000 0101 080a 5d72 631c  ...V.6......]rc.</span><br><span class="line">0x0030:  5d72 5050 6669 7273 7420 6d65 7373 6167  ]rPPfirst.messag</span><br><span class="line">0x0040:  650a                                     e.</span><br><span class="line"></span><br><span class="line">收到客户端返回的复位RST</span><br><span class="line"></span><br><span class="line">00:26:32.781155 IP localhost.40580 &gt; localhost.grcp: Flags [R], seq 2027132645, win 0, length 0</span><br><span class="line">0x0000:  4500 0028 0000 4000 4006 3cce 7f00 0001  E..(..@.@.&lt;.....</span><br><span class="line">0x0010:  7f00 0001 9e84 23a3 78d3 96e5 0000 0000  ......#.x.......</span><br><span class="line">0x0020:  5004 0000 dffd 0000                      P.......</span><br><span class="line"></span><br><span class="line">第二次写入信息触发 SIGPIPE</span><br></pre></td></tr></table></figure><p>方式SIGPIPE中断进程使用<code>signal(SIGPIPE, SIG_IGN)</code>忽略这个信号, 这时send会返回-1并设置errno=EPIPE</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;马上步入四月中旬了, 自己对于socket理论知识知道的还是不多, 于是想了下可以整理下面试题.&lt;/p&gt;
&lt;p&gt;单纯整理”正确答案”怎么行. 我相信大部分面试题代表的都是某个知识点 某个知识面 或有他的重要实际应用&lt;/p&gt;
&lt;p&gt;部分题目是我自己凭空想出来的, 单独开一篇博
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="Socket理论" scheme="http://blog.lsmg.xyz/categories/CPP/Socket%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux多线程服务器端编程</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95120-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95120-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-03-31T09:19:39.000Z</published>
    <updated>2020-04-27T05:57:55.667Z</updated>
    
    <content type="html"><![CDATA[<p>Linux高性能服务器编程基本看玩了, 现在需要进行实战练习, 然而从单纯的只会api到做出项目, 之间的距离<br>不是一般的小, 最终我选择了这本书…..</p><p>相关自己写的代码 大部分放在github 少部分会写在博客中</p><h1 id="第一部分-C-多线程系统编程"><a href="#第一部分-C-多线程系统编程" class="headerlink" title="第一部分 C++多线程系统编程"></a>第一部分 C++多线程系统编程</h1><h2 id="第一章-线程安全的对象生命期管理"><a href="#第一章-线程安全的对象生命期管理" class="headerlink" title="第一章 线程安全的对象生命期管理"></a>第一章 线程安全的对象生命期管理</h2><p>一个线程安全的class需要满足的条件</p><ul><li>多个线程同时访问, 其表现出正确的行为</li><li>无论操作系统如何调度这些线程, 无论这些线程的执行顺序如何交织</li><li>调用端代码无需额外的同步或其他协调操作</li></ul><p>对象构造的安全, 在构造期间不要泄露this指针, 如果不按照以下规定可能会早对象构造完成前就被访问</p><ul><li>不要在构造函数中注册任何回调</li><li>不要在构造函数中把this传给跨线程的对象</li><li>即便在构造函数最后一行也不行, 因为对象可能是一个父类, 会先构造父类部分, 再构造子类部分</li></ul><p>二段式构造有时候可以解决上面的问题</p><p>二段式构造-构造函数+initialize()<br>因为构造函数没有办法告知是否构造成功, 如果使用异常处理将会使代码复杂化.<br>比如在构造函数中使用new操作, 如果new操作失败就会出现不可预料的后果, 然后外部却无法知道<br>再比如将this传给其他跨线程对象, 如果构造结束前传入, 可能就会发生问题</p><p><strong>shared_ptr的引出</strong><br>如果在一个对象中通过指针访问资源(另一个对象), 知道这个资源是否活着是很难的.<br>如果简单的判断指针是否为空, 可能会在线程B已经判断了指针不为空还没有执行后续操作时, 线程A就把<br>这个资源释放掉了</p><p>当然可以通过资源管理对象 管理上面的资源, 但是也存在上面的问题.</p><p>所以要想安全的销毁对象最好在其他线程都看不到的情况下偷偷进行. (垃圾回收原理, 所有人用不到的东西一定是垃圾)</p><p>所以可以再资源管理对象中增加引用计数, 外部对象在释放资源管理对象中资源的时候, 只是将引用计数减一, 当引用计数为0的时候 在进行释放.</p><p>C++可能出现的内存问题</p><ul><li>缓冲区溢出<br>使用<code>std::vector&lt;char&gt;/std::string</code>或者自己编写<code>Buffer Class来管理缓冲区</code>. 记住缓冲区长度, 通过成员函数而不是裸指针修改缓冲区</li><li>空悬指针/野指针<br>使用shared_ptr/weak_ptr</li><li>重复释放<br>使用scoped_ptr, 只在对象析构的时候释放一次</li><li>内存泄漏<br>使用scoped_ptr, 对象析构时自动释放内存</li><li>不配对的new[]/delete<br>把new[] 统统替换成std::vector, scoped_array</li><li>内存碎片</li></ul><p>使用智能指针存在的一些问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) :name_(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Register</span><span class="params">(<span class="built_in">std</span>::weak_ptr&lt;Book&gt; book)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        books_.push_back(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckBook</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 锁争用</span></span><br><span class="line">        <span class="comment">// 这里开头上锁 很可能影响其他的函数, 因为这里调用了用户提供的函数, 等待时间可能会非常长</span></span><br><span class="line">        <span class="comment">// 比如Register函数就没有办法在这段时间中插入新的book</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// mutex lock 开头上锁 保护vector</span></span><br><span class="line">        Iterator iter = books_.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != books_.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; <span class="title">obj</span><span class="params">(iter-&gt;lock())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (obj)</span><br><span class="line">            &#123;</span><br><span class="line">                obj-&gt;DoSomething();</span><br><span class="line">                iter++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                iter = books_.erase(iter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 这样就强制要求了Book必须以shared_ptr管理</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::weak_ptr&lt;Book&gt;&gt;::iterator Iterator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在对象的成员变量vector中保存shared_ptr 会导致管理的资源无法被释放, 因为引用计数最少为1.<br>如果保存weak_ptr可能会导致vector只增不减, 因为weak_ptr只管自己管理的资源, 不管自己.<br>通过定制shared_ptr的析构函数可以解决这个问题</p><p>如果将某个类的this指针 bind到一个function对象, 可能在函数调用时传进入一个已经被释放的对象地址<br>建议使用shared_ptr解决上面的问题, 如果想要获得this指针对应的shared_ptr, 可以另类继承<br><code>enable_shared_from_this&lt;T&gt;</code>, 通过在bind函数绑定<code>shared_from_this()返回的shared_ptr</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span>:</span><span class="built_in">std</span>::enable_shared_from_this&lt;BookShelf&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Book对象固然可以销毁, 但是出现了轻微的内存泄漏</span></span><br><span class="line">    <span class="comment">// book_只增不减!!!!. 虽然Book对象销毁了但是book_中依然保存着weak_ptr</span></span><br><span class="line">    <span class="comment">// 所以需要定制析构功能</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; <span class="title">GetBook</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;bookname)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; pbook;</span><br><span class="line">        <span class="comment">// 上锁</span></span><br><span class="line">        <span class="built_in">std</span>::weak_ptr&lt;Book&gt;&amp; wkbook = books_[bookname];</span><br><span class="line">        pbook = wkbook.lock();</span><br><span class="line">        <span class="keyword">if</span> (!pbook)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// pbook.reset(new Book(bookname));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 依然有问题 绑定this指针可能到时候this指向的对象已经不复存在了</span></span><br><span class="line">            <span class="comment">// pbook.reset(new Book(bookname),</span></span><br><span class="line">            <span class="comment">//   std::bind(&amp;BookShelf::DeleteBook, this, std::placeholders::_1));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意shared_from_this不能在构造函数中调用, 因为构造Bookshelf的时候 他还没有</span></span><br><span class="line">            <span class="comment">// 被交给shared_ptr管理</span></span><br><span class="line">            pbook.reset(<span class="keyword">new</span> Book(bookname),</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;BookShelf::DeleteBook, shared_from_this(), <span class="built_in">std</span>::placeholders::_1));</span><br><span class="line"></span><br><span class="line">            wkbook = pbook;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pbook;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteBook</span><span class="params">(Book* book)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (book)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 上锁</span></span><br><span class="line">            books_.erase(book-&gt;GetName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而上面的代码依然有问题<br>依然有个问题. BookShelf的生命期似乎被意外延长了, 他不会短于function对象<br>所以改用weak_pr不就可以了吗</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span>:</span><span class="built_in">std</span>::enable_shared_from_this&lt;BookShelf&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; <span class="title">GetBook</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;bookname)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; pbook;</span><br><span class="line">        <span class="built_in">std</span>::weak_ptr&lt;Book&gt;&amp; wkbook = books_[bookname];</span><br><span class="line">        pbook = wkbook.lock();</span><br><span class="line">        <span class="keyword">if</span> (!pbook)</span><br><span class="line">        &#123;</span><br><span class="line">            pbook.reset(<span class="keyword">new</span> Book(bookname),</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;BookShelf::WkDeleteCallback,</span><br><span class="line">                    <span class="built_in">std</span>::weak_ptr&lt;BookShelf&gt;(shared_from_this()),</span><br><span class="line">                    <span class="built_in">std</span>::placeholders::_1));</span><br><span class="line"></span><br><span class="line">            wkbook = pbook;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pbook;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WkDeleteCallback</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::weak_ptr&lt;BookShelf&gt; wk_shelf, Book* book)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;BookShelf&gt; <span class="title">bookshelf</span><span class="params">(wk_shelf.lock())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (bookshelf)</span><br><span class="line">        &#123;</span><br><span class="line">            DeleteBook(book);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteBook</span><span class="params">(Book* book)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (book)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 上锁</span></span><br><span class="line">            books_.erase(book-&gt;GetName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一章已经读完了, 笔记只有上面那点. 我在学习Linux高性能服务器编程的大二上半年时间照着书边读边写笔记, 然后后来到了大二下我改成了读完一部分后脑中有什么记什么, 重要的地方如果记不清写不出来就去再看一下. 这样花费在记笔记的时间就少了很多, 写出来的笔记更加方便自己阅读.</p><p>第一章部分内容能看懂 真是谢了之前看的那个项目代码, 那个项目中大量使用了智能指针, 我在读哪个项目的代码的时候查了不少的东西, 现在才能看懂第一章的部分东西.<br>然而大部分?的东西感觉还是似懂非懂, 想写又写不出什么来. 我对于智能指针的使用还是过于晚了把.</p><p>第一章看来后续还要读一遍了</p><h2 id="第二章-线程同步精要"><a href="#第二章-线程同步精要" class="headerlink" title="第二章 线程同步精要"></a>第二章 线程同步精要</h2><p><strong>线程同步的四项原则</strong><br>按重要性排列</p><ol><li>最低限度的共享对象, 减少需要同步的场合, <em>不用就不需要同步了nice!!!</em></li><li>使用高级的并发编程构建, 线程池, 队列, 倒计时</li><li>不得已使用底层同步原语时, 只使用非递归的互斥器和条件变量, 慎用读写锁, 不要用信号量</li><li>除了使用atomic整数外, 不要自己编写lock-free代码, 也不要用内核级的同步原语. 不凭空猜测<br>哪种做法性能更好 比如自旋锁和互斥锁</li></ol><p><strong>互斥器 mutex</strong><br>使用mutex的原则</p><ul><li>使用RAII手法封装mutex的创建销毁加锁解锁这四个操作, 不会因异常而忘记解锁</li><li>只使用非递归的mutex即不可重入的mutex<br>容易排查错误 使用递归mutex问题可能出现也可能不出现(可能由于逻辑问题对一个mutex加锁两次), 而使用非递归即可发现错误并改正</li><li>不手工调用lock()和unlock() 函数, <em>一切交给栈上的Guard对象的构造和析构函数负责</em></li><li>Gruad对象的生命期正好等于临界区</li></ul><p>次要原则</p><ul><li>不使用跨进程的mutex, 进程间通信只用TCP sockets</li><li>加锁解锁在同一个线程 不会出现跨线程的操作 (RAII自动保证)</li><li>不忘记解锁(包括各种提前返回和异常抛出) 不重复解锁 均由RAII自动保证</li><li>必要时考虑用PTHREAD_MUTEX_ERRORCHECK来排错</li></ul><p><strong>封装MutexLock MutexLockGuard Condition</strong><br>在Linux高性能服务器编程中 我也看过了封装mutex, 不过当时并没有使用RAII<br>从这里开始算是对RAII(Resource Acquisition Is Initialization)有了了解</p><p><a href="https://zh.cppreference.com/w/cpp/language/raii" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/language/raii</a><br>拥有open()/close()、lock()/unlock()，或 init()/copyFrom()/destroy()成员函数的类是非RAII类的典型例子</p><p>RAII将资源封装入一个类 如MutexLock类</p><ul><li>构造函数请求资源, 建立所有类不变式, 或在无法完成时抛出异常</li><li>析构函数释放资源并绝不抛出异常<br>始终经由RALL类的实例使用满足要求的资源如MutexLockGuard类, 资源需满足</li><li>自身拥有自动存储期或临时生存期</li><li>或具有与自动或临时对象的生存期绑定的生存期</li></ul><p>自己的理解就是经由RAII类生存期管理资源, RAII生存期开始即使用资源,<br>当RAII类生存期结束, RAII类中保存着的资源也自动销毁<br>RAII可以有效防止上面那些成对函数调用前一个后 由于异常抛出提前返回等 后一个函数没有被调用 造成资源状态异常</p><p><strong>线程安全的Singleton实现</strong><br>这个类在 flamingo 中也见到了, 这次是升级版<br>借由pthread_once保证线程安全</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_once(&amp;ponce_, Init);</span><br><span class="line">        <span class="keyword">return</span> *value_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value_ = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_once_t</span> ponce_;</span><br><span class="line">    <span class="keyword">static</span> T *value_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">pthread_once_t</span> Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p><strong>copy-on-write?? copy-on-other-write!!</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; Entry;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Entry&gt; EntryList;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, EntryList&gt; Map;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Map&gt; MapPtr;</span><br><span class="line"></span><br><span class="line">MapPtr data_;</span><br></pre></td></tr></table></figure><p>好的现在数据存储在data_ 中 系统中存在多个读线程和一个写线程 针对data_<br>如果写线程不管不顾 有数据就往data_中写入 出现了读写进程同时访问data_就会出问题.<br>就书中描述来意思来说 不用大刀阔斧的使用读写锁, 能用mutex简单解决为什么要用读写锁.<br>那么如何保证读写安全呢?</p><p>当读进程读的时候 拷贝一次data_ data_的引用计数至少为2.<br>就在这时写进程判断 data_引用计数不为1, 于是拷贝原来指向的map, 然后将data_ reset指向新的map<br>这时data_引用计数变为1 可以正常写了. 而读进程中保存的map拷贝是稍久的 引用计数降为1, 执行完后就自动析构了旧数据</p><p>下面的代码 读部分只在GetData中加锁, 缩小了临界区</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MapPtr <span class="title">GetData</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// binding reference of type ‘MutexLock&amp;’ to ‘const MutexLock’ discards qualifiers</span></span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CustomerData::Query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;custmoner, <span class="keyword">const</span> <span class="built_in">string</span> &amp;stock)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MapPtr data = GetData();</span><br><span class="line">    Map::const_iterator entries = data-&gt;<span class="built_in">find</span>(custmoner);</span><br><span class="line">    <span class="keyword">if</span> (entries != data-&gt;<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FindEntry(entries-&gt;second, stock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CustomerData::Update</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;customer, <span class="keyword">const</span> CustomerData::EntryList &amp;entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!data_.unique())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MapPtr <span class="title">new_data</span><span class="params">(<span class="keyword">new</span> Map(*data_))</span></span>;</span><br><span class="line">        data_.swap(new_data);</span><br><span class="line">        <span class="comment">// sawp后 先前某个线程通过GetData拿到MapPtr 他会读到稍旧的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(data_.unique());</span><br><span class="line">    (*data_)[customer] = entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三章-多线程服务器的适用场合与常用编程模型"><a href="#第三章-多线程服务器的适用场合与常用编程模型" class="headerlink" title="第三章 多线程服务器的适用场合与常用编程模型"></a>第三章 多线程服务器的适用场合与常用编程模型</h2><p>单线程服务器常用的编程模型<br><code>non-blocking IO + IO multiplexing</code> 即为<code>Reactor模式</code><br>程序的基本结构是一个事件循环, 以事件驱动和事件回调的方式实现业务逻辑</p><p>本质的缺点<br>要求事件回调函数必须是非阻塞的, 单线程还阻塞 这还怎么玩…<br>对于涉及网络IO的请求响应式协议, 容易割裂业务逻辑, 使其散布于多个回调函数中</p><p>多线程服务器常用编程模型</p><ol><li>每个请求创建一个线程, 使用阻塞式IO操作</li><li>使用线程池, 同样是阻塞式IO操作</li><li>非阻塞IO + IO多路复用 即Java NIO方法</li><li>领导者追随者等高级模式</li></ol><p>推荐的C++多线程服务器端编程模式为 one (event) loop per thread + thread pool<br>一个线程一个事件循环 + 线程池<br>事件循环用作IO多路复用, 配合非阻塞IO和定时器<br>线程池用作计算, 具体可以是任务队列或生产者消费者队列</p><p>必须使用单线程的场合</p><ul><li>程序可能会fork</li><li>限制程序的CPU占用率 一个线程最多占满一个核心</li></ul><p>适用多线程程序的场景</p><ul><li>有多个CPU可用, 单核机器上多线程没有性能优势</li><li>线程间有共享数据, 否则建议使用 主进程+工作进程 每个进程都是单线程的模型</li><li>共享数据是可以修改的. 如果数据不能修改可以进程间使用共享内存</li><li>事件响应有优先级差异, 防止优先级反转</li><li>程序要有相当的计算量</li><li>利用异步操作</li><li>能享受到增加CPU数目带来的好处</li><li>多线程有有效地划分责任与功能</li></ul><p>后面大部分我都是看看就过去了, 自己没有丝毫经验 也不打算现在细看</p><h2 id="第四章-C-多线程系统编程精要"><a href="#第四章-C-多线程系统编程精要" class="headerlink" title="第四章 C++多线程系统编程精要"></a>第四章 C++多线程系统编程精要</h2><p>学习多线程编程面临的最大思维方式转变</p><ul><li>当前进程随时可能被切出去</li><li>多线程程序中事件的发生顺序不再有全局统一的先后关系</li></ul><p>常用的11个pthreads函数</p><ul><li>pthread_create() pthread_join()</li><li>pthread_mutex_(create/destory/lock/unlock)</li><li>pthread_cond_(create/destory/wait/signal/broadcast)</li></ul><p>多线程系统编程的难点不在于学习线程原语, 而在于理解多线程与现有的C/C++库函数和系统调用的交互关系<br>以进一步学习如何设计并实现线程安全且高效的程序</p><p>pthread_t并不适合作为程序中对线程的标识符</p><ul><li>他可能会同一进程的两个线程相同</li><li>或者是不利于打印</li><li>无法判断其是否非法</li><li>文件系统中没有对应项</li><li>脱离进程便没意义</li></ul><p>推荐使用gettid()作为线程标识符</p><ul><li>任何时刻都是全局唯一的</li><li>类型为pid_t通常为一个小整数利于在日志中打印.</li><li>0就是非法值1, 因为操作系统第一个进程init的pid是1</li><li>在现代Linux中, 他直接表示内核的任务调度id, 容易在/proc文件系统中找到对应项</li><li>在其他系统工具中也容易定位到某一个具体线程, 列如使用top按线程列出任务,<br>便可以找到线程id, 再根据程序日志判断是哪一个具体线程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">extern</span> __thread <span class="keyword">int</span> t_cachedTid;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cacheTid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(t_cachedTid == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cacheTid();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t_cachedTid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line">__thread <span class="keyword">int</span> t_cachedTid = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CurrentThread::cacheTid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t_cachedTid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t_cachedTid = gettid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">gettid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">pid_t</span>&gt;(::syscall(SYS_gettid));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>thread<br>只能修饰POD类型, 不能修饰class类型, 因为无法自动调用构造析构函数. 可以用于修饰全局变量函数内的静态变量.是GCC内置的线程局部存储设施，存取效率可以和全局变量相比。</strong>thread变量每一个线程有一份独立实体，各个线程的值互不干扰.</p><p><strong>builtin_expect<br>这个指令是gcc引入的，作用是允许程序员将最有可能执行的分支告诉编译器。这个指令的写法为：</strong>builtin_expect(EXP, N)。<br>意思是：EXP==N的概率很大. 就图中代码翻译过来就是 <code>t_cachedTid == 0</code>为<code>0(假)</code>, 即为<code>t_cachedTid</code>最可能不是0.</p><ul><li>使用同一个class创建线程, 全局统一. 一般不会为每个网络连接创建线程, 除非并发数与cpu数目相同<br>一个服务程序的线程数目应该与当前负载无关, 而应该有CPU数目有关.</li><li>程序运行期间不要再创建和销毁线程, 最好在初始化的时候创建所有的线程</li></ul><p>线程销毁的方式</p><ul><li>正常死亡, 从线程主函数返回, 线程正常退出</li><li>非正常死亡, 从线程主函数抛出异常或线程触发segfault信号等非法操作</li><li>自杀 调用pthread_exit() 立刻终止线程</li><li>他杀 其他线程调用pthread_cancel() 来强制终止某个线程</li></ul><p>线程只有一种正常死亡方式, 即第一种 其他方法都是错的Java中甚至把相关函数都废弃了</p><p>每个文件描述符只由一个线程操作, 从而解决消息收发的顺序问题, 把一个文件描述符读写分开未必会提高性能. 同时我们不知道epoll_wait阻塞的时候, 其他线程添加新的fd会发生什么. 为了稳妥起见应该把对同一个epollfd的操作放入同一个线程中执行.</p><p><strong>包装文件描述符和连接</strong><br>用Socket对象包装文件描述符<br>所有对此文件描述符的读写操作都通过此对象进行, 对象的析构函数里关闭文件描述符. 这样只要Socket对象还活着 就不会与其他Socket对象有相同的文件描述符, 也就不会发生串话. 包装文件描述符已经见过了, 同样是在flamingo中看到的.</p><p>用Tcpconnection包装连接<br>如果仅仅记住 fd = 8 这样的文件描述符, A线程accept后转身去处理业务B线程把 fd = 8 给关闭了!! 同时accept一个新的fd 同样是8!!. 这时A线程回复就会出现问题. 所以应该持有封装了Socket对象的Tcpconnection, 保证请求处理期间 文件描述符不会被关闭. 或者是持有Tcpconnection的弱引用. 这样就能知道 fd = 8 到底是原来的还是被关闭后新创建的. Tcpconnection对象不能提前销毁, 所以使用了shared_ptr来管理其生存期, 保证不会提前销毁造成串话.</p><h2 id="第五章-高效的多线程日志"><a href="#第五章-高效的多线程日志" class="headerlink" title="第五章 高效的多线程日志"></a>第五章 高效的多线程日志</h2><p>日志库大体分为前端和后端两部分, 两端之间的联系可能简单到只有一个函数<br>大多数感觉都是宏命令</p><p>日志的滚动也很重要 根据文件大小 和 时间 自动创建新的日志文件, 而不是全写入一个文件中</p><p>避免出现正则表达的元字符(列如我最喜欢的<code>&#39;[&#39;和&#39;]&#39;</code>) 便于使用正则表达式查找</p><p>这一章的笔记是在我照着代码实现了简单的相似功能后才写的, 记录一下好的地方<br>大体分为了 LogStream类和Logger类 前者负责通过<code>&lt;&lt;</code>维护LogBuffer缓冲区, 后者做包装提供接口<br>LogBuffer使用了简单的数组作为缓冲区, 使用Append添加内容 维护写指针</p><p>LogStream重载了多种 参数情况, char和char* 很方便写入到缓冲区中<br>数字则需要转化成字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(short num);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> short num);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span> num);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> num);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">long</span> num);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> <span class="keyword">long</span> num);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">long</span> <span class="keyword">long</span> num);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> num);</span><br><span class="line"></span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">char</span> str);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">const</span> <span class="keyword">char</span>* str);</span><br></pre></td></tr></table></figure><p>转化函数, 不得不说设计的真好. 通过模板解决了多种数字类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> digits_character[] = <span class="string">"0123456789"</span>;</span><br><span class="line"><span class="comment">// LEARN https://www.drdobbs.com/flexible-c-1-efficient-integer-to-string/184401596</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">Convert</span><span class="params">(<span class="keyword">char</span> buff[], T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T i = value;</span><br><span class="line">    <span class="keyword">char</span>* p = buff;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> lsd = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(i % <span class="number">10</span>);</span><br><span class="line">        i /= <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// *p++ = '0' + lsd; 不高效</span></span><br><span class="line">        *p++ = digits_character[lsd];</span><br><span class="line">    &#125; <span class="keyword">while</span> (i != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p++ = <span class="string">'-'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LEARN 原文中是从buff最后一个字节开始写入 但是这里需要从开头写入 所以改为倒置一下</span></span><br><span class="line">    <span class="built_in">std</span>::reverse(buff, p);</span><br><span class="line">    <span class="keyword">return</span> p - buff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LogStream::FormatInteger</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer_.WriteableBytes() &gt; MAX_NUMBER_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> len = Convert(buffer_.WritePeek(), t);</span><br><span class="line">        buffer_.MoveWritePeek(len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将格式化也单独出了一个类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fmt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Fmt(<span class="keyword">const</span> <span class="keyword">char</span>* fmt, T val);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetData</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buff_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> buff_[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">size_t</span> length_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Fmt::Fmt(<span class="keyword">const</span> <span class="keyword">char</span>* fmt, T val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_arithmetic&lt;T&gt;::value == <span class="literal">true</span>, <span class="string">"Must be arithmetic type"</span>);</span><br><span class="line">    length_ = <span class="built_in">snprintf</span>(buff_, <span class="keyword">sizeof</span> buff_, fmt, val);</span><br><span class="line">    assert(length_ &lt; <span class="keyword">sizeof</span> buff_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Logger类的设计<br>方便了日志的打印, 实现了高效的转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> LogLevel</span><br><span class="line">&#123;</span><br><span class="line">    DEBUG,</span><br><span class="line">    INFO,</span><br><span class="line">    WARN,</span><br><span class="line">    ERROR,</span><br><span class="line">    FATAL,</span><br><span class="line">    NUM_LOG_LEVELS <span class="comment">/* 仅用于表示LogLevel元素个数 不做实际使用 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// LEARN 处处保持长度一致 使用NUM_LOG_LEVELS表示大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* LogLevelName[Logger::NUM_LOG_LEVELS] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"DEBUG "</span>,</span><br><span class="line">    <span class="string">"INFO  "</span>,</span><br><span class="line">    <span class="string">"WARN  "</span>,</span><br><span class="line">    <span class="string">"ERROR "</span>,</span><br><span class="line">    <span class="string">"FATAL "</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字符串指针包装类, 减少strlen的调用 或者字符串没有终止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LEARN 临时包装字符串指针和长度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    T(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len):</span><br><span class="line">    str_(str),</span><br><span class="line">    len_(len)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(<span class="built_in">strlen</span>(str) == len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str_;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> len_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用内部类Impl包装了LogStream LogStream负责的是单纯的维护缓冲区 重载各种运算符.<br>Impl的构造函数输出了日志前边的固定部分<br>Logger的构造函数负责根据有无函数名等重载输出额外的固定内容<br>构造和析构之间完成 纯用户自定义部分输出<br>Logger的析构函数负责输出每条日志的结尾部分 文件名和行号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Logger::LogLevel LogLevel;</span><br><span class="line">    Impl(LogLevel level, <span class="keyword">const</span> SourceFile&amp; file, <span class="keyword">int</span> <span class="built_in">line</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FormatTime</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Timestamp time_;</span><br><span class="line">    LogStream stream_;</span><br><span class="line">    LogLevel level_;</span><br><span class="line">    SourceFile filename_;</span><br><span class="line">    <span class="keyword">int</span> line_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内部类SourceFile负责将<code>__FILE__</code>宏产生的字符数组转换成单纯的文件名. 使用了数组引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SourceFile</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 数组的引用 使数组在传参时不会降为 指针</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</span><br><span class="line">    SourceFile(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;arr)[N]):</span><br><span class="line">    data_(arr),</span><br><span class="line">    size_(N - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="built_in">strrchr</span>(data_, <span class="string">'/'</span>); <span class="comment">/* /name */</span></span><br><span class="line">        <span class="keyword">if</span> (name)</span><br><span class="line">        &#123;</span><br><span class="line">            data_ = name + <span class="number">1</span>;</span><br><span class="line">            size_ -= <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(data_ - arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* data_;</span><br><span class="line">    <span class="keyword">int</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其他高效设计</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LEARN 缓存上一次输出的秒 同一秒输出时避免多次格式化</span></span><br><span class="line"><span class="comment">// 同一秒输出仅仅格式化 微秒部分</span></span><br><span class="line">__thread <span class="keyword">char</span> t_time[<span class="number">64</span>];</span><br><span class="line">__thread <span class="keyword">time_t</span> t_last_second;</span><br></pre></td></tr></table></figure><h1 id="第二部分-muduo网络库"><a href="#第二部分-muduo网络库" class="headerlink" title="第二部分 muduo网络库"></a>第二部分 muduo网络库</h1><h2 id="第六章-muduo网络库简介"><a href="#第六章-muduo网络库简介" class="headerlink" title="第六章 muduo网络库简介"></a>第六章 muduo网络库简介</h2><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/ClassDiagram.png" alt=""></p><p>看完前面的一小部分, 我真心觉得这个库跟之前那个flamingo特别像, 估计这种管理方式就是某种主流方式?<br>估计我以后自己写的时候也是会按照这个模式来写了吧</p><p>TCP网络编程最本质的是处理三个半事件</p><ul><li>连接的建立</li><li>连接断开 主动断开close 被动断开 read返回0</li><li>消息到达, 文件描述符可读. 最为重要的一个事件, 对它的处理方式决定了网络编程的风格.(阻塞还是非阻塞, 如何处理分包, 应用层缓冲如何设计)</li><li>消息发送完毕 这算半个</li></ul><p>现在存在的问题</p><ul><li>如果保证发送完应用层缓冲区数据才断开连接<br>自己思考的可以设立标志位, 如果设置了标志位发送完成后检测标志位 关闭连接</li><li>如果要主动发起连接, 但是对方主动拒绝, 如何定期重试<br>按照TCP重试机制 发送SYN 开启定时器 如果定时内没有收到确认ACK则重发SYN</li></ul><p>这里了解到一个词 前向声明,<br>在程序设计中，前向声明（Forward Declaration）是指声明标识符(表示编程的实体，如数据类型、变量、函数)时还没有给出完整的定义。<br>通常为了简化头文件的关系 可以在A的头文件中 声明<code>class B</code>, 这样在你的代码中就可以使用<code>B*</code>而不需要引入B的头文件</p><h2 id="第七章-muduo编程示例"><a href="#第七章-muduo编程示例" class="headerlink" title="第七章 muduo编程示例"></a>第七章 muduo编程示例</h2><p>本章大部分都是实战小例子, 自然要在代码中注释了.<br>博客这里就简单写一写<br><strong>关于<code>input buffer</code>和<code>output buffer</code>已经有所了解过</strong></p><p><code>output buffer</code>在<code>write</code>调用一次没有发送完全的时候起到大用途. 一次没有发送完不应该等待在那里, 应该是接管这些未发送的数据, 阻塞代价是很大的. 应该是注册<code>EPILOUT</code>事件, 直到数据全部发送完毕. 否则就一直注册事件, 当然这是在连接正常的时候.<br>使用<code>output buffer</code>还有一个小问题, 一般情况下一次发送未完成才会使用到<code>output buffer</code>. 当缓冲区中存在数据的时候. 下一次的数据不能进行发送, 而应该是直接追加到尾部.</p><p><code>input buffer</code>某种意义上作用更大, 这涉及到一个重要概念”粘包”的处理. </p><p>这里我了解到了<code>capacity()</code>机制, 可以用来减少内存分配次数. <code>capacity()</code>代表预分配的内存大小,<br>而<code>size()</code>是你写入的数据大小, 当<code>size == capacity</code>的时候<code>再写入内容</code>内存会分配更长的一个数组将旧数据拷贝过去<code>size()</code>依然是你写入的大小, <code>capacity()</code>则会变大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">buff</span><span class="params">(<span class="number">20</span>)</span></span>; <span class="comment">// 填充了20个元素 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    buff.resize(<span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld %ld\n"</span>, buff.<span class="built_in">size</span>(), buff.capacity());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld %ld\n"</span>, buff.<span class="built_in">size</span>(), buff.capacity()); <span class="comment">// 20 20</span></span><br><span class="line">    Foo(<span class="number">512</span>); <span class="comment">// 512 512</span></span><br><span class="line">    Foo(<span class="number">1024</span>); <span class="comment">// 1024 1024</span></span><br><span class="line">    Foo(<span class="number">1025</span>); <span class="comment">// 1025 2048</span></span><br><span class="line">    Foo(<span class="number">2048</span>); <span class="comment">// 2048 2048</span></span><br><span class="line">    Foo(<span class="number">2049</span>); <span class="comment">// 2049 4096</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>花了小半天时间去了解配置了下 protobuf, 是一把很锋利的剑不错!</p><p>网络编程中使用protobuf的两个先决条件</p><ul><li>长度问题, protobuf打包的数据没有自带长度信息或终结符, 这就需要程序自己在发送和接受的时候做正确的切分</li><li>类型问题, protobuf打包的数据没有自带类型信息, 需要由发送方把类型信息传给接收方, 接收方创建对应的具体protobuf message对象, 再做反序列化</li></ul><p>我第一印象解决上面的方法, 就如书中所言是山寨的做法…. 增加header部分</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/protobuf%20class.png" alt="Protobuf类图"></p><p>大概意思就是大部分人通过在头部增加代号标识消息类型(具体对应那个message), 而protobuf提供了<br>根据反射 根据typename 选择对应的Message对象的功能, 由于我没有用过protobuf 目前不是很了解 不过大概就这样了, 后续会专门学习 先用即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg typename=muduo.Query</span></span><br><span class="line">google::<span class="function">protobuf::Message* <span class="title">ProtobufCodec::createMessage</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; typeName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    google::protobuf::Message* message = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">const</span> google::protobuf::Descriptor* descriptor =</span><br><span class="line">        google::protobuf::DescriptorPool::generated_pool()-&gt;FindMessageTypeByName(typeName);</span><br><span class="line">    <span class="keyword">if</span> (descriptor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> google::protobuf::Message* prototype =</span><br><span class="line">            google::protobuf::MessageFactory::generated_factory()-&gt;GetPrototype(descriptor);</span><br><span class="line">        <span class="keyword">if</span> (prototype)</span><br><span class="line">        &#123;</span><br><span class="line">            message = prototype-&gt;New(); <span class="comment">// 返回的是动态创建的指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;google::protobuf::Message&gt; MessagePtr;</span><br><span class="line">MessagePtr message;</span><br><span class="line">message.reset(createMessage(typeName)); <span class="comment">// 接管指针</span></span><br></pre></td></tr></table></figure><p>作者设计的格式如下<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/protobuf%E4%BC%A0%E8%BE%93%E6%A0%BC%E5%BC%8F.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// int32_t version; 根本不需要版本号</span></span><br><span class="line">    <span class="keyword">int32_t</span> len; <span class="comment">// 没有使用uin32_t 是为了跨语言, Java没有unsigned</span></span><br><span class="line">    <span class="keyword">int32_t</span> namelen;</span><br><span class="line">    <span class="keyword">char</span> type_name[namelen]; <span class="comment">// 以 /0 结尾 方便接收方处理 节省strlen() 空间换时间</span></span><br><span class="line">    <span class="keyword">char</span> protobuf_data[len-namelen<span class="number">-8</span>]</span><br><span class="line">    <span class="keyword">int32_t</span> checksum; <span class="comment">// adler32算法 进行校验</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于知道编码器解码器合起来叫什么了… 编解码器(codec)</p><p>后面的一些例子就跳过了, 去准备阅读第八章然后动手写库了 这里才是重点 至于例子当时候自己再写.<br>自己的库不香吗?</p><h2 id="第八章-muduo网路库设计与实现"><a href="#第八章-muduo网路库设计与实现" class="headerlink" title="第八章 muduo网路库设计与实现"></a>第八章 muduo网路库设计与实现</h2><p><del>第八章从第0节开始 一看就是程序员</del></p><p>2020年4月27日11:02:12 距离写完上一行博客已经过去不短的时间了.<br>这段时间我仿照muduo从中抽了部分功能做了自己的mongo库, 然后我将muduo Protobuf作为附属<br>改成了ProtobufServer(包装了TcpServer).</p><p>之后我便重新编写UE4部分的Protobuf收发部分的代码.<br>昨天晚上总算是将UE4打飞机的单机版 成功改造成了联机版. 使用的帧同步<br>服务器稳定性极佳, 而且内存占用很低, 想到了我之前写的Java服务器. 服务器CPU性能占用极少.</p><p>初期设计的时候 单机每秒发送12包, 每包平均0.16kb. 单机每秒就是2kb.  如果有6个客户端<br>服务器算上广播 出站流量 72kb/s</p><p>跑了下iftop看了下基本是这样.<br>12*6 = 72kb/s</p><p>阿里云送的服务器1Mbps, 理论可以支持8个客户端同屏游戏<br>阿里云学生机5Mbps, 理论支持17个客户端同屏游戏</p><p>当然了现在只同步了输入, 不过其他同步内容消耗的流量就很少了.</p><p>服务器程序运行良好, 倒是UE4 偶尔会崩….</p><p>后面慢慢完善打飞机和服务器</p><p>使用框架很简单的就实现了 登录和游玩数据分开 很舒服. 当然了登录目前只是个摆设没有在服务端保存<br>跳过登录依然可以玩, 后面完善db服务器再说</p><h1 id="第三部分-工程实践经验谈"><a href="#第三部分-工程实践经验谈" class="headerlink" title="第三部分 工程实践经验谈"></a>第三部分 工程实践经验谈</h1><h2 id="第九章-分布式-跳过"><a href="#第九章-分布式-跳过" class="headerlink" title="第九章 分布式 跳过"></a>第九章 分布式 跳过</h2><h2 id="第十章-C-编译链接模型精要"><a href="#第十章-C-编译链接模型精要" class="headerlink" title="第十章 C++编译链接模型精要"></a>第十章 C++编译链接模型精要</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux高性能服务器编程基本看玩了, 现在需要进行实战练习, 然而从单纯的只会api到做出项目, 之间的距离&lt;br&gt;不是一般的小, 最终我选择了这本书…..&lt;/p&gt;
&lt;p&gt;相关自己写的代码 大部分放在github 少部分会写在博客中&lt;/p&gt;
&lt;h1 id=&quot;第一部分-C-
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Shell脚本编写</title>
    <link href="http://blog.lsmg.xyz/2020/03/Linux-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
    <id>http://blog.lsmg.xyz/2020/03/Linux-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</id>
    <published>2020-03-26T09:30:22.000Z</published>
    <updated>2020-07-02T04:47:32.290Z</updated>
    
    <content type="html"><![CDATA[<p>由于阿里云服务器github速度异常缓慢, 自己想把一个shell, 改成本地版本发现不是很容易.<br>所以咕咕咕很久的shell脚本, 算是开始学了. 感觉入门应该不会太难把</p><p>我先来我最喜欢的入门网站 菜鸟教程!</p><p>既然写的是脚本就需要解释器了</p><ol><li><code>#!/bin/bash</code> 这个通常见于脚本的第一行, <code>#!</code>算是个约定了 说明脚本需要什么解释器</li><li><code>/bin/sh xx.sh</code> 这种是执行的时候指定, 脚本第一行的那个就失效了</li></ol><p><strong>shell变量-挺正常的规定</strong></p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><p>shell变量类型</p><ul><li>局部变量</li><li>环境变量</li><li>shell变量-shell内置特殊变量</li></ul><p>变量定义 <em>注意 不能随便加空格 下面的等号两侧不能加空格</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接赋值</span></span><br><span class="line">xxx="lsmg"</span><br><span class="line">xxx = "lsmg" # 错误</span><br><span class="line">xxx="Jigokubana" # 随意修改</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 语句赋值</span></span><br><span class="line">for skill in Ada Coffe Action Java; do</span><br><span class="line">    echo "I am good at $&#123;skill&#125;Script"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用变量</span></span><br><span class="line">echo $xxx</span><br><span class="line">echo $&#123;xxx&#125; # &#123;&#125; 用于标记边界</span><br><span class="line">echo "my name is $&#123;xxx&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> const</span></span><br><span class="line">readonly xxx="lsmg" </span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash"> 删除变量</span></span><br><span class="line">unset xxx; 不能用于删除只读变量</span><br></pre></td></tr></table></figure><p>单双引号字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> shell 双引号字符串</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 可以含有转义字符 和变量</span></span></span><br><span class="line">xxx1="\"lsmg\""</span><br><span class="line">echo xxx1 # $ "lsmg"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> shell单引号字符串</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 会原样输出, 无视变量. 即使转义也不能出现单一的单引号 但可以成对出现 用于拼接字符串</span></span></span><br><span class="line">xxx2='lsmg' </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拼接双引号变量双引号输出 单引号变量单引号输出</span></span><br><span class="line">your_name="runoob"</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 使用双引号拼接</span></span></span><br><span class="line">greeting="hello, "$your_name" !"</span><br><span class="line">greeting_1="hello, $&#123;your_name&#125; !"</span><br><span class="line">echo $greeting  $greeting_1 # hello, runoob ! hello, runoob !</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 使用单引号拼接</span></span></span><br><span class="line">greeting_2='hello, '$your_name' !'</span><br><span class="line">greeting_3='hello, $&#123;your_name&#125; !'</span><br><span class="line">echo $greeting_2  $greeting_3 # hello, runoob ! hello, $&#123;your_name&#125; !</span><br></pre></td></tr></table></figure><p>字符串操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">url="https://blog.lsmg.xyz"</span><br><span class="line"></span><br><span class="line">echo $&#123;#url&#125; # 输出长度 21</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意单引号</span></span><br><span class="line">echo `expr index "$url" go` # 输出 字符 g o的位置 哪个先出现就输出哪个</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 字符串截取</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 范围截取</span></span></span><br><span class="line">echo #&#123;url:0:5&#125; # 输出 https 第二个数字代表字符个数 不是范围</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># #截取删除左边字符, 保留右侧字符</span></span></span><br><span class="line">echo #&#123;url#*//&#125; # blog.lsmg.xyz</span><br></pre></td></tr></table></figure><p>数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 空格分隔</span></span><br><span class="line">name=(lsmg Lsmg Jigokubana);</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 你甚至可以 不连续定义</span></span><br><span class="line">nickname[0]=lsmg</span><br><span class="line">nickname[2]=Lsmg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取</span></span><br><span class="line">echo $&#123;nickname[0] nickname[1] nickname[2]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出所有</span></span><br><span class="line">echo $&#123;name[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取得数组元素个数</span></span><br><span class="line">echo $&#123;#name[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取得单个元素长度</span></span><br><span class="line">echo $&#123;#name[1]&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于阿里云服务器github速度异常缓慢, 自己想把一个shell, 改成本地版本发现不是很容易.&lt;br&gt;所以咕咕咕很久的shell脚本, 算是开始学了. 感觉入门应该不会太难把&lt;/p&gt;
&lt;p&gt;我先来我最喜欢的入门网站 菜鸟教程!&lt;/p&gt;
&lt;p&gt;既然写的是脚本就需要解释器了
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="Shell" scheme="http://blog.lsmg.xyz/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>EPOLL本质</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-EPOLL%E6%9C%AC%E8%B4%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-EPOLL%E6%9C%AC%E8%B4%A8/</id>
    <published>2020-03-25T09:35:20.000Z</published>
    <updated>2020-03-25T10:24:04.340Z</updated>
    
    <content type="html"><![CDATA[<p>EPOLL本质是什么?  <del>本质当然是复读机</del></p><p>参考和图片来源<br><a href="https://zhuanlan.zhihu.com/p/64138532" target="_blank" rel="noopener">如果这篇文章说不清epoll的本质，那就过来掐死我吧！</a></p><p>一个socket对应一个端口号, 网络数据包中包含了端口, 内核可以通过端口号找到对应的socket</p><p><strong>select的不足</strong><br>select需要遍历两次socket列表, 第一次遍历用于将进程加入到所有socket的等待队列<br>第二次遍历是每次唤醒都需要将进程从每个socket等待队列移除<br>由于遍历开销大, 所以才规定了select最大的监视数量</p><p><strong>功能分离</strong><br><img src="https://pic2.zhimg.com/80/v2-5ce040484bbe61df5b484730c4cf56cd_720w.jpg" alt=""><br>select将 <code>维护等待队列</code> 和 <code>阻塞进程</code>两个步骤合二为一, 每次select都需要这两部操作, 然而socket并不需要每次都修改<br>epoll将操作分开, 使用epoll_ctl维护等待队列, 使用epoll_wait阻塞进程</p><p><strong>就绪队列</strong><br>select不知道哪些socket接收到了数据, 只能一个个遍历.<br>如果内核维护一个”就绪队列” 引用存储事件就绪的socket, 进程唤醒后获取”就绪队列”就能够知道<br>哪些socket接收到数据</p><p><strong>epoll_create创建了什么?</strong><br>创建了一次eventpoll对象, epollfd正是他所代表的对象. 由于epollfd也是文件系统一员也存在等待队列</p><p>select将进程加入到每个socket的等待队列, 而epoll将进程加入到了eventpoll的等待队列 只加入了一次.</p><p><strong>epoll_ctl修改了什么</strong><br>epoll_ctl将 eventpoll添加到sockfd的等待队列中</p><p>当socket接收到数据后, 中断程序会操作eventpoll对象, 而不是直接操作进程(socket的等待队列中就是eventpoll)</p><p><strong>接收数据</strong><br>socket接收到数据后, 中断程序会给epollpoll的<code>就绪列表</code>添加socket的引用.</p><p>这样socket就不会直接影响进程, 而是通过改变eventpoll的<code>就绪列表</code>来改变进程状态</p><p><strong>epoll_wait</strong><br>当程序执行到epoll_wait后如果<code>就绪队列</code>已经有socket引用就会返回, 如果为空就阻塞进程</p><p><strong>阻塞和唤醒进程</strong><br>进程被添加到了eventpoll的等待队列中, socket接收到数据后, 中断程序一方面修改<code>就绪队列</code>一方面唤醒<br>eventpoll等待队列的进程, 由于<code>就绪队列</code> 进程便知道哪些socket发生变化</p><p><strong>实现细节</strong><br>eventpoll的数据结构是双向链表, 能够快速的插入和删除的数据结构</p><p>就绪队列的数据结构是红黑树, 方便添加删除检索避免重复添加.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;EPOLL本质是什么?  &lt;del&gt;本质当然是复读机&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;参考和图片来源&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64138532&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如果这篇文章说
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="Socket理论" scheme="http://blog.lsmg.xyz/categories/CPP/Socket%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP状态机</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-TCP%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-TCP%E7%8A%B6%E6%80%81%E6%9C%BA/</id>
    <published>2020-03-25T04:55:20.000Z</published>
    <updated>2020-04-08T01:46:19.020Z</updated>
    
    <content type="html"><![CDATA[<ul><li>待补充 双向管道的建立和断开细节</li><li>异常三次握手</li><li>异常四次挥手</li></ul><p><a href="https://blog.csdn.net/q1007729991/article/details/69675752" target="_blank" rel="noopener">资料参考TCP 协议状态机</a></p><p><a href="https://blog.csdn.net/randyjiawenjie/article/details/6397477" target="_blank" rel="noopener">TCP有限状态机分析</a></p><p>Tcp状态图, 虚线代表客户端 实线代表服务器<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP/Socket%E7%90%86%E8%AE%BA/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt=""></p><p>正常的连接建立还是比较容易理解的</p><p>说一下从<code>CLOSE_WAIT</code>到<code>LAST_ACK</code><br>当被动关闭方<code>B</code>接收到<code>FIN</code>后知道对方<code>A</code>要关闭连接, <code>B</code>回复一个<code>ACK</code>给<code>A</code></p><ol><li>如果此时<code>B</code>没有额外要发送的数据就给<code>A</code>, 就发送<code>FIN</code>告知<code>A</code>自己也要关闭了, 然后<code>B</code>进入<code>LAST_ACK</code></li><li>如果此时<code>B</code>有额外信息要发送等发送完毕后. 这时<code>B</code>发送一个<code>FIN</code>告知<code>A</code>然后B进入<code>LAST_ACK</code></li></ol><p>再说一下从<code>FIN_WAIT_1</code>到<code>TIME_WAIT</code></p><ol><li>直接从<code>FIN_WAIT_1</code>到<code>TIME_WAIT</code>, 这个对应上面的第一种情况, 由于<code>B</code>没有额外信息发送直接发送了<code>FIN和ACK</code>, 这时<code>A</code>再发送一个<code>ACK</code>, 进入<code>TIME_WAIT</code></li><li>经过中转状态<code>FIN_WAIT2</code>对应上面第二种情况, 由于<code>B</code>有额外信息发送, 只发送了<code>ACK</code>, 这时<code>A</code>还可以接受数据, 直到<code>B</code>发来<code>FIN</code>然后<code>A</code>发送<code>ACK</code>进入<code>TIME_WAIT</code></li></ol><p>再说一下<code>TIME_WAIT</code>状态<br>主动关闭方<code>A</code>最后发送了<code>ACK</code>确认被动关闭方<code>B</code>的<code>FIN</code>.<br>但是如果这个<code>ACK</code>由于各种原因<code>B</code>没有收到, 所以<code>B</code>会再次发送<code>FIN</code>. 然后<code>A</code>会在<code>2MSL</code>时间内接受到这个<code>FYN</code>, 之后<code>A</code>再次回复一个<code>ACk</code>.计时器重置<code>2MSL</code>时间, 重复上面过程. 直到<code>2MSL</code>时间内<code>A</code>没有收到<code>FIN</code>,说明<code>B</code>已经收到了.则结束连接</p><p><code>2MSL</code>指的是两个<code>MSL</code>时间 单个指的是一个片段在网络中的最大存活时间,<br>A发送的<code>ACK</code>可能消耗一个, B重新发送的<code>FIN</code>可能也要消耗一个.最大两个</p><p>复位报文段</p><ul><li>客户端访问不存在的端口， 服务器会发送带RST标志的复位报文段</li><li>异常终止连接， 发送复位报文段</li><li>客户端或服务端向半打开状态(对方异常终止连接, 但是本方没有收到结束报文)的连接写入数据, 对方回复会一个复位报文段</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;待补充 双向管道的建立和断开细节&lt;/li&gt;
&lt;li&gt;异常三次握手&lt;/li&gt;
&lt;li&gt;异常四次挥手&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/q1007729991/article/details/69675752&quot;
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="Socket理论" scheme="http://blog.lsmg.xyz/categories/CPP/Socket%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Send返回值引出的(非)阻塞IO</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-Send%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8E%A2%E6%9E%90/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-Send%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8E%A2%E6%9E%90/</id>
    <published>2020-03-20T03:14:20.000Z</published>
    <updated>2020-03-20T04:20:31.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现存疑问"><a href="#现存疑问" class="headerlink" title="现存疑问"></a>现存疑问</h1><ol><li>WNOWAIT和O_NONBLOCK 的关系?</li><li>当非阻塞send时, 返回值与什么有关? 本地socket发送缓冲区空余还是对端空余?</li><li>对端接收缓冲区满了会发生什么?</li><li>暂且认为send返回值是拷贝到缓冲区中的字节数, 如果这些数据没有成功发送呢?</li><li>send函数发送的字节数 超出了recv端的接受能力 会发生什么?</li></ol><p>最近这两天在实战一个http服务器的编写.</p><p>遇到了一个问题: send的返回值小于传入的len, 因为我仅调用一次send函数 导致页面一直显示加载</p><p>然后找了下为什么? 什么时候? send返回值会小于len;</p><h1 id="send"><a href="#send" class="headerlink" title="send"></a>send</h1><p><a href="https://stackoverflow.com/questions/14700906/socket-programming-send-return-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/14700906/socket-programming-send-return-value</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In practice, send() in blocking mode sends all the data, regardless of what the documentation says, unless there was an error, in which case nothing is sent.</span><br><span class="line">实战中, send() 处于阻塞状态会发送所有的数据, 除非发生错误 但这会导致数据没有发送</span><br><span class="line"></span><br><span class="line">In non-blocking mode, it sends whatever will fit into the socket send buffer and returns that length if &gt; 0. If the socket send buffer is full, it returns -1 with errno &#x3D; EWOULDBLOCK&#x2F;EAGAIN.</span><br><span class="line">在非阻塞模式下, 只要能放入socket发送缓冲区 就返回放入的长度 如果缓冲区满了就返回-1 设置EWOULDBLOCK&#x2F;EAGAIN</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247486643&idx=1&sn=9db678398f390759ff81b354ef056000&chksm=fc70f75fcb077e49363b087ba45609fdfbcba286338e70c2d4c7092e83e2d3feac56455e02a2&scene=27#wechat_redirect" target="_blank" rel="noopener">非阻塞模式下 send 和 recv 函数的返回值</a></p><p>这篇博客里也说明了这个问题. 下面是原博客的代码稍作修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐的方式二：在一个循环里面根据偏移量发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* buf , <span class="keyword">int</span> buf_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//已发送的字节数目</span></span><br><span class="line">    <span class="keyword">int</span> sent_bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = send(fd, buf + sent_bytes, buf_length - sent_bytes, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;             </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//认为对端关闭了连接</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sent_bytes += ret;</span><br><span class="line">        <span class="keyword">if</span> (sent_bytes == buf_length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//稍稍降低 CPU 的使用率</span></span><br><span class="line">        usleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;现存疑问&quot;&gt;&lt;a href=&quot;#现存疑问&quot; class=&quot;headerlink&quot; title=&quot;现存疑问&quot;&gt;&lt;/a&gt;现存疑问&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;WNOWAIT和O_NONBLOCK 的关系?&lt;/li&gt;
&lt;li&gt;当非阻塞send时, 返回值与什么有关? 本地
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="Socket理论" scheme="http://blog.lsmg.xyz/categories/CPP/Socket%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux的使用</title>
    <link href="http://blog.lsmg.xyz/2020/03/Linux-Linux%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/Linux-Linux%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-17T04:29:20.000Z</published>
    <updated>2020-07-02T04:47:32.290Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>cp -r</td><td>复制目录</td></tr><tr><td>cd -</td><td>切换到上一个工作目录</td></tr></tbody></table><table><thead><tr><th>查找</th><th>功能</th></tr></thead><tbody><tr><td>find ./ -name “core*”</td><td>xargs file</td></tr><tr><td>find ./ -name ‘*.o’</td><td>查找目标文件夹是否有obj文件</td></tr><tr><td>find ./ -name “*.o” | xargs rm -f</td><td>递归删除当前目录所有obj文件</td></tr></tbody></table><table><thead><tr><th>查看文件内容</th><th>功能</th><th>一般用法</th></tr></thead><tbody><tr><td>cat -n</td><td>显示的同时显示行号</td><td>使用管道 ls | cat -n</td></tr><tr><td>head -10 filename</td><td>查看前十行</td><td></td></tr><tr><td>tail -10 failname</td><td>查看后十行</td><td></td></tr><tr><td>diff file1 file2</td><td>查看文件差别</td><td></td></tr><tr><td>tail -f filename</td><td>动态显示文本的最新信息</td><td></td></tr></tbody></table><p>| 给文件增加别名 | 功能 |<br>| ln a b | 创建硬链接, 删除一个另一个仍能使用 |<br>| ln -s a b | 创建符号链接(软连接) 删除源后另一个无法使用 |</p><p>命令行快捷键<br>Ctl-U   删除光标到行首的所有字符 <code>$ 1111 222  --&gt; $</code><br>Ctl-W   删除光标到前边最近一个空格之间的字符 <code>$ 1111 222 --&gt; $ 1111</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;cp -r&lt;/td&gt;
&lt;td&gt;复制目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cd -&lt;/td&gt;
&lt;td&gt;切换到上一个工作目录
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>UNP卷二读书记录</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95115-UNP%E5%8D%B7%E4%BA%8C/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95115-UNP%E5%8D%B7%E4%BA%8C/</id>
    <published>2020-03-15T03:16:20.000Z</published>
    <updated>2020-03-21T01:23:03.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h1><h2 id="管道和有名管道FIFO"><a href="#管道和有名管道FIFO" class="headerlink" title="管道和有名管道FIFO"></a>管道和有名管道FIFO</h2><p><strong>popen pclose</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 成功返回文件指针, 出错为NULL</span></span><br><span class="line"><span class="function">FILE* <span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line">FILE* fp = popen(command, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功为shell终止状态, 出错则为 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">pclose(fp);</span><br></pre></td></tr></table></figure><p>popen创建一个管道并启动另外一个进程 创建者要么从管道读出标准输入, 要么将标准输出写到管道<br>返回的文件指针作用<br>通过type参数控制<br>type = “r” 创建者 通过文件指针读入command命令产生的标准输出<br>type = “w” 创建者 通过文件指针为command命令提供标准输入</p><p>pclose 关闭这个标准IO流</p><p><strong>FIFO 先进先出(first in, first out)</strong></p><p>又称为有名管道(named pipe) 单向(半双工)数据流, 每个FIFO都有一个路径名与之对应.<br>从而允许无亲缘关系的进程访问同一个FIFO</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回 0 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> FIFO1 = <span class="string">"/tmp/fifo.1"</span>;</span><br><span class="line">mkfifo(FIFO1, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建之后需要打开来进行读或者写 可以使用open也可以使用其他标准IO打开函数</span></span><br><span class="line"><span class="keyword">int</span> writefd = <span class="built_in">open</span>(FIFO1, O_WRONLY, <span class="number">0</span>); <span class="comment">/* 在父进程中打开 父进程写 */</span></span><br><span class="line"><span class="keyword">int</span> readfd = <span class="built_in">open</span>(FIFO1, O_RDONLY, <span class="number">0</span>); <span class="comment">/* 在子进程中打开 子进程读 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有调用unlink才能从文件系统删除文件名字</span></span><br><span class="line">unlink(FIFO1);</span><br></pre></td></tr></table></figure><p>mkfifo 隐含已经指定 O_CREAT | O_EXCL<br>要么不存在创建一个新的, 要么返回 errno=EEXIST(所指定名字的FIFO已经存在)</p><p>如果想要打开已经存在的FIFO可以使用open函数.<br>可以判断 如果返回-1 并且errno=EEXIST 就调用open函数打开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子进程</span></span><br><span class="line">readfd = <span class="built_in">open</span>(FIFO1, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">writefd = <span class="built_in">open</span>(FIFO2, O_WRONLY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程</span></span><br><span class="line">writefd = <span class="built_in">open</span>(FIFO1, O_WRONLY, <span class="number">0</span>);</span><br><span class="line">readfd = <span class="built_in">open</span>(FIFO2, O_RDONLY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程 这样会阻塞</span></span><br><span class="line">readfd = <span class="built_in">open</span>(FIFO2, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">writefd = <span class="built_in">open</span>(FIFO1, O_WRONLY, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果调换父进程的两行代码 程序就会进入死锁<br>因为如果当前没有任何进程<code>打开某个FIFO来写</code>, 打开这个<code>FIFO来读</code>的进程将会<code>阻塞</code></p><p>当对一个管道或者FIFO的最终close发生的时候, 该管道或FIFO中的任何残余数据都将被丢弃</p><p>即使在A主机上能够访问到B主机的目录, 即使不同主机上的两个进程都能够通过NFS打开同一个FIFO<br>他们之间也不能通过FIFO从一个进程到另一个进程发送数据</p><p>拒绝服务型攻击Dos<br>如果是单进程可能会让服务器处于阻塞状态, 多进程也可能会由于一个恶意客户发送大量独立请求<br>导致服务器子进程数达到上限, 使得后续的fork失败</p><p><strong>其他</strong><br>从字节流中获取完整的单个信息</p><ul><li>带特殊终止序列<br>许多UNIX应用使用换行分割 因特尔应用程序使用回车符加上一个换行符</li><li>显式长度<br>将长度增加在请求中</li><li>每次连接一个记录<br>应用通过关闭对端连接指示一个记录结束. HTTP1.0使用的这一技术</li></ul><p>标准IO函数fdopen可以将标准IO流与pipe返回的文件描述符相关联’</p><p><strong>限制</strong><br>系统加在管道和FIFO的唯一限制是</p><ul><li>OPEN_MAX<br>一个进程在任意时刻打开的最大描述符数量 &gt;=16</li><li>PIPE_BUF<br>可以原子性的写入一个管道或FIFO的最大数据量 &gt;= 512</li></ul><p><strong>习题练习</strong></p><ol><li>父进程终止的时候, 如果子进程的fd[1]仍处于打开状态, 则子进程对fd[0]的read 不会返回文件结束符,<br>因为fd[1]虽然在父进程中关闭了, 但是在子进程中依然打开. 如果关闭子进程fd[1], 则父进程一旦关闭,<br>他的所有文件描述符即关闭, 子进程对fd[0]的read就会返回0.(想到了自己写的服务器, 客户端断开连接就会read出一个0长度的内容)</li><li>从 不存在即创建, 存在-&gt;打开 变成 存在-&gt;打开, 不存在即创建. 可能会在open打开失败后 创建fifo之前<br>被其他进程抢先创建fifo, 导致本进程的mkfifo调用失败</li><li>出错信息写到了标准错误输出</li><li>可以把第一个open调用设置成非阻塞, 但是为了避免readline返回错误, 标志必须在readline之前去除</li><li>死锁</li><li>读进程关闭管道或者FIFO后给写进程一个信号(往关闭的管道写会产生SIGPIPE信号),<br>写进程关闭管道或者FIFO后将文件结束符发送给读进程(读进程读到长度为0的文件结束符)</li></ol><h2 id="POSIX消息队列"><a href="#POSIX消息队列" class="headerlink" title="POSIX消息队列"></a>POSIX消息队列</h2><p><strong>mqueue创建和删除</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// oflag O_RDONLY O_WRONLY O_RDWR 可以加上O_CREAT和O_EXCL或者O_NONBLOCK</span></span><br><span class="line"><span class="comment">// 创建一个新队列的时候(制定了O_CREAT且消息队列不存在)后两个参数都需要</span></span><br><span class="line"><span class="comment">// 权限位 和 指定某些属性 nullptr则使用默认属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回消息队列 fd 失败 -1</span></span><br><span class="line"><span class="function"><span class="keyword">mqd_t</span> <span class="title">mq_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="comment">/*mode_t mode, struct mq_attr *attr*/</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>注意<br>消息队列文件描述符不必是(而且很可能不是)像文件描述符或者socket文件描述符那样的短整数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭消息队列 引用计数 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_close</span><span class="params">(<span class="keyword">mqd_t</span> mqdes)</span></span>;</span><br></pre></td></tr></table></figure><p>类似close函数, 调用进程可以不再使用该文件描述符, 但是其消息队列并不会从系统中删除</p><p>当一个进程终止的时候, 所有打开着的消息队列都将关闭, 就像自动调用了mq_close</p><p>如果要从系统中删除<code>mq_open</code>第一个参数<code>name</code> 必须调用下面的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用计数 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><p>每个消息队列有一个保存着当前打开描述符数的引用计数器</p><p>当消息队列的引用计数仍大于0时, 其name就能删除<br>但是队列的析构会在<code>引用计数为0</code>的时候自动析构.</p><p>第一个demo敲完之后 一直是errno=13.<br>在<code>man mq_overview</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">On Linux, message queues are created in a virtual filesystem.   (Other  implementa‐</span><br><span class="line">tions may also provide such a feature, but the details are likely to differ.)  This</span><br><span class="line">filesystem can be mounted (by the superuser) using the following commands:</span><br><span class="line"></span><br><span class="line"># mkdir &#x2F;dev&#x2F;mqueue</span><br><span class="line"># mount -t mqueue none &#x2F;dev&#x2F;mqueue</span><br><span class="line"></span><br><span class="line">The sticky bit is automatically enabled on the mount directory.</span><br></pre></td></tr></table></figure><p>而且 name参数的格式是<code>/somename</code> 这个是相对挂载目录的</p><p><strong>属性设置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mq_flags; <span class="comment">/* 0, O_NONBLOCK */</span></span><br><span class="line">    <span class="keyword">long</span> mq_maxmsg; <span class="comment">/* max number */</span></span><br><span class="line">    <span class="keyword">long</span> mq_msgsize; <span class="comment">/* max size of a msg in bytes */</span></span><br><span class="line">    <span class="keyword">long</span> mq_curmsgs; <span class="comment">/* number of message currently on queue */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_getattr</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, struct mq_attr *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 的时候 只有mq_attr中的mq_flags起作用 设置取消O_NONBLOCK</span></span><br><span class="line"><span class="comment">// 最大消息数和最大字节数 只能在创建队列的时候设置</span></span><br><span class="line"><span class="comment">// 队列中房钱消息数 只能获取不能设置</span></span><br><span class="line"><span class="comment">// 第三个参数 不为nullptr则返回之前的属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_setattr</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> struct mq_attr *attr, struct mq_attr *oattr)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>发送接收信息</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prio 优先级 必须 &lt;= MQ_PRIO_MAX</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_send</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> prio)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// len 必须 &gt;= mq_attr.mq_msgsize 如果小于则 errno = EMSGSIZE</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">mq_receive</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> *priop)</span></span>;</span><br></pre></td></tr></table></figure><p>如果不使用优先级 发送的时候可以将 mq_send的 prio 设置为0<br>接受的时候 mq_receive priop 设置为 nullptr</p><p><strong>消息队列的限制</strong></p><ul><li>mq_maxmsg 队列中最大消息数</li><li>mq_msgsize单个消息的最大字节</li><li>MQ_OPEN_MAX 一个进程同时打开消息队列的最大数目</li><li>MQ_PRIO_MAX 最大优先级+1</li></ul><p><strong>异步事件通知</strong></p><ul><li>产生信号</li><li>创建一个线程执行一个指定的函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为指定队列建立或者删除异步事件通知.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回 0 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_notify</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, struct sigevent *nofification)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sival_int;</span><br><span class="line">    <span class="keyword">void</span> *sival_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sigev_notify; <span class="comment">// SIGEV_NONE SIGEV_SIGNAL SIGEV_THREAD</span></span><br><span class="line">    <span class="keyword">int</span> sigev_signo; <span class="comment">// signal number if SIGEV_SIGNAL</span></span><br><span class="line">    <span class="keyword">union</span> sigval sigev_value; <span class="comment">// passed to signal handler pr thread</span></span><br><span class="line">    <span class="comment">// 下面两个用于 SIGEV_THREAD</span></span><br><span class="line">    <span class="keyword">void</span> (*sigev_notify_function)(<span class="keyword">union</span> sigval);</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> *sigev_notify_attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>如果 notification != nullptr<br>当前进程希望 在有一个消息 到达所指定的 先前为空的队列 时得到通知<br>我们说 该进程被注册为接收该队列的通知</p></li><li><p>如果 notification == nullptr<br>如果 该进程被注册为 接受所指定队列通知 则取消它</p></li><li><p>任何时刻只有一个进程可以被注册为 接收某个队列的通知</p></li><li><p>当一个消息到达某个空队列, 而且已经注册, 那么只有当<br>没有因为调用mq_reveive导致的阻塞 的时候才会发出通知</p></li><li><p>通知发出后 注册立即被撤销.. 需要重新注册???</p></li></ol><p>Unix信号产生后会复位成默认行为.<br>信号处理程序通常第一个调用signal函数, 用于重新建立处理程序<br>这时会产生一个空窗时期(信号产生 与 当前进程重建信号处理程序之间)<br>空窗时期再次产生同一信号 可能终止当前进程</p><p>初看起来, mq_notify可能也有这个问题.<br>不过在消息队列<code>为空前</code> <code>通知不会再次产生</code><br>所以不要在<code>读出消息后</code>重新注册<br>而应该在<code>读出消息前</code>重新注册</p><p><code>volatile sig_atomic_t mqflag = 0;</code><br>sig_atomic_t 即使缺少信号所做的异步中断，亦能作为原子实体访问的整数类型。<br>volatile 标记可能会随时改变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;消息传递&quot;&gt;&lt;a href=&quot;#消息传递&quot; class=&quot;headerlink&quot; title=&quot;消息传递&quot;&gt;&lt;/a&gt;消息传递&lt;/h1&gt;&lt;h2 id=&quot;管道和有名管道FIFO&quot;&gt;&lt;a href=&quot;#管道和有名管道FIFO&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>GDB调试</title>
    <link href="http://blog.lsmg.xyz/2020/03/Linux-GDB%E8%B0%83%E8%AF%95/"/>
    <id>http://blog.lsmg.xyz/2020/03/Linux-GDB%E8%B0%83%E8%AF%95/</id>
    <published>2020-03-14T07:09:20.000Z</published>
    <updated>2020-07-02T04:47:32.290Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p><p>对多线程的支持<br>set follow-fork-mode [parent|child]<br>set detach-on-fork [on|off]</p><table><thead><tr><th>follow-fork-mode</th><th>detach-on-fork</th><th>说明</th></tr></thead><tbody><tr><td>parent</td><td>on</td><td>只调试主进程</td></tr><tr><td>child</td><td>on</td><td>只调试子进程</td></tr><tr><td>parent</td><td>off</td><td>同时调试父子进程, gdb跟踪父进程, 子进程阻塞在fork位置</td></tr><tr><td>child</td><td>off</td><td>同上 gdb跟踪子进程, 父进程阻塞</td></tr></tbody></table><p>进程间切换<br>| 命令 | 功能 |<br>| — | — |<br>| info inferiors | 查询正在调试的进程 |<br>| inferior &lt;number&gt; | 切换进程 |</p><table><thead><tr><th>运行命令</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>run</td><td>r</td><td>运行程序</td></tr><tr><td>continue</td><td>c</td><td>继续执行到下有一个断点处</td></tr><tr><td>next</td><td>n</td><td>单步跟踪, 不进入函数</td></tr><tr><td>step</td><td>s</td><td>会进入函数</td></tr><tr><td>until</td><td></td><td>运行程序直到退出循环体</td></tr><tr><td>until + 行号</td><td></td><td>运行至某行</td></tr><tr><td>finish</td><td></td><td>运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回以及参数等信息</td></tr><tr><td>call 函数(参数)</td><td></td><td>调试程序中的可见参数, 并传递参数</td></tr><tr><td>quit</td><td>q</td><td>退出</td></tr></tbody></table><table><thead><tr><th>设置断点</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>break n</td><td>b n</td><td>在第n行设置断点, b xx.cpp:500(xx.cpp文件第500行)</td></tr><tr><td>b fn if a&gt;b</td><td></td><td>在函数f 或者行号n 设置条件断点</td></tr><tr><td>break func</td><td>b func</td><td>在函数func()的入口处设置断点</td></tr><tr><td>delete 断点号n</td><td></td><td>删除第n个断点</td></tr><tr><td>disable 断点号n</td><td></td><td>暂停第n个断点</td></tr><tr><td>enable 断点号n</td><td></td><td>开始第n的断点</td></tr><tr><td>clear 行号n</td><td></td><td>清除第n行的断点</td></tr><tr><td>info b</td><td></td><td>显示断点设置情况</td></tr><tr><td>delete breakpoints</td><td></td><td>清除所有断点</td></tr></tbody></table><table><thead><tr><th>查看源代码</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>默认显示10行</td></tr><tr><td>list 行号</td><td></td><td>以行号为中心的前后十行代码</td></tr><tr><td>list 函数名</td><td></td><td>列出函数名所在函数的代码</td></tr><tr><td>list</td><td></td><td>不带参数, 接着上一次的list命令输出下边的内容</td></tr></tbody></table><table><thead><tr><th>打印表达式</th><th>功能</th></tr></thead><tbody><tr><td>print p</td><td></td></tr><tr><td>p a</td><td>显示a的值</td></tr><tr><td>p ++a</td><td>a的值</td></tr><tr><td>p func(22)</td><td>以整数22作为参数调用 后打印</td></tr><tr><td>p func(a)</td><td>将变量a作为参数</td></tr><tr><td>display 表达式</td><td>每次单步运行后就打印表达式的值</td></tr><tr><td>watch 表达式</td><td>设置检视点, 一旦被监视的表达式值改变就强行终止正在被调试的程序</td></tr><tr><td>whatis</td><td>查询变量或函数</td></tr><tr><td>info function</td><td>查询函数</td></tr><tr><td>info local</td><td>显示当前堆栈页的所有变量</td></tr></tbody></table><table><thead><tr><th>查询运行信息</th><th>功能</th></tr></thead><tbody><tr><td>where/bt</td><td>当前运行的堆栈列表</td></tr><tr><td>bt backtrace</td><td>显示当前的调用堆栈</td></tr><tr><td>up/down</td><td>改变堆栈的显示深度</td></tr><tr><td>set args [args]</td><td>指定程序运行参数</td></tr><tr><td>show args</td><td>查看程序参数</td></tr><tr><td>info program</td><td>查看程序是否运行, 进程号, 被暂停原因</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://linuxtools-rst.readthed
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="GDB调试" scheme="http://blog.lsmg.xyz/tags/GDB%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
</feed>
