<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lsmg的大学之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lsmg.xyz/"/>
  <updated>2020-03-01T02:25:30.601Z</updated>
  <id>http://blog.lsmg.xyz/</id>
  
  <author>
    <name>Lsmg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>STL记录</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-CPP%E9%87%8D%E7%82%B9-STL%E8%AE%B0%E5%BD%95/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-CPP%E9%87%8D%E7%82%B9-STL%E8%AE%B0%E5%BD%95/</id>
    <published>2020-03-01T02:26:55.000Z</published>
    <updated>2020-03-01T02:25:30.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="lower-bound-和-upper-bound"><a href="#lower-bound-和-upper-bound" class="headerlink" title="lower_bound()和 upper_bound()"></a>lower_bound()和 upper_bound()</h2><p><strong>lower_bound(const Key&amp; key)</strong><br><a href="https://zh.cppreference.com/w/cpp/container/map/lower_bound" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/container/map/lower_bound</a><br>返回指向首个不小于 key 的元素的迭代器。若找不到这种元素，则返回尾后迭代器</p><p><strong>upper_bound()</strong><br>返回指向首个大于 key 的元素的迭代器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h1&gt;&lt;h2 id=&quot;lower-bound-和-upper-bound&quot;&gt;&lt;a href=&quot;#lower-bound-和-upper-boun
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>Jsoncpp代码阅读</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Jsoncpp%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Jsoncpp%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2020-03-01T02:26:55.000Z</published>
    <updated>2020-03-02T11:49:01.428Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Json::Value root;</span><br><span class="line">root[<span class="string">"action"</span>] = <span class="string">"run"</span>;</span><br></pre></td></tr></table></figure><p>首先是 <code>[]运算符重载</code> , 统一不同的重载类型<br>调用<code>resolveReference()</code>进行统一的添加<code>k</code>操作</p><p>首先会进行 校验参数, 然后将key封装成一个对象CZString (封装过程为将传入指针保存到 CZString对象中的cstr_)<br>封装完成后再保存<code>k v</code>的<code>map&lt;CZString, Value&gt;</code>中查找有无相同的CZString(key)有的话返回Value引用,<br>没有则创建新的&lt;CZStrng, 空Value&gt;存入map并返回Value的引用</p><p>然后是<code>=运算符重载</code>, “run”自动转换成Value对象<br>转换过程中, 通过<code>duplicateAndPrefixStringValue()</code>将”run”进行了封装<br><code>char* string_; // if allocated_, ptr to { unsigned, char[] }.</code><br>将长度封装到了一个char指针中, 有点类似自己设计tcp协议…</p><p><code>=运算符重载</code>函数将<code>[]运算符重载</code>返回的对象引用 中的相关值<code>swap()</code>成新的Value对象中的相关值</p><p>到这里理解了在Jsoncpp中 一切都是Value 包括&lt;K, V&gt;键值对也是在Value对象中存储<br>每一个&lt;k, v&gt;都可以作为一个Value对象, 这样既实现了复杂嵌套Json中 v为对象的情况 妙啊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个Value对象中都维护一个union</span></span><br><span class="line"><span class="keyword">union</span> ValueHolder &#123;</span><br><span class="line">    LargestInt int_;</span><br><span class="line">    LargestUInt uint_;</span><br><span class="line">    <span class="keyword">double</span> real_;</span><br><span class="line">    <span class="keyword">bool</span> bool_;</span><br><span class="line">    <span class="keyword">char</span>* string_; <span class="comment">// if allocated_, ptr to &#123; unsigned, char[] &#125;.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有的存贮着key的CZString保存起来</span></span><br><span class="line"><span class="comment">//  typedef std::map&lt;CZString, Value&gt; ObjectValues; // std::map&lt;CZString, Value&gt; 键值对</span></span><br><span class="line">    ObjectValues* map_;</span><br><span class="line">  &#125; value_;</span><br></pre></td></tr></table></figure><p>下面的switch的这个type 会在很多地方被修改掉.<br>起初 使用默认构造函数的value type是nullxxx<br>然后调用<code>[]运算符重载</code>的时候会修改掉 type 为 objectValue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归调用 进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuiltStyledStreamWriter::writeValue</span><span class="params">(Value <span class="keyword">const</span>&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (value.type()) &#123;</span><br><span class="line">  <span class="keyword">case</span> nullValue:</span><br><span class="line">    pushValue(nullSymbol_);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> intValue:</span><br><span class="line">    pushValue(valueToString(value.asLargestInt()));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> uintValue:</span><br><span class="line">    pushValue(valueToString(value.asLargestUInt()));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> realValue:</span><br><span class="line">    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,</span><br><span class="line">                            precisionType_));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> stringValue: &#123;</span><br><span class="line">    <span class="comment">// Is NULL is possible for value.string_? No.</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* str;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">bool</span> ok = value.getString(&amp;str, &amp;<span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">if</span> (ok)</span><br><span class="line">      pushValue(valueToQuotedStringN(str, <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(<span class="built_in">end</span> - str),</span><br><span class="line">                                     emitUTF8_));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      pushValue(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> booleanValue:</span><br><span class="line">    pushValue(valueToString(value.asBool()));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> arrayValue:</span><br><span class="line">    writeArrayValue(value);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> objectValue: &#123;</span><br><span class="line">    <span class="function">Value::Members <span class="title">members</span><span class="params">(value.getMemberNames())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (members.empty())</span><br><span class="line">      pushValue(<span class="string">"&#123;&#125;"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      writeWithIndent(<span class="string">"&#123;"</span>);</span><br><span class="line">      indent();</span><br><span class="line">      <span class="keyword">auto</span> it = members.<span class="built_in">begin</span>();</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">String</span> <span class="keyword">const</span>&amp; name = *it;</span><br><span class="line">        Value <span class="keyword">const</span>&amp; childValue = value[name];</span><br><span class="line">        writeCommentBeforeValue(childValue);</span><br><span class="line">        writeWithIndent(valueToQuotedStringN(</span><br><span class="line">            name.data(), <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(name.length()), emitUTF8_));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// :</span></span><br><span class="line">        *sout_ &lt;&lt; colonSymbol_;</span><br><span class="line">        writeValue(childValue);</span><br><span class="line">        <span class="keyword">if</span> (++it == members.<span class="built_in">end</span>()) &#123;</span><br><span class="line">          writeCommentAfterValueOnSameLine(childValue);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *sout_ &lt;&lt; <span class="string">","</span>;</span><br><span class="line">        writeCommentAfterValueOnSameLine(childValue);</span><br><span class="line">      &#125;</span><br><span class="line">      unindent();</span><br><span class="line">      writeWithIndent(<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次是根据下面的例子分析的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Json::Value root;</span><br><span class="line">  Json::Value data;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">bool</span> shouldUseOldWay = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 左侧返回Value的引用</span></span><br><span class="line">  root[<span class="string">"action"</span>] = <span class="string">"run"</span>;</span><br><span class="line">  data[<span class="string">"number"</span>] = <span class="number">1</span>;</span><br><span class="line">  root[<span class="string">"data"</span>] = data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldUseOldWay) &#123;</span><br><span class="line">    Json::FastWriter writer;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> json_file = writer.<span class="built_in">write</span>(root);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; json_file &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 配置文件也是Value对象, 我用我自己.jpg</span></span><br><span class="line">    Json::StreamWriterBuilder builder;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> json_file = Json::writeString(builder, root);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; json_file &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算是了解到了这个库的大概工作流程了. 能学到的部分 吃完午饭继续写.<br>吃完饭试了试家里的显示器, 家里的显示器还是太老了…… 八年的显示器了 看得我眼花<br>还是继续用笔记本吧</p><ol><li><p>首先我很喜欢这种运算符重载的使用形式, 用起来非常的舒服, 需要重载两个运算符 <code>[]</code>和<code>=</code> 而且<br><code>=运算符</code>重载使用的swap交换需要的属性, 感觉不错<br>(后来我看了EffectiveC++ 发现这是<code>=运算符处理自我赋值</code>太巧了)</p></li><li><p>针对需要加载配置文件的类 使用了工厂模式</p></li><li><p>writeValue使用了递归处理.</p></li><li><p>统一处理, k v都是Value对象</p></li><li><p>将用户的string 拷贝到新的<code>char*</code>中 同时在开头增加了长度, 尾部补了0, 没有使用额外的变量去存储<code>char*</code>的长度<br>不太清楚这样做有什么好处</p></li><li><p>常量全部用的 <code>static constexpr</code>修饰</p></li><li><p>恰当的对象嵌套</p></li></ol><hr><p>看完了从 Value到Json 接下来看看从Json到Value</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> rawJson = <span class="string">R"(&#123;"Age": 20, "Name": "colin"&#125;)"</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> rawJsonLength = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(rawJson.length());</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">bool</span> shouldUseOldWay = <span class="literal">false</span>;</span><br><span class="line">  JSONCPP_STRING err;</span><br><span class="line">  Json::Value root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldUseOldWay) &#123;</span><br><span class="line">    Json::Reader reader;</span><br><span class="line">    reader.parse(rawJson, root);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 默认构造函数 使用默认的配置</span></span><br><span class="line">    Json::CharReaderBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据builder的配置生成CharReader类</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Json::CharReader&gt; <span class="title">reader</span><span class="params">(builder.newCharReader())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!reader-&gt;parse(rawJson.c_str(), rawJson.c_str() + rawJsonLength, &amp;root,</span><br><span class="line">                       &amp;err)) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> name = root[<span class="string">"Name"</span>].asString();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> age = root[<span class="string">"Age"</span>].asInt();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析的关键在于<code>parse()</code>函数 传入字符串的首尾指针, 和一个Value引用<br>进入函数后将传入的变量保存到了自己的成员变量中.</p><p>慢慢发现 这个库将很多的默认类型 起了别名 可能是为了统一类型 类似UE4也是自己搞了一套</p><p>主要是<code>OurReader</code>这个负责解析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了大量的using</span></span><br><span class="line"><span class="keyword">using</span> Char = <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> Location = <span class="keyword">const</span> Char*;</span><br></pre></td></tr></table></figure><p>解析逻辑就是<code>parse()</code>调用<code>readValue()</code><br><code>readValue()</code>负责 获取下一次数据类型type_ -&gt;switch(type_) 根据分支决定是否递归再次调用<code>readValue</code><br>总算把逻辑看懂了, 代码依然认为很赞<br><code>readToken()</code>这个函数贯穿整个解析, 通过这个函数获取到下一次的数据是什么类型, 同时移动相关的状态指针<br><code>readToken()</code> 内部大量调用下面的函数 修改当前指针 同时返回字符, 然后switch这个字符判断下一次的数据类型<br>比如遇到<code>{</code>就是一个对象的开始设置好type并返回 遇到<code>}</code>就是对象的结束…..</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取current_指向的字符 并自增</span></span><br><span class="line"><span class="function">OurReader::Char <span class="title">OurReader::getNextChar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current_ == end_)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> *current_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般第一次调用type_会被设置为对象类型, 然后<code>readValue()</code>进入<code>case 对象分支</code><br><code>case对象分支中</code><br>先进行了一次<code>readToken()</code>获取到了k的类型, 然后根据k类型分支 将k的值转换成对应的value<br>之后又是一次<code>readToken()</code>判断是否存在<code>:</code>不存在就是错误<br>在之后使用这个方法, 保存<code>k</code>的vallue获取<code>v</code>的value再次调用<code>readValue()</code>填充值 返回后继续走</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里保存了name 这个k 将name的 v放入了顶层</span></span><br><span class="line">Value&amp; value = currentValue()[name];</span><br><span class="line">nodes_.push(&amp;value);</span><br><span class="line"><span class="keyword">bool</span> ok = readValue();</span><br></pre></td></tr></table></figure><p>读取完<code>v</code>的value之后必定是<code>,</code>或者<code>}</code>又是一次判断 成功判断后一个<code>k v</code>就获取完毕了</p><p><code>using Nodes = std::stack&lt;Value*&gt;</code><br>后面解析的代码更加的妙不可言, 使用<code>Nodes nodes_{}</code>存储当前的value 实现函数之间的操作</p><p>代码合理的组织<br>比如<code>case 对象分支</code>必定是一个<code>k</code>一个<code>:</code>一个<code>v</code> 然后一个分隔符<code>,</code>或<code>}</code> 这些放入了一个函数</p><p>然后获取到<code>k</code>之后使用<code>Value&amp; value = currentValue()[name]</code>获取<code>v</code></p><p>最后依然是递归的使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;t
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="源码学习" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>定义与声明详解</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-27T02:38:08.000Z</published>
    <updated>2020-02-27T03:26:16.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量声明和变量定义"><a href="#变量声明和变量定义" class="headerlink" title="变量声明和变量定义"></a>变量声明和变量定义</h1><p>变量声明: 用于向程序表明变量的类型和名字<br>变量定义: 用于为变量<em>分配存储空间</em>, 同时可为变量指定初始值</p><p>定义时会自动声明, 变量只能被定义一次, 却可以声明多次<br>extern声明不是定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// 声明i 但没有定义i</span></span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">// 定义且声明i</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">10</span>; <span class="comment">// 定义并声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果再函数体内部试图初始化一个由extern标记的变量,会引发错误</span></span><br></pre></td></tr></table></figure><h1 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h1><p>只有extern声明位于函数外部的时候,才能被初始化</p><p><strong>在C++中 可以用来声明全局变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="keyword">int</span> global_int = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> global_int;</span><br><span class="line"><span class="comment">// 后面可以直接使用 global_int, 因为他在其他地方定义了</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;变量声明和变量定义&quot;&gt;&lt;a href=&quot;#变量声明和变量定义&quot; class=&quot;headerlink&quot; title=&quot;变量声明和变量定义&quot;&gt;&lt;/a&gt;变量声明和变量定义&lt;/h1&gt;&lt;p&gt;变量声明: 用于向程序表明变量的类型和名字&lt;br&gt;变量定义: 用于为变量&lt;em&gt;分配
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective读书记录</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-Effective%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-Effective%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/</id>
    <published>2020-02-26T13:43:46.000Z</published>
    <updated>2020-03-01T09:42:35.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款02-尽量用const-enum-inline-替换-define"><a href="#条款02-尽量用const-enum-inline-替换-define" class="headerlink" title="条款02 尽量用const, enum, inline 替换#define"></a>条款02 尽量用const, enum, inline 替换#define</h2><p>前言 我目前自己做的框架中大量用了#define…. 因为用enum涉及到转换才能到int. 来学习下这条</p><p><strong>使用 const 常量来替换 #define</strong><br>谨防机号表出错, 特殊情况下 还能减少字量</p><p>#define无法限定作用域, 这点我已经感受到了</p><p>定义C风格常量字符串<br>const char* const NAME = “lsmg”; 防止指向和指向内容改变<br>定义C++风格常量字符串<br>const std::string NAME = “lsmg”;</p><p>class专属常量, 使用如下方式. 可以限定作用域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_ROOM = <span class="number">10000</span>; <span class="comment">// 常量声明式 - 常量且只有一份</span></span><br><span class="line">Gameroom* rooms[MAX_ROOM];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要获取class专属常量的地址, 或者需要定义式. 则需要在<code>实现文件</code>而非<code>头文件</code>, 如下声明<br><code>const int Game::MAX_ROOM</code> - 未给定初值<br>由于class常量已经在声明时获得初值, 所以不用在给定初值</p><p>这里我发现一件事情, 这本书 不能只读一遍, 最少两边完整的<br>前面就已经开始使用后面的条款了, 先着重本条款, 跨条款的等第二遍</p><h2 id="条款03-尽可能使用const"><a href="#条款03-尽可能使用const" class="headerlink" title="条款03 尽可能使用const"></a>条款03 尽可能使用const</h2><p><strong>总结</strong></p><ul><li>将某些东西声明为const可帮助编译器探测到错误用法<br>const可以用作在任何作用域内的对象, 函数参数, 函数返回类型, 成员函数本体</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = greeting;</span><br><span class="line"><span class="comment">// const 在 * 左边 被指物是常量 在右边自己是常量 两边都是常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = greeting; <span class="comment">// 指针指向可以变, 指向的值不能变</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">// 指针指向不可以变, 指向的值可以变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">// 都不可以变</span></span><br></pre></td></tr></table></figure><p><strong>const 参数, 可你帮你检查 == 被写成=的情况</strong><br>这本书看来挺有意思的2333333</p><p><strong>const 函数, 这里看不太懂 没有原来如此的感觉</strong></p><h2 id="条款04-确定对象使用前已经被初始化"><a href="#条款04-确定对象使用前已经被初始化" class="headerlink" title="条款04 确定对象使用前已经被初始化"></a>条款04 确定对象使用前已经被初始化</h2><p><strong>总结</strong></p><ul><li>为内置型对象进行手工初始化.</li><li>构造函数对号食用成员初值列, 不要在构造函数中赋值. 初值列次数应该与声明次序相同</li><li>为了免除 跨编译单元的初始化次数问题, 用<code>local static</code>对象替换<code>non-local static</code>对象</li></ul><p>永远在使用对象前, 进行初始化.<br>在构造函数中, 对所有值进行初始化<br>构造函数使用<code>成员初始列</code>进行<code>初始化操作</code>而非<code>赋值操作</code></p><p><strong>减少default构造函数不必要的调用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; &amp;room_list);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; room_list_;</span><br><span class="line"><span class="keyword">int</span> roomnum_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class="line">&#123;</span><br><span class="line">name_ = name; <span class="comment">// 这些都是赋值 不是初始化</span></span><br><span class="line">room_list_ = room_list;</span><br><span class="line">roomnum_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++规定 对象的 成员变量  初始化动作  发生在  进入构造函数本体  之前</span></span><br><span class="line"><span class="comment">// name_  room_list_  两个在构造函数中被赋值, 而初始化在进入构造函数之前</span></span><br><span class="line"><span class="comment">// ---发生在这些成员的default构造函数被调用的时候, (发生在进入构造函数前)</span></span><br><span class="line"><span class="comment">// ---roomnum_例外 int属于内置类型</span></span><br></pre></td></tr></table></figure><p>上面的初始化方式, 浪费了default的构造函数 所以推荐使用下面的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A::A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class="line">:name_(name), room_list_(room_list), roomnum_(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然最终结果相同, 但没有浪费default构造函数. 前两个调用的copy构造函数.</p><p><strong>还可以使用成员初值列 来default构造一个成员变量.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A::A()</span><br><span class="line">:name_(), room_list_(), roomnum_(<span class="number">0</span>)</span><br><span class="line">&#123; <span class="comment">// 前两个全部调用的default构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const reference 内置类型(初始化与赋值等成本) 一定成员初始值列</strong></p><p><strong>初始值列总是使用 声明次序进行初始化, 而非写的顺序, 所以最好按声明次序列出</strong></p><p><strong>不同编译单元内定义之 non-local static对象 的初始化 次序</strong><br>static对象: 虚构函数会在main() 结束时被自动调用<br>local static对象: 函数内的static对象<br>non-local对象: 其他static对象</p><p>编译单元: 产出单一目标文件的那些源码, 基本是单一源码文件和他包含的头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filesystem.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">GetNum</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> FIieSystem tfs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// directory.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Directory(params);</span><br><span class="line">&#125;</span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> num = tfs.GetNum(); <span class="comment">// 使用tfs对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function">Directory <span class="title">temp_dir</span><span class="params">(params)</span></span>;</span><br></pre></td></tr></table></figure><p>只有当 tfs在temp_dir初始化之前被初始化 才能得到正确的结果. 否则会调用未初始化的对象</p><p>但是这个次序无法保证<br>因为C++ 对这种情况没有明确定义</p><p>如何解决这个问题呢??<br>将每个<code>non-local static</code>对象搬到自己的专属函数内(该对象在此函数内被声明为static)<br>函数返回一个reference对象他所包含的对象<br>用户调用这个函数而不是直接调用对象</p><p>解决的原因呢?<br>C++ 保证函数内的<code>local static</code>对象 会在<code>函数被调用期间</code>, <code>首次遇到该对象的定义式</code>被初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filesystem.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">GetNum</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">FileSystem</span>&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">FileSystem</span> fs;</span><br><span class="line"><span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// directory.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Directory(params);</span><br><span class="line">&#125;</span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> num = tfs().GetNum(); <span class="comment">// 使用tfs对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">temp_dir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> Directory td;</span><br><span class="line"><span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造析构赋值运算"><a href="#构造析构赋值运算" class="headerlink" title="构造析构赋值运算"></a>构造析构赋值运算</h1><h2 id="条款0506-了解C-默认编写并调用哪些函数-并适当拒绝"><a href="#条款0506-了解C-默认编写并调用哪些函数-并适当拒绝" class="headerlink" title="条款0506 了解C++默认编写并调用哪些函数 并适当拒绝"></a>条款0506 了解C++默认编写并调用哪些函数 并适当拒绝</h2><p><strong>夹带如下私货-public-inline</strong></p><ul><li>一个构造函数(如果你没有任何构造函数)</li><li>一个拷贝构造函数</li><li>一个析构函数</li><li>一个拷贝</li></ul><p>拷贝构造函数和拷贝运算符 自动生成的只是单纯的将来源对象的每一个<code>non-static</code>成员变量<br>拷贝到目标对象</p><p><strong>遇到const 和 引用成员 默认的拷贝无法工作, 编译器会发出警告</strong></p><p><strong>将不需要的成员函数声明为private, 并且不实现</strong></p><h2 id="条款07-为多态基类声明virtual析构函数"><a href="#条款07-为多态基类声明virtual析构函数" class="headerlink" title="条款07 为多态基类声明virtual析构函数"></a>条款07 为多态基类声明virtual析构函数</h2><p>返回指向子类的 父类型指针.<br>如果delete这个指针, 在父类析构函数不是virtual的情况下, 很可能会导致<br>父类的成分被销毁, 然而子类多出来的部分不被销毁. 造成局部销毁!!</p><p><strong>防止局部销毁很简单, 将父类的析构函数声明为virtual</strong></p><p><strong>任何class 只要带有virtual函数 几乎确定应该有一个virtual析构函数</strong></p><p><strong>无端的声明virtual函数是错误的</strong><br>如果class不含virtual函数, 通常表示这个class 不是想做为父类, 这时如果将其析构函数声明为virual<br>是一个馊主意………….</p><p><em>class类的大小 = 成员变量占据大小 + vptr(vitual table pointer)指针大小(4~8 字节)</em></p><p>每一个带有virtual函数的class都有对应的vtbl</p><p>当对象调用某一vitual函数的时候, 实际调用的函数取决于<br>vptr(vitual table pointer)指针指向的vtbl(vitual table)</p><p>无端的使用virtual函数 会导致占用空间的增大</p><h2 id="条款08-别让异常逃离析构函数"><a href="#条款08-别让异常逃离析构函数" class="headerlink" title="条款08 别让异常逃离析构函数"></a>条款08 别让异常逃离析构函数</h2><p><strong>总结</strong></p><ul><li>析构函数绝对不要抛出异常, 如果被析构函数调用的函数可能抛出异常, 析构函数应该捕获所有异常<br>然后吞下它们, 或者结束程序</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应, class应该提供一个普通函数(而非在析构函数中)<br>执行操作</li></ul><p><strong>析构函数不要抛出异常</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">~Widget() &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Widget&gt; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>v</code>被销毁的时候, Widget的析构函数第一次抛出异常C++还能接受?<br>第二次就会造成不明确行为</p><h2 id="条款09-绝不在构造函数和析构过程中调用virtual函数"><a href="#条款09-绝不在构造函数和析构过程中调用virtual函数" class="headerlink" title="条款09: 绝不在构造函数和析构过程中调用virtual函数"></a>条款09: 绝不在构造函数和析构过程中调用virtual函数</h2><p><strong>总结</strong></p><ul><li>在构造和析构期间不要调用virtual函数, 因为这类调用从不下降到<code>子类</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Transaction();</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">LogTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">Transaction::Transaction()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">LogTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">LogTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTransaction</span>:</span> <span class="keyword">public</span> Transaction</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">LogTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure><p>BuyTransaction的构造函数会被调用, 但是父类的构造函数会更显被调用.<br>然后父类构造函数调用<code>LogTransaction()</code>的版本是<code>父类</code>的版本!!! 不是子类的版本</p><p>析构函数也是同样的道理, 当<code>子类</code>的析构函数执行后, <code>子类</code>中的属性值就成为未定义状态<br>进入<code>父类</code>后对象就成为一个<code>父类</code>对象</p><p>本例子中既然无法实现使用<code>virtual</code>函数从<code>父类</code>向下调用, 可以再构造期间, 将<br><code>子类</code>必要的构造信息向上传给<code>父类</code>的构造函数</p><h2 id="条款10-另operator-返回一个reference-to-this"><a href="#条款10-另operator-返回一个reference-to-this" class="headerlink" title="条款10: 另operator= 返回一个reference to *this"></a>条款10: 另operator= 返回一个reference to *this</h2><p>注意这只是一个协议, 并无强制性. 如果不遵守代码依然可以通过编译, 然而这份 协议被所有内置类型<br>和标准程序库提供的类型共同遵守.<br>因此除非你有一个标新立异的好理由, 不然还是随众吧</p><h2 id="条款11-在operator-中处理”自我赋值”"><a href="#条款11-在operator-中处理”自我赋值”" class="headerlink" title="条款11: 在operator= 中处理”自我赋值”"></a>条款11: 在operator= 中处理”自我赋值”</h2><p><strong>总结</strong></p><ul><li>确保当对象自我赋值时operator=有良好的的行为. 其中技术包括比较”来源对象”<br>和”目标对象”的地址, 精心周到的语句顺序, 以及copy-and-swap</li><li>确认任何函数如果操作一个以上的对象, 而其中多个对象是同一个对象的时候, 进行仍未正确</li></ul><p><strong>自我赋值是什么</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>...&#125;;</span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line">w=w; <span class="comment">// 什么这个看起来不可能, 那下面呢?</span></span><br><span class="line"></span><br><span class="line">a[i] = a[j]; <span class="comment">// 这个怎么样?  潜在的自我赋值</span></span><br><span class="line">*px = *py <span class="comment">// 这个呢? 潜在的自我赋值</span></span><br></pre></td></tr></table></figure><p><strong>会出现的问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gameroom</span>&#123;</span>....&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Gameroom* room_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator=的实现代码</span></span><br><span class="line">Game&amp; Game::<span class="keyword">operator</span>=(<span class="keyword">const</span> Game&amp; ths)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> room_;</span><br><span class="line">room_ = <span class="keyword">new</span> Gameroom(*ths.room_);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码 如果 this和ths指向同一个对象就会造成 <code>room_</code>构造失败<br>因为被<code>delete</code>的<code>room_</code>就是要传入的</p><p>如何解决这个问题呢?<br><em>比较来源对象 整同测试</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Game&amp; Game::<span class="keyword">operator</span>=(<span class="keyword">const</span> Game&amp; ths)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;ths)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> room_;</span><br><span class="line">room_ = <span class="keyword">new</span> Gameroom(*ths.room_);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果 <code>new Gameroom(*ths.room_)</code>错误, 导致room_指向不安全的内存<br>使用下面的代码, 可以导出异常安全, 以及自我赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Game&amp; Game::<span class="keyword">operator</span>=(<span class="keyword">const</span> Game&amp; ths)</span><br><span class="line">&#123;</span><br><span class="line">Gameroom* p_room = room_;</span><br><span class="line">room_ = <span class="keyword">new</span> Gameroom(*ths.room_);</span><br><span class="line"><span class="keyword">delete</span> p_room;</span><br><span class="line">retutn *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在如果<code>new Gameroom</code>抛出异常, room_还可以保持原状.<br>同时也能处理自我赋值</p><p><em>copy and swap</em><br>这一段描述我看完之后, 突然想到了上午看的Jsoncpp里面的代码!!!!! 就有这个<br>下面的代码更加高效 但是牺牲了清晰性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Game&amp; rhs)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Game&amp; Game::<span class="keyword">operator</span>=(<span class="keyword">const</span> Game&amp; ths)</span><br><span class="line">&#123;</span><br><span class="line">Game temp(<span class="keyword">this</span>);</span><br><span class="line">swap(temp);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;让自己习惯C&quot;&gt;&lt;a href=&quot;#让自己习惯C&quot; class=&quot;headerlink&quot; title=&quot;让自己习惯C++&quot;&gt;&lt;/a&gt;让自己习惯C++&lt;/h1&gt;&lt;h2 id=&quot;条款02-尽量用const-enum-inline-替换-define&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器编程读书记录-进程线程</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86/</id>
    <published>2020-02-25T14:34:39.000Z</published>
    <updated>2020-03-02T08:01:19.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十三章多进程编程"><a href="#第十三章多进程编程" class="headerlink" title="第十三章多进程编程"></a>第十三章多进程编程</h1><h2 id="exec系列系统调用"><a href="#exec系列系统调用" class="headerlink" title="exec系列系统调用"></a>exec系列系统调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 声明这个是外部函数或外部变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>** environ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻</span></span><br><span class="line"><span class="comment">// arg 和 argv用于向新的程序传递参数</span></span><br><span class="line"><span class="comment">// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量</span></span><br><span class="line"><span class="comment">// exec函数是不返回的, 除非出错</span></span><br><span class="line"><span class="comment">// 如果未报错则源程序被新的程序完全替换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* arg, ....)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">const</span> <span class="keyword">char</span>* arg, ..<span class="number">.0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* arg, ...., <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">char</span>* <span class="keyword">const</span> argv[], <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><h2 id="fork系统调用-进程的创建"><a href="#fork系统调用-进程的创建" class="headerlink" title="fork系统调用-进程的创建"></a>fork系统调用-进程的创建</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0</span></span><br><span class="line"><span class="comment">// 次返回值用于区分是父进程还是子进程</span></span><br><span class="line"><span class="comment">// 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(viod)</span></span>;</span><br></pre></td></tr></table></figure><p>fork系统调用<br>fork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项, 新的进程表项有很多的属性和原进程相同<br><code>堆指针</code> <code>栈指针</code> <code>标志寄存器的值</code>.<br>也存在不同的项目 该进程的PPID(父进程)被设置成原进程的PID,  信号位图被清除(原进程设置的信号处理函数对新进程无效)</p><p>子进程代码与父进程完全相同, 同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)了父进程的数据(堆数据, 栈数据, 静态数据)<br>创建子进程后, 父进程打开的文件描述符默认在子进程中也是打开的<br><code>文件描述符的引用计数</code>, <code>父进程的用户根目录, 当前工作目录等变量的引用计数</code> 均加1<br>(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)</p><h2 id="处理僵尸进程-进程的管理"><a href="#处理僵尸进程-进程的管理" class="headerlink" title="处理僵尸进程-进程的管理"></a>处理僵尸进程-进程的管理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>* stat_loc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)</span></span><br><span class="line"><span class="comment">// options函数取值WNOHANG-waitpid立即返回</span></span><br><span class="line"><span class="comment">// 如果目标子进程正常退出, 则返回子进程的pid</span></span><br><span class="line"><span class="comment">// 如果还没有结束或意外终止, 则立即返回0</span></span><br><span class="line"><span class="comment">// 调用失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* stat_loc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line">WIFEXITED(stat_val); <span class="comment">// 子进程正常结束, 返回一个非0</span></span><br><span class="line">WEXITSTATUS(stat_val); <span class="comment">// 如果WIFEXITED 非0, 它返回子进程的退出码</span></span><br><span class="line">WIFSIGNALED(stat_val);<span class="comment">// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值</span></span><br><span class="line">WTERMSIG(stat_val);<span class="comment">// 如果WIFSIGNALED非0 返回一个信号值</span></span><br><span class="line">WIFSTOPPED(stat_val);<span class="comment">// 如果子进程意外终止, 它返回一个非0值</span></span><br><span class="line">WSTOPSIG(stat_val);<span class="comment">// 如果WIFSTOPED非0, 它返回一个信号值</span></span><br></pre></td></tr></table></figure><p>对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询</p><ul><li>在<code>子进程结束运行之后, 父进程读取其退出状态前</code>, 我们称该子进程处于<code>僵尸态</code></li><li>另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) <code>父进程结束运行之后, 子进程退出之前</code>, 处于<code>僵尸态</code></li></ul><p>以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.</p><p>waitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.<br>SIGCHLD信号- 子进程结束后将会给父进程发送此信号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_child</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> stat;</span><br><span class="line"><span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 善后处理emmmm</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>管道</strong><br>管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证<br>父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].</p><p>可以用两个管道来实现双向传输数据, 也可以用<code>socketpair</code>来创建管道</p><h2 id="信号量-进程的锁"><a href="#信号量-进程的锁" class="headerlink" title="信号量-进程的锁"></a>信号量-进程的锁</h2><p><em>信号量原语</em><br>只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.<br>假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为</p><ul><li>P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行</li><li>V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png" alt=""></li></ul><p>创建信号量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semeget 系统调用</span></span><br><span class="line"><span class="comment">// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集</span></span><br><span class="line"><span class="comment">// key 参数是一个键值, 用来标识一个全局唯一的信号量级, 就像文件名全局唯一地标识一个文件一样.</span></span><br><span class="line"><span class="comment">// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0</span></span><br><span class="line"><span class="comment">// sem_flags指定一组标志, 与调用open函数的mode参数相同用来控制权限</span></span><br><span class="line"><span class="comment">// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错</span></span><br><span class="line"><span class="comment">// - 联合使用IPC_CREAT和IPC_EXCL来创建一组新的唯一额信号量集</span></span><br><span class="line"><span class="comment">// - 如果已经存在则会返回错误 errno = EEXIST</span></span><br><span class="line"><span class="comment">// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br></pre></td></tr></table></figure><p>semget成功时返回一个与之关联的内核结构体semid_ds</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> sem_nsems; <span class="comment">// 被设置为num_sems</span></span><br><span class="line"><span class="keyword">time_t</span> sem_otime; <span class="comment">// 被设置为0</span></span><br><span class="line"><span class="keyword">time_t</span> sem_ctime; <span class="comment">// 被设置为当前的系统时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用来描述权限</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">uid_t</span> uid; <span class="comment">// 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="keyword">gid_t</span> gid; <span class="comment">// 所有者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="keyword">uid_t</span> cuid; <span class="comment">// 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="keyword">gid_t</span> cgid; <span class="comment">// 创建者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="keyword">mode_t</span> mode;<span class="comment">// 访问权限, 背着只为sem_flags参数的最低9位.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>与semop信号量关联的一些重要的内核变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> short semval; <span class="comment">// 信号量的值</span></span><br><span class="line"><span class="keyword">unsigned</span> short semzcnt; <span class="comment">// 等待信号量值变为0的进程数量</span></span><br><span class="line"><span class="keyword">unsigned</span> short semncnt<span class="comment">// 等待信号量值增加的进程数量</span></span><br><span class="line"><span class="keyword">pid_t</span> sempid; <span class="comment">// 最后一次执行semop操作的进程ID</span></span><br></pre></td></tr></table></figure><p>操作信号量, 实际上就是对上面的内核变量操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> short <span class="keyword">int</span> sem_num;<span class="comment">// 信号量集中信号量的编号, 0表示信号量集中的第一个信号量</span></span><br><span class="line">short <span class="keyword">int</span> sem_op; <span class="comment">// 指定操作类型,</span></span><br><span class="line">short <span class="keyword">int</span> sem_flg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.</span></span><br><span class="line"><span class="comment">// sem_ops 参数指向一个sembuf结构体类型的数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> sem_id, struct sembuf* sem_ops, <span class="keyword">size_t</span> num_sem_ops)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sem_op 每种类型的操作行为又受到sem_flags成员的影响</span></span><br><span class="line"><span class="comment">// sem_flag 可选值是可选正整数 0 负整数. </span></span><br><span class="line"><span class="comment">// - IPC_NOWAIT(无论信号量操作是否成功, 都立即返回), </span></span><br><span class="line"><span class="comment">// - SEM_UNDO (当进程退出的时候, 取消正在进行的semop操作)</span></span><br><span class="line"><span class="comment">// -- sem_op &gt; 0</span></span><br><span class="line"><span class="comment">// -- 则semop将被操作的信号量的值semval增加sem_op, 要求调用进程对被操作的信号量集有写权限</span></span><br><span class="line"><span class="comment">// -- 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)</span></span><br><span class="line"><span class="comment">// -- sem_op = 0</span></span><br><span class="line"><span class="comment">// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限</span></span><br><span class="line"><span class="comment">// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0</span></span><br><span class="line"><span class="comment">// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN</span></span><br><span class="line"><span class="comment">// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生</span></span><br><span class="line"><span class="comment">// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1</span></span><br><span class="line"><span class="comment">// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM</span></span><br><span class="line"><span class="comment">// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1</span></span><br><span class="line"><span class="comment">// -- sem_op &lt; 0</span></span><br><span class="line"><span class="comment">// -- 表示对信号量的值进行减操作, 即期望获得信号量, 要求调用进程对被操作信号量集有写权限</span></span><br><span class="line"><span class="comment">// -- 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量</span></span><br><span class="line"><span class="comment">// -- 且semval -= abs(sem_op)</span></span><br><span class="line"><span class="comment">// -- 如果此时这定了SEM_UNDO的标志, 系统更新进程的semadj变量</span></span><br><span class="line"><span class="comment">// -- 如果semval &lt; abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN</span></span><br><span class="line"><span class="comment">// -- 如果没有指定则阻塞进程等待信号量可用, 且 semzcnt +=1, 等到下面三种情况唤醒</span></span><br><span class="line"><span class="comment">// -- 1 发生semval &gt;= abs(sem_op), semzcnt-=1, semval -= abs(sem_op). 在SEM_UNDO设置时更新semadj</span></span><br><span class="line"><span class="comment">// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)</span></span><br><span class="line"><span class="comment">// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)</span></span><br><span class="line"><span class="comment">// num_sem_ops 指定要执行的操作个数, 即sem_ops数组中的元素个数, semop对sem_ops[] 中的每个成员按顺序操作,</span></span><br><span class="line"><span class="comment">// 并且是原子操作</span></span><br><span class="line"><span class="comment">// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semctl 系统调用</span></span><br><span class="line"><span class="comment">// sem_id 参数是由semget返回的信号量集标识符</span></span><br><span class="line"><span class="comment">// sen_num指定被操作的信号量在信号集中的编号</span></span><br><span class="line"><span class="comment">// command指定命令, 可以追加命令所需的参数, 不过有推荐格式</span></span><br><span class="line"><span class="comment">// 成功返回对应command的参数, 失败返回-1 errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> command, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>结构体<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/1.png" alt=""></p><p>command参数<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/semctl%E7%9A%84command%E5%8F%82%E6%95%B0.png" alt=""><br>除去GETALL以外的 其他GET都是操作的单个信号量, 由sem_id指定的第sem_num个信号量.<br>其他操作针对整个信号量集, 此时semctl的参数sem_num被忽略</p><p><em>特殊键值IPC_PRIVATE</em><br>semget的调用者可以给其key参数传递一个特殊的键值<code>IPC_PRIVATE</code>, 这样无论该信号量是否已经存在<br>semget都将创建一个新的信号量.</p><p><strong>总结PV使用方法</strong><br>使用<code>semget</code>获取到唯一的标识.<br>使用<code>semctl</code>的<code>SETVAL</code>传入初始化val的<code>sem_un</code>联合体.来初始化val<br>调用<code>semop</code> 传入唯一标识, <code>sem_op=-1</code>执行P(锁)操作<code>sem_op=1</code>执行V(开锁)操作<br>开关锁通过当<code>sem_op=-1,semval=0</code><br>且未指定<code>IPC_NOWAIT</code><br>等待<code>semval</code>被<code>sem_op=1</code>改为<code>semval=1</code></p><h2 id="共享内存-进程间通信"><a href="#共享内存-进程间通信" class="headerlink" title="共享内存-进程间通信"></a>共享内存-进程间通信</h2><p>最高效的IPC(进程间通信)机制<br>需要自己同步进程对其的访问, 否则会产生竞态条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key</span></span><br><span class="line"><span class="comment">// 与semget相同 标识一段全局唯一的共享内存</span></span><br><span class="line"><span class="comment">// size 内存区域大小 单位字节</span></span><br><span class="line"><span class="comment">// shmflg</span></span><br><span class="line"><span class="comment">// shmflg的参数与semget相同, 同时多了两个额外的参数</span></span><br><span class="line"><span class="comment">// `SHM_HUGETLB`系统将使用"大页面"来为共享内存分配空间</span></span><br><span class="line"><span class="comment">// `SHM_NORESERVE`不为共享内存保留swap空间, 如果物理内存不足</span></span><br><span class="line"><span class="comment">// 在执行写操作的时候将会触发`SIGSEGV`信号</span></span><br><span class="line"><span class="comment">// 成功返回唯一标识, 失败返回-1 errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> shmflg)</span></span></span><br></pre></td></tr></table></figure><p>同时会创建对应的<code>shmid_ds</code>结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_per</span>;</span> <span class="comment">// 权限相关</span></span><br><span class="line"><span class="keyword">size_t</span> shm_segsz; <span class="comment">// 共享内存大小 单位字节size</span></span><br><span class="line"><span class="keyword">__time_t</span> shm_atime; <span class="comment">// 对这段内存最后一次调用semat的时间 0</span></span><br><span class="line"><span class="keyword">__time_t</span> shm_dtime; <span class="comment">// 对这段内存最后一次调用semdt的时间 0</span></span><br><span class="line"><span class="keyword">__time_t</span> shm_ctime; <span class="comment">// 对这段内存最后一次调用semctl的时间 当前时间</span></span><br><span class="line"><span class="keyword">__pid_t</span> shm_cpid; <span class="comment">// 创建者PID</span></span><br><span class="line"><span class="keyword">__pid_t</span> lpid; <span class="comment">// 最后一次执行shmat或shmdt的进程PID</span></span><br><span class="line"><span class="keyword">shmatt_t</span> shm_nattach <span class="comment">// 关联到此共享内存空间的进程数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将共享内存关联到进程的地址空间<br>调用成功之后, 修改shmid_ds的部分<br>shm_nattach +1<br>更新 shm_lpid和shm_atime设置为当前时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shm_id </span></span><br><span class="line"><span class="comment">// shmget返回的唯一标识</span></span><br><span class="line"><span class="comment">// shm_addr </span></span><br><span class="line"><span class="comment">// 关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响</span></span><br><span class="line"><span class="comment">// 如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强</span></span><br><span class="line"><span class="comment">// 如果 shm_addr 非空,且没有`SHM_RND`标志 则关联到指定的地址处</span></span><br><span class="line"><span class="comment">// 如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写*</span></span><br><span class="line"><span class="comment">// shmflg</span></span><br><span class="line"><span class="comment">// SHM_RDONLY 设置后内存内容变成只读</span></span><br><span class="line"><span class="comment">// SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联</span></span><br><span class="line"><span class="comment">// SHM_EXEC 有执行权限 = 读权限</span></span><br><span class="line"><span class="comment">// 成功返回关联到的地址, 失败返回 (void*)-1 errno</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span>* shm_addr, <span class="keyword">int</span> shmflg)</span></span></span><br></pre></td></tr></table></figure><p>将共享内存从进程地址空间中分离<br>成功后<br>shm_nattach -1<br>更新 shm_lpid和shm_dtime设置为当前时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功返回0 失败返回-1 errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* shm_addr)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_ctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds* buf)</span></span></span><br></pre></td></tr></table></figure><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/shmctl.png" alt=""></p><h1 id="第十四章-多线程编程"><a href="#第十四章-多线程编程" class="headerlink" title="第十四章 多线程编程"></a>第十四章 多线程编程</h1><p>根据运行环境和调度者身份, 线程可以分为两种<br>内核线程<br>运行在内核空间, 由内核来调度.<br>用户线程<br>运行在用空间, 由线程库来调用</p><p>当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.</p><p>线程有三种实现方式</p><ul><li>完全在用户空间实现-无需内核支持<br>  创建和调度线程无需内核干预, 速度很快.<br>  不占用额外的内核资源, 对系统影响较小<br>  但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的</li><li>完全由内核调度<br>  创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理<br>  优缺点正好与上一个相反</li><li>双层调度<br>  结合了前两个的优点<br>  不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势</li></ul><h2 id="进程的创建和终止"><a href="#进程的创建和终止" class="headerlink" title="进程的创建和终止"></a>进程的创建和终止</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/pthreadtypes.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">pthread_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* attr, <span class="keyword">void</span>* (*start_routine)(<span class="keyword">void</span>*), <span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0 失败返回错误码</span></span><br><span class="line"><span class="comment">// thread 用来唯一的标识一个新线程</span></span><br><span class="line"><span class="comment">// attr用来设置新县城的属性 传递NULL表示默认线程属性</span></span><br><span class="line"><span class="comment">// start_routine 指定新线程运行的函数</span></span><br><span class="line"><span class="comment">// arg指定函数的参数</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span>* retval)</span></span>;</span><br><span class="line">用来保证线程安全干净的退出, 线程函数最好结束时调用.</span><br><span class="line">通过`retval`参数向线程的回收者传递其退出信息</span><br><span class="line">执行后不会返回到调用者, 而且永远不会失败</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span>** retval)</span></span></span><br><span class="line">可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.</span><br><span class="line">成功时返回<span class="number">0</span>, 失败返回错误码</span><br><span class="line">等待其他线程结束</span><br><span class="line">thread 线程标识符</span><br><span class="line">retval 目标线程的退出返回信息</span><br><span class="line"></span><br><span class="line">错误码如下</span><br><span class="line">`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用</span><br><span class="line">`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程</span><br><span class="line">`ESRCH`目标线程不存在</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span></span><br><span class="line">异常终止一个线程, 即为取消线程</span><br><span class="line">成功返回<span class="number">0</span>, 失败返回错误码</span><br><span class="line"></span><br><span class="line">接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.</span><br><span class="line">一下两个函数成功返回<span class="number">0</span> 失败返回错误码</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动线程取消</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstart</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span>* oldstate)</span></span></span><br><span class="line">第一个参数</span><br><span class="line">PTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态</span><br><span class="line">PTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求指导</span><br><span class="line">这个线程允许被取消</span><br><span class="line">第二个参数 返回之前设定的状态</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程取消类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span>* oldtype)</span></span></span><br><span class="line">第一个参数</span><br><span class="line">PTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消</span><br><span class="line">PTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 知道调用了下面几个所谓的取消点函数</span><br><span class="line">最好使用`pthread_testcancel`函数设置取消点</span><br><span class="line">设置取消类型(如何取消)</span><br><span class="line">第二个参数</span><br><span class="line">原来的取消类型</span><br></pre></td></tr></table></figure><h2 id="POSIX信号量-进程的同步"><a href="#POSIX信号量-进程的同步" class="headerlink" title="POSIX信号量-进程的同步"></a>POSIX信号量-进程的同步</h2><p>多线程也必须考虑线程同步的问题.<br>虽然<code>pthread_join</code>可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求<br>比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.</p><p>以下函数成功返回0 失败返回-1 errno<br><code>int sem_init(sem_t* sem, int pshared, unsigned int value)</code><br>用于初始化一个未命名的信号量.<br>如果<code>pshared</code>为0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享<br><code>value</code>指定参数的初始值<br><em>初始化已经存在的信号量会导致无法预期的结果</em></p><p><code>int sem_destory(sem_t* sem)</code><br>销毁信号量, 释放其占用的系统资源<br><em>销毁正被其他线程等待的信号量, 将会导致无法预期的结果</em></p><p><code>int sem_wait(sem_t* sem)</code><br>以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞, 知道信号量具有非0值</p><p><code>int sem_trywait(sem_t* sem)</code><br>跟上面的函数相同不过不会阻塞. 信号量不为0 则 -1, 为0 则返回-1 errno</p><p><code>int sem_post(sem_t sem)</code><br>原子操作将信号量的值 +1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十三章多进程编程&quot;&gt;&lt;a href=&quot;#第十三章多进程编程&quot; class=&quot;headerlink&quot; title=&quot;第十三章多进程编程&quot;&gt;&lt;/a&gt;第十三章多进程编程&lt;/h1&gt;&lt;h2 id=&quot;exec系列系统调用&quot;&gt;&lt;a href=&quot;#exec系列系统调用&quot; cla
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>CPP11特性</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-CPP11%E7%89%B9%E6%80%A7/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-CPP11%E7%89%B9%E6%80%A7/</id>
    <published>2020-02-19T09:41:27.000Z</published>
    <updated>2020-02-20T15:21:12.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><p>参考资料<br><a href="https://zh.cppreference.com/w/cpp/language/lambda" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/language/lambda</a><br><a href="https://blog.csdn.net/qq_34199383/article/details/80469780" target="_blank" rel="noopener">https://blog.csdn.net/qq_34199383/article/details/80469780</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[ 捕获 ] ( 形参 ) -&gt; ret &#123; 函数体 &#125;</span><br><span class="line">[ 捕获 ] ( 形参 ) &#123; 函数体 &#125;</span><br><span class="line">[ 捕获 ] &#123; 函数体 &#125;</span><br><span class="line"></span><br><span class="line">&amp; 以引用隐式捕获被使用的自动变量</span><br><span class="line">= 以复制隐式捕获被使用的自动变量</span><br><span class="line"></span><br><span class="line">[&amp;]&#123;&#125;;          <span class="comment">// OK：默认以引用捕获</span></span><br><span class="line">[&amp;, i]&#123;&#125;;       <span class="comment">// OK：以引用捕获，但 i 以值捕获</span></span><br><span class="line"></span><br><span class="line">[=]&#123;&#125;;          <span class="comment">// OK：默认以复制捕获</span></span><br><span class="line">[=, &amp;i]&#123;&#125;;      <span class="comment">// OK：以复制捕获，但 i 以引用捕获</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">this</span>]&#123;&#125;; <span class="comment">// 获取this指针, 如果使用了&amp;和=则会默认包括this</span></span><br></pre></td></tr></table></figure><p><strong>使用场景一</strong><br>以sort为代表的函数 需要传入函数的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原版</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xxx(compare);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新版</span></span><br><span class="line">xxx([](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a &gt; b;&#125;);</span><br></pre></td></tr></table></figure><p><strong>使用场景二</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a + b;&#125;;</span><br><span class="line"><span class="keyword">int</span> bar = add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h1 id="类型特性"><a href="#类型特性" class="headerlink" title="类型特性"></a>类型特性</h1><p><a href="https://zh.cppreference.com/w/cpp/types#.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/types#.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29</a></p><p>神仙的头文件<type_traits> 可以判断一个值是否是某个类型</p><p>比如判断一个值<br>是不是 整形<br>是不是 void<br>是不是 数组 等等</p><p>目前不知道用在什么地方合适….. 留个连接备用吧</p><h1 id="花括号初始"><a href="#花括号初始" class="headerlink" title="花括号初始"></a>花括号初始</h1><h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><h2 id="std-function-functional"><a href="#std-function-functional" class="headerlink" title="std::function  functional"></a>std::function  functional</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintB</span><span class="params">(<span class="keyword">int</span> bar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; FPrintA = PrintA;</span><br><span class="line">    FPrintA();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; FPrintB = PrintB;</span><br><span class="line">    FPrintB(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 感觉配合Lambad 挺不错, 在一个函数中经常使用的功能可以这样定义</span></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; FLambad = []()&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Lambad"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    FLambad();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不过使用auto貌似更简单</span></span><br><span class="line"><span class="keyword">auto</span> ALambad = []()&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Lambad"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    ALambad();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ A</span><br><span class="line">$ B</span><br><span class="line">$ Lambad</span><br></pre></td></tr></table></figure><h2 id="std-pair-utility-std-tuple-tuple"><a href="#std-pair-utility-std-tuple-tuple" class="headerlink" title="std::pair utility std::tuple tuple"></a>std::pair utility std::tuple tuple</h2><p><a href="https://zh.cppreference.com/w/cpp/utility/tuple" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/utility/tuple</a></p><p>pair是 结构体模板, 可在一个单元中存储两个相异对象. pair是tuple拥有两个元素的特殊情况</p><p>tuple是固定大小的异类值(啥是异类值??)汇集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;int, double &gt; GetInfoById(int id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1</span>, <span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">2</span>, <span class="number">2.2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::invalid_argument(<span class="string">"id"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> info = GetInfoById(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取指定位置</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(info)</span><br><span class="line">            &lt;&lt; <span class="string">" 2:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(info) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val1;</span><br><span class="line">    <span class="keyword">double</span> val2;</span><br><span class="line"><span class="comment">// 直接创建引用的tuple</span></span><br><span class="line">    <span class="built_in">std</span>::tie(val1, val2) = GetInfoById(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1:"</span> &lt;&lt; val1</span><br><span class="line">              &lt;&lt; <span class="string">" 2:"</span> &lt;&lt; val2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">$ <span class="number">1</span>:<span class="number">1</span> <span class="number">2</span>:<span class="number">1.1</span></span><br><span class="line">$ <span class="number">1</span>:<span class="number">2</span> <span class="number">2</span>:<span class="number">2.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lambda&quot;&gt;&lt;a href=&quot;#Lambda&quot; class=&quot;headerlink&quot; title=&quot;Lambda&quot;&gt;&lt;/a&gt;Lambda&lt;/h1&gt;&lt;p&gt;参考资料&lt;br&gt;&lt;a href=&quot;https://zh.cppreference.com/w/cpp/lan
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>Libevent代码初期了解</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Libevent%E4%BB%A3%E7%A0%81%E5%88%9D%E6%9C%9F%E4%BA%86%E8%A7%A3/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Libevent%E4%BB%A3%E7%A0%81%E5%88%9D%E6%9C%9F%E4%BA%86%E8%A7%A3/</id>
    <published>2020-02-19T06:56:55.000Z</published>
    <updated>2020-03-01T02:21:50.230Z</updated>
    
    <content type="html"><![CDATA[<p>学习来源<br>&lt;Linux 高性能服务器编程&gt;</p><h1 id="I-O框架库概述"><a href="#I-O框架库概述" class="headerlink" title="I/O框架库概述"></a>I/O框架库概述</h1><h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-1IO%E6%A1%86%E6%9E%B6%E7%BB%84%E7%BB%84%E4%BB%B6.png" alt=""><br>句柄(Handler)<br>由于统一了事件源, 一个事件一般跟一个句柄绑定在一起, 事件就绪之后 会通过句柄通知这一个事件.<br>在Linux中 I/O 事件对应的句柄-&gt;文件描述符, 信号事件-&gt;信号值</p><p>事件多路分发器(EventDemultiplexer)<br>事件的到来是随机的, 异步的. 所以只能通过一个循环一直等待事件并进行处理 — 事件循环<br>一般通过IO复用实现 select poll epoll_wait</p><p>事件处理器(EventHandle)<br>具体事件处理器(ConcreteEventHandler)<br>事件处理器执行事件对应的业务逻辑, 通常包含一个或多个handler_event回调函数, 这些回调函数在事件循环中被执行</p><p>Reactor<br>handler_events: 执行事件循环 重复等待事件, 然后依次调用对应的事件处理器<br>register_handler: 向事件多路分发器中注册事件<br>remove_handler: 从中删除一个事件</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-2%20IO%E6%A1%86%E6%9E%B6%E5%BA%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt=""></p><h2 id="Libevent源码分析"><a href="#Libevent源码分析" class="headerlink" title="Libevent源码分析"></a>Libevent源码分析</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_cb</span><span class="params">(<span class="keyword">int</span> fd, short event, <span class="keyword">void</span>* argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    event_base* base = (event_base*)argc;</span><br><span class="line">    timeval <span class="built_in">delay</span> = &#123;<span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Caught an interrupt signal\n"</span>);</span><br><span class="line">    event_base_loopexit(base, &amp;<span class="built_in">delay</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeout_cb</span><span class="params">(<span class="keyword">int</span> fd, short event, <span class="keyword">void</span>* argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"timeout\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 相当于创建一个Reactor实例</span></span><br><span class="line">    event_base* base = event_init();</span><br><span class="line">    </span><br><span class="line">    event* signal_event = evsignal_new(base, SIGINT, signal_cb, base);</span><br><span class="line">    event_add(signal_event, <span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    event* timeout_event = evtimer_new(base, timeout_cb, <span class="literal">nullptr</span>);</span><br><span class="line">    timeval tv&#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    event_add(timeout_event, &amp;tv);</span><br><span class="line">    </span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line">    event_free(signal_event);</span><br><span class="line">    event_free(timeout_event);</span><br><span class="line">    event_base_free(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个事件处理器 然后为绑定上相应的回调函数.<br>然后把这个事件处理器注册到事件队列中中,</p><p>然后事件多路分发器依靠循环一直等待事件的到来, 事件到来后通知相应的事件处理器<br>Reactor则管理这些</p><p>首先要去了解下 <code>事件处理器</code> 对应的就是event这个结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_callback</span> <span class="title">ev_evcallback</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件处理器从属的 event_base</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">ev_base</span>;</span></span><br><span class="line"><span class="comment">// 信号值 或者 文件描述符</span></span><br><span class="line"><span class="keyword">evutil_socket_t</span> ev_fd;</span><br><span class="line"><span class="comment">// 定时器的超时时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ev_timeout</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅用于定时事件</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="comment">// 队列--指出在通用定时器中的位置</span></span><br><span class="line">TAILQ_ENTRY(event) ev_next_with_common_timeout;</span><br><span class="line"><span class="comment">// 时间堆--指出了在时间堆中的位置</span></span><br><span class="line"><span class="keyword">int</span> min_heap_idx;</span><br><span class="line">&#125; ev_timeout_pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">// 通过这个成员 将具有相同文件描述符的IO事件处理器串联起来</span></span><br><span class="line">LIST_ENTRY (event) ev_io_next;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ev_timeout</span>;</span></span><br><span class="line">&#125; ev_io;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">// 相同信号的串联起来</span></span><br><span class="line">LIST_ENTRY (event) ev_signal_next;</span><br><span class="line">short ev_ncalls;</span><br><span class="line"><span class="comment">/* Allows deletes in callback */</span></span><br><span class="line">short *ev_pncalls;</span><br><span class="line">&#125; ev_signal;</span><br><span class="line">&#125; ev_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件类型, 可以通过位处理设置非互斥事件</span></span><br><span class="line">short ev_events;</span><br><span class="line"><span class="comment">// 当前激活事件的类型, 说明被激活的原因</span></span><br><span class="line">short ev_res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到其中有很多的属性, 三种事件对应的不同的属性.</p><p>这些属性的填充函数<br><code>evsignal_new``evtimer_new</code>是宏 统一调用<code>event_new</code><br><code>event_new</code>调用<code>event_assign</code>来进行主要的填充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;@通过宏封装注册函数</span><br><span class="line"></span><br><span class="line">一个事件生成函数 经过宏的封装(可以自动填充某些此事件用不到的参数)可以更方便的对应不同事件的生成, 既统一了注册, 又方便用户调用</span><br></pre></td></tr></table></figure><p>属性之一便是回调函数, 事件回调函数有自己的规定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;@统一事件回调函数</span><br><span class="line"></span><br><span class="line">void (*callback)(evutil_socket_t, short, void *)</span><br><span class="line">这样能够统一回调函数的格式, 同时方便管理</span><br></pre></td></tr></table></figure><p>事件处理器创建完毕, 该把事件处理器添加到事件注册队列. 样例代码中通过的<code>event_add</code>函数来实现将事件处理器添加到事件注册队列<br><code>event_add</code>实际由<code>event_add_nolock_</code>实现 所以接下来是<code>event_add_nolock_</code>函数的说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;@事件处理器的分发实现</span><br><span class="line">将传入的event按照不同类型的事件处理器 分别处理</span><br><span class="line">(因为event_new已经填充了ev_events说明事件类型)</span><br><span class="line"></span><br><span class="line">IO事件 添加绑定</span><br><span class="line">信号事件 绑定相应的信号</span><br><span class="line">定时器 放入相关的的时间管理数据结构中</span><br></pre></td></tr></table></figure><p>使用<code>event_queue_insert_inserted</code>进行注册<br>这里的代码2.1.11 与书上的差别较大, 少了多一半的功能, 也没有被抽成函数, 暂不知道对应的功能代码去了哪里<br>照书上来说<code>event_queue_insert_inserted</code>实现的是将事件处理器加入到<code>event_base</code>的某个事件队列中. 对于新添加的IO和信号事件处理器, 还需要让事件多路分发器来监听对应的事件, 然后建立相应的映射关系. 分别使用<code>evmap_io_add_</code>和<code>evmap_signal_add_</code>(相当于图中的<code>register_event</code>)建立映射. </p><p><code>evmap_io_add_</code>中有一个结构体<code>event_io_map</code><br><code>event_io_map</code>会根据不同的平台最终对应不同的数据结构</p><p><code>evmap_io_add_</code>函数<br>函数中用到的东西, 我目前吸收不了……. 总之是为将IO事件处理器加入到<code>event_base</code>的事件队列中实现的</p><p><code>eventop</code>结构体 是<code>event_base</code>中封装IO复用机制的结构体, 提供了统一的接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为给定的event_base声明后端的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> &#123;</span></span><br><span class="line"><span class="comment">// 后端IO复用技术的名称</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 函数需要初始化所有要用的属性</span></span><br><span class="line"><span class="comment">// 返回的指针会被event_init存储在event_base.evbase</span></span><br><span class="line"><span class="comment">// 失败后返回NULL</span></span><br><span class="line"><span class="keyword">void</span> *(*init)(struct event_base *);</span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line"><span class="keyword">int</span> (*add)(struct event_base *, <span class="keyword">evutil_socket_t</span> fd, short old, short events, <span class="keyword">void</span> *fdinfo);</span><br><span class="line"><span class="comment">// 删除事件</span></span><br><span class="line"><span class="keyword">int</span> (*del)(struct event_base *, <span class="keyword">evutil_socket_t</span> fd, short old, short events, <span class="keyword">void</span> *fdinfo);</span><br><span class="line"><span class="comment">// 等待事件</span></span><br><span class="line"><span class="keyword">int</span> (*dispatch)(struct event_base *, struct timeval *);</span><br><span class="line"><span class="comment">// 释放IO复用机制使用的资源</span></span><br><span class="line"><span class="keyword">void</span> (*dealloc)(struct event_base *);</span><br><span class="line"><span class="comment">// 标记fork后是否需要重新初始化event_base的标志位</span></span><br><span class="line"><span class="keyword">int</span> need_reinit;</span><br><span class="line"><span class="comment">// 用于设定io复用技术支持的一些特性</span></span><br><span class="line"><span class="keyword">enum</span> event_method_feature features;</span><br><span class="line"><span class="comment">// 额外内存的分配</span></span><br><span class="line"><span class="keyword">size_t</span> fdinfo_len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>event_base</code>是Libevent的Reactor. 超长结构体 删除了我不理解的部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> &#123;</span></span><br><span class="line"><span class="comment">// 记录选择的I/O复用机制</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span>;</span></span><br><span class="line"><span class="comment">// 指向IO复用机制真正存储的数据</span></span><br><span class="line"><span class="keyword">void</span> *evbase;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件变换队列 如果一个文件描述符上注册的事件被多次修改, 则可以使用缓冲避免重复的系统调用</span></span><br><span class="line"><span class="comment">// 比如epoll_ctl, 仅能用于时间复杂度O(1)的IO复用技术</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_changelist</span> <span class="title">changelist</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号的后端处理机制</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsigsel</span>;</span></span><br><span class="line"><span class="comment">// 信号事件处理器使用的数据结构, 其中封装了socketpair创建的管道. 用于信号处理函数和</span></span><br><span class="line"><span class="comment">// 事件多路分发器之间的通信, 统一事件源的思路</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evsig_info</span> <span class="title">sig</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到event_base的虚拟(所有, 激活)事件数量, 虚拟(所有, 激活)事件最大数量</span></span><br><span class="line"><span class="keyword">int</span> virtual_event_count;</span><br><span class="line"><span class="keyword">int</span> virtual_event_count_max;</span><br><span class="line"><span class="keyword">int</span> event_count;</span><br><span class="line"><span class="keyword">int</span> event_count_max;</span><br><span class="line"><span class="keyword">int</span> event_count_active;</span><br><span class="line"><span class="keyword">int</span> event_count_active_max;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完事件后 是否退出循环</span></span><br><span class="line"><span class="keyword">int</span> event_gotterm;</span><br><span class="line"><span class="comment">// 是否立即终止循环</span></span><br><span class="line"><span class="keyword">int</span> event_break;</span><br><span class="line"><span class="comment">// 是否启动一个新的事件循环</span></span><br><span class="line"><span class="keyword">int</span> event_continue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前正在处理的活动事件队列的优先级</span></span><br><span class="line"><span class="keyword">int</span> event_running_priority;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记事件循环是否已经启动, 防止重入</span></span><br><span class="line"><span class="keyword">int</span> running_loop;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 活动事件队列数组. 索引值越小的队列优先级越高. 高优先级的活动事件队列中的事件处理器被优先处理</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evcallback_list</span> *<span class="title">activequeues</span>;</span></span><br><span class="line"><span class="comment">// 活动事件队列数组的大小 说明有nactivequeues个不同优先级的活动事件队列</span></span><br><span class="line"><span class="keyword">int</span> nactivequeues;</span><br><span class="line"><span class="comment">/** A list of event_callbacks that should become active the next time</span></span><br><span class="line"><span class="comment"> * we process events, but not this time. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evcallback_list</span> <span class="title">active_later_queue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共同超时逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理通用定时器队列 实体数量 总数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">common_timeout_list</span> **<span class="title">common_timeout_queues</span>;</span></span><br><span class="line"><span class="keyword">int</span> n_common_timeouts;</span><br><span class="line"><span class="keyword">int</span> n_common_timeouts_allocated;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件描述符和IO事件之间的映射关系表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_io_map</span> <span class="title">io</span>;</span></span><br><span class="line"><span class="comment">// 信号值和信号事件之间的映射关系表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_signal_map</span> <span class="title">sigmap</span>;</span></span><br><span class="line"><span class="comment">// 时间堆</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">min_heap</span> <span class="title">timeheap</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理系统时间的成员</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv_cache</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evutil_monotonic_timer</span> <span class="title">monotonic_timer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv_clock_diff</span>;</span></span><br><span class="line"><span class="keyword">time_t</span> last_updated_clock_diff;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EVENT__DISABLE_THREAD_SUPPORT</span></span><br><span class="line"><span class="comment">// 多线程支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前运行该event_base的事件循环的线程</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> th_owner_id;</span><br><span class="line"><span class="comment">// 独占锁</span></span><br><span class="line"><span class="keyword">void</span> *th_base_lock;</span><br><span class="line"><span class="comment">// 当前事件循环正在执行哪个事件处理器的回调函数</span></span><br><span class="line"><span class="keyword">void</span> *current_event_cond;</span><br><span class="line"><span class="comment">// 等待的线程数</span></span><br><span class="line"><span class="keyword">int</span> current_event_waiters;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// 正在处理的事件处理器的回调函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_callback</span> *<span class="title">current_event</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>事件循环, libevent的动力, 即事件循环</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习来源&lt;br&gt;&amp;lt;Linux 高性能服务器编程&amp;gt;&lt;/p&gt;
&lt;h1 id=&quot;I-O框架库概述&quot;&gt;&lt;a href=&quot;#I-O框架库概述&quot; class=&quot;headerlink&quot; title=&quot;I/O框架库概述&quot;&gt;&lt;/a&gt;I/O框架库概述&lt;/h1&gt;&lt;h2 id=&quot;Rea
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="源码学习" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>联机打砖块</title>
    <link href="http://blog.lsmg.xyz/2020/02/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E8%81%94%E6%9C%BA%E6%89%93%E7%A0%96%E5%9D%97/"/>
    <id>http://blog.lsmg.xyz/2020/02/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E8%81%94%E6%9C%BA%E6%89%93%E7%A0%96%E5%9D%97/</id>
    <published>2020-02-17T14:49:56.000Z</published>
    <updated>2020-02-19T14:35:22.496Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客写的有点晚了, 自己的打砖块 已经写了一个段落了. 不过问题不大.</p><p>重要的部分还在后面, 目前还没写到</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为自己发现需要多做一些项目, 然后逐渐的丰富这些项目 来学习. 希望不断地提升自己, 让自己离鹅厂越来越近. 同时写博客能够让我了解得更深刻</p><p>在看到知乎<code>日撸代码100行</code>的一篇推荐博客</p><p><a href="https://zhuanlan.zhihu.com/p/92422059" target="_blank" rel="noopener">UE4的C++教程汇总 - 日撸代码100行的文章 - 知乎</a><br>找到了那个油管的游戏制作.</p><p><a href="https://www.youtube.com/playlist?list=PLZhNP5qJ2IA0KK3ddSl2JWEL8jOcGe6xY" target="_blank" rel="noopener">这个连接-Unreal Engine 4 Tutorials</a><br>选择了一个游戏-打砖块</p><p>那个小游戏还是很简单的 也学到了不少的东西. 不过我想了想 我既然是做游戏服务器, 我为什么不把打砖块修改成联机版打砖块??   不对!!!!我想把那个博主发布的我喜欢的游戏都改成联机版. 然后慢慢丰富游戏前端和后端的功能, 想到这里 我晚上失眠了…. 越想越兴奋.</p><p>自己的话 注意下代码复用. 尤其是后端的代码. 每次把经常用的代码块抽出来 然后总结出一个自己的框架?库?</p><h1 id="联机的实现"><a href="#联机的实现" class="headerlink" title="联机的实现"></a>联机的实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.h</span></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendMessage</span><span class="params">(FString Msg)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function">FString <span class="title">RecvMessage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">FString <span class="title">StringFromUint8Array</span><span class="params">(TArray&lt;uint8&gt; Array)</span></span>;</span><br><span class="line"></span><br><span class="line">FIPv4Address Ip;</span><br><span class="line"></span><br><span class="line">FSocket* ClientFd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ANetActor::CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将字符串ip转换为点分十进制ip</span></span><br><span class="line">FIPv4Address::Parse(IPStr, Ip);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十进制ip 转化成网络地址</span></span><br><span class="line">TSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();</span><br><span class="line">addr-&gt;SetIp(Ip.Value);</span><br><span class="line">addr-&gt;SetPort(Port);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建TCP Socket 文件描述符</span></span><br><span class="line">ClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class="string">"TCP SOCKET"</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ClientFd-&gt;Connect(*addr))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 连接成功</span></span><br><span class="line">UE_LOG(LogTemp, Warning, TEXT(<span class="string">"Connect success!"</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 连接失败</span></span><br><span class="line">UE_LOG(LogTemp, Warning, TEXT(<span class="string">"Connect failed!"</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ANetActor::SendMessage</span><span class="params">(FString Msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//后面直接传送json数据</span></span><br><span class="line">TCHAR* SeriallizedMsg = Msg.GetCharArray().GetData();</span><br><span class="line">int32 MsgSize = FCString::Strlen(SeriallizedMsg);</span><br><span class="line">int32 Send = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ClientFd-&gt;Send((uint8*)TCHAR_TO_UTF8(SeriallizedMsg), MsgSize, Send))</span><br><span class="line">&#123;</span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"MsgSend-Success-&gt;%s"</span>), *Msg);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"MsgSend-Failed-&gt;%s"</span>), *Msg);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FString <span class="title">ANetActor::RecvMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!ClientFd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TArray&lt;uint8&gt; RecvData;</span><br><span class="line">uint32 Size;</span><br><span class="line">uint32 Element = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ClientFd-&gt;HasPendingData(Size))</span><br><span class="line">&#123;</span><br><span class="line">RecvData.Init(Element, FMath::Min(Size, <span class="number">65507u</span>)); <span class="comment">// 65535 - 20 Ip头 - 8 Tcp头</span></span><br><span class="line">int32 Read = <span class="number">0</span>;</span><br><span class="line">ClientFd-&gt;Recv(RecvData.GetData(), RecvData.Num(), Read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RecvData.Num() &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FString RecvJsonString = StringFromUint8Array(RecvData);</span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"MsgRecv-Success-&gt;%s"</span>), *RecvJsonString);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> RecvJsonString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蓝图连接<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F/%E6%89%93%E7%A0%96%E5%9D%97/socket%E8%93%9D%E5%9B%BE.png" alt=""></p><p>这样就能连接到TCP的后台了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客写的有点晚了, 自己的打砖块 已经写了一个段落了. 不过问题不大.&lt;/p&gt;
&lt;p&gt;重要的部分还在后面, 目前还没写到&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="小游戏" scheme="http://blog.lsmg.xyz/categories/%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="小游戏" scheme="http://blog.lsmg.xyz/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>3DMAX快捷键及基础知识</title>
    <link href="http://blog.lsmg.xyz/2020/02/3DMAX-3dmax%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://blog.lsmg.xyz/2020/02/3DMAX-3dmax%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-02-16T08:37:08.000Z</published>
    <updated>2020-02-17T14:48:59.145Z</updated>
    
    <content type="html"><![CDATA[<p>由于自己日后可能需要使用3d建模, 所以今天学习了下. 为了速成 看的B站的一个视频. 感觉效果还行吧.<br>基础的建模可以完成了, 后续需要的话 再继续学习</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>shift</td><td>绘制直线</td></tr><tr><td>删除键</td><td>可以回退一次</td></tr><tr><td></td><td></td></tr><tr><td>W</td><td>移动</td></tr><tr><td>E</td><td>旋转</td></tr><tr><td>R</td><td>缩放</td></tr><tr><td></td><td></td></tr><tr><td>F3</td><td>线框显示模式</td></tr><tr><td>F4</td><td>实体+线框限时模式</td></tr><tr><td></td><td></td></tr><tr><td>Shift</td><td>按住可以复制</td></tr><tr><td></td><td></td></tr><tr><td>Alt+T+A</td><td>阵列</td></tr><tr><td>Alt+T+M</td><td>镜像</td></tr><tr><td>Alt+A+对齐</td><td></td></tr><tr><td>Shitf+I</td><td>间隔工具</td></tr><tr><td></td><td></td></tr><tr><td>Ctrl+X</td><td>专家模式, 隐藏所有多余的东西 获得最大的空间</td></tr><tr><td>Alt+X</td><td>半透明显示</td></tr><tr><td>Ctrl+Shift+X</td><td>变换虚拟体显示切换 可以看到变换虚拟体的明显变化</td></tr><tr><td>O</td><td>自适应降级</td></tr></tbody></table><p><strong>编辑样条线-&gt;顶点</strong><br>优化 在线上添加点<br>焊接 连接两点<br>自动焊接 两点在距离之内自动焊接</p><p><strong>车削修改器</strong><br>将二维图形 指定一个轴然后旋转 得到立体图形</p><p><strong>可编辑多边形</strong><br><em>细分曲面</em><br>迭代次数2-3<br>无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)<br><em>细分置换-经常使用置换网格WSM修改器</em><br>需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图<br><em>绘制变形-未学-用于雕刻地形</em><br><strong>倒角剖面和扫描的区别</strong></p><ol><li>结合点不同</li><li>倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓</li><li>倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于自己日后可能需要使用3d建模, 所以今天学习了下. 为了速成 看的B站的一个视频. 感觉效果还行吧.&lt;br&gt;基础的建模可以完成了, 后续需要的话 再继续学习&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;
      
    
    </summary>
    
    
      <category term="3DMAX" scheme="http://blog.lsmg.xyz/categories/3DMAX/"/>
    
    
      <category term="3DMAX" scheme="http://blog.lsmg.xyz/tags/3DMAX/"/>
    
  </entry>
  
  <entry>
    <title>Git的使用</title>
    <link href="http://blog.lsmg.xyz/2020/02/Git-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://blog.lsmg.xyz/2020/02/Git-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</id>
    <published>2020-02-07T10:24:42.000Z</published>
    <updated>2020-02-22T09:44:40.216Z</updated>
    
    <content type="html"><![CDATA[<p>之前的Git博客 写的终于是自己都看不下去了. 所以打算来重新写一个博客<br>这篇博客主要还是参照的廖雪峰的Git博客<br>自己只做整理方便自己察看</p><p>2020年2月7日18:49:25 再来重新编辑下这些内容<br>2020年2月22日17:29:17 再次更新内容 增加commit规范</p><h1 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># -t Specifies the type of key to create.  The possible values are</span><br><span class="line">#“dsa”, “ecdsa”, “ed25519”, or “rsa”.</span><br><span class="line"># -C 生成注释 ...所以后面的邮箱就是个注释????</span><br><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &lt;message&gt;</span><br><span class="line">git remote add origin  # origin 意为远程库的名字, git的默认叫法</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">git diff</span><br><span class="line">git log</span><br><span class="line">git log --pretty&#x3D;oneline # 简单显示</span><br><span class="line"></span><br><span class="line"># 注意reset是恢复到上一个版本 即为你上一次commit版本或者pull最近的一次</span><br><span class="line">git checkout --&lt;filename&gt; # 恢复工作区, 可用于恢复修改和恢复勿删文件</span><br><span class="line">git reset HEAD &lt;file&gt; # 恢复暂存区</span><br><span class="line">git reset HEAD^ # 恢复版本库</span><br><span class="line">git reset --hard &lt;hash版本号 即为log中的一串英文字母, 只需要前几个字母即可&gt;</span><br><span class="line">git reflog # 所有版本日志</span><br><span class="line"></span><br><span class="line">git rm 从版本库中删除文件</span><br><span class="line"></span><br><span class="line">git push -u origin master # 带上 -u 以后提交就不需要加入origin master, 类似记忆功能</span><br><span class="line"></span><br><span class="line">&#96;git checkout -b dev&#96; #相当于一下两条命令</span><br><span class="line">&#96;git branch dev&#96; # 分支创建</span><br><span class="line">&#96;git checkout dev&#96; # 分支切换</span><br><span class="line">&#96;git branch -d dev&#96; # 分支删除</span><br><span class="line">&#96;git branch&#96; # 查看当前所有分支</span><br><span class="line">&#96;git merge dev&#96; # 将制定的dev分支合并到当前的分支</span><br></pre></td></tr></table></figure><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>首先把Git的三个区说明一下吧 自己后来慢慢感觉这些理论还是很重要的<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/Git%E4%B8%89%E5%A4%A7%E5%88%86%E5%8C%BA.png" alt=""><br>工作区<br>顾名思义, 你当前在IDE直接修改的代码全部都是位于工作区的代码<br>暂存区<br>暂时存取的区域, 你每次使用add提交的文件全部在这个区域中, 这些文件等待你的commit<br>版本库<br>这里存放的是若干个版本, 你每次的commit就是将暂存区的文件作为一个版本提交到版本库, 同时相应的文件被提交后 暂存区的文件被清除</p><h1 id="基础的操作"><a href="#基础的操作" class="headerlink" title="基础的操作"></a>基础的操作</h1><p><strong>你的第一次提交</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &lt;message&gt;</span><br></pre></td></tr></table></figure><p><code>git init</code><br>在你命令所执行的文件夹生成版本库<br><code>git add &lt;file&gt;</code><br>将指定文件从工作区添加到暂存区<br>如果<code>&lt;file&gt;</code>用 <code>.</code> 代替则为所有相对上一次commit修改过的文件<br><code>git commit -m &lt;message&gt;</code><br>提交暂存区的文件到版本库中成为一个版本 message为这个版本(提交)的描述</p><p><strong>好了你已经成功完成了一次提交, 继续去写代码了</strong><br>好你又写完了一堆代码 这时你想知道你工作区的状态是啥-你修改了哪些文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$git status</span><br><span class="line">-------提示如下-----------</span><br><span class="line">位于分支 master</span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line"></span><br><span class="line">修改：     test.txt</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和&#x2F;或 &quot;git commit -a&quot;）</span><br></pre></td></tr></table></figure><p><code>git status</code>告诉你 你修改了test.txt文件, 但是你想知道你怎么修改了这些文件, 做了什么改动<br>这时候就需要<code>git diff</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$git diff</span><br><span class="line">-------提示如下-----------</span><br><span class="line">diff --git a&#x2F;test.txt b&#x2F;test.txt</span><br><span class="line">index 0858ae8..8c14912 100644</span><br><span class="line">--- a&#x2F;test.txt</span><br><span class="line">+++ b&#x2F;test.txt</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> 111111111111111</span><br><span class="line"> 222222222222222</span><br><span class="line"> 333333333333333</span><br><span class="line">+444444444444444</span><br></pre></td></tr></table></figure><p><strong>现在你知道你进行了什么修改, 又进行了一次提交</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line">修改：     test.txt</span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和&#x2F;或 &quot;git commit -a&quot;）</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git add test.txt </span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 &quot;git reset HEAD &lt;文件&gt;...&quot; 以取消暂存）</span><br><span class="line">修改：     test.txt</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git commit -m &quot;ver 0.02&quot;</span><br><span class="line">[master ee4400f] ver 0.02</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br></pre></td></tr></table></figure><h1 id="时光穿梭机"><a href="#时光穿梭机" class="headerlink" title="时光穿梭机"></a>时光穿梭机</h1><p><strong>在commit之间切换</strong><br>Git还可以在不同commit间切换, 当然你必须知道进行过哪些commit, 你不能自己都记在脑子里吧, 所以也存在相关的命令<code>git log</code>来查看你的commit记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lsmg@ubuntu:~&#x2F;temp$ git log</span><br><span class="line">commit ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master)</span><br><span class="line">Author: ***********</span><br><span class="line">Date:   Sat Dec 7 21:06:42 2019 -0800</span><br><span class="line">    ver 0.02</span><br><span class="line"></span><br><span class="line">commit 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class="line">Author: ***********</span><br><span class="line">Date:   Sat Dec 7 20:57:58 2019 -0800</span><br><span class="line">    ver 0.01</span><br><span class="line"></span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git log --pretty&#x3D;oneline # 简洁显示</span><br><span class="line">ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master) ver 0.02</span><br><span class="line">603260e28ac0cc8fb8e4243120eb00bca83585d2 ver 0.01</span><br></pre></td></tr></table></figure><p>上面的<code>HEAD</code>代表当前版本, 上一个版本为<code>HEAD^</code>, 上上一个版本为<code>HEAD^^</code>如此类推<br>回到前N个版本<code>HEAD~N</code><br><code>git reset --hard HEAD^</code> 回到上一个版本.<br>这时你当前版本将会丢失, 使用<code>git log</code>也不会查看到原来的版本信息<br>这时使用<code>git reflog</code>来查看你的所有版本日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lsmg@ubuntu:~&#x2F;temp$ git reset --hard 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class="line">HEAD 现在位于 603260e ver 0.01</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git log</span><br><span class="line">commit 603260e28ac0cc8fb8e4243120eb00bca83585d2 (HEAD -&gt; master)</span><br><span class="line">Author: rjd67441 &lt;rjd67441@hotmail.com&gt;</span><br><span class="line">Date:   Sat Dec 7 20:57:58 2019 -0800</span><br><span class="line"></span><br><span class="line">    ver 0.01</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git reflog </span><br><span class="line">603260e (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class="line">ee4400f HEAD@&#123;1&#125;: commit: ver 0.02</span><br><span class="line">603260e (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): ver 0.01</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git reset --hard ee4400f</span><br><span class="line">HEAD 现在位于 ee4400f ver 0.02</span><br></pre></td></tr></table></figure><p><strong>撤销修改</strong><br>工作区中的撤销<br><code>git checkout -- &lt;filename&gt;</code><br>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。<br>暂存区中的撤销<br><code>git reset HEAD &lt;file&gt;</code><br>版本库的撤销<br><code>git reset HEAD^</code> 乖乖回退一次</p><p><strong>删除文件</strong><br>删除本地文件后<br>确实需要从版本库中删除<br><code>git rm</code>删除然后<code>git commit</code>提交即可<br>误删除需要使用<code>git chechout -- &lt;filename&gt;</code>来恢复</p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p><code>git checkout -b dev</code>相当于一下两条命令<br><code>git branch dev</code> 分支创建<br><code>git checkout dev</code> 分支切换</p><p><code>git branch -d dev</code> 分支删除</p><p><code>git branch</code> 查看当前所有分支</p><p><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p><p><strong>冲突解决</strong><br><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 111111111111111</span><br><span class="line">2 222222222222222</span><br><span class="line">3 333333333333333</span><br><span class="line">4 444444444444444</span><br><span class="line">5 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  # 我在master分支下添加了6666666 并提交</span><br><span class="line">6 6666666</span><br><span class="line">7 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">8 7777777</span><br><span class="line">9 &gt;&gt;&gt;&gt;&gt;&gt;&gt; deb # 我在deb分支下添加了7777777 并提交</span><br></pre></td></tr></table></figure><p>  最后需要我手动修改这个文件为自己需要的内容 然后提交即可</p><p>  <strong>分支管理</strong><br>  通常Git会使用<code>Fast forward</code>模式 这样删除分支后会丢失分支的信息<br>  可以再merge的时候加入<code>--no-ff</code>这样就能解决问题<br>  <code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>  由于禁用<code>Fast forward</code>后<br>  会生成新的commit所以需要加入<code>-m &quot;merge with no-ff&quot;</code></p><p>  <code>git stash</code> 可以储存当前的工作区 继续其他的工作<br>  <code>git stash list</code> 查看储存的工作区列表<br>  <code>git stash apply stash@{0}</code> 恢复指定的储存<br>  <code>git stash pop</code> 恢复并drop最近的存储</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt # stash前</span><br><span class="line">111111</span><br><span class="line">$ vim test.txt </span><br><span class="line">$ cat test.txt # 进行了修改</span><br><span class="line">111111</span><br><span class="line">222222</span><br><span class="line">333333</span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">修改：     test.txt</span><br><span class="line">$ git stash # stash</span><br><span class="line">保存工作目录和索引状态 WIP on master: 854b710 1</span><br><span class="line">$ cat test.txt </span><br><span class="line">111111</span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br><span class="line">$ git stash pop</span><br><span class="line">位于分支 master</span><br><span class="line">修改：     test.txt</span><br><span class="line">$ cat test.txt </span><br><span class="line">111111</span><br><span class="line">222222</span><br><span class="line">333333</span><br></pre></td></tr></table></figure><h1 id="实际工作中分支的应用"><a href="#实际工作中分支的应用" class="headerlink" title="实际工作中分支的应用"></a>实际工作中分支的应用</h1><p><a href="https://zhuanlan.zhihu.com/p/38772378" target="_blank" rel="noopener">主要参考</a><br><strong>主分支</strong></p><ul><li><strong>master</strong>: 这个分支最稳定, 相当于放的可发布版本</li><li><strong>develop</strong>: 开发分支, 平行于master分支, 负责合并各种<code>用于开发子功能</code>的分支</li></ul><p><strong>支持分支</strong>:解决某个问题, 结束后合并回<code>master</code>或<code>develop</code>分支</p><ul><li><strong>feature</strong>功能分支, 用于开发一个个子功能, 来自<code>develop</code>合并到<code>develop</code>去</li><li><strong>release</strong>:发布分支, 用于修改版本号等小修改, 来自<code>develop</code>分支合并到<code>master</code>分支</li><li><strong>hotfixes</strong>:紧急修复bug分支, 从<code>master</code>创建, 合并回<code>develop</code>分支和<code>master</code>分支<br><img src="https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg" alt=""></li></ul><h1 id="commit-规范"><a href="#commit-规范" class="headerlink" title="commit 规范"></a>commit 规范</h1><p><a href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">阮一峰 Commit message 和 Change log 编写指南</a></p><p>Angular 规范.<br>每个commit message 包括三分部<br>Header Body 和 Footer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; &#x2F;&#x2F; 必须</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;body&gt; &#x2F;&#x2F; 非必须</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;footer&gt; &#x2F;&#x2F;非必须</span><br></pre></td></tr></table></figure><p><strong>Header</strong></p><ol><li>type 必需 - 说明commit的类别, 只允许下面七个标识</li></ol><ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><ol start="2"><li><p>scope 非必需 - 用于说明 commit影响的范围<br>比如登录、注册、充值逻辑等等，视项目不同而不同。</p></li><li><p>subject 必需 - commit 目的的简短描述 </p></li></ol><ul><li>不超过50字符 </li><li>第一人称现在时动词开头</li><li>首字母小写</li><li>句尾不加句号</li></ul><p><strong>Body</strong><br>本次commit的详细描述, 可以分成多行</p><p><strong>Footer</strong><br>只用于两种情况 目前用不动 不摘了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前的Git博客 写的终于是自己都看不下去了. 所以打算来重新写一个博客&lt;br&gt;这篇博客主要还是参照的廖雪峰的Git博客&lt;br&gt;自己只做整理方便自己察看&lt;/p&gt;
&lt;p&gt;2020年2月7日18:49:25 再来重新编辑下这些内容&lt;br&gt;2020年2月22日17:29:17 再
      
    
    </summary>
    
    
      <category term="必备技能" scheme="http://blog.lsmg.xyz/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
      <category term="Git操作" scheme="http://blog.lsmg.xyz/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/Git%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="Git操作" scheme="http://blog.lsmg.xyz/tags/Git%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>头文件互相引用</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%87%E5%9D%91-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BA%92%E7%9B%B8%E5%BC%95%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%87%E5%9D%91-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BA%92%E7%9B%B8%E5%BC%95%E7%94%A8/</id>
    <published>2020-02-07T08:37:08.000Z</published>
    <updated>2020-02-07T10:09:48.656Z</updated>
    
    <content type="html"><![CDATA[<p>写在前头 本文中的<strong>编译</strong>二字基本都带加粗, 因为目前为止我还没做学到过<strong>编译</strong>器相关的东西,<br>姑且将<code>那个执行过程</code>称为<strong>编译</strong>, 所以加粗</p><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>二月六号的时候 我在写那个小游戏, 写头文件<code>a.h</code>发现即使引用了一个头文件<code>b.h</code>, 也没有办法使用定义在那个头文件之中的结构体.</p><p>其实有点我没在意: 当我在<code>a.h</code>文件中引用<code>b.h</code>的时候<code>b.h</code>会变成<code>invaild</code>, 这里其实就已经提示了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"b.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_A_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A *a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_B_H</span></span></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span> <span class="comment">// a.h中有b.h就只include a.h</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    B b&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error: ‘A’ does <span class="keyword">not</span> name a type</span><br><span class="line">error: ‘B’ does <span class="keyword">not</span> name a type</span><br></pre></td></tr></table></figure><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><h2 id="先说一下-ifndef-endif"><a href="#先说一下-ifndef-endif" class="headerlink" title="先说一下 #ifndef #endif"></a>先说一下 #ifndef #endif</h2><p><code>ifndef</code>全称<code>if not defined</code><br>意思是如果<code>#ifndef</code>后面的宏没有被定义 就继续<strong>编译</strong>其中的内容<br>继续<strong>编译</strong><code>#ifndef</code>的下一句就是<code>#define</code>这个宏, 这样这个宏就被定义了<br>第二次<strong>编译</strong>遇到这个头文件的时候, <code>#ifndef</code>后面的宏已经被定义了就跳过了if中的内容</p><h2 id="include的作用"><a href="#include的作用" class="headerlink" title="#include的作用"></a>#include的作用</h2><p>将 #include右边的文件展开到此文件中</p><h2 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h2><p>这样当你在main函数中 <code>#include &quot;a.h&quot;</code>的时候<code>a.h</code>之中的内容就被展开<br>变成如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"b.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_A_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    B b&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个include同样操作得到如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A *a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_B_H</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_A_H</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    B b&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我猜测<strong>编译</strong>的时候是逐行执行的, 至少在头文件的这部分是逐行执行<br>这样执行完了<code>行号为2 3 4 5</code>的四个宏 准备执行<code>行号为6</code>的这一行<code>#include &quot;a.h&quot;</code>继续展开<br>得到如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"b.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_A_H</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A *a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_B_H</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_A_H</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    B b&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有些乱 但仔细理解还是能到这里. 这下继续逐行执行 准备是<code>行号为6</code>的这一行(也可能是行号7的部分, 区别就是在include的下一行展开还是本行展开)<code>#ifndef UNTITLED1_A_H</code><br>这个宏就判断<code>UNTITLED1_A_H</code>是不是被定义了, 恩被定义了(第三行代码)跳到对应的<code>#endif</code>, 这样就防止了头文件<br>无穷无尽的调用 我将跳过的部分注释掉方便继续分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="comment">//#ifndef UNTITLED1_A_H</span></span><br><span class="line"><span class="comment">//#define UNTITLED1_A_H</span></span><br><span class="line"><span class="comment">//#include "b.h"</span></span><br><span class="line"><span class="comment">//class A</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//   B *b;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="comment">//#endif //UNTITLED1_A_H</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A *a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_B_H</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_A_H</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    B b&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一行就是<code>第十四行</code>的<code>class B</code>的<strong>编译</strong>, 那么问题来了<code>第16行</code>的<code>A</code>是啥东西??.</p><p>这里报错报了两行 我大胆推测一下 <code>class B</code>的<strong>编译</strong>的出错后, 依然在继续这个过程, 到了<code>class A</code>的时候<br>发现其中的<code>B</code>又是啥呢? 推测不同头文件编译互不影响 所以出现了两行报错</p><p>我们回到<code>class B</code>的头文件在<code>class B</code>的前面加上一行<code>class A;</code> 得到如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="comment">//#ifndef UNTITLED1_A_H</span></span><br><span class="line"><span class="comment">//#define UNTITLED1_A_H</span></span><br><span class="line"><span class="comment">//#include "b.h"</span></span><br><span class="line"><span class="comment">//class A</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//   B *b;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="comment">//#endif //UNTITLED1_A_H</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A *a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_B_H</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_A_H</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    B b&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里你会发现A的报错消失了, 因为这次在<strong>编译</strong><code>class B</code>的时候事先知道了<code>A</code>是一个类并且你必须把<br><code>class B</code>之中的这一句<code>A *a;</code>写成指针, 因为指针大小确定, 而且没有初始化, 所以<strong>编译</strong>就能通过, 如果你写成<br><code>A a;</code>依然会报错, 因为不知道A具体是个啥 最起码的内存都没法分配</p><p>好的下面继续, 你发现虽然A的报错消失了 但是<code>B</code>的报错还在, 我这里依然推测下, 不同头文件之间的<strong>编译</strong>互不影响,<br>所以依然不知道<code>B</code>是什么此时按照上面操作加入<code>class B;</code>前置声明, <strong>编译</strong>正确通过.</p><p>虽然两个头文件<strong>编译</strong>互不影响, 但是既然是main.cpp把他们引进来的 就同时对main.cpp起作用 自然就知道了A和B是啥</p><p>虽然这个问题网上答案很多, 但我对此还是很多不理解, 所以在做某些推测的情况下, 分析出来了这些原因. 如果有误,请直接评论中指出. 这也算是本人的第一篇写的认真的博客</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写在前头 本文中的&lt;strong&gt;编译&lt;/strong&gt;二字基本都带加粗, 因为目前为止我还没做学到过&lt;strong&gt;编译&lt;/strong&gt;器相关的东西,&lt;br&gt;姑且将&lt;code&gt;那个执行过程&lt;/code&gt;称为&lt;strong&gt;编译&lt;/strong&gt;, 所以加粗&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP踩坑" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E8%B8%A9%E5%9D%91/"/>
    
    
      <category term="CPP踩坑记" scheme="http://blog.lsmg.xyz/tags/CPP%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>CMAKE</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-CMAKE/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-CMAKE/</id>
    <published>2020-02-06T09:07:45.000Z</published>
    <updated>2020-02-19T14:35:15.526Z</updated>
    
    <content type="html"><![CDATA[<p>CMAKE并不打算专门去学, 所以就用到哪里学到哪里</p><p>今天clion写项目 遇到一个问题 明明写了aux_source_directory 却依然提示没有加入. 后来查了下, 并不推荐使用那个命令.<br>可能会存在一些问题<br><a href="https://cmake.org/cmake/help/latest/command/aux_source_directory.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/latest/command/aux_source_directory.html</a></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必须片段</span></span><br><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo1)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多文件</span></span><br><span class="line"><span class="comment"># 如果一味地在add_executable中添加源文件, 会导致太长了</span></span><br><span class="line"><span class="comment"># 将dir目录中所有源文件保存在变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SOURCE)</span><br><span class="line"><span class="comment"># 将变量赋值给Demo</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="variable">$&#123;DIR_SOURCE&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多文件多目录</span></span><br><span class="line"><span class="comment"># 需要在主目录和子文件夹中都编写CMakeLists.txt文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主文件添加子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(dir1)</span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Demo Foo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dir1目录中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR1_SOURCE)</span><br><span class="line"><span class="comment"># 生成链接库 Foo 在主文件中添加即可</span></span><br><span class="line"><span class="keyword">add_library</span>(Foo <span class="variable">$&#123;DIR1_SOURCE&#125;</span>)</span><br></pre></td></tr></table></figure><h1 id="CMAKE和MAKE之间的区别"><a href="#CMAKE和MAKE之间的区别" class="headerlink" title="CMAKE和MAKE之间的区别"></a>CMAKE和MAKE之间的区别</h1><p><a href="https://my.oschina.net/xunxun/blog/86781" target="_blank" rel="noopener">博客原文</a></p><p>自己的理解<br>通过为cmake编写CMakeList文件, cmake即可按照规则生成相应的Makefile文件<br>然后make读取Makefile文件就可以按照规则将源代码编译</p><p>总的来说cmake就是为make生成Makefile文件, (Makefile文件可以自己编写, 也可以用Cmake生成)<br>应该是编写CMakeList的代码量少于或者简单于Makefile, 简化了操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CMAKE并不打算专门去学, 所以就用到哪里学到哪里&lt;/p&gt;
&lt;p&gt;今天clion写项目 遇到一个问题 明明写了aux_source_directory 却依然提示没有加入. 后来查了下, 并不推荐使用那个命令.&lt;br&gt;可能会存在一些问题&lt;br&gt;&lt;a href=&quot;https
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>字节对齐</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</id>
    <published>2020-02-06T03:38:08.000Z</published>
    <updated>2020-02-07T08:38:13.076Z</updated>
    
    <content type="html"><![CDATA[<p>以前在牛客碰到不少字节对齐的题目, 当时只是为了记住而记住 今天我在学习自定义TCP二进制数据包<br>的时候 遇到了必须考虑下字节对齐的情景.</p><p><strong>解释</strong><br>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。–百度百科</p><p><strong>原因</strong><br>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况<br>但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。–百度百科</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> foo1;</span><br><span class="line">    <span class="keyword">int</span> foo2;</span><br><span class="line">    short foo3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(Foo) = <span class="number">12</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">char</span>) + <span class="keyword">sizeof</span>(<span class="keyword">int</span>) + <span class="keyword">sizeof</span>(short) = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>说明内存中并不是连续存储的这三个变量;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo foo1&#123;<span class="string">'1'</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">write</span>(fd, &amp;foo1, <span class="keyword">sizeof</span>(foo1));</span><br></pre></td></tr></table></figure><p>// hexdump 查看<br>0000000 5631 0000 0002 0000 0003 0000<br>对应图示如下<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png" alt=""></p><p>第一字节 0x31 正好是 ‘1’ <em>蓝色区域</em><br>二三四字节 为填充 <em>红色区域</em><br>因为sizeof(int)=4所以foo2的偏移量是四的倍数 , 故需要填充三个字节 3+1 = 4</p><p>第五六七八字节 0x02对应2 <em>灰色区域</em><br>这里没有填充是因为sizeof(short)=2所以foo3的偏移量是2的倍数 由于偏移量是8 所以不需要填充</p><p>第九十字节 0x03 对应3<br>第十一十二字节填充<em>黑色区域</em><br>因为此结构中最大的sizeof()=4所以需要将字节数对齐到4的倍数 目前10字节 所以需要填充2字节到<br>12字节满足四的倍数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以前在牛客碰到不少字节对齐的题目, 当时只是为了记住而记住 今天我在学习自定义TCP二进制数据包&lt;br&gt;的时候 遇到了必须考虑下字节对齐的情景.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;br&gt;现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>大二寒假及下学期学习记录</title>
    <link href="http://blog.lsmg.xyz/2020/02/%E5%A4%A7%E4%BA%8C%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.lsmg.xyz/2020/02/%E5%A4%A7%E4%BA%8C%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/</id>
    <published>2020-02-01T09:30:32.000Z</published>
    <updated>2020-02-27T01:49:16.339Z</updated>
    
    <content type="html"><![CDATA[<p>现在是<code>2020年2月1日17:32:50</code> 寒假过半? 目前还不知道寒假什么时候开学. 为了自己能够前往心目中的公司, 学习是必不可少的.<br>学习的同时 应该要注意总结, 防止一天或者一周下来白忙活<br>我们寒假开始是一月九号 到我开始寒假学习的一月二十三号 这些天没有学习用来玩了, 好在后面拾了回来<br>从二十三号到现在二月一号, 每天学习的长度和质量总算是在慢慢上升<br>距离下一个寒假只剩下一年的时间了, 需要更加的努力, 为了大三暑假能够进入心中的公司 大三寒假的实习必不可少了. 加倍努力吧</p><p>这篇博客的标题起初是<code>大二寒假学习记录</code>后来改成了<code>大二寒假及下学期学习记录</code>寒假的学习必不可少, 下学期更要抓紧时间了.</p><h1 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h1><h2 id="一日2020年2月1日17-39-59"><a href="#一日2020年2月1日17-39-59" class="headerlink" title="一日2020年2月1日17:39:59"></a>一日2020年2月1日17:39:59</h2><p>前几天把博客从我自己的服务器迁移到了coding上, 方便以后我乱搞服务器, 现在服务器上没有重要的内容了<br>至于实际的学习方面, 我开始整理我的博客<a href="https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/">主要是这篇</a>这篇现在算告一段落了, 主要是把自己以前学过的用一用. 空洞的写下api<br>理解不是很深刻.<a href="https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/">这两天修改的这一篇</a>. 第二篇自己缺少的东西很多, 由于当时学习到了后面实在是学不下去了.<br>所以现在把后面的部分重新写了一下. 高级部分的线程和进程的部分 实在是太走马观花. 等我顺序学到了 再多写一些例子</p><p>今天的话, 练习了下poll系统调用, 写了一个poll的demo, 然后是整理了下信号的部分, 信号这里整理的依然很少 平时用到的不多, 需要多加使用<br>主要是定时器这里了 定时器把原来的内容删掉了 从新写目前只写完了socket定时</p><p>接下来打算还是多写一些项目 多思考一些 等我整理完了高级部分 就准备去看开源项目?每次看开源项目都感觉自己差的太多, 不知道从哪里看起<br>所以搭配着别人的笔记学习下看源码. 当然看源码之前还是要会大概的使用. 高级部分自然包括了libevent的使用部分</p><p>跑去写项目了</p><h2 id="二日2020年2月2日18-03-23"><a href="#二日2020年2月2日18-03-23" class="headerlink" title="二日2020年2月2日18:03:23"></a>二日2020年2月2日18:03:23</h2><p>罪过罪过, 昨天晚上十一点半 玩了一把军团TD 结果玩到了十二点半 ….. 最后一点半才睡觉<br>今天早上小十一点才起床.<br>我依稀记得我八点被闹钟叫起来emm 然后想着定八点半的闹钟 再睡一会, 结果闹钟没定我就睡着了.</p><p>起来后整理了整理吃了午饭, 就下午小一点了, 打开高级部分 学习<code>信号SIGALRM定时</code></p><p>代码量就400行 一直到我写今天的博客 才算完工</p><p><strong>先写一下遇到的一个问题吧</strong><br>首先表现出来的是<code>超时后 服务器没有断开连接</code><br>然后我去打断点, 发现不是定时器链表部分的问题. 是定时信号没有触发<code>epoll_wait</code>.<br>这里我看了下代码, 发现定时器没有启动加上了<code>alarm(5)</code>, 我本意是理解了书上的代码 再去自己写, 结果还是理解的不深刻, 竟然丢了启动定时器的函数.<br>然后我又运行了下<code>发现还是没有运行到</code><br>然后发现<code>epoll_wait 返回-1 设置EINTR</code>, 后来查阅了下说是被信号处理器中断, 思考可能是与IDE下断点有关??????<br>最后发现自己没有把信号的管道添加到<code>epollfd</code>中再一细看发现丢了关于信号管道的四行代码…</p><p>这个问题应该是很容易排查. 事后感觉应该这样思考<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/epoll%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.png" alt=""><br>以后尽量总结正确的思考模式, 虽然不知道有没有用 但要试一试.</p><p><strong>项目收获方面</strong><br>虽然这个项目只有400多行代码, 但我自己是绝对写不出来的. 只能尽量总结书上代码的好处</p><ol><li>首先肯定是使用alarm超时产生信号SIGALRM来触发回调函数 实现定时</li><li>信号回调函数, 没有直接去触发定时器tick函数, 而是通过一个管道传到了epollfd中, 然后从epollfd的函数中触发相关的if 再去调用tick函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">()</span> <span class="comment">//真正的生效部分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer_lst.tick();</span><br><span class="line">    alarm(TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> save_errno = errno;</span><br><span class="line">    <span class="keyword">int</span> msg = sig;</span><br><span class="line">    send(pipefd[<span class="number">1</span>], (<span class="keyword">char</span>*)&amp;msg, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// pipefd[0]注册进了epoll中 接受到来的信号</span></span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig)</span><span class="comment">// 信号添加</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line">    sa.sa_flags |= SA_RESTART;</span><br><span class="line">    sa.sa_handler = sig_handler;</span><br><span class="line">    sigfillset(&amp;sa.sa_mask);</span><br><span class="line">    exit_if(sigaction(sig, &amp;sa, <span class="literal">nullptr</span>) == <span class="number">-1</span>, <span class="string">"add sig error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> signals[<span class="number">1024</span>]; <span class="comment">// 信号接收, 可能存在多个信号 所以用返回的字节数来逐个取出信号</span></span><br><span class="line">ret = recv(sockfd, signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>); 取出后使用<span class="keyword">switch</span>来分离信号</span><br></pre></td></tr></table></figure></li><li>将大部分常量 #define<br>大概只能总结出这一些来了, 完整的代码我贴在github上吧</li></ol><h2 id="五日-2020年2月6日09-16-23"><a href="#五日-2020年2月6日09-16-23" class="headerlink" title="五日 2020年2月6日09:16:23"></a>五日 2020年2月6日09:16:23</h2><p>三和四号 基本都在玩FF14, 发现自己并不是玩游戏了, 感觉被FF14玩了, 就是那种感觉累了不想玩了, 但却离自己定的小目标远 然后坚持<br>emm 其实感觉这个时候应该下游戏.<br>想想自己这大学一年半玩过的游戏 血族我算是玩的时间最长的大概前前后后我玩了五年, 应该是上半年把 我弃坑了. 游戏后面太氪了, 不得不退游了.<br>后面崩三啥的也玩过, 发现自己并不适合肝的游戏. 最近一个月入坑了fgo, 开始的几个星期还是玩的累了, 自己太肝了, 最近这几天感觉休闲了不少,<br>心态也正常了, 所以暂且会玩一玩.</p><p>主要还是后面这些吧, 我发现自己逐渐有了一个念头: 累了就去玩会游戏, 就去看会直播, 刷刷B站. 后来我感觉这些浪费时间就去搜索了一下<br><strong>玩游戏算浪费时间吗</strong>, 刚才去找了下. 没找到我之前看过的那篇. 结论就是为什么自己不是累了就去小睡一下, 或者看看书,再或者刷刷新的科技圈<br>长长见识? 自己尝试了看书, 发现自己并不是太抗拒. 以后试试把.</p><p>最后自己作为一个想开发游戏的人, 总感觉不玩游戏是不合适的, 但要玩的适度, 毕竟自己还有一年的时间就要找寒假实习, 为了自己的大三暑假进入大厂打下基础.<br>平衡好才是上策.</p><p>接下文, 我发现自己有点?(自信点把点去掉)好高骛远了, 好高骛远会消磨一个人的兴趣和信心. 最终决定不做什么大游戏, 不研究什么框架, 先用自己所会的写一个小游戏,<br>一是为了试着重新拾起兴趣, 二是如果只学而不去写项目, 没有太大收获的</p><p>昨天一天都是策划和编写一个游戏, 游戏逻辑十分的简单. 猜数字 初期的流程图我大概画了下, 姑且算作第一版吧 下面放出来, 我后面可以逐渐丰富这个东西 加上日志登录<br>断线重连等等功能.感觉还是可以的~~ 尽管逻辑很简单.<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%B5%81%E7%A8%8B1.png" alt=""><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%911.png" alt=""></p><p>听说在写代码前规划好, 可以更好地组织代码, 昨天尝试了下感觉还不错. 我在写代码前把游戏的流程图画了一下, 然后标上了哪里会有什么数据交互,<br>之后我去写了数据包头格式<br><strong>头部</strong></p><table><thead><tr><th>偏移量</th><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>封包总大小</td></tr><tr><td>4</td><td>2</td><td>头部长度</td></tr><tr><td>6</td><td>2</td><td>操作码</td></tr></tbody></table><p><strong>操作码</strong></p><table><thead><tr><th>代码</th><th>含义</th><th>数据格式</th></tr></thead><tbody><tr><td>00</td><td>登录</td><td></td></tr><tr><td>01</td><td>桌位信息(服务器发送桌位列表)</td><td>[1000-0-4][1001-0-4]</td></tr><tr><td>02</td><td>桌位操作信息(客户端加入 退出桌位)</td><td>1000</td></tr><tr><td>03</td><td>服务器桌位操作信息反馈(加入退出成功1 加入退出失败0)</td><td>1</td></tr><tr><td>04</td><td>准备</td><td>无</td></tr><tr><td>05</td><td>取消准备</td><td>无</td></tr><tr><td>06</td><td>服务器广播桌位信息</td><td>4[11][10][00][00] (桌位总数, 有人1 准备1)</td></tr><tr><td>A1</td><td>服务器广播游戏开始</td><td>空</td></tr><tr><td>A2</td><td>服务器下发轮到的客户端</td><td>空</td></tr><tr><td>A3</td><td>客户端发送猜测的数字</td><td>50</td></tr><tr><td>A4</td><td>服务器发送猜测数字反馈 (数据合理1, 数据非法0)</td><td>1</td></tr><tr><td>A5</td><td>服务器广播游戏状态</td><td>50-0-75[A][B] (A玩家猜出50 当前范围 0到75 B玩家准备)</td></tr></tbody></table><p>然后草拟了一下 用到的类 用到的数据结构 分几个类 怎么联系起来, 最终我才去写代码, 感觉比一边写<br>一边想要好不少. 写的过程中也发现了一些问题</p><ol><li><code>EPOLLRDHUP</code>这个绑定在listenfd还是newfd?? 如果是newfd还能理解下原理, listenfd就有点理解不了.(试了下, 是newfd)</li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo *a;</span><br><span class="line">Foos b[<span class="number">3</span>];</span><br><span class="line">b[<span class="number">1</span>] = *a;</span><br><span class="line"><span class="comment">// 修改a不会影响b[1], 这个问题听到过, 自己真正试了试才发现如此</span></span><br></pre></td></tr></table></figure></li></ol><p>姑且昨天的就补上这些吧. 今天打算把游戏的服务器跑起来</p><h2 id="六日-2020年2月6日22-12-36"><a href="#六日-2020年2月6日22-12-36" class="headerlink" title="六日 2020年2月6日22:12:36"></a>六日 2020年2月6日22:12:36</h2><p>忙忙碌碌的一天就又要结束了. 今天一天把剩下的一部分逻辑代码写了一部分. 主要是写自定义协议的序列化和反序列化. 起初打算<br>用char* body 来存储, 按照上面定义的格式传输. 后来一想, 这样我就不就是在原地打转吗. 就去网上找了找相关的代码, 看看别人怎么写的</p><p>主要是看的这一篇博客<a href="https://blog.csdn.net/ACb0y/article/details/61421006" target="_blank" rel="noopener">手把手教你实现自定义的应用层协议</a><br>看了之后收获不少. 收获总结在下面吧</p><ol><li>两个头文件互相include<br> 这个是今天了解的最奇葩的一个问题, 如果两个头文件互相include 会出问题. 这个明天开一篇 采坑博客<br> 与此连带的还有class 前置声明, 再者可以到编译相关的问题</li><li>今天了解了一下CMAKE和MAKE的区别和联系, 总算知道了为啥好多安装的时候先cmake 再 make</li><li>还是关于CMAKE 稍微整理了点CMAKE的使用. 随用随整理, 目前不打算一次性整理太多</li><li>Git操作不熟练. 我本地写好了代码文件, commit 然后从服务器pull了一个仅包含readme的仓库, 然后reset<br> 自己写的代码文件全没了, 只剩下README.md 还好之前整理过reflog, 明天也需要在整理下</li><li>安装了jsoncpp, 亿图图示等一些软件. 写了下关于字节对齐的问题. 亿图图示目前感觉挺不错</li></ol><p>代码方面的收获 主要就是看的那篇博客学到的.</p><ol><li>首先就是学会了自定了协议 序列化和反序列化怎么写 代码更美. 虽然可能我看的博客可能不是最好的,<br> 但对我目前来说足够美了, 不过写一遍远远不够.</li><li>学到了巧妙地对 <code>uint8_t*</code>类型的指针(指向流数据缓冲区)转换成<code>uint16_t*</code>等指针类型, 进行解引用 得到原本的数据, 然后对<br>  <code>uint8_t*</code>类型的指针<code>+2</code>就可以跳过一个<code>uint16_t</code>, 虽然这些能够理解, 但实际应用这是第一次</li><li>对于如何更好的组织一个数据结构 有了更深的体会.</li><li>使用vector来存储剩余的包字节, 相比使用一个定长数组进行strcpy 方便了不少</li><li>使用erase擦除也是第一次实际应用</li><li>更好的使用指针</li></ol><p>定一下明天的任务吧, 试运行</p><ol><li>定义游戏的json格式, 把所有的json都定义出来 √</li><li>游戏完成度达到能够正确解析包并分发到合理的部分即可 √</li><li>写一遍采坑博客-头文件互相引用 √</li><li>针对今天Git遇到的文件 在做研究下√</li><li>简单学习下jsoncpp的使用√</li></ol><h2 id="七日-2020年2月7日10-14-53"><a href="#七日-2020年2月7日10-14-53" class="headerlink" title="七日 2020年2月7日10:14:53"></a>七日 2020年2月7日10:14:53</h2><p>2020年2月7日10:14:53<br>今天博客写的格外早, 主要是又遇到一个奇葩问题(其实是我自己使用有误)<br>我昨天最后发现代码跑不起来, 就没有管, 今天看了下跑不起来是因为<code>未定义引用</code><br>好吧, 未定义引用, 我检查了一下发现不对啊, 我加上了<br><code>target_link_libraries(Guess -ljsoncpp network game)</code><br>我当时是这样写的, 结果就是报错<code>未定义引用</code>, 然后我把报错的部分另开一个项目放进去<br>运行起来没问题?????.<br>然后我把报错的代码放在我项目的main文件中, 结果原来的报错也消失了 main中的也没报错?????<br>最后阴差阳错发现这个博客<a href="https://blog.csdn.net/qq_33249383/article/details/88908218" target="_blank" rel="noopener">初入职常见问题：gcc编译时对’xxxx’未定义的引用</a>. 我发现其中的一段话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个主要的原因是gcc编译的时候，各个文件依赖顺序的问题。</span><br><span class="line">在gcc编译的时候，如果文件a依赖于文件b，那么编译的时候必须把a放前面，b放后面。</span><br><span class="line">例如:在main.c中使用了pthread库相关函数，那么编译的时候必须是main.c在前，-lpthread在后。 gcc main.c -lpthread -o a.out 。</span><br></pre></td></tr></table></figure><p>虽然使用的是cmake然后make 不确定编译器, 但我感觉应该试一试. 因为我的软件是编译<code>network.a</code>的时候报错,<br>结果我改成了如下<br><code>target_link_libraries(Guess network game -ljsoncpp)</code><br>发现报错消失了……</p><p>以前一直没有在意这里的顺序问题. 现在知道了问题所在 去搜索target_link_libraries顺序问题<br>找到了一堆解释 哎….</p><p>2020年2月7日18:10:20<br>终于把头文件互相引用给搞明白了, 感觉这篇博客写的还可以吧, 就发到了<a href="https://blog.csdn.net/qq_26790181/article/details/104213520" target="_blank" rel="noopener">csdn上面</a>,自己的博客上也会发的. 就先这样吧<br>今天的第三项任务完成了, 概第四项任务了Git</p><p>2020年2月7日22:17:41<br>今天的任务完成了 还发现一个联系git的网站… 真的是纯偶然发现的<a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">这个</a><br>大创那里今天看了下文档 找了找模板 还可以吧 明天的话</p><ol><li>游戏把服务器端写完 一半</li><li>把找到的大创模板改到springboot上面去  后续再套</li><li>练习并搞懂两道中等算法题目</li><li>在有时间的话把牛客整理了</li></ol><h2 id="八日九日-2020年2月9日18-04-35"><a href="#八日九日-2020年2月9日18-04-35" class="headerlink" title="八日九日 2020年2月9日18:04:35"></a>八日九日 2020年2月9日18:04:35</h2><p>简单写下吧, 昨天 不小心挂彩了, 还好运气还好, 没有太大的伤, 不然特别时期真的难搞.<br>不幸中的万幸</p><p>今天一天都没写代码 或许明天会好一些把</p><h1 id="十日"><a href="#十日" class="headerlink" title="十日"></a>十日</h1><p>2020年2月10日10:02:22<br>今天问题不大了, 继续写游戏的服务器<br>写完服务器后, 做算法题吧</p><h1 id="十四日"><a href="#十四日" class="headerlink" title="十四日"></a>十四日</h1><p>昨天基本问题就不大了, 眼睛周围青了一圈成了大熊猫, 经过四天的休息 看东西倒是不流眼泪了.<br>今天的话, 实际的学习方面有</p><p>终于自己还是要找开源项目看看了, 不过今天2020年2月14日17:08:40头脑不是很清醒, 中午没有睡好. 看了个大概就没看了<br><a href="https://tengine.taobao.org/book/chapter_02.html" target="_blank" rel="noopener">nginx剖析</a></p><p>偶尔发现了一本书, 这不就是我想要看的吗!!!!!!, 准备看这本书 这本书从输入网址到网页返回都很详细的写了写<br><img src="https://pic2.zhimg.com/v2-1336c859990173751b77ad9eb4318602_r.jpg" alt=""></p><h1 id="十五日"><a href="#十五日" class="headerlink" title="十五日"></a>十五日</h1><p>理论上大二寒假就要过完了. 昨天晚上想了很多</p><p>先说一下游戏把: 感觉自己不喜欢玩手机游戏了, 手机游戏非肝即氪 自己没有时间去肝游戏, 肝游戏不会给你工作, 自己没有钱去氪金, 自己又非.抱着这种念头时间长了, 自己对游戏更加提不起兴趣了. 而我又想去做游戏, 一个不想玩游戏的人能做游戏吗? 虽说我的不想玩是在各种因素长时间影响下形成的.</p><p>再说下我对编程吧: 怎么说呢, 我在大二上学期的上半学期之前, 都很喜欢写代码的, 我能在电脑前面坐上一整天. 后来我对代码提不起兴趣了. 原因的话昨天晚上整理了下.</p><ol><li>目的不同了: 我在大二上学期的上半学期之前(包括大一整个学期)都是抱着解决某个问题去写软件的, 说起来是为自己写代码?首先就是我学的Javaweb为了解决校园网登录难的问题, 我用Java写一个客户端, 同时配上了后台和下载站(用的阿里云的OSS). 我记得的那段时间真的快乐. 后面我又为解决手动签到的问题, 做了个签到软件, 也是如此.——后来我学习的目的就是为了增进自己的知识(目的只有一个–进入大公司), 变成了为了学而学(之所以为了学而学是感觉时间真的有限, 我想在大三暑假能够实习, 我只有一年半的时间), 而不是之前, 通过做自己喜欢的东西不会了就去补一补. 长时间这样学习我大二上整个学期一个正经的项目都没有, 长时间为了学而学消磨了我的兴趣??</li><li>我发现我现在好像失去了对编程的乐趣, 现在写项目总想写出更优的结构, 总想写出大项目, 然而我的能力不足. 想实现和无法实现的思想一直持续着, 也是消磨的原因之一? 我现在在想我是不是期初就对linux服务器不感兴趣? 可我感觉当初自己确实想去的, 我想着游戏行业的人员兴趣基本相同, 能够一起做游戏,一边骂着策划脑洞一边做2333, 而不是做自己不喜欢的网站后端, 我发现目前自己都是一个人学习, 一个人做着, 何谈团队的乐趣?</li></ol><p>症状就如上了, 自己也得想想办法了.</p><ol><li>首要任务找个人(找个团队)一起做游戏吧, 自己一个人的话, 说不上我向往的一起写代码的氛围</li><li>找到团队之后, 就能通过一边做游戏一边学习自己的不足了</li><li>我长时间的学习, 做不出自己满意的项目也是原因之一吧.</li><li>手机游戏的话, 暂时不去玩网游了. 我自己更适合单机? 找人做独立游戏?? emm不错</li></ol><h1 id="十六日"><a href="#十六日" class="headerlink" title="十六日"></a>十六日</h1><p>爆肝学习了一天3dmax , 现在是会基本的操作 能够完成一些简单的建模了.</p><p>从B站找个那个课程也是很不错<br><a href="https://www.bilibili.com/video/av18210293/" target="_blank" rel="noopener">3Dmax2018零基础入门教程（第一，二，三，四，五阶段）</a></p><p>一天的事件我就从 P0看到了    P51 过得很快, 但感觉掌握的还能接受</p><hr><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>shift</td><td>绘制直线</td></tr><tr><td>删除键</td><td>可以回退一次</td></tr><tr><td></td><td></td></tr><tr><td>W</td><td>移动</td></tr><tr><td>E</td><td>旋转</td></tr><tr><td>R</td><td>缩放</td></tr><tr><td></td><td></td></tr><tr><td>F3</td><td>线框显示模式</td></tr><tr><td>F4</td><td>实体+线框限时模式</td></tr><tr><td></td><td></td></tr><tr><td>Shift</td><td>按住可以复制</td></tr><tr><td></td><td></td></tr><tr><td>Alt+T+A</td><td>阵列</td></tr><tr><td>Alt+T+M</td><td>镜像</td></tr><tr><td>Alt+A+对齐</td><td></td></tr><tr><td>Shitf+I</td><td>间隔工具</td></tr><tr><td></td><td></td></tr><tr><td>Ctrl+X</td><td>专家模式, 隐藏所有多余的东西 获得最大的空间</td></tr><tr><td>Alt+X</td><td>半透明显示</td></tr><tr><td>Ctrl+Shift+X</td><td>变换虚拟体显示切换 可以看到变换虚拟体的明显变化</td></tr><tr><td>O</td><td>自适应降级</td></tr></tbody></table><p><strong>编辑样条线-&gt;顶点</strong><br>优化 在线上添加点<br>焊接 连接两点<br>自动焊接 两点在距离之内自动焊接</p><p><strong>车削修改器</strong><br>将二维图形 指定一个轴然后旋转 得到立体图形</p><p><strong>可编辑多边形</strong><br><em>细分曲面</em><br>迭代次数2-3<br>无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)<br><em>细分置换-经常使用置换网格WSM修改器</em><br>需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图<br><em>绘制变形-未学-用于雕刻地形</em><br><strong>倒角剖面和扫描的区别</strong></p><ol><li>结合点不同</li><li>倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓</li><li>倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.</li></ol><hr><p>好了暑假也算是结束了</p><p>哦对了 我还在做一个游戏 从YouTube上看到一个打砖块游戏.<br>这只是开始, 因为我是做服务器的所以我要把游戏改成双人联机哒!!!!目前进展还不错</p><p>我打算模仿一个知乎大佬在知乎更新下专栏? 貌似可以诶</p><p>网上讲解服务器的不少 讲解客户端的不少  讲解一套的就少了</p><p>好了博客整理下 寒假结束了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是&lt;code&gt;2020年2月1日17:32:50&lt;/code&gt; 寒假过半? 目前还不知道寒假什么时候开学. 为了自己能够前往心目中的公司, 学习是必不可少的.&lt;br&gt;学习的同时 应该要注意总结, 防止一天或者一周下来白忙活&lt;br&gt;我们寒假开始是一月九号 到我开始寒假学习
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>编程规范</title>
    <link href="http://blog.lsmg.xyz/2020/01/CPP-CPP%E9%87%8D%E7%82%B9-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <id>http://blog.lsmg.xyz/2020/01/CPP-CPP%E9%87%8D%E7%82%B9-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</id>
    <published>2020-01-23T11:35:50.502Z</published>
    <updated>2020-01-23T11:34:45.214Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一点</strong><br>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><p><strong>第二点</strong><br>局部变量应当声明和初始化同时进行, 推荐使用C++11的花括号</p><p><em>如果在循环中, 不要将对象的声明放入其中</em>, 每次进入作用域都会调用构造函数, 每次退出都会调用析构函数</p><p><strong>第三点-类相关</strong><br>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p><p>不要定义隐式类型转换. </p><p>对于转换运算符和单参数构造函数, 请使用 explicit 关键字.</p><ul><li>单参数构造函数有可能会被无意地用作隐式类型转换.</li></ul><p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p><ul><li>MyClass(const MyClass&amp;) = delete;<br>MyClass&amp; operator=(const MyClass&amp;) = delete;</li></ul><p>仅当<code>只有</code>数据成员的时候<code>struct</code>, <code>其他一律</code>使用class</p><p>使用组合常常比使用继承更合理</p><ul><li>所有的继承<code>必须是public</code>, </li></ul><p>多重继承(真正需要的时候很少)</p><ul><li>最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.</li></ul><p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量</p><ul><li>重载运算符, 容易造成代码混乱, 因为没有统一的重载规范</li></ul><p>数据成员都必须是私有的</p><p><strong>第四点-函数相关</strong></p><p>输入参数在先, 后跟输出参数.</p><p>编写简短函数</p><p>所有按引用传递的参数必须加上 const.</p><p>函数重载</p><ul><li>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,<br>而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</li><li>如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.</li></ul><p>省却参数</p><p>函数返回类型后置语法</p><ul><li><code>auto foo(int x) -&gt; int</code> 对于简单的类型, 优点体现不出</li><li>对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别?????.</li></ul><p><strong>杂项</strong><br>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p><p><strong>第五点命名-版本最多的地方</strong></p><p>文件命名</p><ul><li>全部小写包含<code>_</code>最好</li><li>C++ 文件要以 .cc 结尾, 头文件以 .h 结尾.</li></ul><p>类型名称 - 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数</p><ul><li>类型名称的每个单词首字母均大写, 不包含下划线<code>MyExcitingClass</code></li></ul><p>变量命名</p><ul><li>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾</li></ul><p>常量命名</p><ul><li>字母k开头</li><li>声明为 constexpr 或 const</li></ul><p>函数命名</p><ul><li>每个单词首字母大写, 没有下划线</li><li>首字母缩写的单词, 经常对其的第一个字母大写</li></ul><p>命名空间命名</p><ul><li>小写字母命名</li></ul><p>枚举命名</p><ul><li>枚举的命名应当和 常量 或 宏 一致: kEnumName</li></ul><p><strong>第六点-格式</strong></p><p>缩进两个空格</p><p>函数定义与声明</p><ul><li>左圆括号总是和函数名在同一行.(没有标准,,,,,,,,,, emmm 我想我还是换行吧 不过对于else换行挺难受的)</li><li>函数名和左圆括号间永远没有空格.</li><li>圆括号与参数间没有空格.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;第一点&lt;/strong&gt;&lt;br&gt;有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. &lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>游戏知识-杂谈-如何进入游戏开发行业</title>
    <link href="http://blog.lsmg.xyz/2019/12/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E6%9D%82%E8%B0%88-%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E8%A1%8C%E4%B8%9A/"/>
    <id>http://blog.lsmg.xyz/2019/12/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E6%9D%82%E8%B0%88-%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E8%A1%8C%E4%B8%9A/</id>
    <published>2019-12-22T12:50:02.000Z</published>
    <updated>2020-01-03T12:40:21.235Z</updated>
    
    <content type="html"><![CDATA[<p>由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面<br><a href="https://gameinstitute.qq.com/course/detail/10156" target="_blank" rel="noopener">想做游戏吗？如何开始我的游戏开发职业生涯</a></p><a id="more"></a><p>做游戏不会重复做同样的工作, 项目不同</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面&lt;br&gt;&lt;a href=&quot;https://gameinstitute.qq.com/course/detail/10156&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;想做游戏吗？如何开始我的游戏开发职业生涯&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="游戏知识" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="杂谈" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>游戏知识-服务器-服务器通信</title>
    <link href="http://blog.lsmg.xyz/2019/12/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1/"/>
    <id>http://blog.lsmg.xyz/2019/12/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1/</id>
    <published>2019-12-22T12:50:02.000Z</published>
    <updated>2020-01-03T12:40:21.234Z</updated>
    
    <content type="html"><![CDATA[<p>由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面<br><a href="https://gameinstitute.qq.com/course/detail/10096" target="_blank" rel="noopener">服务器通信</a></p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>作业型-单纯多个client对一个server .. 比如我开始写过的聊天室程序</p><h1 id="CS通信"><a href="#CS通信" class="headerlink" title="CS通信"></a>CS通信</h1><p><img src="" alt="浏览器访问过程"><br>DNS协议-基于UDP协议</p><p>TCP<br>面向连接的可靠的有时序性的-流式协议<br>窗口管理<br>流量控制<br>数据确认<br>UDP<br>无连接不保证可靠性的无法保证时序-报文协议</p><p>QQ-CS<br>网络状况较好-UDP????-好吧还是处理了<br>网络状况差-TCP<br>大文件-TCP-TCP适合大文件交互, 因为他保持连接流式协议~</p><p>微信-CS<br>前台运行-TCP长连接<br>后台运行-TCP短连接<br>查看文章-HTTP(TCP短连接)</p><p>QQ-早期产品, 花最少的前~榨干性能<br>微信-腾讯后期产品</p><hr><p>字符串<br>自定义<br>Protobuf</p><p>序列化反序列化.</p><p>UDP协议-不要让单个包的数据量超过1K, 否则会由于分片等 导致一个大包一旦一个分片失败就都失败</p><p>存在的问题</p><ol><li>客户端和服务端数据一直对不上<br>可能是字节序的问题 - 字节序转换(网络字节数传送)</li><li>服务器发送的数据延迟-小包<br>NAGLE算法-小包并不是立即发送-等存多了在一起发送-可以禁用掉~~</li><li>数据较大或者网络波动<br>发送缓冲区慢了.. 适当加大发送缓冲区</li></ol><p>非阻塞IO<br>O_NONBLOCK<br>多路复用<br>select<br>poll<br>epoll</p><h1 id="SS通信"><a href="#SS通信" class="headerlink" title="SS通信"></a>SS通信</h1><p><img src="" alt="服务器间通信"><br>TCP-最常用<br>UDP-非关键数据-日志服务-内网通信网络状况好可以超过MTU<br>非SOCKET通信-进程间通信?-管道-信号-共享内存-信息队列-文件..</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面&lt;br&gt;&lt;a href=&quot;https://gameinstitute.qq.com/course/detail/10096&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;服务器通信&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="游戏知识" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="服务器" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>指针</title>
    <link href="http://blog.lsmg.xyz/2019/11/CPP-CPP%E5%9F%BA%E7%A1%80-%E6%8C%87%E9%92%88/"/>
    <id>http://blog.lsmg.xyz/2019/11/CPP-CPP%E5%9F%BA%E7%A1%80-%E6%8C%87%E9%92%88/</id>
    <published>2019-11-07T14:26:22.000Z</published>
    <updated>2020-01-23T11:35:12.218Z</updated>
    
    <content type="html"><![CDATA[<p>指针的话, 自己是要学会自己去理解各种组合. 首先只要定义复杂指针肯定会涉及到运算符优先级<br>根据运算符优先级判断这个定义的含义</p><h1 id="指针的定义识别"><a href="#指针的定义识别" class="headerlink" title="指针的定义识别"></a>指针的定义识别</h1><h2 id="由运算符优先级判断"><a href="#由运算符优先级判断" class="headerlink" title="由运算符优先级判断"></a>由运算符优先级判断</h2><p>下面列出常见到的运算符</p><p><code>[]</code>中括号这个的优先级最高, 跟括号并列.(排除域运算符).<br>    从左到右的结合性 -意味着<code>p[]</code>中<code>[]</code>会先跟<code>p结合</code>而不是中括号右边的内容<br><code>()</code>与之结合成为函数<br>    从左到右的结合性<br><code>*</code>其次是这个符号<br>    从右到左的结合性</p><p>两个大头<br><code>int *p[3]</code>和<code>int (*p)[3]</code><br>前者由于<code>[]</code>的优先级更高p与之结合说明p是<strong>数组*</strong>得到p本质是什么 数组OR指针*<br>再与<code>*</code>结合说明<strong>数组中的元素</strong>是<strong>指针*</strong>第二次结合 如果第一次是数组-则为数组中的内容, 第一次是指针-则为指针的指向*<br>再与int结合 说明数组中<strong>指针指向</strong>的是int</p><p>后者<code>*</code>先与p结合说明p是一个<strong>指针</strong><br>再与<code>[]</code>结合说明<strong>指针指向</strong>的内容是<strong>数组</strong><br>再与int结合说明<strong>数组中的内容</strong>是int</p><hr><p>本质上定义函数相关的也可以这样理解<br><code>int p(int)</code>和<code>int (*p)(int)</code><br>前者p先与<code>()</code>结合说明p是一个<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p><p>后者p先与<code>*</code>结合说明p是一个<strong>指针</strong><br>与<code>()</code>结合说明<strong>指针指向</strong>的是<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p><h2 id="判断指针的类型"><a href="#判断指针的类型" class="headerlink" title="判断指针的类型"></a>判断指针的类型</h2><p>去除指针声明语句中的指针名称, 剩下的部分就是指针的类型.<br><code>int* p</code>得到<code>int*</code>, 说明指针的类型是<code>int*</code><br><code>int (*p)[3]</code> 说明指针的类型是<code>int (*)[3]</code></p><h2 id="指针指向的类型"><a href="#指针指向的类型" class="headerlink" title="指针指向的类型"></a>指针指向的类型</h2><p>去除指针声明语句中的指针名称, 以及名称左边的指针声明符<em>, 剩下的部分是指针指向的类型<br>`int</em> p<code>得到</code>int<code>说明指针指向的类型就是</code>int<code></code>int (*p)[3]<code>得到</code>int()[3]<code>说明指针指向的类型就是</code>int()[3]`</p><h2 id="指针的值"><a href="#指针的值" class="headerlink" title="指针的值"></a>指针的值</h2><p>指针存储的即为指向一个内存区域的地址值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;指针的话, 自己是要学会自己去理解各种组合. 首先只要定义复杂指针肯定会涉及到运算符优先级&lt;br&gt;根据运算符优先级判断这个定义的含义&lt;/p&gt;
&lt;h1 id=&quot;指针的定义识别&quot;&gt;&lt;a href=&quot;#指针的定义识别&quot; class=&quot;headerlink&quot; title=&quot;指针的定
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP基础" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>C++薄书整理</title>
    <link href="http://blog.lsmg.xyz/2019/10/CPP-CPP%E5%9F%BA%E7%A1%80-2/"/>
    <id>http://blog.lsmg.xyz/2019/10/CPP-CPP%E5%9F%BA%E7%A1%80-2/</id>
    <published>2019-10-20T11:13:22.000Z</published>
    <updated>2020-01-31T08:07:47.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义新量"><a href="#定义新量" class="headerlink" title="定义新量"></a>定义新量</h1><p>auto 自动根据初始值的类型进行自动类型推导.<br>decltype 根据表达式的类型定义对象</p><p>右值引用, 操纵右值对象<br><code>std::move()</code>, 可以将一个</p><p><strong>枚举</strong><br>不限定作用域的定义<br>enum color {red, green, blue};<br>限定在类型内部的作用域<br>enum class color {red, green, blue};<br><code>color a = color::red</code></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>数组传参的长度处理</p><ul><li>直接传递数组长度</li><li>使用C风格字符串(默认结尾有标志)</li><li>使用C++11的新函数begin()和end()同时传递首尾地址</li></ul><p>函数指针<br><code>bool (*pf)(int, int)</code> 可以指向<br><code>bool max(int a,int b)</code><br>调用 <code>pf(1, 1)</code>即可<br>常用于函数的参数是一个函数的返回值</p><p><strong>Lambda</strong><br><code>[]() -&gt; return type {statements}</code><br>中括号代表lambda引导, 其中的captures子句在同一作用域下lambda主体捕获(访问)哪些对象<br>以及如何捕获这些对象</p><ul><li>可以为空, 不会访问外围对象</li><li>[=] 代表用值捕获的方式</li><li>[&amp;] 代表引用捕获</li></ul><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p><strong>辅助函数</strong><br>定义辅助函数, 有点像Java里面的重写toString()函数(最常见的代表的例子)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">os &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元函数</strong><br>一个类的辅助函数从概念上可以看成类的接口, 虽然和类的关系很密切, 但并不是类的成员, 所以不能直接访问私有成员<br>C++ 中可以将该类函数声明为该类的友元.<br>这样就能访问到类的非公有成员.<br>在函数的前面加上<code>friend</code>关键字<br><strong>友元类</strong><br>如果A想访问B的私有成员, 可以在B内声明<code>friend class A</code>, 这样就可以在B内访问A的私有成员<br><em>友元关系是单向的, 不具有交换性, 同时也不具有传递性</em></p><p><strong>构造函数</strong><br>默认构造函数没有参数, 或者所有的参数都具有默认值<br>C++11允许在显示定义构造函数的情况下使用默认构造函数<br>需要在默认构造函数后面加上<code>= default</code><br><em>使用默认构造函数创建类对象时, 切忌在对象名后I使用圆括号, 成了一个函数声明</em></p><p><strong>初始值列表</strong><br>T(int a, int b):a_(a), b_(b){}<br>引用和const修饰的必须用初始值列表初始化, 初始的顺序取决于数据成员在类内的定义顺序,<br>而非初始值列表的顺序</p><p><strong>简化构造函数</strong><br>实际将自己的带参构造函数, 给定默认值, 这样就实现了默认构造函数和带参构造函数的合并</p><p><strong>复制构造函数</strong><br>参数为该类的引用</p><p><strong>委托构造函数</strong><br>减少构造函数代码量<br>实际就是一个构造函数后面加上<code>:</code>调用另一个构造函数, 同时传入参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> bar1_;</span><br><span class="line"><span class="keyword">int</span> bar2_;</span><br><span class="line">A(<span class="keyword">int</span> b1):A(b1, <span class="number">2</span>)&#123;&#125;</span><br><span class="line">A(<span class="keyword">int</span> b1, <span class="keyword">int</span> b2):bar1_(b1), bar2_(b2)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运算符重载</strong><br>T operator /(A, B);<br>双目运算符两个参数<br>单目运算符一个参数<br>对于二元运算符, 左侧运算对象传递给第一个参数, 右侧运算对象传递给第二个参数.</p><p>运算符重载的声明和定义的分离<br>放在类成员中的运算符重载, 需要算入默认的this指针参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>+(<span class="keyword">const</span> Test&amp; right);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAB</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a_;</span><br><span class="line"><span class="keyword">int</span> b_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line">Test::Test(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    a_ = a;</span><br><span class="line">    b_ = b;</span><br><span class="line">&#125;</span><br><span class="line">Test&amp; Test::<span class="keyword">operator</span>+(<span class="keyword">const</span> Test&amp; right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Test <span class="title">test</span><span class="params">(<span class="keyword">this</span>-&gt;a_ + right.a_, <span class="keyword">this</span>-&gt;b_ + right.b_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test::PrintAB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a_, b_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">test1</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">test2</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    Test test = test1 + test2;</span><br><span class="line">    test.PrintAB();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ++ -- </span></span><br><span class="line">Test&amp; <span class="keyword">operator</span>++(); <span class="comment">// 前置版本</span></span><br><span class="line">Test <span class="keyword">operator</span>++(<span class="keyword">int</span>); <span class="comment">// 后置版本</span></span><br></pre></td></tr></table></figure><p><strong>类成员指针</strong><br><em>数据成员指针</em> (private不能通过指针访问)<br>其值是数据成员所在地址相对于对象起始地址的偏移值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A T::*p1 = &amp;T::x</span><br><span class="line"><span class="keyword">int</span> A::*p1 = &amp;A::value</span><br><span class="line">A a;</span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line">a.*p = ......................;</span><br></pre></td></tr></table></figure><p>p1指向T类中的 A类型的x数据成员<br><code>A T::</code>可以用<code>auto</code></p><p><em>成员函数指针</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (A::*pf)();</span><br><span class="line">pf = &amp;A::GetValue;</span><br><span class="line"><span class="comment">// 当然可以使用auto 来简化</span></span><br><span class="line"><span class="keyword">auto</span> pf2 = &amp;A::GetValue;</span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line">(a.*pf)();</span><br></pre></td></tr></table></figure><hr><p>统一初始化<br><code>X x1 = {0} 和 X x2 {0}</code> 这两种是不同的实现!!, 大多数情况下这两个是相通的, 然而当<br><code>explicit构造函数</code>存在的时候<code>前者的初始化是错误的</code></p><p><code>int x{0} int x= 0 int x(0)</code> 最后一个是错误的可能会和函数声明冲突</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">z</span><span class="params">(x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还存在一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; a1&#123;<span class="number">0</span>&#125;; <span class="comment">// OK</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; a3 = <span class="number">0</span>; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>这个错误的原因是copy-initialization引起的<br>这个copy-initialization发生在<code>T x = a</code>的声明, 下面我把原博客的部分重要英文替换成中文或代码描述<br><code>std::atomic&lt;int&gt; a3 = 0</code> 从<code>int类型</code>赋值到<code>可能是 cv-qualified</code>的<code>class type</code><br><a href="https://stackoverflow.com/questions/27527642/what-does-cv-qualified-mean" target="_blank" rel="noopener">cv-qualified</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ***cv-qualified***</span></span><br><span class="line"><span class="comment">// non cv_qualified</span></span><br><span class="line"><span class="keyword">int</span> first; </span><br><span class="line"><span class="keyword">char</span> *second; </span><br><span class="line"></span><br><span class="line"><span class="comment">// cv-qualified </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> third; </span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span> * fourth;</span><br></pre></td></tr></table></figure><p><code>std::atomic&lt;int&gt; a3 = 0</code> 满足了这个条件属于<code>copy-initialization</code><br><a href="https://www.quora.com/What-is-the-difference-between-copy-initialization-and-direct-initialization-of-objects-in-c++" target="_blank" rel="noopener">copy-initialization</a><br><a href="https://blog.csdn.net/ljianhui/article/details/9245661" target="_blank" rel="noopener">直接初始化和复制初始化的区别</a><br>直接初始化会直接用参数生成对象, 而复制初始化会<code>用参数生成临时对象, 然后将这个对象复制到正要创建的对象</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        A () &#123; &#125; <span class="comment">//直接初始化会调用这个构造函数</span></span><br><span class="line">        A (<span class="keyword">const</span> A&amp; a) &#123; &#125; <span class="comment">//复制初始化会调用这个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来需要通过<code>std::atomic&lt;int&gt;(int)</code>把0转换成成一个纯右值(prvalue)的临时对象<br><a href="https://zh.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener">纯右值</a><br><a href="https://www.cnblogs.com/zpcdbky/p/5275959.html" target="_blank" rel="noopener">纯右值</a><br>然后再将这个临时对象用直接初始化(调用复制构造函数), 然而<code>std::atomic&lt;int&gt;</code>把拷贝<br>构造函数给禁用了, 就会出错<br><code>std::atomic&lt;int&gt; a3 {0}</code>这个会直接调用接收int的构造函数</p><p>回到<code>X x1 = {0}</code>这里, 这个表达式是一个复制构造, 用一个braced-init-list(指的{0}).<br>这里有两个阶段<br>首先是会把单个参数的构造函数汇总起来(得到A-list)供选择, 如果其中没有合适的构造函数, 再将候选列表<br>转换为所有构造函数</p><p>如果如果A-list没有构造函数, 并且class T存在默认构造函数, 第一阶段就会被忽略<br>如果在一个使用<code>{}</code>的初始化, 并且选择到了<code>explicit 构造函数头上</code>就会报错</p><p><code>explicit</code>可以防止在调用某个成员函数的时候, 实参类型(通过构造函数之一)自动转换成相应参数,<br>但此时这个函数需要其他的成员变量参与到函数运行, 恰巧这时所需要的其他成员变量没有得到合适的初始化, 就会发生错误(没有得到合适初始化的原因就是, 自动调用了不合适的构造函数生成了这个函数所需要的参数(一般是对象))</p><p>@2019年10月26日21:25:58@算是第一次解决一个环环相扣的问题, 精力有点不足了<br><a href="https://zhuanlan.zhihu.com/p/21102748" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21102748</a> 后续会继续进行理解<br><a href="https://blog.csdn.net/spaceyqy/article/details/22730939" target="_blank" rel="noopener">这里还发现一个</a></p><h1 id="模板-泛型-动态内存-数据结构"><a href="#模板-泛型-动态内存-数据结构" class="headerlink" title="模板, 泛型 动态内存, 数据结构"></a>模板, 泛型 动态内存, 数据结构</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">GetMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; GetMax(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; GetMax&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 显示指定模板类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/C%2B%2B%E5%86%85%E5%AD%98.png" alt=""><br>C++堆的内存需要手动new和delete, 如果一个对象new出来没有在能被释放的时候释放就会造成–<strong>内存泄漏</strong>(需要及时delete不需要的对象)<br>一个指向动态内存的指针, 在动态内存被释放后, 指针依然指向原来的地址–<strong>空悬指针</strong>(释放内存后将相应的指针设置为nullptr)</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义新量&quot;&gt;&lt;a href=&quot;#定义新量&quot; class=&quot;headerlink&quot; title=&quot;定义新量&quot;&gt;&lt;/a&gt;定义新量&lt;/h1&gt;&lt;p&gt;auto 自动根据初始值的类型进行自动类型推导.&lt;br&gt;decltype 根据表达式的类型定义对象&lt;/p&gt;
&lt;p&gt;右值引用,
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP基础" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>牛客整理</title>
    <link href="http://blog.lsmg.xyz/2019/10/CPP-CPP%E5%9F%BA%E7%A1%80-%E7%89%9B%E5%AE%A2/"/>
    <id>http://blog.lsmg.xyz/2019/10/CPP-CPP%E5%9F%BA%E7%A1%80-%E7%89%9B%E5%AE%A2/</id>
    <published>2019-10-19T04:31:37.000Z</published>
    <updated>2020-01-23T11:35:08.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运算出结果类"><a href="#运算出结果类" class="headerlink" title="运算出结果类"></a>运算出结果类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">200</span>;</span><br><span class="line">a+=<span class="number">27</span>;sum+=a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br></pre></td></tr></table></figure><p>a为 -128~127<br> 127  = 0111 1111<br>“128”= 1000 0000 (-128的补码)</p><p>关于1000 0000代表-128 我偶然发现一个博客有种恍然大悟的感觉<br><a href="https://blog.csdn.net/daiyutage/article/details/8575248" target="_blank" rel="noopener">浅析为什么char类型的范围是 —128~+127</a><br>这个博客实在是写的太好了</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a,b,c,d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c,%c,%d,%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c,%c,%c,%c"</span>,a,b,c,d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>%c进行输入会进行转化后存入<br>输入 1 即认为输入 ‘1’ 转换成49存入</p><hr><h1 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h1><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。<br>凡是含有纯虚函数的类叫做 抽象类 。这种类不能声明对象，只是作为基类为派生类服务.<br>除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</p><h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><p>静态成员可以作为默认实参</p><h1 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h1><h1 id="基础中的基础"><a href="#基础中的基础" class="headerlink" title="基础中的基础"></a>基础中的基础</h1><p>这部分有些只保留题目, 不做解析 便于自己想象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> k = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">while</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">--k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面三个函数全部错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char array[MAX_CHAR+1],i; &#x2F;&#x2F; 这个函数在于MAX_CHAR可能会大于255导致i永远无法达到</span><br><span class="line">    for(i&#x3D;0;i&lt;&#x3D;MAX_CHAR;i++)&#123;</span><br><span class="line">        array[i]&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">char*test2()</span><br><span class="line">&#123;</span><br><span class="line">    char p[] &#x3D; &quot;hello world&quot;;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">char *p &#x3D;test2();</span><br><span class="line">void test3()&#123;</span><br><span class="line">    char str[10];</span><br><span class="line">    str++;</span><br><span class="line">    *str&#x3D;&#39;0&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="基础中的Api"><a href="#基础中的Api" class="headerlink" title="基础中的Api"></a>基础中的Api</h1><p>虽然自己还没用过, 但还是要积累</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">4</span>;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'#'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始看到这个题目, 为putchar是放到缓冲区中, 结果就是正常的输出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;运算出结果类&quot;&gt;&lt;a href=&quot;#运算出结果类&quot; class=&quot;headerlink&quot; title=&quot;运算出结果类&quot;&gt;&lt;/a&gt;运算出结果类&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP基础" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
