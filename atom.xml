<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lsmg的大学之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lsmg.xyz/"/>
  <updated>2020-11-25T13:27:40.599Z</updated>
  <id>http://blog.lsmg.xyz/</id>
  
  <author>
    <name>Lsmg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>力扣11.25-N34.在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="http://blog.lsmg.xyz/2020/11/%E5%8A%9B%E6%89%A311.25-N34.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"/>
    <id>http://blog.lsmg.xyz/2020/11/%E5%8A%9B%E6%89%A311.25-N34.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</id>
    <published>2020-11-25T10:50:02.000Z</published>
    <updated>2020-11-25T13:27:40.599Z</updated>
    
    <content type="html"><![CDATA[<h1 id="N34-在排序数组中查找元素的第一个和最后一个位置"><a href="#N34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="N34.在排序数组中查找元素的第一个和最后一个位置"></a>N34.在排序数组中查找元素的第一个和最后一个位置</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 O(log n) 级别。</p><p>如果数组中不存在目标值，返回 [-1, -1]。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sub = (right + left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[sub])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> l_sub, r_sub;</span><br><span class="line">                <span class="keyword">for</span> (l_sub = sub - <span class="number">1</span>; l_sub &gt;=<span class="number">0</span> &amp;&amp; nums[l_sub] == target; --l_sub)</span><br><span class="line">                &#123;</span><br><span class="line">                   </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (r_sub = sub + <span class="number">1</span>; r_sub &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[r_sub] == target; ++r_sub)</span><br><span class="line">                &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> &#123;l_sub + <span class="number">1</span>, r_sub - <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[sub])</span><br><span class="line">            &#123;</span><br><span class="line">                right = sub;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = sub + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路使用二分搜索找到目标元素 然后想左右扩散寻找边界</p><h1 id="剑指-Offer-53-I-在排序数组中查找数字-I"><a href="#剑指-Offer-53-I-在排序数组中查找数字-I" class="headerlink" title="剑指 Offer 53 - I. 在排序数组中查找数字 I"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I</h1><p>统计一个数字在排序数组中出现的次数。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sub = (right + left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target == nums[sub])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l_sub = sub - <span class="number">1</span>; l_sub &gt;=<span class="number">0</span> &amp;&amp; nums[l_sub] == target; --l_sub)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++result;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r_sub = sub + <span class="number">1</span>; r_sub &lt;= nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[r_sub] == target; ++r_sub)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++result;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[sub])</span><br><span class="line">            &#123;</span><br><span class="line">                right = sub;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = sub + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路同上, 返回值不同</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;N34-在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;a href=&quot;#N34-在排序数组中查找元素的第一个和最后一个位置&quot; class=&quot;headerlink&quot; title=&quot;N34.在排序数组中查找元素的第一个和最后一个位置&quot;&gt;&lt;/a&gt;N34.在排序数组中查
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/tags/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>力扣11.24-N3.无重复字符的最长子串</title>
    <link href="http://blog.lsmg.xyz/2020/11/%E5%8A%9B%E6%89%A311.24-N3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://blog.lsmg.xyz/2020/11/%E5%8A%9B%E6%89%A311.24-N3.%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2020-11-24T10:50:02.000Z</published>
    <updated>2020-11-25T13:24:04.068Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h1 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> char_flag[<span class="number">128</span>]; <span class="comment">// 记录字符是否出现过</span></span><br><span class="line">    <span class="keyword">int</span> char_sub[<span class="number">128</span>]; <span class="comment">// 记录字符下标</span></span><br><span class="line">    <span class="built_in">memset</span>(char_flag, <span class="literal">false</span>, <span class="keyword">sizeof</span> char_flag);</span><br><span class="line">    <span class="keyword">int</span> max_result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> begin_sub = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sub = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (sub &lt; s.length())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> current_char = s[sub];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (char_flag[current_char])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sub - begin_sub &gt; max_result)</span><br><span class="line">            &#123;</span><br><span class="line">                max_result = sub - begin_sub;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = begin_sub; i &lt; char_sub[current_char]; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                char_flag[s[i]] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            begin_sub = char_sub[current_char] + <span class="number">1</span>;</span><br><span class="line">            char_sub[current_char] = sub;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            char_sub[current_char] = sub;</span><br><span class="line">            char_flag[current_char] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sub++;</span><br><span class="line">        <span class="keyword">if</span> (sub == s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sub - begin_sub &gt; max_result)</span><br><span class="line">            &#123;</span><br><span class="line">                max_result = sub - begin_sub;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路是按顺序读取char, 如果没有出现过则标记出现记录下标.</p><p>如果出现了则用当前下标减去开始下标判断是否更长来记录, 同时更新开始下标为重复字符的下标后一个字符下标.</p><p>移动开始下标后 需要取消 新开始标记和旧开始标记之前的char标记</p><h1 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> heap[<span class="number">128</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.<span class="built_in">size</span>(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            heap[s[j]]++; <span class="comment">// 标记字符出现</span></span><br><span class="line">            <span class="keyword">while</span>(heap[s[j]] &gt; <span class="number">1</span>) <span class="comment">// 再次出现</span></span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/*</span></span><br><span class="line"><span class="comment">              开始符号标记下标 向前滑动 1 将开始下标的字符滑动出去</span></span><br><span class="line"><span class="comment">              如果滑出去的字符是本次遇到的重复字符 则继续 否则一直滑动到重复字符位置</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">                heap[s[i]]--;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, j - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先看上去 代码就非常的短 我的写了40行而这个仅有10行</p><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p>我的虽然不是一次滑动一个字符 而是滑动一步到位. 但是仍需要一个for循环来去掉滑出的字符. 所以同样例代码思想.</p><p>所以没有必要一次滑动到位, 反正for循环需要执行就在for之中慢慢滑动. <code>这样可以省去记录字符出现的下标</code></p><p>我字符出现记录使用的bool数组然而使用<code>int数组却能包含更多的信息</code>.</p><p>我原版代码需要额外判定一次是否到了尾部, 当最后一个字符没有重复的时候 循环就结束了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/tags/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>P2P直播平台</title>
    <link href="http://blog.lsmg.xyz/2020/11/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-P2P%E7%9B%B4%E6%92%AD%E5%B9%B3%E5%8F%B0/"/>
    <id>http://blog.lsmg.xyz/2020/11/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-P2P%E7%9B%B4%E6%92%AD%E5%B9%B3%E5%8F%B0/</id>
    <published>2020-11-09T08:11:02.000Z</published>
    <updated>2020-11-18T05:59:18.771Z</updated>
    
    <content type="html"><![CDATA[<p>当前进度 <code>服务器端</code>解析Rtmp推流保存并为可以播放的Flv文件 (初版完成)</p><p>服务器端代码量 包含网络部分 3000余行 - 2020年11月18日</p><h1 id="项目规划"><a href="#项目规划" class="headerlink" title="项目规划"></a>项目规划</h1><p>开发轻量级的可用于P2P直播的<code>服务器端</code>和<code>观看客户端</code></p><p>项目不打算开发UI方面的功能, 视频将使用第三方的支持HttpFlv拉流的播放器来播放(如PotPlayer)</p><p>开发可以接收Rtmp推流的<code>服务器端</code>  (初版完成)</p><p><code>服务器端</code>可以<code>接收HttpFlv的拉流</code> (未开发)</p><p>开发<code>观看客户端</code>主要用于从<code>服务器端</code>接收二进制的Flv数据 本地转化成HttpFlv格式 供<code>HttpFlv拉流软件本地拉取</code> (未开发)</p><p><code>观看者客户端</code>可以从<code>服务器端</code>获取数据 野通过P2P与其他<code>观看者客户端</code>进行共享 (未开发)</p><h2 id="初版"><a href="#初版" class="headerlink" title="初版"></a>初版</h2><p>主播使用<code>RTMP推流软件(如Obs)</code>将RTMP流发送到<code>服务器端</code> <code>服务器端</code>将Rtmp流以FLv格式保存在内存缓冲区 或者写入Flv文件</p><p>观看者直接使用<code>服务器端</code>生成的HTTPFLV地址 拉流观看</p><p>观看者下载<code>观看者客户端</code>从<code>服务器端</code>获得Socket数据流</p><p><code>观看者客户端</code>将Socket数据流包装成HTTP协议 生成本地连接如<code>http://127.0.0.1:4000/xxxxx.mp4</code> 使用第三方网络视频播放器进行播放</p><h2 id="P2P版本-未开发"><a href="#P2P版本-未开发" class="headerlink" title="P2P版本 (未开发)"></a>P2P版本 (未开发)</h2><p>由于<code>观看者客户端</code>从<code>服务器端</code>获取的是Socket数据流 <code>观看者客户端</code>可以将其包装成HTTP格式 进行本地播放或者给其他<code>观看者客户端</code>提供链接进行播放</p><h1 id="项目所需技术"><a href="#项目所需技术" class="headerlink" title="项目所需技术"></a>项目所需技术</h1><h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><h3 id="缓存FLV数据"><a href="#缓存FLV数据" class="headerlink" title="缓存FLV数据"></a>缓存FLV数据</h3><p>FLV文件格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class FileHeader</span><br><span class="line">&#123;</span><br><span class="line">char flv[3]; &#x2F;&#x2F; FLV</span><br><span class="line">uint8_t version; &#x2F;&#x2F; 1</span><br><span class="line">uint8_t type_flags; &#x2F;&#x2F; 5</span><br><span class="line">uint32_t header_length; &#x2F;&#x2F; 9</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class FileTag</span><br><span class="line">&#123;</span><br><span class="line">uint32_t previous_tag_size; &#x2F;&#x2F; 不含previous_tag_size  sizeof 上一个Tag - 4</span><br><span class="line">uint8_t tag_type; &#x2F;&#x2F; 音频 8 视频 9 scripts 18</span><br><span class="line">uint8_t data_size[3]; &#x2F;&#x2F; AudioTag VideoTag 的数据长度 从stream_id后开始算起</span><br><span class="line">uint8_t timestamp[3];</span><br><span class="line">uint8_t timestamp_extend;</span><br><span class="line">uint8_t stream_id[3]; &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">char* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FileHeader file_header; &#x2F;&#x2F; 每次开始都要发送一次</span><br><span class="line">FileTag info_tag; &#x2F;&#x2F; 每次开始都要发送一次</span><br><span class="line">FileTag sps_pps_tag; &#x2F;&#x2F; 每次开始都要发送一次 第一个视频tag存储编码信息</span><br><span class="line">FileTag audio_tag; &#x2F;&#x2F; 每次开始都要发送一次 第一个音频tag存储编码信息</span><br><span class="line"></span><br><span class="line">FileTag data[N]; &#x2F;&#x2F; 真正的数据部分</span><br></pre></td></tr></table></figure><p>每次有<code>观看者客户端</code>连接的时候 都要发送一次<code>file_header</code>,<code>info_tag</code>和<code>sps_pps_tag</code> 以及<code>audio_tag</code>之后便是数据部分</p><h3 id="解析RTMP协议-从中得到音视频流"><a href="#解析RTMP协议-从中得到音视频流" class="headerlink" title="解析RTMP协议 从中得到音视频流"></a>解析RTMP协议 从中得到音视频流</h3><h4 id="RTMP握手协议"><a href="#RTMP握手协议" class="headerlink" title="RTMP握手协议"></a>RTMP握手协议</h4><p>Obs客户端首先会发送C1 服务器端直接将C1作为S1发送回去, Obs会发送C2 服务端继续发送C1作为S2 握手成功</p><p>商定窗口大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">--&gt;</span><br><span class="line">connect</span><br><span class="line"></span><br><span class="line">&lt;-- Window Acknowledgement Size 5000000</span><br><span class="line">[02 00 00 00 00 00 04 05 00 00 00 00 00 4c 4b 40]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;-- Set Peer Bandwidth 5000000,Dynamic|Set Chunk Size 4096|_result(&#39;NetConnection.Connect.Success&#39;)</span><br><span class="line">[02 00 00 00 00 00 05 06 00 00 00 00 00 4c 4b 40 02]</span><br><span class="line">[02 00 00 00 00 00 04 01 00 00 00 00 00 00 10 00]</span><br><span class="line">[03 00 00 00 00 00 be 14 00 00 00 00 02 00 07 5f 72 65 73 75 6c 74 00 3f f0 00 00 00 00 00 00 03 00 06 66 6d 73 56 65 72 02 00 0d 46 4d 53 2f 33 2c 30 2c 31 2c 31 32 33 00 0c 63 61 70 61 62 69 6c 69 74 69 65 73 00 40 3f 00 00 00 00 00 00 00 00 09 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74 75 73 00 04 63 6f 64 65 02 00 1d 4e 65 74 43 6f 6e 6e 65 63 74 69 6f 6e 2e 43 6f 6e 6e 65 63 74 2e 53 75 63 63 65 73 73 00 0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 15 43 6f 6e 6e 65 63 74 69 6f 6e 20 73 75 63 63 65 65 64 65 64 2e 00 0e 6f 62 6a 65 63 74 45 6e 63 6f 64 69 6e 67 00 00 00 00 00 00 00 00 00 00 00 09]</span><br></pre></td></tr></table></figure><p>建立流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--&gt;</span><br><span class="line">releaseStream</span><br><span class="line">FCPublish</span><br><span class="line">&lt;-- _result()</span><br><span class="line">[03 00 00 00 00 00 1d 14 00 00 00 00 02 00 07 5f 72 65 73 75 6c 74 00 40 10 00 00 00 00 00 00 05 00 3f f0 00 00 00 00 00 00]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--&gt;</span><br><span class="line">publish</span><br><span class="line">&lt;-- onStatus(&#39;NetStream.Publish.Start&#39;)</span><br><span class="line">[05 00 00 00 00 00 69 14 01 00 00 00 02 00 08 6f 6e 53 74 61 74 75 73 00 00 00 00 00 00 00 00 00 05 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74 75 73 00 04 63 6f 64 65 02 00 17 4e 65 74 53 74 72 65 61 6d 2e 50 75 62 6c 69 73 68 2e 53 74 61 72 74 00 0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 10 53 74 61 72 74 20 70 75 62 6c 69 73 68 69 6e 67 00 00 09]</span><br></pre></td></tr></table></figure><p>至此连接建立完毕, Obs开始推流</p><h4 id="RTMP推流协议部分"><a href="#RTMP推流协议部分" class="headerlink" title="RTMP推流协议部分"></a>RTMP推流协议部分</h4><p>RTMP的消息单元称为Message单个Message太大被拆分为多块 包装在Message Chunk中发送</p><p>所以服务器端需要从TCP流中获取Message Chunk组装出Message 再从Message中获取到音视频数据</p><h5 id="Message-Chunk"><a href="#Message-Chunk" class="headerlink" title="Message Chunk"></a>Message Chunk</h5><p><code>Message Chunk</code> = <code>Message Chunk Header</code> + <code>Chunk Data</code></p><p><code>Message Chunk Header</code> = <code>Basic Header</code> + <code>Message Header</code> + <code>extern timestamp</code></p><p>如以下例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000   04 00 00 00 00 00 31 09 01 00 00 00 17 00 00 00</span><br><span class="line">0010   00 01 64 00 28 ff e1 00 1d 67 64 00 28 ac d9 40</span><br><span class="line">0020   78 02 27 e5 9a 80 80 80 a0 00 00 03 00 20 00 00</span><br><span class="line">0030   07 91 e3 06 32 c0 01 00 04 68 ef bc b0</span><br></pre></td></tr></table></figure><p><strong>Basic Header</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">04 &#x3D; 00  00 0100&#x2F;&#x2F; fmt &#x3D; 0 csid &#x3D; 4</span><br></pre></td></tr></table></figure><p>1字节 初期只关注csid为4的数据部分, 因为csid为4时对应音视频数据</p><p><strong>Message Header</strong></p><p>fmt = 0 11字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 &#x2F;&#x2F; timestamp</span><br><span class="line">00 00 31 &#x2F;&#x2F; msglength</span><br><span class="line">09 &#x2F;&#x2F; typeid 9视频</span><br><span class="line">01 00 00 00 &#x2F;&#x2F; 小端存储  message stream id</span><br></pre></td></tr></table></figure><p>fmt = 1 7字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 &#x2F;&#x2F; timestamp 前一个块时间戳与当前块时间戳的差值，即相对时间戳</span><br><span class="line">00 00 31 &#x2F;&#x2F; msglength</span><br><span class="line">09 &#x2F;&#x2F; typeid 9视频</span><br><span class="line">&#x2F;&#x2F; 不含 message stream id 此时块与之前的块取相同的消息流ID</span><br></pre></td></tr></table></figure><p>fmt = 2 3字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 &#x2F;&#x2F; timestamp 前一个块时间戳与当前块时间戳的差值，即相对时间戳</span><br><span class="line">&#x2F;&#x2F; 不含 msglength 与前一个相同</span><br><span class="line">&#x2F;&#x2F; 09 不含typeid 9视频</span><br><span class="line">&#x2F;&#x2F; 不含 message stream id 此时块与之前的块取相同的消息流ID</span><br></pre></td></tr></table></figure><p>fmt = 3 0字节</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不含头 一个消息被分成多个的时候 使用这个类型</span><br></pre></td></tr></table></figure><p>Obs发送<code>@SetDataFrame()</code>其中Data为info_tag的data部分<br>Obs发送<code>Audio Data</code>其中Data为audio_tag的data部分  音频数据包<br>Obs发送<code>Video Data</code>其中Data为sps_pps_tag的data部分  视频数据包</p><p>之后便是数据的发送.</p><h1 id="文件介绍"><a href="#文件介绍" class="headerlink" title="文件介绍"></a>文件介绍</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt 总配置文件</span><br><span class="line">├── CMakeSettings.json vsstudio2019 cmake项目配置文件</span><br><span class="line">├── main.cpp 接收Obs推流数据 除去握手和建立连接部分 保存到data中 实测会导致 obs发送的publish也被保存</span><br><span class="line">├── network 网络核心模块</span><br><span class="line">│   ├── Acceptor.cpp</span><br><span class="line">│   ├── Acceptor.h</span><br><span class="line">│   ├── Callback.h</span><br><span class="line">│   ├── Channel.cpp</span><br><span class="line">│   ├── Channel.h</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── Epoll.cpp</span><br><span class="line">│   ├── Epoll.h</span><br><span class="line">│   ├── EventLoop.cpp</span><br><span class="line">│   ├── EventLoop.h</span><br><span class="line">│   ├── InetAddress.cpp</span><br><span class="line">│   ├── InetAddress.h</span><br><span class="line">│   ├── Socket.cpp</span><br><span class="line">│   ├── Socket.h</span><br><span class="line">│   ├── SocketOps.cpp</span><br><span class="line">│   ├── SocketOps.h</span><br><span class="line">│   ├── TcpConnection.cpp</span><br><span class="line">│   ├── TcpConnection.h</span><br><span class="line">│   ├── TcpServer.cpp</span><br><span class="line">│   └── TcpServer.h</span><br><span class="line">├── server</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── codec 编解码器 用于解析数据流 Flv和Rtmp的数据包解析位置以及相关数据包格式</span><br><span class="line">│   │   ├── FlvCodec.cpp 供FlvManager使用 不直接使用</span><br><span class="line">│   │   ├── FlvCodec.h</span><br><span class="line">│   │   ├── RtmpCodec.cpp 供RtmpManager使用 不直接使用 包含Rtmp数据包到Flv数据包的转换函数</span><br><span class="line">│   │   └── RtmpCodec.h</span><br><span class="line">│   ├── FlvManager.cpp Flv管理器用于保存解析好的多个FlvTag信息, 管理Flv解析过程</span><br><span class="line">│   ├── FlvManager.h</span><br><span class="line">│   ├── RtmpManager.cpp Rtmp管理器用于将解析好的Rtmp转换成Flv数据包 保存到FlvManager中, 管理Rtmp流解析过程</span><br><span class="line">│   ├── RtmpManager.h</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── FlvManagerTest.cpp 测试FlvManager对正常Flv文件的解析 以及相关数据的存储</span><br><span class="line">│       └── RtmpManagerTest.cpp 测试RTMPManager对Rtmp数据流的解析 转换成Flv数据保存 并将Flv数据保存为Flv文件</span><br><span class="line">└── utils 工具类</span><br><span class="line">    ├── Buffer.cpp 通用缓冲区</span><br><span class="line">    ├── Buffer.h</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── File.cpp 文件对象 用于简单的读写文件</span><br><span class="line">    └── File.h</span><br></pre></td></tr></table></figure><h1 id="犯错"><a href="#犯错" class="headerlink" title="犯错"></a>犯错</h1><p>fmt = 2的时候并不包含typeid  导致的错误</p><p>只有在读满一个chunk分块4096字节后 返回解析一个新的header的时候<br>当remain小于等于RTMP_CHUNK_SIZE的时候说明 此chunk分块结束了  虽然知道此逻辑但是 逻辑并没有完全表示出来</p><p>错写成了下面的形式 没有判断当前的chunk分块是否读完</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (remain &lt;= RTMP_CHUNK_SIZE &amp;&amp; read_chunk_size_ == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">chunk_over_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">chunk_over_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (remain &gt; RTMP_CHUNK_SIZE)</span><br><span class="line">&#123;</span><br><span class="line">chunk_over_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">chunk_over_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;当前进度 &lt;code&gt;服务器端&lt;/code&gt;解析Rtmp推流保存并为可以播放的Flv文件 (初版完成)&lt;/p&gt;
&lt;p&gt;服务器端代码量 包含网络部分 3000余行 - 2020年11月18日&lt;/p&gt;
&lt;h1 id=&quot;项目规划&quot;&gt;&lt;a href=&quot;#项目规划&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="项目制作" scheme="http://blog.lsmg.xyz/categories/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C/"/>
    
    
      <category term="P2P直播平台" scheme="http://blog.lsmg.xyz/tags/P2P%E7%9B%B4%E6%92%AD%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>HTTP框架底层原理实现</title>
    <link href="http://blog.lsmg.xyz/2020/11/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-HTTP%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.lsmg.xyz/2020/11/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-HTTP%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</id>
    <published>2020-11-01T14:45:39.000Z</published>
    <updated>2020-11-07T07:12:14.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>后端组使用各种框架</p><ul><li>Java的Springboot</li><li>Python的Django</li></ul><p>框架的底层原理是什么? 当然涉及原理性的东西太多了, 我这里指的是为什么客户端的几次简单点击 最终会转化成了后端的函数调用?</p><p>Springboot针对某一个URL能Get Post等等设置对应的方法. 还能得到指定的参数?</p><p>客户端的几下简单的点击就能够将数据传送到后端 从后端拿回数据然后进行显示</p><p>后端也只要在相关的函数后处理接收到的数据</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>要解释上面的问题需要用到计算机学院几门专业课的只是 &lt;操作系统&gt; &lt;计算机组成原理 跳过&gt; &lt;计算机网络&gt;</p><p>基础知识我要不要学? HTTP协议? DNS怎么发挥的作用?</p><p>GET POST 有什么区别? 为什么GET有参数长度限制(自己本以为是RFC规定 然而是浏览器规定的而且是URL长度限制而不是参数限制) 而POST没有参数长度限制<br>新了解到了</p><p>无法访问网页怎么办? 可以根据浏览器访问流程进行排查</p><p>校园网断网跳转怎么实现的? DNS污染又是什么? <em>返回错误的IP</em></p><p>favicon? 如何实现的自动加载 <em>GET /favicon.ico HTTP/1.1</em></p><p>抓包的原理</p><h1 id="浏览器访问流程"><a href="#浏览器访问流程" class="headerlink" title="浏览器访问流程"></a>浏览器访问流程</h1><p>当你输入一个网址, 按下回车后 首先会向DNS服务器发送DNS请求将域名转换成IP. <em>DNS污染</em></p><p>然后向 IP+端口号 <strong>建立连接 强调!</strong> 发送HTTP请求 (HTTP默认是80端口) 接收HTTP回应 进行解析HTML 然后请求相关的JS文件等</p><p>然而收发HTTP并不是 操作系统提供的基础API的功能 那是怎么来的?</p><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>协议是什么?</p><p>文本协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">GET  HTTP&#x2F;1.1</span><br><span class="line">Host: 10.2.5.251</span><br><span class="line">Connection: keep-alive</span><br><span class="line">DNT: 1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.183 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">DNT: 1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.183 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Sec-Fetch-Site: none</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class="line">Cookie: BIDUPSID&#x3D;275AD930CBDC20F9C9E074230710B72E; PSTM&#x3D;1602485007; BAIDUID&#x3D;93E8E77E51A5F22CA01131559BA8666A:FG&#x3D;1; BD_UPN&#x3D;12314753; BDUSS&#x3D;BjRVJYdFQ5TEJKWWNPck1ZcWdOVklMT0JHMHhQMUx3UGxDZjhNMVVhRmdqcXRmSVFBQUFBJCQAAAAAAAAAAAEAAADZQdlRcmpkNjc0NDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGABhF9gAYRfM3; BDUSS_BFESS&#x3D;BjRVJYdFQ5TEJKWWNPck1ZcWdOVklMT0JHMHhQMUx3UGxDZjhNMVVhRmdqcXRmSVFBQUFBJCQAAAAAAAAAAAEAAADZQdlRcmpkNjc0NDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGABhF9gAYRfM3; BAIDUID_BFESS&#x3D;F500721F63FBCA4EDC7DA170AE314FEE:FG&#x3D;1; BDORZ&#x3D;B490B5EBF6F3CD402E515D22BCDA1598; COOKIE_SESSION&#x3D;332523_0_8_0_3_6_1_0_7_4_42_0_332523_0_6_0_1604291277_0_1604291271%7C8%230_0_1604291271%7C1; sug&#x3D;3; sugstore&#x3D;0; ORIGIN&#x3D;0; bdime&#x3D;0; ZD_ENTRY&#x3D;google</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST http:&#x2F;&#x2F;202.119.196.6:8080&#x2F;Self&#x2F;login&#x2F;verify HTTP&#x2F;1.1</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Origin: http:&#x2F;&#x2F;202.119.196.6:8080</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">DNT: 1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.111 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Referer: http:&#x2F;&#x2F;202.119.196.6:8080&#x2F;Self&#x2F;login&#x2F;?302&#x3D;LI</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class="line">Host: 202.119.196.6:8080</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Content-Length: 60</span><br><span class="line">Cookie: JSESSIONID&#x3D;E56420ED06E0ABE922C5A904DBB9C944</span><br><span class="line"></span><br><span class="line">foo&#x3D;&amp;bar&#x3D;&amp;checkcode&#x3D;1234&amp;account&#x3D;08180000&amp;password&#x3D;md5&amp;code&#x3D;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Sat, 31 Dec 2005 23:59:59 GMT</span><br><span class="line">Content-Type: text&#x2F;html;charset&#x3D;ISO-8859-1</span><br><span class="line">Content-Length: 122</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Wrox Homepage&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- body goes here --&gt;</span><br><span class="line">HTTP&#x2F;1.1 200 OK Date: Sat</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>根据这个格式<em>描述一下格式</em> 请求方法 请求路径 HTTP版本</p><p>HEADER部分 需要什么HEADER加入什么</p><p>BODY部分 放入数据</p><p>所根据的这个格式 这个规定就叫做协议 HTTP的规定就是HTTP协议</p><p>所以说你在手机上查询电费也好 电脑上浏览网页也罢 前端调用后端也是如此 只要是HTTP的API 都会将数据按照这个格式进行打包</p><ol><li><strong>建立连接后</strong>   Fiddler监听拦截的数据, 你知道了这个包的数据都有什么 然后自己建立连接发送同样的包 效果是一样的</li><li>发送打包的数据 </li><li>接收服务器返回的结果</li><li>所以可以抓包后模拟请求这就这么来的</li></ol><h1 id="从TCP看HTTP"><a href="#从TCP看HTTP" class="headerlink" title="从TCP看HTTP"></a>从TCP看HTTP</h1><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E4%B8%83%E5%B1%82%E5%92%8C%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE.png" alt=""></p><p><em>将根据这张图说一说, 经常让了解的 七层和四层协议.  (网络访问(链接)层)</em></p><p>上边面说的建立连接建立的实际是TCP连接</p><p>TCP连接是通过 IP和端口号建立的 正好使用的上面的IP和端口号</p><p>TCP连接干什么?  连接就是传输数据 这就涉及到了读写操作  全双工</p><p>两个套接字之间的通信 客户端持有一个套接字 服务器持有一个套接字 然后客户端的数据发送和服务器端的数据接收就是转化为了针对套接字的读写</p><p>套接字你可以理解为 两个电话互相通话</p><p>套接字的建立和管理都比较复杂, 但是流程极为固定 干脆将这些代码包装起来 对外界提供一个简单的函数即可 内部帮你管理建立TCP连接</p><p>客户端指的就是你的浏览器也好, 你的应用也好 套接字这个核心的东西被包装了起来</p><p>所以输入网址也好, 使用form标签也罢. 最终都是根据HTTP协议包装你想要发送或者接受的数据. 建立TCP连接 然后将包装好的数据发送到套接字 对方从套接字接受 (流, 流水 按顺序流入)</p><p><em>nc 命令 演示演示?</em></p><p>所以你可以没有域名 照样可以使用HTTP协议 照样访问网页.</p><p>因为HTTP交互的核心就是 根据HTTP协议包装数据 经由TCP连接收发数据 TCP连接使用的是 IP和端口号 而非域名</p><p>域名就没有用了吗? 除了便于记忆? <em>域名 区分作用</em></p><h1 id="HTTP框架"><a href="#HTTP框架" class="headerlink" title="HTTP框架"></a>HTTP框架</h1><p>上面说了HTTP交互细节. 本质就是的收发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;api?a&#x3D;1&amp;b&#x3D;2 HTTP&#x2F;1.1</span><br><span class="line">Host: 10.2.5.251</span><br><span class="line">Connection: keep-alive</span><br><span class="line">DNT: 1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.183 Safari&#x2F;537.36</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class="line"></span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Sat, 31 Dec 2005 23:59:59 GMT</span><br><span class="line">Content-Type: text&#x2F;html;charset&#x3D;ISO-8859-1</span><br><span class="line">Content-Length: 122</span><br><span class="line"></span><br><span class="line">＜html＞</span><br><span class="line">＜head＞</span><br><span class="line">＜title＞Wrox Homepage＜&#x2F;title＞</span><br><span class="line">＜&#x2F;head＞</span><br><span class="line">＜body＞</span><br><span class="line">＜!-- body goes here --＞</span><br><span class="line">＜&#x2F;body＞</span><br><span class="line">＜&#x2F;html＞</span><br></pre></td></tr></table></figure><p>服务器端从套接字 接收到数据后 大家没有见过上面的东西吧</p><p>那就是框架接受之后 把它们作为字符串存了起来 然后按照HTTP的固定协议格式 将内容解析</p><p>必须解析的一般有 Get /api?a=1&amp;b=2  然后得知了这是一个GET请求 请求的URL是 /api 有两个参数 叫什么 值是多少</p><p>然后根据你服务器代码设定的找到一个对应的函数, 框架调用这个函数 传入参数 你就可以处理相应的逻辑了.</p><h1 id="库和框架"><a href="#库和框架" class="headerlink" title="库和框架?"></a>库和框架?</h1><p>库是帮你提供某些功能的包装, 单个库一般并不能开发完整的应用, 只是作为一部分功能函数. curl库 线程库</p><p>框架可以理解为库的升级版, 你使用一个框架提供的函数 就能开发完整的应用, 大多数框架还能方便的引入其他的库来供自己使用.</p><h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx?"></a>nginx?</h1><p>nginx大家用过没有?</p><p>一般逻辑都是设置一个域名 然后指向一个端口 是不是?</p><p>域名这个东西就藏在了HTTPRequest的 header里 他同样从TCP连接接收数据 解析 便知道了域名 然后根据配置转发即可</p><h1 id="要不要学基础知识"><a href="#要不要学基础知识" class="headerlink" title="要不要学基础知识?"></a>要不要学基础知识?</h1><p>端口 计算机网络 组装nas计网</p><p>网线到内核 操作系统和计算机组成原理</p><h1 id="自学能力"><a href="#自学能力" class="headerlink" title="自学能力"></a>自学能力</h1><p>我大一来的工作室 来的时候是远爷带我学的JavaWeb. </p><p>随便找了本Java书给划一下看哪里</p><p>给我指明了一个框架, 然后呢? 去学呗</p><p>百度-&gt;谷歌中文-&gt;谷歌英文 <a href="https://translate.google.cn/" target="_blank" rel="noopener">https://translate.google.cn/</a></p><p>知乎 百度 谷歌 Github StackOverflow 等等</p><p>遇到问题先百度</p><ul><li>视频?</li><li>看书?</li><li>文档?</li></ul><p>大二转LinuxC++ 全部都是从零开始 没有人带我</p><h1 id="大学生"><a href="#大学生" class="headerlink" title="大学生"></a>大学生</h1><p>垃圾xxxA4 我就是不想学.</p><p>写博客?</p><p>人外有人天外有天</p><p>让自己一天比一天更加优秀 提升自己</p><p>平衡自己时间  爆肝程序<br>社交 我用大二上的社交换到了Linux入门 我退出了xxxx</p><p>大三上减肥(身高), 参加活动, 锻炼身体, 找对象? 规律作息</p><p>穿搭</p><p>多多质疑 乳酸菌饮料?</p><p>不要被轻易带节奏 12:55秒 <a href="https://www.bilibili.com/video/BV1jV411o7VV" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1jV411o7VV</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; title=&quot;框架&quot;&gt;&lt;/a&gt;框架&lt;/h1&gt;&lt;p&gt;后端组使用各种框架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java的Springboot&lt;/li&gt;
&lt;li&gt;Python的Django&lt;/li&gt;
&lt;/u
      
    
    </summary>
    
    
      <category term="分享会" scheme="http://blog.lsmg.xyz/categories/%E5%88%86%E4%BA%AB%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>远程连接宿舍电脑</title>
    <link href="http://blog.lsmg.xyz/2020/10/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%AE%BF%E8%88%8D%E7%94%B5%E8%84%91/"/>
    <id>http://blog.lsmg.xyz/2020/10/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E5%AE%BF%E8%88%8D%E7%94%B5%E8%84%91/</id>
    <published>2020-10-29T08:40:39.000Z</published>
    <updated>2020-10-28T09:16:59.234Z</updated>
    
    <content type="html"><![CDATA[<p>学校机房电脑配置低? 卡慢?</p><p>学习机房电脑没有自己电脑环境用着顺手?</p><p>你还在担心使用机房电脑后需要拷贝代码到U盘或者QQ吗?</p><p><del>机房电脑玩大型游戏?</del></p><p>使用远程连接吧!</p><h1 id="向日葵等"><a href="#向日葵等" class="headerlink" title="向日葵等"></a>向日葵等</h1><p>优点: 不需要公网IP就能使用, 安装使用非常方便<br>缺点: 由于数据交互经过了向日葵的服务器导致延迟较高?</p><h1 id="Win10自带远程连接"><a href="#Win10自带远程连接" class="headerlink" title="Win10自带远程连接"></a>Win10自带远程连接</h1><p>优点: 内网使用延迟极低, 就像直接操作远在其他地方的笔记本一样<br>缺点: 需要内网使用, 配置较为繁琐.</p><p>针对内网这一问题, 学校机房, 学校stuwifi, 宿舍网线都是同一内网(得益于三网通一, 没想到这货还有这样的好处), 所以最大的问题解决了.</p><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>必须确保电脑为专业版  最好是正版专业版盗版可能会有账户配置等问题 自行查阅.</p><p>任务栏左下角Win10图标右击, 打开设置 –&gt; 更新和安全 –&gt; 选择激活  确保显示的为专业版<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E4%B8%93%E4%B8%9A%E7%89%88.png" alt=""></p><p>可惜大部分笔记本都是家庭版, 我这里只推荐一种方法家庭版升级专业版. 其他方法自行百度尝试</p><p>去淘宝购买<strong>家庭版升级专业版Win10密钥</strong>注意不是简单的专业版就行了必须写着<strong>升级</strong>, 详细咨询客服吧</p><p>大概15软妹币左右即可拥有正版Win10专业版, 而且不需要重装系统C盘不会动.</p><p>购买密钥后 在更新和安全的激活那里选择<strong>更改产品密钥</strong> 输入确认即可.</p><h2 id="自己电脑开启远程连接"><a href="#自己电脑开启远程连接" class="headerlink" title="自己电脑开启远程连接"></a>自己电脑开启远程连接</h2><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.png" alt=""></p><p>桌面我的电脑(此电脑) 右击选择属性-&gt;远程设置-&gt;勾选图示三个对勾.</p><h2 id="确认电脑IP"><a href="#确认电脑IP" class="headerlink" title="确认电脑IP"></a>确认电脑IP</h2><p>cmd输入ipconfig记录好自己的IPV4地址和IPV6地址 IPV6不要记录临时地址</p><p>IPV6地址永远不会变,  且<strong>无论电脑是否登录都能使用</strong>, 但是机房电脑没有IPV6</p><p>IPV4地址可能会改变, 需要<strong>10.2.5.251电脑登录后</strong>才能使用 推荐设置静态IPV4地址或者每次使用记录下IPV4</p><h2 id="机房电脑设置"><a href="#机房电脑设置" class="headerlink" title="机房电脑设置"></a>机房电脑设置</h2><p>机房电脑任务栏左下角的Win10图标右侧的搜索(放大镜标志) –&gt; 输入<strong>远程</strong>二字-&gt;选择弹出来的<strong>远程桌面连接</strong>-&gt;输入<strong>IPV4</strong>地址</p><p>确保宿舍电脑联网的情况下 点击连接就提示让你输入账号密码.  账号和密码是你Win10账户的账号和密码. 输入账号密码就连接成功了.</p><h2 id="其他建议选项"><a href="#其他建议选项" class="headerlink" title="其他建议选项"></a>其他建议选项</h2><ol><li>宿舍建议直插网线, 宿舍电脑使用Wifi可能有延迟感觉</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学校机房电脑配置低? 卡慢?&lt;/p&gt;
&lt;p&gt;学习机房电脑没有自己电脑环境用着顺手?&lt;/p&gt;
&lt;p&gt;你还在担心使用机房电脑后需要拷贝代码到U盘或者QQ吗?&lt;/p&gt;
&lt;p&gt;&lt;del&gt;机房电脑玩大型游戏?&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;使用远程连接吧!&lt;/p&gt;
&lt;h1 id=&quot;向日葵
      
    
    </summary>
    
    
      <category term="分享会" scheme="http://blog.lsmg.xyz/categories/%E5%88%86%E4%BA%AB%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>蓝图与C++交互</title>
    <link href="http://blog.lsmg.xyz/2020/10/UE4-%E8%93%9D%E5%9B%BEC++%E4%BA%A4%E4%BA%92/"/>
    <id>http://blog.lsmg.xyz/2020/10/UE4-%E8%93%9D%E5%9B%BEC++%E4%BA%A4%E4%BA%92/</id>
    <published>2020-10-11T12:31:22.000Z</published>
    <updated>2020-10-11T13:55:41.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蓝图Widget与C-代码交互-反射"><a href="#蓝图Widget与C-代码交互-反射" class="headerlink" title="蓝图Widget与C++代码交互-反射"></a>蓝图Widget与C++代码交互-反射</h1><ol><li>创建UserWidget的C++子类 MyUserWidget<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于初始化</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Initialize</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="comment">// 绑定到按钮的点击事件</span></span><br><span class="line">UFUNCTION() <span class="comment">// 必须加不然会导致无反应 日志报错</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ButtonLoginEvent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射获取实例 需要名称保持一致</span></span><br><span class="line">UPROPERTY(Meta = (BindWidget))</span><br><span class="line">UButton* ButtonLogin;</span><br><span class="line">UPROPERTY(Meta = (BindWidget))</span><br><span class="line">UTextBlock* TextBlockUsername; <span class="comment">// 一个文本框</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">UMyUserWidget::Initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Super::Initialize()) <span class="comment">// 会报错提示不存在 无影响</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行点击函数绑定</span></span><br><span class="line">    ButtonLogin-&gt;OnClicked.__Internal_AddDynamic(<span class="keyword">this</span>, &amp;UMyUserWidget::ButtonLoginEvent, FName(<span class="string">"ButtonLoginEvent"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取并显示 文本框文字</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyUserWidget::ButtonLoginEvent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (GEngine)</span><br><span class="line">    &#123;</span><br><span class="line">        FString Username = TextBlockUsername-&gt;GetText().ToString();</span><br><span class="line"></span><br><span class="line">        GEngine-&gt;AddOnScreenDebugMessage(<span class="number">-1</span>, <span class="number">20</span>, FColor::Yellow, Username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>创建需要绑定的蓝图NewWidgetBlueprint</li><li>打开蓝图后点击File-&gt;Reparent Blueprint选择MyUserWidget作为父类</li><li>添加名为ButtonLogin的按钮和TextBlockUsername的文本框 用于反射</li><li>创建HUD的C++子类MyHud</li><li>创建MyHud的蓝图BP_MuHud</li><li>将MyHud的蓝图设置为 GameMode的HUDClass, 这样启动的时候就能创建MuHud蓝图的实例<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从BP_MuHud中选择 NewWidgetBlueprint蓝图</span></span><br><span class="line">UPROPERTY(EditAnywhere, Category = <span class="string">"UserWidget"</span>)</span><br><span class="line">TSubclassOf&lt;<span class="class"><span class="keyword">class</span> <span class="title">UMUserWidget</span>&gt; <span class="title">WidgetClass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动时创建蓝图实例并显示 设置输入方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AMyHUD::BeginPlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Super::BeginPlay();</span><br><span class="line"></span><br><span class="line">    UUserWidget* Widget = CreateWidget&lt;UMyUserWidget&gt;(GetWorld(), WidgetClass);</span><br><span class="line">    <span class="keyword">if</span> (Widget != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Widget-&gt;AddToViewport();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    APlayerController* MyPlayerController = Cast&lt;APlayerController&gt;(UGameplayStatics::GetPlayerController(GetWorld(), <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入只对UI</span></span><br><span class="line">    <span class="keyword">if</span> (MyPlayerController != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MyPlayerController-&gt;bShowMouseCursor = <span class="literal">true</span>;</span><br><span class="line">        FInputModeUIOnly InputMode;</span><br><span class="line">        MyPlayerController-&gt;SetInputMode(InputMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;蓝图Widget与C-代码交互-反射&quot;&gt;&lt;a href=&quot;#蓝图Widget与C-代码交互-反射&quot; class=&quot;headerlink&quot; title=&quot;蓝图Widget与C++代码交互-反射&quot;&gt;&lt;/a&gt;蓝图Widget与C++代码交互-反射&lt;/h1&gt;&lt;ol&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="UE4" scheme="http://blog.lsmg.xyz/categories/UE4/"/>
    
    
      <category term="蓝图与C++交互" scheme="http://blog.lsmg.xyz/tags/%E8%93%9D%E5%9B%BE%E4%B8%8EC-%E4%BA%A4%E4%BA%92/"/>
    
  </entry>
  
  <entry>
    <title>UNP记录</title>
    <link href="http://blog.lsmg.xyz/2020/10/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95150-UNP/"/>
    <id>http://blog.lsmg.xyz/2020/10/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95150-UNP/</id>
    <published>2020-10-06T04:17:39.000Z</published>
    <updated>2020-10-31T07:41:43.077Z</updated>
    
    <content type="html"><![CDATA[<p>由于已经在Linux高性能服务器开发中详细说明过绝大部分系统函数</p><p>Linux高性能服务器开发的重叠部分, 我会将新的点补充到原博客中, 这里仅作部分简单的说明</p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>通过定义<code>包裹函数</code>可以缩短程序. 在muduo框架中就存在包裹函数 将系统函数进行包装</p><p>函数中进行错误处理, 这样外部使用<code>包裹函数</code>包装好的系统函数的时候可以简化错误处理</p><p><strong>daytimecpclient-domain.cpp</strong><br>第一个样例程序稍作修改 可以解析域名  inet_addr没有请求网络 速度快 而gethostbyname会请求域名<br>服务器速度可能慢</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in server_addr&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> ((server_addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>])) == INADDR_NONE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>* <span class="title">hostptr</span> = <span class="title">gethostbyname</span>(<span class="title">argv</span>[1]);</span></span><br><span class="line">    <span class="keyword">if</span> (!hostptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"invalid input %s\n"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    server_addr.sin_addr.s_addr = *((<span class="keyword">unsigned</span> <span class="keyword">long</span>*)hostptr-&gt;h_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代服务器: 对于每个客户连接都执行迭代一次<br>并发服务器: 同时处理多个客户连接</p><h1 id="第二章-传输层"><a href="#第二章-传输层" class="headerlink" title="第二章 传输层"></a>第二章 传输层</h1><p>客户端 主动调用close之后 发送了FIN包</p><p>服务端 接收到FIN包后read返回0</p><p>服务器 read返回0之后调用close函数 发送FIN包</p><p>客户端 接收服务器的FIN包</p><p><strong>@@35 P TCP状态转换图@@</strong></p><p><strong>@@36 P TCP状态转换和Socket函数间的联系@@</strong></p><p>多宿主计算机  可能插有多块网卡</p><p>通过bind到INADDR_ANY来监听多个接口的同一个端口</p><h1 id="第三章-套接字编程简介"><a href="#第三章-套接字编程简介" class="headerlink" title="第三章 套接字编程简介"></a>第三章 套接字编程简介</h1><p>大多数套接字函数 都需要一个指向<code>套接字地址结构</code>的指针作为参数. 每个协议簇都定义了他自己的<code>套接字地址结构</code>. 这些结构的名字均<code>以sockaddr_开头</code></p><p><strong>@@61 P 不同套接字地址结构的比较@@</strong></p><h1 id="第四章-基本TCP套接字编程"><a href="#第四章-基本TCP套接字编程" class="headerlink" title="第四章 基本TCP套接字编程"></a>第四章 基本TCP套接字编程</h1><p><strong>connect函数</strong></p><p>ETIMEDOUT: 客户端没有收到SYN的回应 尝试几次后如果依然没有收到回应则返回错误</p><p>ECONNREFUSED: 服务器在指定端口上没有进程等待与之连接导致收到了RST回复  之后立即返回错误</p><p>connect失败之后 此套接字无法继续使用 需要close当前套接字后重新调用socket</p><p><strong>bind函数</strong></p><p>如果调用listen或者connect前没有调用bind则操作系统会分配一个临时端口. 对于客户端来说可以接受临时端口, 然而服务器一般都是需要指定端口 供外接连接. </p><p>如果指定的端口为0 则认为没有指定端口 会分配临时端口. 如果地址指定为0(INADDR_ANY) 则系统选择IP地址</p><p>RPC服务器可以使用临时端口, 但必须将临时端口注册到端口映射器, 这样客户端才能得到对应的临时端口, 之后进行连接</p><p>可以使用getsockname获取到系统临时分配的地址和端口</p><p><strong>listen函数</strong></p><p>socket函数创建的套接字默认被认为是主动套接字(准备调用connect) 使用listen函数将一个<code>未连接</code>的套接字转换成一个被动套接字</p><p>内核为一个监听的系统套接字维护两个队列</p><ul><li>未完成队列 已经收到了SYN但还未完成三次握手</li><li>已完成队列 已经进行了三次握手<code>等待accept从队列中取走</code> 已建立的连接 如果<code>此队列为空, accept阻塞</code></li></ul><p>未完成队列+已完成队列的总长度 即为listen函数的第二个参数backlog</p><p>connect函数调用 -&gt; 服务器收到了SYN包 -&gt; 在未完成队列创建相关内容 -&gt; 创建完毕后返回SYN和ACK -&gt; 客户端返回ACK -&gt; 从未完成队列移动到已完成队列队尾</p><p><a href="https://blog.csdn.net/yangbodong22011/article/details/60399728" target="_blank" rel="noopener">https://blog.csdn.net/yangbodong22011/article/details/60399728</a></p><p>实际用Centos(内核为4.18版本)测试后, 实际情况为上方博客的情况. 即backlog是已完成队列大小, 而且会存在+1</p><p>看到这里后想到之前遇到的一个BUG, 注册入<code>epollfd</code>中的<code>listenfd</code>没有设置成<code>ENONBLOCK</code>, <code>epoll_wait不会返回, 进而去调用accept</code>, 然而客户端<code>connect</code>函数返回显示已经建立连接.  –也就是connect返回说明连接建立, 发生在accpet函数调用前.</p><p>当客户端发送FIN后服务器read类函数返回0</p><p><strong>@@91 P exec函数之间的关系@@</strong></p><p><strong>accept函数</strong><br>accpet函数的第一个参数必须是 被动套接字 即调用过listen, 否则返回EINVAL错误</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p>正常启动 正常终止时程序的表现与TCP协议的关系</p><p>慢系统调用: 适用于那些可能永远阻塞的系统调用, accpet(没有新连接就一直阻塞), read(读取不到一直阻塞)等等.</p><p>EINTR: 当阻塞于某个慢系统调用的进程, 捕获某个信号且相应信号处理函数返回时, 慢系统调用<code>可能</code>返回一个EINTR错误</p><p>诸如read, write, select等来说可以忽略EINTR, 如下方这个常见的代码片段. <strong>但是connect则不行, 否则立即返回错误??</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> result = <span class="built_in">read</span>(fd, <span class="built_in">buffer</span>, <span class="keyword">sizeof</span> <span class="built_in">buffer</span>);</span><br><span class="line"><span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同时有N个SIGCHLD信号到达, 信号处理函数极可能执行不够N次.</p><ul><li>UNIX信号没有排队概念</li><li>问题导致的结果不确定, 即不确定调用多少次</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigchld_handler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pid_t</span> pid;</span><br><span class="line">  <span class="keyword">int</span> stat;</span><br><span class="line">  <span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">process</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用waitpid来获取所有已终止进程状态, 并且指定了<code>WNOHANG</code>防止不必要的阻塞.</p><p>而wait则不能在这里替换waitpid, 因为wait只能阻塞</p><p><strong>第五章 正常启动 正常终止 accept返回前终止 服务器进程终止 服务主机崩溃 主机崩溃后重启 主机关机</strong></p><h1 id="第六章-I-O-复用-select和poll函数"><a href="#第六章-I-O-复用-select和poll函数" class="headerlink" title="第六章 I/O 复用 select和poll函数"></a>第六章 I/O 复用 select和poll函数</h1><p>进程需要一种预先告知内核的能力, 使得内核一旦发现进程指定的一个或多个I/O条件就绪, 他就通知进程. –IO复用</p><p>UNIX可用的五种IO模型</p><ul><li>阻塞式I/O</li><li>非阻塞式I/O</li><li>I/O复用</li><li>信号驱动式I/O(SIGIO)</li><li>异步I/O(POSIX的aio_系列函数)</li></ul><p>前四种都是同步IO, 因为他们在真正的IO阶段read,readfrom等导致了阻塞<br>只有异步IO模型才是异步IO</p><p><strong>@@低水位标记 ?@@</strong></p><h2 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h2><p>尽管timeval允许指定一个微秒级的分辨率, 但是真实的分辨率吗…… 部分实现的粗糙一些. 并且还有<code>调度延迟(定时器结束后, 内核还需要花时间调度相应进程运行)</code></p><p>struct fd_set 一个集合,可以存储多个文件描述符<br>内部是一个32位整数的数组, 数组第一个元素对应0<del>31描述符 一个二进制位代表一个描述符<br>数组第二个元素对应32</del>63 以此类推</p><p>可读条件</p><ul><li>socket内核接收缓存区中的字节数大于或等于 其低水位标记</li><li>socket通信的对方关闭连接 读半连接关闭, 对socket的读操作返回0</li><li>监听socket上有新的连接请求</li><li>socket上有未处理的错误, 可以使用getsockopt的SO_ERROR来读取和清除错误 套接字的读操作不阻塞 并返回-1</li></ul><p>可写条件</p><ul><li>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记, <strong>且套接字已经连接, 或套接字不需要连接UDP</strong></li><li>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</li><li>socket使用非阻塞connect 连接成功或失败后</li><li>socket上有未处理的错误 套接字的写操作不阻塞 并返回-1</li></ul><p>异常条件</p><ul><li>发送带外数据</li></ul><p>当select返回可读事件后 如果不进行处理 则下次select调用会继续返回</p><h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><ol><li>close会将引用计数-1 等到为0时才关闭套接字. shutdown则可以无视此, 激发TCP的正常连接终止序列</li><li>close会终止读和写两个方向的数据传送, 但由于TCP全双工有时需要告知对方我方发送已经完毕</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于已经在Linux高性能服务器开发中详细说明过绝大部分系统函数&lt;/p&gt;
&lt;p&gt;Linux高性能服务器开发的重叠部分, 我会将新的点补充到原博客中, 这里仅作部分简单的说明&lt;/p&gt;
&lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>深度探索C++对象模型</title>
    <link href="http://blog.lsmg.xyz/2020/09/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95130-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/"/>
    <id>http://blog.lsmg.xyz/2020/09/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95130-%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-09-15T07:17:39.000Z</published>
    <updated>2020-10-27T15:59:19.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-关于对象"><a href="#第一章-关于对象" class="headerlink" title="第一章 关于对象"></a>第一章 关于对象</h1><p>加上封装之后的成本增加了吗?</p><p>并没有增加成本, C++在布局以及存取时间上主要的额外负担是由virtual引起的</p><ul><li>virtual func机制 用来支持一个有效率的执行期绑定</li><li>virtual base class 用来实现多次出现在继承体系中的base class, 有一个单一而被共享的实例</li></ul><p>C++ 有两种成员变量<code>static</code>和<code>nonstatic</code><br>三种成员函数<code>static</code>, <code>nonstatic</code>和<code>virtual</code></p><h1 id="第三章Data语义学"><a href="#第三章Data语义学" class="headerlink" title="第三章Data语义学"></a>第三章Data语义学</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo foo;</span><br></pre></td></tr></table></figure><p><code>sizeof foo = ?</code>答案是1， 这是为了防止不同的对象却有相同的地址</p><p>同时class也存在<code>字节对齐</code>现象</p><p>在针对虚拟继承问题的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D对象的内存结构  从低地址开始</span><br><span class="line"></span><br><span class="line">D对象数据部分  《- D类对象指针 dptr 指向这里 可以从vptr指向的表中获取A对象数据部分的偏移量 offset</span><br><span class="line">C对象数据部分</span><br><span class="line">B对象数据部分</span><br><span class="line">A对象数据部分  《- dptr + offset 则实现了 子类指针向父类指针的转化</span><br></pre></td></tr></table></figure><p>A 派生出 B C。 B C派生出D  如何保证在BC对象中都有A对象， 而在D对象中只有一个A对象？</p><p>一种方法是 </p><p>先安排派生类的部分 再后接基类的部分， 这样派生类D的对象指针就是指向自己数据部分的指针</p><p>如果想要实现子类向父类转换呢？</p><p>在vtpr指向的表中的 -1 位置放置偏移量， 由于D类对象的指针是内存开始位置 如果要转换成A类指针</p><p>则从D类对象的vptr指向的表中获取A类数据部分的偏移量 这样就实现了子类向父类转换</p><h1 id="第四章-Function语义学"><a href="#第四章-Function语义学" class="headerlink" title="第四章 Function语义学"></a>第四章 Function语义学</h1><p>name mangling</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-关于对象&quot;&gt;&lt;a href=&quot;#第一章-关于对象&quot; class=&quot;headerlink&quot; title=&quot;第一章 关于对象&quot;&gt;&lt;/a&gt;第一章 关于对象&lt;/h1&gt;&lt;p&gt;加上封装之后的成本增加了吗?&lt;/p&gt;
&lt;p&gt;并没有增加成本, C++在布局以及存取时间上主要
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>CPP入门分享</title>
    <link href="http://blog.lsmg.xyz/2020/09/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-%E6%8A%93%E5%8F%96%E6%8E%A5%E5%8F%A3/"/>
    <id>http://blog.lsmg.xyz/2020/09/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-%E6%8A%93%E5%8F%96%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-09-09T02:40:39.000Z</published>
    <updated>2020-10-28T08:55:57.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>Fiddler 截获HTTP请求包<br>Postman 测试接口与生成代码<br>Chrome+SwitchyOmega插件</p><p>安装见视频</p><h1 id="配置Fiddler"><a href="#配置Fiddler" class="headerlink" title="配置Fiddler"></a>配置Fiddler</h1><p>Tools-&gt;Options-&gt;HTTPS 勾选Decrypt HTTPS traffic 确认安装证书</p><p>Tools-&gt;Options-&gt;Connections 勾选Allow remote computer xxxx</p><p>记下 Connections中的端口号 默认为8888</p><h1 id="配置SwitchyOmega插件"><a href="#配置SwitchyOmega插件" class="headerlink" title="配置SwitchyOmega插件"></a>配置SwitchyOmega插件</h1><p>新增情景模式-&gt;选择代理服务器</p><p>代理协议HTTP 代理服务器 127.0.0.1 端口 8888</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;工具&quot;&gt;&lt;a href=&quot;#工具&quot; class=&quot;headerlink&quot; title=&quot;工具&quot;&gt;&lt;/a&gt;工具&lt;/h1&gt;&lt;p&gt;Fiddler 截获HTTP请求包&lt;br&gt;Postman 测试接口与生成代码&lt;br&gt;Chrome+SwitchyOmega插件&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="分享会" scheme="http://blog.lsmg.xyz/categories/%E5%88%86%E4%BA%AB%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>CPP入门分享</title>
    <link href="http://blog.lsmg.xyz/2020/08/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-cpp%E5%85%A5%E9%97%A8/"/>
    <id>http://blog.lsmg.xyz/2020/08/%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A-cpp%E5%85%A5%E9%97%A8/</id>
    <published>2020-08-28T02:40:39.000Z</published>
    <updated>2020-10-28T08:55:57.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h1><h2 id="为什么选择的是CPP"><a href="#为什么选择的是CPP" class="headerlink" title="为什么选择的是CPP"></a>为什么选择的是CPP</h2><p>学校开设</p><ul><li>Python</li><li>CPP</li><li>xxx</li></ul><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>课堂讲的肯定比我讲的要好 不过我打算侧重在更加详细的讲某些基础内容 然后主要的是每周的答疑maybe</p><h2 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h2><p>每周五六日中一天 以计算机专业的CPP课本进度 提前讲一部分下周的内容</p><p>下一周你遇到的问题的问题私聊我 下周五六日中一天直播的时候讲解</p><h2 id="独立解决问题的能力"><a href="#独立解决问题的能力" class="headerlink" title="独立解决问题的能力"></a>独立解决问题的能力</h2><p>善用搜索引擎<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%B4%A0%E8%B4%A8%E4%BA%94%E8%BF%9E.jpg" alt=""></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E7%99%BE%E5%BA%A6Or%E9%97%AE%E4%BA%BA.jpg" alt=""></p><p>当然也不是 所有都要自己找 不去问别人</p><p>当你一个问题考虑很久的时候 xxx</p><h2 id="编程难在哪里"><a href="#编程难在哪里" class="headerlink" title="编程难在哪里?"></a>编程难在哪里?</h2><p>什么是关键字?</p><p><a href="https://www.runoob.com/w3cnote/cpp-keyword-intro.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/cpp-keyword-intro.html</a></p><p><img src="https://www.runoob.com/wp-content/uploads/2018/06/20130806104900234.jpg" alt="C++关键字"></p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>if</td><td>else</td><td>while</td><td>for</td><td>switch</td><td>case</td></tr><tr><td>break</td><td>continue</td><td>return</td><td></td><td></td><td></td></tr><tr><td>int</td><td>short</td><td>char</td><td>double</td><td>long</td><td>float</td></tr><tr><td>const</td><td>static</td><td></td><td></td><td></td><td></td></tr><tr><td>delete</td><td>new</td><td></td><td></td><td></td><td></td></tr><tr><td>enum</td><td>struct</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>思想</p><p>有限的关键字 “无穷” 的组合</p><h2 id="分享-gt-私人QQ群"><a href="#分享-gt-私人QQ群" class="headerlink" title="分享-&gt;私人QQ群"></a>分享-&gt;私人QQ群</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一次&quot;&gt;&lt;a href=&quot;#第一次&quot; class=&quot;headerlink&quot; title=&quot;第一次&quot;&gt;&lt;/a&gt;第一次&lt;/h1&gt;&lt;h2 id=&quot;为什么选择的是CPP&quot;&gt;&lt;a href=&quot;#为什么选择的是CPP&quot; class=&quot;headerlink&quot; title=&quot;为
      
    
    </summary>
    
    
      <category term="分享会" scheme="http://blog.lsmg.xyz/categories/%E5%88%86%E4%BA%AB%E4%BC%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>EPOLLET丢失新连接事件</title>
    <link href="http://blog.lsmg.xyz/2020/08/%E9%87%87%E5%9D%91%E8%AE%B0-EPOLLET%E4%B8%A2%E5%A4%B1%E6%96%B0%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6/"/>
    <id>http://blog.lsmg.xyz/2020/08/%E9%87%87%E5%9D%91%E8%AE%B0-EPOLLET%E4%B8%A2%E5%A4%B1%E6%96%B0%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6/</id>
    <published>2020-08-03T15:03:08.000Z</published>
    <updated>2020-08-03T15:55:56.702Z</updated>
    
    <content type="html"><![CDATA[<p>谨以此文献给我, 两次踩坑.</p><p>第一次是根据muduo写我的mongo</p><p>第二次则是后来我又根据muduo写higan. <del>框架名字不是重点</del></p><h1 id="症状描述"><a href="#症状描述" class="headerlink" title="症状描述"></a>症状描述</h1><ol><li>最首先的症状就是使用ab压测的时候, 压测会在快结束的时候卡住 而且压测过程中也会出现卡顿<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\XXX&gt; ab -n 1000 -c 94 -k  http:&#x2F;&#x2F;10.4.160.96:1022&#x2F;hello</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 1874286 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http:&#x2F;&#x2F;www.zeustech.net&#x2F;</span><br><span class="line">Licensed to The Apache Software Foundation, http:&#x2F;&#x2F;www.apache.org&#x2F;</span><br><span class="line"></span><br><span class="line">Benchmarking 10.4.160.96 (be patient)</span><br><span class="line">Completed 100 requests</span><br><span class="line">Completed 200 requests</span><br><span class="line">Completed 300 requests</span><br><span class="line">Completed 400 requests</span><br><span class="line">Completed 500 requests</span><br><span class="line">Completed 600 requests</span><br><span class="line">Completed 700 requests</span><br><span class="line">Completed 800 requests</span><br><span class="line">Completed 900 requests</span><br><span class="line">apr_pollset_poll: The timeout specified has expired (70007)</span><br><span class="line">Total of 996 requests completed</span><br></pre></td></tr></table></figure></li><li>这时候已经建立的连接不受影响 却无法建立新的连接 debug的时候发现会出现建立已经关闭的连接</li><li>上面的问题发生与不发生 跟我是否开多线程有关, 如果我不建立额外的EventLoopThread就不会出现这个问题</li></ol><h1 id="第一波排查-线程之间互相影响"><a href="#第一波排查-线程之间互相影响" class="headerlink" title="第一波排查 线程之间互相影响"></a>第一波排查 线程之间互相影响</h1><p>因为问题出现与否 与我是否设置多线程有关, 我就开始排查线程之间的影响.<br>重点放在了muduo的RunInLoop函数. 因为这个函数我一直不是明白怎么回事.<br>最终根据muduo的设计思想 一个EventLoop对应一个Thread.<br>结合RunInLoop就可以达到谁的事件谁处理的效果</p><p>举个例子, 连接中断后, 子线程返回相应的事件 要去调用TcpServer的RemoveConnection将自己移除, 如果不使用RunInLoop<br>当有多个子线程 同时触发同样的事件 同时去对map进行删除操作 必然需要加锁. 况且连接连接的时候也要对map进行插入操作.<br>使用RunInLoop判断后得知是子线程在调用RunInLoop而非对应的线程, 就将任务存储到了相关的EventLoop中. 而EventLoop中存储的任务只有其所属的Thread才能处理.<br>所以实现了统一所有子线程的移除连接操作到了主线程中, 而连接的建立也是主线程操作, 最终避免了加锁.</p><p>然后那个swap命令处理任务度列减少加锁的时间也很赞</p><p>最终我加上了几处重要的RunInLoop, 不过并没有解决问题………….</p><h1 id="第二波排查-到底返回了多少事件"><a href="#第二波排查-到底返回了多少事件" class="headerlink" title="第二波排查 到底返回了多少事件?"></a>第二波排查 到底返回了多少事件?</h1><p>我在Acceptor等多个可读事件回调的位置加了计数器, 这时候最先发现的就是连接建立数量不对.</p><p>上边996个完成请求缺了4个, 并且正好连接建立了90个连接, 而非设置的并发94, 也是少了4个.</p><p>我先怀疑是否是ab压测的处理, 我试了下muduo多线程下94个连接 higan单线程94连接,多线程90连接, 排除了ab的问题</p><p>少的链接去了哪里? 我使用netstat命令发现 正好是四个CLOSE_WAIT 我去看了下ab的包正好是114字节 说明了少的四个链接的位置<br>而且这四个端口号正好是从本该是第91个连接的端口号开始的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@fish ~]# netstat -an | grep 1022</span><br><span class="line">tcp        4      0 0.0.0.0:1022            0.0.0.0:*               LISTEN     </span><br><span class="line">tcp      114      0 10.4.160.96:1022        10.4.160.95:8785        CLOSE_WAIT </span><br><span class="line">tcp      114      0 10.4.160.96:1022        10.4.160.95:8787        CLOSE_WAIT </span><br><span class="line">tcp      114      0 10.4.160.96:1022        10.4.160.95:8786        CLOSE_WAIT </span><br><span class="line">tcp      114      0 10.4.160.96:1022        10.4.160.95:8784        CLOSE_WAIT</span><br></pre></td></tr></table></figure><p>其实netstat不对劲早就发现了, 然而并不理解netstat命令 没有重视问题.</p><p>使用Man命令察看了 第二列是Recv-Q 对于CLOSE_WAIT来说是未接收的字节数 对于LISTEN则是未接收的连接数</p><h1 id="第三波排查-为什么这四个连接没有被接受"><a href="#第三波排查-为什么这四个连接没有被接受" class="headerlink" title="第三波排查 为什么这四个连接没有被接受"></a>第三波排查 为什么这四个连接没有被接受</h1><p>首先我发现了我这行代码写的有问题, 而我的epoll_events_是一个vector 后面的代码有扩容逻辑 难道是因为max_event太小导致的ET模式漏掉事件?<br>并不是, 未被返回的事件是不会被忽略的 只有你从内核中将事件接收出来, 下次才不会提醒</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码为 int event_num = epoll_wait(epollfd_, &amp;*epoll_events_.begin(), 一个常数, timeout);</span></span><br><span class="line"><span class="comment">// 修改后为 int event_num = epoll_wait(epollfd_, &amp;*epoll_events_.begin(), static_cast&lt;int&gt;(epoll_events_.size()), timeout);</span></span><br></pre></td></tr></table></figure><p>只能继续排查了, 因为知道了Recv-Q的存在 直接搜索几个关键字 找到了这个网页</p><p><a href="https://www.cnblogs.com/cxt-janson/p/9273440.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxt-janson/p/9273440.html</a></p><p>最后我尝试将EPOLLET模式改为EPOLLLT正常了!!!!!!</p><h1 id="仍存在的问题"><a href="#仍存在的问题" class="headerlink" title="仍存在的问题"></a>仍存在的问题</h1><p>为什么只有我在启用多线程的时候才会发生丢失连接的现象? 这个问题目前还没找到.</p><h1 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h1><p>我最先排查的重点是线程之间的影响, 我对于muduo的多线程处理机制还是不熟悉, 自以为是了某些地方. </p><p>连接建立的数量不对的时候虽然发现了Recv-Q以及CLOSE_WAIT 但由于对Tcp连接状态的理解以及netstat命令的不熟悉, 导致走了弯路.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;谨以此文献给我, 两次踩坑.&lt;/p&gt;
&lt;p&gt;第一次是根据muduo写我的mongo&lt;/p&gt;
&lt;p&gt;第二次则是后来我又根据muduo写higan. &lt;del&gt;框架名字不是重点&lt;/del&gt;&lt;/p&gt;
&lt;h1 id=&quot;症状描述&quot;&gt;&lt;a href=&quot;#症状描述&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="采坑记" scheme="http://blog.lsmg.xyz/categories/%E9%87%87%E5%9D%91%E8%AE%B0/"/>
    
    
      <category term="采坑记" scheme="http://blog.lsmg.xyz/tags/%E9%87%87%E5%9D%91%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>网络配置</title>
    <link href="http://blog.lsmg.xyz/2020/07/Linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.lsmg.xyz/2020/07/Linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</id>
    <published>2020-07-18T09:39:20.000Z</published>
    <updated>2020-07-18T09:50:25.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务器双网卡配置"><a href="#服务器双网卡配置" class="headerlink" title="服务器双网卡配置"></a>服务器双网卡配置</h1><p>内网访问外网</p><p>外网接在了校园网上, 不过我的路由器不支持Ipv6, 有没有多余的lan口 只能接在服务器的lan口上</p><p>需要设置内网网卡开机启动 固定的Ip地址10.5.1.2 以及子网掩码255.255.255.0<br>然后路由器设置固定Ip地址10.5.1.3 子网掩码255.255.255.0 与内网网卡同网段</p><p>然后使用<code>firewall-cmd --add-masquerade --permanent</code></p><p>Masquerading is useful if the machine is a router and machines connected over an interface in another zone should be able to use the first connection.<br>通过另一个区域(zone)的接口 使用默认zone的接口上网</p><p><a href="https://www.server-world.info/en/note?os=CentOS_7&amp;p=firewalld&amp;f=2" target="_blank" rel="noopener">https://www.server-world.info/en/note?os=CentOS_7&amp;p=firewalld&amp;f=2</a><br>配置完才发现的神网址…. 好吧 写得非常清楚</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;服务器双网卡配置&quot;&gt;&lt;a href=&quot;#服务器双网卡配置&quot; class=&quot;headerlink&quot; title=&quot;服务器双网卡配置&quot;&gt;&lt;/a&gt;服务器双网卡配置&lt;/h1&gt;&lt;p&gt;内网访问外网&lt;/p&gt;
&lt;p&gt;外网接在了校园网上, 不过我的路由器不支持Ipv6, 有没有多余
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="网络配置" scheme="http://blog.lsmg.xyz/tags/%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>算法四</title>
    <link href="http://blog.lsmg.xyz/2020/07/%E7%AE%97%E6%B3%9592-%E7%AE%97%E6%B3%95%E5%9B%9B/"/>
    <id>http://blog.lsmg.xyz/2020/07/%E7%AE%97%E6%B3%9592-%E7%AE%97%E6%B3%95%E5%9B%9B/</id>
    <published>2020-07-17T07:51:28.000Z</published>
    <updated>2020-11-04T14:30:35.474Z</updated>
    
    <content type="html"><![CDATA[<p>来之不易的暑期留校, 一半献给算法.</p><h1 id="第二章-排序"><a href="#第二章-排序" class="headerlink" title="第二章 排序"></a>第二章 排序</h1><p>选择排序</p><ul><li>运行时间和输入的数据无关, 仅和数量有关.<br>不会利用输入的初始状态</li><li>数据移动是最少的<br>我们将研究的其他任何算法 都不具备这个特性…..</li></ul><p>插入排序</p><ul><li>适合小规模数组</li><li>对于部分有序的数组, 处理起来很有效</li><li>倒置的数量很少时, 插入排序很可能比其他算法还要快</li></ul><p>希尔排序</p><ul><li>插入排序对于大规模乱序数组很慢, 因为它只会交换相邻元素, 因此为了改进插入排序的局部性,提出了希尔排序</li><li>希尔排序交换不相邻的元素以对数组的局部性进行排序, 最终用插入排序调整局部有序的数组</li></ul><p>归并排序</p><ul><li>原地归并排序</li><li>自顶向下 递归实现 分治思想</li><li>自底向上 从归并微型数组到整体归并</li></ul><p>快速排序</p><ul><li>分治排序算法</li></ul><p>堆排序</p><ul><li>只能说妙啊.. 这本书先讲的优先队列如何实现, 然后紧接着就用sink方法完成了堆排序</li></ul><p><strong>稳定性</strong></p><p>某地在某时下雨 时间和地点存在对应关系.<br>按照时间排序后, 再按照地点排序 单个地点的时间排序就很可能被打乱</p><p>稳定, 则时间排序没有被打乱. 不稳定, 很可能时间排序被打乱</p><table><thead><tr><th>算法</th><th>是否稳定</th><th>是否为原地排序</th><th>时间复杂度</th><th>空间复杂度</th><th>备注</th></tr></thead><tbody><tr><td>选择排序</td><td>否</td><td>是</td><td>N^2</td><td>1</td><td>最简单粗暴的方式, 交换次数最少</td></tr><tr><td>插入排序</td><td>是</td><td>是</td><td>介于N与N^2</td><td>1</td><td>很大程度取决输入元素的排列情况, 如果倒置元素很少则性能可能超过快排</td></tr><tr><td>希尔排序</td><td>否</td><td>是</td><td></td><td>1</td><td>插入排序的改良版, 改善了插入排序过于局限</td></tr><tr><td>快速排序</td><td>否</td><td>是</td><td>NlogN</td><td>lgN</td><td>分治, 运行效率由概率保证</td></tr><tr><td>归并排序</td><td>是</td><td>否</td><td>NlogN</td><td>N</td><td>自顶向下(递归 分治)和自底向上(从局部到整体) 两种方法</td></tr><tr><td>堆排序</td><td>否</td><td>是</td><td>NlogN</td><td>1</td><td>学完后突然想到了如果在很多的数字中找到最大的多少个数这种问题</td></tr></tbody></table><p><strong>2.4 优先队列</strong></p><p>需要支持两种操作, 删除最大元素和插入元素  - 优先级队列</p><ol><li>数组实现(无序) - 插入快 删除慢</li></ol><p>Insert方法 直接将元素插入尾部, 类似栈的push方法</p><p>DelMax方法 使用一个内部循环找出最大的元素和边界元素交换 然后删除边界元素, 删除的时候类似pop方法</p><ol start="2"><li>数组实现(有序) - 插入慢 删除快</li></ol><p>Insert方法 中进行排序, 插入新的元素的时候将较大元素向右移动一格位置, 然后插入新的元素</p><p>DelMax方法 直接删除右侧元素, 类似栈的pop方法</p><ol start="3"><li>链表表示法</li></ol><p>无序序列是解决问题的惰性方法, 仅在必要的时候才会采取行动 找出最大元素</p><p>有序序列是解决问题的积极方法, 尽可能的未雨绸缪, 使得找出最大元素高效</p><ol start="4"><li><code>二叉堆</code>表示法 - 插入和删除都为线性对数级别</li></ol><p>Insert方法 将新元素添加到数组末端, 增加了堆的大小 将新元素<code>上浮</code>到合适的位置</p><p>DelMax方法 删除顶部元素 将数组的最后一个元素放到顶部 将其<code>下沉</code>到合适的位置 减小了堆的大小 将</p><p><strong>堆</strong></p><p>二叉堆: 每个元素都要保证小于等于(大于等于)另外两个特定位置的元素. 其根节点是最小(最大)元素</p><ol><li>二叉堆的指针表示法</li></ol><p>需要使用三个指针, 指向父节点和两个子节点</p><ol start="2"><li>使用数组</li></ol><p>完全二叉树可以使用数组表示 不使用数组的0位置元素 从1开始 k的子节点分别在2k和2k+1</p><p><strong>堆的有序化</strong></p><p>以最大堆为例</p><ol><li>由下至上的堆有序化 <code>上浮</code></li></ol><p>堆的有序状态因为 某个节点比他的父节点更大 被打破.</p><p>需要与父节点交换, 不断向上直到遇到一个更大的父节点 或者到了顶部</p><ol start="2"><li>由上至下的堆有序化 <code>下浮</code></li></ol><p>堆的有序状态因为 某个父节点比 他的两个子节点或其中之一子节点 小 被打破.</p><p>将父节点与子节点中较大的一个进行交换直到它的子节点都比它小 获得到了底部</p><h1 id="第三章-查找"><a href="#第三章-查找" class="headerlink" title="第三章 查找"></a>第三章 查找</h1><p>符号表: 最主要的目的是是将<code>one key</code>和<code>one value</code>联系起来, 是一种存储键值对的数据结构, 支持插入和查找</p><table><thead><tr><th>使用的数据结构</th><th>实现</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>链表(顺序查找)</td><td>SequentialSearchST</td><td>适用于小型问题</td><td>对于大型表很慢</td></tr><tr><td>有序数组(二分)</td><td>BinarySearchST</td><td>最优的查找和空间需求, 能够进行有序性相关的操作</td><td>插入操作很慢</td></tr><tr><td>二叉查找树</td><td>BST</td><td>实现简单, 能够进行有序性相关的操作</td><td>没有性能上界的保证, 链接需要额外的空间</td></tr><tr><td>平衡二叉树</td><td>RedBlackBST</td><td>最优的查找和插入效率, 能够进行有序性相关的操作</td><td>链接需要额外的空间</td></tr><tr><td>散列表</td><td>SeparateChainHashST LinearProbingHashST</td><td>能够快速的查找和插入常见的数据类型</td><td>需要计算散列, 无法进行有序性相关操作, 链接和空节点需要额外的空间</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来之不易的暑期留校, 一半献给算法.&lt;/p&gt;
&lt;h1 id=&quot;第二章-排序&quot;&gt;&lt;a href=&quot;#第二章-排序&quot; class=&quot;headerlink&quot; title=&quot;第二章 排序&quot;&gt;&lt;/a&gt;第二章 排序&lt;/h1&gt;&lt;p&gt;选择排序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行时间和输入的数据
      
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>VIM(spf-13)使用</title>
    <link href="http://blog.lsmg.xyz/2020/07/Linux-VIM%E6%8A%98%E8%85%BEspf13/"/>
    <id>http://blog.lsmg.xyz/2020/07/Linux-VIM%E6%8A%98%E8%85%BEspf13/</id>
    <published>2020-07-05T12:31:22.000Z</published>
    <updated>2020-10-27T01:04:01.740Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html" target="_blank" rel="noopener">https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html</a> vim分屏</p><h1 id="乱码解决"><a href="#乱码解决" class="headerlink" title="乱码解决"></a>乱码解决</h1><p>中文乱码</p><p>修改locale.conf确实解决了 但我想要的是阿里云那种显示英文中文却不是乱码</p><p>最终<code>vim /etc/vconsole.conf</code>将cn改为us就解决了….</p><p>中间也尝试安装语言包, 记得是已经安装 最终是修改上面那个之后就好了</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">R           进入替换模式</span><br><span class="line"></span><br><span class="line">e           光标后移一个单词 连续的符号也算一个单词 &lt;&lt;</span><br><span class="line">E           光标后移一个单词 无视符号</span><br><span class="line"></span><br><span class="line">b           光标前移一个单词 连续的符号也算一个单词 &lt;&lt;</span><br><span class="line">B           光标前移一个单词 无视符号</span><br><span class="line"></span><br><span class="line">yy或Y       复制整行          </span><br><span class="line">p           光标之后粘贴</span><br><span class="line">P大写           光标之前粘贴</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2020年7月30日10:14:18</span></span><br><span class="line">ctrl+r      重做撤销内容</span><br><span class="line">u           撤销</span><br><span class="line"></span><br><span class="line">^           本行第一个非空格字符</span><br><span class="line"><span class="meta">$</span><span class="bash">           本行最后一个非空格字符</span></span><br><span class="line">G           文件尾</span><br><span class="line">gg          文件头</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2020年10月27日08:51:36</span></span><br><span class="line">V选中行后</span><br><span class="line">SHIFT + . 缩进</span><br><span class="line">SHIFT + , 取消缩进</span><br><span class="line"></span><br><span class="line">:1,10&gt; 1~10行缩进</span><br><span class="line">:1,10&lt; 1~10行取消缩进</span><br></pre></td></tr></table></figure><h1 id="注释-NERDCommenter"><a href="#注释-NERDCommenter" class="headerlink" title="注释 NERDCommenter"></a>注释 NERDCommenter</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">,c&lt;space&gt;   当前行注释和切换注释</span><br><span class="line"></span><br><span class="line">,cs         块注释当前选中或当前行</span><br><span class="line">v           小写v进入多字符选择模式</span><br><span class="line">V           大写V进入多行选择</span><br></pre></td></tr></table></figure><h1 id="文件导航工具-NERDTree"><a href="#文件导航工具-NERDTree" class="headerlink" title="文件导航工具 NERDTree"></a>文件导航工具 NERDTree</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">ctrl + e    打开文件导航</span><br><span class="line">o           打开文件, 目录, 标签</span><br><span class="line">go          打开文件, 目录, 标签, 但光标仍位于导航栏</span><br><span class="line"></span><br><span class="line">R           刷新根目录下所有文件</span><br><span class="line">r           刷新当前目录下文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2020年7月30日16:22:01</span></span><br><span class="line">--------------------------------------</span><br><span class="line">t           在新tab中打开选中节点书签</span><br><span class="line">T           同上 但焦点仍在当前tab</span><br><span class="line"></span><br><span class="line">gt, gT      在tab之间切换</span><br><span class="line"></span><br><span class="line">:tabc       关闭当前tab</span><br><span class="line">:tabo       关闭其他tab</span><br><span class="line">:tabs       查看所有打开的tab</span><br><span class="line">-----------------------------------------</span><br><span class="line">i           在新的split中打开选择文件 两个部分水平切割</span><br><span class="line">gi          同上 焦点仍位于导航栏</span><br><span class="line">s           在新的split中打开选择文件 垂直切割</span><br><span class="line">gs          同上 焦点仍位于导航栏</span><br><span class="line"></span><br><span class="line">ctrl+w w    顺序切换, 两个窗口的时候非常方便</span><br><span class="line">ctrl+w hjkl 对应左 下 上 有</span><br><span class="line"></span><br><span class="line">ctrl+w c    关闭当前split</span><br><span class="line">ctrl+w o    关闭其他split</span><br><span class="line">-----------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tab         补全菜单向下移动</span><br><span class="line">space       补全为当前单词 附带一个空格</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/fl
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="spf-13" scheme="http://blog.lsmg.xyz/tags/spf-13/"/>
    
  </entry>
  
  <entry>
    <title>大二暑假学习规划与记录</title>
    <link href="http://blog.lsmg.xyz/2020/07/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87/"/>
    <id>http://blog.lsmg.xyz/2020/07/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%A4%A7%E4%BA%8C%E6%9A%91%E5%81%87/</id>
    <published>2020-07-04T14:08:32.000Z</published>
    <updated>2020-07-30T02:12:14.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h1><p><strong>2020年7月4日22:09:19</strong><br>C++Primer从头到尾看一遍 做习题.  16章+3章.<br>两天一章, 力求看透, 看足.  整理笔记.</p><p><strong>2020年7月4日22:11:54</strong><br>微信公众号运营, 整理自己发过的博客.</p><p><strong>2020年7月4日22:11:59</strong><br>算法学习, 较快的看完数据结构与算法. 奈何大一下没有好好学.  欠的总归要还<br><a href="https://next.xuetangx.com/learn/THU08091000384/THU08091000384/1516243/article/1387079" target="_blank" rel="noopener">https://next.xuetangx.com/learn/THU08091000384/THU08091000384/1516243/article/1387079</a></p><p><a href="https://next.xuetangx.com/learn/THU08091002048/THU08091002048/1515966/article/1373713" target="_blank" rel="noopener">https://next.xuetangx.com/learn/THU08091002048/THU08091002048/1515966/article/1373713</a></p><p><strong>2020年7月4日22:26:56</strong><br>晚上看操作系统<br><a href="https://www.bilibili.com/video/BV1iW411d7hd" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1iW411d7hd</a></p><p>大概时间规划大概如下.  上午C++基础或与之相关 下午算法 晚上操作系统或与之相关. 具体要等暑假开始实行调整.  最后一个暑假,<del>彼岸鱼你可长点心吧</del></p><p><strong>2020年7月14日23:52:20</strong><br>留校有点麻烦, 哎.  尽全力想法留校吧.</p><p>学习具体的时间安排.</p><p><strong>2020年7月17日15:31:42</strong><br>激动人心的一刻!!! 留校申请过了, 感谢老师的帮助. 我还有什么理由不更好好利用暑假呢??</p><p>算法最终选择了算法四教材</p><h1 id="2020年7月27日-2020年8月2日"><a href="#2020年7月27日-2020年8月2日" class="headerlink" title="2020年7月27日 - 2020年8月2日"></a>2020年7月27日 - 2020年8月2日</h1><p><strong>2020年7月30日00:31:57</strong><br>没想到第一次记录都是这个时间点了…..<br>原因是使用了更高级的方式… 记录了自己每个时间段干了什么emm</p><p>这里用来写总结吧, 最终每个星期插一张图片=, =</p><p><strong>2020年7月30日10:11:52</strong></p><p>详细了解并使用exec系列函数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;规划&quot;&gt;&lt;a href=&quot;#规划&quot; class=&quot;headerlink&quot; title=&quot;规划&quot;&gt;&lt;/a&gt;规划&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;2020年7月4日22:09:19&lt;/strong&gt;&lt;br&gt;C++Primer从头到尾看一遍 做习题.  16章+3章.&lt;b
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>小方说知识星球</title>
    <link href="http://blog.lsmg.xyz/2020/06/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%B0%8F%E6%96%B9%E8%AF%B4%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83/"/>
    <id>http://blog.lsmg.xyz/2020/06/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E5%B0%8F%E6%96%B9%E8%AF%B4%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83/</id>
    <published>2020-06-16T11:29:20.000Z</published>
    <updated>2020-07-17T12:38:50.735Z</updated>
    
    <content type="html"><![CDATA[<p>这里并不做过多的记录, 记录一些tips吧</p><p>lsof 能用做文件删除恢复. 仅限于文件虽然被删除但依然被某个进程打开.</p><p>bind函数<br>地址可以指定 INADDR_ANY<br>那么端口呢?  测试了下如果端口为0确实是 bind到了随机端口</p><p>bind到一个已经bind的端口会出错. 然而如果端口为0 随机的端口则没有被bind过</p><p>客户端connect前调用bind能够以指定端口号连接, 这个在高性能服务器见过 不过一直没有用过</p><p>异步connect? 非阻塞connect</p><p>connect尝试次数? 尝试间隔? </p><table><thead><tr><th>函数名称</th><th>返回值</th><th>阻塞</th><th>非阻塞</th></tr></thead><tbody><tr><td>recv</td><td>-1</td><td>出错</td><td>判断是否为EWOULDBLOCK(数据已经收完, ET模式收完数据的标志) 或者 EINTR(信号中断)</td></tr><tr><td>recv</td><td>0</td><td>对端关闭</td><td>对端关闭</td></tr><tr><td>send</td><td>-1</td><td>出错</td><td>EWOULDBLOCK(数据无法继续发出) EAGAIN</td></tr></tbody></table><p>LT 想收多少收多少 收不完就提醒<br>ET 爱收不收 过了这村没这店</p><p>老大让你开发一个邮件服务器, 大多数人像Springboot使用者. 第一时间就会去找库<br>然而大多数HTTP协议实现都比较简单, 在自己公司所用框架的网络基础上, 很简单就能写出.8</p><p>2020年7月17日20:30:06<br>理论-&gt;常用Api-&gt;知晓如何组织底层Api<br>网络编程重难点解析直播录像及课件, 终于看完了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这里并不做过多的记录, 记录一些tips吧&lt;/p&gt;
&lt;p&gt;lsof 能用做文件删除恢复. 仅限于文件虽然被删除但依然被某个进程打开.&lt;/p&gt;
&lt;p&gt;bind函数&lt;br&gt;地址可以指定 INADDR_ANY&lt;br&gt;那么端口呢?  测试了下如果端口为0确实是 bind到了随机端口
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="肉疼" scheme="http://blog.lsmg.xyz/tags/%E8%82%89%E7%96%BC/"/>
    
      <category term="小方说" scheme="http://blog.lsmg.xyz/tags/%E5%B0%8F%E6%96%B9%E8%AF%B4/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络笔记</title>
    <link href="http://blog.lsmg.xyz/2020/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>http://blog.lsmg.xyz/2020/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</id>
    <published>2020-06-16T00:50:22.000Z</published>
    <updated>2020-07-14T08:01:25.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title="?"></a>?</h1><p>物理层-以太网帧<br>数据链路层-MAC帧-添加了首部和尾部-FCS校验<br>网络层-IP数据报-首部校验和<br>传输层-报文,流 </p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p><strong>封装成帧</strong><br>帧首部SOH, 01H<br>帧尾部EOT, 04H</p><p><strong>透明传输</strong><br>数据部分出现 01H和04H以及1BH  在前面增加转义字符ESC 1BH</p><p><strong>差错检测</strong><br>CRC校验<br>FCS冗余码</p><p><strong>PPP协议</strong><br>7EH 帧首帧尾</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>网络层-数据报<br>数据链路层-MAC帧</p><p>网络层向上只提供 简单灵活的 无连接的 尽最大努力交付 的 <code>数据报</code>服务</p><p>地址解析协议ARP<br>网际控制报文协议 ICMP<br>网际组管理协议 IGMP</p><p>转发器-物理层使用的中间设备<br>网桥或桥接器-数据链路层使用的中间设备<br>路由器-网络层中间设备<br>网关-网络层以上使用的中间设备</p><p>一个路由器互联的多个局域网网络中-<code>网络层及以上高层协议必须相同</code> 而物理层和数据链路层则可不同(p116)<br>IP地址<code>用于网络层及以上高层</code> MAC地址用于<code>数据链路层和物理层</code></p><p>路由器转发的时候 源和目的MAC都<code>会</code>变化, 然而源和目的IP<code>不</code>变化 p118 p123</p><p>互联网名字和数字分配机构ICANN进行分配</p><p><strong>IP地址编址的三个阶段</strong></p><ul><li>分类的IP地址<br>IP地址由<code>网络号-主机号</code>构成</li></ul><table><thead><tr><th>类别</th><th>范围</th><th>网络号固定部分</th><th>总网络号位数</th><th>主机号位数</th></tr></thead><tbody><tr><td>A类</td><td>1-126</td><td>0</td><td>7+1位</td><td>主机号24位</td></tr><tr><td>B类</td><td>128-191</td><td>10</td><td>2+14位</td><td>主机号16位</td></tr><tr><td>C类</td><td>192-223</td><td>110</td><td>3+21位</td><td>主机号8位</td></tr><tr><td>D类</td><td>224-239</td><td>1110</td><td>多播地址</td><td></td></tr><tr><td>E类</td><td>240-255</td><td>1111</td><td>保留</td><td></td></tr></tbody></table><p>A类</p><p>2^7-2</p><p>网络号全0 表示本网络<br>网络号 0111 1111 127 代表本地换环回(你压根没被当做网络地址, 上表中跳过了127)</p><p>2^24-2</p><p>主机号全0 表示本主机连接的网络地址<br>主机号全1 代表该网络上的所有主机</p><p>B类</p><p>2^14-1</p><p>扣除了128.0.0.0 从128.1.0.0开始</p><p>2^16-2</p><p>抛去主机号全0和全1 原因同上</p><p>C类</p><p>2^21-1</p><p>扣除了192.0.0.0 从192.0.1.0开始</p><p>2^8-2</p><p>扣除全0和全1原因同上</p><p>其他特殊IP<br><code>10.*.*.*</code> <code>172.16.*.*-172.31.*.*</code> <code>192.168.*.*</code> - 三个私有地址网段 用于私网</p><ul><li>子网的划分<br>将B类地址主机号前面几个字作为子网号 划分子网 将二级地址转化为三级地址<br>现有B类地址<code>145.13.0.0</code>取八位作为子网<code>145.13.1.0</code>为一个子网 主机号剩下8位</li></ul><p>子网掩码<br>当<code>145.13.1.3</code>到达路由器<code>145.13.0.0</code>(描述不恰当)后 如何将其转发到子网<code>145.13.1.0</code><br>使用子网掩码AND运算得到网络地址<br>子网掩码子网数子网主机数p138</p><p><em>@划分子网情况下分组转发算法p140@</em></p><ul><li>构成超网<br>变长子网掩码VLSM(Variable Length Subnet Mask)<br>在其基础上研究出无分类编址方法-无分类域间路由选择CIDR(Classless Inter-domain Routing)</li></ul><p>128.14.35.7/20 表明前20位是网络前缀<br>成为/20地址块<br><em>@变长子网掩码划分子网@</em></p><p>用CIDR地址块来查找目的网络 这种地址的聚合常称为<code>聚合路由</code>也称为<code>构成超网</code></p><p>从匹配结果总选择具有最长网络前缀的路由-<code>最长前缀匹配</code></p><hr><p>ARP略</p><hr><p>IP数据报格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|         Identification        |Flags|      Fragment Offset    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                       Source Address                          |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Destination Address                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>IHL: 首部长度 最大 2^4-1 = 15 <code>单位四字节</code><br>最小是5 即最小首部为20字节<br>最大15  即最大为60字节</p><p>Total Length: 总长度 最大 2^16-1 = 65535 <code>单位一字节</code><br>以太网最大数据帧 1518 抛去14头部 4字节校验 剩余1500即为<code>MTU</code>  数据<code>帧</code>(链路层)的<code>数据字段</code>最大长度</p><p>flags: 标识<br>第一位MF MF=1标识<code>还有分片</code> DF=1标识<code>不能分片</code></p><p>Fragment Offset: 片偏移 <code>单位八字节</code><br>13位  </p><p><em>@分片计算 p129@</em></p><p>Time to Live: 生存时间<br><code>先减1</code>再判断是否为0, 为0则丢弃</p><p>Protocol: 协议<br>常用 TCP-6 UDP-17</p><p>Header Checksum: <code>首部校验和</code> 不包括数据部分<br>每次经过路由器都可能变化 生存时间标志片偏移可能变化</p><hr><p>首部分为很多16位字的序列 先将原校验和清零 在将所有序列求反码相加 再求反码写入校验和<br>接收方将所有序列 求反码相加(这里不将校验和清零) 得到的和取反码 必须为零 </p><p>IP数据报的可选部分无分隔符 最后需要用全0的字段补齐为 <code>四的整数倍</code></p><p><code>分组转发算法</code><br><em>@路由器路径 与路由表下一跳地址 p132@</em></p><p>同页特定主机路由和默认路由 下一页分组转发算法</p><p>ICMP略</p><p>互联网路由选择协议</p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><p>网络层为<code>主机</code>之间提供逻辑通信, 而传输层为应用程序之间提供<code>端到端</code>的逻辑通信</p><p>熟知端口号 - 0<del>1023 - 服务器端<br>登记端口号 - 1024</del>49151 - 提供给没有熟知端口号使用<br>短暂端口号 - 客户端</p><p>复用分用的关键 对下使用了IP数据报头部的字段Protocol 以及 对上端口号的使用</p><p>UDP数据报 TCP报文段<br>UDP是无连接的, 不可靠的, 基于数据报<br>TCP是面向连接的, 可靠的, 基于流的服务<br>(可靠 无差错, 不丢失, 不重复, 按序到达)</p><h2 id="用户数据报协议-UDP-User-Datagram-Protocol"><a href="#用户数据报协议-UDP-User-Datagram-Protocol" class="headerlink" title="用户数据报协议 UDP User Datagram Protocol"></a>用户数据报协议 UDP User Datagram Protocol</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0      7 8     15 16    23 24    31</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|          source address           |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|        destination address        |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|  zero  |protocol|   UDP length    |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0      7 8     15 16    23 24    31</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|     Source      |   Destination   |</span><br><span class="line">|      Port       |      Port       |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|                 |                 |</span><br><span class="line">|     Length      |    Checksum     |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|</span><br><span class="line">|          data octets ...</span><br><span class="line">+---------------- ...</span><br><span class="line"></span><br><span class="line">    User Datagram Header Format</span><br></pre></td></tr></table></figure><p>UDP length 同 Length: 最小值为8（仅包含首部 无数据）<br>Checksum: 校验和 使用 <code>伪首部</code> <code>首部</code> <code>数据</code> 计算出<br>校验了源和目的端口和地址</p><p>protocol： udp为17 tcp为6</p><p>伪首部12字节, 既不向下传递, 也不向上递交 仅仅为了计算校验和</p><p><em>@校验和计算 p210@</em><br><em>@TCP和UDP交付IP层的分片@</em><br>同样16B一组 </p><h2 id="传输控制协议-TCP-Transmission-Control-Protocol"><a href="#传输控制协议-TCP-Transmission-Control-Protocol" class="headerlink" title="传输控制协议 TCP Transmission Control Protocol"></a>传输控制协议 TCP Transmission Control Protocol</h2><p>为了传输的可靠性使用了下面的协议<br><strong>自动重传请求ARQ</strong><br>超时重传：每次发送完设置超时计时器， 超时之前收到确认就取消定时器， 否则到期后重发，并重置定时器。</p><p><code>收到重复报文</code>：A发送后B的回复丢失，A重发报文。丢弃重复的报文， 并向对方发送确认，而不能认为之前发送过就不发送了。<br><code>收到迟到的确认报文</code>：丢弃， 什么也不做。</p><p><strong><del>停止等待协议</del> 流水线传输协议</strong><br>使用流水线传输协议 就要使用 连续ARQ协议 和 滑动窗口协议</p><p><strong>连续ARQ协议</strong><br>可以连续发送五个连续分组 而不需要对方的确认</p><p>每收到一个确认，发送窗口就向前滑动。如果原来发送了五个分组就可以发送第六个分组了。<br>累计确认： 对按序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都收到了。<br>GO-back-N：如果中间第三个分组丢失，接收方只能发送前两个分组的确认，发送方需要发送后面三个分组。</p><p><strong>滑动窗口协议</strong></p><p> <strong>拥塞控制</strong><br><em>@p232 拥塞控制方法 画图和慢开始 拥塞避免 快恢复@</em></p><p><strong>超时重传时间确认</strong></p><p>报文往返时间RTTS<br>新的RTTS = (1-a) x 旧RTTS + a x 新RTTS<br>a = 0.125</p><p>超时重传时间<br>RTO = RTTS + 4 x RTTD</p><p>RTTD = (1 - b) x 旧RTTD + b x | RTTS - 新的RTT |<br>b = 0,25</p><p>karn算法 只要报文段重传就不采用其往返时间<br>修正 每重传一次新的时间为旧的2倍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure><p>seq: 序号<br><em>报文的序号和ack的对应关系</em></p><p>ack: 确认号<br>确认号为N 表明, 到序号N-1的所有数据都收到</p><p>数据偏移: 单位是四字节<br>头部长度 最少是20字节 最大是60字节 所以该项最少为5</p><p>URG: 紧急标识<br>如果TCP发送缓冲区有很多数据, 但需要紧急发送某个命令. 正常情况下会加在缓冲区位<br>如果设置了标识, 则插入到最前边</p><p>ACK: 确认号<br>TCP规定, 建立连接后所有的报文段ACK都设置为1<br><strong>可以携带数据 不携带数据则不会消耗 报文号</strong></p><p>PSH: 推送<br>接收方收到该标识后 将数据尽快提交到应用程序, 而不是等缓冲满了提交</p><p>RST: 复位<br>说明TCP连接出现严重差错  必须重新建立连接</p><p>SYN: 同步<br>连接建立时用来同步序号<br>含有此标记 不能携带数据 但<strong>仍要消耗一个序列号</strong></p><p>FIN: 终止连接</p><p>窗口:<br>发送本报文段一方的接收窗口</p><p>检验和:<br>需要加上12字节的伪首部<br><em>检验和计算</em></p><p>紧急指针:<br>指明报文段中紧急数据的字节数</p><p>MSS: 最大报文段长度, 指的是数据字段的最大长度</p><p><em>@tcp连接的建立和断开 p238@</em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;?&quot;&gt;&lt;/a&gt;?&lt;/h1&gt;&lt;p&gt;物理层-以太网帧&lt;br&gt;数据链路层-MAC帧-添加了首部和尾部-FCS校验&lt;br&gt;网络层-IP数据报-首部校验和&lt;br&gt;传输层-报文,流 &lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://blog.lsmg.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="自底向上?" scheme="http://blog.lsmg.xyz/tags/%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A/"/>
    
  </entry>
  
  <entry>
    <title>csapp笔记</title>
    <link href="http://blog.lsmg.xyz/2020/06/Linux-csapp140/"/>
    <id>http://blog.lsmg.xyz/2020/06/Linux-csapp140/</id>
    <published>2020-06-07T01:09:20.000Z</published>
    <updated>2020-07-30T03:10:10.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h1><p><img src="http://lsmg-img.oss-cn-beijing.aliyuncs.com/csapp/1-3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F.png" alt=""></p><p>预处理-&gt;编译-&gt;汇编-&gt;链接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1111</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, PI);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预处理<br>宏替换和注释消失 但是空行还在<br><code>g++ -E hello.cpp -o hello.i</code><br><code>tail -9 hello.i</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">5</span> <span class="string">"hello.cpp"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, <span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译 生成汇编<br><code>g++ -S hello.i</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        .file   &quot;hello.cpp&quot;</span><br><span class="line">        .text</span><br><span class="line">        .section        .rodata</span><br><span class="line">.LC1:</span><br><span class="line">        .string &quot;%f\n&quot;</span><br><span class="line">.LC2:</span><br><span class="line">        .string &quot;hello, world!&quot;</span><br><span class="line">        .text</span><br><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        subq    $16, %rsp</span><br><span class="line">        movq    .LC0(%rip), %rax</span><br><span class="line">        movq    %rax, -8(%rbp)</span><br><span class="line">        movsd   -8(%rbp), %xmm0</span><br><span class="line">        leaq    .LC1(%rip), %rdi</span><br><span class="line">        movl    $1, %eax</span><br><span class="line">        call    printf@PLT</span><br><span class="line">        leaq    .LC2(%rip), %rdi</span><br><span class="line">        call    puts@PLT</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        leave</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .section        .rodata</span><br><span class="line">        .align 8</span><br><span class="line">.LC0:</span><br><span class="line">        .long   1374389535</span><br><span class="line">        .long   1074339512</span><br><span class="line">        .ident  &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;</span><br><span class="line">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>汇编 生成 可重定位二进制目标程序<br>gcc编译器 -c参数 起到的作用是编译和汇编 -S参数 仅仅是编译<br><code>g++ -c hello.s</code></p><p>链接 生成执行文件<br><code>g++ hello.o -o hello</code></p><p>在不同进程间切换 交错执行的执行-上下文切换<br>操作系统保持进程运行所需的所有状态信息 这种状态-上下文</p><p>线程共享代码和全局数据</p><h1 id="第一部分-程序结构和执行"><a href="#第一部分-程序结构和执行" class="headerlink" title="第一部分 程序结构和执行"></a>第一部分 程序结构和执行</h1><h2 id="第二章-信息存储"><a href="#第二章-信息存储" class="headerlink" title="第二章 信息存储"></a>第二章 信息存储</h2><p>孤立地讲,单个位不是非常有用. 然而, 当把位组合在一起, 再加上某种解释,即赋予不同可能位组合不同的含义, 我们就能表示任何有限集合的元素.</p><h1 id="第三章-程序的机器级表示"><a href="#第三章-程序的机器级表示" class="headerlink" title="第三章 程序的机器级表示"></a>第三章 程序的机器级表示</h1><h2 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h2><p>编写高效的程序</p><ul><li>选择一组适当的算法和数据结构</li><li>编写出编译器能够有效优化以转变为高效的可执行程序的源代码</li><li>大项目的并行计算</li></ul><p>整数运算使用乘法的结合律和交换律, 当溢出的时候, 结果依然是一致的.<br>但是浮点数使用结合律和交换律的时候, 在溢出时, 结果却不是一致的.</p><p>整数的表示虽然只能编码一个相对较小的数值范围, 但是这种标识是精确地<br>浮点数能编码一个较大的数值范围, 但是这种表示只是近似的.</p><h2 id="第六章-存储器层次结构"><a href="#第六章-存储器层次结构" class="headerlink" title="第六章 存储器层次结构"></a>第六章 存储器层次结构</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-计算机系统漫游&quot;&gt;&lt;a href=&quot;#第一章-计算机系统漫游&quot; class=&quot;headerlink&quot; title=&quot;第一章 计算机系统漫游&quot;&gt;&lt;/a&gt;第一章 计算机系统漫游&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://lsmg-img.oss-cn-b
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="csapp" scheme="http://blog.lsmg.xyz/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>陀螺球(废弃)</title>
    <link href="http://blog.lsmg.xyz/2020/06/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-%E9%99%80%E8%9E%BA%E7%90%83/"/>
    <id>http://blog.lsmg.xyz/2020/06/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C-%E9%99%80%E8%9E%BA%E7%90%83/</id>
    <published>2020-06-02T04:50:02.000Z</published>
    <updated>2020-11-09T08:02:09.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础设计"><a href="#基础设计" class="headerlink" title="基础设计"></a>基础设计</h1><h2 id="基本玩法"><a href="#基本玩法" class="headerlink" title="基本玩法"></a>基本玩法</h2><p>使用手机陀螺仪控制圆形小球的移动.  存在各种关卡组件以及小球装备 从初始点最终到达目的地</p><p>首先考虑制作出地图编辑器<br>玩家可以下载并游玩其他人创建的地图</p><p>其次增加双人联机的功能 双人共同通关?</p><p>包含计时以及通关星数 通过碰撞获得两颗星 关卡时间一颗星</p><h2 id="关卡组件"><a href="#关卡组件" class="headerlink" title="关卡组件"></a>关卡组件</h2><table><thead><tr><th>物品代码</th><th>物品名称</th><th>物品描述</th></tr></thead><tbody><tr><td>10001</td><td>基础方块</td><td>提供基础阻挡功能</td></tr><tr><td>10002</td><td>出生点</td><td></td></tr><tr><td>10003</td><td>终点</td><td></td></tr><tr><td>10004</td><td>关卡星星</td><td>用于增加通关星数</td></tr><tr><td>10100</td><td>加速</td><td>提供一个方向的瞬时力</td></tr></tbody></table><h3 id="基础方块"><a href="#基础方块" class="headerlink" title="基础方块"></a>基础方块</h3><p>均使用int</p><p>| 10001 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z | 物品缩放X | 物品缩放Y | 物品缩放Z |</p><h3 id="出生点"><a href="#出生点" class="headerlink" title="出生点"></a>出生点</h3><p>| 10002 | 位置X | 位置Y | 位置Z |</p><h3 id="终点"><a href="#终点" class="headerlink" title="终点"></a>终点</h3><p>| 10003 | 位置X | 位置Y | 位置Z |</p><h3 id="关卡星星"><a href="#关卡星星" class="headerlink" title="关卡星星"></a>关卡星星</h3><p>| 10004 | 位置X | 位置Y | 位置Z |</p><p>增加一颗通关星1</p><p>| 10005 | 位置X | 位置Y | 位置Z |</p><p>增加一颗通关星2</p><h3 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h3><p>| 10100 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z |</p><p>提供方块对向的瞬时力</p><ul><li>用于改善体验</li><li>用于所短时间完成要求</li></ul><h3 id="传送"><a href="#传送" class="headerlink" title="传送"></a>传送</h3><p>| 10101 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z | 颜色代码 |</p><h2 id="小球装备"><a href="#小球装备" class="headerlink" title="小球装备"></a>小球装备</h2><h2 id="地图设计"><a href="#地图设计" class="headerlink" title="地图设计"></a>地图设计</h2><h1 id="前端实现"><a href="#前端实现" class="headerlink" title="前端实现"></a>前端实现</h1><p>创建基础方块父类</p><p>父类必要组件</p><ul><li>Static Mesh</li></ul><p>父类函数</p><ul><li>Serialize(TArray<int32>&amp; Data);</li></ul><p>必要成员变量</p><ul><li>物品代码</li><li>物品参数数量</li></ul><h2 id="地图保存"><a href="#地图保存" class="headerlink" title="地图保存"></a>地图保存</h2><p>调用各个组件的Serialize将各自的数据保存入Data</p><h2 id="地图加载"><a href="#地图加载" class="headerlink" title="地图加载"></a>地图加载</h2><p>struct Component<br>{<br>  TSubclassOf&lt;组件父类&gt; Obj<br>  int Nums 生成此组件需要的参数数量<br>}</p><p>TMap&lt;int32, Component&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础设计&quot;&gt;&lt;a href=&quot;#基础设计&quot; class=&quot;headerlink&quot; title=&quot;基础设计&quot;&gt;&lt;/a&gt;基础设计&lt;/h1&gt;&lt;h2 id=&quot;基本玩法&quot;&gt;&lt;a href=&quot;#基本玩法&quot; class=&quot;headerlink&quot; title=&quot;基本玩法&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="项目制作" scheme="http://blog.lsmg.xyz/categories/%E9%A1%B9%E7%9B%AE%E5%88%B6%E4%BD%9C/"/>
    
    
      <category term="陀螺球" scheme="http://blog.lsmg.xyz/tags/%E9%99%80%E8%9E%BA%E7%90%83/"/>
    
  </entry>
  
  <entry>
    <title>代码大全</title>
    <link href="http://blog.lsmg.xyz/2020/05/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95130-%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    <id>http://blog.lsmg.xyz/2020/05/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95130-%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/</id>
    <published>2020-05-13T13:19:39.000Z</published>
    <updated>2020-08-02T04:37:31.212Z</updated>
    
    <content type="html"><![CDATA[<p>距离上次什么时候写博客已经记不清了, 看了眼GitHub备份记录 已经25天了. 这25天我咕了吗? 咕是不可能咕的. 这段时间我终于做出了第一个UE4比较完善的联机游戏.<br>学习了更多的muduo自己的mongo也更加完善. 只看书写博客不写代码可不行.</p><p>技术类书籍慢慢开始看了, mongo写的时间不短了.  代码大全听说是神书? 来粗读看看吧</p><h1 id="第-部分"><a href="#第-部分" class="headerlink" title="第?部分"></a>第?部分</h1><h2 id="第六章-可以工作的类"><a href="#第六章-可以工作的类" class="headerlink" title="第六章 可以工作的类"></a>第六章 可以工作的类</h2><p>使用ADT 可以实现隐藏细节, 改动不会影响到整个程序.</p><p>这点感受还是有些的. 前两天自己写VPN(目前项目暂停了)的时候, 有个Buffer类, Buffer类的核心是libevent的evbuff, 我直接使用Get方法Get到这个evbuff的指针, 然后在外部进行操作.<br>起初这样只是图简单吧, 也想到了这样会写出烂代码. 后面改动核心evbuff的时候, 发现太麻烦了, 最终改成了几个简单的接口 Append Clear等, 对外隐藏了内部是什么缓冲结构</p><p>has a  —- 组合 包含<br>is a —- 集成 epoll(select) is a mutiplexing</p><p>只有一个实例的类是值得怀疑的, 同样只有一个派生类的基类也是值得怀疑的</p><p>拷贝对象优先使用深拷贝</p><p>创建类的原因</p><ul><li>为现实世界中的对象建模</li><li>为抽象的对象建模 形状类是抽象的 不过圆 正方形等都是真实存在的</li><li>降低复杂度 一个类创建结束后, 你就可以忘掉其中的细节 使用接口即可</li><li>隔离复杂度</li><li>隐藏实现细节 限制变动的影响范围 隐藏全局数据</li><li>让参数传递更加舒畅 成员变量 </li><li>复用代码</li></ul><h2 id="第七章-高质量的子程序"><a href="#第七章-高质量的子程序" class="headerlink" title="第七章 高质量的子程序"></a>第七章 高质量的子程序</h2><p>创建子程序的正当理由</p><ul><li>降低复杂度<br>一个子程序编写完毕后, 应该可以忘记其中的细节</li><li>引入中间,易懂的抽象<br>避免代码重复  从大块的代码中抽取子程序</li><li>隐藏顺序 如果某两行代码有特定的执行顺序, 可以考虑抽取出来. 感觉这里可以推广到Mutex lock后忘记unlock 或者 Buffer中读取数据后 忘记移动指针?</li><li>提高可移植性 这点看项目了</li></ul><p>似乎过于简单没有必要写成子程序, 当然也要看情况了</p><ul><li>这里我感觉最深的还是 两行或者三行经常调用的程序, 如果重复写多次 最终告知你需要修改的时候 那可真是灾难性的消息. 实例的话: 增加参数校验等等</li></ul><p>准确的使用对仗词</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>add</td><td>remove</td></tr><tr><td>begin</td><td>end</td></tr><tr><td>create</td><td>destory</td></tr><tr><td>next</td><td>previous</td></tr><tr><td>start</td><td>stop</td></tr></tbody></table><p>如何使用子程序参数</p><ul><li>按照输入-修改-输出的顺序排列参数</li><li>如果几个子程序都是用了类似的一些参数, 应该让这些参数的排列顺序一致</li><li>使用所有的参数, 删去未使用到的参数</li><li>不要把子程序的参数用做工作变量</li></ul><p>设置函数的返回值</p><ul><li>检查所有可能的返回路径, 在函数开头设置默认返回 一个不错的选择(muduo中见到了)</li><li>老生常谈的不要返回局部对象的引用或者指针</li></ul><p>少使用宏吧 inline和typedef 不香吗, 不是肉包子也是好吃的素包子了</p><h2 id="第八章-防御式编程"><a href="#第八章-防御式编程" class="headerlink" title="第八章 防御式编程"></a>第八章 防御式编程</h2><p><del>防御式编程并不是说让你在编程时保持 “防备批评或攻击” 的态度</del></p><p>子程序不应该因为传入错误数据而被破坏</p><ul><li>检查所有源自外部数据的值</li><li>检查子程序所有输入参数的值</li><li>决定如何处理错误的输入数据</li></ul><p>使用错误处理代码来处理与其发生的状况, 使用断言来处理绝不应该发生的状况</p><p>错误处理技术 其他感觉… 用不到吧 现在不记录了</p><ul><li>返回中立值 最简单的方法, 继续执行操作并简单的返回一个没有危害的数值. 数值计算-返回0 字符串返回空串 指针返回空指针</li><li>日志打印</li><li>关闭程序</li></ul><p>隔离程序<br>两块相对独立的代码块 在交互函数见进行参数校验 过滤掉一个模块传来的非法参数</p><p>辅助调试的代码…..<br>我现在就遇到一个bug 还不知道怎么修改 与多线程有关的问题 排查真难-2020年5月18日13:11:43<br>2020年6月18日23:50:44 排查掉了 今天看到了这段话 补充上吧</p><p>决定产品最终发布的时候应该保留多少防御内容<br>防御内容越多消耗的性能越多</p><h2 id="第九章-伪代码的编程过程"><a href="#第九章-伪代码的编程过程" class="headerlink" title="第九章 伪代码的编程过程"></a>第九章 伪代码的编程过程</h2><p>原则</p><ul><li>用类似英语的句子来准确描述特定的操作</li><li>便面使用目标编程语言中的特定语法元素</li><li>在本意的层面上编写伪代码. 用伪代码描述解决问题的方法意图, 而不是去写如何用目标语言实现这个方法</li><li>在一个足够低的层次上编写伪代码, 以便近乎自动的生成代码, 如果层次过高则会隐藏细节问题</li></ul><ol><li>定义子程序要解决的问题</li></ol><ul><li>子程序将要隐藏的信息</li><li>传给子程序的各项输入, 得到的输出</li><li>调用子程序前确保相关前条件成立. 输入数据的范围正确 流已经初始化 文件已经打开或关闭</li><li>在子程序将控制权交回调用方程序之前, 确保其后条件成立. 多线程问题居多</li></ul><ol start="2"><li>为子程序命名</li><li>决定如何测试子程序</li><li>在标准库中搜寻可用的功能</li><li>考虑错误处理和效率问题</li></ol><h1 id="第三部分-变量variables"><a href="#第三部分-变量variables" class="headerlink" title="第三部分 变量variables"></a>第三部分 变量variables</h1><h2 id="第十章-使用变量的一般事项"><a href="#第十章-使用变量的一般事项" class="headerlink" title="第十章 使用变量的一般事项"></a>第十章 使用变量的一般事项</h2><p>这本书还教你做人…  分数不可能很高 因为有的概念是杜撰的!!<br>(请读第33章 个人性格 诚实一节)</p><p>位图<br>B-树<br>堆<br>栈<br>文字量<br>查找表<br>引用完整性<br>树<br>共用体<br>变体</p><ul><li>在声明的时候就进行初始化</li><li>在理想的情况下, 在靠近第一次使用变量的位置声明和定义变量</li><li>多多使用const 吧</li><li>注意计数器和累加器. 这里很久前遇到一个坑 无符号自减可能会下溢</li><li>构造函数中进行初始化</li><li>检查是否需要重新初始化</li><li>检查输入的合法性</li><li>初始化指针建议初始化为 0, 一旦你看到为0的指针越界就知道是没有赋值</li></ul><h2 id="第十一章-变量名的力量"><a href="#第十一章-变量名的力量" class="headerlink" title="第十一章 变量名的力量"></a>第十一章 变量名的力量</h2><ol><li>为循环下标 临时变量命名</li><li>bool变量<br>done-&gt;事情已经完成<br>error-&gt;有错误发生<br>found-&gt;找到<br>success/ok -&gt;某操作已经成功 不是很具体<br>Is前缀可以用在模糊不清的词前, 不过这样也会导致最终表达模糊不清</li><li>标识全局变量 使用 <code>g_</code> 前缀</li><li>标识类型声明 <code>T</code> 前缀</li><li>避免在名字中使用1 2 后缀file_1 file_2</li></ol><h2 id="第十二章-基本数据类型"><a href="#第十二章-基本数据类型" class="headerlink" title="第十二章 基本数据类型"></a>第十二章 基本数据类型</h2><ol><li>避免使用神秘数值 突然出现某个数值 这样一方面不便于修改所有值 一方面防止忘记数值含义</li><li>除零 的发生</li><li>防止溢出 这里最常见的就是循环体中了 更尤其是unsigned变量自减的时候</li><li>防范数组越界</li><li>C风格字符串的长度声明为 <code>CONSTANT+1</code>, CONSTANT是长度. 防止到时候你分不清长度是该+1还是-1还是就是本身</li></ol><p><code>if(chosen_color = 1)</code>和<code>if(chose_color = Color_Red)</code>后者枚举的使用更清楚.<br>枚举示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color</span><br><span class="line">&#123;</span><br><span class="line">  COLOR_RED,</span><br><span class="line">  COLOR_BLUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单点控制(single-pointcontrol)让程序真正软了起来, 将一个量保存在变量中. 程序中使用变量名替换这个量</p><h2 id="第十三章-不常见的数据类型"><a href="#第十三章-不常见的数据类型" class="headerlink" title="第十三章 不常见的数据类型"></a>第十三章 不常见的数据类型</h2><p>p318</p><p>引用必须总是引用一个对象, 而指针则可以指向空值.<br>引用所指向的对象在改引用初始化后不能改变</p><p>全局变量应该加以说明</p><p>全局数据隐藏到类中, 使用static</p><p>不应该吧所有数据放在一个大对象中到处传递</p><p>不要实用全局变量存放中间结果</p><h1 id="第四部分语句"><a href="#第四部分语句" class="headerlink" title="第四部分语句"></a>第四部分语句</h1><h2 id="第十四章-组织直线型代码"><a href="#第十四章-组织直线型代码" class="headerlink" title="第十四章 组织直线型代码"></a>第十四章 组织直线型代码</h2><ul><li>设法组织代码, 使依赖关系变得非常明显<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = ReadData();</span><br><span class="line">result = CalculateResultsFromData(data);</span><br><span class="line">PrintResult(result);</span><br></pre></td></tr></table></figure>这段代码看起来很舒服, 逻辑清理, 命名到位. 明显的表明了函数间的依赖关系</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revenue.ComputeMonthly();</span><br><span class="line">revenue.ComputeQuarterly();</span><br><span class="line">revenue.ComputeAnnual();</span><br></pre></td></tr></table></figure><p>这段代码, 前后依赖关系没有表现出来. 实际上计算季度收入需要先计算月收入 计算年收入需要季度收入</p><ul><li>使子程序名能凸显依赖关系</li><li>使用子程序参数明确显示依赖关系</li></ul><p>几个函数连续使用相同的参数, 说明之间极可能存在依赖关系.<br>几个函数使用不同的参数, 说明之间极可能不存在依赖关系</p><ul><li>对逻辑不清晰的代码 进行注释说明</li><li>使用断言或者错误来处理错误的调用顺序</li></ul><h2 id="第十五章-使用条件语句"><a href="#第十五章-使用条件语句" class="headerlink" title="第十五章 使用条件语句"></a>第十五章 使用条件语句</h2><p>if 语句</p><ul><li>首先写正常的代码路径, 再处理不常见的情况. 使得正确情况的执行路径在代码中是清晰的.</li><li>确保对于等量的分支是正确的(最好不要用&gt;替换&gt;= &lt;替换&lt;=) 防止off-by-one偏差一的错误. 这点emm</li><li>把正常情况的处理放在if后面 不要放在else后面 (看了眼示例代码, 对于嵌套if非常重要)</li><li><del>通用汽车公司做的分析发现 有五到八成的if语句都需要配有else语句</del></li><li>确保考虑到所有的情况, 一串if elseif之后应该加上一个else检查其他情况, 防止有未考虑到的情况</li></ul><p>case语句</p><ul><li>default语句只用来检查真正的默认情况, 而不是用来处理你认为的最后一种情况. 否则<br>你将失去case语句的标号(label)所提供的自动说明功能, 也丧失了default子句检错的能力</li><li>利用default语句来检错</li><li>case语句后没有break应该注释说明</li></ul><h2 id="第十六章-控制循环"><a href="#第十六章-控制循环" class="headerlink" title="第十六章 控制循环"></a>第十六章 控制循环</h2><ul><li>不要滥用循环下标<br>最好不要在循环体外 使用 依赖于循环下标最终取值的代码 可能会因为循环异常退出或者循环结束, 得到的下标并不是你想要的下标. 应该使用合适的变量用来标记在循环中是否遇到了你想要的情况</li><li>考虑在while循环中使用break而不是布尔标记</li><li>不要使用浮点数作为边界</li><li>使用有意义的下标变量名, 防止下标串话.</li><li>不要在循环中修改下标值</li></ul><p>下面的代码就是下标串话, 本来第二个循环应该使用j. 这种bug可能不是很容易排查出来, i和j乍一看很像.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>  i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; xxx; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  xxxx</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; j &lt;xxx; ++j)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>低效的程序员会随意做一些试验, 直到他们找到了一种看上去能工作的组合. 如果某个循环没有按照想象工作,低效的程序员可能会把<code>&lt;</code>改为<code>&lt;=</code>. 如果还不行可能把下标<code>+1</code>或者<code>-1</code>. 这样最终可能碰出正确组合, 也有可能把原来的错误改成了另一个更微妙的错误. 即使这样随意的开发过程能够产生正确的程序, 这些程序员也不明白为什么这个程序是正确的.</p><h2 id="第十七章-不常见的控制结构"><a href="#第十七章-不常见的控制结构" class="headerlink" title="第十七章 不常见的控制结构"></a>第十七章 不常见的控制结构</h2><p>递归前两天正好用过, 如果用的恰当的话 感觉很不错</p><p>我也不想去用…… =, =</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;距离上次什么时候写博客已经记不清了, 看了眼GitHub备份记录 已经25天了. 这25天我咕了吗? 咕是不可能咕的. 这段时间我终于做出了第一个UE4比较完善的联机游戏.&lt;br&gt;学习了更多的muduo自己的mongo也更加完善. 只看书写博客不写代码可不行.&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="软件开发" scheme="http://blog.lsmg.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书记录" scheme="http://blog.lsmg.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
</feed>
