<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lsmg的大学之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lsmg.xyz/"/>
  <updated>2020-06-02T05:07:51.671Z</updated>
  <id>http://blog.lsmg.xyz/</id>
  
  <author>
    <name>Lsmg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>陀螺球</title>
    <link href="http://blog.lsmg.xyz/2020/06/%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C-%E9%99%80%E8%9E%BA%E7%90%83/"/>
    <id>http://blog.lsmg.xyz/2020/06/%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C-%E9%99%80%E8%9E%BA%E7%90%83/</id>
    <published>2020-06-02T04:50:02.000Z</published>
    <updated>2020-06-02T05:07:51.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本玩法"><a href="#基本玩法" class="headerlink" title="基本玩法"></a>基本玩法</h1><p>使用手机陀螺仪控制圆形小球的移动.  存在各种关卡组件以及小球装备 从初始点最终到达目的地</p><p>首先考虑制作出地图编辑器<br>玩家可以下载并游玩其他人创建的地图</p><p>其次增加双人联机的功能 双人共同通关?</p><p>包含计时以及通关星数 通过碰撞获得两颗星 关卡时间一颗星</p><h1 id="关卡组件"><a href="#关卡组件" class="headerlink" title="关卡组件"></a>关卡组件</h1><table><thead><tr><th>物品代码</th><th>物品名称</th><th>物品描述</th></tr></thead><tbody><tr><td>10001</td><td>基础方块</td><td>提供基础阻挡功能</td></tr><tr><td>10002</td><td>出生点</td><td></td></tr><tr><td>10003</td><td>终点</td><td></td></tr><tr><td>10004</td><td>关卡星星</td><td>用于增加通关星数</td></tr><tr><td>10100</td><td>加速</td><td>提供一个方向的瞬时力</td></tr></tbody></table><h2 id="基础方块"><a href="#基础方块" class="headerlink" title="基础方块"></a>基础方块</h2><p>均使用int <code>10*4 = 40B</code></p><p>| 10001 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z | 物品缩放X | 物品缩放Y | 物品缩放Z |</p><h2 id="出生点"><a href="#出生点" class="headerlink" title="出生点"></a>出生点</h2><p>| 10002 | 位置X | 位置Y | 位置Z |</p><h2 id="终点"><a href="#终点" class="headerlink" title="终点"></a>终点</h2><p>| 10003 | 位置X | 位置Y | 位置Z |</p><h2 id="关卡星星"><a href="#关卡星星" class="headerlink" title="关卡星星"></a>关卡星星</h2><p>| 10004 | 位置X | 位置Y | 位置Z |</p><p>增加一颗通关星</p><h2 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h2><p>| 10100 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z |</p><p>提供方块对向的瞬时力</p><ul><li>用于改善体验</li><li>用于所短时间完成要求</li></ul><h1 id="小球装备"><a href="#小球装备" class="headerlink" title="小球装备"></a>小球装备</h1><h1 id="地图设计"><a href="#地图设计" class="headerlink" title="地图设计"></a>地图设计</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本玩法&quot;&gt;&lt;a href=&quot;#基本玩法&quot; class=&quot;headerlink&quot; title=&quot;基本玩法&quot;&gt;&lt;/a&gt;基本玩法&lt;/h1&gt;&lt;p&gt;使用手机陀螺仪控制圆形小球的移动.  存在各种关卡组件以及小球装备 从初始点最终到达目的地&lt;/p&gt;
&lt;p&gt;首先考虑制作出地图
      
    
    </summary>
    
    
      <category term="游戏制作" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C/"/>
    
    
      <category term="陀螺球" scheme="http://blog.lsmg.xyz/tags/%E9%99%80%E8%9E%BA%E7%90%83/"/>
    
  </entry>
  
  <entry>
    <title>代码大全</title>
    <link href="http://blog.lsmg.xyz/2020/05/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95130-%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
    <id>http://blog.lsmg.xyz/2020/05/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95130-%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8/</id>
    <published>2020-05-13T13:19:39.000Z</published>
    <updated>2020-05-25T11:42:44.138Z</updated>
    
    <content type="html"><![CDATA[<p>距离上次什么时候写博客已经记不清了, 看了眼GitHub备份记录 已经25天了. 这25天我咕了吗? 咕是不可能咕的. 这段时间我终于做出了第一个UE4比较完善的联机游戏.<br>学习了更多的muduo自己的mongo也更加完善. 学而不思则罔,思而不学则殆. 只看书写博客不写代码可不行.</p><p>技术类书籍慢慢开始看了, mongo写的时间不短了.  代码大全听说是神书? 来粗读看看吧</p><h1 id="第-部分"><a href="#第-部分" class="headerlink" title="第?部分"></a>第?部分</h1><h2 id="第六章-可以工作的类"><a href="#第六章-可以工作的类" class="headerlink" title="第六章 可以工作的类"></a>第六章 可以工作的类</h2><p>使用ADT 可以实现隐藏细节, 改动不会影响到整个程序.</p><p>这点感受还是有些的. 前两天自己写VPN(目前项目暂停了)的时候, 有个Buffer类, Buffer类的核心是libevent的evbuff, 我直接使用Get方法Get到这个evbuff的指针, 然后在外部进行操作.<br>起初这样只是图简单吧, 也想到了这样会写出烂代码. 后面改动核心evbuff的时候, 发现太麻烦了, 最终改成了几个简单的接口 Append Clear等, 对外隐藏了内部是什么缓冲结构</p><p>has a  —- 组合 包含<br>is a —- 集成 epoll(select) is a mutiplexing</p><p>只有一个实例的类是值得怀疑的, 同样只有一个派生类的基类也是值得怀疑的</p><p>拷贝对象优先使用深拷贝</p><p>创建类的原因</p><ul><li>为现实世界中的对象建模</li><li>为抽象的对象建模 形状类是抽象的 不过圆 正方形等都是真实存在的</li><li>降低复杂度 一个类创建结束后, 你就可以忘掉其中的细节 使用接口即可</li><li>隔离复杂度</li><li>隐藏实现细节 限制变动的影响范围 隐藏全局数据</li><li>让参数传递更加舒畅 成员变量 </li><li>复用代码</li></ul><h2 id="第七章-高质量的子程序"><a href="#第七章-高质量的子程序" class="headerlink" title="第七章 高质量的子程序"></a>第七章 高质量的子程序</h2><p>创建子程序的正当理由</p><ul><li>降低复杂度<br>一个子程序编写完毕后, 应该可以忘记其中的细节</li><li>引入中间,易懂的抽象<br>避免代码重复  从大块的代码中抽取子程序</li><li>隐藏顺序 如果某两行代码有特定的执行顺序, 可以考虑抽取出来. 感觉这里可以推广到Mutex lock后忘记unlock 或者 Buffer中读取数据后 忘记移动指针?</li><li>提高可移植性 这点看项目了</li></ul><p>似乎过于简单没有必要写成子程序, 当然也要看情况了</p><ul><li>这里我感觉最深的还是 两行或者三行经常调用的程序, 如果重复写多次 最终告知你需要修改的时候 那可真是灾难性的消息. 实例的话: 增加参数校验等等</li></ul><p>准确的使用对仗词</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>add</td><td>remove</td></tr><tr><td>begin</td><td>end</td></tr><tr><td>create</td><td>destory</td></tr><tr><td>next</td><td>previous</td></tr><tr><td>start</td><td>stop</td></tr></tbody></table><p>如何使用子程序参数</p><ul><li>按照输入-修改-输出的顺序排列参数</li><li>如果几个子程序都是用了类似的一些参数, 应该让这些参数的排列顺序一致</li><li>使用所有的参数, 删去未使用到的参数</li><li>不要把子程序的参数用做工作变量</li></ul><p>设置函数的返回值</p><ul><li>检查所有可能的返回路径, 在函数开头设置默认返回 一个不错的选择(muduo中见到了)</li><li>老生常谈的不要返回局部对象的引用或者指针</li></ul><p>少使用宏吧 inline和typedef 不香吗, 不是肉包子也是好吃的素包子了</p><h2 id="第八章-防御式编程"><a href="#第八章-防御式编程" class="headerlink" title="第八章 防御式编程"></a>第八章 防御式编程</h2><p><del>防御式编程并不是说让你在编程时保持 “防备批评或攻击” 的态度</del></p><p>子程序不应该因为传入错误数据而被破坏</p><ul><li>检查所有源自外部数据的值</li><li>检查子程序所有输入参数的值</li><li>决定如何处理错误的输入数据</li></ul><p>使用错误处理代码来处理与其发生的状况, 使用断言来处理绝不应该发生的状况</p><p>错误处理技术 其他感觉… 用不到吧 现在不记录了</p><ul><li>返回中立值 最简单的方法, 继续执行操作并简单的返回一个没有危害的数值. 数值计算-返回0 字符串返回空串 指针返回空指针</li><li>日志打印</li><li>关闭程序</li></ul><p>隔离程序<br>两块相对独立的代码块 在交互函数见进行参数校验 过滤掉一个模块传来的非法参数</p><p>辅助调试的代码…..<br>我现在就遇到一个bug 还不知道怎么修改 与多线程有关的问题 排查真难-2020年5月18日13:11:43</p><p>决定产品最终发布的时候应该保留多少防御内容<br>防御内容越多消耗的性能越多</p><h2 id="第九章-伪代码的编程过程"><a href="#第九章-伪代码的编程过程" class="headerlink" title="第九章 伪代码的编程过程"></a>第九章 伪代码的编程过程</h2><p>原则</p><ul><li>用类似英语的句子来准确描述特定的操作</li><li>便面使用目标编程语言中的特定语法元素</li><li>在本意的层面上编写伪代码. 用伪代码描述解决问题的方法意图, 而不是去写如何用目标语言实现这个方法</li><li>在一个足够低的层次上编写伪代码, 以便近乎自动的生成代码, 如果层次过高则会隐藏细节问题</li></ul><ol><li>定义子程序要解决的问题</li></ol><ul><li>子程序将要隐藏的信息</li><li>传给子程序的各项输入, 得到的输出</li><li>调用子程序前确保相关前条件成立. 输入数据的范围正确 流已经初始化 文件已经打开或关闭</li><li>在子程序将控制权交回调用方程序之前, 确保其后条件成立. 多线程问题居多</li></ul><ol start="2"><li>为子程序命名</li><li>决定如何测试子程序</li><li>在标准库中搜寻可用的功能</li><li>考虑错误处理和效率问题</li></ol><h1 id="第三部分-变量variables"><a href="#第三部分-变量variables" class="headerlink" title="第三部分 变量variables"></a>第三部分 变量variables</h1><h2 id="第十章-使用变量的一般事项"><a href="#第十章-使用变量的一般事项" class="headerlink" title="第十章 使用变量的一般事项"></a>第十章 使用变量的一般事项</h2><p>这本书还教你做人…  分数不可能很高 因为有的概念是杜撰的!!<br>(请读第33章 个人性格 诚实一节)</p><p>位图<br>B-树<br>堆<br>栈<br>文字量<br>查找表<br>引用完整性<br>树<br>共用体<br>变体</p><ul><li>在声明的时候就进行初始化</li><li>在理想的情况下, 在靠近第一次使用变量的位置声明和定义变量</li><li>多多使用const 吧</li><li>注意计数器和累加器. 这里很久前遇到一个坑 无符号自减可能会下溢</li><li>构造函数中进行初始化</li><li>检查是否需要重新初始化</li><li>检查输入的合法性</li><li>初始化指针建议初始化为 0, 一旦你看到为0的指针越界就知道是没有赋值</li></ul><h2 id="第十一章-变量名的力量"><a href="#第十一章-变量名的力量" class="headerlink" title="第十一章 变量名的力量"></a>第十一章 变量名的力量</h2><ol><li>为循环下标 临时变量命名</li><li>bool变量<br>done-&gt;事情已经完成<br>error-&gt;有错误发生<br>found-&gt;找到<br>success/ok -&gt;某操作已经成功 不是很具体<br>Is前缀可以用在模糊不清的词前, 不过这样也会导致最终表达模糊不清</li><li>标识全局变量 使用 <code>g_</code> 前缀</li><li>标识类型声明 <code>T</code> 前缀</li><li>避免在名字中使用1 2 后缀file_1 file_2</li></ol><h2 id="第十二章-基本数据类型"><a href="#第十二章-基本数据类型" class="headerlink" title="第十二章 基本数据类型"></a>第十二章 基本数据类型</h2><ol><li>避免使用神秘数值 突然出现某个数值 这样一方面不便于修改所有值 一方面防止忘记数值含义</li><li><code>/0</code> 的发生</li><li>防止溢出 这里最常见的就是循环体中了 更尤其是unsigned变量自减的时候</li><li>防范数组越界</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;距离上次什么时候写博客已经记不清了, 看了眼GitHub备份记录 已经25天了. 这25天我咕了吗? 咕是不可能咕的. 这段时间我终于做出了第一个UE4比较完善的联机游戏.&lt;br&gt;学习了更多的muduo自己的mongo也更加完善. 学而不思则罔,思而不学则殆. 只看书写博客
      
    
    </summary>
    
    
      <category term="软件开发" scheme="http://blog.lsmg.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
      <category term="读书记录" scheme="http://blog.lsmg.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>编程规范</title>
    <link href="http://blog.lsmg.xyz/2020/05/CPP-CPP%E9%87%8D%E7%82%B9-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <id>http://blog.lsmg.xyz/2020/05/CPP-CPP%E9%87%8D%E7%82%B9-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</id>
    <published>2020-05-02T09:03:25.194Z</published>
    <updated>2020-03-05T13:58:34.793Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一点</strong><br>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><p><strong>第二点</strong><br>局部变量应当声明和初始化同时进行, 推荐使用C++11的花括号</p><p><em>如果在循环中, 不要将对象的声明放入其中</em>, 每次进入作用域都会调用构造函数, 每次退出都会调用析构函数</p><p><strong>第三点-类相关</strong><br>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p><p>不要定义隐式类型转换. </p><p>对于转换运算符和单参数构造函数, 请使用 explicit 关键字.</p><ul><li>单参数构造函数有可能会被无意地用作隐式类型转换.</li></ul><p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p><ul><li>MyClass(const MyClass&amp;) = delete;</li><li>MyClass&amp; operator=(const MyClass&amp;) = delete;</li></ul><p>仅当<code>只有</code>数据成员的时候<code>struct</code>, <code>其他一律</code>使用class</p><p>使用组合常常比使用继承更合理</p><ul><li>所有的继承<code>必须是public</code>, </li></ul><p>多重继承(真正需要的时候很少)</p><ul><li>最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.</li></ul><p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量</p><ul><li>重载运算符, 容易造成代码混乱, 因为没有统一的重载规范</li></ul><p>数据成员都必须是私有的</p><p><strong>第四点-函数相关</strong></p><p>输入参数在先, 后跟输出参数.</p><p>编写简短函数</p><p>所有按引用传递的参数必须加上 const.</p><p>函数重载</p><ul><li>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,<br>而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</li><li>如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.</li></ul><p>省却参数</p><p>函数返回类型后置语法</p><ul><li><code>auto foo(int x) -&gt; int</code> 对于简单的类型, 优点体现不出</li><li>对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别?????.</li></ul><p><strong>杂项</strong><br>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p><p><strong>第五点命名-版本最多的地方</strong></p><p>文件命名</p><ul><li>全部小写包含<code>_</code>最好</li><li>C++ 文件要以 .cc 结尾, 头文件以 .h 结尾.</li></ul><p>类型名称 - 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数</p><ul><li>类型名称的每个单词首字母均大写, 不包含下划线<code>MyExcitingClass</code></li></ul><p>变量命名</p><ul><li>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾</li></ul><p>常量命名</p><ul><li>全部大写</li><li>声明为 constexpr 或 const</li></ul><p>函数命名</p><ul><li>每个单词首字母大写, 没有下划线</li><li>首字母缩写的单词, 经常对其的第一个字母大写</li></ul><p>命名空间命名</p><ul><li>小写字母命名</li></ul><p>枚举命名</p><ul><li>枚举的命名应当和 常量 或 宏 一致</li></ul><p><strong>第六点-格式</strong></p><p>缩进四个空格</p><p>函数定义与声明</p><ul><li>左圆括号总是和函数名在同一行.(没有标准,,,,,,,,,, emmm 我想我还是换行吧)</li><li>函数名和左圆括号间永远没有空格.</li><li>圆括号与参数间没有空格.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;第一点&lt;/strong&gt;&lt;br&gt;有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. &lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题点带面</title>
    <link href="http://blog.lsmg.xyz/2020/04/CPP-Socket%E7%90%86%E8%AE%BA-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%82%B9%E5%B8%A6%E9%9D%A2/"/>
    <id>http://blog.lsmg.xyz/2020/04/CPP-Socket%E7%90%86%E8%AE%BA-%E9%9D%A2%E8%AF%95%E9%A2%98%E7%82%B9%E5%B8%A6%E9%9D%A2/</id>
    <published>2020-04-11T03:00:20.000Z</published>
    <updated>2020-05-18T04:43:23.817Z</updated>
    
    <content type="html"><![CDATA[<p>马上步入四月中旬了, 自己对于socket理论知识知道的还是不多, 于是想了下可以整理下面试题.</p><p>单纯整理”正确答案”怎么行. 我相信大部分面试题代表的都是某个知识点 某个知识面 或有他的重要实际应用</p><p>部分题目是我自己凭空想出来的, 单独开一篇博客又不是内容足够, 索性放在一起</p><h1 id="基础api相关"><a href="#基础api相关" class="headerlink" title="基础api相关"></a>基础api相关</h1><h2 id="send发送的时候会自动转换字节序"><a href="#send发送的时候会自动转换字节序" class="headerlink" title="send发送的时候会自动转换字节序??"></a>send发送的时候会自动转换字节序??</h2><p>作为开篇问题, 我选了这个. 这个问题也算是困扰了一段时间.<br>网上的解答自然已经有了<br><a href="https://stackoverflow.com/questions/23106938/do-recv-and-send-convert-the-messages-in-network-order-format-automatically" target="_blank" rel="noopener">https://stackoverflow.com/questions/23106938/do-recv-and-send-convert-the-messages-in-network-order-format-automatically</a></p><p>最先接触到socket字节序转换相信大多是<code>htons()</code><br>这个说明是将主机字节序转换成网络字节序, 我使用的自然是小端 将小端转换成大端 反转链表就好<br>而在大端上 头文件自动选择了<code>htons()</code>空命令版本</p><p>起初我使用send发送全是 类似string的东西 char*保存, 单字节数据自然不会受字节序影响</p><p>但是最近学习了moduo后发现了发送数字的实际应用<br>对于一个 <code>int32_t</code>类型的数字需要调用<code>htobe32()</code>转换成<code>大端序</code>然后<code>std::copy</code>到buffer中<br>接收端读取出四个字节 <code>std::copy</code>到<code>int32_t</code>中, 需要调用下<code>be32toh()</code>转换成<code>小端序</code> 这就涉及到了字节序转换</p><p>总结下就是单字节数据比如发送一个字符串 是不会收到字节序影响<br>而如果你直接发送数字比如<code>int32_t</code> 就会受到影响</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;马上步入四月中旬了, 自己对于socket理论知识知道的还是不多, 于是想了下可以整理下面试题.&lt;/p&gt;
&lt;p&gt;单纯整理”正确答案”怎么行. 我相信大部分面试题代表的都是某个知识点 某个知识面 或有他的重要实际应用&lt;/p&gt;
&lt;p&gt;部分题目是我自己凭空想出来的, 单独开一篇博
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="Socket理论" scheme="http://blog.lsmg.xyz/categories/CPP/Socket%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux多线程服务器端编程</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95120-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95120-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-03-31T09:19:39.000Z</published>
    <updated>2020-04-27T05:57:55.667Z</updated>
    
    <content type="html"><![CDATA[<p>Linux高性能服务器编程基本看玩了, 现在需要进行实战练习, 然而从单纯的只会api到做出项目, 之间的距离<br>不是一般的小, 最终我选择了这本书…..</p><p>相关自己写的代码 大部分放在github 少部分会写在博客中</p><h1 id="第一部分-C-多线程系统编程"><a href="#第一部分-C-多线程系统编程" class="headerlink" title="第一部分 C++多线程系统编程"></a>第一部分 C++多线程系统编程</h1><h2 id="第一章-线程安全的对象生命期管理"><a href="#第一章-线程安全的对象生命期管理" class="headerlink" title="第一章 线程安全的对象生命期管理"></a>第一章 线程安全的对象生命期管理</h2><p>一个线程安全的class需要满足的条件</p><ul><li>多个线程同时访问, 其表现出正确的行为</li><li>无论操作系统如何调度这些线程, 无论这些线程的执行顺序如何交织</li><li>调用端代码无需额外的同步或其他协调操作</li></ul><p>对象构造的安全, 在构造期间不要泄露this指针, 如果不按照以下规定可能会早对象构造完成前就被访问</p><ul><li>不要在构造函数中注册任何回调</li><li>不要在构造函数中把this传给跨线程的对象</li><li>即便在构造函数最后一行也不行, 因为对象可能是一个父类, 会先构造父类部分, 再构造子类部分</li></ul><p>二段式构造有时候可以解决上面的问题</p><p>二段式构造-构造函数+initialize()<br>因为构造函数没有办法告知是否构造成功, 如果使用异常处理将会使代码复杂化.<br>比如在构造函数中使用new操作, 如果new操作失败就会出现不可预料的后果, 然后外部却无法知道<br>再比如将this传给其他跨线程对象, 如果构造结束前传入, 可能就会发生问题</p><p><strong>shared_ptr的引出</strong><br>如果在一个对象中通过指针访问资源(另一个对象), 知道这个资源是否活着是很难的.<br>如果简单的判断指针是否为空, 可能会在线程B已经判断了指针不为空还没有执行后续操作时, 线程A就把<br>这个资源释放掉了</p><p>当然可以通过资源管理对象 管理上面的资源, 但是也存在上面的问题.</p><p>所以要想安全的销毁对象最好在其他线程都看不到的情况下偷偷进行. (垃圾回收原理, 所有人用不到的东西一定是垃圾)</p><p>所以可以再资源管理对象中增加引用计数, 外部对象在释放资源管理对象中资源的时候, 只是将引用计数减一, 当引用计数为0的时候 在进行释放.</p><p>C++可能出现的内存问题</p><ul><li>缓冲区溢出<br>使用<code>std::vector&lt;char&gt;/std::string</code>或者自己编写<code>Buffer Class来管理缓冲区</code>. 记住缓冲区长度, 通过成员函数而不是裸指针修改缓冲区</li><li>空悬指针/野指针<br>使用shared_ptr/weak_ptr</li><li>重复释放<br>使用scoped_ptr, 只在对象析构的时候释放一次</li><li>内存泄漏<br>使用scoped_ptr, 对象析构时自动释放内存</li><li>不配对的new[]/delete<br>把new[] 统统替换成std::vector, scoped_array</li><li>内存碎片</li></ul><p>使用智能指针存在的一些问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) :name_(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Register</span><span class="params">(<span class="built_in">std</span>::weak_ptr&lt;Book&gt; book)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        books_.push_back(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckBook</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 锁争用</span></span><br><span class="line">        <span class="comment">// 这里开头上锁 很可能影响其他的函数, 因为这里调用了用户提供的函数, 等待时间可能会非常长</span></span><br><span class="line">        <span class="comment">// 比如Register函数就没有办法在这段时间中插入新的book</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// mutex lock 开头上锁 保护vector</span></span><br><span class="line">        Iterator iter = books_.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != books_.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; <span class="title">obj</span><span class="params">(iter-&gt;lock())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (obj)</span><br><span class="line">            &#123;</span><br><span class="line">                obj-&gt;DoSomething();</span><br><span class="line">                iter++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                iter = books_.erase(iter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 这样就强制要求了Book必须以shared_ptr管理</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::weak_ptr&lt;Book&gt;&gt;::iterator Iterator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在对象的成员变量vector中保存shared_ptr 会导致管理的资源无法被释放, 因为引用计数最少为1.<br>如果保存weak_ptr可能会导致vector只增不减, 因为weak_ptr只管自己管理的资源, 不管自己.<br>通过定制shared_ptr的析构函数可以解决这个问题</p><p>如果将某个类的this指针 bind到一个function对象, 可能在函数调用时传进入一个已经被释放的对象地址<br>建议使用shared_ptr解决上面的问题, 如果想要获得this指针对应的shared_ptr, 可以另类继承<br><code>enable_shared_from_this&lt;T&gt;</code>, 通过在bind函数绑定<code>shared_from_this()返回的shared_ptr</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span>:</span><span class="built_in">std</span>::enable_shared_from_this&lt;BookShelf&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Book对象固然可以销毁, 但是出现了轻微的内存泄漏</span></span><br><span class="line">    <span class="comment">// book_只增不减!!!!. 虽然Book对象销毁了但是book_中依然保存着weak_ptr</span></span><br><span class="line">    <span class="comment">// 所以需要定制析构功能</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; <span class="title">GetBook</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;bookname)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; pbook;</span><br><span class="line">        <span class="comment">// 上锁</span></span><br><span class="line">        <span class="built_in">std</span>::weak_ptr&lt;Book&gt;&amp; wkbook = books_[bookname];</span><br><span class="line">        pbook = wkbook.lock();</span><br><span class="line">        <span class="keyword">if</span> (!pbook)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// pbook.reset(new Book(bookname));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 依然有问题 绑定this指针可能到时候this指向的对象已经不复存在了</span></span><br><span class="line">            <span class="comment">// pbook.reset(new Book(bookname),</span></span><br><span class="line">            <span class="comment">//   std::bind(&amp;BookShelf::DeleteBook, this, std::placeholders::_1));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意shared_from_this不能在构造函数中调用, 因为构造Bookshelf的时候 他还没有</span></span><br><span class="line">            <span class="comment">// 被交给shared_ptr管理</span></span><br><span class="line">            pbook.reset(<span class="keyword">new</span> Book(bookname),</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;BookShelf::DeleteBook, shared_from_this(), <span class="built_in">std</span>::placeholders::_1));</span><br><span class="line"></span><br><span class="line">            wkbook = pbook;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pbook;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteBook</span><span class="params">(Book* book)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (book)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 上锁</span></span><br><span class="line">            books_.erase(book-&gt;GetName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而上面的代码依然有问题<br>依然有个问题. BookShelf的生命期似乎被意外延长了, 他不会短于function对象<br>所以改用weak_pr不就可以了吗</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span>:</span><span class="built_in">std</span>::enable_shared_from_this&lt;BookShelf&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; <span class="title">GetBook</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;bookname)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; pbook;</span><br><span class="line">        <span class="built_in">std</span>::weak_ptr&lt;Book&gt;&amp; wkbook = books_[bookname];</span><br><span class="line">        pbook = wkbook.lock();</span><br><span class="line">        <span class="keyword">if</span> (!pbook)</span><br><span class="line">        &#123;</span><br><span class="line">            pbook.reset(<span class="keyword">new</span> Book(bookname),</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;BookShelf::WkDeleteCallback,</span><br><span class="line">                    <span class="built_in">std</span>::weak_ptr&lt;BookShelf&gt;(shared_from_this()),</span><br><span class="line">                    <span class="built_in">std</span>::placeholders::_1));</span><br><span class="line"></span><br><span class="line">            wkbook = pbook;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pbook;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WkDeleteCallback</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::weak_ptr&lt;BookShelf&gt; wk_shelf, Book* book)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;BookShelf&gt; <span class="title">bookshelf</span><span class="params">(wk_shelf.lock())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (bookshelf)</span><br><span class="line">        &#123;</span><br><span class="line">            DeleteBook(book);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteBook</span><span class="params">(Book* book)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (book)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 上锁</span></span><br><span class="line">            books_.erase(book-&gt;GetName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一章已经读完了, 笔记只有上面那点. 我在学习Linux高性能服务器编程的大二上半年时间照着书边读边写笔记, 然后后来到了大二下我改成了读完一部分后脑中有什么记什么, 重要的地方如果记不清写不出来就去再看一下. 这样花费在记笔记的时间就少了很多, 写出来的笔记更加方便自己阅读.</p><p>第一章部分内容能看懂 真是谢了之前看的那个项目代码, 那个项目中大量使用了智能指针, 我在读哪个项目的代码的时候查了不少的东西, 现在才能看懂第一章的部分东西.<br>然而大部分?的东西感觉还是似懂非懂, 想写又写不出什么来. 我对于智能指针的使用还是过于晚了把.</p><p>第一章看来后续还要读一遍了</p><h2 id="第二章-线程同步精要"><a href="#第二章-线程同步精要" class="headerlink" title="第二章 线程同步精要"></a>第二章 线程同步精要</h2><p><strong>线程同步的四项原则</strong><br>按重要性排列</p><ol><li>最低限度的共享对象, 减少需要同步的场合, <em>不用就不需要同步了nice!!!</em></li><li>使用高级的并发编程构建, 线程池, 队列, 倒计时</li><li>不得已使用底层同步原语时, 只使用非递归的互斥器和条件变量, 慎用读写锁, 不要用信号量</li><li>除了使用atomic整数外, 不要自己编写lock-free代码, 也不要用内核级的同步原语. 不凭空猜测<br>哪种做法性能更好 比如自旋锁和互斥锁</li></ol><p><strong>互斥器 mutex</strong><br>使用mutex的原则</p><ul><li>使用RAII手法封装mutex的创建销毁加锁解锁这四个操作, 不会因异常而忘记解锁</li><li>只使用非递归的mutex即不可重入的mutex<br>容易排查错误 使用递归mutex问题可能出现也可能不出现(可能由于逻辑问题对一个mutex加锁两次), 而使用非递归即可发现错误并改正</li><li>不手工调用lock()和unlock() 函数, <em>一切交给栈上的Guard对象的构造和析构函数负责</em></li><li>Gruad对象的生命期正好等于临界区</li></ul><p>次要原则</p><ul><li>不使用跨进程的mutex, 进程间通信只用TCP sockets</li><li>加锁解锁在同一个线程 不会出现跨线程的操作 (RAII自动保证)</li><li>不忘记解锁(包括各种提前返回和异常抛出) 不重复解锁 均由RAII自动保证</li><li>必要时考虑用PTHREAD_MUTEX_ERRORCHECK来排错</li></ul><p><strong>封装MutexLock MutexLockGuard Condition</strong><br>在Linux高性能服务器编程中 我也看过了封装mutex, 不过当时并没有使用RAII<br>从这里开始算是对RAII(Resource Acquisition Is Initialization)有了了解</p><p><a href="https://zh.cppreference.com/w/cpp/language/raii" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/language/raii</a><br>拥有open()/close()、lock()/unlock()，或 init()/copyFrom()/destroy()成员函数的类是非RAII类的典型例子</p><p>RAII将资源封装入一个类 如MutexLock类</p><ul><li>构造函数请求资源, 建立所有类不变式, 或在无法完成时抛出异常</li><li>析构函数释放资源并绝不抛出异常<br>始终经由RALL类的实例使用满足要求的资源如MutexLockGuard类, 资源需满足</li><li>自身拥有自动存储期或临时生存期</li><li>或具有与自动或临时对象的生存期绑定的生存期</li></ul><p>自己的理解就是经由RAII类生存期管理资源, RAII生存期开始即使用资源,<br>当RAII类生存期结束, RAII类中保存着的资源也自动销毁<br>RAII可以有效防止上面那些成对函数调用前一个后 由于异常抛出提前返回等 后一个函数没有被调用 造成资源状态异常</p><p><strong>线程安全的Singleton实现</strong><br>这个类在 flamingo 中也见到了, 这次是升级版<br>借由pthread_once保证线程安全</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_once(&amp;ponce_, Init);</span><br><span class="line">        <span class="keyword">return</span> *value_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value_ = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_once_t</span> ponce_;</span><br><span class="line">    <span class="keyword">static</span> T *value_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">pthread_once_t</span> Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p><strong>copy-on-write?? copy-on-other-write!!</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; Entry;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Entry&gt; EntryList;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, EntryList&gt; Map;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Map&gt; MapPtr;</span><br><span class="line"></span><br><span class="line">MapPtr data_;</span><br></pre></td></tr></table></figure><p>好的现在数据存储在data_ 中 系统中存在多个读线程和一个写线程 针对data_<br>如果写线程不管不顾 有数据就往data_中写入 出现了读写进程同时访问data_就会出问题.<br>就书中描述来意思来说 不用大刀阔斧的使用读写锁, 能用mutex简单解决为什么要用读写锁.<br>那么如何保证读写安全呢?</p><p>当读进程读的时候 拷贝一次data_ data_的引用计数至少为2.<br>就在这时写进程判断 data_引用计数不为1, 于是拷贝原来指向的map, 然后将data_ reset指向新的map<br>这时data_引用计数变为1 可以正常写了. 而读进程中保存的map拷贝是稍久的 引用计数降为1, 执行完后就自动析构了旧数据</p><p>下面的代码 读部分只在GetData中加锁, 缩小了临界区</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MapPtr <span class="title">GetData</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// binding reference of type ‘MutexLock&amp;’ to ‘const MutexLock’ discards qualifiers</span></span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CustomerData::Query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;custmoner, <span class="keyword">const</span> <span class="built_in">string</span> &amp;stock)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MapPtr data = GetData();</span><br><span class="line">    Map::const_iterator entries = data-&gt;<span class="built_in">find</span>(custmoner);</span><br><span class="line">    <span class="keyword">if</span> (entries != data-&gt;<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FindEntry(entries-&gt;second, stock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CustomerData::Update</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;customer, <span class="keyword">const</span> CustomerData::EntryList &amp;entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!data_.unique())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MapPtr <span class="title">new_data</span><span class="params">(<span class="keyword">new</span> Map(*data_))</span></span>;</span><br><span class="line">        data_.swap(new_data);</span><br><span class="line">        <span class="comment">// sawp后 先前某个线程通过GetData拿到MapPtr 他会读到稍旧的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(data_.unique());</span><br><span class="line">    (*data_)[customer] = entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三章-多线程服务器的适用场合与常用编程模型"><a href="#第三章-多线程服务器的适用场合与常用编程模型" class="headerlink" title="第三章 多线程服务器的适用场合与常用编程模型"></a>第三章 多线程服务器的适用场合与常用编程模型</h2><p>单线程服务器常用的编程模型<br><code>non-blocking IO + IO multiplexing</code> 即为<code>Reactor模式</code><br>程序的基本结构是一个事件循环, 以事件驱动和事件回调的方式实现业务逻辑</p><p>本质的缺点<br>要求事件回调函数必须是非阻塞的, 单线程还阻塞 这还怎么玩…<br>对于涉及网络IO的请求响应式协议, 容易割裂业务逻辑, 使其散布于多个回调函数中</p><p>多线程服务器常用编程模型</p><ol><li>每个请求创建一个线程, 使用阻塞式IO操作</li><li>使用线程池, 同样是阻塞式IO操作</li><li>非阻塞IO + IO多路复用 即Java NIO方法</li><li>领导者追随者等高级模式</li></ol><p>推荐的C++多线程服务器端编程模式为 one (event) loop per thread + thread pool<br>一个线程一个事件循环 + 线程池<br>事件循环用作IO多路复用, 配合非阻塞IO和定时器<br>线程池用作计算, 具体可以是任务队列或生产者消费者队列</p><p>必须使用单线程的场合</p><ul><li>程序可能会fork</li><li>限制程序的CPU占用率 一个线程最多占满一个核心</li></ul><p>适用多线程程序的场景</p><ul><li>有多个CPU可用, 单核机器上多线程没有性能优势</li><li>线程间有共享数据, 否则建议使用 主进程+工作进程 每个进程都是单线程的模型</li><li>共享数据是可以修改的. 如果数据不能修改可以进程间使用共享内存</li><li>事件响应有优先级差异, 防止优先级反转</li><li>程序要有相当的计算量</li><li>利用异步操作</li><li>能享受到增加CPU数目带来的好处</li><li>多线程有有效地划分责任与功能</li></ul><p>后面大部分我都是看看就过去了, 自己没有丝毫经验 也不打算现在细看</p><h2 id="第四章-C-多线程系统编程精要"><a href="#第四章-C-多线程系统编程精要" class="headerlink" title="第四章 C++多线程系统编程精要"></a>第四章 C++多线程系统编程精要</h2><p>学习多线程编程面临的最大思维方式转变</p><ul><li>当前进程随时可能被切出去</li><li>多线程程序中事件的发生顺序不再有全局统一的先后关系</li></ul><p>常用的11个pthreads函数</p><ul><li>pthread_create() pthread_join()</li><li>pthread_mutex_(create/destory/lock/unlock)</li><li>pthread_cond_(create/destory/wait/signal/broadcast)</li></ul><p>多线程系统编程的难点不在于学习线程原语, 而在于理解多线程与现有的C/C++库函数和系统调用的交互关系<br>以进一步学习如何设计并实现线程安全且高效的程序</p><p>pthread_t并不适合作为程序中对线程的标识符</p><ul><li>他可能会同一进程的两个线程相同</li><li>或者是不利于打印</li><li>无法判断其是否非法</li><li>文件系统中没有对应项</li><li>脱离进程便没意义</li></ul><p>推荐使用gettid()作为线程标识符</p><ul><li>任何时刻都是全局唯一的</li><li>类型为pid_t通常为一个小整数利于在日志中打印.</li><li>0就是非法值1, 因为操作系统第一个进程init的pid是1</li><li>在现代Linux中, 他直接表示内核的任务调度id, 容易在/proc文件系统中找到对应项</li><li>在其他系统工具中也容易定位到某一个具体线程, 列如使用top按线程列出任务,<br>便可以找到线程id, 再根据程序日志判断是哪一个具体线程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">extern</span> __thread <span class="keyword">int</span> t_cachedTid;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cacheTid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(t_cachedTid == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cacheTid();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t_cachedTid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line">__thread <span class="keyword">int</span> t_cachedTid = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CurrentThread::cacheTid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t_cachedTid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t_cachedTid = gettid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">gettid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">pid_t</span>&gt;(::syscall(SYS_gettid));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>thread<br>只能修饰POD类型, 不能修饰class类型, 因为无法自动调用构造析构函数. 可以用于修饰全局变量函数内的静态变量.是GCC内置的线程局部存储设施，存取效率可以和全局变量相比。</strong>thread变量每一个线程有一份独立实体，各个线程的值互不干扰.</p><p><strong>builtin_expect<br>这个指令是gcc引入的，作用是允许程序员将最有可能执行的分支告诉编译器。这个指令的写法为：</strong>builtin_expect(EXP, N)。<br>意思是：EXP==N的概率很大. 就图中代码翻译过来就是 <code>t_cachedTid == 0</code>为<code>0(假)</code>, 即为<code>t_cachedTid</code>最可能不是0.</p><ul><li>使用同一个class创建线程, 全局统一. 一般不会为每个网络连接创建线程, 除非并发数与cpu数目相同<br>一个服务程序的线程数目应该与当前负载无关, 而应该有CPU数目有关.</li><li>程序运行期间不要再创建和销毁线程, 最好在初始化的时候创建所有的线程</li></ul><p>线程销毁的方式</p><ul><li>正常死亡, 从线程主函数返回, 线程正常退出</li><li>非正常死亡, 从线程主函数抛出异常或线程触发segfault信号等非法操作</li><li>自杀 调用pthread_exit() 立刻终止线程</li><li>他杀 其他线程调用pthread_cancel() 来强制终止某个线程</li></ul><p>线程只有一种正常死亡方式, 即第一种 其他方法都是错的Java中甚至把相关函数都废弃了</p><p>每个文件描述符只由一个线程操作, 从而解决消息收发的顺序问题, 把一个文件描述符读写分开未必会提高性能. 同时我们不知道epoll_wait阻塞的时候, 其他线程添加新的fd会发生什么. 为了稳妥起见应该把对同一个epollfd的操作放入同一个线程中执行.</p><p><strong>包装文件描述符和连接</strong><br>用Socket对象包装文件描述符<br>所有对此文件描述符的读写操作都通过此对象进行, 对象的析构函数里关闭文件描述符. 这样只要Socket对象还活着 就不会与其他Socket对象有相同的文件描述符, 也就不会发生串话. 包装文件描述符已经见过了, 同样是在flamingo中看到的.</p><p>用Tcpconnection包装连接<br>如果仅仅记住 fd = 8 这样的文件描述符, A线程accept后转身去处理业务B线程把 fd = 8 给关闭了!! 同时accept一个新的fd 同样是8!!. 这时A线程回复就会出现问题. 所以应该持有封装了Socket对象的Tcpconnection, 保证请求处理期间 文件描述符不会被关闭. 或者是持有Tcpconnection的弱引用. 这样就能知道 fd = 8 到底是原来的还是被关闭后新创建的. Tcpconnection对象不能提前销毁, 所以使用了shared_ptr来管理其生存期, 保证不会提前销毁造成串话.</p><h2 id="第五章-高效的多线程日志"><a href="#第五章-高效的多线程日志" class="headerlink" title="第五章 高效的多线程日志"></a>第五章 高效的多线程日志</h2><p>日志库大体分为前端和后端两部分, 两端之间的联系可能简单到只有一个函数<br>大多数感觉都是宏命令</p><p>日志的滚动也很重要 根据文件大小 和 时间 自动创建新的日志文件, 而不是全写入一个文件中</p><p>避免出现正则表达的元字符(列如我最喜欢的<code>&#39;[&#39;和&#39;]&#39;</code>) 便于使用正则表达式查找</p><p>这一章的笔记是在我照着代码实现了简单的相似功能后才写的, 记录一下好的地方<br>大体分为了 LogStream类和Logger类 前者负责通过<code>&lt;&lt;</code>维护LogBuffer缓冲区, 后者做包装提供接口<br>LogBuffer使用了简单的数组作为缓冲区, 使用Append添加内容 维护写指针</p><p>LogStream重载了多种 参数情况, char和char* 很方便写入到缓冲区中<br>数字则需要转化成字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(short num);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> short num);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">int</span> num);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> num);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">long</span> num);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> <span class="keyword">long</span> num);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">long</span> <span class="keyword">long</span> num);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> num);</span><br><span class="line"></span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">char</span> str);</span><br><span class="line">LogStream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">const</span> <span class="keyword">char</span>* str);</span><br></pre></td></tr></table></figure><p>转化函数, 不得不说设计的真好. 通过模板解决了多种数字类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> digits_character[] = <span class="string">"0123456789"</span>;</span><br><span class="line"><span class="comment">// LEARN https://www.drdobbs.com/flexible-c-1-efficient-integer-to-string/184401596</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">Convert</span><span class="params">(<span class="keyword">char</span> buff[], T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T i = value;</span><br><span class="line">    <span class="keyword">char</span>* p = buff;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> lsd = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(i % <span class="number">10</span>);</span><br><span class="line">        i /= <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// *p++ = '0' + lsd; 不高效</span></span><br><span class="line">        *p++ = digits_character[lsd];</span><br><span class="line">    &#125; <span class="keyword">while</span> (i != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *p++ = <span class="string">'-'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *p = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LEARN 原文中是从buff最后一个字节开始写入 但是这里需要从开头写入 所以改为倒置一下</span></span><br><span class="line">    <span class="built_in">std</span>::reverse(buff, p);</span><br><span class="line">    <span class="keyword">return</span> p - buff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LogStream::FormatInteger</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer_.WriteableBytes() &gt; MAX_NUMBER_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> len = Convert(buffer_.WritePeek(), t);</span><br><span class="line">        buffer_.MoveWritePeek(len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将格式化也单独出了一个类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fmt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    Fmt(<span class="keyword">const</span> <span class="keyword">char</span>* fmt, T val);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetData</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buff_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetLength</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> buff_[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">size_t</span> length_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Fmt::Fmt(<span class="keyword">const</span> <span class="keyword">char</span>* fmt, T val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_arithmetic&lt;T&gt;::value == <span class="literal">true</span>, <span class="string">"Must be arithmetic type"</span>);</span><br><span class="line">    length_ = <span class="built_in">snprintf</span>(buff_, <span class="keyword">sizeof</span> buff_, fmt, val);</span><br><span class="line">    assert(length_ &lt; <span class="keyword">sizeof</span> buff_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Logger类的设计<br>方便了日志的打印, 实现了高效的转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> LogLevel</span><br><span class="line">&#123;</span><br><span class="line">    DEBUG,</span><br><span class="line">    INFO,</span><br><span class="line">    WARN,</span><br><span class="line">    ERROR,</span><br><span class="line">    FATAL,</span><br><span class="line">    NUM_LOG_LEVELS <span class="comment">/* 仅用于表示LogLevel元素个数 不做实际使用 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// LEARN 处处保持长度一致 使用NUM_LOG_LEVELS表示大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* LogLevelName[Logger::NUM_LOG_LEVELS] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"DEBUG "</span>,</span><br><span class="line">    <span class="string">"INFO  "</span>,</span><br><span class="line">    <span class="string">"WARN  "</span>,</span><br><span class="line">    <span class="string">"ERROR "</span>,</span><br><span class="line">    <span class="string">"FATAL "</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>字符串指针包装类, 减少strlen的调用 或者字符串没有终止</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LEARN 临时包装字符串指针和长度</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    T(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">size_t</span> len):</span><br><span class="line">    str_(str),</span><br><span class="line">    len_(len)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(<span class="built_in">strlen</span>(str) == len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str_;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> len_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用内部类Impl包装了LogStream LogStream负责的是单纯的维护缓冲区 重载各种运算符.<br>Impl的构造函数输出了日志前边的固定部分<br>Logger的构造函数负责根据有无函数名等重载输出额外的固定内容<br>构造和析构之间完成 纯用户自定义部分输出<br>Logger的析构函数负责输出每条日志的结尾部分 文件名和行号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Logger::LogLevel LogLevel;</span><br><span class="line">    Impl(LogLevel level, <span class="keyword">const</span> SourceFile&amp; file, <span class="keyword">int</span> <span class="built_in">line</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FormatTime</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Timestamp time_;</span><br><span class="line">    LogStream stream_;</span><br><span class="line">    LogLevel level_;</span><br><span class="line">    SourceFile filename_;</span><br><span class="line">    <span class="keyword">int</span> line_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内部类SourceFile负责将<code>__FILE__</code>宏产生的字符数组转换成单纯的文件名. 使用了数组引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SourceFile</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 数组的引用 使数组在传参时不会降为 指针</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">int</span> N&gt;</span><br><span class="line">    SourceFile(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;arr)[N]):</span><br><span class="line">    data_(arr),</span><br><span class="line">    size_(N - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="built_in">strrchr</span>(data_, <span class="string">'/'</span>); <span class="comment">/* /name */</span></span><br><span class="line">        <span class="keyword">if</span> (name)</span><br><span class="line">        &#123;</span><br><span class="line">            data_ = name + <span class="number">1</span>;</span><br><span class="line">            size_ -= <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(data_ - arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* data_;</span><br><span class="line">    <span class="keyword">int</span> size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其他高效设计</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LEARN 缓存上一次输出的秒 同一秒输出时避免多次格式化</span></span><br><span class="line"><span class="comment">// 同一秒输出仅仅格式化 微秒部分</span></span><br><span class="line">__thread <span class="keyword">char</span> t_time[<span class="number">64</span>];</span><br><span class="line">__thread <span class="keyword">time_t</span> t_last_second;</span><br></pre></td></tr></table></figure><h1 id="第二部分-muduo网络库"><a href="#第二部分-muduo网络库" class="headerlink" title="第二部分 muduo网络库"></a>第二部分 muduo网络库</h1><h2 id="第六章-muduo网络库简介"><a href="#第六章-muduo网络库简介" class="headerlink" title="第六章 muduo网络库简介"></a>第六章 muduo网络库简介</h2><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/ClassDiagram.png" alt=""></p><p>看完前面的一小部分, 我真心觉得这个库跟之前那个flamingo特别像, 估计这种管理方式就是某种主流方式?<br>估计我以后自己写的时候也是会按照这个模式来写了吧</p><p>TCP网络编程最本质的是处理三个半事件</p><ul><li>连接的建立</li><li>连接断开 主动断开close 被动断开 read返回0</li><li>消息到达, 文件描述符可读. 最为重要的一个事件, 对它的处理方式决定了网络编程的风格.(阻塞还是非阻塞, 如何处理分包, 应用层缓冲如何设计)</li><li>消息发送完毕 这算半个</li></ul><p>现在存在的问题</p><ul><li>如果保证发送完应用层缓冲区数据才断开连接<br>自己思考的可以设立标志位, 如果设置了标志位发送完成后检测标志位 关闭连接</li><li>如果要主动发起连接, 但是对方主动拒绝, 如何定期重试<br>按照TCP重试机制 发送SYN 开启定时器 如果定时内没有收到确认ACK则重发SYN</li></ul><p>这里了解到一个词 前向声明,<br>在程序设计中，前向声明（Forward Declaration）是指声明标识符(表示编程的实体，如数据类型、变量、函数)时还没有给出完整的定义。<br>通常为了简化头文件的关系 可以在A的头文件中 声明<code>class B</code>, 这样在你的代码中就可以使用<code>B*</code>而不需要引入B的头文件</p><h2 id="第七章-muduo编程示例"><a href="#第七章-muduo编程示例" class="headerlink" title="第七章 muduo编程示例"></a>第七章 muduo编程示例</h2><p>本章大部分都是实战小例子, 自然要在代码中注释了.<br>博客这里就简单写一写<br><strong>关于<code>input buffer</code>和<code>output buffer</code>已经有所了解过</strong></p><p><code>output buffer</code>在<code>write</code>调用一次没有发送完全的时候起到大用途. 一次没有发送完不应该等待在那里, 应该是接管这些未发送的数据, 阻塞代价是很大的. 应该是注册<code>EPILOUT</code>事件, 直到数据全部发送完毕. 否则就一直注册事件, 当然这是在连接正常的时候.<br>使用<code>output buffer</code>还有一个小问题, 一般情况下一次发送未完成才会使用到<code>output buffer</code>. 当缓冲区中存在数据的时候. 下一次的数据不能进行发送, 而应该是直接追加到尾部.</p><p><code>input buffer</code>某种意义上作用更大, 这涉及到一个重要概念”粘包”的处理. </p><p>这里我了解到了<code>capacity()</code>机制, 可以用来减少内存分配次数. <code>capacity()</code>代表预分配的内存大小,<br>而<code>size()</code>是你写入的数据大小, 当<code>size == capacity</code>的时候<code>再写入内容</code>内存会分配更长的一个数组将旧数据拷贝过去<code>size()</code>依然是你写入的大小, <code>capacity()</code>则会变大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">buff</span><span class="params">(<span class="number">20</span>)</span></span>; <span class="comment">// 填充了20个元素 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    buff.resize(<span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld %ld\n"</span>, buff.<span class="built_in">size</span>(), buff.capacity());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld %ld\n"</span>, buff.<span class="built_in">size</span>(), buff.capacity()); <span class="comment">// 20 20</span></span><br><span class="line">    Foo(<span class="number">512</span>); <span class="comment">// 512 512</span></span><br><span class="line">    Foo(<span class="number">1024</span>); <span class="comment">// 1024 1024</span></span><br><span class="line">    Foo(<span class="number">1025</span>); <span class="comment">// 1025 2048</span></span><br><span class="line">    Foo(<span class="number">2048</span>); <span class="comment">// 2048 2048</span></span><br><span class="line">    Foo(<span class="number">2049</span>); <span class="comment">// 2049 4096</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>花了小半天时间去了解配置了下 protobuf, 是一把很锋利的剑不错!</p><p>网络编程中使用protobuf的两个先决条件</p><ul><li>长度问题, protobuf打包的数据没有自带长度信息或终结符, 这就需要程序自己在发送和接受的时候做正确的切分</li><li>类型问题, protobuf打包的数据没有自带类型信息, 需要由发送方把类型信息传给接收方, 接收方创建对应的具体protobuf message对象, 再做反序列化</li></ul><p>我第一印象解决上面的方法, 就如书中所言是山寨的做法…. 增加header部分</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/protobuf%20class.png" alt="Protobuf类图"></p><p>大概意思就是大部分人通过在头部增加代号标识消息类型(具体对应那个message), 而protobuf提供了<br>根据反射 根据typename 选择对应的Message对象的功能, 由于我没有用过protobuf 目前不是很了解 不过大概就这样了, 后续会专门学习 先用即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eg typename=muduo.Query</span></span><br><span class="line">google::<span class="function">protobuf::Message* <span class="title">ProtobufCodec::createMessage</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; typeName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    google::protobuf::Message* message = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">const</span> google::protobuf::Descriptor* descriptor =</span><br><span class="line">        google::protobuf::DescriptorPool::generated_pool()-&gt;FindMessageTypeByName(typeName);</span><br><span class="line">    <span class="keyword">if</span> (descriptor)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> google::protobuf::Message* prototype =</span><br><span class="line">            google::protobuf::MessageFactory::generated_factory()-&gt;GetPrototype(descriptor);</span><br><span class="line">        <span class="keyword">if</span> (prototype)</span><br><span class="line">        &#123;</span><br><span class="line">            message = prototype-&gt;New(); <span class="comment">// 返回的是动态创建的指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;google::protobuf::Message&gt; MessagePtr;</span><br><span class="line">MessagePtr message;</span><br><span class="line">message.reset(createMessage(typeName)); <span class="comment">// 接管指针</span></span><br></pre></td></tr></table></figure><p>作者设计的格式如下<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/protobuf%E4%BC%A0%E8%BE%93%E6%A0%BC%E5%BC%8F.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// int32_t version; 根本不需要版本号</span></span><br><span class="line">    <span class="keyword">int32_t</span> len; <span class="comment">// 没有使用uin32_t 是为了跨语言, Java没有unsigned</span></span><br><span class="line">    <span class="keyword">int32_t</span> namelen;</span><br><span class="line">    <span class="keyword">char</span> type_name[namelen]; <span class="comment">// 以 /0 结尾 方便接收方处理 节省strlen() 空间换时间</span></span><br><span class="line">    <span class="keyword">char</span> protobuf_data[len-namelen<span class="number">-8</span>]</span><br><span class="line">    <span class="keyword">int32_t</span> checksum; <span class="comment">// adler32算法 进行校验</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于知道编码器解码器合起来叫什么了… 编解码器(codec)</p><p>后面的一些例子就跳过了, 去准备阅读第八章然后动手写库了 这里才是重点 至于例子当时候自己再写.<br>自己的库不香吗?</p><h2 id="第八章-muduo网路库设计与实现"><a href="#第八章-muduo网路库设计与实现" class="headerlink" title="第八章 muduo网路库设计与实现"></a>第八章 muduo网路库设计与实现</h2><p><del>第八章从第0节开始 一看就是程序员</del></p><p>2020年4月27日11:02:12 距离写完上一行博客已经过去不短的时间了.<br>这段时间我仿照muduo从中抽了部分功能做了自己的mongo库, 然后我将muduo Protobuf作为附属<br>改成了ProtobufServer(包装了TcpServer).</p><p>之后我便重新编写UE4部分的Protobuf收发部分的代码.<br>昨天晚上总算是将UE4打飞机的单机版 成功改造成了联机版. 使用的帧同步<br>服务器稳定性极佳, 而且内存占用很低, 想到了我之前写的Java服务器. 服务器CPU性能占用极少.</p><p>初期设计的时候 单机每秒发送12包, 每包平均0.16kb. 单机每秒就是2kb.  如果有6个客户端<br>服务器算上广播 出站流量 72kb/s</p><p>跑了下iftop看了下基本是这样.<br>12*6 = 72kb/s</p><p>阿里云送的服务器1Mbps, 理论可以支持8个客户端同屏游戏<br>阿里云学生机5Mbps, 理论支持17个客户端同屏游戏</p><p>当然了现在只同步了输入, 不过其他同步内容消耗的流量就很少了.</p><p>服务器程序运行良好, 倒是UE4 偶尔会崩….</p><p>后面慢慢完善打飞机和服务器</p><p>使用框架很简单的就实现了 登录和游玩数据分开 很舒服. 当然了登录目前只是个摆设没有在服务端保存<br>跳过登录依然可以玩, 后面完善db服务器再说</p><h1 id="第三部分-工程实践经验谈"><a href="#第三部分-工程实践经验谈" class="headerlink" title="第三部分 工程实践经验谈"></a>第三部分 工程实践经验谈</h1><h2 id="第九章-分布式-跳过"><a href="#第九章-分布式-跳过" class="headerlink" title="第九章 分布式 跳过"></a>第九章 分布式 跳过</h2><h2 id="第十章-C-编译链接模型精要"><a href="#第十章-C-编译链接模型精要" class="headerlink" title="第十章 C++编译链接模型精要"></a>第十章 C++编译链接模型精要</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux高性能服务器编程基本看玩了, 现在需要进行实战练习, 然而从单纯的只会api到做出项目, 之间的距离&lt;br&gt;不是一般的小, 最终我选择了这本书…..&lt;/p&gt;
&lt;p&gt;相关自己写的代码 大部分放在github 少部分会写在博客中&lt;/p&gt;
&lt;h1 id=&quot;第一部分-C-
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Shell脚本编写</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</id>
    <published>2020-03-26T09:30:22.000Z</published>
    <updated>2020-03-26T10:51:22.857Z</updated>
    
    <content type="html"><![CDATA[<p>由于阿里云服务器github速度异常缓慢, 自己想把一个shell, 改成本地版本发现不是很容易.<br>所以咕咕咕很久的shell脚本, 算是开始学了. 感觉入门应该不会太难把</p><p>我先来我最喜欢的入门网站 菜鸟教程!</p><p>既然写的是脚本就需要解释器了</p><ol><li><code>#!/bin/bash</code> 这个通常见于脚本的第一行, <code>#!</code>算是个约定了 说明脚本需要什么解释器</li><li><code>/bin/sh xx.sh</code> 这种是执行的时候指定, 脚本第一行的那个就失效了</li></ol><p><strong>shell变量-挺正常的规定</strong></p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><p>shell变量类型</p><ul><li>局部变量</li><li>环境变量</li><li>shell变量-shell内置特殊变量</li></ul><p>变量定义 <em>注意 不能随便加空格 下面的等号两侧不能加空格</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接赋值</span></span><br><span class="line">xxx="lsmg"</span><br><span class="line">xxx = "lsmg" # 错误</span><br><span class="line">xxx="Jigokubana" # 随意修改</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 语句赋值</span></span><br><span class="line">for skill in Ada Coffe Action Java; do</span><br><span class="line">    echo "I am good at $&#123;skill&#125;Script"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用变量</span></span><br><span class="line">echo $xxx</span><br><span class="line">echo $&#123;xxx&#125; # &#123;&#125; 用于标记边界</span><br><span class="line">echo "my name is $&#123;xxx&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> const</span></span><br><span class="line">readonly xxx="lsmg" </span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash"> 删除变量</span></span><br><span class="line">unset xxx; 不能用于删除只读变量</span><br></pre></td></tr></table></figure><p>单双引号字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> shell 双引号字符串</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 可以含有转义字符 和变量</span></span></span><br><span class="line">xxx1="\"lsmg\""</span><br><span class="line">echo xxx1 # $ "lsmg"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> shell单引号字符串</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 会原样输出, 无视变量. 即使转义也不能出现单一的单引号 但可以成对出现 用于拼接字符串</span></span></span><br><span class="line">xxx2='lsmg' </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拼接双引号变量双引号输出 单引号变量单引号输出</span></span><br><span class="line">your_name="runoob"</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 使用双引号拼接</span></span></span><br><span class="line">greeting="hello, "$your_name" !"</span><br><span class="line">greeting_1="hello, $&#123;your_name&#125; !"</span><br><span class="line">echo $greeting  $greeting_1 # hello, runoob ! hello, runoob !</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 使用单引号拼接</span></span></span><br><span class="line">greeting_2='hello, '$your_name' !'</span><br><span class="line">greeting_3='hello, $&#123;your_name&#125; !'</span><br><span class="line">echo $greeting_2  $greeting_3 # hello, runoob ! hello, $&#123;your_name&#125; !</span><br></pre></td></tr></table></figure><p>字符串操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">url="https://blog.lsmg.xyz"</span><br><span class="line"></span><br><span class="line">echo $&#123;#url&#125; # 输出长度 21</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意单引号</span></span><br><span class="line">echo `expr index "$url" go` # 输出 字符 g o的位置 哪个先出现就输出哪个</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 字符串截取</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 范围截取</span></span></span><br><span class="line">echo #&#123;url:0:5&#125; # 输出 https 第二个数字代表字符个数 不是范围</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># #截取删除左边字符, 保留右侧字符</span></span></span><br><span class="line">echo #&#123;url#*//&#125; # blog.lsmg.xyz</span><br></pre></td></tr></table></figure><p>数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 空格分隔</span></span><br><span class="line">name=(lsmg Lsmg Jigokubana);</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 你甚至可以 不连续定义</span></span><br><span class="line">nickname[0]=lsmg</span><br><span class="line">nickname[2]=Lsmg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取</span></span><br><span class="line">echo $&#123;nickname[0] nickname[1] nickname[2]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出所有</span></span><br><span class="line">echo $&#123;name[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取得数组元素个数</span></span><br><span class="line">echo $&#123;#name[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取得单个元素长度</span></span><br><span class="line">echo $&#123;#name[1]&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于阿里云服务器github速度异常缓慢, 自己想把一个shell, 改成本地版本发现不是很容易.&lt;br&gt;所以咕咕咕很久的shell脚本, 算是开始学了. 感觉入门应该不会太难把&lt;/p&gt;
&lt;p&gt;我先来我最喜欢的入门网站 菜鸟教程!&lt;/p&gt;
&lt;p&gt;既然写的是脚本就需要解释器了
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Shell" scheme="http://blog.lsmg.xyz/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>EPOLL本质</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-EPOLL%E6%9C%AC%E8%B4%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-EPOLL%E6%9C%AC%E8%B4%A8/</id>
    <published>2020-03-25T09:35:20.000Z</published>
    <updated>2020-03-25T10:24:04.340Z</updated>
    
    <content type="html"><![CDATA[<p>EPOLL本质是什么?  <del>本质当然是复读机</del></p><p>参考和图片来源<br><a href="https://zhuanlan.zhihu.com/p/64138532" target="_blank" rel="noopener">如果这篇文章说不清epoll的本质，那就过来掐死我吧！</a></p><p>一个socket对应一个端口号, 网络数据包中包含了端口, 内核可以通过端口号找到对应的socket</p><p><strong>select的不足</strong><br>select需要遍历两次socket列表, 第一次遍历用于将进程加入到所有socket的等待队列<br>第二次遍历是每次唤醒都需要将进程从每个socket等待队列移除<br>由于遍历开销大, 所以才规定了select最大的监视数量</p><p><strong>功能分离</strong><br><img src="https://pic2.zhimg.com/80/v2-5ce040484bbe61df5b484730c4cf56cd_720w.jpg" alt=""><br>select将 <code>维护等待队列</code> 和 <code>阻塞进程</code>两个步骤合二为一, 每次select都需要这两部操作, 然而socket并不需要每次都修改<br>epoll将操作分开, 使用epoll_ctl维护等待队列, 使用epoll_wait阻塞进程</p><p><strong>就绪队列</strong><br>select不知道哪些socket接收到了数据, 只能一个个遍历.<br>如果内核维护一个”就绪队列” 引用存储事件就绪的socket, 进程唤醒后获取”就绪队列”就能够知道<br>哪些socket接收到数据</p><p><strong>epoll_create创建了什么?</strong><br>创建了一次eventpoll对象, epollfd正是他所代表的对象. 由于epollfd也是文件系统一员也存在等待队列</p><p>select将进程加入到每个socket的等待队列, 而epoll将进程加入到了eventpoll的等待队列 只加入了一次.</p><p><strong>epoll_ctl修改了什么</strong><br>epoll_ctl将 eventpoll添加到sockfd的等待队列中</p><p>当socket接收到数据后, 中断程序会操作eventpoll对象, 而不是直接操作进程(socket的等待队列中就是eventpoll)</p><p><strong>接收数据</strong><br>socket接收到数据后, 中断程序会给epollpoll的<code>就绪列表</code>添加socket的引用.</p><p>这样socket就不会直接影响进程, 而是通过改变eventpoll的<code>就绪列表</code>来改变进程状态</p><p><strong>epoll_wait</strong><br>当程序执行到epoll_wait后如果<code>就绪队列</code>已经有socket引用就会返回, 如果为空就阻塞进程</p><p><strong>阻塞和唤醒进程</strong><br>进程被添加到了eventpoll的等待队列中, socket接收到数据后, 中断程序一方面修改<code>就绪队列</code>一方面唤醒<br>eventpoll等待队列的进程, 由于<code>就绪队列</code> 进程便知道哪些socket发生变化</p><p><strong>实现细节</strong><br>eventpoll的数据结构是双向链表, 能够快速的插入和删除的数据结构</p><p>就绪队列的数据结构是红黑树, 方便添加删除检索避免重复添加.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;EPOLL本质是什么?  &lt;del&gt;本质当然是复读机&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;参考和图片来源&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64138532&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如果这篇文章说
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="Socket理论" scheme="http://blog.lsmg.xyz/categories/CPP/Socket%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP状态机</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-TCP%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-TCP%E7%8A%B6%E6%80%81%E6%9C%BA/</id>
    <published>2020-03-25T04:55:20.000Z</published>
    <updated>2020-04-08T01:46:19.020Z</updated>
    
    <content type="html"><![CDATA[<ul><li>待补充 双向管道的建立和断开细节</li><li>异常三次握手</li><li>异常四次挥手</li></ul><p><a href="https://blog.csdn.net/q1007729991/article/details/69675752" target="_blank" rel="noopener">资料参考TCP 协议状态机</a></p><p><a href="https://blog.csdn.net/randyjiawenjie/article/details/6397477" target="_blank" rel="noopener">TCP有限状态机分析</a></p><p>Tcp状态图, 虚线代表客户端 实线代表服务器<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP/Socket%E7%90%86%E8%AE%BA/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt=""></p><p>正常的连接建立还是比较容易理解的</p><p>说一下从<code>CLOSE_WAIT</code>到<code>LAST_ACK</code><br>当被动关闭方<code>B</code>接收到<code>FIN</code>后知道对方<code>A</code>要关闭连接, <code>B</code>回复一个<code>ACK</code>给<code>A</code></p><ol><li>如果此时<code>B</code>没有额外要发送的数据就给<code>A</code>, 就发送<code>FIN</code>告知<code>A</code>自己也要关闭了, 然后<code>B</code>进入<code>LAST_ACK</code></li><li>如果此时<code>B</code>有额外信息要发送等发送完毕后. 这时<code>B</code>发送一个<code>FIN</code>告知<code>A</code>然后B进入<code>LAST_ACK</code></li></ol><p>再说一下从<code>FIN_WAIT_1</code>到<code>TIME_WAIT</code></p><ol><li>直接从<code>FIN_WAIT_1</code>到<code>TIME_WAIT</code>, 这个对应上面的第一种情况, 由于<code>B</code>没有额外信息发送直接发送了<code>FIN和ACK</code>, 这时<code>A</code>再发送一个<code>ACK</code>, 进入<code>TIME_WAIT</code></li><li>经过中转状态<code>FIN_WAIT2</code>对应上面第二种情况, 由于<code>B</code>有额外信息发送, 只发送了<code>ACK</code>, 这时<code>A</code>还可以接受数据, 直到<code>B</code>发来<code>FIN</code>然后<code>A</code>发送<code>ACK</code>进入<code>TIME_WAIT</code></li></ol><p>再说一下<code>TIME_WAIT</code>状态<br>主动关闭方<code>A</code>最后发送了<code>ACK</code>确认被动关闭方<code>B</code>的<code>FIN</code>.<br>但是如果这个<code>ACK</code>由于各种原因<code>B</code>没有收到, 所以<code>B</code>会再次发送<code>FIN</code>. 然后<code>A</code>会在<code>2MSL</code>时间内接受到这个<code>FYN</code>, 之后<code>A</code>再次回复一个<code>ACk</code>.计时器重置<code>2MSL</code>时间, 重复上面过程. 直到<code>2MSL</code>时间内<code>A</code>没有收到<code>FIN</code>,说明<code>B</code>已经收到了.则结束连接</p><p><code>2MSL</code>指的是两个<code>MSL</code>时间 单个指的是一个片段在网络中的最大存活时间,<br>A发送的<code>ACK</code>可能消耗一个, B重新发送的<code>FIN</code>可能也要消耗一个.最大两个</p><p>复位报文段</p><ul><li>客户端访问不存在的端口， 服务器会发送带RST标志的复位报文段</li><li>异常终止连接， 发送复位报文段</li><li>客户端或服务端向半打开状态(对方异常终止连接, 但是本方没有收到结束报文)的连接写入数据, 对方回复会一个复位报文段</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;待补充 双向管道的建立和断开细节&lt;/li&gt;
&lt;li&gt;异常三次握手&lt;/li&gt;
&lt;li&gt;异常四次挥手&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/q1007729991/article/details/69675752&quot;
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="Socket理论" scheme="http://blog.lsmg.xyz/categories/CPP/Socket%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Send返回值引出的(非)阻塞IO</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-Send%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8E%A2%E6%9E%90/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-Send%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8E%A2%E6%9E%90/</id>
    <published>2020-03-20T03:14:20.000Z</published>
    <updated>2020-03-20T04:20:31.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现存疑问"><a href="#现存疑问" class="headerlink" title="现存疑问"></a>现存疑问</h1><ol><li>WNOWAIT和O_NONBLOCK 的关系?</li><li>当非阻塞send时, 返回值与什么有关? 本地socket发送缓冲区空余还是对端空余?</li><li>对端接收缓冲区满了会发生什么?</li><li>暂且认为send返回值是拷贝到缓冲区中的字节数, 如果这些数据没有成功发送呢?</li><li>send函数发送的字节数 超出了recv端的接受能力 会发生什么?</li></ol><p>最近这两天在实战一个http服务器的编写.</p><p>遇到了一个问题: send的返回值小于传入的len, 因为我仅调用一次send函数 导致页面一直显示加载</p><p>然后找了下为什么? 什么时候? send返回值会小于len;</p><h1 id="send"><a href="#send" class="headerlink" title="send"></a>send</h1><p><a href="https://stackoverflow.com/questions/14700906/socket-programming-send-return-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/14700906/socket-programming-send-return-value</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In practice, send() in blocking mode sends all the data, regardless of what the documentation says, unless there was an error, in which case nothing is sent.</span><br><span class="line">实战中, send() 处于阻塞状态会发送所有的数据, 除非发生错误 但这会导致数据没有发送</span><br><span class="line"></span><br><span class="line">In non-blocking mode, it sends whatever will fit into the socket send buffer and returns that length if &gt; 0. If the socket send buffer is full, it returns -1 with errno &#x3D; EWOULDBLOCK&#x2F;EAGAIN.</span><br><span class="line">在非阻塞模式下, 只要能放入socket发送缓冲区 就返回放入的长度 如果缓冲区满了就返回-1 设置EWOULDBLOCK&#x2F;EAGAIN</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247486643&idx=1&sn=9db678398f390759ff81b354ef056000&chksm=fc70f75fcb077e49363b087ba45609fdfbcba286338e70c2d4c7092e83e2d3feac56455e02a2&scene=27#wechat_redirect" target="_blank" rel="noopener">非阻塞模式下 send 和 recv 函数的返回值</a></p><p>这篇博客里也说明了这个问题. 下面是原博客的代码稍作修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐的方式二：在一个循环里面根据偏移量发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* buf , <span class="keyword">int</span> buf_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//已发送的字节数目</span></span><br><span class="line">    <span class="keyword">int</span> sent_bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = send(fd, buf + sent_bytes, buf_length - sent_bytes, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;             </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//认为对端关闭了连接</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sent_bytes += ret;</span><br><span class="line">        <span class="keyword">if</span> (sent_bytes == buf_length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//稍稍降低 CPU 的使用率</span></span><br><span class="line">        usleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;现存疑问&quot;&gt;&lt;a href=&quot;#现存疑问&quot; class=&quot;headerlink&quot; title=&quot;现存疑问&quot;&gt;&lt;/a&gt;现存疑问&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;WNOWAIT和O_NONBLOCK 的关系?&lt;/li&gt;
&lt;li&gt;当非阻塞send时, 返回值与什么有关? 本地
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="Socket理论" scheme="http://blog.lsmg.xyz/categories/CPP/Socket%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux的使用</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-17T04:29:20.000Z</published>
    <updated>2020-03-17T04:56:16.103Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>cp -r</td><td>复制目录</td></tr><tr><td>cd -</td><td>切换到上一个工作目录</td></tr></tbody></table><table><thead><tr><th>查找</th><th>功能</th></tr></thead><tbody><tr><td>find ./ -name “core*”</td><td>xargs file</td></tr><tr><td>find ./ -name ‘*.o’</td><td>查找目标文件夹是否有obj文件</td></tr><tr><td>find ./ -name “*.o” | xargs rm -f</td><td>递归删除当前目录所有obj文件</td></tr></tbody></table><table><thead><tr><th>查看文件内容</th><th>功能</th><th>一般用法</th></tr></thead><tbody><tr><td>cat -n</td><td>显示的同时显示行号</td><td>使用管道 ls | cat -n</td></tr><tr><td>head -10 filename</td><td>查看前十行</td><td></td></tr><tr><td>tail -10 failname</td><td>查看后十行</td><td></td></tr><tr><td>diff file1 file2</td><td>查看文件差别</td><td></td></tr><tr><td>tail -f filename</td><td>动态显示文本的最新信息</td><td></td></tr></tbody></table><p>| 给文件增加别名 | 功能 |<br>| ln a b | 创建硬链接, 删除一个另一个仍能使用 |<br>| ln -s a b | 创建符号链接(软连接) 删除源后另一个无法使用 |</p><p>命令行快捷键<br>Ctl-U   删除光标到行首的所有字符 <code>$ 1111 222  --&gt; $</code><br>Ctl-W   删除光标到前边最近一个空格之间的字符 <code>$ 1111 222 --&gt; $ 1111</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;cp -r&lt;/td&gt;
&lt;td&gt;复制目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cd -&lt;/td&gt;
&lt;td&gt;切换到上一个工作目录
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>UNP卷二读书记录</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95115-UNP%E5%8D%B7%E4%BA%8C/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95115-UNP%E5%8D%B7%E4%BA%8C/</id>
    <published>2020-03-15T03:16:20.000Z</published>
    <updated>2020-03-21T01:23:03.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h1><h2 id="管道和有名管道FIFO"><a href="#管道和有名管道FIFO" class="headerlink" title="管道和有名管道FIFO"></a>管道和有名管道FIFO</h2><p><strong>popen pclose</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 成功返回文件指针, 出错为NULL</span></span><br><span class="line"><span class="function">FILE* <span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line">FILE* fp = popen(command, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功为shell终止状态, 出错则为 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">pclose(fp);</span><br></pre></td></tr></table></figure><p>popen创建一个管道并启动另外一个进程 创建者要么从管道读出标准输入, 要么将标准输出写到管道<br>返回的文件指针作用<br>通过type参数控制<br>type = “r” 创建者 通过文件指针读入command命令产生的标准输出<br>type = “w” 创建者 通过文件指针为command命令提供标准输入</p><p>pclose 关闭这个标准IO流</p><p><strong>FIFO 先进先出(first in, first out)</strong></p><p>又称为有名管道(named pipe) 单向(半双工)数据流, 每个FIFO都有一个路径名与之对应.<br>从而允许无亲缘关系的进程访问同一个FIFO</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回 0 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> FIFO1 = <span class="string">"/tmp/fifo.1"</span>;</span><br><span class="line">mkfifo(FIFO1, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建之后需要打开来进行读或者写 可以使用open也可以使用其他标准IO打开函数</span></span><br><span class="line"><span class="keyword">int</span> writefd = <span class="built_in">open</span>(FIFO1, O_WRONLY, <span class="number">0</span>); <span class="comment">/* 在父进程中打开 父进程写 */</span></span><br><span class="line"><span class="keyword">int</span> readfd = <span class="built_in">open</span>(FIFO1, O_RDONLY, <span class="number">0</span>); <span class="comment">/* 在子进程中打开 子进程读 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有调用unlink才能从文件系统删除文件名字</span></span><br><span class="line">unlink(FIFO1);</span><br></pre></td></tr></table></figure><p>mkfifo 隐含已经指定 O_CREAT | O_EXCL<br>要么不存在创建一个新的, 要么返回 errno=EEXIST(所指定名字的FIFO已经存在)</p><p>如果想要打开已经存在的FIFO可以使用open函数.<br>可以判断 如果返回-1 并且errno=EEXIST 就调用open函数打开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子进程</span></span><br><span class="line">readfd = <span class="built_in">open</span>(FIFO1, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">writefd = <span class="built_in">open</span>(FIFO2, O_WRONLY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程</span></span><br><span class="line">writefd = <span class="built_in">open</span>(FIFO1, O_WRONLY, <span class="number">0</span>);</span><br><span class="line">readfd = <span class="built_in">open</span>(FIFO2, O_RDONLY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程 这样会阻塞</span></span><br><span class="line">readfd = <span class="built_in">open</span>(FIFO2, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">writefd = <span class="built_in">open</span>(FIFO1, O_WRONLY, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果调换父进程的两行代码 程序就会进入死锁<br>因为如果当前没有任何进程<code>打开某个FIFO来写</code>, 打开这个<code>FIFO来读</code>的进程将会<code>阻塞</code></p><p>当对一个管道或者FIFO的最终close发生的时候, 该管道或FIFO中的任何残余数据都将被丢弃</p><p>即使在A主机上能够访问到B主机的目录, 即使不同主机上的两个进程都能够通过NFS打开同一个FIFO<br>他们之间也不能通过FIFO从一个进程到另一个进程发送数据</p><p>拒绝服务型攻击Dos<br>如果是单进程可能会让服务器处于阻塞状态, 多进程也可能会由于一个恶意客户发送大量独立请求<br>导致服务器子进程数达到上限, 使得后续的fork失败</p><p><strong>其他</strong><br>从字节流中获取完整的单个信息</p><ul><li>带特殊终止序列<br>许多UNIX应用使用换行分割 因特尔应用程序使用回车符加上一个换行符</li><li>显式长度<br>将长度增加在请求中</li><li>每次连接一个记录<br>应用通过关闭对端连接指示一个记录结束. HTTP1.0使用的这一技术</li></ul><p>标准IO函数fdopen可以将标准IO流与pipe返回的文件描述符相关联’</p><p><strong>限制</strong><br>系统加在管道和FIFO的唯一限制是</p><ul><li>OPEN_MAX<br>一个进程在任意时刻打开的最大描述符数量 &gt;=16</li><li>PIPE_BUF<br>可以原子性的写入一个管道或FIFO的最大数据量 &gt;= 512</li></ul><p><strong>习题练习</strong></p><ol><li>父进程终止的时候, 如果子进程的fd[1]仍处于打开状态, 则子进程对fd[0]的read 不会返回文件结束符,<br>因为fd[1]虽然在父进程中关闭了, 但是在子进程中依然打开. 如果关闭子进程fd[1], 则父进程一旦关闭,<br>他的所有文件描述符即关闭, 子进程对fd[0]的read就会返回0.(想到了自己写的服务器, 客户端断开连接就会read出一个0长度的内容)</li><li>从 不存在即创建, 存在-&gt;打开 变成 存在-&gt;打开, 不存在即创建. 可能会在open打开失败后 创建fifo之前<br>被其他进程抢先创建fifo, 导致本进程的mkfifo调用失败</li><li>出错信息写到了标准错误输出</li><li>可以把第一个open调用设置成非阻塞, 但是为了避免readline返回错误, 标志必须在readline之前去除</li><li>死锁</li><li>读进程关闭管道或者FIFO后给写进程一个信号(往关闭的管道写会产生SIGPIPE信号),<br>写进程关闭管道或者FIFO后将文件结束符发送给读进程(读进程读到长度为0的文件结束符)</li></ol><h2 id="POSIX消息队列"><a href="#POSIX消息队列" class="headerlink" title="POSIX消息队列"></a>POSIX消息队列</h2><p><strong>mqueue创建和删除</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// oflag O_RDONLY O_WRONLY O_RDWR 可以加上O_CREAT和O_EXCL或者O_NONBLOCK</span></span><br><span class="line"><span class="comment">// 创建一个新队列的时候(制定了O_CREAT且消息队列不存在)后两个参数都需要</span></span><br><span class="line"><span class="comment">// 权限位 和 指定某些属性 nullptr则使用默认属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回消息队列 fd 失败 -1</span></span><br><span class="line"><span class="function"><span class="keyword">mqd_t</span> <span class="title">mq_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="comment">/*mode_t mode, struct mq_attr *attr*/</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>注意<br>消息队列文件描述符不必是(而且很可能不是)像文件描述符或者socket文件描述符那样的短整数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭消息队列 引用计数 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_close</span><span class="params">(<span class="keyword">mqd_t</span> mqdes)</span></span>;</span><br></pre></td></tr></table></figure><p>类似close函数, 调用进程可以不再使用该文件描述符, 但是其消息队列并不会从系统中删除</p><p>当一个进程终止的时候, 所有打开着的消息队列都将关闭, 就像自动调用了mq_close</p><p>如果要从系统中删除<code>mq_open</code>第一个参数<code>name</code> 必须调用下面的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用计数 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><p>每个消息队列有一个保存着当前打开描述符数的引用计数器</p><p>当消息队列的引用计数仍大于0时, 其name就能删除<br>但是队列的析构会在<code>引用计数为0</code>的时候自动析构.</p><p>第一个demo敲完之后 一直是errno=13.<br>在<code>man mq_overview</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">On Linux, message queues are created in a virtual filesystem.   (Other  implementa‐</span><br><span class="line">tions may also provide such a feature, but the details are likely to differ.)  This</span><br><span class="line">filesystem can be mounted (by the superuser) using the following commands:</span><br><span class="line"></span><br><span class="line"># mkdir &#x2F;dev&#x2F;mqueue</span><br><span class="line"># mount -t mqueue none &#x2F;dev&#x2F;mqueue</span><br><span class="line"></span><br><span class="line">The sticky bit is automatically enabled on the mount directory.</span><br></pre></td></tr></table></figure><p>而且 name参数的格式是<code>/somename</code> 这个是相对挂载目录的</p><p><strong>属性设置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mq_flags; <span class="comment">/* 0, O_NONBLOCK */</span></span><br><span class="line">    <span class="keyword">long</span> mq_maxmsg; <span class="comment">/* max number */</span></span><br><span class="line">    <span class="keyword">long</span> mq_msgsize; <span class="comment">/* max size of a msg in bytes */</span></span><br><span class="line">    <span class="keyword">long</span> mq_curmsgs; <span class="comment">/* number of message currently on queue */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_getattr</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, struct mq_attr *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 的时候 只有mq_attr中的mq_flags起作用 设置取消O_NONBLOCK</span></span><br><span class="line"><span class="comment">// 最大消息数和最大字节数 只能在创建队列的时候设置</span></span><br><span class="line"><span class="comment">// 队列中房钱消息数 只能获取不能设置</span></span><br><span class="line"><span class="comment">// 第三个参数 不为nullptr则返回之前的属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_setattr</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> struct mq_attr *attr, struct mq_attr *oattr)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>发送接收信息</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prio 优先级 必须 &lt;= MQ_PRIO_MAX</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_send</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> prio)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// len 必须 &gt;= mq_attr.mq_msgsize 如果小于则 errno = EMSGSIZE</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">mq_receive</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> *priop)</span></span>;</span><br></pre></td></tr></table></figure><p>如果不使用优先级 发送的时候可以将 mq_send的 prio 设置为0<br>接受的时候 mq_receive priop 设置为 nullptr</p><p><strong>消息队列的限制</strong></p><ul><li>mq_maxmsg 队列中最大消息数</li><li>mq_msgsize单个消息的最大字节</li><li>MQ_OPEN_MAX 一个进程同时打开消息队列的最大数目</li><li>MQ_PRIO_MAX 最大优先级+1</li></ul><p><strong>异步事件通知</strong></p><ul><li>产生信号</li><li>创建一个线程执行一个指定的函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为指定队列建立或者删除异步事件通知.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回 0 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_notify</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, struct sigevent *nofification)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sival_int;</span><br><span class="line">    <span class="keyword">void</span> *sival_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sigev_notify; <span class="comment">// SIGEV_NONE SIGEV_SIGNAL SIGEV_THREAD</span></span><br><span class="line">    <span class="keyword">int</span> sigev_signo; <span class="comment">// signal number if SIGEV_SIGNAL</span></span><br><span class="line">    <span class="keyword">union</span> sigval sigev_value; <span class="comment">// passed to signal handler pr thread</span></span><br><span class="line">    <span class="comment">// 下面两个用于 SIGEV_THREAD</span></span><br><span class="line">    <span class="keyword">void</span> (*sigev_notify_function)(<span class="keyword">union</span> sigval);</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> *sigev_notify_attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>如果 notification != nullptr<br>当前进程希望 在有一个消息 到达所指定的 先前为空的队列 时得到通知<br>我们说 该进程被注册为接收该队列的通知</p></li><li><p>如果 notification == nullptr<br>如果 该进程被注册为 接受所指定队列通知 则取消它</p></li><li><p>任何时刻只有一个进程可以被注册为 接收某个队列的通知</p></li><li><p>当一个消息到达某个空队列, 而且已经注册, 那么只有当<br>没有因为调用mq_reveive导致的阻塞 的时候才会发出通知</p></li><li><p>通知发出后 注册立即被撤销.. 需要重新注册???</p></li></ol><p>Unix信号产生后会复位成默认行为.<br>信号处理程序通常第一个调用signal函数, 用于重新建立处理程序<br>这时会产生一个空窗时期(信号产生 与 当前进程重建信号处理程序之间)<br>空窗时期再次产生同一信号 可能终止当前进程</p><p>初看起来, mq_notify可能也有这个问题.<br>不过在消息队列<code>为空前</code> <code>通知不会再次产生</code><br>所以不要在<code>读出消息后</code>重新注册<br>而应该在<code>读出消息前</code>重新注册</p><p><code>volatile sig_atomic_t mqflag = 0;</code><br>sig_atomic_t 即使缺少信号所做的异步中断，亦能作为原子实体访问的整数类型。<br>volatile 标记可能会随时改变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;消息传递&quot;&gt;&lt;a href=&quot;#消息传递&quot; class=&quot;headerlink&quot; title=&quot;消息传递&quot;&gt;&lt;/a&gt;消息传递&lt;/h1&gt;&lt;h2 id=&quot;管道和有名管道FIFO&quot;&gt;&lt;a href=&quot;#管道和有名管道FIFO&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>GDB调试</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-GDB%E8%B0%83%E8%AF%95/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-GDB%E8%B0%83%E8%AF%95/</id>
    <published>2020-03-14T07:09:20.000Z</published>
    <updated>2020-03-17T08:39:20.200Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p><p>对多线程的支持<br>set follow-fork-mode [parent|child]<br>set detach-on-fork [on|off]</p><table><thead><tr><th>follow-fork-mode</th><th>detach-on-fork</th><th>说明</th></tr></thead><tbody><tr><td>parent</td><td>on</td><td>只调试主进程</td></tr><tr><td>child</td><td>on</td><td>只调试子进程</td></tr><tr><td>parent</td><td>off</td><td>同时调试父子进程, gdb跟踪父进程, 子进程阻塞在fork位置</td></tr><tr><td>child</td><td>off</td><td>同上 gdb跟踪子进程, 父进程阻塞</td></tr></tbody></table><p>进程间切换<br>| 命令 | 功能 |<br>| — | — |<br>| info inferiors | 查询正在调试的进程 |<br>| inferior &lt;number&gt; | 切换进程 |</p><table><thead><tr><th>运行命令</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>run</td><td>r</td><td>运行程序</td></tr><tr><td>continue</td><td>c</td><td>继续执行到下有一个断点处</td></tr><tr><td>next</td><td>n</td><td>单步跟踪, 不进入函数</td></tr><tr><td>step</td><td>s</td><td>会进入函数</td></tr><tr><td>until</td><td></td><td>运行程序直到退出循环体</td></tr><tr><td>until + 行号</td><td></td><td>运行至某行</td></tr><tr><td>finish</td><td></td><td>运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回以及参数等信息</td></tr><tr><td>call 函数(参数)</td><td></td><td>调试程序中的可见参数, 并传递参数</td></tr><tr><td>quit</td><td>q</td><td>退出</td></tr></tbody></table><table><thead><tr><th>设置断点</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>break n</td><td>b n</td><td>在第n行设置断点, b xx.cpp:500(xx.cpp文件第500行)</td></tr><tr><td>b fn if a&gt;b</td><td></td><td>在函数f 或者行号n 设置条件断点</td></tr><tr><td>break func</td><td>b func</td><td>在函数func()的入口处设置断点</td></tr><tr><td>delete 断点号n</td><td></td><td>删除第n个断点</td></tr><tr><td>disable 断点号n</td><td></td><td>暂停第n个断点</td></tr><tr><td>enable 断点号n</td><td></td><td>开始第n的断点</td></tr><tr><td>clear 行号n</td><td></td><td>清除第n行的断点</td></tr><tr><td>info b</td><td></td><td>显示断点设置情况</td></tr><tr><td>delete breakpoints</td><td></td><td>清除所有断点</td></tr></tbody></table><table><thead><tr><th>查看源代码</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>默认显示10行</td></tr><tr><td>list 行号</td><td></td><td>以行号为中心的前后十行代码</td></tr><tr><td>list 函数名</td><td></td><td>列出函数名所在函数的代码</td></tr><tr><td>list</td><td></td><td>不带参数, 接着上一次的list命令输出下边的内容</td></tr></tbody></table><table><thead><tr><th>打印表达式</th><th>功能</th></tr></thead><tbody><tr><td>print p</td><td></td></tr><tr><td>p a</td><td>显示a的值</td></tr><tr><td>p ++a</td><td>a的值</td></tr><tr><td>p func(22)</td><td>以整数22作为参数调用 后打印</td></tr><tr><td>p func(a)</td><td>将变量a作为参数</td></tr><tr><td>display 表达式</td><td>每次单步运行后就打印表达式的值</td></tr><tr><td>watch 表达式</td><td>设置检视点, 一旦被监视的表达式值改变就强行终止正在被调试的程序</td></tr><tr><td>whatis</td><td>查询变量或函数</td></tr><tr><td>info function</td><td>查询函数</td></tr><tr><td>info local</td><td>显示当前堆栈页的所有变量</td></tr></tbody></table><table><thead><tr><th>查询运行信息</th><th>功能</th></tr></thead><tbody><tr><td>where/bt</td><td>当前运行的堆栈列表</td></tr><tr><td>bt backtrace</td><td>显示当前的调用堆栈</td></tr><tr><td>up/down</td><td>改变堆栈的显示深度</td></tr><tr><td>set args [args]</td><td>指定程序运行参数</td></tr><tr><td>show args</td><td>查看程序参数</td></tr><tr><td>info program</td><td>查看程序是否运行, 进程号, 被暂停原因</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://linuxtools-rst.readthed
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="GDB调试" scheme="http://blog.lsmg.xyz/tags/GDB%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>csapp笔记</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-csapp/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-csapp/</id>
    <published>2020-03-14T07:09:20.000Z</published>
    <updated>2020-03-14T10:15:31.077Z</updated>
    
    <content type="html"><![CDATA[<p>选择性阅读</p><h1 id="第十二章-并发编程"><a href="#第十二章-并发编程" class="headerlink" title="第十二章 并发编程"></a>第十二章 并发编程</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;选择性阅读&lt;/p&gt;
&lt;h1 id=&quot;第十二章-并发编程&quot;&gt;&lt;a href=&quot;#第十二章-并发编程&quot; class=&quot;headerlink&quot; title=&quot;第十二章 并发编程&quot;&gt;&lt;/a&gt;第十二章 并发编程&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="csapp" scheme="http://blog.lsmg.xyz/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>权限管理</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3/</id>
    <published>2020-03-14T07:09:20.000Z</published>
    <updated>2020-03-14T10:14:04.755Z</updated>
    
    <content type="html"><![CDATA[<p><code>drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs</code><br>档案权限类型<br>连接数<br>档案拥有者<br>档案所属群组<br>档案容量<br>档案最后被修改时间<br>档名</p><p>文件类型和权限<br><code>drwxr-xr-x</code></p><p>第一位 d 表明档案类型是 目录</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>d</td><td>目录</td></tr><tr><td>-</td><td>文件</td></tr><tr><td>|</td><td>链接文件</td></tr><tr><td>b</td><td>设备文件中可供存储的周边设备, 可随机读取设备</td></tr><tr><td>c</td><td>序列号设备, 如键盘鼠标, 一次性读取设备</td></tr></tbody></table><p>后面每三位一组 为<code>rwx</code>的组合 分别代表 <code>读</code>, <code>写</code>, <code>执行</code><br>三组 第一组<code>文件拥有者权限</code> 第二组<code>群组中账号权限</code> 第三组<code>非本人且没有加入本群组的其他账号权限</code></p><p>第三部分表示这个文件的<code>拥有者账号</code><br>第四部分表示这个文件<code>所属群组</code></p><p>相关命令<br>-chgrp 改变文件所属群组<br>-chown 改变文件拥有者<br>-chmod 改变文件权限</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs&lt;/code&gt;&lt;br&gt;档案权限类型&lt;br&gt;连接数&lt;br&gt;档案拥有者&lt;br&gt;档案所属群组&lt;br&gt;档案容量&lt;br&gt;档案最后被修改时间&lt;br&gt;档名&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="权限管理" scheme="http://blog.lsmg.xyz/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器-理论部分</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9599-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9599-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/</id>
    <published>2020-03-06T14:53:00.000Z</published>
    <updated>2020-04-27T02:35:52.021Z</updated>
    
    <content type="html"><![CDATA[<p>距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.<br>半年后开始准备补上这四章</p><h1 id="第一章-TCP-IP协议族"><a href="#第一章-TCP-IP协议族" class="headerlink" title="第一章 TCP/IP协议族"></a>第一章 TCP/IP协议族</h1><h2 id="TCP-IP协议族体系结构和主要协议"><a href="#TCP-IP协议族体系结构和主要协议" class="headerlink" title="TCP/IP协议族体系结构和主要协议"></a>TCP/IP协议族体系结构和主要协议</h2><p>协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg" alt=""></p><p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=3a1768f4c6fc1e17e9b284632bf99d66/0dd7912397dda144d48ab350bbb7d0a20df48655.jpg" alt=""></p><p>同样七层是osi参考模型, 简化后得到四层<br>不同层次之间, 通过接口互相交流, 这样方便了各层次的修改</p><p><strong>应用层</strong><br>负责处理应用程序的逻辑</p><p><strong>表示层</strong><br>定义了数据的格式及加密</p><p><strong>会话层</strong><br>它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的</p><p><strong>传输层</strong><br>为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.<br>此层存在两大协议TCP协议和UDP协议<br>TCP协议(Transmission Control Protocol 传输控制协议)</p><ul><li>为应用层提供<code>可靠的, 面向连接, 基于流的服务</code></li><li>通过<code>超时重传</code>和<code>数据确认</code>等确保数据正常送达.</li><li>TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 0                   1                   2                   3</span><br><span class="line"> 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class="line">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |           |G|K|H|T|N|N|                               |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">|                             data                              |</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure></li></ul><p>UPD协议(User Datagram Protocol 用户数据报协议)</p><ul><li>为应用层提供<code>不可靠的, 无连接的, 基于数据报的服务</code></li><li>一般需要自己处理<code>数据确认</code>和<code>超时重传</code>的问题</li><li>通信两者不存储状态, 每次发送都需要指定地址信息. <code>有自己的长度</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> 0      7 8     15 16    23 24    31</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|     Source      |   Destination   |</span><br><span class="line">|      Port       |      Port       |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|                 |                 |</span><br><span class="line">|     Length      |    Checksum     |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|</span><br><span class="line">|          data octets ...</span><br><span class="line">+---------------- ...</span><br><span class="line"></span><br><span class="line">    User Datagram Header Format</span><br></pre></td></tr></table></figure></li></ul><p><strong>网络层</strong><br>实现了数据包的选路和转发.  只有数据包到不了目标地址, 就<code>下一跳</code>(hop by hop), 选择最近的.<br><em>IP协议(Internet Protocol)</em> 以及 <em>ICMP协议(Internet Control Message Protocol)</em><br>后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)</p><p><strong>数据链路层</strong><br>实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.<br>存在两个协议 <em>ARP协议(Address Resolve Protocol, 地址解析协议)</em>. 还有<em>RARP(Reverse ~, 逆地址解析协议)</em>.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议<em>ARP欺骗, 可能与这个有关, 目前不去学习</em></p><p><strong>封装</strong><br>上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.<br>被TCP封装的数据成为 <code>TCP报文段</code></p><ul><li>内核部分发送成功后删除数据</li></ul><p>被UDP封装的数据成为 <code>UDP数据报</code></p><ul><li>发送后即删除</li></ul><p>再经IP封装后成为<code>IP数据报</code><br>最后经过数据链路层封装后为 <code>帧</code></p><p>以太网最大数据帧1518字节 抛去14头部 帧尾4校验<br>MTU: 帧的最大传输单元 一般为1500字节<br>MSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头-20TCP头 还有额外的40字节可选部分</p><p><strong>ARP</strong><br>ARP协议能实现任意网络层地址到任意物理地址的转换</p><h1 id="第二章-IP协议详解"><a href="#第二章-IP协议详解" class="headerlink" title="第二章 IP协议详解"></a>第二章 IP协议详解</h1><p>IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一<br>IP协议为上层协议提供无状态, 无连接, 不可靠的服务</p><p>IP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制</p><p>当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png" alt=""></p><p>路由机制</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png" alt=""></p><p>给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤</p><ul><li>查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步</li><li>查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到……. 否则下一步</li><li>选择默认路由项, 通常意味着下一跳路由是网关</li></ul><h1 id="第三章-TCP协议详解"><a href="#第三章-TCP协议详解" class="headerlink" title="第三章 TCP协议详解"></a>第三章 TCP协议详解</h1><p>Tcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.</p><p>UDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断</p><p>ISN-初始序号值<br>32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移<br>32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答</p><p>ACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为<code>确认报文段</code><br>PSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间<br>RST标志: 要求对方重新建立连接 携带……<code>复位报文段</code><br>SYN标志: 标志请求建立一个连接 携带……<code>同步报文段</code><br>FIN标志: 通知对方本端连接要关闭了, 携带..<code>结束报文段</code></p><p>16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据<br>16位校验和: <code>可靠传输的重要保障</code>发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验<code>TCP头部</code>和<code>数据部分</code></p><p>额外参数之窗口扩大因子, TCP连接初始化时, 双方使用该选项协商通告窗口的扩大因子.<br>通告窗口大小是16位即最大65535字节, 但实际会比这个要大<br>假设通告窗口大小为N, 扩大因子是M(位移数, 0-14) 实际通告窗口大小为 N*2^M, 或者称为N左移M位</p><p><strong>TCP连接的建立和关闭</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 三次握手</span><br><span class="line"># 客户端发送请求连接 ISN&#x3D;seq + 0 &#x3D; 3683340920</span><br><span class="line"># mss 最大数据载量1460</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [S], seq 3683340920, win 64240, </span><br><span class="line">options [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0</span><br><span class="line"></span><br><span class="line"># 同意客户端连接</span><br><span class="line"># ack &#x3D; 客户端发送 seq + 1</span><br><span class="line"># 同时发送服务端的seq</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [S.], seq 938535101, ack 3683340921, win 64240, </span><br><span class="line">options [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0</span><br><span class="line"></span><br><span class="line"># 虽然这个报文段没有字节 但由于是同步报文段 需要占用一个序号值</span><br><span class="line"># 这里是tcpdump的处理 ack显示相对值 即 3683340921 - 3683340920 &#x3D; 1</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [.], ack 938535102, win 4106, length 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 包含FIN标志 说明要求结束连接 也需要占用一个序号值</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [F.], seq 1, ack 1, win 4106, length 0</span><br><span class="line"></span><br><span class="line"># 服务端确认关闭连接</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [.], ack 2, win 502, length 0</span><br><span class="line"></span><br><span class="line"># 服务端发送关闭连接</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [F.], seq 1, ack 2, win 4105, length 0</span><br><span class="line"></span><br><span class="line"># 客户端确认</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [.], ack 2, win 503, length 0</span><br></pre></td></tr></table></figure><p><strong>TCP超时重传</strong><br>TCP服务必须能够进行超时重传<br>这就需要为每个TCP报文段维护一个重传定时器, 发送时启动<br>如果超时后依然没有收到回复则进行重发 并重置定时器</p><p>超时时间 0.2 0.4 0.8 1.6 3.2 单位是秒, 类似TCP超时重连<br>重传最多次数 默认15</p><p><strong>拥塞控制</strong><br>提高网络利用率, 降低丢包率 保证网络资源对每条数据流的公平性 –拥塞控制</p><h1 id="第四章TCP-IP通信案例"><a href="#第四章TCP-IP通信案例" class="headerlink" title="第四章TCP/IP通信案例"></a>第四章TCP/IP通信案例</h1><p>上游服务器: 一个HTTP请求可能被多个代理服务器转发, 后面的服务器称为前面的服务器的上游服务器</p><p>正向代理服务器: 要求客户端自己设置代理服务器的地址, 客户将每次请求都直接发送到该代理服务器,并由代理服务器来请求目标资源<br>反向代理服务器: 被设置在服务器端, 客户端无需进行设置. 用代理服务器接收网络上的请求, 然后将请求转发给内网上的服务器, 并将从内部服务器上得到的结果返回给客户端, 代理服务器对外表现为一个真正的服务器.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.&lt;br&gt;半年后开始准备补上这四章&lt;/p&gt;
&lt;h1 id=&quot;第一章-TCP-IP协议族&quot;&gt;&lt;a href=&quot;#第一章-TCP-IP协议族&quot; class=&quot;headerlink&quot; title=&quot;第一章 TC
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>分支管理和实际应用</title>
    <link href="http://blog.lsmg.xyz/2020/03/Git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/Git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</id>
    <published>2020-03-06T11:34:25.000Z</published>
    <updated>2020-03-12T07:48:44.746Z</updated>
    
    <content type="html"><![CDATA[<p>2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄… 来更新下</p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p><code>git checkout -b dev</code>相当于一下两条命令<br><code>git branch dev</code> 分支创建<br><code>git checkout dev</code> 分支切换</p><p><code>git branch -d dev</code> 分支删除</p><p><code>git branch</code> 查看当前所有分支</p><p><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p><p><strong>冲突解决</strong><br><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 111111111111111</span><br><span class="line">2 222222222222222</span><br><span class="line">3 333333333333333</span><br><span class="line">4 444444444444444</span><br><span class="line">5 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  # 我在master分支下添加了6666666 并提交</span><br><span class="line">6 6666666</span><br><span class="line">7 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">8 7777777</span><br><span class="line">9 &gt;&gt;&gt;&gt;&gt;&gt;&gt; deb # 我在deb分支下添加了7777777 并提交</span><br></pre></td></tr></table></figure><p>最后需要我手动修改这个文件为自己需要的内容 然后提交即可</p><p><strong>分支管理</strong><br>通常Git会使用<code>Fast forward</code>模式 这样删除分支后会丢失分支的信息<br>可以再merge的时候加入<code>--no-ff</code>这样就能解决问题<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>由于禁用<code>Fast forward</code>后<br>会生成新的commit所以需要加入<code>-m &quot;merge with no-ff&quot;</code></p><p>git stash 可以储存当前的工作区 继续其他的工作<br>git stash list 查看储存的工作区列表<br>git stash apply stash@{0} 恢复指定的储存<br>git stash pop 恢复并drop最近的存储 慎用这个 建议使用上边的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt # stash前</span><br><span class="line">111111</span><br><span class="line">$ vim test.txt </span><br><span class="line">$ cat test.txt # 进行了修改</span><br><span class="line">111111</span><br><span class="line">222222</span><br><span class="line">333333</span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">修改：     test.txt</span><br><span class="line">$ git stash # stash</span><br><span class="line">保存工作目录和索引状态 WIP on master: 854b710 1</span><br><span class="line">$ cat test.txt </span><br><span class="line">111111</span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br><span class="line">$ git stash pop</span><br><span class="line">位于分支 master</span><br><span class="line">修改：     test.txt</span><br><span class="line">$ cat test.txt </span><br><span class="line">111111</span><br><span class="line">222222</span><br><span class="line">333333</span><br></pre></td></tr></table></figure><h1 id="实际工作中分支的应用"><a href="#实际工作中分支的应用" class="headerlink" title="实际工作中分支的应用"></a>实际工作中分支的应用</h1><p><a href="https://zhuanlan.zhihu.com/p/38772378" target="_blank" rel="noopener">主要参考</a><br><strong>主分支</strong></p><ul><li><strong>master</strong>: 这个分支最稳定, 相当于放的可发布版本</li><li><strong>develop</strong>: 开发分支, 平行于master分支, 负责合并各种<code>用于开发子功能</code>的分支</li></ul><p><strong>支持分支</strong>:解决某个问题, 结束后合并回<code>master</code>或<code>develop</code>分支</p><ul><li><strong>feature</strong>功能分支, 用于开发一个个子功能, 来自<code>develop</code>合并到<code>develop</code>去</li><li><strong>release</strong>:发布分支, 用于修改版本号等小修改, 来自<code>develop</code>分支合并到<code>master</code>分支</li><li><strong>hotfixes</strong>:紧急修复bug分支, 从<code>master</code>创建, 合并回<code>develop</code>分支和<code>master</code>分支<br><img src="https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg" alt=""></li></ul><p><a href="https://juejin.im/post/5d82e1f3e51d4561d044cd88#heading-14" target="_blank" rel="noopener">Git 分支管理规范</a></p><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">Git 基础 - 打标签</a></p><p><strong>develop分支完成了操作, 准备发布新的版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从 develop 分支上创建 release 分支:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命名规则如下 release-事件-版本</span></span><br><span class="line">git checkout –b release-20190919-v1.0.0 develop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修复完release的bug后再次提交修改:</span></span><br><span class="line">git checkout release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交本地修改, 如果没有修改bug 可以跳过</span></span><br><span class="line">git add .</span><br><span class="line">git commit –m “提交日志”</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送 release 分支</span></span><br><span class="line">git push origin release-20190919-v1.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发布新版本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并 release 分支到 master 分支:</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并 release 分支到 develop 分支:</span></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 master 分支上创建标签:</span></span><br><span class="line">git tag tag-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地 release 分支:</span></span><br><span class="line">git branch –d release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程 release 分支:</span></span><br><span class="line">git push origin :release-20190919-v1.0.0</span><br></pre></td></tr></table></figure><p>新版本完成之后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推送master分支</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意上边打的tag需要手动提交 默认push不会提交tag</span></span><br><span class="line">git push origin [tag name]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以给push增加参数</span></span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h1 id="本地和远程分支和tag的删除"><a href="#本地和远程分支和tag的删除" class="headerlink" title="本地和远程分支和tag的删除"></a>本地和远程分支和tag的删除</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 本地</span></span><br><span class="line">git tag -d xxx</span><br><span class="line">git branch -d xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 远程</span></span><br><span class="line">git push origin :refs/tags/xxx</span><br><span class="line">git push origin :xxx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄… 来更新下&lt;/p&gt;
&lt;h1 id=&quot;分支管理&quot;&gt;&lt;a href=&quot;#分支管理&quot; class=&quot;headerlink&quot; title=&quot;分支管理&quot;&gt;&lt;/a&gt;分支管理&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git 
      
    
    </summary>
    
    
      <category term="必备技能" scheme="http://blog.lsmg.xyz/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
      <category term="Git操作" scheme="http://blog.lsmg.xyz/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/Git%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="Git操作" scheme="http://blog.lsmg.xyz/tags/Git%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>循环判断中使用无符号类型</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-CPP%E9%87%87%E5%9D%91-%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%AD%E4%B9%8B%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-CPP%E9%87%87%E5%9D%91-%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%AD%E4%B9%8B%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-03-06T09:37:08.000Z</published>
    <updated>2020-03-06T12:18:05.173Z</updated>
    
    <content type="html"><![CDATA[<p>下面的代码 会产生错误.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无符号类型的数值和有符号类型的数值进行运算(包括算数逻辑运算等)会将有符号类型的数值转换成无符号类型的数值.</p><p>但是对于char short等小于int的数值运算的时候 会转换成int 纯正的int<br>对于unsigned char在转换成int时，无论最高位是0还是1，都补0<br>signed char的则高位时1补1 0补0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0*23 1</span></span><br><span class="line"><span class="comment">// 1*23 0</span></span><br><span class="line"><span class="comment">// 1*24 本来是int 但被当作了 无符号int 所以输出</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) <span class="comment">// 逻辑运算也转换了</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a &lt; b"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4294967295</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//   11111111 11111111 11111111 11111111</span></span><br><span class="line"><span class="comment">//   00000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">// 1 00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> c = <span class="number">2</span>; <span class="comment">// 0*22 1 0</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">-1</span>; <span class="comment">// 1*24</span></span><br><span class="line"><span class="keyword">if</span> (c &lt; d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c &lt; d"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c + d &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1   直接把高位的1溢出了 留下了0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2*23 1</span></span><br><span class="line"><span class="comment">// 1*23 0</span></span><br><span class="line"><span class="comment">// 1*24 被转换成了int 所以输出-1</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> e = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> f = <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">if</span> (e &lt; f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"e &lt; f"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 没有输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e + f &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> g = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> h = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (g &lt; h)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"g &lt; h"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 未输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g + h &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面的代码 会产生错误.&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP踩坑" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E8%B8%A9%E5%9D%91/"/>
    
    
      <category term="CPP踩坑记" scheme="http://blog.lsmg.xyz/tags/CPP%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Mysql基本使用</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql-Mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql-Mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-06T07:25:28.000Z</published>
    <updated>2020-03-06T07:59:36.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>Ubuntu18.04 安装 mysql5.7</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><p>安装完毕后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开shell管理程序</span></span><br><span class="line">sudo mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 123456 换成你自己的密码</span></span><br><span class="line">ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 刷新一下</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出</span></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录测试</span></span><br><span class="line">mysql -uroot -p # 回车 后输入自己的密码再次回车</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装和配置&quot;&gt;&lt;a href=&quot;#安装和配置&quot; class=&quot;headerlink&quot; title=&quot;安装和配置&quot;&gt;&lt;/a&gt;安装和配置&lt;/h1&gt;&lt;p&gt;Ubuntu18.04 安装 mysql5.7&lt;/p&gt;
&lt;figure class=&quot;highlight shell
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://blog.lsmg.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://blog.lsmg.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://blog.lsmg.xyz/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>球球</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AD%A6%E9%99%A2-%E7%90%83%E7%90%83/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AD%A6%E9%99%A2-%E7%90%83%E7%90%83/</id>
    <published>2020-03-05T13:50:02.000Z</published>
    <updated>2020-06-03T02:34:52.427Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://gameinstitute.qq.com/course/detail/10110" target="_blank" rel="noopener">休闲: 球球</a></p><p>P2P 模式…….. 好吧没有采用基本模式<br>采用了变种, 从客户端中选取主客户端 局域网游戏会采用</p><p><strong>状态同步</strong><br>MMO用的多, 断线重连简单 直接返回状态</p><p>收到命令集 计算后 返回结果 防作弊 服务器压力大 包量大</p><p>预表现emm</p><p><strong>帧同步</strong><br>服务器广播客户端发送的指令集, 断线重连需要补上丢失的帧</p><p>预表现emm</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E8%AF%BE%E5%A0%82/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AF%B9%E6%AF%94.png" alt=""></p><p>航标<br>终于知道游戏瞬移是怎么回事了</p><p>影子追随</p><p>心跳包矫正时间 获取延迟等等</p><p>王者 帧同步.</p><p>守望先锋 16ms一个包</p><p>RTT网络延迟</p><p>预表现</p><p>测试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://gameinstitute.qq.com/course/detail/10110&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;休闲: 球球&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P2P 模式…….. 好吧没有采用基本模式&lt;br&gt;采用了变
      
    
    </summary>
    
    
      <category term="游戏知识" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="服务器" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="腾讯游戏学院" scheme="http://blog.lsmg.xyz/tags/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AD%A6%E9%99%A2/"/>
    
  </entry>
  
  <entry>
    <title>数据结构指针简答应用</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9590-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9590-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</id>
    <published>2020-03-03T02:38:28.000Z</published>
    <updated>2020-03-31T09:07:13.076Z</updated>
    
    <content type="html"><![CDATA[<p>为了压缩长度. 所有空行都删掉了</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="哈希表建立快速索引-一遍和两遍哈希的使用"><a href="#哈希表建立快速索引-一遍和两遍哈希的使用" class="headerlink" title="哈希表建立快速索引, 一遍和两遍哈希的使用"></a>哈希表建立快速索引, 一遍和两遍哈希的使用</h2><p><a href="https://leetcode.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum</a><br>题目很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><p>不是最差… 也差不多了 最简单粗暴的形式 O(n2) O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 答案肯定是一个小数和一个大数 相加, 直接往后找 测试用例应该是排好序的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, j&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两遍哈希 由于需要更快的找到 vector中某个元素的下标, 非常适合哈希表来做<br>先放入哈希表中, 再寻找自己所需要的值是否存在以及下标 O(n) O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; the_map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">the_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> search = the_map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line"><span class="comment">// unordered_map&lt;int, int&gt;::iterator search = the_map.find(target - nums[i]);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (search != the_map.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (search-&gt;second == i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, search-&gt;second&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一遍哈希, 既然是要在表中查找到需要数 还需要判断是否同一个数<br>干脆直接在插入前就进行查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; the_map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> search = the_map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line"><span class="keyword">if</span> (search != the_map.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, search-&gt;second&#125;;</span><br><span class="line">&#125;</span><br><span class="line">the_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flag的使用"><a href="#flag的使用" class="headerlink" title="flag的使用"></a>flag的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</span><br><span class="line"></span><br><span class="line">在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">假设字符串的长度不会超过 1010。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure><p>这个开始我这样写的, 因为需要<br>在有奇数字母个数的时候 需要额外 结果+1<br>没有奇数字母个数 结果不需要额外 +1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> letter[<span class="number">68</span>]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">letter[s[i] - <span class="number">65</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> oddnum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">68</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> num = letter[i];</span><br><span class="line">sum += num;</span><br><span class="line"><span class="keyword">if</span> (num %<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">oddnum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum -= oddnum;</span><br><span class="line"><span class="comment">// 通过额外的一个if判断 是否存在奇数</span></span><br><span class="line"><span class="keyword">if</span> (oddnum &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> oddnum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 设置这个flag 代码少了一个if 实际用途有没有.... 感觉这个思想是可以的</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">68</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> num = letter[i];</span><br><span class="line">sum += num;</span><br><span class="line"><span class="keyword">if</span> (num %<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">oddnum++;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum -= oddnum;</span><br><span class="line"><span class="keyword">return</span> sum + flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针操作"><a href="#双指针操作" class="headerlink" title="双指针操作"></a>双指针操作</h1><h2 id="双指针左右逼近-数学问题"><a href="#双指针左右逼近-数学问题" class="headerlink" title="双指针左右逼近-数学问题"></a>双指针左右逼近-数学问题</h2><p><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode.com/problems/container-with-most-water/</a></p><p>存水量 = a(宽) * b(长);</p><p>从a最大的时候开始, 如果想要获得更大的存水量, 只能减少a, 增加b</p><p>使用两个指针 一个指向最左边 一个指向最右边</p><p>这就有了移动哪个指针的问题, 为了得到更长的b 只能移动指向较短b的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;   </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator left = <span class="built_in">height</span>.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator right = <span class="built_in">height</span>.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">min</span>(*left, *right) * (right - left);</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; <span class="built_in">max</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">max</span> = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移动较短边</span></span><br><span class="line">        <span class="keyword">if</span> (*left &lt;= *right)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并排序数组-双指针操作-拷贝到临时数组和直接写到原数组"><a href="#合并排序数组-双指针操作-拷贝到临时数组和直接写到原数组" class="headerlink" title="合并排序数组-双指针操作 拷贝到临时数组和直接写到原数组"></a>合并排序数组-双指针操作 拷贝到临时数组和直接写到原数组</h2><p><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sorted-merge-lcci/</a><br>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。<br>初始化 A 和 B 的元素数量分别为 m 和 n。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">B = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>第一次太惨了, 看来我算法需要加倍的联系啊. 先不说考虑很久</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 这里的 m + n就有点问题, 后面会空转 改为m + temp合适</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (A.at(i) &lt; B.at(temp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">A.insert(A.<span class="built_in">begin</span>() + i, B.at(temp++));</span><br><span class="line"><span class="keyword">if</span> (temp == n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">A.insert(A.<span class="built_in">begin</span>() + m + temp, B.<span class="built_in">begin</span>() + temp, B.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line">A.erase(A.<span class="built_in">begin</span>() + n + m, A.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用插入再删除, 本身这个方法就不是很好. 后来看题解有双指针, 就去试了下. 这样需要额外的空间<br>如果直接正序的修改A的值, 可能会导致A的值被覆盖掉.<br>那么倒序呢? 倒序放上最大的值 就不会覆盖掉A中未读取的值了 继续修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sorted[m + n];</span><br><span class="line"><span class="keyword">auto</span> a = A.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> b = B.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index != m + n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a - A.<span class="built_in">begin</span>() == m)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b - B.<span class="built_in">begin</span>() == n)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*a &lt; *b)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*a == *b)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *a++;</span><br><span class="line">sorted[index++] = *b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *b++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">A[i] = sorted[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改正后的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = m + n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a = m - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (index &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = B[b--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = A[a--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A[a] &gt; B[b])</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = A[a--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A[a] == B[b])</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = A[a--];</span><br><span class="line">A[index--] = B[b--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">A[index--] = B[b--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Plus-One-临时插入-如果无效则删除"><a href="#Plus-One-临时插入-如果无效则删除" class="headerlink" title="Plus One-临时插入 如果无效则删除"></a>Plus One-临时插入 如果无效则删除</h2><p><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">https://leetcode.com/problems/plus-one/</a><br>给定一个数组, [1, 2, 3]代表123 给这个数字+1 返回数组形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">Explanation: The <span class="built_in">array</span> represents the integer <span class="number">123.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// insert zero in case of like this [9]</span></span><br><span class="line">digits.insert(digits.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">end</span> = digits.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">*<span class="built_in">end</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(*<span class="built_in">end</span> == <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">*<span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">*(--<span class="built_in">end</span>) += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if the zero is useless delete it</span></span><br><span class="line"><span class="keyword">if</span> (digits[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">digits.erase(digits.<span class="built_in">begin</span>(), digits.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谨记无符号踩坑"><a href="#谨记无符号踩坑" class="headerlink" title="谨记无符号踩坑"></a>谨记无符号踩坑</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p><p>这个的代码就不贴出来了, 我也没有偷懒 没有!!!</p><p>这个主要是记录下 无符号值的使用</p><p>充实了我的CPP踩坑记的文章</p><h2 id="数组排序降低复杂度-通过排序去重"><a href="#数组排序降低复杂度-通过排序去重" class="headerlink" title="数组排序降低复杂度 通过排序去重"></a>数组排序降低复杂度 通过排序去重</h2><p>三数之和<br><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> target = -nums[i];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line"><span class="keyword">if</span> (sum == target)</span><br><span class="line">&#123;</span><br><span class="line">result.push_back(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line"><span class="keyword">while</span> ((left &lt; right) &amp;&amp; (nums[left] == nums[left + <span class="number">1</span>]))</span><br><span class="line">&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((left &lt; right) &amp;&amp; (nums[right] == nums[right - <span class="number">1</span>]))</span><br><span class="line">&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">left++;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>) &amp;&amp; (nums[i] == nums[i + <span class="number">1</span>]))</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组排序降复杂度-单一结果保存应放在循环外"><a href="#数组排序降复杂度-单一结果保存应放在循环外" class="headerlink" title="数组排序降复杂度 单一结果保存应放在循环外"></a>数组排序降复杂度 单一结果保存应放在循环外</h2><p><a href="https://leetcode-cn.com/problems/3sum-closest/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum-closest/submissions/</a></p><p>这是我第一道自己做的 而且第一次提交就对的中等题目 QAQ<br>也是受了之前三数之和的启发</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个保存结果用的 我最开始放在了for里面, 最后用</span></span><br><span class="line"><span class="comment">// map自动按key排序选出最小的abs然后取出originsum</span></span><br><span class="line"><span class="comment">// 结果应该是放在for外面就好 这个题目就这一个逻辑简单结果</span></span><br><span class="line"><span class="keyword">int</span> absminsum = INT_MAX;</span><br><span class="line"><span class="keyword">int</span> originsum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> singel = nums[i];</span><br><span class="line"><span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sum = singel + nums[left] + nums[right];</span><br><span class="line"><span class="keyword">int</span> temp = sum - target;</span><br><span class="line"><span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (-temp &lt; absminsum)</span><br><span class="line">&#123;</span><br><span class="line">absminsum = -temp;</span><br><span class="line">originsum = sum;</span><br><span class="line">&#125;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp &lt;= absminsum)</span><br><span class="line">&#123;</span><br><span class="line">absminsum = temp;</span><br><span class="line">originsum = sum;</span><br><span class="line">&#125;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((i &lt; nums.<span class="built_in">size</span>() <span class="number">-3</span>) &amp;&amp; (nums[i + <span class="number">1</span>] == nums[i]))</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> originsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h2><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘,<br>return the length of last word (last word means the last appearing word if we loop from left to right) in the string.<br>If the last word does not exist, return 0.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"Hello World"</span></span><br><span class="line">Output: <span class="number">5</span></span><br></pre></td></tr></table></figure><p>…出了问题 这个题目刚才写的解析全没了…… 只能保存下改正完的答案了<br>赶紧下载了一个vscode来用用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sub = s.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((sub &gt;= <span class="number">0</span>) &amp;&amp; (s[sub] == <span class="string">' '</span>))</span><br><span class="line">&#123;</span><br><span class="line">sub--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (sub &gt;= <span class="number">0</span> &amp;&amp; (s[sub] != <span class="string">' '</span>))</span><br><span class="line">&#123;</span><br><span class="line">sub--;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> it = s.rbegin(), piv = s.rbegin();</span><br><span class="line"><span class="keyword">for</span>(;it != s.rend() &amp;&amp; *it == <span class="string">' '</span>; it++, piv = it);</span><br><span class="line"><span class="keyword">for</span>(;it != s.rend() &amp;&amp; *it != <span class="string">' '</span>; it++);</span><br><span class="line"><span class="keyword">return</span> it - piv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="atoi-flag灵性的初始值-优先级-INT-MIN-gt-INT-MAX"><a href="#atoi-flag灵性的初始值-优先级-INT-MIN-gt-INT-MAX" class="headerlink" title="atoi flag灵性的初始值, 优先级, -INT_MIN &gt; INT_MAX"></a>atoi flag灵性的初始值, 优先级, -INT_MIN &gt; INT_MAX</h2><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi/submissions/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">begin</span> = &amp;str[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">end</span> = &amp;str[str.<span class="built_in">size</span>()];</span><br><span class="line"><span class="keyword">while</span> (*<span class="built_in">begin</span> == <span class="string">' '</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">begin</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">begin</span> == <span class="built_in">end</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认给1 很灵性 在*begin是+的时候少一次赋值 开头就是数字的情况不用在写一次else</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span> (*<span class="built_in">begin</span> == <span class="string">'-'</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">begin</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*<span class="built_in">begin</span> == <span class="string">'+'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">begin</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="built_in">begin</span> &lt; <span class="built_in">end</span>) &amp;&amp; (*<span class="built_in">begin</span> &gt;= <span class="string">'0'</span>) &amp;&amp; (*<span class="built_in">begin</span> &lt;= <span class="string">'9'</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (result &gt; INT_MAX / <span class="number">10</span> || (result == INT_MAX / <span class="number">10</span> &amp;&amp; (*<span class="built_in">begin</span> - <span class="string">'0'</span>) &gt; INT_MAX % <span class="number">10</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result &lt; INT_MIN / <span class="number">10</span> || (result == INT_MIN / <span class="number">10</span> &amp;&amp; (*<span class="built_in">begin</span> - <span class="string">'0'</span>) &gt; -(INT_MIN % <span class="number">10</span>))) <span class="comment">// 这里要有括号 -INT_MIN &gt; INT_MAX</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> INT_MIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每步都乘一次flag也不错, 方便判断INTMAX和INTMIN</span></span><br><span class="line">result = result * <span class="number">10</span> + flag * (*<span class="built_in">begin</span> - <span class="string">'0'</span>); </span><br><span class="line"><span class="built_in">begin</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="a-a-b-b"><a href="#a-a-b-b" class="headerlink" title="a^a^b = b"></a>a^a^b = b</h2><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>这个题目上来寻找单独的数字, 我直接就sort然后遍历一次, 找到单个的数字.<br>我以为这样就很快了, 结果看了下排名. 啪啪啪的打脸</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; i = i + <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] != nums[i + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然打败了40%的人, 就去看看更快的解法把. 首先我看到了就是这个<br>我只想说…. 位运算6666, 没想到异或可以这样用<br><code>a^0 = a</code>  <code>a^a = 0</code> <code>a^a^b = b</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">&#123;</span><br><span class="line">ret ^= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有哈希表做法, 应该是利用的哈希表快速索引, 我也是才知道map范围for循环是pair不是iter auto不能用太多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[n]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; n : <span class="built_in">map</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n.second == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> n.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="链表环判断双指针赛跑-单一体现key-set"><a href="#链表环判断双指针赛跑-单一体现key-set" class="headerlink" title="链表环判断双指针赛跑 单一体现key-set"></a>链表环判断双指针赛跑 单一体现key-set</h2><p><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle/</a><br><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/</a></p><p>大意就是判断一个链表是否有环, 因为之前在那本小灰上看到过. 脑子中首先想的两个指针赛跑.</p><p>快的指针一次走两步, 慢的一次走一步. 快的终将会追上慢的, 如果碰到了nullptr就返回false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode *walk = head;</span><br><span class="line">        ListNode *<span class="built_in">run</span> = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">run</span>-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            walk = walk-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">run</span>-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">run</span> = <span class="built_in">run</span>-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (walk == <span class="built_in">run</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改了一下, 感觉下面的代码要好一些?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="keyword">if</span> ((head == <span class="literal">nullptr</span>) || (head-&gt;next == <span class="literal">nullptr</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *walk = head;</span><br><span class="line">ListNode *<span class="built_in">run</span> = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (walk != <span class="built_in">run</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">run</span> == <span class="literal">nullptr</span>) || (<span class="built_in">run</span>-&gt;next == <span class="literal">nullptr</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">walk = walk-&gt;next;</span><br><span class="line"><span class="built_in">run</span> = <span class="built_in">run</span>-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是要保证访问过的单一, 就是用set了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">set</span>&lt;ListNode*&gt; hashset&#123;&#125;;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hashset.count(head) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">hashset.insert(head);</span><br><span class="line"></span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表反转-while-node-nullptr"><a href="#链表反转-while-node-nullptr" class="headerlink" title="链表反转 while (node != nullptr)"></a>链表反转 while (node != nullptr)</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/submissions/</a></p><p>原版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">ListNode *lp = <span class="literal">nullptr</span>;</span><br><span class="line">ListNode *rp = head;</span><br><span class="line">ListNode *temp = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (rp-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = rp-&gt;next;</span><br><span class="line">rp-&gt;next = lp;</span><br><span class="line">lp = rp;</span><br><span class="line">rp = temp;</span><br><span class="line">&#125;</span><br><span class="line">rp-&gt;next = lp;</span><br><span class="line"><span class="keyword">return</span> rp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *lp = <span class="literal">nullptr</span>;</span><br><span class="line">ListNode *rp = head;</span><br><span class="line">ListNode *temp = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (rp != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = rp-&gt;next;</span><br><span class="line">rp-&gt;next = lp;</span><br><span class="line">lp = rp;</span><br><span class="line">rp = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><h2 id="括号匹配-哈希表用作条件匹配"><a href="#括号匹配-哈希表用作条件匹配" class="headerlink" title="括号匹配 哈希表用作条件匹配"></a>括号匹配 哈希表用作条件匹配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span> ca, <span class="keyword">char</span> cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ca == <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cb == <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ca == <span class="string">'['</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cb == <span class="string">']'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ca == <span class="string">'&#123;'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cb == <span class="string">'&#125;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; brackets;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> temp = <span class="string">'\0'</span>;</span><br><span class="line"><span class="comment">// 在空容器上调用 back 导致未定义行为。</span></span><br><span class="line"><span class="keyword">if</span> (brackets.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = brackets.top();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (valid(temp, s[i]))</span><br><span class="line">&#123;</span><br><span class="line">brackets.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">brackets.push(s[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> brackets.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是我第一次提交的方法, 然而可以使用哈希表. 使代码看起来更简单些<br>下面使用哈希表扩展性更加好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; bracket_map&#123;&#123;<span class="string">'('</span>, <span class="number">1</span>&#125;, &#123;<span class="string">'['</span>, <span class="number">2</span>&#125;, &#123;<span class="string">'&#123;'</span>, <span class="number">3</span>&#125;, </span><br><span class="line">&#123;<span class="string">')'</span>, <span class="number">4</span>&#125;, &#123;<span class="string">']'</span>, <span class="number">5</span>&#125;, &#123;<span class="string">'&#125;'</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; brackets;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> flag = bracket_map[s[i]];</span><br><span class="line"><span class="keyword">if</span> (flag &lt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">brackets.push(flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!brackets.empty() &amp;&amp; (flag - <span class="number">3</span>) == brackets.top())</span><br><span class="line">&#123;</span><br><span class="line">brackets.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">brackets.push(flag);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> brackets.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了压缩长度. 所有空行都删掉了&lt;/p&gt;
&lt;h1 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h1&gt;&lt;h2 id=&quot;哈希表建立快速索引-一遍和两遍哈希的使用&quot;&gt;&lt;a href=&quot;#哈希表建立
      
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题记录" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
</feed>
