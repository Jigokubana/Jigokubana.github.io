<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lsmg的大学之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lsmg.xyz/"/>
  <updated>2020-03-15T03:23:26.347Z</updated>
  <id>http://blog.lsmg.xyz/</id>
  
  <author>
    <name>Lsmg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UNP卷二读书记录</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95115-UNP%E5%8D%B7%E4%BA%8C/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95115-UNP%E5%8D%B7%E4%BA%8C/</id>
    <published>2020-03-15T03:16:20.000Z</published>
    <updated>2020-03-15T03:23:26.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h1><h2 id="管道和有名管道FIFO"><a href="#管道和有名管道FIFO" class="headerlink" title="管道和有名管道FIFO"></a>管道和有名管道FIFO</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;消息传递&quot;&gt;&lt;a href=&quot;#消息传递&quot; class=&quot;headerlink&quot; title=&quot;消息传递&quot;&gt;&lt;/a&gt;消息传递&lt;/h1&gt;&lt;h2 id=&quot;管道和有名管道FIFO&quot;&gt;&lt;a href=&quot;#管道和有名管道FIFO&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>GDB调试</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-GDB%E8%B0%83%E8%AF%95/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-GDB%E8%B0%83%E8%AF%95/</id>
    <published>2020-03-14T07:09:20.000Z</published>
    <updated>2020-03-15T04:25:07.960Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p><table><thead><tr><th>运行命令</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>run</td><td>r</td><td>运行程序</td></tr><tr><td>continue</td><td>c</td><td>继续执行到下有一个断点处</td></tr><tr><td>next</td><td>n</td><td>单步跟踪, 不进入函数</td></tr><tr><td>step</td><td>s</td><td>会进入函数</td></tr><tr><td>until</td><td></td><td>运行程序直到退出循环体</td></tr><tr><td>until + 行号</td><td></td><td>运行至某行</td></tr><tr><td>finish</td><td></td><td>运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回以及参数等信息</td></tr><tr><td>call 函数(参数)</td><td></td><td>调试程序中的可见参数, 并传递参数</td></tr><tr><td>quit</td><td>q</td><td>退出</td></tr></tbody></table><table><thead><tr><th>设置断点</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>break n</td><td>b n</td><td>在第n行设置断点, b xx.cpp:500(xx.cpp文件第500行)</td></tr><tr><td>b fn if a&gt;b</td><td></td><td>在函数f 或者行号n 设置条件断点</td></tr><tr><td>break func</td><td>b func</td><td>在函数func()的入口处设置断点</td></tr><tr><td>delete 断点号n</td><td></td><td>删除第n个断点</td></tr><tr><td>disable 断点号n</td><td></td><td>暂停第n个断点</td></tr><tr><td>enable 断点号n</td><td></td><td>开始第n的断点</td></tr><tr><td>clear 行号n</td><td></td><td>清除第n行的断点</td></tr><tr><td>info b</td><td></td><td>显示断点设置情况</td></tr><tr><td>delete breakpoints</td><td></td><td>清除所有断点</td></tr></tbody></table><table><thead><tr><th>查看源代码</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>默认显示10行</td></tr><tr><td>list 行号</td><td></td><td>以行号为中心的前后十行代码</td></tr><tr><td>list 函数名</td><td></td><td>列出函数名所在函数的代码</td></tr><tr><td>list</td><td></td><td>不带参数, 接着上一次的list命令输出下边的内容</td></tr></tbody></table><table><thead><tr><th>打印表达式</th><th>功能</th></tr></thead><tbody><tr><td>print p</td><td></td></tr><tr><td>p a</td><td>显示a的值</td></tr><tr><td>p ++a</td><td>a的值</td></tr><tr><td>p func(22)</td><td>以整数22作为参数调用 后打印</td></tr><tr><td>p func(a)</td><td>将变量a作为参数</td></tr><tr><td>display 表达式</td><td>每次单步运行后就打印表达式的值</td></tr><tr><td>watch 表达式</td><td>设置检视点, 一旦被监视的表达式值改变就强行终止正在被调试的程序</td></tr><tr><td>whatis</td><td>查询变量或函数</td></tr><tr><td>info function</td><td>查询函数</td></tr><tr><td>info local</td><td>显示当前堆栈页的所有变量</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://linuxtools-rst.readthed
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="GDB调试" scheme="http://blog.lsmg.xyz/tags/GDB%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>csapp笔记</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-csapp/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-csapp/</id>
    <published>2020-03-14T07:09:20.000Z</published>
    <updated>2020-03-14T10:15:31.077Z</updated>
    
    <content type="html"><![CDATA[<p>选择性阅读</p><h1 id="第十二章-并发编程"><a href="#第十二章-并发编程" class="headerlink" title="第十二章 并发编程"></a>第十二章 并发编程</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;选择性阅读&lt;/p&gt;
&lt;h1 id=&quot;第十二章-并发编程&quot;&gt;&lt;a href=&quot;#第十二章-并发编程&quot; class=&quot;headerlink&quot; title=&quot;第十二章 并发编程&quot;&gt;&lt;/a&gt;第十二章 并发编程&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="csapp" scheme="http://blog.lsmg.xyz/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>权限管理</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3/</id>
    <published>2020-03-14T07:09:20.000Z</published>
    <updated>2020-03-14T10:14:04.755Z</updated>
    
    <content type="html"><![CDATA[<p><code>drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs</code><br>档案权限类型<br>连接数<br>档案拥有者<br>档案所属群组<br>档案容量<br>档案最后被修改时间<br>档名</p><p>文件类型和权限<br><code>drwxr-xr-x</code></p><p>第一位 d 表明档案类型是 目录</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>d</td><td>目录</td></tr><tr><td>-</td><td>文件</td></tr><tr><td>|</td><td>链接文件</td></tr><tr><td>b</td><td>设备文件中可供存储的周边设备, 可随机读取设备</td></tr><tr><td>c</td><td>序列号设备, 如键盘鼠标, 一次性读取设备</td></tr></tbody></table><p>后面每三位一组 为<code>rwx</code>的组合 分别代表 <code>读</code>, <code>写</code>, <code>执行</code><br>三组 第一组<code>文件拥有者权限</code> 第二组<code>群组中账号权限</code> 第三组<code>非本人且没有加入本群组的其他账号权限</code></p><p>第三部分表示这个文件的<code>拥有者账号</code><br>第四部分表示这个文件<code>所属群组</code></p><p>相关命令<br>-chgrp 改变文件所属群组<br>-chown 改变文件拥有者<br>-chmod 改变文件权限</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs&lt;/code&gt;&lt;br&gt;档案权限类型&lt;br&gt;连接数&lt;br&gt;档案拥有者&lt;br&gt;档案所属群组&lt;br&gt;档案容量&lt;br&gt;档案最后被修改时间&lt;br&gt;档名&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="权限管理" scheme="http://blog.lsmg.xyz/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>UE4TCP数据传输</title>
    <link href="http://blog.lsmg.xyz/2020/03/UE4-%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"/>
    <id>http://blog.lsmg.xyz/2020/03/UE4-%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/</id>
    <published>2020-03-08T08:38:28.000Z</published>
    <updated>2020-03-09T13:36:52.520Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下UE4 Tcp传输数据的客户端代码<br>方便日后使用</p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>#include “Networking.h”</p><p>// 添加 Networking 和 Sockets<br>PublicDependencyModuleNames.AddRange(new string[] { “Core”, “CoreUObject”, “Engine”, “InputCore”, “Networking”, “Sockets”});</p><h1 id="用到的数据结构"><a href="#用到的数据结构" class="headerlink" title="用到的数据结构"></a>用到的数据结构</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">FMsgType</span>:</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">EROOM_ENTER,</span><br><span class="line">EROOM_EXIT,</span><br><span class="line">EPLAYER_READY,</span><br><span class="line">EPLAYER_CANCEL_READY,</span><br><span class="line">EGAME_START,</span><br><span class="line">EROOM_PLAY_DATA,</span><br><span class="line">EGAME_OVER</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">FMsgVersion</span> :</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">VERSION0 = <span class="number">0</span>,</span><br><span class="line">VERSION1 = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoHead</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FMsgType MsgType;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    FMsgVersion MsgVer;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    int32 BodyLen;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoBody</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    <span class="keyword">bool</span> Result;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    int32 MsgId;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    TArray&lt;int32&gt; DataArray;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoMsg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    FProtoHead Header;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    FProtoBody Body;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="socket管理"><a href="#socket管理" class="headerlink" title="socket管理"></a>socket管理</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span>;</span><br><span class="line"></span><br><span class="line">FIPv4Address Ip;</span><br><span class="line">FSocket* ClientFd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将字符串ip转换为点分十进制ip</span></span><br><span class="line">    FIPv4Address::Parse(IPStr, Ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将十进制ip 转化成网络地址</span></span><br><span class="line">    TSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();</span><br><span class="line">    addr-&gt;SetIp(Ip.Value);</span><br><span class="line">    addr-&gt;SetPort(Port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP Socket 文件描述符</span></span><br><span class="line">    ClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class="string">"TCP SOCKET"</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ClientFd-&gt;Connect(*addr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据发送和接收"><a href="#数据发送和接收" class="headerlink" title="数据发送和接收"></a>数据发送和接收</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendMsg</span><span class="params">(FProtoMsg Msg)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RecvMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::SendMsg</span><span class="params">(FProtoMsg Msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Len;</span><br><span class="line"><span class="keyword">int</span> Send;</span><br><span class="line">uint8* data;</span><br><span class="line">data = Encode(Msg, &amp;Len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ClientFd-&gt;Send(data, Len, Send))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::RecvMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ClientFd != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">uint8 Buffer[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">uint32 Size = <span class="number">0</span>;</span><br><span class="line">int32 Read = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ClientFd-&gt;HasPendingData(Size))</span><br><span class="line">&#123;</span><br><span class="line">ClientFd-&gt;Recv(Buffer, <span class="number">1024</span>, Read);</span><br><span class="line"><span class="keyword">return</span> Decode(Buffer, Read);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据序列化"><a href="#数据序列化" class="headerlink" title="数据序列化"></a>数据序列化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="function">uint8* <span class="title">Encode</span><span class="params">(FProtoMsg Msg, int32* Len)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> HEADER_SIZE = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function">uint8* <span class="title">AGameNetwork::Encode</span><span class="params">(FProtoMsg Msg, int32* Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Msg.Header.BodyLen = Msg.Body.DataArray.Num() * Msg.Body.DataArray.GetTypeSize() + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">*Len = Msg.Header.BodyLen + HEADER_SIZE;</span><br><span class="line"><span class="comment">// HEADER</span></span><br><span class="line"><span class="keyword">auto</span> data = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[*Len];</span><br><span class="line">    <span class="keyword">auto</span> pdata = data;</span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, *Len);</span><br><span class="line"></span><br><span class="line">*pdata = (uint8)Msg.Header.MsgType;</span><br><span class="line">pdata++;</span><br><span class="line"></span><br><span class="line">*pdata = (uint8)Msg.Header.MsgVer;</span><br><span class="line">pdata++;</span><br><span class="line"></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)pdata = Msg.Header.BodyLen;</span><br><span class="line">pdata += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BODY</span></span><br><span class="line">pdata++;</span><br><span class="line">*(<span class="keyword">uint32_t</span>*)pdata = Msg.Body.MsgId;</span><br><span class="line">pdata += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(pdata, Msg.Body.DataArray.GetData(), Msg.Header.BodyLen - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据反序列化"><a href="#数据反序列化" class="headerlink" title="数据反序列化"></a>数据反序列化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Decode</span><span class="params">(uint8* data, int32 len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParseHeader</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParseBody</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseStatus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PARSE_INIT,</span><br><span class="line">    PARSE_HEAD,</span><br><span class="line">    PARSE_BODY</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TArray&lt;uint8&gt; ReservedData;</span><br><span class="line">FProtoMsg* CurrentMsg;</span><br><span class="line">ParseStatus ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class="line">TArray&lt;FProtoMsg&gt; MsgArray;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::Decode</span><span class="params">(uint8* data, int32 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 防止沾包 直接将受到的数据全部按顺序存储</span></span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ReservedData.Push(data[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int32 r_len = ReservedData.Num();</span><br><span class="line">uint8* r_data = ReservedData.GetData();</span><br><span class="line">int32 parse_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (r_len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (ParseStatus)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_INIT:</span><br><span class="line">CurrentMsg = <span class="keyword">new</span> FProtoMsg();</span><br><span class="line">ParseStatus = ParseStatus::PARSE_HEAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_HEAD:</span><br><span class="line"><span class="keyword">if</span> (!ParseHeader(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_BODY:</span><br><span class="line"><span class="keyword">if</span> (!ParseBody(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CurrentMsg != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">MsgArray.Push(*CurrentMsg);</span><br><span class="line">&#125;</span><br><span class="line">CurrentMsg = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; parse_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ReservedData.Pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::ParseHeader</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*reserved_len &lt; HEADER_SIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8* data = *r_data;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.MsgType = StaticCast&lt;FMsgType&gt;(*data);</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.MsgVer = StaticCast&lt;FMsgVersion&gt;(*data);</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.BodyLen = *(uint32*)data;</span><br><span class="line"></span><br><span class="line">*reserved_len -= HEADER_SIZE;</span><br><span class="line">*parse_len += HEADER_SIZE;</span><br><span class="line">*r_data += HEADER_SIZE;</span><br><span class="line"></span><br><span class="line">ParseStatus = ParseStatus::PARSE_BODY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::ParseBody</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*reserved_len &lt; CurrentMsg-&gt;Header.BodyLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8* data = *r_data;</span><br><span class="line"><span class="comment">// current_msg-&gt;body = data;</span></span><br><span class="line">CurrentMsg-&gt;Body.Result = (*data) == <span class="number">1</span>;</span><br><span class="line">data++;</span><br><span class="line">CurrentMsg-&gt;Body.MsgId = *(int32*)data;</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ((CurrentMsg-&gt;Header.BodyLen - <span class="number">5</span>) / <span class="keyword">sizeof</span>(int32)); ++i)</span><br><span class="line">&#123;</span><br><span class="line">CurrentMsg-&gt;Body.DataArray.Add(*(int32*)data);</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*reserved_len -= CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line">*parse_len += CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line">*r_data += CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line"></span><br><span class="line">ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line">    <span class="function">FProtoMsg <span class="title">Front</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line">    <span class="function">TArray&lt;FProtoMsg&gt; <span class="title">PopBackAllMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::IsEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MsgArray.Num() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FProtoMsg <span class="title">AGameNetwork::Front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MsgArray.Top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AGameNetwork::Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// MsgArray.Pop();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TArray&lt;FProtoMsg&gt; <span class="title">AGameNetwork::PopBackAllMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TArray&lt;FProtoMsg&gt; MsgArrayTemp = MsgArray;</span><br><span class="line">MsgArray.Empty();</span><br><span class="line"><span class="keyword">return</span> MsgArrayTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整代码-继承自GameStateBase"><a href="#完整代码-继承自GameStateBase" class="headerlink" title="完整代码-继承自GameStateBase"></a>完整代码-继承自GameStateBase</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CoreMinimal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GameFramework/GameStateBase.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Networking.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GameNetwork.generated.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">FMsgType</span>:</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">EROOM_ENTER,</span><br><span class="line">EROOM_EXIT,</span><br><span class="line">EPLAYER_READY,</span><br><span class="line">EPLAYER_CANCEL_READY,</span><br><span class="line">EGAME_START,</span><br><span class="line">EROOM_PLAY_DATA,</span><br><span class="line">EGAME_OVER</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">FMsgVersion</span> :</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">VERSION0 = <span class="number">0</span>,</span><br><span class="line">VERSION1 = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoHead</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FMsgType MsgType;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FMsgVersion MsgVer;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">int32 BodyLen;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoBody</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line"><span class="keyword">bool</span> Result;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">int32 MsgId;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">TArray&lt;int32&gt; DataArray;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoMsg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FProtoHead Header;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FProtoBody Body;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PACMAN_API</span> <span class="title">AGameNetwork</span> :</span> <span class="keyword">public</span> AGameStateBase</span><br><span class="line">&#123;</span><br><span class="line">GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendMsg</span><span class="params">(FProtoMsg Msg)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RecvMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function">FProtoMsg <span class="title">Front</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function">TArray&lt;FProtoMsg&gt; <span class="title">PopBackAllMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">FIPv4Address Ip;</span><br><span class="line"></span><br><span class="line">FSocket* ClientFd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseStatus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">PARSE_INIT,</span><br><span class="line">PARSE_HEAD,</span><br><span class="line">PARSE_BODY</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Decode</span><span class="params">(uint8* data, int32 len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">uint8* <span class="title">Encode</span><span class="params">(FProtoMsg Msg, int32* Len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> HEADER_SIZE = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">TArray&lt;uint8&gt; ReservedData;</span><br><span class="line"></span><br><span class="line">FProtoMsg* CurrentMsg;</span><br><span class="line"></span><br><span class="line">ParseStatus ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class="line"></span><br><span class="line">TArray&lt;FProtoMsg&gt; MsgArray;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParseHeader</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParseBody</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GameNetwork.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将字符串ip转换为点分十进制ip</span></span><br><span class="line">FIPv4Address::Parse(IPStr, Ip);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十进制ip 转化成网络地址</span></span><br><span class="line">TSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();</span><br><span class="line">addr-&gt;SetIp(Ip.Value);</span><br><span class="line">addr-&gt;SetPort(Port);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建TCP Socket 文件描述符</span></span><br><span class="line">ClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class="string">"TCP SOCKET"</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ClientFd-&gt;Connect(*addr))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::SendMsg</span><span class="params">(FProtoMsg Msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Len;</span><br><span class="line"><span class="keyword">int</span> Send;</span><br><span class="line">uint8* data;</span><br><span class="line">data = Encode(Msg, &amp;Len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ClientFd-&gt;Send(data, Len, Send))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::RecvMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ClientFd != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">uint8 Buffer[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">uint32 Size = <span class="number">0</span>;</span><br><span class="line">int32 Read = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ClientFd-&gt;HasPendingData(Size))</span><br><span class="line">&#123;</span><br><span class="line">ClientFd-&gt;Recv(Buffer, <span class="number">1024</span>, Read);</span><br><span class="line"><span class="keyword">return</span> Decode(Buffer, Read);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::Decode</span><span class="params">(uint8* data, int32 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 防止沾包 直接将受到的数据全部按顺序存储</span></span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ReservedData.Push(data[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int32 r_len = ReservedData.Num();</span><br><span class="line">uint8* r_data = ReservedData.GetData();</span><br><span class="line">int32 parse_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (r_len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (ParseStatus)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_INIT:</span><br><span class="line">CurrentMsg = <span class="keyword">new</span> FProtoMsg();</span><br><span class="line">ParseStatus = ParseStatus::PARSE_HEAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_HEAD:</span><br><span class="line"><span class="keyword">if</span> (!ParseHeader(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_BODY:</span><br><span class="line"><span class="keyword">if</span> (!ParseBody(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CurrentMsg != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">MsgArray.Push(*CurrentMsg);</span><br><span class="line">&#125;</span><br><span class="line">CurrentMsg = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; parse_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ReservedData.Pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint8* <span class="title">AGameNetwork::Encode</span><span class="params">(FProtoMsg Msg, int32* Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Msg.Header.BodyLen = Msg.Body.DataArray.Num() * Msg.Body.DataArray.GetTypeSize() + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">*Len = Msg.Header.BodyLen + HEADER_SIZE;</span><br><span class="line"><span class="comment">// HEADER</span></span><br><span class="line"><span class="keyword">auto</span>* data = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[*Len];</span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, *Len);</span><br><span class="line"></span><br><span class="line">*data = (uint8)Msg.Header.MsgType;</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">*data = (uint8)Msg.Header.MsgVer;</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)data = Msg.Header.BodyLen;</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BODY</span></span><br><span class="line">data++;</span><br><span class="line">*(<span class="keyword">uint32_t</span>*)data = Msg.Body.MsgId;</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(data, Msg.Body.DataArray.GetData(), Msg.Header.BodyLen - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回退增加的部分</span></span><br><span class="line"><span class="keyword">return</span> data - HEADER_SIZE - <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::ParseHeader</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*reserved_len &lt; HEADER_SIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8* data = *r_data;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.MsgType = StaticCast&lt;FMsgType&gt;(*data);</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.MsgVer = StaticCast&lt;FMsgVersion&gt;(*data);</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.BodyLen = *(uint32*)data;</span><br><span class="line"></span><br><span class="line">*reserved_len -= HEADER_SIZE;</span><br><span class="line">*parse_len += HEADER_SIZE;</span><br><span class="line">*r_data += HEADER_SIZE;</span><br><span class="line"></span><br><span class="line">ParseStatus = ParseStatus::PARSE_BODY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::ParseBody</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*reserved_len &lt; CurrentMsg-&gt;Header.BodyLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8* data = *r_data;</span><br><span class="line"><span class="comment">// current_msg-&gt;body = data;</span></span><br><span class="line">CurrentMsg-&gt;Body.Result = (*data) == <span class="number">1</span>;</span><br><span class="line">data++;</span><br><span class="line">CurrentMsg-&gt;Body.MsgId = *(int32*)data;</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ((CurrentMsg-&gt;Header.BodyLen - <span class="number">5</span>) / <span class="keyword">sizeof</span>(int32)); ++i)</span><br><span class="line">&#123;</span><br><span class="line">CurrentMsg-&gt;Body.DataArray.Add(*(int32*)data);</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*reserved_len -= CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line">*parse_len += CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line">*r_data += CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line"></span><br><span class="line">ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::IsEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MsgArray.Num() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FProtoMsg <span class="title">AGameNetwork::Front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MsgArray.Top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AGameNetwork::Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// MsgArray.Pop();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TArray&lt;FProtoMsg&gt; <span class="title">AGameNetwork::PopBackAllMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TArray&lt;FProtoMsg&gt; MsgArrayTemp = MsgArray;</span><br><span class="line">MsgArray.Empty();</span><br><span class="line"><span class="keyword">return</span> MsgArrayTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一下UE4 Tcp传输数据的客户端代码&lt;br&gt;方便日后使用&lt;/p&gt;
&lt;h1 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;headerlink&quot; title=&quot;头文件&quot;&gt;&lt;/a&gt;头文件&lt;/h1&gt;&lt;p&gt;#include “Networking.h”&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="UE4" scheme="http://blog.lsmg.xyz/categories/UE4/"/>
    
      <category term="网络" scheme="http://blog.lsmg.xyz/categories/UE4/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器-理论部分</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9599-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9599-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/</id>
    <published>2020-03-06T14:53:00.000Z</published>
    <updated>2020-03-14T07:10:50.487Z</updated>
    
    <content type="html"><![CDATA[<p>距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.<br>半年后开始准备补上这四章</p><h1 id="第一章-TCP-IP协议族"><a href="#第一章-TCP-IP协议族" class="headerlink" title="第一章 TCP/IP协议族"></a>第一章 TCP/IP协议族</h1><h2 id="TCP-IP协议族体系结构和主要协议"><a href="#TCP-IP协议族体系结构和主要协议" class="headerlink" title="TCP/IP协议族体系结构和主要协议"></a>TCP/IP协议族体系结构和主要协议</h2><p>协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg" alt=""></p><p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=3a1768f4c6fc1e17e9b284632bf99d66/0dd7912397dda144d48ab350bbb7d0a20df48655.jpg" alt=""></p><p>同样七层是osi参考模型, 简化后得到四层<br>不同层次之间, 通过接口互相交流, 这样方便了各层次的修改</p><p><strong>应用层</strong><br>负责处理应用程序的逻辑</p><p><strong>表示层</strong><br>定义了数据的格式及加密</p><p><strong>会话层</strong><br>它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的</p><p><strong>传输层</strong><br>为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.<br>此层存在两大协议TCP协议和UDP协议<br>TCP协议(Transmission Control Protocol 传输控制协议)</p><ul><li>为应用层提供<code>可靠的, 面向连接, 基于流的服务</code></li><li>通过<code>超时重传</code>和<code>数据确认</code>等确保数据正常送达.</li><li>TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器<br>UPD协议(User Datagram Protocol 用户数据报协议)</li><li>为应用层提供<code>不可靠的, 无连接的, 基于数据报的服务</code></li><li>一般需要自己处理<code>数据确认</code>和<code>超时重传</code>的问题</li><li>通信两者不存储状态, 每次发送都需要指定地址信息. <code>有自己的长度</code></li></ul><p><strong>网络层</strong><br>实现了数据包的选路和转发.  只有数据包到不了目标地址, 就<code>下一跳</code>(hop by hop), 选择最近的.<br><em>IP协议(Internet Protocol)</em> 以及 <em>ICMP协议(Internet Control Message Protocol)</em><br>后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)</p><p><strong>数据链路层</strong><br>实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.<br>存在两个协议 <em>ARP协议(Address Resolve Protocol, 地址解析协议)</em>. 还有<em>RARP(Reverse ~, 逆地址解析协议)</em>.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议<em>ARP欺骗, 可能与这个有关, 目前不去学习</em></p><p><strong>封装</strong><br>上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.<br>被TCP封装的数据成为 <code>TCP报文段</code></p><ul><li>内核部分发送成功后删除数据</li></ul><p>被UDP封装的数据成为 <code>UDP数据报</code></p><ul><li>发送后即删除</li></ul><p>再经IP封装后成为<code>IP数据报</code><br>最后经过数据链路层封装后为 <code>帧</code></p><p>以太网最大数据帧1518字节 抛去14头部 帧尾4校验<br>MTU: 帧的最大传输单元 一般为1500字节<br>MSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头-20TCP头 还有额外的40字节可选部分</p><p><strong>ARP</strong><br>ARP协议能实现任意网络层地址到任意物理地址的转换</p><h1 id="第二章-IP协议详解"><a href="#第二章-IP协议详解" class="headerlink" title="第二章 IP协议详解"></a>第二章 IP协议详解</h1><p>IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一<br>IP协议为上层协议提供无状态, 无连接, 不可靠的服务</p><p>IP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制</p><p>当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png" alt=""></p><p>路由机制</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png" alt=""></p><p>给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤</p><ul><li>查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步</li><li>查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到……. 否则下一步</li><li>选择默认路由项, 通常意味着下一跳路由是网关</li></ul><h1 id="第三章-TCP协议详解"><a href="#第三章-TCP协议详解" class="headerlink" title="第三章 TCP协议详解"></a>第三章 TCP协议详解</h1><p>Tcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.</p><p>UDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断</p><p>ISN-初始序号值<br>32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移<br>32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答???(可以顺带发送?)</p><p>ACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为<code>确认报文段</code><br>PSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间<br>RST标志: 要求对方重新建立连接 携带……<code>复位报文段</code><br>SYN标志: 标志请求建立一个连接 携带……<code>同步报文段</code><br>FIN标志: 通知对方本端连接要关闭了, 携带..<code>结束报文段</code></p><p>16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据<br>16位校验和: <code>可靠传输的重要保障</code>发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验<code>TCP头部</code>和<code>数据部分</code></p><p><strong>TCP连接的建立和关闭</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 三次握手</span><br><span class="line"># 客户端发送请求连接 ISN&#x3D;seq + 0 &#x3D; 3683340920</span><br><span class="line"># mss 最大数据载量1460</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [S], seq 3683340920, win 64240, </span><br><span class="line">options [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0</span><br><span class="line"></span><br><span class="line"># 同意客户端连接</span><br><span class="line"># ack &#x3D; 客户端发送 seq + 1</span><br><span class="line"># 同时发送服务端的seq</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [S.], seq 938535101, ack 3683340921, win 64240, </span><br><span class="line">options [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0</span><br><span class="line"></span><br><span class="line"># 虽然这个报文段没有字节 但由于是同步报文段 需要占用一个序号值</span><br><span class="line"># 这里是tcpdump的处理 ack显示相对值 即 3683340921 - 3683340920 &#x3D; 1</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [.], ack 1, win 4106, length 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 包含FIN标志 说明要求结束连接 也需要占用一个序号值</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [F.], seq 1, ack 1, win 4106, length 0</span><br><span class="line"></span><br><span class="line"># 服务端确认关闭连接</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [.], ack 2, win 502, length 0</span><br><span class="line"></span><br><span class="line"># 服务端发送关闭连接</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [F.], seq 1, ack 2, win 4105, length 0</span><br><span class="line"></span><br><span class="line"># 客户端确认</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [.], ack 2, win 503, length 0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.&lt;br&gt;半年后开始准备补上这四章&lt;/p&gt;
&lt;h1 id=&quot;第一章-TCP-IP协议族&quot;&gt;&lt;a href=&quot;#第一章-TCP-IP协议族&quot; class=&quot;headerlink&quot; title=&quot;第一章 TC
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>分支管理和实际应用</title>
    <link href="http://blog.lsmg.xyz/2020/03/Git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/Git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</id>
    <published>2020-03-06T11:34:25.000Z</published>
    <updated>2020-03-12T07:48:44.746Z</updated>
    
    <content type="html"><![CDATA[<p>2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄… 来更新下</p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p><code>git checkout -b dev</code>相当于一下两条命令<br><code>git branch dev</code> 分支创建<br><code>git checkout dev</code> 分支切换</p><p><code>git branch -d dev</code> 分支删除</p><p><code>git branch</code> 查看当前所有分支</p><p><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p><p><strong>冲突解决</strong><br><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 111111111111111</span><br><span class="line">2 222222222222222</span><br><span class="line">3 333333333333333</span><br><span class="line">4 444444444444444</span><br><span class="line">5 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  # 我在master分支下添加了6666666 并提交</span><br><span class="line">6 6666666</span><br><span class="line">7 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">8 7777777</span><br><span class="line">9 &gt;&gt;&gt;&gt;&gt;&gt;&gt; deb # 我在deb分支下添加了7777777 并提交</span><br></pre></td></tr></table></figure><p>最后需要我手动修改这个文件为自己需要的内容 然后提交即可</p><p><strong>分支管理</strong><br>通常Git会使用<code>Fast forward</code>模式 这样删除分支后会丢失分支的信息<br>可以再merge的时候加入<code>--no-ff</code>这样就能解决问题<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>由于禁用<code>Fast forward</code>后<br>会生成新的commit所以需要加入<code>-m &quot;merge with no-ff&quot;</code></p><p>git stash 可以储存当前的工作区 继续其他的工作<br>git stash list 查看储存的工作区列表<br>git stash apply stash@{0} 恢复指定的储存<br>git stash pop 恢复并drop最近的存储 慎用这个 建议使用上边的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt # stash前</span><br><span class="line">111111</span><br><span class="line">$ vim test.txt </span><br><span class="line">$ cat test.txt # 进行了修改</span><br><span class="line">111111</span><br><span class="line">222222</span><br><span class="line">333333</span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">修改：     test.txt</span><br><span class="line">$ git stash # stash</span><br><span class="line">保存工作目录和索引状态 WIP on master: 854b710 1</span><br><span class="line">$ cat test.txt </span><br><span class="line">111111</span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br><span class="line">$ git stash pop</span><br><span class="line">位于分支 master</span><br><span class="line">修改：     test.txt</span><br><span class="line">$ cat test.txt </span><br><span class="line">111111</span><br><span class="line">222222</span><br><span class="line">333333</span><br></pre></td></tr></table></figure><h1 id="实际工作中分支的应用"><a href="#实际工作中分支的应用" class="headerlink" title="实际工作中分支的应用"></a>实际工作中分支的应用</h1><p><a href="https://zhuanlan.zhihu.com/p/38772378" target="_blank" rel="noopener">主要参考</a><br><strong>主分支</strong></p><ul><li><strong>master</strong>: 这个分支最稳定, 相当于放的可发布版本</li><li><strong>develop</strong>: 开发分支, 平行于master分支, 负责合并各种<code>用于开发子功能</code>的分支</li></ul><p><strong>支持分支</strong>:解决某个问题, 结束后合并回<code>master</code>或<code>develop</code>分支</p><ul><li><strong>feature</strong>功能分支, 用于开发一个个子功能, 来自<code>develop</code>合并到<code>develop</code>去</li><li><strong>release</strong>:发布分支, 用于修改版本号等小修改, 来自<code>develop</code>分支合并到<code>master</code>分支</li><li><strong>hotfixes</strong>:紧急修复bug分支, 从<code>master</code>创建, 合并回<code>develop</code>分支和<code>master</code>分支<br><img src="https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg" alt=""></li></ul><p><a href="https://juejin.im/post/5d82e1f3e51d4561d044cd88#heading-14" target="_blank" rel="noopener">Git 分支管理规范</a></p><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">Git 基础 - 打标签</a></p><p><strong>develop分支完成了操作, 准备发布新的版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从 develop 分支上创建 release 分支:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命名规则如下 release-事件-版本</span></span><br><span class="line">git checkout –b release-20190919-v1.0.0 develop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修复完release的bug后再次提交修改:</span></span><br><span class="line">git checkout release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交本地修改, 如果没有修改bug 可以跳过</span></span><br><span class="line">git add .</span><br><span class="line">git commit –m “提交日志”</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送 release 分支</span></span><br><span class="line">git push origin release-20190919-v1.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发布新版本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并 release 分支到 master 分支:</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并 release 分支到 develop 分支:</span></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 master 分支上创建标签:</span></span><br><span class="line">git tag tag-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地 release 分支:</span></span><br><span class="line">git branch –d release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程 release 分支:</span></span><br><span class="line">git push origin :release-20190919-v1.0.0</span><br></pre></td></tr></table></figure><p>新版本完成之后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推送master分支</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意上边打的tag需要手动提交 默认push不会提交tag</span></span><br><span class="line">git push origin [tag name]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以给push增加参数</span></span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h1 id="本地和远程分支和tag的删除"><a href="#本地和远程分支和tag的删除" class="headerlink" title="本地和远程分支和tag的删除"></a>本地和远程分支和tag的删除</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 本地</span></span><br><span class="line">git tag -d xxx</span><br><span class="line">git branch -d xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 远程</span></span><br><span class="line">git push origin :refs/tags/xxx</span><br><span class="line">git push origin :xxx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄… 来更新下&lt;/p&gt;
&lt;h1 id=&quot;分支管理&quot;&gt;&lt;a href=&quot;#分支管理&quot; class=&quot;headerlink&quot; title=&quot;分支管理&quot;&gt;&lt;/a&gt;分支管理&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git 
      
    
    </summary>
    
    
      <category term="必备技能" scheme="http://blog.lsmg.xyz/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
      <category term="Git操作" scheme="http://blog.lsmg.xyz/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/Git%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="Git操作" scheme="http://blog.lsmg.xyz/tags/Git%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>循环判断中使用无符号类型</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-CPP%E9%87%87%E5%9D%91-%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%AD%E4%B9%8B%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-CPP%E9%87%87%E5%9D%91-%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%AD%E4%B9%8B%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-03-06T09:37:08.000Z</published>
    <updated>2020-03-06T12:18:05.173Z</updated>
    
    <content type="html"><![CDATA[<p>下面的代码 会产生错误.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无符号类型的数值和有符号类型的数值进行运算(包括算数逻辑运算等)会将有符号类型的数值转换成无符号类型的数值.</p><p>但是对于char short等小于int的数值运算的时候 会转换成int 纯正的int<br>对于unsigned char在转换成int时，无论最高位是0还是1，都补0<br>signed char的则高位时1补1 0补0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0*23 1</span></span><br><span class="line"><span class="comment">// 1*23 0</span></span><br><span class="line"><span class="comment">// 1*24 本来是int 但被当作了 无符号int 所以输出</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) <span class="comment">// 逻辑运算也转换了</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a &lt; b"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4294967295</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//   11111111 11111111 11111111 11111111</span></span><br><span class="line"><span class="comment">//   00000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">// 1 00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> c = <span class="number">2</span>; <span class="comment">// 0*22 1 0</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">-1</span>; <span class="comment">// 1*24</span></span><br><span class="line"><span class="keyword">if</span> (c &lt; d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c &lt; d"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c + d &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1   直接把高位的1溢出了 留下了0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2*23 1</span></span><br><span class="line"><span class="comment">// 1*23 0</span></span><br><span class="line"><span class="comment">// 1*24 被转换成了int 所以输出-1</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> e = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> f = <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">if</span> (e &lt; f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"e &lt; f"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 没有输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e + f &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> g = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> h = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (g &lt; h)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"g &lt; h"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 未输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g + h &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面的代码 会产生错误.&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP踩坑" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E8%B8%A9%E5%9D%91/"/>
    
    
      <category term="CPP踩坑记" scheme="http://blog.lsmg.xyz/tags/CPP%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Mysql基本使用</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql-Mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql-Mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-06T07:25:28.000Z</published>
    <updated>2020-03-06T07:59:36.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>Ubuntu18.04 安装 mysql5.7</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><p>安装完毕后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开shell管理程序</span></span><br><span class="line">sudo mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 123456 换成你自己的密码</span></span><br><span class="line">ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 刷新一下</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出</span></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录测试</span></span><br><span class="line">mysql -uroot -p # 回车 后输入自己的密码再次回车</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装和配置&quot;&gt;&lt;a href=&quot;#安装和配置&quot; class=&quot;headerlink&quot; title=&quot;安装和配置&quot;&gt;&lt;/a&gt;安装和配置&lt;/h1&gt;&lt;p&gt;Ubuntu18.04 安装 mysql5.7&lt;/p&gt;
&lt;figure class=&quot;highlight shell
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://blog.lsmg.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://blog.lsmg.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://blog.lsmg.xyz/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>球球</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AD%A6%E9%99%A2-%E7%90%83%E7%90%83/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AD%A6%E9%99%A2-%E7%90%83%E7%90%83/</id>
    <published>2020-03-05T13:50:02.000Z</published>
    <updated>2020-03-05T14:42:14.972Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://gameinstitute.qq.com/course/detail/10110" target="_blank" rel="noopener">休闲: 球球</a></p><p>P2P 模式…….. 好吧没有采用基本模式<br>采用了变种, 从客户端中选取主客户端 局域网游戏会采用</p><p><strong>状态同步</strong><br>MMO用的多, 断线重连简单 直接返回状态</p><p>收到命令集 计算后 返回结果 防作弊 服务器压力大 包量大</p><p>预表现emm</p><p><strong>帧同步</strong><br>服务器广播客户端发送的指令集, 断线重连需要补上丢失的帧</p><p>预表现emm</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E8%AF%BE%E5%A0%82/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AF%B9%E6%AF%94.png" alt=""></p><p>航标<br>终于知道游戏瞬移是怎么回事了</p><p>影子追随</p><p>心跳包矫正时间 获取延迟等等</p><p>王者 帧同步.</p><p>守望先锋 16ms一个包</p><p>RTT网络延迟</p><p>预表现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://gameinstitute.qq.com/course/detail/10110&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;休闲: 球球&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P2P 模式…….. 好吧没有采用基本模式&lt;br&gt;采用了变
      
    
    </summary>
    
    
      <category term="游戏知识" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="服务器" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="腾讯游戏学院" scheme="http://blog.lsmg.xyz/tags/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AD%A6%E9%99%A2/"/>
    
  </entry>
  
  <entry>
    <title>操作系统点带面</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%82%B9%E5%B8%A6%E9%9D%A2/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%82%B9%E5%B8%A6%E9%9D%A2/</id>
    <published>2020-03-03T10:41:28.000Z</published>
    <updated>2020-03-14T10:41:26.689Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode中等算法</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9591-%E4%B8%AD%E7%AD%89%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9591-%E4%B8%AD%E7%AD%89%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-03T02:38:28.000Z</published>
    <updated>2020-03-07T02:56:59.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jump-Game-动态规划-贪婪"><a href="#Jump-Game-动态规划-贪婪" class="headerlink" title="Jump Game-动态规划 贪婪"></a>Jump Game-动态规划 贪婪</h1><p><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game/</a></p><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.<br>Each element in the array represents your maximum jump length at that position.<br>Determine if you are able to reach the last index.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">1</span>:</span><br><span class="line">Input: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: Jump <span class="number">1</span> <span class="built_in">step</span> from index <span class="number">0</span> to <span class="number">1</span>, then <span class="number">3</span> steps to the last index.</span><br><span class="line"></span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="literal">false</span></span><br><span class="line">Explanation: You will always arrive at index <span class="number">3</span> no matter what. Its maximum</span><br><span class="line">             jump length is <span class="number">0</span>, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure><p>这是我LeetCode第一道中等难度算法, 刚上来不知道怎么做. 然后瞟了一眼题解说是动态规划问题.我就去查了下动态规划的问题解法</p><p><a href="https://www.zhihu.com/question/23995189/answer/613096905" target="_blank" rel="noopener">什么是动态规划（Dynamic Programming）？动态规划的意义是什么？ - 阮行止的回答 - 知乎</a></p><p><strong>贪心</strong><br>这样算是有了个初步了解, 不过我上来先用了贪心… 因为简单一些, 动态规划暂时没有想到怎么解.<br>结果运行时间超过 11%的人好吧 最坏的时间复杂度应该是O(n!)… 最优O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum_step = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> now_sub = sum_step - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> min_sub = now_sub;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> jumpout = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = now_sub - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= (now_sub - i))</span><br><span class="line">            &#123;</span><br><span class="line">                min_sub = i;</span><br><span class="line">                jumpout = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        now_sub = min_sub;</span><br><span class="line">        <span class="keyword">if</span> (jumpout)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> now_sub == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        jumpout = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我看了下题解的贪婪算法… 我的应该也是贪婪的一种. 不过题解的贪婪更加快.<br>我的想法是从顶开始 每次遍历找到<code>最低的能跳过来的一层</code> 然后再从<code>最低的能跳过来的一层</code>遍历.直到到不能再跳就返回当前是不是底层</p><p>题解的解法粗略看就是差在了第一个if的判断条件, 我判断的当前的层, 题解判断的<code>最低的能跳过来的一层</code>题解的解法是<code>能跳则跳</code> 我的解法是<code>跳最少的次数</code> 实际上针对此题<code>能跳则跳</code>就好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now_sub = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> min_sub = now_sub;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = now_sub - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + i &gt;= min_sub)</span><br><span class="line">        &#123;</span><br><span class="line">            min_sub = i;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> min_sub == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我猜测绝对有一道题输出最少的跳跃次数, 没想到真有. 结果试了下时间超限…..<br>理论上我第一种解法能够完成emmm, 不过先不管那道题目了.</p><p><strong>递归回溯</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJumpFromPosition</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">position</span> == nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_position = <span class="built_in">min</span>(<span class="built_in">position</span> + nums[<span class="built_in">position</span>], (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// for (int i = max_position; i &gt; position; --i)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">position</span> + <span class="number">1</span>; i &lt;= max_position; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (canJumpFromPosition(i, nums))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canJumpFromPosition(<span class="number">0</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方法思考起来简单些, 你只要知道递归的条件是什么</p><p>递归到什么时候返回值来回溯</p><p>这个题目, 你只要在当前位置不断跳到所有能去的位置, 然后递归下去. 直到你的位置到了尾部就返回true, 或者你不能再跳返回false. 自然时间超限了</p><p>上面的解法, 还有优化的空间. 因为这个是从左到右依次进行, 然而实际上从越远的地方进行更容易到达尾部. 所以可以修改for的判断条件在图中注释部分</p><p><strong>动态规划 自上而下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Index &#123;UNKNOW, GOOD, BAD&#125;;</span><br><span class="line">Index *memo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJumpFromPosition</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memo[<span class="built_in">position</span>] != UNKNOW)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[<span class="built_in">position</span>] == GOOD;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_position = <span class="built_in">min</span>(<span class="built_in">position</span> + nums[<span class="built_in">position</span>], (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = max_position; i &gt; <span class="built_in">position</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (canJumpFromPosition(i, nums))</span><br><span class="line">        &#123;</span><br><span class="line">            memo[<span class="built_in">position</span>] = GOOD;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    memo[<span class="built_in">position</span>] = BAD;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    memo = <span class="keyword">new</span> Index[nums.<span class="built_in">size</span>()]&#123;&#125;;</span><br><span class="line">    memo[nums.<span class="built_in">size</span>() - <span class="number">1</span>] = GOOD;</span><br><span class="line">    <span class="keyword">return</span> canJumpFromPosition(<span class="number">0</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前的方法中, 仔细想想就会发现 会有很多的下标被多次调用, 尽管那个下标是无法到达结尾的. 怎么解决呢? 当然是保存状态了, 每次递归结束后就标记当前的下标能不能到达. 之后遇到被标记的下标就能直接返回</p><p>然而现在的时间复杂度依然高达 O(n^2)</p><p><strong>自下而上的动态规划</strong></p><p>通过消除递归的方式, 消除递归的一个好方法就是颠倒顺序. 上面那是从左到右向右跳, 这次我们从右向左向右跳, 就能更容易的知道知道某个下标是<code>GOOD</code>还是<code>BAD</code>了, 因为离最右端更近了.</p><p>时间复杂度依然是O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Index &#123;UNKNOW, GOOD, BAD&#125;;</span><br><span class="line">Index *memo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    memo = <span class="keyword">new</span> Index[nums.<span class="built_in">size</span>()]&#123;&#125;;</span><br><span class="line">    memo[nums.<span class="built_in">size</span>() - <span class="number">1</span>] = GOOD;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> furthest_jump = <span class="built_in">min</span>(nums[i] + i, (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= furthest_jump; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (memo[j] == GOOD)</span><br><span class="line">            &#123;</span><br><span class="line">                memo[i] = GOOD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[<span class="number">0</span>] == GOOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Jump-Game-动态规划-贪婪&quot;&gt;&lt;a href=&quot;#Jump-Game-动态规划-贪婪&quot; class=&quot;headerlink&quot; title=&quot;Jump Game-动态规划 贪婪&quot;&gt;&lt;/a&gt;Jump Game-动态规划 贪婪&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="中等算法" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/%E4%B8%AD%E7%AD%89%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode简单算法</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9590-%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9590-%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-03T02:38:28.000Z</published>
    <updated>2020-03-10T07:23:02.474Z</updated>
    
    <content type="html"><![CDATA[<p>由于国内LeetCode解题时间有点微妙, 基本题目只在英文版做</p><p>为了压缩长度. 所有空行都删掉了</p><h1 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h1><h2 id="Two-Sum-哈希表建立快速索引-一遍和两遍哈希的使用"><a href="#Two-Sum-哈希表建立快速索引-一遍和两遍哈希的使用" class="headerlink" title="Two Sum-哈希表建立快速索引, 一遍和两遍哈希的使用"></a>Two Sum-哈希表建立快速索引, 一遍和两遍哈希的使用</h2><p><a href="https://leetcode.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum</a><br>题目很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><p>不是最差… 也差不多了 最简单粗暴的形式 O(n2) O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 答案肯定是一个小数和一个大数 相加, 直接往后找 测试用例应该是排好序的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, j&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两遍哈希 由于需要更快的找到 vector中某个元素的下标, 非常适合哈希表来做<br>先放入哈希表中, 再寻找自己所需要的值是否存在以及下标 O(n) O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; the_map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">the_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> search = the_map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line"><span class="comment">// unordered_map&lt;int, int&gt;::iterator search = the_map.find(target - nums[i]);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (search != the_map.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (search-&gt;second == i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, search-&gt;second&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一遍哈希, 既然是要在表中查找到需要数 还需要判断是否同一个数<br>干脆直接在插入前就进行查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; the_map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> search = the_map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line"><span class="keyword">if</span> (search != the_map.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, search-&gt;second&#125;;</span><br><span class="line">&#125;</span><br><span class="line">the_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><h2 id="合并排序的数组-双指针操作-拷贝到临时数组和直接写到原数组"><a href="#合并排序的数组-双指针操作-拷贝到临时数组和直接写到原数组" class="headerlink" title="合并排序的数组-双指针操作 拷贝到临时数组和直接写到原数组"></a>合并排序的数组-双指针操作 拷贝到临时数组和直接写到原数组</h2><p><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sorted-merge-lcci/</a><br>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。<br>初始化 A 和 B 的元素数量分别为 m 和 n。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">B = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>第一次太惨了, 看来我算法需要加倍的联系啊. 先不说考虑很久</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 这里的 m + n就有点问题, 后面会空转 改为m + temp合适</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (A.at(i) &lt; B.at(temp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">A.insert(A.<span class="built_in">begin</span>() + i, B.at(temp++));</span><br><span class="line"><span class="keyword">if</span> (temp == n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">A.insert(A.<span class="built_in">begin</span>() + m + temp, B.<span class="built_in">begin</span>() + temp, B.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line">A.erase(A.<span class="built_in">begin</span>() + n + m, A.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用插入再删除, 本身这个方法就不是很好. 后来看题解有双指针, 就去试了下. 这样需要额外的空间<br>如果直接正序的修改A的值, 可能会导致A的值被覆盖掉.<br>那么倒序呢? 倒序放上最大的值 就不会覆盖掉A中未读取的值了 继续修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sorted[m + n];</span><br><span class="line"><span class="keyword">auto</span> a = A.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> b = B.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index != m + n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a - A.<span class="built_in">begin</span>() == m)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b - B.<span class="built_in">begin</span>() == n)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*a &lt; *b)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*a == *b)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *a++;</span><br><span class="line">sorted[index++] = *b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *b++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">A[i] = sorted[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改正后的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = m + n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a = m - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (index &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = B[b--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = A[a--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A[a] &gt; B[b])</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = A[a--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A[a] == B[b])</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = A[a--];</span><br><span class="line">A[index--] = B[b--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">A[index--] = B[b--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Plus-One-临时插入-如果无效则删除"><a href="#Plus-One-临时插入-如果无效则删除" class="headerlink" title="Plus One-临时插入 如果无效则删除"></a>Plus One-临时插入 如果无效则删除</h2><p><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">https://leetcode.com/problems/plus-one/</a><br>给定一个数组, [1, 2, 3]代表123 给这个数字+1 返回数组形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">Explanation: The <span class="built_in">array</span> represents the integer <span class="number">123.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// insert zero in case of like this [9]</span></span><br><span class="line">digits.insert(digits.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">end</span> = digits.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">*<span class="built_in">end</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(*<span class="built_in">end</span> == <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">*<span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">*(--<span class="built_in">end</span>) += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if the zero is useless delete it</span></span><br><span class="line"><span class="keyword">if</span> (digits[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">digits.erase(digits.<span class="built_in">begin</span>(), digits.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a>Best Time to Buy and Sell Stock</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p><p>这个的代码就不贴出来了, 我也没有偷懒 没有!!!</p><p>这个主要是记录下 无符号值的使用</p><p>充实了我的CPP踩坑记的文章</p><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="Length-of-Last-Word-反向迭代器"><a href="#Length-of-Last-Word-反向迭代器" class="headerlink" title="Length of Last Word-反向迭代器"></a>Length of Last Word-反向迭代器</h2><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘,<br>return the length of last word (last word means the last appearing word if we loop from left to right) in the string.<br>If the last word does not exist, return 0.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"Hello World"</span></span><br><span class="line">Output: <span class="number">5</span></span><br></pre></td></tr></table></figure><p>…出了问题 这个题目刚才写的解析全没了…… 只能保存下改正完的答案了<br>赶紧下载了一个vscode来用用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sub = s.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((sub &gt;= <span class="number">0</span>) &amp;&amp; (s[sub] == <span class="string">' '</span>))</span><br><span class="line">&#123;</span><br><span class="line">sub--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (sub &gt;= <span class="number">0</span> &amp;&amp; (s[sub] != <span class="string">' '</span>))</span><br><span class="line">&#123;</span><br><span class="line">sub--;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> it = s.rbegin(), piv = s.rbegin();</span><br><span class="line"><span class="keyword">for</span>(;it != s.rend() &amp;&amp; *it == <span class="string">' '</span>; it++, piv = it);</span><br><span class="line"><span class="keyword">for</span>(;it != s.rend() &amp;&amp; *it != <span class="string">' '</span>; it++);</span><br><span class="line"><span class="keyword">return</span> it - piv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="Single-Number-a-a-b-b"><a href="#Single-Number-a-a-b-b" class="headerlink" title="Single Number- a^a^b = b"></a>Single Number- a^a^b = b</h2><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>这个题目上来寻找单独的数字, 我直接就sort然后遍历一次, 找到单个的数字.<br>我以为这样就很快了, 结果看了下排名. 啪啪啪的打脸</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; i = i + <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] != nums[i + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然打败了40%的人, 就去看看更快的解法把. 首先我看到了就是这个<br>我只想说…. 位运算6666, 没想到异或可以这样用<br><code>a^0 = a</code>  <code>a^a = 0</code> <code>a^a^b = b</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">&#123;</span><br><span class="line">ret ^= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有哈希表做法, 应该是利用的哈希表快速索引, 我也是才知道map范围for循环是pair不是iter auto不能用太多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[n]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; n : <span class="built_in">map</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n.second == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> n.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="Linked-List-Cycle-双指针赛跑-单一体现key-set-Linked-List-Cycle-II顺带也做了"><a href="#Linked-List-Cycle-双指针赛跑-单一体现key-set-Linked-List-Cycle-II顺带也做了" class="headerlink" title="Linked List Cycle-双指针赛跑 单一体现key-set  Linked List Cycle II顺带也做了"></a>Linked List Cycle-双指针赛跑 单一体现key-set  Linked List Cycle II顺带也做了</h2><p><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle/</a><br><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/</a></p><p>大意就是判断一个链表是否有环, 因为之前在那本小灰上看到过. 脑子中首先想的两个指针赛跑.</p><p>快的指针一次走两步, 慢的一次走一步. 快的终将会追上慢的, 如果碰到了nullptr就返回false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode *walk = head;</span><br><span class="line">        ListNode *<span class="built_in">run</span> = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">run</span>-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            walk = walk-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">run</span>-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">run</span> = <span class="built_in">run</span>-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (walk == <span class="built_in">run</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改了一下, 感觉下面的代码要好一些?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="keyword">if</span> ((head == <span class="literal">nullptr</span>) || (head-&gt;next == <span class="literal">nullptr</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *walk = head;</span><br><span class="line">ListNode *<span class="built_in">run</span> = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (walk != <span class="built_in">run</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">run</span> == <span class="literal">nullptr</span>) || (<span class="built_in">run</span>-&gt;next == <span class="literal">nullptr</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">walk = walk-&gt;next;</span><br><span class="line"><span class="built_in">run</span> = <span class="built_in">run</span>-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是要保证访问过的单一, 就是用set了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">set</span>&lt;ListNode*&gt; hashset&#123;&#125;;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hashset.count(head) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">hashset.insert(head);</span><br><span class="line"></span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于国内LeetCode解题时间有点微妙, 基本题目只在英文版做&lt;/p&gt;
&lt;p&gt;为了压缩长度. 所有空行都删掉了&lt;/p&gt;
&lt;h1 id=&quot;unordered-map&quot;&gt;&lt;a href=&quot;#unordered-map&quot; class=&quot;headerlink&quot; title=&quot;un
      
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="简单算法" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>STL与实现记录</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-CPP%E9%87%8D%E7%82%B9-STL%E8%AE%B0%E5%BD%95/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-CPP%E9%87%8D%E7%82%B9-STL%E8%AE%B0%E5%BD%95/</id>
    <published>2020-03-01T02:26:55.000Z</published>
    <updated>2020-03-10T07:08:24.354Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容器库"><a href="#容器库" class="headerlink" title="容器库"></a>容器库</h1><table><thead><tr><th>顺序容器</th><th>按序访问</th></tr></thead><tbody><tr><td>array</td><td>静态的连续数组</td></tr><tr><td>vector</td><td>动态的连续数组</td></tr><tr><td>deque</td><td>双端队列</td></tr><tr><td>forward_list</td><td>单链表</td></tr><tr><td>list</td><td>双链表</td></tr></tbody></table><table><thead><tr><th>关联容器</th><th>能实现快速查找O(logn)</th></tr></thead><tbody><tr><td>set</td><td>唯一key的集合, 按照key排序</td></tr><tr><td>map</td><td>k v集合, 按照k排序, k是唯一的</td></tr><tr><td>multiset</td><td>key的集合 按照key排序</td></tr><tr><td>multimap</td><td>k v的集合, 按照key排序</td></tr></tbody></table><table><thead><tr><th>无序关联容器</th><th>快速查找均摊O(1)最坏O(n)的无序(哈希)数据结构</th></tr></thead><tbody><tr><td>unordered_set</td><td>唯一key的集合, 按照key生成散列</td></tr><tr><td>unordered_map</td><td>唯一key, k v的集合, 按照key生成散列</td></tr><tr><td>unordered_multiset</td><td>key的集合, 按照key生成散列</td></tr><tr><td>unordered_multimap</td><td>k v的集合, 按照key生成散列</td></tr></tbody></table><table><thead><tr><th>容器适配器</th><th>提供顺序容器的不同接口</th></tr></thead><tbody><tr><td>stack</td><td>适配一个容器提供栈</td></tr><tr><td>queue</td><td>适配一个容器提供队列</td></tr><tr><td>priority_queue</td><td>适配一个容器提供优先级队列</td></tr></tbody></table><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><h2 id="lower-bound-和-upper-bound"><a href="#lower-bound-和-upper-bound" class="headerlink" title="lower_bound()和 upper_bound()"></a>lower_bound()和 upper_bound()</h2><p><strong>lower_bound(const Key&amp; key)</strong><br><a href="https://zh.cppreference.com/w/cpp/container/map/lower_bound" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/container/map/lower_bound</a><br>返回指向首个不小于 key 的元素的迭代器。若找不到这种元素，则返回尾后迭代器</p><p><strong>upper_bound()</strong><br>返回指向首个大于 key 的元素的迭代器。</p><h1 id="vertor"><a href="#vertor" class="headerlink" title="vertor"></a>vertor</h1><table><thead><tr><th>函数名称</th><th>使用详解</th></tr></thead><tbody><tr><td>at []</td><td>获取指定位置的元素 有边界检查</td></tr><tr><td>insert</td><td>在指定位置的前面插入, 可以插入单项, vector和数组</td></tr><tr><td>max_size</td><td>理论最大容量</td></tr><tr><td>capacity</td><td>实际最大容量</td></tr></tbody></table><h1 id="图片Warn"><a href="#图片Warn" class="headerlink" title="图片Warn"></a>图片Warn</h1><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8.png" alt=""></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8.png" alt=""></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8.png" alt=""></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;容器库&quot;&gt;&lt;a href=&quot;#容器库&quot; class=&quot;headerlink&quot; title=&quot;容器库&quot;&gt;&lt;/a&gt;容器库&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;顺序容器&lt;/th&gt;
&lt;th&gt;按序访问&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbod
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>Jsoncpp代码阅读</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Jsoncpp%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-Jsoncpp%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2020-03-01T02:26:55.000Z</published>
    <updated>2020-03-04T07:52:44.944Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Json::Value root;</span><br><span class="line">root[<span class="string">"action"</span>] = <span class="string">"run"</span>;</span><br></pre></td></tr></table></figure><p>首先是 <code>[]运算符重载</code> , 统一不同的重载类型<br>调用<code>resolveReference()</code>进行统一的添加<code>k</code>操作</p><p>首先会进行 校验参数, 然后将key封装成一个对象CZString (封装过程为将传入指针保存到 CZString对象中的cstr_)<br>封装完成后再保存<code>k v</code>的<code>map&lt;CZString, Value&gt;</code>中查找有无相同的CZString(key)有的话返回Value引用,<br>没有则创建新的&lt;CZStrng, 空Value&gt;存入map并返回Value的引用</p><p>然后是<code>=运算符重载</code>, “run”自动转换成Value对象<br>转换过程中, 通过<code>duplicateAndPrefixStringValue()</code>将”run”进行了封装<br><code>char* string_; // if allocated_, ptr to { unsigned, char[] }.</code><br>将长度封装到了一个char指针中, 有点类似自己设计tcp协议…</p><p><code>=运算符重载</code>函数将<code>[]运算符重载</code>返回的对象引用 中的相关值<code>swap()</code>成新的Value对象中的相关值</p><p>到这里理解了在Jsoncpp中 一切都是Value 包括&lt;K, V&gt;键值对也是在Value对象中存储<br>每一个&lt;k, v&gt;都可以作为一个Value对象, 这样既实现了复杂嵌套Json中 v为对象的情况 妙啊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个Value对象中都维护一个union</span></span><br><span class="line"><span class="keyword">union</span> ValueHolder &#123;</span><br><span class="line">    LargestInt int_;</span><br><span class="line">    LargestUInt uint_;</span><br><span class="line">    <span class="keyword">double</span> real_;</span><br><span class="line">    <span class="keyword">bool</span> bool_;</span><br><span class="line">    <span class="keyword">char</span>* string_; <span class="comment">// if allocated_, ptr to &#123; unsigned, char[] &#125;.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有的存贮着key的CZString保存起来</span></span><br><span class="line"><span class="comment">//  typedef std::map&lt;CZString, Value&gt; ObjectValues; // std::map&lt;CZString, Value&gt; 键值对</span></span><br><span class="line">    ObjectValues* map_;</span><br><span class="line">  &#125; value_;</span><br></pre></td></tr></table></figure><p>下面的switch的这个type 会在很多地方被修改掉.<br>起初 使用默认构造函数的value type是nullxxx<br>然后调用<code>[]运算符重载</code>的时候会修改掉 type 为 objectValue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归调用 进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuiltStyledStreamWriter::writeValue</span><span class="params">(Value <span class="keyword">const</span>&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (value.type()) &#123;</span><br><span class="line">  <span class="keyword">case</span> nullValue:</span><br><span class="line">    pushValue(nullSymbol_);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> intValue:</span><br><span class="line">    pushValue(valueToString(value.asLargestInt()));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> uintValue:</span><br><span class="line">    pushValue(valueToString(value.asLargestUInt()));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> realValue:</span><br><span class="line">    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,</span><br><span class="line">                            precisionType_));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> stringValue: &#123;</span><br><span class="line">    <span class="comment">// Is NULL is possible for value.string_? No.</span></span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* str;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span>* <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">bool</span> ok = value.getString(&amp;str, &amp;<span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">if</span> (ok)</span><br><span class="line">      pushValue(valueToQuotedStringN(str, <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(<span class="built_in">end</span> - str),</span><br><span class="line">                                     emitUTF8_));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      pushValue(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> booleanValue:</span><br><span class="line">    pushValue(valueToString(value.asBool()));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> arrayValue:</span><br><span class="line">    writeArrayValue(value);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> objectValue: &#123;</span><br><span class="line">    <span class="function">Value::Members <span class="title">members</span><span class="params">(value.getMemberNames())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (members.empty())</span><br><span class="line">      pushValue(<span class="string">"&#123;&#125;"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      writeWithIndent(<span class="string">"&#123;"</span>);</span><br><span class="line">      indent();</span><br><span class="line">      <span class="keyword">auto</span> it = members.<span class="built_in">begin</span>();</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">String</span> <span class="keyword">const</span>&amp; name = *it;</span><br><span class="line">        Value <span class="keyword">const</span>&amp; childValue = value[name];</span><br><span class="line">        writeCommentBeforeValue(childValue);</span><br><span class="line">        writeWithIndent(valueToQuotedStringN(</span><br><span class="line">            name.data(), <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(name.length()), emitUTF8_));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// :</span></span><br><span class="line">        *sout_ &lt;&lt; colonSymbol_;</span><br><span class="line">        writeValue(childValue);</span><br><span class="line">        <span class="keyword">if</span> (++it == members.<span class="built_in">end</span>()) &#123;</span><br><span class="line">          writeCommentAfterValueOnSameLine(childValue);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *sout_ &lt;&lt; <span class="string">","</span>;</span><br><span class="line">        writeCommentAfterValueOnSameLine(childValue);</span><br><span class="line">      &#125;</span><br><span class="line">      unindent();</span><br><span class="line">      writeWithIndent(<span class="string">"&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次是根据下面的例子分析的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Json::Value root;</span><br><span class="line">  Json::Value data;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">bool</span> shouldUseOldWay = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 左侧返回Value的引用</span></span><br><span class="line">  root[<span class="string">"action"</span>] = <span class="string">"run"</span>;</span><br><span class="line">  data[<span class="string">"number"</span>] = <span class="number">1</span>;</span><br><span class="line">  root[<span class="string">"data"</span>] = data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldUseOldWay) &#123;</span><br><span class="line">    Json::FastWriter writer;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> json_file = writer.<span class="built_in">write</span>(root);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; json_file &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 配置文件也是Value对象, 我用我自己.jpg</span></span><br><span class="line">    Json::StreamWriterBuilder builder;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> json_file = Json::writeString(builder, root);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; json_file &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算是了解到了这个库的大概工作流程了. 能学到的部分 吃完午饭继续写.<br>吃完饭试了试家里的显示器, 家里的显示器还是太老了…… 八年的显示器了 看得我眼花<br>还是继续用笔记本吧</p><ol><li><p>首先我很喜欢这种运算符重载的使用形式, 用起来非常的舒服, 需要重载两个运算符 <code>[]</code>和<code>=</code> 而且<br><code>=运算符</code>重载使用的swap交换需要的属性, 感觉不错<br>(后来我看了EffectiveC++ 发现这是<code>=运算符处理自我赋值</code>太巧了)</p></li><li><p>针对需要加载配置文件的类 使用了工厂模式</p></li><li><p>writeValue使用了递归处理.</p></li><li><p>统一处理, k v都是Value对象</p></li><li><p>将用户的string 拷贝到新的<code>char*</code>中 同时在开头增加了长度, 尾部补了0, 没有使用额外的变量去存储<code>char*</code>的长度<br>不太清楚这样做有什么好处</p></li><li><p>常量全部用的 <code>static constexpr</code>修饰</p></li><li><p>恰当的对象嵌套</p></li></ol><hr><p>看完了从 Value到Json 接下来看看从Json到Value</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> rawJson = <span class="string">R"(&#123;"Age": 20, "Name": "colin"&#125;)"</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> rawJsonLength = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(rawJson.length());</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">bool</span> shouldUseOldWay = <span class="literal">false</span>;</span><br><span class="line">  JSONCPP_STRING err;</span><br><span class="line">  Json::Value root;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldUseOldWay) &#123;</span><br><span class="line">    Json::Reader reader;</span><br><span class="line">    reader.parse(rawJson, root);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 默认构造函数 使用默认的配置</span></span><br><span class="line">    Json::CharReaderBuilder builder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据builder的配置生成CharReader类</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Json::CharReader&gt; <span class="title">reader</span><span class="params">(builder.newCharReader())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!reader-&gt;parse(rawJson.c_str(), rawJson.c_str() + rawJsonLength, &amp;root,</span><br><span class="line">                       &amp;err)) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"error"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> name = root[<span class="string">"Name"</span>].asString();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> age = root[<span class="string">"Age"</span>].asInt();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析的关键在于<code>parse()</code>函数 传入字符串的首尾指针, 和一个Value引用<br>进入函数后将传入的变量保存到了自己的成员变量中.</p><p>慢慢发现 这个库将很多的默认类型 起了别名 可能是为了统一类型 类似UE4也是自己搞了一套</p><p>主要是<code>OurReader</code>这个负责解析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了大量的using</span></span><br><span class="line"><span class="keyword">using</span> Char = <span class="keyword">char</span>;</span><br><span class="line"><span class="keyword">using</span> Location = <span class="keyword">const</span> Char*;</span><br></pre></td></tr></table></figure><p>解析逻辑就是<code>parse()</code>调用<code>readValue()</code><br><code>readValue()</code>负责 获取下一次数据类型type_ -&gt;switch(type_) 根据分支决定是否递归再次调用<code>readValue</code><br>总算把逻辑看懂了, 代码依然认为很赞<br><code>readToken()</code>这个函数贯穿整个解析, 通过这个函数获取到下一次的数据是什么类型, 同时移动相关的状态指针<br><code>readToken()</code> 内部大量调用下面的函数 修改当前指针 同时返回字符, 然后switch这个字符判断下一次的数据类型<br>比如遇到<code>{</code>就是一个对象的开始设置好type并返回 遇到<code>}</code>就是对象的结束…..</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取current_指向的字符 并自增</span></span><br><span class="line"><span class="function">OurReader::Char <span class="title">OurReader::getNextChar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current_ == end_)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> *current_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般第一次调用type_会被设置为对象类型, 然后<code>readValue()</code>进入<code>case 对象分支</code><br><code>case对象分支中</code><br>先进行了一次<code>readToken()</code>获取到了k的类型, 然后根据k类型分支 将k的值转换成对应的value<br>之后又是一次<code>readToken()</code>判断是否存在<code>:</code>不存在就是错误<br>在之后使用这个方法, 保存<code>k</code>的vallue获取<code>v</code>的value再次调用<code>readValue()</code>填充值 返回后继续走</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里保存了name 这个k 将name的 v放入了顶层</span></span><br><span class="line">Value&amp; value = currentValue()[name];</span><br><span class="line">nodes_.push(&amp;value);</span><br><span class="line"><span class="keyword">bool</span> ok = readValue();</span><br></pre></td></tr></table></figure><p>读取完<code>v</code>的value之后必定是<code>,</code>或者<code>}</code>又是一次判断 成功判断后一个<code>k v</code>就获取完毕了</p><p><code>using Nodes = std::stack&lt;Value*&gt;</code><br>后面解析的代码更加的妙不可言, 使用<code>Nodes nodes_{}</code>存储当前的value 实现函数之间的操作</p><p>代码合理的组织<br>比如<code>case 对象分支</code>必定是一个<code>k</code>一个<code>:</code>一个<code>v</code> 然后一个分隔符<code>,</code>或<code>}</code> 这些放入了一个函数</p><p>然后获取到<code>k</code>之后使用<code>Value&amp; value = currentValue()[name]</code>获取<code>v</code></p><p>最后依然是递归的使用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;t
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="源码学习" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>定义与声明详解</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%A3%B0%E6%98%8E%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-02-27T02:38:08.000Z</published>
    <updated>2020-02-27T03:26:16.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量声明和变量定义"><a href="#变量声明和变量定义" class="headerlink" title="变量声明和变量定义"></a>变量声明和变量定义</h1><p>变量声明: 用于向程序表明变量的类型和名字<br>变量定义: 用于为变量<em>分配存储空间</em>, 同时可为变量指定初始值</p><p>定义时会自动声明, 变量只能被定义一次, 却可以声明多次<br>extern声明不是定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i; <span class="comment">// 声明i 但没有定义i</span></span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">// 定义且声明i</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">10</span>; <span class="comment">// 定义并声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果再函数体内部试图初始化一个由extern标记的变量,会引发错误</span></span><br></pre></td></tr></table></figure><h1 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h1><p>只有extern声明位于函数外部的时候,才能被初始化</p><p><strong>在C++中 可以用来声明全局变量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="keyword">int</span> global_int = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> global_int;</span><br><span class="line"><span class="comment">// 后面可以直接使用 global_int, 因为他在其他地方定义了</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;变量声明和变量定义&quot;&gt;&lt;a href=&quot;#变量声明和变量定义&quot; class=&quot;headerlink&quot; title=&quot;变量声明和变量定义&quot;&gt;&lt;/a&gt;变量声明和变量定义&lt;/h1&gt;&lt;p&gt;变量声明: 用于向程序表明变量的类型和名字&lt;br&gt;变量定义: 用于为变量&lt;em&gt;分配
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>Effective读书记录</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95110-Effective%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95110-Effective%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/</id>
    <published>2020-02-26T13:43:46.000Z</published>
    <updated>2020-03-06T14:15:24.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款02-尽量用const-enum-inline-替换-define"><a href="#条款02-尽量用const-enum-inline-替换-define" class="headerlink" title="条款02 尽量用const, enum, inline 替换#define"></a>条款02 尽量用const, enum, inline 替换#define</h2><p>前言 我目前自己做的框架中大量用了#define…. 因为用enum涉及到转换才能到int. 来学习下这条</p><p><strong>使用 const 常量来替换 #define</strong><br>谨防机号表出错, 特殊情况下 还能减少字量</p><p>#define无法限定作用域, 这点我已经感受到了</p><p>定义C风格常量字符串<br>const char* const NAME = “lsmg”; 防止指向和指向内容改变<br>定义C++风格常量字符串<br>const std::string NAME = “lsmg”;</p><p>class专属常量, 使用如下方式. 可以限定作用域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_ROOM = <span class="number">10000</span>; <span class="comment">// 常量声明式 - 常量且只有一份</span></span><br><span class="line">Gameroom* rooms[MAX_ROOM];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要获取class专属常量的地址, 或者需要定义式. 则需要在<code>实现文件</code>而非<code>头文件</code>, 如下声明<br><code>const int Game::MAX_ROOM</code> - 未给定初值<br>由于class常量已经在声明时获得初值, 所以不用在给定初值</p><p>这里我发现一件事情, 这本书 不能只读一遍, 最少两边完整的<br>前面就已经开始使用后面的条款了, 先着重本条款, 跨条款的等第二遍</p><h2 id="条款03-尽可能使用const"><a href="#条款03-尽可能使用const" class="headerlink" title="条款03 尽可能使用const"></a>条款03 尽可能使用const</h2><p><strong>总结</strong></p><ul><li>将某些东西声明为const可帮助编译器探测到错误用法<br>const可以用作在任何作用域内的对象, 函数参数, 函数返回类型, 成员函数本体</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = greeting;</span><br><span class="line"><span class="comment">// const 在 * 左边 被指物是常量 在右边自己是常量 两边都是常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = greeting; <span class="comment">// 指针指向可以变, 指向的值不能变</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">// 指针指向不可以变, 指向的值可以变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">// 都不可以变</span></span><br></pre></td></tr></table></figure><p><strong>const 参数, 可你帮你检查 == 被写成=的情况</strong><br>这本书看来挺有意思的2333333</p><p><strong>const 函数, 这里看不太懂 没有原来如此的感觉</strong></p><h2 id="条款04-确定对象使用前已经被初始化"><a href="#条款04-确定对象使用前已经被初始化" class="headerlink" title="条款04 确定对象使用前已经被初始化"></a>条款04 确定对象使用前已经被初始化</h2><p><strong>总结</strong></p><ul><li>为内置型对象进行手工初始化.</li><li>构造函数对号食用成员初值列, 不要在构造函数中赋值. 初值列次数应该与声明次序相同</li><li>为了免除 跨编译单元的初始化次数问题, 用<code>local static</code>对象替换<code>non-local static</code>对象</li></ul><p>永远在使用对象前, 进行初始化.<br>在构造函数中, 对所有值进行初始化<br>构造函数使用<code>成员初始列</code>进行<code>初始化操作</code>而非<code>赋值操作</code></p><p><strong>减少default构造函数不必要的调用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; &amp;room_list);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; room_list_;</span><br><span class="line"><span class="keyword">int</span> roomnum_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class="line">&#123;</span><br><span class="line">name_ = name; <span class="comment">// 这些都是赋值 不是初始化</span></span><br><span class="line">room_list_ = room_list;</span><br><span class="line">roomnum_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++规定 对象的 成员变量  初始化动作  发生在  进入构造函数本体  之前</span></span><br><span class="line"><span class="comment">// name_  room_list_  两个在构造函数中被赋值, 而初始化在进入构造函数之前</span></span><br><span class="line"><span class="comment">// ---发生在这些成员的default构造函数被调用的时候, (发生在进入构造函数前)</span></span><br><span class="line"><span class="comment">// ---roomnum_例外 int属于内置类型</span></span><br></pre></td></tr></table></figure><p>上面的初始化方式, 浪费了default的构造函数 所以推荐使用下面的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A::A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class="line">:name_(name), room_list_(room_list), roomnum_(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然最终结果相同, 但没有浪费default构造函数. 前两个调用的copy构造函数.</p><p><strong>还可以使用成员初值列 来default构造一个成员变量.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A::A()</span><br><span class="line">:name_(), room_list_(), roomnum_(<span class="number">0</span>)</span><br><span class="line">&#123; <span class="comment">// 前两个全部调用的default构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const reference 内置类型(初始化与赋值等成本) 一定成员初始值列</strong></p><p><strong>初始值列总是使用 声明次序进行初始化, 而非写的顺序, 所以最好按声明次序列出</strong></p><p><strong>不同编译单元内定义之 non-local static对象 的初始化 次序</strong><br>static对象: 虚构函数会在main() 结束时被自动调用<br>local static对象: 函数内的static对象<br>non-local对象: 其他static对象</p><p>编译单元: 产出单一目标文件的那些源码, 基本是单一源码文件和他包含的头文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filesystem.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">GetNum</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> FIieSystem tfs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// directory.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Directory(params);</span><br><span class="line">&#125;</span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> num = tfs.GetNum(); <span class="comment">// 使用tfs对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function">Directory <span class="title">temp_dir</span><span class="params">(params)</span></span>;</span><br></pre></td></tr></table></figure><p>只有当 tfs在temp_dir初始化之前被初始化 才能得到正确的结果. 否则会调用未初始化的对象</p><p>但是这个次序无法保证<br>因为C++ 对这种情况没有明确定义</p><p>如何解决这个问题呢??<br>将每个<code>non-local static</code>对象搬到自己的专属函数内(该对象在此函数内被声明为static)<br>函数返回一个reference对象他所包含的对象<br>用户调用这个函数而不是直接调用对象</p><p>解决的原因呢?<br>C++ 保证函数内的<code>local static</code>对象 会在<code>函数被调用期间</code>, <code>首次遇到该对象的定义式</code>被初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filesystem.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSystem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">GetNum</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">FileSystem</span>&amp; <span class="title">tfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">FileSystem</span> fs;</span><br><span class="line"><span class="keyword">return</span> fs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// directory.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Directory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Directory(params);</span><br><span class="line">&#125;</span><br><span class="line">Directory::Directory(params)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> num = tfs().GetNum(); <span class="comment">// 使用tfs对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Directory&amp; <span class="title">temp_dir</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> Directory td;</span><br><span class="line"><span class="keyword">return</span> td;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造析构赋值运算"><a href="#构造析构赋值运算" class="headerlink" title="构造析构赋值运算"></a>构造析构赋值运算</h1><h2 id="条款0506-了解C-默认编写并调用哪些函数-并适当拒绝"><a href="#条款0506-了解C-默认编写并调用哪些函数-并适当拒绝" class="headerlink" title="条款0506 了解C++默认编写并调用哪些函数 并适当拒绝"></a>条款0506 了解C++默认编写并调用哪些函数 并适当拒绝</h2><p><strong>夹带如下私货-public-inline</strong></p><ul><li>一个构造函数(如果你没有任何构造函数)</li><li>一个拷贝构造函数</li><li>一个析构函数</li><li>一个拷贝</li></ul><p>拷贝构造函数和拷贝运算符 自动生成的只是单纯的将来源对象的每一个<code>non-static</code>成员变量<br>拷贝到目标对象</p><p><strong>遇到const 和 引用成员 默认的拷贝无法工作, 编译器会发出警告</strong></p><p><strong>将不需要的成员函数声明为private, 并且不实现</strong></p><h2 id="条款07-为多态基类声明virtual析构函数"><a href="#条款07-为多态基类声明virtual析构函数" class="headerlink" title="条款07 为多态基类声明virtual析构函数"></a>条款07 为多态基类声明virtual析构函数</h2><p>返回指向子类的 父类型指针.<br>如果delete这个指针, 在父类析构函数不是virtual的情况下, 很可能会导致<br>父类的成分被销毁, 然而子类多出来的部分不被销毁. 造成局部销毁!!</p><p><strong>防止局部销毁很简单, 将父类的析构函数声明为virtual</strong></p><p><strong>任何class 只要带有virtual函数 几乎确定应该有一个virtual析构函数</strong></p><p><strong>无端的声明virtual函数是错误的</strong><br>如果class不含virtual函数, 通常表示这个class 不是想做为父类, 这时如果将其析构函数声明为virual<br>是一个馊主意………….</p><p><em>class类的大小 = 成员变量占据大小 + vptr(vitual table pointer)指针大小(4~8 字节)</em></p><p>每一个带有virtual函数的class都有对应的vtbl</p><p>当对象调用某一vitual函数的时候, 实际调用的函数取决于<br>vptr(vitual table pointer)指针指向的vtbl(vitual table)</p><p>无端的使用virtual函数 会导致占用空间的增大</p><h2 id="条款08-别让异常逃离析构函数"><a href="#条款08-别让异常逃离析构函数" class="headerlink" title="条款08 别让异常逃离析构函数"></a>条款08 别让异常逃离析构函数</h2><p><strong>总结</strong></p><ul><li>析构函数绝对不要抛出异常, 如果被析构函数调用的函数可能抛出异常, 析构函数应该捕获所有异常<br>然后吞下它们, 或者结束程序</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应, class应该提供一个普通函数(而非在析构函数中)<br>执行操作</li></ul><p><strong>析构函数不要抛出异常</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">~Widget() &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Widget&gt; v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>v</code>被销毁的时候, Widget的析构函数第一次抛出异常C++还能接受?<br>第二次就会造成不明确行为</p><h2 id="条款09-绝不在构造函数和析构过程中调用virtual函数"><a href="#条款09-绝不在构造函数和析构过程中调用virtual函数" class="headerlink" title="条款09: 绝不在构造函数和析构过程中调用virtual函数"></a>条款09: 绝不在构造函数和析构过程中调用virtual函数</h2><p><strong>总结</strong></p><ul><li>在构造和析构期间不要调用virtual函数, 因为这类调用从不下降到<code>子类</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Transaction();</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">LogTransaction</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">Transaction::Transaction()</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">LogTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTransaction</span>:</span> <span class="keyword">public</span> Transaction</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">LogTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTransaction</span>:</span> <span class="keyword">public</span> Transaction</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">LogTransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure><p>BuyTransaction的构造函数会被调用, 但是父类的构造函数会更显被调用.<br>然后父类构造函数调用<code>LogTransaction()</code>的版本是<code>父类</code>的版本!!! 不是子类的版本</p><p>析构函数也是同样的道理, 当<code>子类</code>的析构函数执行后, <code>子类</code>中的属性值就成为未定义状态<br>进入<code>父类</code>后对象就成为一个<code>父类</code>对象</p><p>本例子中既然无法实现使用<code>virtual</code>函数从<code>父类</code>向下调用, 可以再构造期间, 将<br><code>子类</code>必要的构造信息向上传给<code>父类</code>的构造函数</p><h2 id="条款10-另operator-返回一个reference-to-this"><a href="#条款10-另operator-返回一个reference-to-this" class="headerlink" title="条款10: 另operator= 返回一个reference to *this"></a>条款10: 另operator= 返回一个reference to *this</h2><p>注意这只是一个协议, 并无强制性. 如果不遵守代码依然可以通过编译, 然而这份 协议被所有内置类型<br>和标准程序库提供的类型共同遵守.<br>因此除非你有一个标新立异的好理由, 不然还是随众吧</p><h2 id="条款11-在operator-中处理”自我赋值”"><a href="#条款11-在operator-中处理”自我赋值”" class="headerlink" title="条款11: 在operator= 中处理”自我赋值”"></a>条款11: 在operator= 中处理”自我赋值”</h2><p><strong>总结</strong></p><ul><li>确保当对象自我赋值时operator=有良好的的行为. 其中技术包括比较”来源对象”<br>和”目标对象”的地址, 精心周到的语句顺序, 以及copy-and-swap</li><li>确认任何函数如果操作一个以上的对象, 而其中多个对象是同一个对象的时候, 进行仍未正确</li></ul><p><strong>自我赋值是什么</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> &#123;</span>...&#125;;</span><br><span class="line">Widget w;</span><br><span class="line"></span><br><span class="line">w=w; <span class="comment">// 什么这个看起来不可能, 那下面呢?</span></span><br><span class="line"></span><br><span class="line">a[i] = a[j]; <span class="comment">// 这个怎么样?  潜在的自我赋值</span></span><br><span class="line">*px = *py <span class="comment">// 这个呢? 潜在的自我赋值</span></span><br></pre></td></tr></table></figure><p><strong>会出现的问题</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gameroom</span>&#123;</span>....&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Gameroom* room_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator=的实现代码</span></span><br><span class="line">Game&amp; Game::<span class="keyword">operator</span>=(<span class="keyword">const</span> Game&amp; ths)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> room_;</span><br><span class="line">room_ = <span class="keyword">new</span> Gameroom(*ths.room_);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码 如果 this和ths指向同一个对象就会造成 <code>room_</code>构造失败<br>因为被<code>delete</code>的<code>room_</code>就是要传入的</p><p>如何解决这个问题呢?<br><em>比较来源对象 整同测试</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Game&amp; Game::<span class="keyword">operator</span>=(<span class="keyword">const</span> Game&amp; ths)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == &amp;ths)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> room_;</span><br><span class="line">room_ = <span class="keyword">new</span> Gameroom(*ths.room_);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果 <code>new Gameroom(*ths.room_)</code>错误, 导致room_指向不安全的内存<br>使用下面的代码, 可以导出异常安全, 以及自我赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Game&amp; Game::<span class="keyword">operator</span>=(<span class="keyword">const</span> Game&amp; ths)</span><br><span class="line">&#123;</span><br><span class="line">Gameroom* p_room = room_;</span><br><span class="line">room_ = <span class="keyword">new</span> Gameroom(*ths.room_);</span><br><span class="line"><span class="keyword">delete</span> p_room;</span><br><span class="line">retutn *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在如果<code>new Gameroom</code>抛出异常, room_还可以保持原状.<br>同时也能处理自我赋值</p><p><em>copy and swap</em><br>这一段描述我看完之后, 突然想到了上午看的Jsoncpp里面的代码!!!!! 就有这个<br>下面的代码更加高效 但是牺牲了清晰性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Game&amp; rhs)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Game&amp; Game::<span class="keyword">operator</span>=(<span class="keyword">const</span> Game&amp; ths)</span><br><span class="line">&#123;</span><br><span class="line">Game temp(<span class="keyword">this</span>);</span><br><span class="line">swap(temp);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条款12-复制对象时勿忘其每一个成分"><a href="#条款12-复制对象时勿忘其每一个成分" class="headerlink" title="条款12: 复制对象时勿忘其每一个成分"></a>条款12: 复制对象时勿忘其每一个成分</h2><h1 id="设计与声明"><a href="#设计与声明" class="headerlink" title="设计与声明"></a>设计与声明</h1><h2 id="条款19-设计class犹如设计type"><a href="#条款19-设计class犹如设计type" class="headerlink" title="条款19: 设计class犹如设计type"></a>条款19: 设计class犹如设计type</h2><p>如何设计高效的classes呢?</p><ul><li>新class的对象该如何被创建和销毁? 这会影响到构造析构函数内存分配释放函数</li><li>对象的初始化和对象的赋值有什么样的差别? 决定构造函数和赋值运算符的行为.<br>搞清初始化和赋值</li><li>注意class对象被值传递 拷贝构造函数会被调用用来生成临时对象</li><li>什么是新class的合法值? <code>setter</code>函数需要进行的范围检查</li><li>你的新class需要配合某个继承图系吗? // TODO</li><li>你的新class需要什么样的转换? 如果需要类型转换需要在class中编写<code>类型转换函数</code></li><li>什么样的操作运算符和函数对此class而言是合理的? 决定你为class声明哪些函数(条款 23 24 46)</li><li>将需要驳回的标准函数设置为private</li><li>你的新type有多么一般化? 或许应该定义一整个class家族. 也许模板能帮你</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;让自己习惯C&quot;&gt;&lt;a href=&quot;#让自己习惯C&quot; class=&quot;headerlink&quot; title=&quot;让自己习惯C++&quot;&gt;&lt;/a&gt;让自己习惯C++&lt;/h1&gt;&lt;h2 id=&quot;条款02-尽量用const-enum-inline-替换-define&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器-进程线程</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95102-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95102-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86/</id>
    <published>2020-02-25T14:34:39.000Z</published>
    <updated>2020-03-15T01:43:24.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十三章多进程编程"><a href="#第十三章多进程编程" class="headerlink" title="第十三章多进程编程"></a>第十三章多进程编程</h1><h2 id="exec系列系统调用"><a href="#exec系列系统调用" class="headerlink" title="exec系列系统调用"></a>exec系列系统调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 声明这个是外部函数或外部变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>** environ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻</span></span><br><span class="line"><span class="comment">// arg-接受可变参数 和 argv用于向新的程序传递参数数组</span></span><br><span class="line"><span class="comment">// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量</span></span><br><span class="line"><span class="comment">// exec函数是不返回的, 除非出错</span></span><br><span class="line"><span class="comment">// 如果未报错则源程序被新的程序完全替换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">const</span> <span class="keyword">char</span>* arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* arg, ..., <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">char</span>* <span class="keyword">const</span> argv[], <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><h2 id="fork系统调用-进程的创建"><a href="#fork系统调用-进程的创建" class="headerlink" title="fork系统调用-进程的创建"></a>fork系统调用-进程的创建</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0</span></span><br><span class="line"><span class="comment">// 次返回值用于区分是父进程还是子进程</span></span><br><span class="line"><span class="comment">// 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(viod)</span></span>;</span><br></pre></td></tr></table></figure><p>fork系统调用<br>fork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项<br>新的进程表项有很多的属性和原进程相同</p><ul><li>堆指针</li><li>栈指针</li><li>标志寄存器的值</li><li>子进程代码与父进程完全相同</li><li>同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)父进程的数据(堆数据, 栈数据, 静态数据)</li><li>创建子进程后, <em>父进程打开的文件描述符默认在子进程中也是打开的</em> <code>文件描述符的引用计数</code>, <code>父进程的用户根目录, 当前工作目录等变量的引用计数</code> 均加1</li></ul><p>也存在不同的项目</p><ul><li>该进程的PPID(标识父进程)被设置成原进程的PID,  </li><li><code>信号位图被清除</code>(原进程设置的信号处理函数对新进程无效)</li></ul><p>(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)</p><p>The child process is an exact duplicate of the parent process except<br>for the following points:</p><ul><li><p>The child has its own unique process ID, and this PID does not<br> match the ID of any existing process group (setpgid(2)) or<br> session. 子进程拥有自己唯一的进程ID, 不与其他相同</p></li><li><p>The child’s parent process ID is the same as the parent’s process<br> ID. 子进程的父进程ID PPID 与父进程ID PID相同</p></li><li><p>The child does not inherit its parent’s memory locks (mlock(2),<br> mlockall(2)). 子进程不继承父进程的内存锁(保证一部分内存处于内存中, 而不是sawp分区)</p></li><li><p>Process resource utilizations (getrusage(2)) and CPU time counters<br> (times(2)) are reset to zero in the child.<br> 进程资源使用和CPU时间计数器在子进程中重置为0</p></li><li><p>The child’s set of pending signals is initially empty<br> (sigpending(2)). 信号位图被初始化为空 原信号处理函数对子进程无效 需重新设置</p></li><li><p>The child does not inherit semaphore adjustments from its parent<br> (semop(2)). 不会继承semadj</p></li><li><p>The child does not inherit process-associated record locks from<br> its parent (fcntl(2)).  (On the other hand, it does inherit<br> fcntl(2) open file description locks and flock(2) locks from its<br> parent.)</p></li><li><p>The child does not inherit timers from its parent (setitimer(2),<br> alarm(2), timer_create(2)). 不会继承定时器</p></li><li><p>The child does not inherit outstanding asynchronous I/O operations<br> from its parent (aio_read(3), aio_write(3)), nor does it inherit<br> any asynchronous I/O contexts from its parent (see io_setup(2)).</p></li></ul><h2 id="处理僵尸进程-进程的管理"><a href="#处理僵尸进程-进程的管理" class="headerlink" title="处理僵尸进程-进程的管理"></a>处理僵尸进程-进程的管理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>* stat_loc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)</span></span><br><span class="line"><span class="comment">// options函数取值WNOHANG-waitpid立即返回</span></span><br><span class="line"><span class="comment">// 如果目标子进程正常退出, 则返回子进程的pid</span></span><br><span class="line"><span class="comment">// 如果还没有结束或意外终止, 则立即返回0</span></span><br><span class="line"><span class="comment">// 调用失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* stat_loc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line">WIFEXITED(stat_val); <span class="comment">// 子进程正常结束, 返回一个非0</span></span><br><span class="line">WEXITSTATUS(stat_val); <span class="comment">// 如果WIFEXITED 非0, 它返回子进程的退出码</span></span><br><span class="line">WIFSIGNALED(stat_val);<span class="comment">// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值</span></span><br><span class="line">WTERMSIG(stat_val);<span class="comment">// 如果WIFSIGNALED非0 返回一个信号值</span></span><br><span class="line">WIFSTOPPED(stat_val);<span class="comment">// 如果子进程意外终止, 它返回一个非0值</span></span><br><span class="line">WSTOPSIG(stat_val);<span class="comment">// 如果WIFSTOPED非0, 它返回一个信号值</span></span><br></pre></td></tr></table></figure><p>对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询</p><ul><li>在<code>子进程结束运行之后, 父进程读取其退出状态前</code>, 我们称该子进程处于<code>僵尸态</code></li><li>另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) <code>父进程结束运行之后, 子进程退出之前</code>, 处于<code>僵尸态</code></li></ul><p>以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.</p><p>waitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.<br>SIGCHLD信号- 子进程结束后将会给父进程发送此信号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_child</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> stat;</span><br><span class="line"><span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 善后处理emmmm</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量-进程的锁"><a href="#信号量-进程的锁" class="headerlink" title="信号量-进程的锁"></a>信号量-进程的锁</h2><p><em>信号量原语</em><br>只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.<br>假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为</p><ul><li>P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行</li><li>V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png" alt=""></li></ul><p><strong>总结PV使用方法</strong></p><p>使用<code>semget</code>获取到唯一的标识.<br>使用<code>semctl</code>的<code>SETVAL</code>传入初始化val的<code>sem_un</code>联合体.来初始化val<br>调用<code>semop</code> 传入唯一标识, <code>sem_op=-1</code>执行P(锁)操作<code>sem_op=1</code>执行V(开锁)操作<br>开关锁通过当<code>sem_op=-1,semval=0</code><br>且未指定<code>IPC_NOWAIT</code><br>等待<code>semval</code>被<code>sem_op=1</code>改为<code>semval=1</code></p><p><strong>创建信号量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semeget 系统调用</span></span><br><span class="line"><span class="comment">// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集</span></span><br><span class="line"><span class="comment">// key 参数是一个键值, 用来标识一个全局唯一的信号量级,可以在不同进程中获取</span></span><br><span class="line"><span class="comment">// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0. 一般都是为1</span></span><br><span class="line"><span class="comment">// sem_flags指定一组标志, 来控制权限</span></span><br><span class="line"><span class="comment">// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错</span></span><br><span class="line"><span class="comment">// - IPC_CREAT | IPC_EXCL来创建一组唯一信号量集 如果已经存在则会返回错误 errno = EEXIST</span></span><br><span class="line"><span class="comment">// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sem_id = semget((<span class="keyword">key_t</span>)<span class="number">1234</span>, <span class="number">1</span>, <span class="number">0666</span> | IPC_CREAT);</span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semctl 系统调用</span></span><br><span class="line"><span class="comment">// sem_id 参数是由semget返回的信号量集标识符</span></span><br><span class="line"><span class="comment">// sen_num指定被操作的信号量在信号集中的编号</span></span><br><span class="line"><span class="comment">// command指定命令, 可以追加命令所需的参数, 不过有推荐格式</span></span><br><span class="line"><span class="comment">// 成功返回对应command的参数, 失败返回-1 errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> command, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四个参数 竟然需要手动声明...</span></span><br><span class="line"><span class="keyword">union</span> semun</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span>              val;    <span class="comment">/* Value for SETVAL */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>    <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line"><span class="keyword">unsigned</span> short  *<span class="built_in">array</span>;  <span class="comment">/* Array for GETALL, SETALL */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>  *__<span class="title">buf</span>;</span>  <span class="comment">/* Buffer for IPC_INFO</span></span><br><span class="line"><span class="comment">(Linux-specific) */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="keyword">union</span> semun sem_union;</span><br><span class="line">sem_union.val = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 这里可以直接第三个参数传入1(val)</span></span><br><span class="line"><span class="keyword">if</span> (semctl(sem_id, <span class="number">0</span>, SETVAL, sem_union) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量</span></span><br><span class="line"><span class="keyword">union</span> semun sem_union&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (semctl(sem_id, <span class="number">0</span>, IPC_RMID, sem_union) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>与semop信号量关联的一些重要的内核变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> short semval; <span class="comment">// 信号量的值</span></span><br><span class="line"><span class="keyword">unsigned</span> short semzcnt; <span class="comment">// 等待信号量值变为0的进程数量</span></span><br><span class="line"><span class="keyword">unsigned</span> short semncnt<span class="comment">// 等待信号量值增加的进程数量</span></span><br><span class="line"><span class="keyword">pid_t</span> sempid; <span class="comment">// 最后一次执行semop操作的进程ID</span></span><br></pre></td></tr></table></figure><p>操作信号量, 实际上就是对上面的内核变量操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.</span></span><br><span class="line"><span class="comment">// sem_ops 参数指向一个sembuf结构体类型的数组</span></span><br><span class="line"><span class="comment">// num_sem_ops 说明操作数组中哪个信号量</span></span><br><span class="line"><span class="comment">// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> sem_id, struct sembuf* sem_ops, <span class="keyword">size_t</span> num_sem_ops)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sem_op &lt; 0 期望获得信号量</span></span><br><span class="line"><span class="comment">// semval-=abs(sem_op),要求调用进程对被操作信号量集有写权限</span></span><br><span class="line"><span class="comment">// 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果semval &lt; abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN</span></span><br><span class="line"><span class="comment">// 如果没有指定 则 阻塞进程等待信号量可用, 且 semzcnt +=1, 等到下面三种情况唤醒</span></span><br><span class="line"><span class="comment">// 1 发生semval &gt;= abs(sem_op), semzcnt-=1, semval-=abs(sem_op). 在SEM_UNDO设置时更新semadj</span></span><br><span class="line"><span class="comment">// 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)</span></span><br><span class="line"><span class="comment">// 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">P</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>; <span class="comment">// 信号量编号 第几个信号量 一般都是第0个</span></span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>; <span class="comment">// P</span></span><br><span class="line"><span class="comment">// IPC_NOWAIT 无论信号量操作是否成功, 都立即返回</span></span><br><span class="line"><span class="comment">// SEM_UNDO当进程退出的时候, 取消正在进行的semop操作 PV操作系统更新进程的semadj变量</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">return</span> semop(sem_id, &amp;sem_b, <span class="number">1</span>) != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// sem_op &gt; 0 </span></span><br><span class="line"><span class="comment">// semval+=sem_op , 要求调用进程对被操作的信号量集有写权限</span></span><br><span class="line"><span class="comment">// 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">V</span><span class="params">(<span class="keyword">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>;</span></span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>; <span class="comment">// V</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">return</span> semop(sem_id, &amp;sem_b, <span class="number">1</span>) != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -- sem_op = 0</span></span><br><span class="line"><span class="comment">// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限</span></span><br><span class="line"><span class="comment">// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0</span></span><br><span class="line"><span class="comment">// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN</span></span><br><span class="line"><span class="comment">// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生</span></span><br><span class="line"><span class="comment">// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1</span></span><br><span class="line"><span class="comment">// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM</span></span><br><span class="line"><span class="comment">// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1</span></span><br></pre></td></tr></table></figure><p>semget成功时返回一个与之关联的内核结构体semid_ds</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> sem_nsems; <span class="comment">// 被设置为num_sems</span></span><br><span class="line"><span class="keyword">time_t</span> sem_otime; <span class="comment">// 被设置为0</span></span><br><span class="line"><span class="keyword">time_t</span> sem_ctime; <span class="comment">// 被设置为当前的系统时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用来描述权限</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">uid_t</span> uid; <span class="comment">// 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="keyword">gid_t</span> gid; <span class="comment">// 所有者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="keyword">uid_t</span> cuid; <span class="comment">// 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="keyword">gid_t</span> cgid; <span class="comment">// 创建者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="keyword">mode_t</span> mode;<span class="comment">// 访问权限, 背着只为sem_flags参数的最低9位.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享内存-进程间通信"><a href="#共享内存-进程间通信" class="headerlink" title="共享内存-进程间通信"></a>共享内存-进程间通信</h2><p><strong>最高效的IPC(进程间通信)机制</strong><br>需要自己同步进程对其的访问, 否则会产生竞态条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key</span></span><br><span class="line"><span class="comment">// 与semget相同 标识一段全局唯一的共享内存</span></span><br><span class="line"><span class="comment">// size 内存区域大小 单位字节</span></span><br><span class="line"><span class="comment">// shmflg</span></span><br><span class="line"><span class="comment">// IPC_CREAT 存不存在都创建新的共享内存</span></span><br><span class="line"><span class="comment">// IPC_CREAT | IPC_EXCL 不存在则创建 存在则报错</span></span><br><span class="line"><span class="comment">// SHM_HUGETLB 系统将使用"大页面"来为共享内存分配空间</span></span><br><span class="line"><span class="comment">// SHM_NORESERVE 不为共享内存保留swap空间, 如果物理内存不足</span></span><br><span class="line"><span class="comment">// -在执行写操作的时候将会触发`SIGSEGV`信号</span></span><br><span class="line"><span class="comment">// -成功返回唯一标识, 失败返回-1 errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> shmflg)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shm_id </span></span><br><span class="line"><span class="comment">// shmget返回的唯一标识</span></span><br><span class="line"><span class="comment">// shm_addr </span></span><br><span class="line"><span class="comment">// 关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响</span></span><br><span class="line"><span class="comment">// 如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强</span></span><br><span class="line"><span class="comment">// 如果 shm_addr 非空,且没有`SHM_RND`标志 则关联到指定的地址处</span></span><br><span class="line"><span class="comment">// 如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写*</span></span><br><span class="line"><span class="comment">// shmflg</span></span><br><span class="line"><span class="comment">// SHM_RDONLY 设置后内存内容变成只读, 不设置则为读写模式</span></span><br><span class="line"><span class="comment">// SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联</span></span><br><span class="line"><span class="comment">// SHM_EXEC 有执行权限</span></span><br><span class="line"><span class="comment">// 成功返回关联到的地址, 失败返回 (void*)-1 errno</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span>* shm_addr, <span class="keyword">int</span> shmflg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将共享内存关联到进程的地址空间 调用成功之后, 修改shmid_ds的部分内容</span></span></span><br><span class="line"><span class="function"><span class="comment">// -shm_nattach +1</span></span></span><br><span class="line"><span class="function"><span class="comment">// -更新 shm_lpid</span></span></span><br><span class="line"><span class="function"><span class="comment">// -shm_atime设置为当前时间</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将共享内存从进程地址空间中分离</span></span><br><span class="line"><span class="comment">// 成功后</span></span><br><span class="line"><span class="comment">// -shm_nattach -1</span></span><br><span class="line"><span class="comment">// -更新 shm_lpid和shm_dtime设置为当前时间</span></span><br><span class="line"><span class="comment">// 成功返回0 失败返回-1 errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* shm_addr)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_ctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds* buf)</span></span></span><br></pre></td></tr></table></figure><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/shmctl.png" alt=""></p><hr><p>shmget 同时会创建对应的<code>shmid_ds</code>结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_per</span>;</span> <span class="comment">// 权限相关</span></span><br><span class="line"><span class="keyword">size_t</span> shm_segsz; <span class="comment">// 共享内存大小 单位字节size</span></span><br><span class="line"><span class="keyword">__time_t</span> shm_atime; <span class="comment">// 对这段内存最后一次调用semat的时间 0</span></span><br><span class="line"><span class="keyword">__time_t</span> shm_dtime; <span class="comment">// 对这段内存最后一次调用semdt的时间 0</span></span><br><span class="line"><span class="keyword">__time_t</span> shm_ctime; <span class="comment">// 对这段内存最后一次调用semctl的时间 当前时间</span></span><br><span class="line"><span class="keyword">__pid_t</span> shm_cpid; <span class="comment">// 创建者PID</span></span><br><span class="line"><span class="keyword">__pid_t</span> lpid; <span class="comment">// 最后一次执行shmat或shmdt的进程PID</span></span><br><span class="line"><span class="keyword">shmatt_t</span> shm_nattach <span class="comment">// 关联到此共享内存空间的进程数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>共享内存的POSIX方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> shmfd = shm_open(<span class="string">"/shm_name"</span>, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">ERROR_IF(shmfd == <span class="number">-1</span>, <span class="string">"shm open"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = ftruncate(shmfd, BUFFER_SIZE);</span><br><span class="line">ERROR_IF(ret == <span class="number">-1</span>, <span class="string">"ftruncate"</span>);</span><br><span class="line"></span><br><span class="line">share_mem = (<span class="keyword">char</span>*)mmap(<span class="literal">nullptr</span>, BUFFER_SIZE,</span><br><span class="line">PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, <span class="number">0</span>);</span><br><span class="line">ERROR_IF(share_mem == MAP_FAILED, <span class="string">"share_mem"</span>);</span><br><span class="line"><span class="built_in">close</span>(shmfd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消关联</span></span><br><span class="line">munmap((<span class="keyword">void</span>*)share_mem, BUFFER_SIZE);</span><br></pre></td></tr></table></figure><h2 id="进程通信-管道"><a href="#进程通信-管道" class="headerlink" title="进程通信-管道"></a>进程通信-管道</h2><p>管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证<br>父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].</p><p>可以用两个管道来实现双向传输数据, 也可以用<code>socketpair</code>来创建管道</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是两个进程之间传递二进制块数据的一种简单有效的方式.<br>每个数据块都有自己的类型, 接收方可以根据类型有选择的接收数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">// 与semget 相同, 成功返回标识符</span></span><br><span class="line"><span class="comment">// msgflg的设置和作用域setget相同</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msg_ptr参数指向一个准备发送的消息, 消息必须按如下定义</span></span><br><span class="line"><span class="comment">// msg_sz 指的是mtext的长度!!!</span></span><br><span class="line"><span class="comment">// msgflg通常仅支持IPC_NOWAIT 以非阻塞形式发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span> *msg_ptr, <span class="keyword">size_t</span> msg_sz, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line">默认如果消息队列已满, 则会阻塞. 如果设置了 IPC_NOTWAIT</span><br><span class="line">就立即返回 设置errno=EAGIN</span><br><span class="line"></span><br><span class="line">系统自带这个结构体 不过mtext长度是<span class="number">1.</span>..</span><br><span class="line">struct msgbuf</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> mtype; <span class="comment">/* 消息类型 正整数*/</span></span><br><span class="line"><span class="keyword">char</span> mtext[<span class="number">512</span>]; <span class="comment">/* 消息数据*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msgtype = 0 读取消息队列第一个消息</span></span><br><span class="line"><span class="comment">// msgtype &gt; 0 读取消息队列第一个类型是msgtype的消息 除非标志了MSG_EXCEPT</span></span><br><span class="line"><span class="comment">// msgtype &lt; 0 读取第一个 类型值 &lt; abs(msgtype)的消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IPC_NOWAIT 如果消息队列没有消息, 则msgrcv立即返回并设置errno=ENOMSG</span></span><br><span class="line"><span class="comment">// MSG_EXCEPT 如果msgtype大于0, 则接收第一个非 msgtype 的数据</span></span><br><span class="line"><span class="comment">// MSG_NOERROR 消息部分长度超过msg_sz 则将它截断</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">void</span> *msg_ptr, <span class="keyword">size_t</span> msg_sz, <span class="keyword">long</span> <span class="keyword">int</span> msgtype, <span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line">处于阻塞状态 当消息队列被移除(errno=EIDRM)或者程序接受到信号(errno=EINTR) 都会中断阻塞状态</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">int</span> command, struct msqid_ds *buf)</span></span>;</span><br><span class="line"></span><br><span class="line">IPC_STAT 复制消息队列关联的数据结构</span><br><span class="line">IPC_SET 将buf中的部分成员更新到目标的内核数据</span><br><span class="line">IPC_RMID 立即移除消息队列, 唤醒所有等待读消息和写消息的进程</span><br><span class="line">IPC_INFO 获取系统消息队列资源配置信息</span><br><span class="line"></span><br><span class="line">MSG_INFO 返回已经分配的消息队列所占用资源信息</span><br><span class="line">MSG_STAT msgqid不再是标识符, 而是内核消息队列的数组索引</span><br></pre></td></tr></table></figure><h2 id="在进程间传递文件描述符"><a href="#在进程间传递文件描述符" class="headerlink" title="在进程间传递文件描述符"></a>在进程间传递文件描述符</h2><h2 id="IPC命令-查看进程间通信的全局唯一key"><a href="#IPC命令-查看进程间通信的全局唯一key" class="headerlink" title="IPC命令-查看进程间通信的全局唯一key"></a>IPC命令-查看进程间通信的全局唯一key</h2><h1 id="第十四章-多线程编程"><a href="#第十四章-多线程编程" class="headerlink" title="第十四章 多线程编程"></a>第十四章 多线程编程</h1><p>根据运行环境和调度者身份, 线程可以分为两种<br>内核线程<br>运行在内核空间, 由内核来调度.<br>用户线程<br>运行在用空间, 由线程库来调用</p><p>当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.</p><p>线程有三种实现方式</p><ul><li>完全在用户空间实现-无需内核支持<br>  创建和调度线程无需内核干预, 速度很快.<br>  不占用额外的内核资源, 对系统影响较小<br>  但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的</li><li>完全由内核调度<br>  创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理<br>  优缺点正好与上一个相反</li><li>双层调度<br>  结合了前两个的优点<br>  不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势</li></ul><h2 id="进程的创建和终止"><a href="#进程的创建和终止" class="headerlink" title="进程的创建和终止"></a>进程的创建和终止</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/pthreadtypes.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">pthread_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* attr, <span class="keyword">void</span>* (*start_routine)(<span class="keyword">void</span>*), <span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0 失败返回错误码</span></span><br><span class="line"><span class="comment">// thread 用来唯一的标识一个新线程</span></span><br><span class="line"><span class="comment">// attr用来设置新县城的属性 传递NULL表示默认线程属性</span></span><br><span class="line"><span class="comment">// start_routine 指定新线程运行的函数</span></span><br><span class="line"><span class="comment">// arg指定函数的参数</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span>* retval)</span></span>;</span><br><span class="line">用来保证线程安全干净的退出, 线程函数最好结束时调用.</span><br><span class="line">通过`retval`参数向线程的回收者传递其退出信息</span><br><span class="line">执行后不会返回到调用者, 而且永远不会失败</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span>** retval)</span></span></span><br><span class="line">可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.</span><br><span class="line">成功时返回<span class="number">0</span>, 失败返回错误码</span><br><span class="line">等待其他线程结束</span><br><span class="line">thread 线程标识符</span><br><span class="line">retval 目标线程的退出返回信息</span><br><span class="line"></span><br><span class="line">错误码如下</span><br><span class="line">`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用</span><br><span class="line">`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程</span><br><span class="line">`ESRCH`目标线程不存在</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span></span><br><span class="line">异常终止一个线程, 即为取消线程</span><br><span class="line">成功返回<span class="number">0</span>, 失败返回错误码</span><br><span class="line"></span><br><span class="line">接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.</span><br><span class="line">一下两个函数成功返回<span class="number">0</span> 失败返回错误码</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动线程取消</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstart</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span>* oldstate)</span></span></span><br><span class="line">第一个参数</span><br><span class="line">PTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态</span><br><span class="line">PTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求指导</span><br><span class="line">这个线程允许被取消</span><br><span class="line">第二个参数 返回之前设定的状态</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程取消类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span>* oldtype)</span></span></span><br><span class="line">第一个参数</span><br><span class="line">PTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消</span><br><span class="line">PTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 知道调用了下面几个所谓的取消点函数</span><br><span class="line">最好使用`pthread_testcancel`函数设置取消点</span><br><span class="line">设置取消类型(如何取消)</span><br><span class="line">第二个参数</span><br><span class="line">原来的取消类型</span><br></pre></td></tr></table></figure><h2 id="POSIX信号量-进程的同步"><a href="#POSIX信号量-进程的同步" class="headerlink" title="POSIX信号量-进程的同步"></a>POSIX信号量-进程的同步</h2><p>多线程也必须考虑线程同步的问题.<br>虽然<code>pthread_join</code>可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求<br>比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.</p><p>以下函数成功返回0 失败返回-1 errno<br><code>int sem_init(sem_t* sem, int pshared, unsigned int value)</code><br>用于初始化一个未命名的信号量.<br>如果<code>pshared</code>为0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享<br><code>value</code>指定参数的初始值<br><em>初始化已经存在的信号量会导致无法预期的结果</em></p><p><code>int sem_destory(sem_t* sem)</code><br>销毁信号量, 释放其占用的系统资源<br><em>销毁正被其他线程等待的信号量, 将会导致无法预期的结果</em></p><p><code>int sem_wait(sem_t* sem)</code><br>以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞, 知道信号量具有非0值</p><p><code>int sem_trywait(sem_t* sem)</code><br>跟上面的函数相同不过不会阻塞. 信号量不为0 则 -1, 为0 则返回-1 errno</p><p><code>int sem_post(sem_t sem)</code><br>原子操作将信号量的值 +1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十三章多进程编程&quot;&gt;&lt;a href=&quot;#第十三章多进程编程&quot; class=&quot;headerlink&quot; title=&quot;第十三章多进程编程&quot;&gt;&lt;/a&gt;第十三章多进程编程&lt;/h1&gt;&lt;h2 id=&quot;exec系列系统调用&quot;&gt;&lt;a href=&quot;#exec系列系统调用&quot; cla
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>commit规范</title>
    <link href="http://blog.lsmg.xyz/2020/02/Git-commit%E8%A7%84%E8%8C%83/"/>
    <id>http://blog.lsmg.xyz/2020/02/Git-commit%E8%A7%84%E8%8C%83/</id>
    <published>2020-02-22T04:22:02.000Z</published>
    <updated>2020-03-07T12:51:06.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="commit-规范"><a href="#commit-规范" class="headerlink" title="commit 规范"></a>commit 规范</h1><p><a href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">阮一峰 Commit message 和 Change log 编写指南</a></p><p>Angular 规范.<br>每个commit message 包括三分部<br>Header Body 和 Footer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; &#x2F;&#x2F; 必须</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;body&gt; &#x2F;&#x2F; 非必须</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;footer&gt; &#x2F;&#x2F;非必须</span><br></pre></td></tr></table></figure><p><strong>Header</strong></p><ol><li>type 必需 - 说明commit的类别, 只允许下面七个标识</li></ol><ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><ol start="2"><li><p>scope 非必需 - 用于说明 commit影响的范围<br>比如登录、注册、充值逻辑等等，视项目不同而不同。</p></li><li><p>subject 必需 - commit 目的的简短描述 </p></li></ol><ul><li>不超过50字符 </li><li>第一人称现在时动词开头</li><li>首字母小写</li><li>句尾不加句号</li></ul><p><strong>Body</strong><br>本次commit的详细描述, 可以分成多行</p><p><strong>Footer</strong><br>只用于两种情况 目前用不动 不摘了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;commit-规范&quot;&gt;&lt;a href=&quot;#commit-规范&quot; class=&quot;headerlink&quot; title=&quot;commit 规范&quot;&gt;&lt;/a&gt;commit 规范&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.ruanyifeng.com/blog/2
      
    
    </summary>
    
    
      <category term="必备技能" scheme="http://blog.lsmg.xyz/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
      <category term="Git操作" scheme="http://blog.lsmg.xyz/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/Git%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="Git操作" scheme="http://blog.lsmg.xyz/tags/Git%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>CPP11特性</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-CPP11%E7%89%B9%E6%80%A7/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-CPP11%E7%89%B9%E6%80%A7/</id>
    <published>2020-02-19T09:41:27.000Z</published>
    <updated>2020-02-20T15:21:12.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><p>参考资料<br><a href="https://zh.cppreference.com/w/cpp/language/lambda" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/language/lambda</a><br><a href="https://blog.csdn.net/qq_34199383/article/details/80469780" target="_blank" rel="noopener">https://blog.csdn.net/qq_34199383/article/details/80469780</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[ 捕获 ] ( 形参 ) -&gt; ret &#123; 函数体 &#125;</span><br><span class="line">[ 捕获 ] ( 形参 ) &#123; 函数体 &#125;</span><br><span class="line">[ 捕获 ] &#123; 函数体 &#125;</span><br><span class="line"></span><br><span class="line">&amp; 以引用隐式捕获被使用的自动变量</span><br><span class="line">= 以复制隐式捕获被使用的自动变量</span><br><span class="line"></span><br><span class="line">[&amp;]&#123;&#125;;          <span class="comment">// OK：默认以引用捕获</span></span><br><span class="line">[&amp;, i]&#123;&#125;;       <span class="comment">// OK：以引用捕获，但 i 以值捕获</span></span><br><span class="line"></span><br><span class="line">[=]&#123;&#125;;          <span class="comment">// OK：默认以复制捕获</span></span><br><span class="line">[=, &amp;i]&#123;&#125;;      <span class="comment">// OK：以复制捕获，但 i 以引用捕获</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">this</span>]&#123;&#125;; <span class="comment">// 获取this指针, 如果使用了&amp;和=则会默认包括this</span></span><br></pre></td></tr></table></figure><p><strong>使用场景一</strong><br>以sort为代表的函数 需要传入函数的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原版</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xxx(compare);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新版</span></span><br><span class="line">xxx([](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a &gt; b;&#125;);</span><br></pre></td></tr></table></figure><p><strong>使用场景二</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a + b;&#125;;</span><br><span class="line"><span class="keyword">int</span> bar = add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h1 id="类型特性"><a href="#类型特性" class="headerlink" title="类型特性"></a>类型特性</h1><p><a href="https://zh.cppreference.com/w/cpp/types#.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/types#.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29</a></p><p>神仙的头文件<type_traits> 可以判断一个值是否是某个类型</p><p>比如判断一个值<br>是不是 整形<br>是不是 void<br>是不是 数组 等等</p><p>目前不知道用在什么地方合适….. 留个连接备用吧</p><h1 id="花括号初始"><a href="#花括号初始" class="headerlink" title="花括号初始"></a>花括号初始</h1><h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><h2 id="std-function-functional"><a href="#std-function-functional" class="headerlink" title="std::function  functional"></a>std::function  functional</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintB</span><span class="params">(<span class="keyword">int</span> bar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; FPrintA = PrintA;</span><br><span class="line">    FPrintA();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; FPrintB = PrintB;</span><br><span class="line">    FPrintB(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 感觉配合Lambad 挺不错, 在一个函数中经常使用的功能可以这样定义</span></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; FLambad = []()&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Lambad"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    FLambad();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不过使用auto貌似更简单</span></span><br><span class="line"><span class="keyword">auto</span> ALambad = []()&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Lambad"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    ALambad();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ A</span><br><span class="line">$ B</span><br><span class="line">$ Lambad</span><br></pre></td></tr></table></figure><h2 id="std-pair-utility-std-tuple-tuple"><a href="#std-pair-utility-std-tuple-tuple" class="headerlink" title="std::pair utility std::tuple tuple"></a>std::pair utility std::tuple tuple</h2><p><a href="https://zh.cppreference.com/w/cpp/utility/tuple" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/utility/tuple</a></p><p>pair是 结构体模板, 可在一个单元中存储两个相异对象. pair是tuple拥有两个元素的特殊情况</p><p>tuple是固定大小的异类值(啥是异类值??)汇集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;int, double &gt; GetInfoById(int id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1</span>, <span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">2</span>, <span class="number">2.2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::invalid_argument(<span class="string">"id"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> info = GetInfoById(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取指定位置</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(info)</span><br><span class="line">            &lt;&lt; <span class="string">" 2:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(info) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val1;</span><br><span class="line">    <span class="keyword">double</span> val2;</span><br><span class="line"><span class="comment">// 直接创建引用的tuple</span></span><br><span class="line">    <span class="built_in">std</span>::tie(val1, val2) = GetInfoById(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1:"</span> &lt;&lt; val1</span><br><span class="line">              &lt;&lt; <span class="string">" 2:"</span> &lt;&lt; val2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">$ <span class="number">1</span>:<span class="number">1</span> <span class="number">2</span>:<span class="number">1.1</span></span><br><span class="line">$ <span class="number">1</span>:<span class="number">2</span> <span class="number">2</span>:<span class="number">2.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lambda&quot;&gt;&lt;a href=&quot;#Lambda&quot; class=&quot;headerlink&quot; title=&quot;Lambda&quot;&gt;&lt;/a&gt;Lambda&lt;/h1&gt;&lt;p&gt;参考资料&lt;br&gt;&lt;a href=&quot;https://zh.cppreference.com/w/cpp/lan
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
</feed>
