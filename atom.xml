<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lsmg的大学之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lsmg.xyz/"/>
  <updated>2020-04-04T09:22:32.383Z</updated>
  <id>http://blog.lsmg.xyz/</id>
  
  <author>
    <name>Lsmg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux多线程服务器端编程</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95120-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95120-Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-03-31T09:19:39.000Z</published>
    <updated>2020-04-04T09:22:32.383Z</updated>
    
    <content type="html"><![CDATA[<p>Linux高性能服务器编程基本看玩了, 现在需要进行实战练习, 然而从单纯的只会api到做出项目, 之间的距离<br>不是一般的小, 最终我选择了这本书…..</p><p>相关自己写的代码 大部分放在github 少部分会写在博客中</p><h1 id="第一部分-C-多线程系统编程"><a href="#第一部分-C-多线程系统编程" class="headerlink" title="第一部分 C++多线程系统编程"></a>第一部分 C++多线程系统编程</h1><h2 id="第一章-线程安全的对象生命期管理"><a href="#第一章-线程安全的对象生命期管理" class="headerlink" title="第一章 线程安全的对象生命期管理"></a>第一章 线程安全的对象生命期管理</h2><p>一个线程安全的class需要满足的条件</p><ul><li>多个线程同时访问, 其表现出正确的行为</li><li>无论操作系统如何调度这些线程, 无论这些线程的执行顺序如何交织</li><li>调用端代码无需额外的同步或其他协调操作</li></ul><p>对象构造的安全, 在构造期间不要泄露this指针, 如果不按照以下规定可能会早对象构造完成前就被访问</p><ul><li>不要在构造函数中注册任何回调</li><li>不要在构造函数中把this传给跨线程的对象</li><li>即便在构造函数最后一行也不行, 因为对象可能是一个父类, 会先构造父类部分, 再构造子类部分</li></ul><p>二段式构造有时候可以解决上面的问题</p><p>二段式构造-构造函数+initialize()<br>因为构造函数没有办法告知是否构造成功, 如果使用异常处理将会使代码复杂化.<br>比如在构造函数中使用new操作, 如果new操作失败就会出现不可预料的后果, 然后外部却无法知道<br>再比如将this传给其他跨线程对象, 如果构造结束前传入, 可能就会发生问题</p><p><strong>shared_ptr的引出</strong><br>如果在一个对象中通过指针访问资源(另一个对象), 知道这个资源是否活着是很难的.<br>如果简单的判断指针是否为空, 可能会在线程B已经判断了指针不为空还没有执行后续操作时, 线程A就把<br>这个资源释放掉了</p><p>当然可以通过资源管理对象 管理上面的资源, 但是也存在上面的问题.</p><p>所以要想安全的销毁对象最好在其他线程都看不到的情况下偷偷进行. (垃圾回收原理, 所有人用不到的东西一定是垃圾)</p><p>所以可以再资源管理对象中增加引用计数, 外部对象在释放资源管理对象中资源的时候, 只是将引用计数减一, 当引用计数为0的时候 在进行释放.</p><p>C++可能出现的内存问题</p><ul><li>缓冲区溢出<br>使用<code>std::vector&lt;char&gt;/std::string</code>或者自己编写<code>Buffer Class来管理缓冲区</code>. 记住缓冲区长度, 通过成员函数而不是裸指针修改缓冲区</li><li>空悬指针/野指针<br>使用shared_ptr/weak_ptr</li><li>重复释放<br>使用scoped_ptr, 只在对象析构的时候释放一次</li><li>内存泄漏<br>使用scoped_ptr, 对象析构时自动释放内存</li><li>不配对的new[]/delete<br>把new[] 统统替换成std::vector, scoped_array</li><li>内存碎片</li></ul><p>使用智能指针存在的一些问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) :name_(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Register</span><span class="params">(<span class="built_in">std</span>::weak_ptr&lt;Book&gt; book)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        books_.push_back(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckBook</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 锁争用</span></span><br><span class="line">        <span class="comment">// 这里开头上锁 很可能影响其他的函数, 因为这里调用了用户提供的函数, 等待时间可能会非常长</span></span><br><span class="line">        <span class="comment">// 比如Register函数就没有办法在这段时间中插入新的book</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// mutex lock 开头上锁 保护vector</span></span><br><span class="line">        Iterator iter = books_.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (iter != books_.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; <span class="title">obj</span><span class="params">(iter-&gt;lock())</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (obj)</span><br><span class="line">            &#123;</span><br><span class="line">                obj-&gt;DoSomething();</span><br><span class="line">                iter++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                iter = books_.erase(iter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 这样就强制要求了Book必须以shared_ptr管理</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::weak_ptr&lt;Book&gt;&gt;::iterator Iterator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在对象的成员变量vector中保存shared_ptr 会导致管理的资源无法被释放, 因为引用计数最少为1.<br>如果保存weak_ptr可能会导致vector只增不减, 因为weak_ptr只管自己管理的资源, 不管自己.<br>通过定制shared_ptr的析构函数可以解决这个问题</p><p>如果将某个类的this指针 bind到一个function对象, 可能在函数调用时传进入一个已经被释放的对象地址<br>建议使用shared_ptr解决上面的问题, 如果想要获得this指针对应的shared_ptr, 可以另类继承<br><code>enable_shared_from_this&lt;T&gt;</code>, 通过在bind函数绑定<code>shared_from_this()返回的shared_ptr</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span>:</span><span class="built_in">std</span>::enable_shared_from_this&lt;BookShelf&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Book对象固然可以销毁, 但是出现了轻微的内存泄漏</span></span><br><span class="line">    <span class="comment">// book_只增不减!!!!. 虽然Book对象销毁了但是book_中依然保存着weak_ptr</span></span><br><span class="line">    <span class="comment">// 所以需要定制析构功能</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; <span class="title">GetBook</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;bookname)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; pbook;</span><br><span class="line">        <span class="comment">// 上锁</span></span><br><span class="line">        <span class="built_in">std</span>::weak_ptr&lt;Book&gt;&amp; wkbook = books_[bookname];</span><br><span class="line">        pbook = wkbook.lock();</span><br><span class="line">        <span class="keyword">if</span> (!pbook)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// pbook.reset(new Book(bookname));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 依然有问题 绑定this指针可能到时候this指向的对象已经不复存在了</span></span><br><span class="line">            <span class="comment">// pbook.reset(new Book(bookname),</span></span><br><span class="line">            <span class="comment">//   std::bind(&amp;BookShelf::DeleteBook, this, std::placeholders::_1));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意shared_from_this不能在构造函数中调用, 因为构造Bookshelf的时候 他还没有</span></span><br><span class="line">            <span class="comment">// 被交给shared_ptr管理</span></span><br><span class="line">            pbook.reset(<span class="keyword">new</span> Book(bookname),</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;BookShelf::DeleteBook, shared_from_this(), <span class="built_in">std</span>::placeholders::_1));</span><br><span class="line"></span><br><span class="line">            wkbook = pbook;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pbook;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteBook</span><span class="params">(Book* book)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (book)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 上锁</span></span><br><span class="line">            books_.erase(book-&gt;GetName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而上面的代码依然有问题<br>依然有个问题. BookShelf的生命期似乎被意外延长了, 他不会短于function对象<br>所以改用weak_pr不就可以了吗</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span>:</span><span class="built_in">std</span>::enable_shared_from_this&lt;BookShelf&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; <span class="title">GetBook</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;bookname)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Book&gt; pbook;</span><br><span class="line">        <span class="built_in">std</span>::weak_ptr&lt;Book&gt;&amp; wkbook = books_[bookname];</span><br><span class="line">        pbook = wkbook.lock();</span><br><span class="line">        <span class="keyword">if</span> (!pbook)</span><br><span class="line">        &#123;</span><br><span class="line">            pbook.reset(<span class="keyword">new</span> Book(bookname),</span><br><span class="line">                <span class="built_in">std</span>::bind(&amp;BookShelf::WkDeleteCallback,</span><br><span class="line">                    <span class="built_in">std</span>::weak_ptr&lt;BookShelf&gt;(shared_from_this()),</span><br><span class="line">                    <span class="built_in">std</span>::placeholders::_1));</span><br><span class="line"></span><br><span class="line">            wkbook = pbook;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pbook;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">WkDeleteCallback</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::weak_ptr&lt;BookShelf&gt; wk_shelf, Book* book)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;BookShelf&gt; <span class="title">bookshelf</span><span class="params">(wk_shelf.lock())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (bookshelf)</span><br><span class="line">        &#123;</span><br><span class="line">            DeleteBook(book);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DeleteBook</span><span class="params">(Book* book)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (book)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 上锁</span></span><br><span class="line">            books_.erase(book-&gt;GetName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一章已经读完了, 笔记只有上面那点. 我在学习Linux高性能服务器编程的大二上半年时间照着书边读边写笔记, 然后后来到了大二下我改成了读完一部分后脑中有什么记什么, 重要的地方如果记不清写不出来就去再看一下. 这样花费在记笔记的时间就少了很多, 写出来的笔记更加方便自己阅读.</p><p>第一章部分内容能看懂 真是谢了之前看的那个项目代码, 那个项目中大量使用了智能指针, 我在读哪个项目的代码的时候查了不少的东西, 现在才能看懂第一章的部分东西.<br>然而大部分?的东西感觉还是似懂非懂, 想写又写不出什么来. 我对于智能指针的使用还是过于晚了把.</p><p>第一章看来后续还要读一遍了</p><h2 id="第二章-线程同步精要"><a href="#第二章-线程同步精要" class="headerlink" title="第二章 线程同步精要"></a>第二章 线程同步精要</h2><p><strong>线程同步的四项原则</strong><br>按重要性排列</p><ol><li>最低限度的共享对象, 减少需要同步的场合, <em>不用就不需要同步了nice!!!</em></li><li>使用高级的并发编程构建, 线程池, 队列, 倒计时</li><li>不得已使用底层同步原语时, 只使用非递归的互斥器和条件变量, 慎用读写锁, 不要用信号量</li><li>除了使用atomic整数外, 不要自己编写lock-free代码, 也不要用内核级的同步原语. 不凭空猜测<br>哪种做法性能更好 比如自旋锁和互斥锁</li></ol><p><strong>互斥器 mutex</strong><br>使用mutex的原则</p><ul><li>使用RAII手法封装mutex的创建销毁加锁解锁这四个操作, 不会因异常而忘记解锁</li><li>只使用非递归的mutex即不可重入的mutex<br>容易排查错误 使用递归mutex问题可能出现也可能不出现(可能由于逻辑问题对一个mutex加锁两次), 而使用非递归即可发现错误并改正</li><li>不手工调用lock()和unlock() 函数, <em>一切交给栈上的Guard对象的构造和析构函数负责</em></li><li>Gruad对象的生命期正好等于临界区</li></ul><p>次要原则</p><ul><li>不使用跨进程的mutex, 进程间通信只用TCP sockets</li><li>加锁解锁在同一个线程 不会出现跨线程的操作 (RAII自动保证)</li><li>不忘记解锁(包括各种提前返回和异常抛出) 不重复解锁 均由RAII自动保证</li><li>必要时考虑用PTHREAD_MUTEX_ERRORCHECK来排错</li></ul><p><strong>封装MutexLock MutexLockGuard Condition</strong><br>在Linux高性能服务器编程中 我也看过了封装mutex, 不过当时并没有使用RAII<br>从这里开始算是对RAII(Resource Acquisition Is Initialization)有了了解</p><p><a href="https://zh.cppreference.com/w/cpp/language/raii" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/language/raii</a><br>拥有open()/close()、lock()/unlock()，或 init()/copyFrom()/destroy()成员函数的类是非RAII类的典型例子</p><p>RAII将资源封装入一个类 如MutexLock类</p><ul><li>构造函数请求资源, 建立所有类不变式, 或在无法完成时抛出异常</li><li>析构函数释放资源并绝不抛出异常<br>始终经由RALL类的实例使用满足要求的资源如MutexLockGuard类, 资源需满足</li><li>自身拥有自动存储期或临时生存期</li><li>或具有与自动或临时对象的生存期绑定的生存期</li></ul><p>自己的理解就是经由RAII类生存期管理资源, RAII生存期开始即使用资源,<br>当RAII类生存期结束, RAII类中保存着的资源也自动销毁<br>RAII可以有效防止上面那些成对函数调用前一个后 由于异常抛出提前返回等 后一个函数没有被调用 造成资源状态异常</p><p><strong>线程安全的Singleton实现</strong><br>这个类在 flamingo 中也见到了, 这次是升级版<br>借由pthread_once保证线程安全</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> :</span> noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T&amp; <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pthread_once(&amp;ponce_, Init);</span><br><span class="line">        <span class="keyword">return</span> *value_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value_ = <span class="keyword">new</span> T();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_once_t</span> ponce_;</span><br><span class="line">    <span class="keyword">static</span> T *value_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">pthread_once_t</span> Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* Singleton&lt;T&gt;::value_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p><strong>copy-on-write?? copy-on-other-write!!</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; Entry;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Entry&gt; EntryList;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, EntryList&gt; Map;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Map&gt; MapPtr;</span><br><span class="line"></span><br><span class="line">MapPtr data_;</span><br></pre></td></tr></table></figure><p>好的现在数据存储在data_ 中 系统中存在多个读线程和一个写线程 针对data_<br>如果写线程不管不顾 有数据就往data_中写入 出现了读写进程同时访问data_就会出问题.<br>就书中描述来意思来说 不用大刀阔斧的使用读写锁, 能用mutex简单解决为什么要用读写锁.<br>那么如何保证读写安全呢?</p><p>当读进程读的时候 拷贝一次data_ data_的引用计数至少为2.<br>就在这时写进程判断 data_引用计数不为1, 于是拷贝原来指向的map, 然后将data_ reset指向新的map<br>这时data_引用计数变为1 可以正常写了. 而读进程中保存的map拷贝是稍久的 引用计数降为1, 执行完后就自动析构了旧数据</p><p>下面的代码 读部分只在GetData中加锁, 缩小了临界区</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MapPtr <span class="title">GetData</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// binding reference of type ‘MutexLock&amp;’ to ‘const MutexLock’ discards qualifiers</span></span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CustomerData::Query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;custmoner, <span class="keyword">const</span> <span class="built_in">string</span> &amp;stock)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MapPtr data = GetData();</span><br><span class="line">    Map::const_iterator entries = data-&gt;<span class="built_in">find</span>(custmoner);</span><br><span class="line">    <span class="keyword">if</span> (entries != data-&gt;<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FindEntry(entries-&gt;second, stock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CustomerData::Update</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;customer, <span class="keyword">const</span> CustomerData::EntryList &amp;entries)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!data_.unique())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MapPtr <span class="title">new_data</span><span class="params">(<span class="keyword">new</span> Map(*data_))</span></span>;</span><br><span class="line">        data_.swap(new_data);</span><br><span class="line">        <span class="comment">// sawp后 先前某个线程通过GetData拿到MapPtr 他会读到稍旧的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(data_.unique());</span><br><span class="line">    (*data_)[customer] = entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三章-多线程服务器的适用场合与常用编程模型"><a href="#第三章-多线程服务器的适用场合与常用编程模型" class="headerlink" title="第三章 多线程服务器的适用场合与常用编程模型"></a>第三章 多线程服务器的适用场合与常用编程模型</h2><p>单线程服务器常用的编程模型<br><code>non-blocking IO + IO multiplexing</code> 即为<code>Reactor模式</code><br>程序的基本结构是一个事件循环, 以事件驱动和事件回调的方式实现业务逻辑</p><p>本质的缺点<br>要求事件回调函数必须是非阻塞的, 单线程还阻塞 这还怎么玩…<br>对于涉及网络IO的请求响应式协议, 容易割裂业务逻辑, 使其散布于多个回调函数中</p><p>多线程服务器常用编程模型</p><ol><li>每个请求创建一个线程, 使用阻塞式IO操作</li><li>使用线程池, 同样是阻塞式IO操作</li><li>非阻塞IO + IO多路复用 即Java NIO方法</li><li>领导者追随者等高级模式</li></ol><p>推荐的C++多线程服务器端编程模式为 one (event) loop per thread + thread pool<br>一个线程一个事件循环 + 线程池<br>事件循环用作IO多路复用, 配合非阻塞IO和定时器<br>线程池用作计算, 具体可以是任务队列或生产者消费者队列</p><p>必须使用单线程的场合</p><ul><li>程序可能会fork</li><li>限制程序的CPU占用率 一个线程最多占满一个核心</li></ul><p>适用多线程程序的场景</p><ul><li>有多个CPU可用, 单核机器上多线程没有性能优势</li><li>线程间有共享数据, 否则建议使用 主进程+工作进程 每个进程都是单线程的模型</li><li>共享数据是可以修改的. 如果数据不能修改可以进程间使用共享内存</li><li>事件响应有优先级差异, 防止优先级反转</li><li>程序要有相当的计算量</li><li>利用异步操作</li><li>能享受到增加CPU数目带来的好处</li><li>多线程有有效地划分责任与功能</li></ul><p>后面大部分我都是看看就过去了, 自己没有丝毫经验 也不打算现在细看</p><h2 id="第四章-C-多线程系统编程精要"><a href="#第四章-C-多线程系统编程精要" class="headerlink" title="第四章 C++多线程系统编程精要"></a>第四章 C++多线程系统编程精要</h2><p>学习多线程编程面临的最大思维方式转变</p><ul><li>当前进程随时可能被切出去</li><li>多线程程序中事件的发生顺序不再有全局统一的先后关系</li></ul><p>常用的11个pthreads函数</p><ul><li>pthread_create() pthread_join()</li><li>pthread_mutex_(create/destory/lock/unlock)</li><li>pthread_cond_(create/destory/wait/signal/broadcast)</li></ul><p>多线程系统编程的难点不在于学习线程原语, 而在于理解多线程与现有的C/C++库函数和系统调用的交互关系<br>以进一步学习如何设计并实现线程安全且高效的程序</p><p>pthread_t并不适合作为程序中对线程的标识符</p><ul><li>他可能会同一进程的两个线程相同</li><li>或者是不利于打印</li><li>无法判断其是否非法</li><li>文件系统中没有对应项</li><li>脱离进程便没意义</li></ul><p>推荐使用gettid()作为线程标识符</p><ul><li>任何时刻都是全局唯一的</li><li>类型为pid_t通常为一个小整数利于在日志中打印.</li><li>0就是非法值1, 因为操作系统第一个进程init的pid是1</li><li>在现代Linux中, 他直接表示内核的任务调度id, 容易在/proc文件系统中找到对应项</li><li>在其他系统工具中也容易定位到某一个具体线程, 列如使用top按线程列出任务,<br>便可以找到线程id, 再根据程序日志判断是哪一个具体线程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .h</span></span><br><span class="line"><span class="keyword">extern</span> __thread <span class="keyword">int</span> t_cachedTid;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cacheTid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">tid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(t_cachedTid == <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        cacheTid();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t_cachedTid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line">__thread <span class="keyword">int</span> t_cachedTid = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CurrentThread::cacheTid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t_cachedTid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t_cachedTid = gettid();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// .cpp</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">gettid</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">pid_t</span>&gt;(::syscall(SYS_gettid));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>thread<br>只能修饰POD类型, 不能修饰class类型, 因为无法自动调用构造析构函数. 可以用于修饰全局变量函数内的静态变量.是GCC内置的线程局部存储设施，存取效率可以和全局变量相比。</strong>thread变量每一个线程有一份独立实体，各个线程的值互不干扰.</p><p><strong>builtin_expect<br>这个指令是gcc引入的，作用是允许程序员将最有可能执行的分支告诉编译器。这个指令的写法为：</strong>builtin_expect(EXP, N)。<br>意思是：EXP==N的概率很大. 就图中代码翻译过来就是 <code>t_cachedTid == 0</code>为<code>0(假)</code>, 即为<code>t_cachedTid</code>最可能不是0.</p><ul><li>使用同一个class创建线程, 全局统一. 一般不会为每个网络连接创建线程, 除非并发数与cpu数目相同<br>一个服务程序的线程数目应该与当前负载无关, 而应该有CPU数目有关.</li><li>程序运行期间不要再创建和销毁线程, 最好在初始化的时候创建所有的线程</li></ul><p>线程销毁的方式</p><ul><li>正常死亡, 从线程主函数返回, 线程正常退出</li><li>非正常死亡, 从线程主函数抛出异常或线程触发segfault信号等非法操作</li><li>自杀 调用pthread_exit() 立刻终止线程</li><li>他杀 其他线程调用pthread_cancel() 来强制终止某个线程</li></ul><p>线程只有一种正常死亡方式, 即第一种 其他方法都是错的Java中甚至把相关函数都废弃了</p><p>每个文件描述符只由一个线程操作, 从而解决消息收发的顺序问题, 把一个文件描述符读写分开未必会提高性能. 同时我们不知道epoll_wait阻塞的时候, 其他线程添加新的fd会发生什么. 为了稳妥起见应该把对同一个epollfd的操作放入同一个线程中执行.</p><p><strong>包装文件描述符和连接</strong><br>用Socket对象包装文件描述符<br>所有对此文件描述符的读写操作都通过此对象进行, 对象的析构函数里关闭文件描述符. 这样只要Socket对象还活着 就不会与其他Socket对象有相同的文件描述符, 也就不会发生串话. 包装文件描述符已经见过了, 同样是在flamingo中看到的.</p><p>用Tcpconnection包装连接<br>如果仅仅记住 fd = 8 这样的文件描述符, A线程accept后转身去处理业务B线程把 fd = 8 给关闭了!! 同时accept一个新的fd 同样是8!!. 这时A线程回复就会出现问题. 所以应该持有封装了Socket对象的Tcpconnection, 保证请求处理期间 文件描述符不会被关闭. 或者是持有Tcpconnection的弱引用. 这样就能知道 fd = 8 到底是原来的还是被关闭后新创建的. Tcpconnection对象不能提前销毁, 所以使用了shared_ptr来管理其生存期, 保证不会提前销毁造成串话.</p><h2 id="第五章-高效的多线程日志"><a href="#第五章-高效的多线程日志" class="headerlink" title="第五章 高效的多线程日志"></a>第五章 高效的多线程日志</h2><h1 id="第二部分-muduo网络库"><a href="#第二部分-muduo网络库" class="headerlink" title="第二部分 muduo网络库"></a>第二部分 muduo网络库</h1><h2 id="第六章-muduo网络库简介"><a href="#第六章-muduo网络库简介" class="headerlink" title="第六章 muduo网络库简介"></a>第六章 muduo网络库简介</h2><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/ClassDiagram.png" alt=""></p><p>看完前面的一小部分, 我真心觉得这个库跟之前那个flamingo特别像, 估计这种管理方式就是某种主流方式?<br>估计我以后自己写的时候也是会按照这个模式来写了吧</p><p>TCP网络编程最本质的是处理三个半事件</p><ul><li>连接的建立</li><li>连接断开 主动断开close 被动断开 read返回0</li><li>消息到达, 文件描述符可读. 最为重要的一个事件, 对它的处理方式决定了网络编程的风格.(阻塞还是非阻塞, 如何处理分包, 应用层缓冲如何设计)</li><li>消息发送完毕 这算半个</li></ul><p>现在存在的问题</p><ul><li>如果保证发送完应用层缓冲区数据才断开连接<br>自己思考的可以设立标志位, 如果设置了标志位发送完成后检测标志位 关闭连接</li><li>如果要主动发起连接, 但是对方主动拒绝, 如何定期重试<br>按照TCP重试机制 发送SYN 开启定时器 如果定时内没有收到确认ACK则重发SYN</li></ul><p>这里了解到一个词 前向声明,<br>在程序设计中，前向声明（Forward Declaration）是指声明标识符(表示编程的实体，如数据类型、变量、函数)时还没有给出完整的定义。<br>通常为了简化头文件的关系 可以在A的头文件中 声明<code>class B</code>, 这样在你的代码中就可以使用<code>B*</code>而不需要引入B的头文件</p><h2 id="第七章-muduo编程示例"><a href="#第七章-muduo编程示例" class="headerlink" title="第七章 muduo编程示例"></a>第七章 muduo编程示例</h2><p>本章大部分都是实战小例子, 自然要在代码中注释了.<br>博客这里就简单写一写<br><strong>关于<code>input buffer</code>和<code>output buffer</code>已经有所了解过</strong></p><p><code>output buffer</code>在<code>write</code>调用一次没有发送完全的时候起到大用途. 一次没有发送完不应该等待在那里, 应该是接管这些未发送的数据, 阻塞代价是很大的. 应该是注册<code>EPILOUT</code>事件, 直到数据全部发送完毕. 否则就一直注册事件, 当然这是在连接正常的时候.<br>使用<code>output buffer</code>还有一个小问题, 一般情况下一次发送未完成才会使用到<code>output buffer</code>. 当缓冲区中存在数据的时候. 下一次的数据不能进行发送, 而应该是直接追加到尾部.</p><p><code>input buffer</code>某种意义上作用更大, 这涉及到一个重要概念”粘包”的处理. </p><p>这里我了解到了<code>capacity()</code>机制, 可以用来减少内存分配次数. <code>capacity()</code>代表预分配的内存大小,<br>而<code>size()</code>是你写入的数据大小, 当<code>size == capacity</code>的时候<code>再写入内容</code>内存会分配更长的一个数组将旧数据拷贝过去<code>size()</code>依然是你写入的大小, <code>capacity()</code>则会变大</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="title">buff</span><span class="params">(<span class="number">20</span>)</span></span>; <span class="comment">// 填充了20个元素 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    buff.resize(<span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld %ld\n"</span>, buff.<span class="built_in">size</span>(), buff.capacity());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld %ld\n"</span>, buff.<span class="built_in">size</span>(), buff.capacity()); <span class="comment">// 20 20</span></span><br><span class="line">    Foo(<span class="number">512</span>); <span class="comment">// 512 512</span></span><br><span class="line">    Foo(<span class="number">1024</span>); <span class="comment">// 1024 1024</span></span><br><span class="line">    Foo(<span class="number">1025</span>); <span class="comment">// 1025 2048</span></span><br><span class="line">    Foo(<span class="number">2048</span>); <span class="comment">// 2048 2048</span></span><br><span class="line">    Foo(<span class="number">2049</span>); <span class="comment">// 2049 4096</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux高性能服务器编程基本看玩了, 现在需要进行实战练习, 然而从单纯的只会api到做出项目, 之间的距离&lt;br&gt;不是一般的小, 最终我选择了这本书…..&lt;/p&gt;
&lt;p&gt;相关自己写的代码 大部分放在github 少部分会写在博客中&lt;/p&gt;
&lt;h1 id=&quot;第一部分-C-
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Shell脚本编写</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</id>
    <published>2020-03-26T09:30:22.000Z</published>
    <updated>2020-03-26T10:51:22.857Z</updated>
    
    <content type="html"><![CDATA[<p>由于阿里云服务器github速度异常缓慢, 自己想把一个shell, 改成本地版本发现不是很容易.<br>所以咕咕咕很久的shell脚本, 算是开始学了. 感觉入门应该不会太难把</p><p>我先来我最喜欢的入门网站 菜鸟教程!</p><p>既然写的是脚本就需要解释器了</p><ol><li><code>#!/bin/bash</code> 这个通常见于脚本的第一行, <code>#!</code>算是个约定了 说明脚本需要什么解释器</li><li><code>/bin/sh xx.sh</code> 这种是执行的时候指定, 脚本第一行的那个就失效了</li></ol><p><strong>shell变量-挺正常的规定</strong></p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><p>shell变量类型</p><ul><li>局部变量</li><li>环境变量</li><li>shell变量-shell内置特殊变量</li></ul><p>变量定义 <em>注意 不能随便加空格 下面的等号两侧不能加空格</em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接赋值</span></span><br><span class="line">xxx="lsmg"</span><br><span class="line">xxx = "lsmg" # 错误</span><br><span class="line">xxx="Jigokubana" # 随意修改</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 语句赋值</span></span><br><span class="line">for skill in Ada Coffe Action Java; do</span><br><span class="line">    echo "I am good at $&#123;skill&#125;Script"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用变量</span></span><br><span class="line">echo $xxx</span><br><span class="line">echo $&#123;xxx&#125; # &#123;&#125; 用于标记边界</span><br><span class="line">echo "my name is $&#123;xxx&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> const</span></span><br><span class="line">readonly xxx="lsmg" </span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash"> 删除变量</span></span><br><span class="line">unset xxx; 不能用于删除只读变量</span><br></pre></td></tr></table></figure><p>单双引号字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> shell 双引号字符串</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 可以含有转义字符 和变量</span></span></span><br><span class="line">xxx1="\"lsmg\""</span><br><span class="line">echo xxx1 # $ "lsmg"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> shell单引号字符串</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 会原样输出, 无视变量. 即使转义也不能出现单一的单引号 但可以成对出现 用于拼接字符串</span></span></span><br><span class="line">xxx2='lsmg' </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拼接双引号变量双引号输出 单引号变量单引号输出</span></span><br><span class="line">your_name="runoob"</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 使用双引号拼接</span></span></span><br><span class="line">greeting="hello, "$your_name" !"</span><br><span class="line">greeting_1="hello, $&#123;your_name&#125; !"</span><br><span class="line">echo $greeting  $greeting_1 # hello, runoob ! hello, runoob !</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 使用单引号拼接</span></span></span><br><span class="line">greeting_2='hello, '$your_name' !'</span><br><span class="line">greeting_3='hello, $&#123;your_name&#125; !'</span><br><span class="line">echo $greeting_2  $greeting_3 # hello, runoob ! hello, $&#123;your_name&#125; !</span><br></pre></td></tr></table></figure><p>字符串操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">url="https://blog.lsmg.xyz"</span><br><span class="line"></span><br><span class="line">echo $&#123;#url&#125; # 输出长度 21</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意单引号</span></span><br><span class="line">echo `expr index "$url" go` # 输出 字符 g o的位置 哪个先出现就输出哪个</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 字符串截取</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># 范围截取</span></span></span><br><span class="line">echo #&#123;url:0:5&#125; # 输出 https 第二个数字代表字符个数 不是范围</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment"># #截取删除左边字符, 保留右侧字符</span></span></span><br><span class="line">echo #&#123;url#*//&#125; # blog.lsmg.xyz</span><br></pre></td></tr></table></figure><p>数组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 空格分隔</span></span><br><span class="line">name=(lsmg Lsmg Jigokubana);</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 你甚至可以 不连续定义</span></span><br><span class="line">nickname[0]=lsmg</span><br><span class="line">nickname[2]=Lsmg</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 读取</span></span><br><span class="line">echo $&#123;nickname[0] nickname[1] nickname[2]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出所有</span></span><br><span class="line">echo $&#123;name[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取得数组元素个数</span></span><br><span class="line">echo $&#123;#name[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取得单个元素长度</span></span><br><span class="line">echo $&#123;#name[1]&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于阿里云服务器github速度异常缓慢, 自己想把一个shell, 改成本地版本发现不是很容易.&lt;br&gt;所以咕咕咕很久的shell脚本, 算是开始学了. 感觉入门应该不会太难把&lt;/p&gt;
&lt;p&gt;我先来我最喜欢的入门网站 菜鸟教程!&lt;/p&gt;
&lt;p&gt;既然写的是脚本就需要解释器了
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Shell" scheme="http://blog.lsmg.xyz/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>EPOLL本质</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-EPOLL%E6%9C%AC%E8%B4%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-EPOLL%E6%9C%AC%E8%B4%A8/</id>
    <published>2020-03-25T09:35:20.000Z</published>
    <updated>2020-03-25T10:24:04.340Z</updated>
    
    <content type="html"><![CDATA[<p>EPOLL本质是什么?  <del>本质当然是复读机</del></p><p>参考和图片来源<br><a href="https://zhuanlan.zhihu.com/p/64138532" target="_blank" rel="noopener">如果这篇文章说不清epoll的本质，那就过来掐死我吧！</a></p><p>一个socket对应一个端口号, 网络数据包中包含了端口, 内核可以通过端口号找到对应的socket</p><p><strong>select的不足</strong><br>select需要遍历两次socket列表, 第一次遍历用于将进程加入到所有socket的等待队列<br>第二次遍历是每次唤醒都需要将进程从每个socket等待队列移除<br>由于遍历开销大, 所以才规定了select最大的监视数量</p><p><strong>功能分离</strong><br><img src="https://pic2.zhimg.com/80/v2-5ce040484bbe61df5b484730c4cf56cd_720w.jpg" alt=""><br>select将 <code>维护等待队列</code> 和 <code>阻塞进程</code>两个步骤合二为一, 每次select都需要这两部操作, 然而socket并不需要每次都修改<br>epoll将操作分开, 使用epoll_ctl维护等待队列, 使用epoll_wait阻塞进程</p><p><strong>就绪队列</strong><br>select不知道哪些socket接收到了数据, 只能一个个遍历.<br>如果内核维护一个”就绪队列” 引用存储事件就绪的socket, 进程唤醒后获取”就绪队列”就能够知道<br>哪些socket接收到数据</p><p><strong>epoll_create创建了什么?</strong><br>创建了一次eventpoll对象, epollfd正是他所代表的对象. 由于epollfd也是文件系统一员也存在等待队列</p><p>select将进程加入到每个socket的等待队列, 而epoll将进程加入到了eventpoll的等待队列 只加入了一次.</p><p><strong>epoll_ctl修改了什么</strong><br>epoll_ctl将 eventpoll添加到sockfd的等待队列中</p><p>当socket接收到数据后, 中断程序会操作eventpoll对象, 而不是直接操作进程(socket的等待队列中就是eventpoll)</p><p><strong>接收数据</strong><br>socket接收到数据后, 中断程序会给epollpoll的<code>就绪列表</code>添加socket的引用.</p><p>这样socket就不会直接影响进程, 而是通过改变eventpoll的<code>就绪列表</code>来改变进程状态</p><p><strong>epoll_wait</strong><br>当程序执行到epoll_wait后如果<code>就绪队列</code>已经有socket引用就会返回, 如果为空就阻塞进程</p><p><strong>阻塞和唤醒进程</strong><br>进程被添加到了eventpoll的等待队列中, socket接收到数据后, 中断程序一方面修改<code>就绪队列</code>一方面唤醒<br>eventpoll等待队列的进程, 由于<code>就绪队列</code> 进程便知道哪些socket发生变化</p><p><strong>实现细节</strong><br>eventpoll的数据结构是双向链表, 能够快速的插入和删除的数据结构</p><p>就绪队列的数据结构是红黑树, 方便添加删除检索避免重复添加.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;EPOLL本质是什么?  &lt;del&gt;本质当然是复读机&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;参考和图片来源&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/64138532&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如果这篇文章说
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="Socket理论" scheme="http://blog.lsmg.xyz/categories/CPP/Socket%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP状态机</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-TCP%E7%8A%B6%E6%80%81%E6%9C%BA/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-TCP%E7%8A%B6%E6%80%81%E6%9C%BA/</id>
    <published>2020-03-25T04:55:20.000Z</published>
    <updated>2020-03-25T08:47:53.413Z</updated>
    
    <content type="html"><![CDATA[<ul><li>待补充 双向管道的建立和断开细节</li><li>异常三次握手</li><li>异常四次挥手</li></ul><p><a href="https://blog.csdn.net/q1007729991/article/details/69675752" target="_blank" rel="noopener">资料参考TCP 协议状态机</a></p><p><a href="https://blog.csdn.net/randyjiawenjie/article/details/6397477" target="_blank" rel="noopener">TCP有限状态机分析</a></p><p>Tcp状态图, 虚线代表客户端 实线代表服务器<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP/Socket%E7%90%86%E8%AE%BA/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt=""></p><p>正常的连接建立还是比较容易理解的</p><p>说一下从<code>CLOSE_WAIT</code>到<code>LAST_ACK</code><br>当被动关闭方<code>B</code>接收到<code>FIN</code>后知道对方<code>A</code>要关闭连接, <code>B</code>回复一个<code>ACK</code>给<code>A</code></p><ol><li>如果此时<code>B</code>没有额外要发送的数据就给<code>A</code>, 就发送<code>FIN</code>告知<code>A</code>自己也要关闭了, 然后<code>B</code>进入<code>LAST_ACK</code></li><li>如果此时<code>B</code>有额外信息要发送等发送完毕后. 这时<code>B</code>发送一个<code>FIN</code>告知<code>A</code>然后B进入<code>LAST_ACK</code></li></ol><p>再说一下从<code>FIN_WAIT_1</code>到<code>TIME_WAIT</code></p><ol><li>直接从<code>FIN_WAIT_1</code>到<code>TIME_WAIT</code>, 这个对应上面的第一种情况, 由于<code>B</code>没有额外信息发送直接发送了<code>FIN和ACK</code>, 这时<code>A</code>再发送一个<code>ACK</code>, 进入<code>TIME_WAIT</code></li><li>经过中转状态<code>FIN_WAIT2</code>对应上面第二种情况, 由于<code>B</code>有额外信息发送, 只发送了<code>ACK</code>, 这时<code>A</code>还可以接受数据, 直到<code>B</code>发来<code>FIN</code>然后<code>A</code>发送<code>ACK</code>进入<code>TIME_WAIT</code></li></ol><p>再说一下<code>TIME_WAIT</code>状态<br>主动关闭方<code>A</code>最后发送了<code>ACK</code>确认被动关闭方<code>B</code>的<code>FIN</code>.<br>但是如果这个<code>ACK</code>由于各种原因<code>B</code>没有收到, 所以<code>B</code>会再次发送<code>FIN</code>. 然后<code>A</code>会在<code>2MSL</code>时间内接受到这个<code>FYN</code>, 之后<code>A</code>再次回复一个<code>ACk</code>.计时器重置<code>2MSL</code>时间, 重复上面过程. 直到<code>2MSL</code>时间内<code>A</code>没有收到<code>FIN</code>,说明<code>B</code>已经收到了.则结束连接</p><p><code>2MSL</code>指的是两个<code>MSL</code>时间 单个指的是一个片段在网络中的最大存活时间,<br>A发送的<code>ACK</code>可能消耗一个, B重新发送的<code>FIN</code>可能也要消耗一个.最大两个</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;待补充 双向管道的建立和断开细节&lt;/li&gt;
&lt;li&gt;异常三次握手&lt;/li&gt;
&lt;li&gt;异常四次挥手&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/q1007729991/article/details/69675752&quot;
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="Socket理论" scheme="http://blog.lsmg.xyz/categories/CPP/Socket%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Send返回值引出的(非)阻塞IO</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-Send%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8E%A2%E6%9E%90/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-Socket%E7%90%86%E8%AE%BA-Send%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8E%A2%E6%9E%90/</id>
    <published>2020-03-20T03:14:20.000Z</published>
    <updated>2020-03-20T04:20:31.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="现存疑问"><a href="#现存疑问" class="headerlink" title="现存疑问"></a>现存疑问</h1><ol><li>WNOWAIT和O_NONBLOCK 的关系?</li><li>当非阻塞send时, 返回值与什么有关? 本地socket发送缓冲区空余还是对端空余?</li><li>对端接收缓冲区满了会发生什么?</li><li>暂且认为send返回值是拷贝到缓冲区中的字节数, 如果这些数据没有成功发送呢?</li><li>send函数发送的字节数 超出了recv端的接受能力 会发生什么?</li></ol><p>最近这两天在实战一个http服务器的编写.</p><p>遇到了一个问题: send的返回值小于传入的len, 因为我仅调用一次send函数 导致页面一直显示加载</p><p>然后找了下为什么? 什么时候? send返回值会小于len;</p><h1 id="send"><a href="#send" class="headerlink" title="send"></a>send</h1><p><a href="https://stackoverflow.com/questions/14700906/socket-programming-send-return-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/14700906/socket-programming-send-return-value</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In practice, send() in blocking mode sends all the data, regardless of what the documentation says, unless there was an error, in which case nothing is sent.</span><br><span class="line">实战中, send() 处于阻塞状态会发送所有的数据, 除非发生错误 但这会导致数据没有发送</span><br><span class="line"></span><br><span class="line">In non-blocking mode, it sends whatever will fit into the socket send buffer and returns that length if &gt; 0. If the socket send buffer is full, it returns -1 with errno &#x3D; EWOULDBLOCK&#x2F;EAGAIN.</span><br><span class="line">在非阻塞模式下, 只要能放入socket发送缓冲区 就返回放入的长度 如果缓冲区满了就返回-1 设置EWOULDBLOCK&#x2F;EAGAIN</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247486643&idx=1&sn=9db678398f390759ff81b354ef056000&chksm=fc70f75fcb077e49363b087ba45609fdfbcba286338e70c2d4c7092e83e2d3feac56455e02a2&scene=27#wechat_redirect" target="_blank" rel="noopener">非阻塞模式下 send 和 recv 函数的返回值</a></p><p>这篇博客里也说明了这个问题. 下面是原博客的代码稍作修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//推荐的方式二：在一个循环里面根据偏移量发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendData</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* buf , <span class="keyword">int</span> buf_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//已发送的字节数目</span></span><br><span class="line">    <span class="keyword">int</span> sent_bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = send(fd, buf + sent_bytes, buf_length - sent_bytes, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;             </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//认为对端关闭了连接</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sent_bytes += ret;</span><br><span class="line">        <span class="keyword">if</span> (sent_bytes == buf_length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//稍稍降低 CPU 的使用率</span></span><br><span class="line">        usleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;现存疑问&quot;&gt;&lt;a href=&quot;#现存疑问&quot; class=&quot;headerlink&quot; title=&quot;现存疑问&quot;&gt;&lt;/a&gt;现存疑问&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;WNOWAIT和O_NONBLOCK 的关系?&lt;/li&gt;
&lt;li&gt;当非阻塞send时, 返回值与什么有关? 本地
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="Socket理论" scheme="http://blog.lsmg.xyz/categories/CPP/Socket%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux的使用</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-Linux%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-17T04:29:20.000Z</published>
    <updated>2020-03-17T04:56:16.103Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>cp -r</td><td>复制目录</td></tr><tr><td>cd -</td><td>切换到上一个工作目录</td></tr></tbody></table><table><thead><tr><th>查找</th><th>功能</th></tr></thead><tbody><tr><td>find ./ -name “core*”</td><td>xargs file</td></tr><tr><td>find ./ -name ‘*.o’</td><td>查找目标文件夹是否有obj文件</td></tr><tr><td>find ./ -name “*.o” | xargs rm -f</td><td>递归删除当前目录所有obj文件</td></tr></tbody></table><table><thead><tr><th>查看文件内容</th><th>功能</th><th>一般用法</th></tr></thead><tbody><tr><td>cat -n</td><td>显示的同时显示行号</td><td>使用管道 ls | cat -n</td></tr><tr><td>head -10 filename</td><td>查看前十行</td><td></td></tr><tr><td>tail -10 failname</td><td>查看后十行</td><td></td></tr><tr><td>diff file1 file2</td><td>查看文件差别</td><td></td></tr><tr><td>tail -f filename</td><td>动态显示文本的最新信息</td><td></td></tr></tbody></table><p>| 给文件增加别名 | 功能 |<br>| ln a b | 创建硬链接, 删除一个另一个仍能使用 |<br>| ln -s a b | 创建符号链接(软连接) 删除源后另一个无法使用 |</p><p>命令行快捷键<br>Ctl-U   删除光标到行首的所有字符 <code>$ 1111 222  --&gt; $</code><br>Ctl-W   删除光标到前边最近一个空格之间的字符 <code>$ 1111 222 --&gt; $ 1111</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;cp -r&lt;/td&gt;
&lt;td&gt;复制目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cd -&lt;/td&gt;
&lt;td&gt;切换到上一个工作目录
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>UNP卷二读书记录</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95115-UNP%E5%8D%B7%E4%BA%8C/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95115-UNP%E5%8D%B7%E4%BA%8C/</id>
    <published>2020-03-15T03:16:20.000Z</published>
    <updated>2020-03-21T01:23:03.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h1><h2 id="管道和有名管道FIFO"><a href="#管道和有名管道FIFO" class="headerlink" title="管道和有名管道FIFO"></a>管道和有名管道FIFO</h2><p><strong>popen pclose</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 成功返回文件指针, 出错为NULL</span></span><br><span class="line"><span class="function">FILE* <span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span>;</span><br><span class="line">FILE* fp = popen(command, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功为shell终止状态, 出错则为 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line">pclose(fp);</span><br></pre></td></tr></table></figure><p>popen创建一个管道并启动另外一个进程 创建者要么从管道读出标准输入, 要么将标准输出写到管道<br>返回的文件指针作用<br>通过type参数控制<br>type = “r” 创建者 通过文件指针读入command命令产生的标准输出<br>type = “w” 创建者 通过文件指针为command命令提供标准输入</p><p>pclose 关闭这个标准IO流</p><p><strong>FIFO 先进先出(first in, first out)</strong></p><p>又称为有名管道(named pipe) 单向(半双工)数据流, 每个FIFO都有一个路径名与之对应.<br>从而允许无亲缘关系的进程访问同一个FIFO</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回 0 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> FIFO1 = <span class="string">"/tmp/fifo.1"</span>;</span><br><span class="line">mkfifo(FIFO1, <span class="number">0666</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建之后需要打开来进行读或者写 可以使用open也可以使用其他标准IO打开函数</span></span><br><span class="line"><span class="keyword">int</span> writefd = <span class="built_in">open</span>(FIFO1, O_WRONLY, <span class="number">0</span>); <span class="comment">/* 在父进程中打开 父进程写 */</span></span><br><span class="line"><span class="keyword">int</span> readfd = <span class="built_in">open</span>(FIFO1, O_RDONLY, <span class="number">0</span>); <span class="comment">/* 在子进程中打开 子进程读 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有调用unlink才能从文件系统删除文件名字</span></span><br><span class="line">unlink(FIFO1);</span><br></pre></td></tr></table></figure><p>mkfifo 隐含已经指定 O_CREAT | O_EXCL<br>要么不存在创建一个新的, 要么返回 errno=EEXIST(所指定名字的FIFO已经存在)</p><p>如果想要打开已经存在的FIFO可以使用open函数.<br>可以判断 如果返回-1 并且errno=EEXIST 就调用open函数打开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子进程</span></span><br><span class="line">readfd = <span class="built_in">open</span>(FIFO1, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">writefd = <span class="built_in">open</span>(FIFO2, O_WRONLY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程</span></span><br><span class="line">writefd = <span class="built_in">open</span>(FIFO1, O_WRONLY, <span class="number">0</span>);</span><br><span class="line">readfd = <span class="built_in">open</span>(FIFO2, O_RDONLY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程 这样会阻塞</span></span><br><span class="line">readfd = <span class="built_in">open</span>(FIFO2, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">writefd = <span class="built_in">open</span>(FIFO1, O_WRONLY, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果调换父进程的两行代码 程序就会进入死锁<br>因为如果当前没有任何进程<code>打开某个FIFO来写</code>, 打开这个<code>FIFO来读</code>的进程将会<code>阻塞</code></p><p>当对一个管道或者FIFO的最终close发生的时候, 该管道或FIFO中的任何残余数据都将被丢弃</p><p>即使在A主机上能够访问到B主机的目录, 即使不同主机上的两个进程都能够通过NFS打开同一个FIFO<br>他们之间也不能通过FIFO从一个进程到另一个进程发送数据</p><p>拒绝服务型攻击Dos<br>如果是单进程可能会让服务器处于阻塞状态, 多进程也可能会由于一个恶意客户发送大量独立请求<br>导致服务器子进程数达到上限, 使得后续的fork失败</p><p><strong>其他</strong><br>从字节流中获取完整的单个信息</p><ul><li>带特殊终止序列<br>许多UNIX应用使用换行分割 因特尔应用程序使用回车符加上一个换行符</li><li>显式长度<br>将长度增加在请求中</li><li>每次连接一个记录<br>应用通过关闭对端连接指示一个记录结束. HTTP1.0使用的这一技术</li></ul><p>标准IO函数fdopen可以将标准IO流与pipe返回的文件描述符相关联’</p><p><strong>限制</strong><br>系统加在管道和FIFO的唯一限制是</p><ul><li>OPEN_MAX<br>一个进程在任意时刻打开的最大描述符数量 &gt;=16</li><li>PIPE_BUF<br>可以原子性的写入一个管道或FIFO的最大数据量 &gt;= 512</li></ul><p><strong>习题练习</strong></p><ol><li>父进程终止的时候, 如果子进程的fd[1]仍处于打开状态, 则子进程对fd[0]的read 不会返回文件结束符,<br>因为fd[1]虽然在父进程中关闭了, 但是在子进程中依然打开. 如果关闭子进程fd[1], 则父进程一旦关闭,<br>他的所有文件描述符即关闭, 子进程对fd[0]的read就会返回0.(想到了自己写的服务器, 客户端断开连接就会read出一个0长度的内容)</li><li>从 不存在即创建, 存在-&gt;打开 变成 存在-&gt;打开, 不存在即创建. 可能会在open打开失败后 创建fifo之前<br>被其他进程抢先创建fifo, 导致本进程的mkfifo调用失败</li><li>出错信息写到了标准错误输出</li><li>可以把第一个open调用设置成非阻塞, 但是为了避免readline返回错误, 标志必须在readline之前去除</li><li>死锁</li><li>读进程关闭管道或者FIFO后给写进程一个信号(往关闭的管道写会产生SIGPIPE信号),<br>写进程关闭管道或者FIFO后将文件结束符发送给读进程(读进程读到长度为0的文件结束符)</li></ol><h2 id="POSIX消息队列"><a href="#POSIX消息队列" class="headerlink" title="POSIX消息队列"></a>POSIX消息队列</h2><p><strong>mqueue创建和删除</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// oflag O_RDONLY O_WRONLY O_RDWR 可以加上O_CREAT和O_EXCL或者O_NONBLOCK</span></span><br><span class="line"><span class="comment">// 创建一个新队列的时候(制定了O_CREAT且消息队列不存在)后两个参数都需要</span></span><br><span class="line"><span class="comment">// 权限位 和 指定某些属性 nullptr则使用默认属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回消息队列 fd 失败 -1</span></span><br><span class="line"><span class="function"><span class="keyword">mqd_t</span> <span class="title">mq_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">int</span> oflag,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="comment">/*mode_t mode, struct mq_attr *attr*/</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>注意<br>消息队列文件描述符不必是(而且很可能不是)像文件描述符或者socket文件描述符那样的短整数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关闭消息队列 引用计数 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_close</span><span class="params">(<span class="keyword">mqd_t</span> mqdes)</span></span>;</span><br></pre></td></tr></table></figure><p>类似close函数, 调用进程可以不再使用该文件描述符, 但是其消息队列并不会从系统中删除</p><p>当一个进程终止的时候, 所有打开着的消息队列都将关闭, 就像自动调用了mq_close</p><p>如果要从系统中删除<code>mq_open</code>第一个参数<code>name</code> 必须调用下面的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用计数 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure><p>每个消息队列有一个保存着当前打开描述符数的引用计数器</p><p>当消息队列的引用计数仍大于0时, 其name就能删除<br>但是队列的析构会在<code>引用计数为0</code>的时候自动析构.</p><p>第一个demo敲完之后 一直是errno=13.<br>在<code>man mq_overview</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">On Linux, message queues are created in a virtual filesystem.   (Other  implementa‐</span><br><span class="line">tions may also provide such a feature, but the details are likely to differ.)  This</span><br><span class="line">filesystem can be mounted (by the superuser) using the following commands:</span><br><span class="line"></span><br><span class="line"># mkdir &#x2F;dev&#x2F;mqueue</span><br><span class="line"># mount -t mqueue none &#x2F;dev&#x2F;mqueue</span><br><span class="line"></span><br><span class="line">The sticky bit is automatically enabled on the mount directory.</span><br></pre></td></tr></table></figure><p>而且 name参数的格式是<code>/somename</code> 这个是相对挂载目录的</p><p><strong>属性设置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> mq_flags; <span class="comment">/* 0, O_NONBLOCK */</span></span><br><span class="line">    <span class="keyword">long</span> mq_maxmsg; <span class="comment">/* max number */</span></span><br><span class="line">    <span class="keyword">long</span> mq_msgsize; <span class="comment">/* max size of a msg in bytes */</span></span><br><span class="line">    <span class="keyword">long</span> mq_curmsgs; <span class="comment">/* number of message currently on queue */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_getattr</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, struct mq_attr *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set 的时候 只有mq_attr中的mq_flags起作用 设置取消O_NONBLOCK</span></span><br><span class="line"><span class="comment">// 最大消息数和最大字节数 只能在创建队列的时候设置</span></span><br><span class="line"><span class="comment">// 队列中房钱消息数 只能获取不能设置</span></span><br><span class="line"><span class="comment">// 第三个参数 不为nullptr则返回之前的属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_setattr</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> struct mq_attr *attr, struct mq_attr *oattr)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>发送接收信息</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prio 优先级 必须 &lt;= MQ_PRIO_MAX</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_send</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> prio)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// len 必须 &gt;= mq_attr.mq_msgsize 如果小于则 errno = EMSGSIZE</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">mq_receive</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, <span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> *priop)</span></span>;</span><br></pre></td></tr></table></figure><p>如果不使用优先级 发送的时候可以将 mq_send的 prio 设置为0<br>接受的时候 mq_receive priop 设置为 nullptr</p><p><strong>消息队列的限制</strong></p><ul><li>mq_maxmsg 队列中最大消息数</li><li>mq_msgsize单个消息的最大字节</li><li>MQ_OPEN_MAX 一个进程同时打开消息队列的最大数目</li><li>MQ_PRIO_MAX 最大优先级+1</li></ul><p><strong>异步事件通知</strong></p><ul><li>产生信号</li><li>创建一个线程执行一个指定的函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为指定队列建立或者删除异步事件通知.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功返回 0 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mq_notify</span><span class="params">(<span class="keyword">mqd_t</span> mqdes, struct sigevent *nofification)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sival_int;</span><br><span class="line">    <span class="keyword">void</span> *sival_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sigev_notify; <span class="comment">// SIGEV_NONE SIGEV_SIGNAL SIGEV_THREAD</span></span><br><span class="line">    <span class="keyword">int</span> sigev_signo; <span class="comment">// signal number if SIGEV_SIGNAL</span></span><br><span class="line">    <span class="keyword">union</span> sigval sigev_value; <span class="comment">// passed to signal handler pr thread</span></span><br><span class="line">    <span class="comment">// 下面两个用于 SIGEV_THREAD</span></span><br><span class="line">    <span class="keyword">void</span> (*sigev_notify_function)(<span class="keyword">union</span> sigval);</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> *sigev_notify_attributes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>如果 notification != nullptr<br>当前进程希望 在有一个消息 到达所指定的 先前为空的队列 时得到通知<br>我们说 该进程被注册为接收该队列的通知</p></li><li><p>如果 notification == nullptr<br>如果 该进程被注册为 接受所指定队列通知 则取消它</p></li><li><p>任何时刻只有一个进程可以被注册为 接收某个队列的通知</p></li><li><p>当一个消息到达某个空队列, 而且已经注册, 那么只有当<br>没有因为调用mq_reveive导致的阻塞 的时候才会发出通知</p></li><li><p>通知发出后 注册立即被撤销.. 需要重新注册???</p></li></ol><p>Unix信号产生后会复位成默认行为.<br>信号处理程序通常第一个调用signal函数, 用于重新建立处理程序<br>这时会产生一个空窗时期(信号产生 与 当前进程重建信号处理程序之间)<br>空窗时期再次产生同一信号 可能终止当前进程</p><p>初看起来, mq_notify可能也有这个问题.<br>不过在消息队列<code>为空前</code> <code>通知不会再次产生</code><br>所以不要在<code>读出消息后</code>重新注册<br>而应该在<code>读出消息前</code>重新注册</p><p><code>volatile sig_atomic_t mqflag = 0;</code><br>sig_atomic_t 即使缺少信号所做的异步中断，亦能作为原子实体访问的整数类型。<br>volatile 标记可能会随时改变</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;消息传递&quot;&gt;&lt;a href=&quot;#消息传递&quot; class=&quot;headerlink&quot; title=&quot;消息传递&quot;&gt;&lt;/a&gt;消息传递&lt;/h1&gt;&lt;h2 id=&quot;管道和有名管道FIFO&quot;&gt;&lt;a href=&quot;#管道和有名管道FIFO&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>csapp笔记</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-csapp/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-csapp/</id>
    <published>2020-03-14T07:09:20.000Z</published>
    <updated>2020-03-14T10:15:31.077Z</updated>
    
    <content type="html"><![CDATA[<p>选择性阅读</p><h1 id="第十二章-并发编程"><a href="#第十二章-并发编程" class="headerlink" title="第十二章 并发编程"></a>第十二章 并发编程</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;选择性阅读&lt;/p&gt;
&lt;h1 id=&quot;第十二章-并发编程&quot;&gt;&lt;a href=&quot;#第十二章-并发编程&quot; class=&quot;headerlink&quot; title=&quot;第十二章 并发编程&quot;&gt;&lt;/a&gt;第十二章 并发编程&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="csapp" scheme="http://blog.lsmg.xyz/tags/csapp/"/>
    
  </entry>
  
  <entry>
    <title>GDB调试</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-GDB%E8%B0%83%E8%AF%95/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-GDB%E8%B0%83%E8%AF%95/</id>
    <published>2020-03-14T07:09:20.000Z</published>
    <updated>2020-03-17T08:39:20.200Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p><p>对多线程的支持<br>set follow-fork-mode [parent|child]<br>set detach-on-fork [on|off]</p><table><thead><tr><th>follow-fork-mode</th><th>detach-on-fork</th><th>说明</th></tr></thead><tbody><tr><td>parent</td><td>on</td><td>只调试主进程</td></tr><tr><td>child</td><td>on</td><td>只调试子进程</td></tr><tr><td>parent</td><td>off</td><td>同时调试父子进程, gdb跟踪父进程, 子进程阻塞在fork位置</td></tr><tr><td>child</td><td>off</td><td>同上 gdb跟踪子进程, 父进程阻塞</td></tr></tbody></table><p>进程间切换<br>| 命令 | 功能 |<br>| — | — |<br>| info inferiors | 查询正在调试的进程 |<br>| inferior &lt;number&gt; | 切换进程 |</p><table><thead><tr><th>运行命令</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>run</td><td>r</td><td>运行程序</td></tr><tr><td>continue</td><td>c</td><td>继续执行到下有一个断点处</td></tr><tr><td>next</td><td>n</td><td>单步跟踪, 不进入函数</td></tr><tr><td>step</td><td>s</td><td>会进入函数</td></tr><tr><td>until</td><td></td><td>运行程序直到退出循环体</td></tr><tr><td>until + 行号</td><td></td><td>运行至某行</td></tr><tr><td>finish</td><td></td><td>运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回以及参数等信息</td></tr><tr><td>call 函数(参数)</td><td></td><td>调试程序中的可见参数, 并传递参数</td></tr><tr><td>quit</td><td>q</td><td>退出</td></tr></tbody></table><table><thead><tr><th>设置断点</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>break n</td><td>b n</td><td>在第n行设置断点, b xx.cpp:500(xx.cpp文件第500行)</td></tr><tr><td>b fn if a&gt;b</td><td></td><td>在函数f 或者行号n 设置条件断点</td></tr><tr><td>break func</td><td>b func</td><td>在函数func()的入口处设置断点</td></tr><tr><td>delete 断点号n</td><td></td><td>删除第n个断点</td></tr><tr><td>disable 断点号n</td><td></td><td>暂停第n个断点</td></tr><tr><td>enable 断点号n</td><td></td><td>开始第n的断点</td></tr><tr><td>clear 行号n</td><td></td><td>清除第n行的断点</td></tr><tr><td>info b</td><td></td><td>显示断点设置情况</td></tr><tr><td>delete breakpoints</td><td></td><td>清除所有断点</td></tr></tbody></table><table><thead><tr><th>查看源代码</th><th>缩写</th><th>功能</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>默认显示10行</td></tr><tr><td>list 行号</td><td></td><td>以行号为中心的前后十行代码</td></tr><tr><td>list 函数名</td><td></td><td>列出函数名所在函数的代码</td></tr><tr><td>list</td><td></td><td>不带参数, 接着上一次的list命令输出下边的内容</td></tr></tbody></table><table><thead><tr><th>打印表达式</th><th>功能</th></tr></thead><tbody><tr><td>print p</td><td></td></tr><tr><td>p a</td><td>显示a的值</td></tr><tr><td>p ++a</td><td>a的值</td></tr><tr><td>p func(22)</td><td>以整数22作为参数调用 后打印</td></tr><tr><td>p func(a)</td><td>将变量a作为参数</td></tr><tr><td>display 表达式</td><td>每次单步运行后就打印表达式的值</td></tr><tr><td>watch 表达式</td><td>设置检视点, 一旦被监视的表达式值改变就强行终止正在被调试的程序</td></tr><tr><td>whatis</td><td>查询变量或函数</td></tr><tr><td>info function</td><td>查询函数</td></tr><tr><td>info local</td><td>显示当前堆栈页的所有变量</td></tr></tbody></table><table><thead><tr><th>查询运行信息</th><th>功能</th></tr></thead><tbody><tr><td>where/bt</td><td>当前运行的堆栈列表</td></tr><tr><td>bt backtrace</td><td>显示当前的调用堆栈</td></tr><tr><td>up/down</td><td>改变堆栈的显示深度</td></tr><tr><td>set args [args]</td><td>指定程序运行参数</td></tr><tr><td>show args</td><td>查看程序参数</td></tr><tr><td>info program</td><td>查看程序是否运行, 进程号, 被暂停原因</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://linuxtools-rst.readthed
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="GDB调试" scheme="http://blog.lsmg.xyz/tags/GDB%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>权限管理</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3/</id>
    <published>2020-03-14T07:09:20.000Z</published>
    <updated>2020-03-14T10:14:04.755Z</updated>
    
    <content type="html"><![CDATA[<p><code>drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs</code><br>档案权限类型<br>连接数<br>档案拥有者<br>档案所属群组<br>档案容量<br>档案最后被修改时间<br>档名</p><p>文件类型和权限<br><code>drwxr-xr-x</code></p><p>第一位 d 表明档案类型是 目录</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>d</td><td>目录</td></tr><tr><td>-</td><td>文件</td></tr><tr><td>|</td><td>链接文件</td></tr><tr><td>b</td><td>设备文件中可供存储的周边设备, 可随机读取设备</td></tr><tr><td>c</td><td>序列号设备, 如键盘鼠标, 一次性读取设备</td></tr></tbody></table><p>后面每三位一组 为<code>rwx</code>的组合 分别代表 <code>读</code>, <code>写</code>, <code>执行</code><br>三组 第一组<code>文件拥有者权限</code> 第二组<code>群组中账号权限</code> 第三组<code>非本人且没有加入本群组的其他账号权限</code></p><p>第三部分表示这个文件的<code>拥有者账号</code><br>第四部分表示这个文件<code>所属群组</code></p><p>相关命令<br>-chgrp 改变文件所属群组<br>-chown 改变文件拥有者<br>-chmod 改变文件权限</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs&lt;/code&gt;&lt;br&gt;档案权限类型&lt;br&gt;连接数&lt;br&gt;档案拥有者&lt;br&gt;档案所属群组&lt;br&gt;档案容量&lt;br&gt;档案最后被修改时间&lt;br&gt;档名&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://blog.lsmg.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="权限管理" scheme="http://blog.lsmg.xyz/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>UE4TCP数据传输</title>
    <link href="http://blog.lsmg.xyz/2020/03/UE4-%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/"/>
    <id>http://blog.lsmg.xyz/2020/03/UE4-%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/</id>
    <published>2020-03-08T08:38:28.000Z</published>
    <updated>2020-03-09T13:36:52.520Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下UE4 Tcp传输数据的客户端代码<br>方便日后使用</p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><p>#include “Networking.h”</p><p>// 添加 Networking 和 Sockets<br>PublicDependencyModuleNames.AddRange(new string[] { “Core”, “CoreUObject”, “Engine”, “InputCore”, “Networking”, “Sockets”});</p><h1 id="用到的数据结构"><a href="#用到的数据结构" class="headerlink" title="用到的数据结构"></a>用到的数据结构</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">FMsgType</span>:</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">EROOM_ENTER,</span><br><span class="line">EROOM_EXIT,</span><br><span class="line">EPLAYER_READY,</span><br><span class="line">EPLAYER_CANCEL_READY,</span><br><span class="line">EGAME_START,</span><br><span class="line">EROOM_PLAY_DATA,</span><br><span class="line">EGAME_OVER</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">FMsgVersion</span> :</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">VERSION0 = <span class="number">0</span>,</span><br><span class="line">VERSION1 = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoHead</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FMsgType MsgType;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    FMsgVersion MsgVer;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    int32 BodyLen;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoBody</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    <span class="keyword">bool</span> Result;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    int32 MsgId;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    TArray&lt;int32&gt; DataArray;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoMsg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    FProtoHead Header;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">    FProtoBody Body;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="socket管理"><a href="#socket管理" class="headerlink" title="socket管理"></a>socket管理</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span>;</span><br><span class="line"></span><br><span class="line">FIPv4Address Ip;</span><br><span class="line">FSocket* ClientFd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将字符串ip转换为点分十进制ip</span></span><br><span class="line">    FIPv4Address::Parse(IPStr, Ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将十进制ip 转化成网络地址</span></span><br><span class="line">    TSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();</span><br><span class="line">    addr-&gt;SetIp(Ip.Value);</span><br><span class="line">    addr-&gt;SetPort(Port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP Socket 文件描述符</span></span><br><span class="line">    ClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class="string">"TCP SOCKET"</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ClientFd-&gt;Connect(*addr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据发送和接收"><a href="#数据发送和接收" class="headerlink" title="数据发送和接收"></a>数据发送和接收</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendMsg</span><span class="params">(FProtoMsg Msg)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RecvMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::SendMsg</span><span class="params">(FProtoMsg Msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Len;</span><br><span class="line"><span class="keyword">int</span> Send;</span><br><span class="line">uint8* data;</span><br><span class="line">data = Encode(Msg, &amp;Len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ClientFd-&gt;Send(data, Len, Send))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::RecvMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ClientFd != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">uint8 Buffer[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">uint32 Size = <span class="number">0</span>;</span><br><span class="line">int32 Read = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ClientFd-&gt;HasPendingData(Size))</span><br><span class="line">&#123;</span><br><span class="line">ClientFd-&gt;Recv(Buffer, <span class="number">1024</span>, Read);</span><br><span class="line"><span class="keyword">return</span> Decode(Buffer, Read);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据序列化"><a href="#数据序列化" class="headerlink" title="数据序列化"></a>数据序列化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="function">uint8* <span class="title">Encode</span><span class="params">(FProtoMsg Msg, int32* Len)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> HEADER_SIZE = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function">uint8* <span class="title">AGameNetwork::Encode</span><span class="params">(FProtoMsg Msg, int32* Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Msg.Header.BodyLen = Msg.Body.DataArray.Num() * Msg.Body.DataArray.GetTypeSize() + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">*Len = Msg.Header.BodyLen + HEADER_SIZE;</span><br><span class="line"><span class="comment">// HEADER</span></span><br><span class="line"><span class="keyword">auto</span> data = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[*Len];</span><br><span class="line">    <span class="keyword">auto</span> pdata = data;</span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, *Len);</span><br><span class="line"></span><br><span class="line">*pdata = (uint8)Msg.Header.MsgType;</span><br><span class="line">pdata++;</span><br><span class="line"></span><br><span class="line">*pdata = (uint8)Msg.Header.MsgVer;</span><br><span class="line">pdata++;</span><br><span class="line"></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)pdata = Msg.Header.BodyLen;</span><br><span class="line">pdata += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BODY</span></span><br><span class="line">pdata++;</span><br><span class="line">*(<span class="keyword">uint32_t</span>*)pdata = Msg.Body.MsgId;</span><br><span class="line">pdata += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(pdata, Msg.Body.DataArray.GetData(), Msg.Header.BodyLen - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据反序列化"><a href="#数据反序列化" class="headerlink" title="数据反序列化"></a>数据反序列化</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Decode</span><span class="params">(uint8* data, int32 len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParseHeader</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParseBody</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseStatus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PARSE_INIT,</span><br><span class="line">    PARSE_HEAD,</span><br><span class="line">    PARSE_BODY</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TArray&lt;uint8&gt; ReservedData;</span><br><span class="line">FProtoMsg* CurrentMsg;</span><br><span class="line">ParseStatus ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class="line">TArray&lt;FProtoMsg&gt; MsgArray;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::Decode</span><span class="params">(uint8* data, int32 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 防止沾包 直接将受到的数据全部按顺序存储</span></span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ReservedData.Push(data[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int32 r_len = ReservedData.Num();</span><br><span class="line">uint8* r_data = ReservedData.GetData();</span><br><span class="line">int32 parse_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (r_len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (ParseStatus)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_INIT:</span><br><span class="line">CurrentMsg = <span class="keyword">new</span> FProtoMsg();</span><br><span class="line">ParseStatus = ParseStatus::PARSE_HEAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_HEAD:</span><br><span class="line"><span class="keyword">if</span> (!ParseHeader(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_BODY:</span><br><span class="line"><span class="keyword">if</span> (!ParseBody(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CurrentMsg != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">MsgArray.Push(*CurrentMsg);</span><br><span class="line">&#125;</span><br><span class="line">CurrentMsg = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; parse_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ReservedData.Pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::ParseHeader</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*reserved_len &lt; HEADER_SIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8* data = *r_data;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.MsgType = StaticCast&lt;FMsgType&gt;(*data);</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.MsgVer = StaticCast&lt;FMsgVersion&gt;(*data);</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.BodyLen = *(uint32*)data;</span><br><span class="line"></span><br><span class="line">*reserved_len -= HEADER_SIZE;</span><br><span class="line">*parse_len += HEADER_SIZE;</span><br><span class="line">*r_data += HEADER_SIZE;</span><br><span class="line"></span><br><span class="line">ParseStatus = ParseStatus::PARSE_BODY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::ParseBody</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*reserved_len &lt; CurrentMsg-&gt;Header.BodyLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8* data = *r_data;</span><br><span class="line"><span class="comment">// current_msg-&gt;body = data;</span></span><br><span class="line">CurrentMsg-&gt;Body.Result = (*data) == <span class="number">1</span>;</span><br><span class="line">data++;</span><br><span class="line">CurrentMsg-&gt;Body.MsgId = *(int32*)data;</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ((CurrentMsg-&gt;Header.BodyLen - <span class="number">5</span>) / <span class="keyword">sizeof</span>(int32)); ++i)</span><br><span class="line">&#123;</span><br><span class="line">CurrentMsg-&gt;Body.DataArray.Add(*(int32*)data);</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*reserved_len -= CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line">*parse_len += CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line">*r_data += CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line"></span><br><span class="line">ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h</span></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line">    <span class="function">FProtoMsg <span class="title">Front</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line">    <span class="function">TArray&lt;FProtoMsg&gt; <span class="title">PopBackAllMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::IsEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MsgArray.Num() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FProtoMsg <span class="title">AGameNetwork::Front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MsgArray.Top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AGameNetwork::Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// MsgArray.Pop();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TArray&lt;FProtoMsg&gt; <span class="title">AGameNetwork::PopBackAllMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TArray&lt;FProtoMsg&gt; MsgArrayTemp = MsgArray;</span><br><span class="line">MsgArray.Empty();</span><br><span class="line"><span class="keyword">return</span> MsgArrayTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="完整代码-继承自GameStateBase"><a href="#完整代码-继承自GameStateBase" class="headerlink" title="完整代码-继承自GameStateBase"></a>完整代码-继承自GameStateBase</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CoreMinimal.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GameFramework/GameStateBase.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Networking.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GameNetwork.generated.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">FMsgType</span>:</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">EROOM_ENTER,</span><br><span class="line">EROOM_EXIT,</span><br><span class="line">EPLAYER_READY,</span><br><span class="line">EPLAYER_CANCEL_READY,</span><br><span class="line">EGAME_START,</span><br><span class="line">EROOM_PLAY_DATA,</span><br><span class="line">EGAME_OVER</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UENUM(BlueprintType)</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">FMsgVersion</span> :</span>uint8</span><br><span class="line">&#123;</span><br><span class="line">VERSION0 = <span class="number">0</span>,</span><br><span class="line">VERSION1 = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoHead</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FMsgType MsgType;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FMsgVersion MsgVer;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">int32 BodyLen;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoBody</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line"><span class="keyword">bool</span> Result;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">int32 MsgId;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">TArray&lt;int32&gt; DataArray;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">USTRUCT(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FProtoMsg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">GENERATED_BODY()</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FProtoHead Header;</span><br><span class="line">UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class="string">"Mantra"</span>)</span><br><span class="line">FProtoBody Body;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">UCLASS()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PACMAN_API</span> <span class="title">AGameNetwork</span> :</span> <span class="keyword">public</span> AGameStateBase</span><br><span class="line">&#123;</span><br><span class="line">GENERATED_BODY()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendMsg</span><span class="params">(FProtoMsg Msg)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RecvMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function">FProtoMsg <span class="title">Front</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function">TArray&lt;FProtoMsg&gt; <span class="title">PopBackAllMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">FIPv4Address Ip;</span><br><span class="line"></span><br><span class="line">FSocket* ClientFd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseStatus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">PARSE_INIT,</span><br><span class="line">PARSE_HEAD,</span><br><span class="line">PARSE_BODY</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Decode</span><span class="params">(uint8* data, int32 len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">uint8* <span class="title">Encode</span><span class="params">(FProtoMsg Msg, int32* Len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> HEADER_SIZE = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">TArray&lt;uint8&gt; ReservedData;</span><br><span class="line"></span><br><span class="line">FProtoMsg* CurrentMsg;</span><br><span class="line"></span><br><span class="line">ParseStatus ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class="line"></span><br><span class="line">TArray&lt;FProtoMsg&gt; MsgArray;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParseHeader</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ParseBody</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"GameNetwork.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将字符串ip转换为点分十进制ip</span></span><br><span class="line">FIPv4Address::Parse(IPStr, Ip);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十进制ip 转化成网络地址</span></span><br><span class="line">TSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();</span><br><span class="line">addr-&gt;SetIp(Ip.Value);</span><br><span class="line">addr-&gt;SetPort(Port);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建TCP Socket 文件描述符</span></span><br><span class="line">ClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class="string">"TCP SOCKET"</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ClientFd-&gt;Connect(*addr))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::SendMsg</span><span class="params">(FProtoMsg Msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Len;</span><br><span class="line"><span class="keyword">int</span> Send;</span><br><span class="line">uint8* data;</span><br><span class="line">data = Encode(Msg, &amp;Len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ClientFd-&gt;Send(data, Len, Send))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::RecvMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ClientFd != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">uint8 Buffer[<span class="number">1024</span>]&#123;&#125;;</span><br><span class="line">uint32 Size = <span class="number">0</span>;</span><br><span class="line">int32 Read = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ClientFd-&gt;HasPendingData(Size))</span><br><span class="line">&#123;</span><br><span class="line">ClientFd-&gt;Recv(Buffer, <span class="number">1024</span>, Read);</span><br><span class="line"><span class="keyword">return</span> Decode(Buffer, Read);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::Decode</span><span class="params">(uint8* data, int32 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 防止沾包 直接将受到的数据全部按顺序存储</span></span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ReservedData.Push(data[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int32 r_len = ReservedData.Num();</span><br><span class="line">uint8* r_data = ReservedData.GetData();</span><br><span class="line">int32 parse_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (r_len &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (ParseStatus)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_INIT:</span><br><span class="line">CurrentMsg = <span class="keyword">new</span> FProtoMsg();</span><br><span class="line">ParseStatus = ParseStatus::PARSE_HEAD;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_HEAD:</span><br><span class="line"><span class="keyword">if</span> (!ParseHeader(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> ParseStatus::PARSE_BODY:</span><br><span class="line"><span class="keyword">if</span> (!ParseBody(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CurrentMsg != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">MsgArray.Push(*CurrentMsg);</span><br><span class="line">&#125;</span><br><span class="line">CurrentMsg = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (int32 i = <span class="number">0</span>; i &lt; parse_len; ++i)</span><br><span class="line">&#123;</span><br><span class="line">ReservedData.Pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">uint8* <span class="title">AGameNetwork::Encode</span><span class="params">(FProtoMsg Msg, int32* Len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Msg.Header.BodyLen = Msg.Body.DataArray.Num() * Msg.Body.DataArray.GetTypeSize() + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">*Len = Msg.Header.BodyLen + HEADER_SIZE;</span><br><span class="line"><span class="comment">// HEADER</span></span><br><span class="line"><span class="keyword">auto</span>* data = <span class="keyword">new</span> <span class="keyword">uint8_t</span>[*Len];</span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, *Len);</span><br><span class="line"></span><br><span class="line">*data = (uint8)Msg.Header.MsgType;</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">*data = (uint8)Msg.Header.MsgVer;</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">*(<span class="keyword">uint32_t</span>*)data = Msg.Header.BodyLen;</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BODY</span></span><br><span class="line">data++;</span><br><span class="line">*(<span class="keyword">uint32_t</span>*)data = Msg.Body.MsgId;</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(data, Msg.Body.DataArray.GetData(), Msg.Header.BodyLen - <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回退增加的部分</span></span><br><span class="line"><span class="keyword">return</span> data - HEADER_SIZE - <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::ParseHeader</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*reserved_len &lt; HEADER_SIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8* data = *r_data;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.MsgType = StaticCast&lt;FMsgType&gt;(*data);</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.MsgVer = StaticCast&lt;FMsgVersion&gt;(*data);</span><br><span class="line">data++;</span><br><span class="line"></span><br><span class="line">CurrentMsg-&gt;Header.BodyLen = *(uint32*)data;</span><br><span class="line"></span><br><span class="line">*reserved_len -= HEADER_SIZE;</span><br><span class="line">*parse_len += HEADER_SIZE;</span><br><span class="line">*r_data += HEADER_SIZE;</span><br><span class="line"></span><br><span class="line">ParseStatus = ParseStatus::PARSE_BODY;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::ParseBody</span><span class="params">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (*reserved_len &lt; CurrentMsg-&gt;Header.BodyLen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint8* data = *r_data;</span><br><span class="line"><span class="comment">// current_msg-&gt;body = data;</span></span><br><span class="line">CurrentMsg-&gt;Body.Result = (*data) == <span class="number">1</span>;</span><br><span class="line">data++;</span><br><span class="line">CurrentMsg-&gt;Body.MsgId = *(int32*)data;</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ((CurrentMsg-&gt;Header.BodyLen - <span class="number">5</span>) / <span class="keyword">sizeof</span>(int32)); ++i)</span><br><span class="line">&#123;</span><br><span class="line">CurrentMsg-&gt;Body.DataArray.Add(*(int32*)data);</span><br><span class="line">data += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*reserved_len -= CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line">*parse_len += CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line">*r_data += CurrentMsg-&gt;Header.BodyLen;</span><br><span class="line"></span><br><span class="line">ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AGameNetwork::IsEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MsgArray.Num() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FProtoMsg <span class="title">AGameNetwork::Front</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MsgArray.Top();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AGameNetwork::Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// MsgArray.Pop();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TArray&lt;FProtoMsg&gt; <span class="title">AGameNetwork::PopBackAllMsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TArray&lt;FProtoMsg&gt; MsgArrayTemp = MsgArray;</span><br><span class="line">MsgArray.Empty();</span><br><span class="line"><span class="keyword">return</span> MsgArrayTemp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一下UE4 Tcp传输数据的客户端代码&lt;br&gt;方便日后使用&lt;/p&gt;
&lt;h1 id=&quot;头文件&quot;&gt;&lt;a href=&quot;#头文件&quot; class=&quot;headerlink&quot; title=&quot;头文件&quot;&gt;&lt;/a&gt;头文件&lt;/h1&gt;&lt;p&gt;#include “Networking.h”&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="UE4" scheme="http://blog.lsmg.xyz/categories/UE4/"/>
    
      <category term="网络" scheme="http://blog.lsmg.xyz/categories/UE4/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器-理论部分</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9599-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%9599-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%86/</id>
    <published>2020-03-06T14:53:00.000Z</published>
    <updated>2020-03-17T12:09:12.437Z</updated>
    
    <content type="html"><![CDATA[<p>距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.<br>半年后开始准备补上这四章</p><h1 id="第一章-TCP-IP协议族"><a href="#第一章-TCP-IP协议族" class="headerlink" title="第一章 TCP/IP协议族"></a>第一章 TCP/IP协议族</h1><h2 id="TCP-IP协议族体系结构和主要协议"><a href="#TCP-IP协议族体系结构和主要协议" class="headerlink" title="TCP/IP协议族体系结构和主要协议"></a>TCP/IP协议族体系结构和主要协议</h2><p>协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg" alt=""></p><p><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=3a1768f4c6fc1e17e9b284632bf99d66/0dd7912397dda144d48ab350bbb7d0a20df48655.jpg" alt=""></p><p>同样七层是osi参考模型, 简化后得到四层<br>不同层次之间, 通过接口互相交流, 这样方便了各层次的修改</p><p><strong>应用层</strong><br>负责处理应用程序的逻辑</p><p><strong>表示层</strong><br>定义了数据的格式及加密</p><p><strong>会话层</strong><br>它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的</p><p><strong>传输层</strong><br>为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.<br>此层存在两大协议TCP协议和UDP协议<br>TCP协议(Transmission Control Protocol 传输控制协议)</p><ul><li>为应用层提供<code>可靠的, 面向连接, 基于流的服务</code></li><li>通过<code>超时重传</code>和<code>数据确认</code>等确保数据正常送达.</li><li>TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器<br>UPD协议(User Datagram Protocol 用户数据报协议)</li><li>为应用层提供<code>不可靠的, 无连接的, 基于数据报的服务</code></li><li>一般需要自己处理<code>数据确认</code>和<code>超时重传</code>的问题</li><li>通信两者不存储状态, 每次发送都需要指定地址信息. <code>有自己的长度</code></li></ul><p><strong>网络层</strong><br>实现了数据包的选路和转发.  只有数据包到不了目标地址, 就<code>下一跳</code>(hop by hop), 选择最近的.<br><em>IP协议(Internet Protocol)</em> 以及 <em>ICMP协议(Internet Control Message Protocol)</em><br>后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)</p><p><strong>数据链路层</strong><br>实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.<br>存在两个协议 <em>ARP协议(Address Resolve Protocol, 地址解析协议)</em>. 还有<em>RARP(Reverse ~, 逆地址解析协议)</em>.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议<em>ARP欺骗, 可能与这个有关, 目前不去学习</em></p><p><strong>封装</strong><br>上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.<br>被TCP封装的数据成为 <code>TCP报文段</code></p><ul><li>内核部分发送成功后删除数据</li></ul><p>被UDP封装的数据成为 <code>UDP数据报</code></p><ul><li>发送后即删除</li></ul><p>再经IP封装后成为<code>IP数据报</code><br>最后经过数据链路层封装后为 <code>帧</code></p><p>以太网最大数据帧1518字节 抛去14头部 帧尾4校验<br>MTU: 帧的最大传输单元 一般为1500字节<br>MSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头-20TCP头 还有额外的40字节可选部分</p><p><strong>ARP</strong><br>ARP协议能实现任意网络层地址到任意物理地址的转换</p><h1 id="第二章-IP协议详解"><a href="#第二章-IP协议详解" class="headerlink" title="第二章 IP协议详解"></a>第二章 IP协议详解</h1><p>IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一<br>IP协议为上层协议提供无状态, 无连接, 不可靠的服务</p><p>IP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制</p><p>当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png" alt=""></p><p>路由机制</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png" alt=""></p><p>给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤</p><ul><li>查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步</li><li>查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到……. 否则下一步</li><li>选择默认路由项, 通常意味着下一跳路由是网关</li></ul><h1 id="第三章-TCP协议详解"><a href="#第三章-TCP协议详解" class="headerlink" title="第三章 TCP协议详解"></a>第三章 TCP协议详解</h1><p>Tcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.</p><p>UDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断</p><p>ISN-初始序号值<br>32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移<br>32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答</p><p>ACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为<code>确认报文段</code><br>PSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间<br>RST标志: 要求对方重新建立连接 携带……<code>复位报文段</code><br>SYN标志: 标志请求建立一个连接 携带……<code>同步报文段</code><br>FIN标志: 通知对方本端连接要关闭了, 携带..<code>结束报文段</code></p><p>16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据<br>16位校验和: <code>可靠传输的重要保障</code>发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验<code>TCP头部</code>和<code>数据部分</code></p><p><strong>TCP连接的建立和关闭</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 三次握手</span><br><span class="line"># 客户端发送请求连接 ISN&#x3D;seq + 0 &#x3D; 3683340920</span><br><span class="line"># mss 最大数据载量1460</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [S], seq 3683340920, win 64240, </span><br><span class="line">options [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0</span><br><span class="line"></span><br><span class="line"># 同意客户端连接</span><br><span class="line"># ack &#x3D; 客户端发送 seq + 1</span><br><span class="line"># 同时发送服务端的seq</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [S.], seq 938535101, ack 3683340921, win 64240, </span><br><span class="line">options [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0</span><br><span class="line"></span><br><span class="line"># 虽然这个报文段没有字节 但由于是同步报文段 需要占用一个序号值</span><br><span class="line"># 这里是tcpdump的处理 ack显示相对值 即 3683340921 - 3683340920 &#x3D; 1</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [.], ack 938535102, win 4106, length 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 包含FIN标志 说明要求结束连接 也需要占用一个序号值</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [F.], seq 1, ack 1, win 4106, length 0</span><br><span class="line"></span><br><span class="line"># 服务端确认关闭连接</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [.], ack 2, win 502, length 0</span><br><span class="line"></span><br><span class="line"># 服务端发送关闭连接</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [F.], seq 1, ack 2, win 4105, length 0</span><br><span class="line"></span><br><span class="line"># 客户端确认</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [.], ack 2, win 503, length 0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.&lt;br&gt;半年后开始准备补上这四章&lt;/p&gt;
&lt;h1 id=&quot;第一章-TCP-IP协议族&quot;&gt;&lt;a href=&quot;#第一章-TCP-IP协议族&quot; class=&quot;headerlink&quot; title=&quot;第一章 TC
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>分支管理和实际应用</title>
    <link href="http://blog.lsmg.xyz/2020/03/Git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/Git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</id>
    <published>2020-03-06T11:34:25.000Z</published>
    <updated>2020-03-12T07:48:44.746Z</updated>
    
    <content type="html"><![CDATA[<p>2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄… 来更新下</p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p><code>git checkout -b dev</code>相当于一下两条命令<br><code>git branch dev</code> 分支创建<br><code>git checkout dev</code> 分支切换</p><p><code>git branch -d dev</code> 分支删除</p><p><code>git branch</code> 查看当前所有分支</p><p><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p><p><strong>冲突解决</strong><br><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 111111111111111</span><br><span class="line">2 222222222222222</span><br><span class="line">3 333333333333333</span><br><span class="line">4 444444444444444</span><br><span class="line">5 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  # 我在master分支下添加了6666666 并提交</span><br><span class="line">6 6666666</span><br><span class="line">7 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">8 7777777</span><br><span class="line">9 &gt;&gt;&gt;&gt;&gt;&gt;&gt; deb # 我在deb分支下添加了7777777 并提交</span><br></pre></td></tr></table></figure><p>最后需要我手动修改这个文件为自己需要的内容 然后提交即可</p><p><strong>分支管理</strong><br>通常Git会使用<code>Fast forward</code>模式 这样删除分支后会丢失分支的信息<br>可以再merge的时候加入<code>--no-ff</code>这样就能解决问题<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>由于禁用<code>Fast forward</code>后<br>会生成新的commit所以需要加入<code>-m &quot;merge with no-ff&quot;</code></p><p>git stash 可以储存当前的工作区 继续其他的工作<br>git stash list 查看储存的工作区列表<br>git stash apply stash@{0} 恢复指定的储存<br>git stash pop 恢复并drop最近的存储 慎用这个 建议使用上边的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt # stash前</span><br><span class="line">111111</span><br><span class="line">$ vim test.txt </span><br><span class="line">$ cat test.txt # 进行了修改</span><br><span class="line">111111</span><br><span class="line">222222</span><br><span class="line">333333</span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">修改：     test.txt</span><br><span class="line">$ git stash # stash</span><br><span class="line">保存工作目录和索引状态 WIP on master: 854b710 1</span><br><span class="line">$ cat test.txt </span><br><span class="line">111111</span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br><span class="line">$ git stash pop</span><br><span class="line">位于分支 master</span><br><span class="line">修改：     test.txt</span><br><span class="line">$ cat test.txt </span><br><span class="line">111111</span><br><span class="line">222222</span><br><span class="line">333333</span><br></pre></td></tr></table></figure><h1 id="实际工作中分支的应用"><a href="#实际工作中分支的应用" class="headerlink" title="实际工作中分支的应用"></a>实际工作中分支的应用</h1><p><a href="https://zhuanlan.zhihu.com/p/38772378" target="_blank" rel="noopener">主要参考</a><br><strong>主分支</strong></p><ul><li><strong>master</strong>: 这个分支最稳定, 相当于放的可发布版本</li><li><strong>develop</strong>: 开发分支, 平行于master分支, 负责合并各种<code>用于开发子功能</code>的分支</li></ul><p><strong>支持分支</strong>:解决某个问题, 结束后合并回<code>master</code>或<code>develop</code>分支</p><ul><li><strong>feature</strong>功能分支, 用于开发一个个子功能, 来自<code>develop</code>合并到<code>develop</code>去</li><li><strong>release</strong>:发布分支, 用于修改版本号等小修改, 来自<code>develop</code>分支合并到<code>master</code>分支</li><li><strong>hotfixes</strong>:紧急修复bug分支, 从<code>master</code>创建, 合并回<code>develop</code>分支和<code>master</code>分支<br><img src="https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg" alt=""></li></ul><p><a href="https://juejin.im/post/5d82e1f3e51d4561d044cd88#heading-14" target="_blank" rel="noopener">Git 分支管理规范</a></p><p><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">Git 基础 - 打标签</a></p><p><strong>develop分支完成了操作, 准备发布新的版本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从 develop 分支上创建 release 分支:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命名规则如下 release-事件-版本</span></span><br><span class="line">git checkout –b release-20190919-v1.0.0 develop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修复完release的bug后再次提交修改:</span></span><br><span class="line">git checkout release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交本地修改, 如果没有修改bug 可以跳过</span></span><br><span class="line">git add .</span><br><span class="line">git commit –m “提交日志”</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送 release 分支</span></span><br><span class="line">git push origin release-20190919-v1.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 发布新版本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并 release 分支到 master 分支:</span></span><br><span class="line">git checkout master</span><br><span class="line">git merge --no-ff release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并 release 分支到 develop 分支:</span></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在 master 分支上创建标签:</span></span><br><span class="line">git tag tag-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地 release 分支:</span></span><br><span class="line">git branch –d release-20190919-v1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程 release 分支:</span></span><br><span class="line">git push origin :release-20190919-v1.0.0</span><br></pre></td></tr></table></figure><p>新版本完成之后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 推送master分支</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意上边打的tag需要手动提交 默认push不会提交tag</span></span><br><span class="line">git push origin [tag name]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以给push增加参数</span></span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h1 id="本地和远程分支和tag的删除"><a href="#本地和远程分支和tag的删除" class="headerlink" title="本地和远程分支和tag的删除"></a>本地和远程分支和tag的删除</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 本地</span></span><br><span class="line">git tag -d xxx</span><br><span class="line">git branch -d xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 远程</span></span><br><span class="line">git push origin :refs/tags/xxx</span><br><span class="line">git push origin :xxx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄… 来更新下&lt;/p&gt;
&lt;h1 id=&quot;分支管理&quot;&gt;&lt;a href=&quot;#分支管理&quot; class=&quot;headerlink&quot; title=&quot;分支管理&quot;&gt;&lt;/a&gt;分支管理&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git 
      
    
    </summary>
    
    
      <category term="必备技能" scheme="http://blog.lsmg.xyz/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
      <category term="Git操作" scheme="http://blog.lsmg.xyz/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/Git%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="Git操作" scheme="http://blog.lsmg.xyz/tags/Git%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>循环判断中使用无符号类型</title>
    <link href="http://blog.lsmg.xyz/2020/03/CPP-CPP%E9%87%87%E5%9D%91-%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%AD%E4%B9%8B%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B/"/>
    <id>http://blog.lsmg.xyz/2020/03/CPP-CPP%E9%87%87%E5%9D%91-%E5%BE%AA%E7%8E%AF%E5%88%A4%E6%96%AD%E4%B9%8B%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-03-06T09:37:08.000Z</published>
    <updated>2020-03-06T12:18:05.173Z</updated>
    
    <content type="html"><![CDATA[<p>下面的代码 会产生错误.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无符号类型的数值和有符号类型的数值进行运算(包括算数逻辑运算等)会将有符号类型的数值转换成无符号类型的数值.</p><p>但是对于char short等小于int的数值运算的时候 会转换成int 纯正的int<br>对于unsigned char在转换成int时，无论最高位是0还是1，都补0<br>signed char的则高位时1补1 0补0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0*23 1</span></span><br><span class="line"><span class="comment">// 1*23 0</span></span><br><span class="line"><span class="comment">// 1*24 本来是int 但被当作了 无符号int 所以输出</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">if</span> (a &lt; b) <span class="comment">// 逻辑运算也转换了</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a &lt; b"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4294967295</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//   11111111 11111111 11111111 11111111</span></span><br><span class="line"><span class="comment">//   00000000 00000000 00000000 00000010</span></span><br><span class="line"><span class="comment">// 1 00000000 00000000 00000000 00000001</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> c = <span class="number">2</span>; <span class="comment">// 0*22 1 0</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">-1</span>; <span class="comment">// 1*24</span></span><br><span class="line"><span class="keyword">if</span> (c &lt; d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"c &lt; d"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c + d &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1   直接把高位的1溢出了 留下了0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2*23 1</span></span><br><span class="line"><span class="comment">// 1*23 0</span></span><br><span class="line"><span class="comment">// 1*24 被转换成了int 所以输出-1</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> e = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> f = <span class="number">-2</span>;</span><br><span class="line"><span class="keyword">if</span> (e &lt; f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"e &lt; f"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 没有输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e + f &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> g = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">char</span> h = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (g &lt; h)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"g &lt; h"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 未输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; g + h &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下面的代码 会产生错误.&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP踩坑" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E8%B8%A9%E5%9D%91/"/>
    
    
      <category term="CPP踩坑记" scheme="http://blog.lsmg.xyz/tags/CPP%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>Mysql基本使用</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql-Mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%95%B0%E6%8D%AE%E5%BA%93-Mysql-Mysql%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2020-03-06T07:25:28.000Z</published>
    <updated>2020-03-06T07:59:36.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h1><p>Ubuntu18.04 安装 mysql5.7</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><p>安装完毕后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打开shell管理程序</span></span><br><span class="line">sudo mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 123456 换成你自己的密码</span></span><br><span class="line">ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 刷新一下</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出</span></span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录测试</span></span><br><span class="line">mysql -uroot -p # 回车 后输入自己的密码再次回车</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装和配置&quot;&gt;&lt;a href=&quot;#安装和配置&quot; class=&quot;headerlink&quot; title=&quot;安装和配置&quot;&gt;&lt;/a&gt;安装和配置&lt;/h1&gt;&lt;p&gt;Ubuntu18.04 安装 mysql5.7&lt;/p&gt;
&lt;figure class=&quot;highlight shell
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://blog.lsmg.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Mysql" scheme="http://blog.lsmg.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://blog.lsmg.xyz/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>球球</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AD%A6%E9%99%A2-%E7%90%83%E7%90%83/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AD%A6%E9%99%A2-%E7%90%83%E7%90%83/</id>
    <published>2020-03-05T13:50:02.000Z</published>
    <updated>2020-03-05T14:42:14.972Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://gameinstitute.qq.com/course/detail/10110" target="_blank" rel="noopener">休闲: 球球</a></p><p>P2P 模式…….. 好吧没有采用基本模式<br>采用了变种, 从客户端中选取主客户端 局域网游戏会采用</p><p><strong>状态同步</strong><br>MMO用的多, 断线重连简单 直接返回状态</p><p>收到命令集 计算后 返回结果 防作弊 服务器压力大 包量大</p><p>预表现emm</p><p><strong>帧同步</strong><br>服务器广播客户端发送的指令集, 断线重连需要补上丢失的帧</p><p>预表现emm</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E8%AF%BE%E5%A0%82/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AF%B9%E6%AF%94.png" alt=""></p><p>航标<br>终于知道游戏瞬移是怎么回事了</p><p>影子追随</p><p>心跳包矫正时间 获取延迟等等</p><p>王者 帧同步.</p><p>守望先锋 16ms一个包</p><p>RTT网络延迟</p><p>预表现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://gameinstitute.qq.com/course/detail/10110&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;休闲: 球球&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P2P 模式…….. 好吧没有采用基本模式&lt;br&gt;采用了变
      
    
    </summary>
    
    
      <category term="游戏知识" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="服务器" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="腾讯游戏学院" scheme="http://blog.lsmg.xyz/tags/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E5%AD%A6%E9%99%A2/"/>
    
  </entry>
  
  <entry>
    <title>操作系统点带面</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%82%B9%E5%B8%A6%E9%9D%A2/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%82%B9%E5%B8%A6%E9%9D%A2/</id>
    <published>2020-03-03T10:41:28.000Z</published>
    <updated>2020-03-14T10:41:26.689Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>算法分类学习</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9592-%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA-%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB%E5%AD%A6%E4%B9%A0/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9592-%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA-%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-03-03T02:38:28.000Z</published>
    <updated>2020-03-17T03:56:20.086Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法理论" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9591-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E7%AE%97%E6%B3%95/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9591-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E7%AE%97%E6%B3%95/</id>
    <published>2020-03-03T02:38:28.000Z</published>
    <updated>2020-03-19T08:44:16.156Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="贪心-动态规划"><a href="#贪心-动态规划" class="headerlink" title="贪心 动态规划"></a>贪心 动态规划</h2><p><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">https://leetcode.com/problems/jump-game/</a></p><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.<br>Each element in the array represents your maximum jump length at that position.<br>Determine if you are able to reach the last index.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Example <span class="number">1</span>:</span><br><span class="line">Input: [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: Jump <span class="number">1</span> <span class="built_in">step</span> from index <span class="number">0</span> to <span class="number">1</span>, then <span class="number">3</span> steps to the last index.</span><br><span class="line"></span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="literal">false</span></span><br><span class="line">Explanation: You will always arrive at index <span class="number">3</span> no matter what. Its maximum</span><br><span class="line">             jump length is <span class="number">0</span>, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure><p>这是我LeetCode第一道中等难度算法, 刚上来不知道怎么做. 然后瞟了一眼题解说是动态规划问题.我就去查了下动态规划的问题解法</p><p><a href="https://www.zhihu.com/question/23995189/answer/613096905" target="_blank" rel="noopener">什么是动态规划（Dynamic Programming）？动态规划的意义是什么？ - 阮行止的回答 - 知乎</a></p><p><strong>贪心</strong><br>这样算是有了个初步了解, 不过我上来先用了贪心… 因为简单一些, 动态规划暂时没有想到怎么解.<br>结果运行时间超过 11%的人好吧 最坏的时间复杂度应该是O(n!)… 最优O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum_step = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> now_sub = sum_step - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> min_sub = now_sub;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> jumpout = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = now_sub - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= (now_sub - i))</span><br><span class="line">            &#123;</span><br><span class="line">                min_sub = i;</span><br><span class="line">                jumpout = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        now_sub = min_sub;</span><br><span class="line">        <span class="keyword">if</span> (jumpout)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> now_sub == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        jumpout = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我看了下题解的贪婪算法… 我的应该也是贪婪的一种. 不过题解的贪婪更加快.<br>我的想法是从顶开始 每次遍历找到<code>最低的能跳过来的一层</code> 然后再从<code>最低的能跳过来的一层</code>遍历.直到到不能再跳就返回当前是不是底层</p><p>题解的解法粗略看就是差在了第一个if的判断条件, 我判断的当前的层, 题解判断的<code>最低的能跳过来的一层</code>题解的解法是<code>能跳则跳</code> 我的解法是<code>跳最少的次数</code> 实际上针对此题<code>能跳则跳</code>就好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now_sub = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> min_sub = now_sub;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = now_sub - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + i &gt;= min_sub)</span><br><span class="line">        &#123;</span><br><span class="line">            min_sub = i;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> min_sub == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我猜测绝对有一道题输出最少的跳跃次数, 没想到真有. 结果试了下时间超限…..<br>理论上我第一种解法能够完成emmm, 不过先不管那道题目了.</p><p><strong>递归回溯</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJumpFromPosition</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">position</span> == nums.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_position = <span class="built_in">min</span>(<span class="built_in">position</span> + nums[<span class="built_in">position</span>], (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// for (int i = max_position; i &gt; position; --i)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">position</span> + <span class="number">1</span>; i &lt;= max_position; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (canJumpFromPosition(i, nums))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> canJumpFromPosition(<span class="number">0</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种方法思考起来简单些, 你只要知道递归的条件是什么</p><p>递归到什么时候返回值来回溯</p><p>这个题目, 你只要在当前位置不断跳到所有能去的位置, 然后递归下去. 直到你的位置到了尾部就返回true, 或者你不能再跳返回false. 自然时间超限了</p><p>上面的解法, 还有优化的空间. 因为这个是从左到右依次进行, 然而实际上从越远的地方进行更容易到达尾部. 所以可以修改for的判断条件在图中注释部分</p><p><strong>动态规划 自上而下</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Index &#123;UNKNOW, GOOD, BAD&#125;;</span><br><span class="line">Index *memo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJumpFromPosition</span><span class="params">(<span class="keyword">int</span> <span class="built_in">position</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memo[<span class="built_in">position</span>] != UNKNOW)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[<span class="built_in">position</span>] == GOOD;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max_position = <span class="built_in">min</span>(<span class="built_in">position</span> + nums[<span class="built_in">position</span>], (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = max_position; i &gt; <span class="built_in">position</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (canJumpFromPosition(i, nums))</span><br><span class="line">        &#123;</span><br><span class="line">            memo[<span class="built_in">position</span>] = GOOD;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    memo[<span class="built_in">position</span>] = BAD;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    memo = <span class="keyword">new</span> Index[nums.<span class="built_in">size</span>()]&#123;&#125;;</span><br><span class="line">    memo[nums.<span class="built_in">size</span>() - <span class="number">1</span>] = GOOD;</span><br><span class="line">    <span class="keyword">return</span> canJumpFromPosition(<span class="number">0</span>, nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前的方法中, 仔细想想就会发现 会有很多的下标被多次调用, 尽管那个下标是无法到达结尾的. 怎么解决呢? 当然是保存状态了, 每次递归结束后就标记当前的下标能不能到达. 之后遇到被标记的下标就能直接返回</p><p>然而现在的时间复杂度依然高达 O(n^2)</p><p><strong>自下而上的动态规划</strong></p><p>通过消除递归的方式, 消除递归的一个好方法就是颠倒顺序. 上面那是从左到右向右跳, 这次我们从右向左向右跳, 就能更容易的知道知道某个下标是<code>GOOD</code>还是<code>BAD</code>了, 因为离最右端更近了.</p><p>时间复杂度依然是O(n^2)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Index &#123;UNKNOW, GOOD, BAD&#125;;</span><br><span class="line">Index *memo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    memo = <span class="keyword">new</span> Index[nums.<span class="built_in">size</span>()]&#123;&#125;;</span><br><span class="line">    memo[nums.<span class="built_in">size</span>() - <span class="number">1</span>] = GOOD;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> furthest_jump = <span class="built_in">min</span>(nums[i] + i, (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= furthest_jump; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (memo[j] == GOOD)</span><br><span class="line">            &#123;</span><br><span class="line">                memo[i] = GOOD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[<span class="number">0</span>] == GOOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h2 id=&quot;贪心-动态规划&quot;&gt;&lt;a href=&quot;#贪心-动态规划&quot; class=&quot;headerlink&quot; title=&quot;贪心 
      
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题记录" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构指针简答应用</title>
    <link href="http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9590-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/03/%E7%AE%97%E6%B3%9590-%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</id>
    <published>2020-03-03T02:38:28.000Z</published>
    <updated>2020-03-31T09:07:13.076Z</updated>
    
    <content type="html"><![CDATA[<p>为了压缩长度. 所有空行都删掉了</p><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="哈希表建立快速索引-一遍和两遍哈希的使用"><a href="#哈希表建立快速索引-一遍和两遍哈希的使用" class="headerlink" title="哈希表建立快速索引, 一遍和两遍哈希的使用"></a>哈希表建立快速索引, 一遍和两遍哈希的使用</h2><p><a href="https://leetcode.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode.com/problems/two-sum</a><br>题目很简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><p>不是最差… 也差不多了 最简单粗暴的形式 O(n2) O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 答案肯定是一个小数和一个大数 相加, 直接往后找 测试用例应该是排好序的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, j&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两遍哈希 由于需要更快的找到 vector中某个元素的下标, 非常适合哈希表来做<br>先放入哈希表中, 再寻找自己所需要的值是否存在以及下标 O(n) O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; the_map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">the_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> search = the_map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line"><span class="comment">// unordered_map&lt;int, int&gt;::iterator search = the_map.find(target - nums[i]);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (search != the_map.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (search-&gt;second == i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, search-&gt;second&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一遍哈希, 既然是要在表中查找到需要数 还需要判断是否同一个数<br>干脆直接在插入前就进行查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; the_map;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> search = the_map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line"><span class="keyword">if</span> (search != the_map.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;i, search-&gt;second&#125;;</span><br><span class="line">&#125;</span><br><span class="line">the_map.insert(&#123;nums[i], i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="flag的使用"><a href="#flag的使用" class="headerlink" title="flag的使用"></a>flag的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</span><br><span class="line"></span><br><span class="line">在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">假设字符串的长度不会超过 1010。</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure><p>这个开始我这样写的, 因为需要<br>在有奇数字母个数的时候 需要额外 结果+1<br>没有奇数字母个数 结果不需要额外 +1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> letter[<span class="number">68</span>]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">letter[s[i] - <span class="number">65</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> oddnum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">68</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> num = letter[i];</span><br><span class="line">sum += num;</span><br><span class="line"><span class="keyword">if</span> (num %<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">oddnum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum -= oddnum;</span><br><span class="line"><span class="comment">// 通过额外的一个if判断 是否存在奇数</span></span><br><span class="line"><span class="keyword">if</span> (oddnum &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> oddnum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 设置这个flag 代码少了一个if 实际用途有没有.... 感觉这个思想是可以的</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">68</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> num = letter[i];</span><br><span class="line">sum += num;</span><br><span class="line"><span class="keyword">if</span> (num %<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">oddnum++;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sum -= oddnum;</span><br><span class="line"><span class="keyword">return</span> sum + flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双指针操作"><a href="#双指针操作" class="headerlink" title="双指针操作"></a>双指针操作</h1><h2 id="双指针左右逼近-数学问题"><a href="#双指针左右逼近-数学问题" class="headerlink" title="双指针左右逼近-数学问题"></a>双指针左右逼近-数学问题</h2><p><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode.com/problems/container-with-most-water/</a></p><p>存水量 = a(宽) * b(长);</p><p>从a最大的时候开始, 如果想要获得更大的存水量, 只能减少a, 增加b</p><p>使用两个指针 一个指向最左边 一个指向最右边</p><p>这就有了移动哪个指针的问题, 为了得到更长的b 只能移动指向较短b的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">height</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;   </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator left = <span class="built_in">height</span>.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator right = <span class="built_in">height</span>.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">min</span>(*left, *right) * (right - left);</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; <span class="built_in">max</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">max</span> = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移动较短边</span></span><br><span class="line">        <span class="keyword">if</span> (*left &lt;= *right)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并排序数组-双指针操作-拷贝到临时数组和直接写到原数组"><a href="#合并排序数组-双指针操作-拷贝到临时数组和直接写到原数组" class="headerlink" title="合并排序数组-双指针操作 拷贝到临时数组和直接写到原数组"></a>合并排序数组-双指针操作 拷贝到临时数组和直接写到原数组</h2><p><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sorted-merge-lcci/</a><br>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。<br>初始化 A 和 B 的元素数量分别为 m 和 n。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">B = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>第一次太惨了, 看来我算法需要加倍的联系啊. 先不说考虑很久</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 这里的 m + n就有点问题, 后面会空转 改为m + temp合适</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (A.at(i) &lt; B.at(temp))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">A.insert(A.<span class="built_in">begin</span>() + i, B.at(temp++));</span><br><span class="line"><span class="keyword">if</span> (temp == n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (temp &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">A.insert(A.<span class="built_in">begin</span>() + m + temp, B.<span class="built_in">begin</span>() + temp, B.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line">A.erase(A.<span class="built_in">begin</span>() + n + m, A.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用插入再删除, 本身这个方法就不是很好. 后来看题解有双指针, 就去试了下. 这样需要额外的空间<br>如果直接正序的修改A的值, 可能会导致A的值被覆盖掉.<br>那么倒序呢? 倒序放上最大的值 就不会覆盖掉A中未读取的值了 继续修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sorted[m + n];</span><br><span class="line"><span class="keyword">auto</span> a = A.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> b = B.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (index != m + n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a - A.<span class="built_in">begin</span>() == m)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b - B.<span class="built_in">begin</span>() == n)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*a &lt; *b)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*a == *b)</span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *a++;</span><br><span class="line">sorted[index++] = *b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sorted[index++] = *b++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m + n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">A[i] = sorted[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改正后的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = m + n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a = m - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (index &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = B[b--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = A[a--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A[a] &gt; B[b])</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = A[a--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (A[a] == B[b])</span><br><span class="line">&#123;</span><br><span class="line">A[index--] = A[a--];</span><br><span class="line">A[index--] = B[b--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">A[index--] = B[b--];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Plus-One-临时插入-如果无效则删除"><a href="#Plus-One-临时插入-如果无效则删除" class="headerlink" title="Plus One-临时插入 如果无效则删除"></a>Plus One-临时插入 如果无效则删除</h2><p><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">https://leetcode.com/problems/plus-one/</a><br>给定一个数组, [1, 2, 3]代表123 给这个数字+1 返回数组形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">Explanation: The <span class="built_in">array</span> represents the integer <span class="number">123.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">plusOne</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// insert zero in case of like this [9]</span></span><br><span class="line">digits.insert(digits.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> <span class="built_in">end</span> = digits.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">*<span class="built_in">end</span> += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(*<span class="built_in">end</span> == <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">*<span class="built_in">end</span> = <span class="number">0</span>;</span><br><span class="line">*(--<span class="built_in">end</span>) += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if the zero is useless delete it</span></span><br><span class="line"><span class="keyword">if</span> (digits[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">digits.erase(digits.<span class="built_in">begin</span>(), digits.<span class="built_in">begin</span>() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="谨记无符号踩坑"><a href="#谨记无符号踩坑" class="headerlink" title="谨记无符号踩坑"></a>谨记无符号踩坑</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p><p>这个的代码就不贴出来了, 我也没有偷懒 没有!!!</p><p>这个主要是记录下 无符号值的使用</p><p>充实了我的CPP踩坑记的文章</p><h2 id="数组排序降低复杂度-通过排序去重"><a href="#数组排序降低复杂度-通过排序去重" class="headerlink" title="数组排序降低复杂度 通过排序去重"></a>数组排序降低复杂度 通过排序去重</h2><p>三数之和<br><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> target = -nums[i];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line"><span class="keyword">if</span> (sum == target)</span><br><span class="line">&#123;</span><br><span class="line">result.push_back(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line"><span class="keyword">while</span> ((left &lt; right) &amp;&amp; (nums[left] == nums[left + <span class="number">1</span>]))</span><br><span class="line">&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((left &lt; right) &amp;&amp; (nums[right] == nums[right - <span class="number">1</span>]))</span><br><span class="line">&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">left++;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>) &amp;&amp; (nums[i] == nums[i + <span class="number">1</span>]))</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组排序降复杂度-单一结果保存应放在循环外"><a href="#数组排序降复杂度-单一结果保存应放在循环外" class="headerlink" title="数组排序降复杂度 单一结果保存应放在循环外"></a>数组排序降复杂度 单一结果保存应放在循环外</h2><p><a href="https://leetcode-cn.com/problems/3sum-closest/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/3sum-closest/submissions/</a></p><p>这是我第一道自己做的 而且第一次提交就对的中等题目 QAQ<br>也是受了之前三数之和的启发</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个保存结果用的 我最开始放在了for里面, 最后用</span></span><br><span class="line"><span class="comment">// map自动按key排序选出最小的abs然后取出originsum</span></span><br><span class="line"><span class="comment">// 结果应该是放在for外面就好 这个题目就这一个逻辑简单结果</span></span><br><span class="line"><span class="keyword">int</span> absminsum = INT_MAX;</span><br><span class="line"><span class="keyword">int</span> originsum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> singel = nums[i];</span><br><span class="line"><span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sum = singel + nums[left] + nums[right];</span><br><span class="line"><span class="keyword">int</span> temp = sum - target;</span><br><span class="line"><span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (-temp &lt; absminsum)</span><br><span class="line">&#123;</span><br><span class="line">absminsum = -temp;</span><br><span class="line">originsum = sum;</span><br><span class="line">&#125;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (temp &lt;= absminsum)</span><br><span class="line">&#123;</span><br><span class="line">absminsum = temp;</span><br><span class="line">originsum = sum;</span><br><span class="line">&#125;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((i &lt; nums.<span class="built_in">size</span>() <span class="number">-3</span>) &amp;&amp; (nums[i + <span class="number">1</span>] == nums[i]))</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> originsum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><h2 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h2><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘,<br>return the length of last word (last word means the last appearing word if we loop from left to right) in the string.<br>If the last word does not exist, return 0.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">"Hello World"</span></span><br><span class="line">Output: <span class="number">5</span></span><br></pre></td></tr></table></figure><p>…出了问题 这个题目刚才写的解析全没了…… 只能保存下改正完的答案了<br>赶紧下载了一个vscode来用用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sub = s.length() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>((sub &gt;= <span class="number">0</span>) &amp;&amp; (s[sub] == <span class="string">' '</span>))</span><br><span class="line">&#123;</span><br><span class="line">sub--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (sub &gt;= <span class="number">0</span> &amp;&amp; (s[sub] != <span class="string">' '</span>))</span><br><span class="line">&#123;</span><br><span class="line">sub--;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> it = s.rbegin(), piv = s.rbegin();</span><br><span class="line"><span class="keyword">for</span>(;it != s.rend() &amp;&amp; *it == <span class="string">' '</span>; it++, piv = it);</span><br><span class="line"><span class="keyword">for</span>(;it != s.rend() &amp;&amp; *it != <span class="string">' '</span>; it++);</span><br><span class="line"><span class="keyword">return</span> it - piv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="atoi-flag灵性的初始值-优先级-INT-MIN-gt-INT-MAX"><a href="#atoi-flag灵性的初始值-优先级-INT-MIN-gt-INT-MAX" class="headerlink" title="atoi flag灵性的初始值, 优先级, -INT_MIN &gt; INT_MAX"></a>atoi flag灵性的初始值, 优先级, -INT_MIN &gt; INT_MAX</h2><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi/submissions/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(<span class="built_in">string</span> str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">begin</span> = &amp;str[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">end</span> = &amp;str[str.<span class="built_in">size</span>()];</span><br><span class="line"><span class="keyword">while</span> (*<span class="built_in">begin</span> == <span class="string">' '</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">begin</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">begin</span> == <span class="built_in">end</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认给1 很灵性 在*begin是+的时候少一次赋值 开头就是数字的情况不用在写一次else</span></span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span> (*<span class="built_in">begin</span> == <span class="string">'-'</span>)</span><br><span class="line">&#123;</span><br><span class="line">flag = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">begin</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*<span class="built_in">begin</span> == <span class="string">'+'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">begin</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="built_in">begin</span> &lt; <span class="built_in">end</span>) &amp;&amp; (*<span class="built_in">begin</span> &gt;= <span class="string">'0'</span>) &amp;&amp; (*<span class="built_in">begin</span> &lt;= <span class="string">'9'</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (result &gt; INT_MAX / <span class="number">10</span> || (result == INT_MAX / <span class="number">10</span> &amp;&amp; (*<span class="built_in">begin</span> - <span class="string">'0'</span>) &gt; INT_MAX % <span class="number">10</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> INT_MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result &lt; INT_MIN / <span class="number">10</span> || (result == INT_MIN / <span class="number">10</span> &amp;&amp; (*<span class="built_in">begin</span> - <span class="string">'0'</span>) &gt; -(INT_MIN % <span class="number">10</span>))) <span class="comment">// 这里要有括号 -INT_MIN &gt; INT_MAX</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> INT_MIN;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每步都乘一次flag也不错, 方便判断INTMAX和INTMIN</span></span><br><span class="line">result = result * <span class="number">10</span> + flag * (*<span class="built_in">begin</span> - <span class="string">'0'</span>); </span><br><span class="line"><span class="built_in">begin</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="a-a-b-b"><a href="#a-a-b-b" class="headerlink" title="a^a^b = b"></a>a^a^b = b</h2><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1]</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Input: [4,1,2,1,2]</span><br><span class="line">Output: 4</span><br></pre></td></tr></table></figure><p>这个题目上来寻找单独的数字, 我直接就sort然后遍历一次, 找到单个的数字.<br>我以为这样就很快了, 结果看了下排名. 啪啪啪的打脸</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">sort(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; i = i + <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] != nums[i + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然打败了40%的人, 就去看看更快的解法把. 首先我看到了就是这个<br>我只想说…. 位运算6666, 没想到异或可以这样用<br><code>a^0 = a</code>  <code>a^a = 0</code> <code>a^a^b = b</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">&#123;</span><br><span class="line">ret ^= n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有哈希表做法, 应该是利用的哈希表快速索引, 我也是才知道map范围for循环是pair不是iter auto不能用太多</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n : nums)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>[n]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; n : <span class="built_in">map</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n.second == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> n.first;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="链表环判断双指针赛跑-单一体现key-set"><a href="#链表环判断双指针赛跑-单一体现key-set" class="headerlink" title="链表环判断双指针赛跑 单一体现key-set"></a>链表环判断双指针赛跑 单一体现key-set</h2><p><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle/</a><br><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode.com/problems/linked-list-cycle-ii/</a></p><p>大意就是判断一个链表是否有环, 因为之前在那本小灰上看到过. 脑子中首先想的两个指针赛跑.</p><p>快的指针一次走两步, 慢的一次走一步. 快的终将会追上慢的, 如果碰到了nullptr就返回false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode *walk = head;</span><br><span class="line">        ListNode *<span class="built_in">run</span> = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">run</span>-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            walk = walk-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">run</span>-&gt;next-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">run</span> = <span class="built_in">run</span>-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (walk == <span class="built_in">run</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改了一下, 感觉下面的代码要好一些?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="keyword">if</span> ((head == <span class="literal">nullptr</span>) || (head-&gt;next == <span class="literal">nullptr</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *walk = head;</span><br><span class="line">ListNode *<span class="built_in">run</span> = head-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (walk != <span class="built_in">run</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">run</span> == <span class="literal">nullptr</span>) || (<span class="built_in">run</span>-&gt;next == <span class="literal">nullptr</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">walk = walk-&gt;next;</span><br><span class="line"><span class="built_in">run</span> = <span class="built_in">run</span>-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是要保证访问过的单一, 就是用set了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">set</span>&lt;ListNode*&gt; hashset&#123;&#125;;</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hashset.count(head) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">hashset.insert(head);</span><br><span class="line"></span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表反转-while-node-nullptr"><a href="#链表反转-while-node-nullptr" class="headerlink" title="链表反转 while (node != nullptr)"></a>链表反转 while (node != nullptr)</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-linked-list/submissions/</a></p><p>原版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">ListNode *lp = <span class="literal">nullptr</span>;</span><br><span class="line">ListNode *rp = head;</span><br><span class="line">ListNode *temp = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (rp-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = rp-&gt;next;</span><br><span class="line">rp-&gt;next = lp;</span><br><span class="line">lp = rp;</span><br><span class="line">rp = temp;</span><br><span class="line">&#125;</span><br><span class="line">rp-&gt;next = lp;</span><br><span class="line"><span class="keyword">return</span> rp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode *lp = <span class="literal">nullptr</span>;</span><br><span class="line">ListNode *rp = head;</span><br><span class="line">ListNode *temp = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (rp != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = rp-&gt;next;</span><br><span class="line">rp-&gt;next = lp;</span><br><span class="line">lp = rp;</span><br><span class="line">rp = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> lp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><h2 id="括号匹配-哈希表用作条件匹配"><a href="#括号匹配-哈希表用作条件匹配" class="headerlink" title="括号匹配 哈希表用作条件匹配"></a>括号匹配 哈希表用作条件匹配</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">(<span class="keyword">char</span> ca, <span class="keyword">char</span> cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ca == <span class="string">'('</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cb == <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ca == <span class="string">'['</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cb == <span class="string">']'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ca == <span class="string">'&#123;'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> cb == <span class="string">'&#125;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; brackets;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> temp = <span class="string">'\0'</span>;</span><br><span class="line"><span class="comment">// 在空容器上调用 back 导致未定义行为。</span></span><br><span class="line"><span class="keyword">if</span> (brackets.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = brackets.top();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (valid(temp, s[i]))</span><br><span class="line">&#123;</span><br><span class="line">brackets.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">brackets.push(s[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> brackets.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是我第一次提交的方法, 然而可以使用哈希表. 使代码看起来更简单些<br>下面使用哈希表扩展性更加好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; bracket_map&#123;&#123;<span class="string">'('</span>, <span class="number">1</span>&#125;, &#123;<span class="string">'['</span>, <span class="number">2</span>&#125;, &#123;<span class="string">'&#123;'</span>, <span class="number">3</span>&#125;, </span><br><span class="line">&#123;<span class="string">')'</span>, <span class="number">4</span>&#125;, &#123;<span class="string">']'</span>, <span class="number">5</span>&#125;, &#123;<span class="string">'&#125;'</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; brackets;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> flag = bracket_map[s[i]];</span><br><span class="line"><span class="keyword">if</span> (flag &lt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">brackets.push(flag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!brackets.empty() &amp;&amp; (flag - <span class="number">3</span>) == brackets.top())</span><br><span class="line">&#123;</span><br><span class="line">brackets.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">brackets.push(flag);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> brackets.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了压缩长度. 所有空行都删掉了&lt;/p&gt;
&lt;h1 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h1&gt;&lt;h2 id=&quot;哈希表建立快速索引-一遍和两遍哈希的使用&quot;&gt;&lt;a href=&quot;#哈希表建立
      
    
    </summary>
    
    
      <category term="算法" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法刷题记录" scheme="http://blog.lsmg.xyz/categories/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
</feed>
