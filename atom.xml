<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lsmg的大学之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lsmg.xyz/"/>
  <updated>2020-02-26T15:16:11.934Z</updated>
  <id>http://blog.lsmg.xyz/</id>
  
  <author>
    <name>Lsmg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Effective读书记录</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-Effective%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-Effective%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/</id>
    <published>2020-02-26T13:43:46.000Z</published>
    <updated>2020-02-26T15:16:11.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款02-尽量用const-enum-inline-替换-define"><a href="#条款02-尽量用const-enum-inline-替换-define" class="headerlink" title="条款02 尽量用const, enum, inline 替换#define"></a>条款02 尽量用const, enum, inline 替换#define</h2><p>前言 我目前自己做的框架中大量用了#define…. 因为用enum涉及到转换才能到int. 来学习下这条</p><p><strong>使用 const 常量来替换 #define</strong><br>谨防机号表出错, 特殊情况下 还能减少字量</p><p>#define无法限定作用域, 这点我已经感受到了</p><p>定义C风格常量字符串<br>const char* const NAME = “lsmg”; 防止指向和指向内容改变<br>定义C++风格常量字符串<br>const std::string NAME = “lsmg”;</p><p>class专属常量, 使用如下方式. 可以限定作用域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_ROOM = <span class="number">10000</span>; <span class="comment">// 常量声明式 - 常量且只有一份</span></span><br><span class="line">Gameroom* rooms[MAX_ROOM];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要获取class专属常量的地址, 或者需要定义式. 则需要在<code>实现文件</code>而非<code>头文件</code>, 如下声明<br><code>const int Game::MAX_ROOM</code> - 未给定初值<br>由于class常量已经在声明时获得初值, 所以不用在给定初值</p><p>这里我发现一件事情, 这本书 不能只读一遍, 最少两边完整的<br>前面就已经开始使用后面的条款了, 先着重本条款, 跨条款的等第二遍</p><h2 id="条款03-尽可能使用const"><a href="#条款03-尽可能使用const" class="headerlink" title="条款03 尽可能使用const"></a>条款03 尽可能使用const</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = greeting;</span><br><span class="line"><span class="comment">// const 在 * 左边 被指物是常量 在右边自己是常量 两边都是常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = greeting; <span class="comment">// 指针指向可以变, 指向的值不能变</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">// 指针指向不可以变, 指向的值可以变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">// 都不可以变</span></span><br></pre></td></tr></table></figure><p><strong>const 参数, 可你帮你检查 == 被写成=的情况</strong><br>这本书看来挺有意思的2333333</p><p><strong>const 函数, 这里看不太懂 没有原来如此的感觉</strong></p><h2 id="条款04-确定对象使用前已经被初始化"><a href="#条款04-确定对象使用前已经被初始化" class="headerlink" title="条款04 确定对象使用前已经被初始化"></a>条款04 确定对象使用前已经被初始化</h2><p>永远在使用对象前, 进行初始化.<br>在构造函数中, 对所有值进行初始化<br>构造函数使用<code>成员初始列</code>进行<code>初始化操作</code>而非<code>赋值操作</code><br><strong>减少default构造函数不必要的调用</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Class A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; &amp;room_list);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; room_list_;</span><br><span class="line"><span class="keyword">int</span> roomnum_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class="line">&#123;</span><br><span class="line">name_ = name; <span class="comment">// 这些都是赋值 不是初始化</span></span><br><span class="line">room_list_ = room_list;</span><br><span class="line">roomnum_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C++规定 对象的 成员变量  初始化动作  发生在  进入构造函数本体  之前</span></span><br><span class="line"><span class="comment">// name_  room_list_  两个在构造函数中被赋值, 而初始化在进入构造函数之前</span></span><br><span class="line"><span class="comment">// ---发生在这些成员的default构造函数被调用的时候, (发生在进入构造函数前)</span></span><br><span class="line"><span class="comment">// ---roomnum_例外 int属于内置类型</span></span><br></pre></td></tr></table></figure><p>上面的初始化方式, 浪费了default的构造函数 所以推荐使用下面的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A::A(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class="line">:name_(name), room_list_(room_list), roomnum_(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然最终结果相同, 但没有浪费default构造函数. 前两个调用的copy构造函数.</p><p><strong>还可以使用成员初值列 来default构造一个成员变量.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A::A()</span><br><span class="line">:name_(), room_list_(), roomnum_(<span class="number">0</span>)</span><br><span class="line">&#123; <span class="comment">// 前两个全部调用的default构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const reference 内置类型(初始化与赋值等成本) 一定成员初始值列</strong></p><p><strong>初始值列总是使用 声明次序进行初始化, 而非写的顺序, 所以最好按声明次序列出</strong></p><h1 id="构造析构赋值运算"><a href="#构造析构赋值运算" class="headerlink" title="构造析构赋值运算"></a>构造析构赋值运算</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;让自己习惯C&quot;&gt;&lt;a href=&quot;#让自己习惯C&quot; class=&quot;headerlink&quot; title=&quot;让自己习惯C++&quot;&gt;&lt;/a&gt;让自己习惯C++&lt;/h1&gt;&lt;h2 id=&quot;条款02-尽量用const-enum-inline-替换-define&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器编程读书记录-高级部分</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E9%83%A8%E5%88%86/</id>
    <published>2020-02-25T14:34:39.000Z</published>
    <updated>2020-02-25T14:36:47.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十三章多进程编程"><a href="#第十三章多进程编程" class="headerlink" title="第十三章多进程编程"></a>第十三章多进程编程</h1><h2 id="exec系列系统调用"><a href="#exec系列系统调用" class="headerlink" title="exec系列系统调用"></a>exec系列系统调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 声明这个是外部函数或外部变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>** environ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻</span></span><br><span class="line"><span class="comment">// arg 和 argv用于向新的程序传递参数</span></span><br><span class="line"><span class="comment">// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量</span></span><br><span class="line"><span class="comment">// exec函数是不返回的, 除非出错</span></span><br><span class="line"><span class="comment">// 如果未报错则源程序被新的程序完全替换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* arg, ....)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">const</span> <span class="keyword">char</span>* arg, ..<span class="number">.0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> <span class="keyword">char</span>* arg, ...., <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">char</span>* <span class="keyword">const</span> argv[], <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><h2 id="fork系统调用-进程的创建"><a href="#fork系统调用-进程的创建" class="headerlink" title="fork系统调用-进程的创建"></a>fork系统调用-进程的创建</h2><p><strong>fork系统调用api</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0</span></span><br><span class="line"><span class="comment">// 次返回值用于区分是父进程还是子进程</span></span><br><span class="line"><span class="comment">// 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(viod)</span></span>;</span><br></pre></td></tr></table></figure><p>fork系统调用<br>fork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项, 新的进程表项有很多的属性和原进程相同<br><code>堆指针</code> <code>栈指针</code> <code>标志寄存器的值</code>.<br>也存在不同的项目 该进程的PPID(父进程)被设置成原进程的PID,  信号位图被清除(原进程设置的信号处理函数对新进程无效)</p><p>子进程代码与父进程完全相同, 同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)了父进程的数据(堆数据, 栈数据, 静态数据)<br>创建子进程后, 父进程打开的文件描述符默认在子进程中也是打开的<br><code>文件描述符的引用计数</code>, <code>父进程的用户根目录, 当前工作目录等变量的引用计数</code> 均加1<br>(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)</p><h2 id="处理僵尸进程-进程的管理"><a href="#处理僵尸进程-进程的管理" class="headerlink" title="处理僵尸进程-进程的管理"></a>处理僵尸进程-进程的管理</h2><p><strong>处理僵尸进程API</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>* stat_loc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)</span></span><br><span class="line"><span class="comment">// options函数取值WNOHANG-waitpid立即返回</span></span><br><span class="line"><span class="comment">// 如果目标子进程正常退出, 则返回子进程的pid</span></span><br><span class="line"><span class="comment">// 如果还没有结束或意外终止, 则立即返回0</span></span><br><span class="line"><span class="comment">// 调用失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* stat_loc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line">WIFEXITED(stat_val); <span class="comment">// 子进程正常结束, 返回一个非0</span></span><br><span class="line">WEXITSTATUS(stat_val); <span class="comment">// 如果WIFEXITED 非0, 它返回子进程的退出码</span></span><br><span class="line">WIFSIGNALED(stat_val);<span class="comment">// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值</span></span><br><span class="line">WTERMSIG(stat_val);<span class="comment">// 如果WIFSIGNALED非0 返回一个信号值</span></span><br><span class="line">WIFSTOPPED(stat_val);<span class="comment">// 如果子进程意外终止, 它返回一个非0值</span></span><br><span class="line">WSTOPSIG(stat_val);<span class="comment">// 如果WIFSTOPED非0, 它返回一个信号值</span></span><br></pre></td></tr></table></figure><p>对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询</p><ul><li>在<code>子进程结束运行之后, 父进程读取其退出状态前</code>, 我们称该子进程处于<code>僵尸态</code></li><li>另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) <code>父进程结束运行之后, 子进程退出之前</code>, 处于<code>僵尸态</code></li></ul><p>以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.</p><p>waitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.<br>SIGCHLD信号- 子进程结束后将会给父进程发送此信号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_child</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> stat;</span><br><span class="line"><span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 善后处理emmmm</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>管道</strong><br>管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证<br>父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].</p><p>可以用两个管道来实现双向传输数据, 也可以用<code>socketpair</code>来创建管道</p><h2 id="信号量-进程的锁"><a href="#信号量-进程的锁" class="headerlink" title="信号量-进程的锁"></a>信号量-进程的锁</h2><p><em>信号量原语</em><br>只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.<br>假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为</p><ul><li>P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行</li><li>V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png" alt=""></li></ul><p>创建信号量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semeget 系统调用</span></span><br><span class="line"><span class="comment">// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集</span></span><br><span class="line"><span class="comment">// key 参数是一个键值, 用来标识一个全局唯一的信号量级, 就像文件名全局唯一地标识一个文件一样.</span></span><br><span class="line"><span class="comment">// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0</span></span><br><span class="line"><span class="comment">// sem_flags指定一组标志, 与调用open函数的mode参数相同</span></span><br><span class="line"><span class="comment">// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错</span></span><br><span class="line"><span class="comment">// - 联合使用IPC_CREAT和IPC_EXCL来创建一组新的唯一额信号量集</span></span><br><span class="line"><span class="comment">// - 如果已经存在则会返回错误 errno = EEXIST</span></span><br><span class="line"><span class="comment">// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">int</span> num_sems, <span class="keyword">int</span> sem_flags)</span></span>;</span><br></pre></td></tr></table></figure><p>semget成功时返回一个与之关联的内核结构体semid_ds</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> sem_nsems; <span class="comment">// 被设置为num_sems</span></span><br><span class="line"><span class="keyword">time_t</span> sem_otime; <span class="comment">// 被设置为0</span></span><br><span class="line"><span class="keyword">time_t</span> sem_ctime; <span class="comment">// 被设置为当前的系统时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用来描述权限</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">uid_t</span> uid; <span class="comment">// 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="keyword">gid_t</span> gid; <span class="comment">// 所有者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="keyword">uid_t</span> cuid; <span class="comment">// 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="keyword">gid_t</span> cgid; <span class="comment">// 创建者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="keyword">mode_t</span> mode;<span class="comment">// 访问权限, 背着只为sem_flags参数的最低9位.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>与semop信号量关联的一些重要的内核变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> short semval; <span class="comment">// 信号量的值</span></span><br><span class="line"><span class="keyword">unsigned</span> short semzcnt; <span class="comment">// 等待信号量值变为0的进程数量</span></span><br><span class="line"><span class="keyword">unsigned</span> short semncnt<span class="comment">// 等待信号量值增加的进程数量</span></span><br><span class="line"><span class="keyword">pid_t</span> sempid; <span class="comment">// 最后一次执行semop操作的进程ID</span></span><br></pre></td></tr></table></figure><p>操作信号量, 实际上就是对上面的内核变量操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> short <span class="keyword">int</span> sem_num;<span class="comment">// 信号量集中信号量的编号, 0表示信号量集中的第一个信号量</span></span><br><span class="line">short <span class="keyword">int</span> sem_op; <span class="comment">// 指定操作类型,</span></span><br><span class="line">short <span class="keyword">int</span> sem_flg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.</span></span><br><span class="line"><span class="comment">// sem_ops 参数指向一个sembuf结构体类型的数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> sem_id, struct sembuf* sem_ops, <span class="keyword">size_t</span> num_sem_ops)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sem_op 每种类型的操作行为又受到sem_flags成员的影响</span></span><br><span class="line"><span class="comment">// sem_flag 可选值是可选正整数 0 负整数. </span></span><br><span class="line"><span class="comment">// - IPC_NOWAIT(无论信号量操作是否成功, 都立即返回), </span></span><br><span class="line"><span class="comment">// - SEM_UNDO (当进程退出的时候, 取消正在进行的semop操作)</span></span><br><span class="line"><span class="comment">// -- sem_op &gt; 0</span></span><br><span class="line"><span class="comment">// -- 则semop将被操作的信号量的值semval增加sem_op, 要求调用进程对被操作的信号量集有写权限</span></span><br><span class="line"><span class="comment">// -- 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)</span></span><br><span class="line"><span class="comment">// -- sem_op = 0</span></span><br><span class="line"><span class="comment">// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限</span></span><br><span class="line"><span class="comment">// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0</span></span><br><span class="line"><span class="comment">// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN</span></span><br><span class="line"><span class="comment">// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生</span></span><br><span class="line"><span class="comment">// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1</span></span><br><span class="line"><span class="comment">// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM</span></span><br><span class="line"><span class="comment">// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1</span></span><br><span class="line"><span class="comment">// -- sem_op &lt; 0</span></span><br><span class="line"><span class="comment">// -- 表示对信号量的值进行减操作, 即期望获得信号量, 要求调用进程对被操作信号量集有写权限</span></span><br><span class="line"><span class="comment">// -- 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量</span></span><br><span class="line"><span class="comment">// -- 且semval -= abs(sem_op)</span></span><br><span class="line"><span class="comment">// -- 如果此时这定了SEM_UNDO的标志, 系统更新进程的semadj变量</span></span><br><span class="line"><span class="comment">// -- 如果semval &lt; abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN</span></span><br><span class="line"><span class="comment">// -- 如果没有指定则阻塞进程等待信号量可用, 且semzcnt +=1, 等到下面三种情况唤醒</span></span><br><span class="line"><span class="comment">// -- 1 发生semval &gt;= abs(sem_op), semzcnt-=1, semval -= abs(sem_op). 在SEM_UNDO设置时更新semadj</span></span><br><span class="line"><span class="comment">// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)</span></span><br><span class="line"><span class="comment">// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)</span></span><br><span class="line"><span class="comment">// num_sem_ops 指定要执行的操作个数, 即sem_ops数组中的元素个数, semop对sem_ops[] 中的每个成员按顺序操作,</span></span><br><span class="line"><span class="comment">// 并且是原子操作</span></span><br><span class="line"><span class="comment">// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semctl 系统调用</span></span><br><span class="line"><span class="comment">// sem_id 参数是由semget返回的信号量集标识符</span></span><br><span class="line"><span class="comment">// sen_num指定被操作的信号量在信号集中的编号</span></span><br><span class="line"><span class="comment">// command指定命令, 可以追加命令所需的参数, 不过有推荐格式</span></span><br><span class="line"><span class="comment">// 成功返回对应command的参数, 失败返回-1 errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> sem_id, <span class="keyword">int</span> sem_num, <span class="keyword">int</span> command, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>结构体<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/1.png" alt=""></p><p>command参数<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/semctl%E7%9A%84command%E5%8F%82%E6%95%B0.png" alt=""><br>除去GETALL以外的 其他GET都是操作的单个信号量, 由sem_id指定的第sem_num个信号量.<br>其他操作针对整个信号量集, 此时semctl的参数sem_num被忽略</p><p><em>特殊键值IPC_PRIVATE</em><br>semget的调用者可以给其key参数传递一个特殊的键值<code>IPC_PRIVATE</code>, 这样无论该信号量是否已经存在<br>semget都将创建一个新的信号量.</p><p><strong>总结PV使用方法</strong><br>使用<code>semget</code>获取到唯一的标识.<br>使用<code>semctl</code>的<code>SETVAL</code>传入初始化val的<code>sem_un</code>联合体.来初始化val<br>调用<code>semop</code> 传入唯一标识, <code>sem_op=-1</code>执行P(锁)操作<code>sem_op=1</code>执行V(开锁)操作<br>开关锁通过当<code>sem_op=-1,semval=0</code><br>且未指定<code>IPC_NOWAIT</code><br>等待<code>semval</code>被<code>sem_op=1</code>改为<code>semval=1</code></p><h2 id="共享内存-进程间通信"><a href="#共享内存-进程间通信" class="headerlink" title="共享内存-进程间通信"></a>共享内存-进程间通信</h2><p>最高效的IPC(进程间通信)机制<br>需要自己同步进程对其的访问, 否则会产生竞态条件</p><p><code>int shmget(key_t key, size_t size, int shmflg)</code><br>成功返回唯一标识, 失败返回-1 errno<br>key<br>与semget相同 标识一段全局唯一的共享内存<br>size 内存区域大小 单位字节<br>shmflg<br>shmflg的参数与semget相同, 同时多了两个额外的参数<br><code>SHM_HUGETLB</code>系统将使用”大页面”来为共享内存分配空间<br><code>SHM_NORESERVE</code>不为共享内存保留swap空间, 如果物理内存不足在执行写操作的<br>时候将会触发<code>SIGSEGV</code>信号</p><p>同时会创建对应的<code>shmid_ds</code>结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_per</span>;</span> <span class="comment">// 权限相关</span></span><br><span class="line"><span class="keyword">size_t</span> shm_segsz; <span class="comment">// 共享内存大小 单位字节size</span></span><br><span class="line"><span class="keyword">__time_t</span> shm_atime; <span class="comment">// 对这段内存最后一次调用semat的时间 0</span></span><br><span class="line"><span class="keyword">__time_t</span> shm_dtime; <span class="comment">// 对这段内存最后一次调用semdt的时间 0</span></span><br><span class="line"><span class="keyword">__time_t</span> shm_ctime; <span class="comment">// 对这段内存最后一次调用semctl的时间 当前时间</span></span><br><span class="line"><span class="keyword">__pid_t</span> shm_cpid; <span class="comment">// 创建者PID</span></span><br><span class="line"><span class="keyword">__pid_t</span> lpid; <span class="comment">// 最后一次执行shmat或shmdt的进程PID</span></span><br><span class="line"><span class="keyword">shmatt_t</span> shm_nattach <span class="comment">// 关联到此共享内存空间的进程数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void* shmat(int shm_id, const void* shm_addr, int shmflg)</code><br>将共享内存关联到进程的地址空间<br>成功返回关联到的地址, 失败返回 (void<em>)-1 errno<br>shm_id<br>shmget返回的唯一标识<br>shm_addr<br>关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响<br>如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强<br>如果 shm_addr 非空,且没有<code>SHM_RND</code>标志 则关联到指定的地址处<br>如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写</em><br>shmflg<br>SHM_RDONLY 设置后内存内容变成只读<br>SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联<br>SHM_EXEC 有执行权限 = 读权限<br>调用成功之后, 修改shmid_ds的部分<br>shm_nattach +1<br>更新 shm_lpid和shm_atime设置为当前时间</p><p><code>int shmdt(const void* shm_addr)</code><br>将共享内存从进程地址空间中分离<br>成功返回0 失败返回-1 errno<br>成功后<br>shm_nattach -1<br>更新 shm_lpid和shm_dtime设置为当前时间</p><p><code>int shm_ctl(int shm_id, int command, struct shmid_ds* buf)</code><br>,目前还不清楚哪些实用, 所以暂时贴图了<br>成功返回相关值, 失败返回 -1 errno<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/shmctl.png" alt=""></p><h1 id="第十四章-多线程编程"><a href="#第十四章-多线程编程" class="headerlink" title="第十四章 多线程编程"></a>第十四章 多线程编程</h1><p>根据运行环境和调度者身份, 线程可以分为两种<br>内核线程<br>运行在内核空间, 由内核来调度.<br>用户线程<br>运行在用空间, 由线程库来调用</p><p>当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.</p><p>线程有三种实现方式</p><ul><li>完全在用户空间实现-无需内核支持<br>  创建和调度线程无需内核干预, 速度很快.<br>  不占用额外的内核资源, 对系统影响较小<br>  但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的</li><li>完全由内核调度<br>  创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理<br>  优缺点正好与上一个相反</li><li>双层调度<br>  结合了前两个的优点<br>  不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势</li></ul><h2 id="进程的创建和终止"><a href="#进程的创建和终止" class="headerlink" title="进程的创建和终止"></a>进程的创建和终止</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/pthreadtypes.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">pthread_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* attr, <span class="keyword">void</span>* (*start_routine)(<span class="keyword">void</span>*), <span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0 失败返回错误码</span></span><br><span class="line"><span class="comment">// thread 用来唯一的标识一个新线程</span></span><br><span class="line"><span class="comment">// attr用来设置新县城的属性 传递NULL表示默认线程属性</span></span><br><span class="line"><span class="comment">// start_routine 指定新线程运行的函数</span></span><br><span class="line"><span class="comment">// arg指定函数的参数</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span>* retval)</span></span>;</span><br><span class="line">用来保证线程安全干净的退出, 线程函数最好结束时调用.</span><br><span class="line">通过`retval`参数向线程的回收者传递其退出信息</span><br><span class="line">执行后不会返回到调用者, 而且永远不会失败</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span>** retval)</span></span></span><br><span class="line">可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.</span><br><span class="line">成功时返回<span class="number">0</span>, 失败返回错误码</span><br><span class="line">等待其他线程结束</span><br><span class="line">thread 线程标识符</span><br><span class="line">retval 目标线程的退出返回信息</span><br><span class="line"></span><br><span class="line">错误码如下</span><br><span class="line">`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用</span><br><span class="line">`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程</span><br><span class="line">`ESRCH`目标线程不存在</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span></span><br><span class="line">异常终止一个线程, 即为取消线程</span><br><span class="line">成功返回<span class="number">0</span>, 失败返回错误码</span><br><span class="line"></span><br><span class="line">接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.</span><br><span class="line">一下两个函数成功返回<span class="number">0</span> 失败返回错误码</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动线程取消</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcancelstart</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span>* oldstate)</span></span></span><br><span class="line">第一个参数</span><br><span class="line">PTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态</span><br><span class="line">PTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求指导</span><br><span class="line">这个线程允许被取消</span><br><span class="line">第二个参数 返回之前设定的状态</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置线程取消类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span>* oldtype)</span></span></span><br><span class="line">第一个参数</span><br><span class="line">PTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消</span><br><span class="line">PTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 知道调用了下面几个所谓的取消点函数</span><br><span class="line">最好使用`pthread_testcancel`函数设置取消点</span><br><span class="line">设置取消类型(如何取消)</span><br><span class="line">第二个参数</span><br><span class="line">原来的取消类型</span><br></pre></td></tr></table></figure><h2 id="POSIX信号量-进程的同步"><a href="#POSIX信号量-进程的同步" class="headerlink" title="POSIX信号量-进程的同步"></a>POSIX信号量-进程的同步</h2><p>多线程也必须考虑线程同步的问题.<br>虽然<code>pthread_join</code>可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求<br>比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.</p><p>以下函数成功返回0 失败返回-1 errno<br><code>int sem_init(sem_t* sem, int pshared, unsigned int value)</code><br>用于初始化一个未命名的信号量.<br>如果<code>pshared</code>为0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享<br><code>value</code>指定参数的初始值<br><em>初始化已经存在的信号量会导致无法预期的结果</em></p><p><code>int sem_destory(sem_t* sem)</code><br>销毁信号量, 释放其占用的系统资源<br><em>销毁正被其他线程等待的信号量, 将会导致无法预期的结果</em></p><p><code>int sem_wait(sem_t* sem)</code><br>以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞, 知道信号量具有非0值</p><p><code>int sem_trywait(sem_t* sem)</code><br>跟上面的函数相同不过不会阻塞. 信号量不为0 则 -1, 为0 则返回-1 errno</p><p><code>int sem_post(sem_t sem)</code><br>原子操作将信号量的值 +1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十三章多进程编程&quot;&gt;&lt;a href=&quot;#第十三章多进程编程&quot; class=&quot;headerlink&quot; title=&quot;第十三章多进程编程&quot;&gt;&lt;/a&gt;第十三章多进程编程&lt;/h1&gt;&lt;h2 id=&quot;exec系列系统调用&quot;&gt;&lt;a href=&quot;#exec系列系统调用&quot; cla
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>CPP11特性</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-CPP11%E7%89%B9%E6%80%A7/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-CPP11%E7%89%B9%E6%80%A7/</id>
    <published>2020-02-19T09:41:27.000Z</published>
    <updated>2020-02-20T15:21:12.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h1><p>参考资料<br><a href="https://zh.cppreference.com/w/cpp/language/lambda" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/language/lambda</a><br><a href="https://blog.csdn.net/qq_34199383/article/details/80469780" target="_blank" rel="noopener">https://blog.csdn.net/qq_34199383/article/details/80469780</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[ 捕获 ] ( 形参 ) -&gt; ret &#123; 函数体 &#125;</span><br><span class="line">[ 捕获 ] ( 形参 ) &#123; 函数体 &#125;</span><br><span class="line">[ 捕获 ] &#123; 函数体 &#125;</span><br><span class="line"></span><br><span class="line">&amp; 以引用隐式捕获被使用的自动变量</span><br><span class="line">= 以复制隐式捕获被使用的自动变量</span><br><span class="line"></span><br><span class="line">[&amp;]&#123;&#125;;          <span class="comment">// OK：默认以引用捕获</span></span><br><span class="line">[&amp;, i]&#123;&#125;;       <span class="comment">// OK：以引用捕获，但 i 以值捕获</span></span><br><span class="line"></span><br><span class="line">[=]&#123;&#125;;          <span class="comment">// OK：默认以复制捕获</span></span><br><span class="line">[=, &amp;i]&#123;&#125;;      <span class="comment">// OK：以复制捕获，但 i 以引用捕获</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">this</span>]&#123;&#125;; <span class="comment">// 获取this指针, 如果使用了&amp;和=则会默认包括this</span></span><br></pre></td></tr></table></figure><p><strong>使用场景一</strong><br>以sort为代表的函数 需要传入函数的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原版</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xxx(compare);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新版</span></span><br><span class="line">xxx([](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a &gt; b;&#125;);</span><br></pre></td></tr></table></figure><p><strong>使用场景二</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a + b;&#125;;</span><br><span class="line"><span class="keyword">int</span> bar = add(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h1 id="类型特性"><a href="#类型特性" class="headerlink" title="类型特性"></a>类型特性</h1><p><a href="https://zh.cppreference.com/w/cpp/types#.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/types#.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29</a></p><p>神仙的头文件<type_traits> 可以判断一个值是否是某个类型</p><p>比如判断一个值<br>是不是 整形<br>是不是 void<br>是不是 数组 等等</p><p>目前不知道用在什么地方合适….. 留个连接备用吧</p><h1 id="花括号初始"><a href="#花括号初始" class="headerlink" title="花括号初始"></a>花括号初始</h1><h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><h2 id="std-function-functional"><a href="#std-function-functional" class="headerlink" title="std::function  functional"></a>std::function  functional</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintB</span><span class="params">(<span class="keyword">int</span> bar)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; FPrintA = PrintA;</span><br><span class="line">    FPrintA();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; FPrintB = PrintB;</span><br><span class="line">    FPrintB(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 感觉配合Lambad 挺不错, 在一个函数中经常使用的功能可以这样定义</span></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; FLambad = []()&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Lambad"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    FLambad();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不过使用auto貌似更简单</span></span><br><span class="line"><span class="keyword">auto</span> ALambad = []()&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Lambad"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;;</span><br><span class="line">    ALambad();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ A</span><br><span class="line">$ B</span><br><span class="line">$ Lambad</span><br></pre></td></tr></table></figure><h2 id="std-pair-utility-std-tuple-tuple"><a href="#std-pair-utility-std-tuple-tuple" class="headerlink" title="std::pair utility std::tuple tuple"></a>std::pair utility std::tuple tuple</h2><p><a href="https://zh.cppreference.com/w/cpp/utility/tuple" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/utility/tuple</a></p><p>pair是 结构体模板, 可在一个单元中存储两个相异对象. pair是tuple拥有两个元素的特殊情况</p><p>tuple是固定大小的异类值(啥是异类值??)汇集</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;int, double &gt; GetInfoById(int id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1</span>, <span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">2</span>, <span class="number">2.2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::invalid_argument(<span class="string">"id"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> info = GetInfoById(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取指定位置</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(info)</span><br><span class="line">            &lt;&lt; <span class="string">" 2:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(info) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val1;</span><br><span class="line">    <span class="keyword">double</span> val2;</span><br><span class="line"><span class="comment">// 直接创建引用的tuple</span></span><br><span class="line">    <span class="built_in">std</span>::tie(val1, val2) = GetInfoById(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"1:"</span> &lt;&lt; val1</span><br><span class="line">              &lt;&lt; <span class="string">" 2:"</span> &lt;&lt; val2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">$ <span class="number">1</span>:<span class="number">1</span> <span class="number">2</span>:<span class="number">1.1</span></span><br><span class="line">$ <span class="number">1</span>:<span class="number">2</span> <span class="number">2</span>:<span class="number">2.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lambda&quot;&gt;&lt;a href=&quot;#Lambda&quot; class=&quot;headerlink&quot; title=&quot;Lambda&quot;&gt;&lt;/a&gt;Lambda&lt;/h1&gt;&lt;p&gt;参考资料&lt;br&gt;&lt;a href=&quot;https://zh.cppreference.com/w/cpp/lan
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>Libevent代码初期了解</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-Libevent%E4%BB%A3%E7%A0%81%E5%88%9D%E6%9C%9F%E4%BA%86%E8%A7%A3/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-Libevent%E4%BB%A3%E7%A0%81%E5%88%9D%E6%9C%9F%E4%BA%86%E8%A7%A3/</id>
    <published>2020-02-19T06:56:55.000Z</published>
    <updated>2020-02-20T09:19:33.541Z</updated>
    
    <content type="html"><![CDATA[<p>学习来源<br>&lt;Linux 高性能服务器编程&gt;</p><h1 id="I-O框架库概述"><a href="#I-O框架库概述" class="headerlink" title="I/O框架库概述"></a>I/O框架库概述</h1><h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-1IO%E6%A1%86%E6%9E%B6%E7%BB%84%E7%BB%84%E4%BB%B6.png" alt=""><br>句柄(Handler)<br>由于统一了事件源, 一个事件一般跟一个句柄绑定在一起, 事件就绪之后 会通过句柄通知这一个事件.<br>在Linux中 I/O 事件对应的句柄-&gt;文件描述符, 信号事件-&gt;信号值</p><p>事件多路分发器(EventDemultiplexer)<br>事件的到来是随机的, 异步的. 所以只能通过一个循环一直等待事件并进行处理 — 事件循环<br>一般通过IO复用实现 select poll epoll_wait</p><p>事件处理器(EventHandle)<br>具体事件处理器(ConcreteEventHandler)<br>事件处理器执行事件对应的业务逻辑, 通常包含一个或多个handler_event回调函数, 这些回调函数在事件循环中被执行</p><p>Reactor<br>handler_events: 执行事件循环 重复等待事件, 然后依次调用对应的事件处理器<br>register_handler: 向事件多路分发器中注册事件<br>remove_handler: 从中删除一个事件</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-2%20IO%E6%A1%86%E6%9E%B6%E5%BA%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt=""></p><h2 id="Libevent源码分析"><a href="#Libevent源码分析" class="headerlink" title="Libevent源码分析"></a>Libevent源码分析</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;event.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_cb</span><span class="params">(<span class="keyword">int</span> fd, short event, <span class="keyword">void</span>* argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    event_base* base = (event_base*)argc;</span><br><span class="line">    timeval <span class="built_in">delay</span> = &#123;<span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Caught an interrupt signal\n"</span>);</span><br><span class="line">    event_base_loopexit(base, &amp;<span class="built_in">delay</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeout_cb</span><span class="params">(<span class="keyword">int</span> fd, short event, <span class="keyword">void</span>* argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"timeout\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 相当于创建一个Reactor实例</span></span><br><span class="line">    event_base* base = event_init();</span><br><span class="line">    </span><br><span class="line">    event* signal_event = evsignal_new(base, SIGINT, signal_cb, base);</span><br><span class="line">    event_add(signal_event, <span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    event* timeout_event = evtimer_new(base, timeout_cb, <span class="literal">nullptr</span>);</span><br><span class="line">    timeval tv&#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    event_add(timeout_event, &amp;tv);</span><br><span class="line">    </span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line">    event_free(signal_event);</span><br><span class="line">    event_free(timeout_event);</span><br><span class="line">    event_base_free(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个事件处理器 然后为绑定上相应的回调函数.<br>然后把这个事件处理器注册到事件队列中中,</p><p>然后事件多路分发器依靠循环一直等待事件的到来, 事件到来后通知相应的事件处理器<br>Reactor则管理这些</p><p>首先要去了解下 <code>事件处理器</code> 对应的就是event这个结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_callback</span> <span class="title">ev_evcallback</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件处理器从属的 event_base</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">ev_base</span>;</span></span><br><span class="line"><span class="comment">// 信号值 或者 文件描述符</span></span><br><span class="line"><span class="keyword">evutil_socket_t</span> ev_fd;</span><br><span class="line"><span class="comment">// 定时器的超时时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ev_timeout</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅用于定时事件</span></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="comment">// 队列--指出在通用定时器中的位置</span></span><br><span class="line">TAILQ_ENTRY(event) ev_next_with_common_timeout;</span><br><span class="line"><span class="comment">// 时间堆--指出了在时间堆中的位置</span></span><br><span class="line"><span class="keyword">int</span> min_heap_idx;</span><br><span class="line">&#125; ev_timeout_pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">// 通过这个成员 将具有相同文件描述符的IO事件处理器串联起来</span></span><br><span class="line">LIST_ENTRY (event) ev_io_next;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ev_timeout</span>;</span></span><br><span class="line">&#125; ev_io;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">// 相同信号的串联起来</span></span><br><span class="line">LIST_ENTRY (event) ev_signal_next;</span><br><span class="line">short ev_ncalls;</span><br><span class="line"><span class="comment">/* Allows deletes in callback */</span></span><br><span class="line">short *ev_pncalls;</span><br><span class="line">&#125; ev_signal;</span><br><span class="line">&#125; ev_;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件类型, 可以通过位处理设置非互斥事件</span></span><br><span class="line">short ev_events;</span><br><span class="line"><span class="comment">// 当前激活事件的类型, 说明被激活的原因</span></span><br><span class="line">short ev_res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到其中有很多的属性, 三种事件对应的不同的属性.</p><p>这些属性的填充函数<br><code>evsignal_new``evtimer_new</code>是宏 统一调用<code>event_new</code><br><code>event_new</code>调用<code>event_assign</code>来进行主要的填充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;@通过宏封装注册函数</span><br><span class="line"></span><br><span class="line">一个事件生成函数 经过宏的封装(可以自动填充某些此事件用不到的参数)可以更方便的对应不同事件的生成, 既统一了注册, 又方便用户调用</span><br></pre></td></tr></table></figure><p>属性之一便是回调函数, 事件回调函数有自己的规定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;@统一事件回调函数</span><br><span class="line"></span><br><span class="line">void (*callback)(evutil_socket_t, short, void *)</span><br><span class="line">这样能够统一回调函数的格式, 同时方便管理</span><br></pre></td></tr></table></figure><p>事件处理器创建完毕, 该把事件处理器添加到事件注册队列. 样例代码中通过的<code>event_add</code>函数来实现将事件处理器添加到事件注册队列<br><code>event_add</code>实际由<code>event_add_nolock_</code>实现 所以接下来是<code>event_add_nolock_</code>函数的说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;@事件处理器的分发实现</span><br><span class="line">将传入的event按照不同类型的事件处理器 分别处理</span><br><span class="line">(因为event_new已经填充了ev_events说明事件类型)</span><br><span class="line"></span><br><span class="line">IO事件 添加绑定</span><br><span class="line">信号事件 绑定相应的信号</span><br><span class="line">定时器 放入相关的的时间管理数据结构中</span><br></pre></td></tr></table></figure><p>使用<code>event_queue_insert_inserted</code>进行注册<br>这里的代码2.1.11 与书上的差别较大, 少了多一半的功能, 也没有被抽成函数, 暂不知道对应的功能代码去了哪里<br>照书上来说<code>event_queue_insert_inserted</code>实现的是将事件处理器加入到<code>event_base</code>的某个事件队列中. 对于新添加的IO和信号事件处理器, 还需要让事件多路分发器来监听对应的事件, 然后建立相应的映射关系. 分别使用<code>evmap_io_add_</code>和<code>evmap_signal_add_</code>(相当于图中的<code>register_event</code>)建立映射. </p><p><code>evmap_io_add_</code>中有一个结构体<code>event_io_map</code><br><code>event_io_map</code>会根据不同的平台最终对应不同的数据结构</p><p><code>evmap_io_add_</code>函数<br>函数中用到的东西, 我目前吸收不了……. 总之是为将IO事件处理器加入到<code>event_base</code>的事件队列中实现的</p><p><code>eventop</code>结构体 是<code>event_base</code>中封装IO复用机制的结构体, 提供了统一的接口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为给定的event_base声明后端的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> &#123;</span></span><br><span class="line"><span class="comment">// 后端IO复用技术的名称</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 函数需要初始化所有要用的属性</span></span><br><span class="line"><span class="comment">// 返回的指针会被event_init存储在event_base.evbase</span></span><br><span class="line"><span class="comment">// 失败后返回NULL</span></span><br><span class="line"><span class="keyword">void</span> *(*init)(struct event_base *);</span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line"><span class="keyword">int</span> (*add)(struct event_base *, <span class="keyword">evutil_socket_t</span> fd, short old, short events, <span class="keyword">void</span> *fdinfo);</span><br><span class="line"><span class="comment">// 删除事件</span></span><br><span class="line"><span class="keyword">int</span> (*del)(struct event_base *, <span class="keyword">evutil_socket_t</span> fd, short old, short events, <span class="keyword">void</span> *fdinfo);</span><br><span class="line"><span class="comment">// 等待事件</span></span><br><span class="line"><span class="keyword">int</span> (*dispatch)(struct event_base *, struct timeval *);</span><br><span class="line"><span class="comment">// 释放IO复用机制使用的资源</span></span><br><span class="line"><span class="keyword">void</span> (*dealloc)(struct event_base *);</span><br><span class="line"><span class="comment">// 标记fork后是否需要重新初始化event_base的标志位</span></span><br><span class="line"><span class="keyword">int</span> need_reinit;</span><br><span class="line"><span class="comment">// 用于设定io复用技术支持的一些特性</span></span><br><span class="line"><span class="keyword">enum</span> event_method_feature features;</span><br><span class="line"><span class="comment">// 额外内存的分配</span></span><br><span class="line"><span class="keyword">size_t</span> fdinfo_len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>event_base</code>是Libevent的Reactor. 超长结构体 删除了我不理解的部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> &#123;</span></span><br><span class="line"><span class="comment">// 记录选择的I/O复用机制</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsel</span>;</span></span><br><span class="line"><span class="comment">// 指向IO复用机制真正存储的数据</span></span><br><span class="line"><span class="keyword">void</span> *evbase;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件变换队列 如果一个文件描述符上注册的事件被多次修改, 则可以使用缓冲避免重复的系统调用</span></span><br><span class="line"><span class="comment">// 比如epoll_ctl, 仅能用于时间复杂度O(1)的IO复用技术</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_changelist</span> <span class="title">changelist</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号的后端处理机制</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">eventop</span> *<span class="title">evsigsel</span>;</span></span><br><span class="line"><span class="comment">// 信号事件处理器使用的数据结构, 其中封装了socketpair创建的管道. 用于信号处理函数和</span></span><br><span class="line"><span class="comment">// 事件多路分发器之间的通信, 统一事件源的思路</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evsig_info</span> <span class="title">sig</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到event_base的虚拟(所有, 激活)事件数量, 虚拟(所有, 激活)事件最大数量</span></span><br><span class="line"><span class="keyword">int</span> virtual_event_count;</span><br><span class="line"><span class="keyword">int</span> virtual_event_count_max;</span><br><span class="line"><span class="keyword">int</span> event_count;</span><br><span class="line"><span class="keyword">int</span> event_count_max;</span><br><span class="line"><span class="keyword">int</span> event_count_active;</span><br><span class="line"><span class="keyword">int</span> event_count_active_max;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理完事件后 是否退出循环</span></span><br><span class="line"><span class="keyword">int</span> event_gotterm;</span><br><span class="line"><span class="comment">// 是否立即终止循环</span></span><br><span class="line"><span class="keyword">int</span> event_break;</span><br><span class="line"><span class="comment">// 是否启动一个新的事件循环</span></span><br><span class="line"><span class="keyword">int</span> event_continue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前正在处理的活动事件队列的优先级</span></span><br><span class="line"><span class="keyword">int</span> event_running_priority;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记事件循环是否已经启动, 防止重入</span></span><br><span class="line"><span class="keyword">int</span> running_loop;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 活动事件队列数组. 索引值越小的队列优先级越高. 高优先级的活动事件队列中的事件处理器被优先处理</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evcallback_list</span> *<span class="title">activequeues</span>;</span></span><br><span class="line"><span class="comment">// 活动事件队列数组的大小 说明有nactivequeues个不同优先级的活动事件队列</span></span><br><span class="line"><span class="keyword">int</span> nactivequeues;</span><br><span class="line"><span class="comment">/** A list of event_callbacks that should become active the next time</span></span><br><span class="line"><span class="comment"> * we process events, but not this time. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evcallback_list</span> <span class="title">active_later_queue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 共同超时逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理通用定时器队列 实体数量 总数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">common_timeout_list</span> **<span class="title">common_timeout_queues</span>;</span></span><br><span class="line"><span class="keyword">int</span> n_common_timeouts;</span><br><span class="line"><span class="keyword">int</span> n_common_timeouts_allocated;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件描述符和IO事件之间的映射关系表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_io_map</span> <span class="title">io</span>;</span></span><br><span class="line"><span class="comment">// 信号值和信号事件之间的映射关系表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_signal_map</span> <span class="title">sigmap</span>;</span></span><br><span class="line"><span class="comment">// 时间堆</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">min_heap</span> <span class="title">timeheap</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理系统时间的成员</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv_cache</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evutil_monotonic_timer</span> <span class="title">monotonic_timer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv_clock_diff</span>;</span></span><br><span class="line"><span class="keyword">time_t</span> last_updated_clock_diff;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EVENT__DISABLE_THREAD_SUPPORT</span></span><br><span class="line"><span class="comment">// 多线程支持</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前运行该event_base的事件循环的线程</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> th_owner_id;</span><br><span class="line"><span class="comment">// 独占锁</span></span><br><span class="line"><span class="keyword">void</span> *th_base_lock;</span><br><span class="line"><span class="comment">// 当前事件循环正在执行哪个事件处理器的回调函数</span></span><br><span class="line"><span class="keyword">void</span> *current_event_cond;</span><br><span class="line"><span class="comment">// 等待的线程数</span></span><br><span class="line"><span class="keyword">int</span> current_event_waiters;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// 正在处理的事件处理器的回调函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_callback</span> *<span class="title">current_event</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>事件循环, libevent的动力, 即事件循环</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习来源&lt;br&gt;&amp;lt;Linux 高性能服务器编程&amp;gt;&lt;/p&gt;
&lt;h1 id=&quot;I-O框架库概述&quot;&gt;&lt;a href=&quot;#I-O框架库概述&quot; class=&quot;headerlink&quot; title=&quot;I/O框架库概述&quot;&gt;&lt;/a&gt;I/O框架库概述&lt;/h1&gt;&lt;h2 id=&quot;Rea
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="框架学习" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>联机打砖块</title>
    <link href="http://blog.lsmg.xyz/2020/02/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E8%81%94%E6%9C%BA%E6%89%93%E7%A0%96%E5%9D%97/"/>
    <id>http://blog.lsmg.xyz/2020/02/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E8%81%94%E6%9C%BA%E6%89%93%E7%A0%96%E5%9D%97/</id>
    <published>2020-02-17T14:49:56.000Z</published>
    <updated>2020-02-19T14:35:22.496Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客写的有点晚了, 自己的打砖块 已经写了一个段落了. 不过问题不大.</p><p>重要的部分还在后面, 目前还没写到</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为自己发现需要多做一些项目, 然后逐渐的丰富这些项目 来学习. 希望不断地提升自己, 让自己离鹅厂越来越近. 同时写博客能够让我了解得更深刻</p><p>在看到知乎<code>日撸代码100行</code>的一篇推荐博客</p><p><a href="https://zhuanlan.zhihu.com/p/92422059" target="_blank" rel="noopener">UE4的C++教程汇总 - 日撸代码100行的文章 - 知乎</a><br>找到了那个油管的游戏制作.</p><p><a href="https://www.youtube.com/playlist?list=PLZhNP5qJ2IA0KK3ddSl2JWEL8jOcGe6xY" target="_blank" rel="noopener">这个连接-Unreal Engine 4 Tutorials</a><br>选择了一个游戏-打砖块</p><p>那个小游戏还是很简单的 也学到了不少的东西. 不过我想了想 我既然是做游戏服务器, 我为什么不把打砖块修改成联机版打砖块??   不对!!!!我想把那个博主发布的我喜欢的游戏都改成联机版. 然后慢慢丰富游戏前端和后端的功能, 想到这里 我晚上失眠了…. 越想越兴奋.</p><p>自己的话 注意下代码复用. 尤其是后端的代码. 每次把经常用的代码块抽出来 然后总结出一个自己的框架?库?</p><h1 id="联机的实现"><a href="#联机的实现" class="headerlink" title="联机的实现"></a>联机的实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.h</span></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SendMessage</span><span class="params">(FString Msg)</span></span>;</span><br><span class="line"></span><br><span class="line">UFUNCTION(BlueprintCallable, Category = <span class="string">"TCP Network"</span>)</span><br><span class="line"><span class="function">FString <span class="title">RecvMessage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">FString <span class="title">StringFromUint8Array</span><span class="params">(TArray&lt;uint8&gt; Array)</span></span>;</span><br><span class="line"></span><br><span class="line">FIPv4Address Ip;</span><br><span class="line"></span><br><span class="line">FSocket* ClientFd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ANetActor::CreateSocket</span><span class="params">(<span class="keyword">const</span> FString IPStr, int32 Port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将字符串ip转换为点分十进制ip</span></span><br><span class="line">FIPv4Address::Parse(IPStr, Ip);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将十进制ip 转化成网络地址</span></span><br><span class="line">TSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();</span><br><span class="line">addr-&gt;SetIp(Ip.Value);</span><br><span class="line">addr-&gt;SetPort(Port);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建TCP Socket 文件描述符</span></span><br><span class="line">ClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class="string">"TCP SOCKET"</span>), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ClientFd-&gt;Connect(*addr))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 连接成功</span></span><br><span class="line">UE_LOG(LogTemp, Warning, TEXT(<span class="string">"Connect success!"</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 连接失败</span></span><br><span class="line">UE_LOG(LogTemp, Warning, TEXT(<span class="string">"Connect failed!"</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ANetActor::SendMessage</span><span class="params">(FString Msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//后面直接传送json数据</span></span><br><span class="line">TCHAR* SeriallizedMsg = Msg.GetCharArray().GetData();</span><br><span class="line">int32 MsgSize = FCString::Strlen(SeriallizedMsg);</span><br><span class="line">int32 Send = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ClientFd-&gt;Send((uint8*)TCHAR_TO_UTF8(SeriallizedMsg), MsgSize, Send))</span><br><span class="line">&#123;</span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"MsgSend-Success-&gt;%s"</span>), *Msg);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"MsgSend-Failed-&gt;%s"</span>), *Msg);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FString <span class="title">ANetActor::RecvMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!ClientFd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TArray&lt;uint8&gt; RecvData;</span><br><span class="line">uint32 Size;</span><br><span class="line">uint32 Element = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ClientFd-&gt;HasPendingData(Size))</span><br><span class="line">&#123;</span><br><span class="line">RecvData.Init(Element, FMath::Min(Size, <span class="number">65507u</span>)); <span class="comment">// 65535 - 20 Ip头 - 8 Tcp头</span></span><br><span class="line">int32 Read = <span class="number">0</span>;</span><br><span class="line">ClientFd-&gt;Recv(RecvData.GetData(), RecvData.Num(), Read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RecvData.Num() &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FString RecvJsonString = StringFromUint8Array(RecvData);</span><br><span class="line">UE_LOG(LogTemp, Log, TEXT(<span class="string">"MsgRecv-Success-&gt;%s"</span>), *RecvJsonString);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> RecvJsonString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>蓝图连接<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F/%E6%89%93%E7%A0%96%E5%9D%97/socket%E8%93%9D%E5%9B%BE.png" alt=""></p><p>这样就能连接到TCP的后台了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇博客写的有点晚了, 自己的打砖块 已经写了一个段落了. 不过问题不大.&lt;/p&gt;
&lt;p&gt;重要的部分还在后面, 目前还没写到&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="小游戏" scheme="http://blog.lsmg.xyz/categories/%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="小游戏" scheme="http://blog.lsmg.xyz/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>3DMAX快捷键及基础知识</title>
    <link href="http://blog.lsmg.xyz/2020/02/3DMAX-3dmax%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://blog.lsmg.xyz/2020/02/3DMAX-3dmax%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-02-16T08:37:08.000Z</published>
    <updated>2020-02-17T14:48:59.145Z</updated>
    
    <content type="html"><![CDATA[<p>由于自己日后可能需要使用3d建模, 所以今天学习了下. 为了速成 看的B站的一个视频. 感觉效果还行吧.<br>基础的建模可以完成了, 后续需要的话 再继续学习</p><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>shift</td><td>绘制直线</td></tr><tr><td>删除键</td><td>可以回退一次</td></tr><tr><td></td><td></td></tr><tr><td>W</td><td>移动</td></tr><tr><td>E</td><td>旋转</td></tr><tr><td>R</td><td>缩放</td></tr><tr><td></td><td></td></tr><tr><td>F3</td><td>线框显示模式</td></tr><tr><td>F4</td><td>实体+线框限时模式</td></tr><tr><td></td><td></td></tr><tr><td>Shift</td><td>按住可以复制</td></tr><tr><td></td><td></td></tr><tr><td>Alt+T+A</td><td>阵列</td></tr><tr><td>Alt+T+M</td><td>镜像</td></tr><tr><td>Alt+A+对齐</td><td></td></tr><tr><td>Shitf+I</td><td>间隔工具</td></tr><tr><td></td><td></td></tr><tr><td>Ctrl+X</td><td>专家模式, 隐藏所有多余的东西 获得最大的空间</td></tr><tr><td>Alt+X</td><td>半透明显示</td></tr><tr><td>Ctrl+Shift+X</td><td>变换虚拟体显示切换 可以看到变换虚拟体的明显变化</td></tr><tr><td>O</td><td>自适应降级</td></tr></tbody></table><p><strong>编辑样条线-&gt;顶点</strong><br>优化 在线上添加点<br>焊接 连接两点<br>自动焊接 两点在距离之内自动焊接</p><p><strong>车削修改器</strong><br>将二维图形 指定一个轴然后旋转 得到立体图形</p><p><strong>可编辑多边形</strong><br><em>细分曲面</em><br>迭代次数2-3<br>无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)<br><em>细分置换-经常使用置换网格WSM修改器</em><br>需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图<br><em>绘制变形-未学-用于雕刻地形</em><br><strong>倒角剖面和扫描的区别</strong></p><ol><li>结合点不同</li><li>倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓</li><li>倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于自己日后可能需要使用3d建模, 所以今天学习了下. 为了速成 看的B站的一个视频. 感觉效果还行吧.&lt;br&gt;基础的建模可以完成了, 后续需要的话 再继续学习&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;按键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;
      
    
    </summary>
    
    
      <category term="3DMAX" scheme="http://blog.lsmg.xyz/categories/3DMAX/"/>
    
    
      <category term="3DMAX" scheme="http://blog.lsmg.xyz/tags/3DMAX/"/>
    
  </entry>
  
  <entry>
    <title>Git的使用</title>
    <link href="http://blog.lsmg.xyz/2020/02/Git-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
    <id>http://blog.lsmg.xyz/2020/02/Git-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</id>
    <published>2020-02-07T10:24:42.000Z</published>
    <updated>2020-02-22T09:44:40.216Z</updated>
    
    <content type="html"><![CDATA[<p>之前的Git博客 写的终于是自己都看不下去了. 所以打算来重新写一个博客<br>这篇博客主要还是参照的廖雪峰的Git博客<br>自己只做整理方便自己察看</p><p>2020年2月7日18:49:25 再来重新编辑下这些内容<br>2020年2月22日17:29:17 再次更新内容 增加commit规范</p><h1 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># -t Specifies the type of key to create.  The possible values are</span><br><span class="line">#“dsa”, “ecdsa”, “ed25519”, or “rsa”.</span><br><span class="line"># -C 生成注释 ...所以后面的邮箱就是个注释????</span><br><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &lt;message&gt;</span><br><span class="line">git remote add origin  # origin 意为远程库的名字, git的默认叫法</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">git diff</span><br><span class="line">git log</span><br><span class="line">git log --pretty&#x3D;oneline # 简单显示</span><br><span class="line"></span><br><span class="line"># 注意reset是恢复到上一个版本 即为你上一次commit版本或者pull最近的一次</span><br><span class="line">git checkout --&lt;filename&gt; # 恢复工作区, 可用于恢复修改和恢复勿删文件</span><br><span class="line">git reset HEAD &lt;file&gt; # 恢复暂存区</span><br><span class="line">git reset HEAD^ # 恢复版本库</span><br><span class="line">git reset --hard &lt;hash版本号 即为log中的一串英文字母, 只需要前几个字母即可&gt;</span><br><span class="line">git reflog # 所有版本日志</span><br><span class="line"></span><br><span class="line">git rm 从版本库中删除文件</span><br><span class="line"></span><br><span class="line">git push -u origin master # 带上 -u 以后提交就不需要加入origin master, 类似记忆功能</span><br><span class="line"></span><br><span class="line">&#96;git checkout -b dev&#96; #相当于一下两条命令</span><br><span class="line">&#96;git branch dev&#96; # 分支创建</span><br><span class="line">&#96;git checkout dev&#96; # 分支切换</span><br><span class="line">&#96;git branch -d dev&#96; # 分支删除</span><br><span class="line">&#96;git branch&#96; # 查看当前所有分支</span><br><span class="line">&#96;git merge dev&#96; # 将制定的dev分支合并到当前的分支</span><br></pre></td></tr></table></figure><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>首先把Git的三个区说明一下吧 自己后来慢慢感觉这些理论还是很重要的<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/Git%E4%B8%89%E5%A4%A7%E5%88%86%E5%8C%BA.png" alt=""><br>工作区<br>顾名思义, 你当前在IDE直接修改的代码全部都是位于工作区的代码<br>暂存区<br>暂时存取的区域, 你每次使用add提交的文件全部在这个区域中, 这些文件等待你的commit<br>版本库<br>这里存放的是若干个版本, 你每次的commit就是将暂存区的文件作为一个版本提交到版本库, 同时相应的文件被提交后 暂存区的文件被清除</p><h1 id="基础的操作"><a href="#基础的操作" class="headerlink" title="基础的操作"></a>基础的操作</h1><p><strong>你的第一次提交</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m &lt;message&gt;</span><br></pre></td></tr></table></figure><p><code>git init</code><br>在你命令所执行的文件夹生成版本库<br><code>git add &lt;file&gt;</code><br>将指定文件从工作区添加到暂存区<br>如果<code>&lt;file&gt;</code>用 <code>.</code> 代替则为所有相对上一次commit修改过的文件<br><code>git commit -m &lt;message&gt;</code><br>提交暂存区的文件到版本库中成为一个版本 message为这个版本(提交)的描述</p><p><strong>好了你已经成功完成了一次提交, 继续去写代码了</strong><br>好你又写完了一堆代码 这时你想知道你工作区的状态是啥-你修改了哪些文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$git status</span><br><span class="line">-------提示如下-----------</span><br><span class="line">位于分支 master</span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line"></span><br><span class="line">修改：     test.txt</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和&#x2F;或 &quot;git commit -a&quot;）</span><br></pre></td></tr></table></figure><p><code>git status</code>告诉你 你修改了test.txt文件, 但是你想知道你怎么修改了这些文件, 做了什么改动<br>这时候就需要<code>git diff</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$git diff</span><br><span class="line">-------提示如下-----------</span><br><span class="line">diff --git a&#x2F;test.txt b&#x2F;test.txt</span><br><span class="line">index 0858ae8..8c14912 100644</span><br><span class="line">--- a&#x2F;test.txt</span><br><span class="line">+++ b&#x2F;test.txt</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> 111111111111111</span><br><span class="line"> 222222222222222</span><br><span class="line"> 333333333333333</span><br><span class="line">+444444444444444</span><br></pre></td></tr></table></figure><p><strong>现在你知道你进行了什么修改, 又进行了一次提交</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line">修改：     test.txt</span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和&#x2F;或 &quot;git commit -a&quot;）</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git add test.txt </span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 &quot;git reset HEAD &lt;文件&gt;...&quot; 以取消暂存）</span><br><span class="line">修改：     test.txt</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git commit -m &quot;ver 0.02&quot;</span><br><span class="line">[master ee4400f] ver 0.02</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br></pre></td></tr></table></figure><h1 id="时光穿梭机"><a href="#时光穿梭机" class="headerlink" title="时光穿梭机"></a>时光穿梭机</h1><p><strong>在commit之间切换</strong><br>Git还可以在不同commit间切换, 当然你必须知道进行过哪些commit, 你不能自己都记在脑子里吧, 所以也存在相关的命令<code>git log</code>来查看你的commit记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lsmg@ubuntu:~&#x2F;temp$ git log</span><br><span class="line">commit ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master)</span><br><span class="line">Author: ***********</span><br><span class="line">Date:   Sat Dec 7 21:06:42 2019 -0800</span><br><span class="line">    ver 0.02</span><br><span class="line"></span><br><span class="line">commit 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class="line">Author: ***********</span><br><span class="line">Date:   Sat Dec 7 20:57:58 2019 -0800</span><br><span class="line">    ver 0.01</span><br><span class="line"></span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git log --pretty&#x3D;oneline # 简洁显示</span><br><span class="line">ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master) ver 0.02</span><br><span class="line">603260e28ac0cc8fb8e4243120eb00bca83585d2 ver 0.01</span><br></pre></td></tr></table></figure><p>上面的<code>HEAD</code>代表当前版本, 上一个版本为<code>HEAD^</code>, 上上一个版本为<code>HEAD^^</code>如此类推<br>回到前N个版本<code>HEAD~N</code><br><code>git reset --hard HEAD^</code> 回到上一个版本.<br>这时你当前版本将会丢失, 使用<code>git log</code>也不会查看到原来的版本信息<br>这时使用<code>git reflog</code>来查看你的所有版本日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lsmg@ubuntu:~&#x2F;temp$ git reset --hard 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class="line">HEAD 现在位于 603260e ver 0.01</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git log</span><br><span class="line">commit 603260e28ac0cc8fb8e4243120eb00bca83585d2 (HEAD -&gt; master)</span><br><span class="line">Author: rjd67441 &lt;rjd67441@hotmail.com&gt;</span><br><span class="line">Date:   Sat Dec 7 20:57:58 2019 -0800</span><br><span class="line"></span><br><span class="line">    ver 0.01</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git reflog </span><br><span class="line">603260e (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class="line">ee4400f HEAD@&#123;1&#125;: commit: ver 0.02</span><br><span class="line">603260e (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): ver 0.01</span><br><span class="line">lsmg@ubuntu:~&#x2F;temp$ git reset --hard ee4400f</span><br><span class="line">HEAD 现在位于 ee4400f ver 0.02</span><br></pre></td></tr></table></figure><p><strong>撤销修改</strong><br>工作区中的撤销<br><code>git checkout -- &lt;filename&gt;</code><br>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。<br>暂存区中的撤销<br><code>git reset HEAD &lt;file&gt;</code><br>版本库的撤销<br><code>git reset HEAD^</code> 乖乖回退一次</p><p><strong>删除文件</strong><br>删除本地文件后<br>确实需要从版本库中删除<br><code>git rm</code>删除然后<code>git commit</code>提交即可<br>误删除需要使用<code>git chechout -- &lt;filename&gt;</code>来恢复</p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p><code>git checkout -b dev</code>相当于一下两条命令<br><code>git branch dev</code> 分支创建<br><code>git checkout dev</code> 分支切换</p><p><code>git branch -d dev</code> 分支删除</p><p><code>git branch</code> 查看当前所有分支</p><p><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p><p><strong>冲突解决</strong><br><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 111111111111111</span><br><span class="line">2 222222222222222</span><br><span class="line">3 333333333333333</span><br><span class="line">4 444444444444444</span><br><span class="line">5 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  # 我在master分支下添加了6666666 并提交</span><br><span class="line">6 6666666</span><br><span class="line">7 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">8 7777777</span><br><span class="line">9 &gt;&gt;&gt;&gt;&gt;&gt;&gt; deb # 我在deb分支下添加了7777777 并提交</span><br></pre></td></tr></table></figure><p>  最后需要我手动修改这个文件为自己需要的内容 然后提交即可</p><p>  <strong>分支管理</strong><br>  通常Git会使用<code>Fast forward</code>模式 这样删除分支后会丢失分支的信息<br>  可以再merge的时候加入<code>--no-ff</code>这样就能解决问题<br>  <code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>  由于禁用<code>Fast forward</code>后<br>  会生成新的commit所以需要加入<code>-m &quot;merge with no-ff&quot;</code></p><p>  <code>git stash</code> 可以储存当前的工作区 继续其他的工作<br>  <code>git stash list</code> 查看储存的工作区列表<br>  <code>git stash apply stash@{0}</code> 恢复指定的储存<br>  <code>git stash pop</code> 恢复并drop最近的存储</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.txt # stash前</span><br><span class="line">111111</span><br><span class="line">$ vim test.txt </span><br><span class="line">$ cat test.txt # 进行了修改</span><br><span class="line">111111</span><br><span class="line">222222</span><br><span class="line">333333</span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">修改：     test.txt</span><br><span class="line">$ git stash # stash</span><br><span class="line">保存工作目录和索引状态 WIP on master: 854b710 1</span><br><span class="line">$ cat test.txt </span><br><span class="line">111111</span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br><span class="line">$ git stash pop</span><br><span class="line">位于分支 master</span><br><span class="line">修改：     test.txt</span><br><span class="line">$ cat test.txt </span><br><span class="line">111111</span><br><span class="line">222222</span><br><span class="line">333333</span><br></pre></td></tr></table></figure><h1 id="实际工作中分支的应用"><a href="#实际工作中分支的应用" class="headerlink" title="实际工作中分支的应用"></a>实际工作中分支的应用</h1><p><a href="https://zhuanlan.zhihu.com/p/38772378" target="_blank" rel="noopener">主要参考</a><br><strong>主分支</strong></p><ul><li><strong>master</strong>: 这个分支最稳定, 相当于放的可发布版本</li><li><strong>develop</strong>: 开发分支, 平行于master分支, 负责合并各种<code>用于开发子功能</code>的分支</li></ul><p><strong>支持分支</strong>:解决某个问题, 结束后合并回<code>master</code>或<code>develop</code>分支</p><ul><li><strong>feature</strong>功能分支, 用于开发一个个子功能, 来自<code>develop</code>合并到<code>develop</code>去</li><li><strong>release</strong>:发布分支, 用于修改版本号等小修改, 来自<code>develop</code>分支合并到<code>master</code>分支</li><li><strong>hotfixes</strong>:紧急修复bug分支, 从<code>master</code>创建, 合并回<code>develop</code>分支和<code>master</code>分支<br><img src="https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg" alt=""></li></ul><h1 id="commit-规范"><a href="#commit-规范" class="headerlink" title="commit 规范"></a>commit 规范</h1><p><a href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">阮一峰 Commit message 和 Change log 编写指南</a></p><p>Angular 规范.<br>每个commit message 包括三分部<br>Header Body 和 Footer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; &#x2F;&#x2F; 必须</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;body&gt; &#x2F;&#x2F; 非必须</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;footer&gt; &#x2F;&#x2F;非必须</span><br></pre></td></tr></table></figure><p><strong>Header</strong></p><ol><li>type 必需 - 说明commit的类别, 只允许下面七个标识</li></ol><ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><ol start="2"><li><p>scope 非必需 - 用于说明 commit影响的范围<br>比如登录、注册、充值逻辑等等，视项目不同而不同。</p></li><li><p>subject 必需 - commit 目的的简短描述 </p></li></ol><ul><li>不超过50字符 </li><li>第一人称现在时动词开头</li><li>首字母小写</li><li>句尾不加句号</li></ul><p><strong>Body</strong><br>本次commit的详细描述, 可以分成多行</p><p><strong>Footer</strong><br>只用于两种情况 目前用不动 不摘了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前的Git博客 写的终于是自己都看不下去了. 所以打算来重新写一个博客&lt;br&gt;这篇博客主要还是参照的廖雪峰的Git博客&lt;br&gt;自己只做整理方便自己察看&lt;/p&gt;
&lt;p&gt;2020年2月7日18:49:25 再来重新编辑下这些内容&lt;br&gt;2020年2月22日17:29:17 再
      
    
    </summary>
    
    
      <category term="必备技能" scheme="http://blog.lsmg.xyz/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/"/>
    
      <category term="Git操作" scheme="http://blog.lsmg.xyz/categories/%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD/Git%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="Git操作" scheme="http://blog.lsmg.xyz/tags/Git%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>头文件互相引用</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%87%E5%9D%91-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BA%92%E7%9B%B8%E5%BC%95%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%87%E5%9D%91-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%BA%92%E7%9B%B8%E5%BC%95%E7%94%A8/</id>
    <published>2020-02-07T08:37:08.000Z</published>
    <updated>2020-02-07T10:09:48.656Z</updated>
    
    <content type="html"><![CDATA[<p>写在前头 本文中的<strong>编译</strong>二字基本都带加粗, 因为目前为止我还没做学到过<strong>编译</strong>器相关的东西,<br>姑且将<code>那个执行过程</code>称为<strong>编译</strong>, 所以加粗</p><h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>二月六号的时候 我在写那个小游戏, 写头文件<code>a.h</code>发现即使引用了一个头文件<code>b.h</code>, 也没有办法使用定义在那个头文件之中的结构体.</p><p>其实有点我没在意: 当我在<code>a.h</code>文件中引用<code>b.h</code>的时候<code>b.h</code>会变成<code>invaild</code>, 这里其实就已经提示了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"b.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_A_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A *a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_B_H</span></span></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span> <span class="comment">// a.h中有b.h就只include a.h</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    B b&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error: ‘A’ does <span class="keyword">not</span> name a type</span><br><span class="line">error: ‘B’ does <span class="keyword">not</span> name a type</span><br></pre></td></tr></table></figure><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><h2 id="先说一下-ifndef-endif"><a href="#先说一下-ifndef-endif" class="headerlink" title="先说一下 #ifndef #endif"></a>先说一下 #ifndef #endif</h2><p><code>ifndef</code>全称<code>if not defined</code><br>意思是如果<code>#ifndef</code>后面的宏没有被定义 就继续<strong>编译</strong>其中的内容<br>继续<strong>编译</strong><code>#ifndef</code>的下一句就是<code>#define</code>这个宏, 这样这个宏就被定义了<br>第二次<strong>编译</strong>遇到这个头文件的时候, <code>#ifndef</code>后面的宏已经被定义了就跳过了if中的内容</p><h2 id="include的作用"><a href="#include的作用" class="headerlink" title="#include的作用"></a>#include的作用</h2><p>将 #include右边的文件展开到此文件中</p><h2 id="问题解释"><a href="#问题解释" class="headerlink" title="问题解释"></a>问题解释</h2><p>这样当你在main函数中 <code>#include &quot;a.h&quot;</code>的时候<code>a.h</code>之中的内容就被展开<br>变成如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"b.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_A_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    B b&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个include同样操作得到如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"a.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A *a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_B_H</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_A_H</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    B b&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我猜测<strong>编译</strong>的时候是逐行执行的, 至少在头文件的这部分是逐行执行<br>这样执行完了<code>行号为2 3 4 5</code>的四个宏 准备执行<code>行号为6</code>的这一行<code>#include &quot;a.h&quot;</code>继续展开<br>得到如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"b.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_A_H</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A *a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_B_H</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_A_H</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    B b&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有些乱 但仔细理解还是能到这里. 这下继续逐行执行 准备是<code>行号为6</code>的这一行(也可能是行号7的部分, 区别就是在include的下一行展开还是本行展开)<code>#ifndef UNTITLED1_A_H</code><br>这个宏就判断<code>UNTITLED1_A_H</code>是不是被定义了, 恩被定义了(第三行代码)跳到对应的<code>#endif</code>, 这样就防止了头文件<br>无穷无尽的调用 我将跳过的部分注释掉方便继续分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="comment">//#ifndef UNTITLED1_A_H</span></span><br><span class="line"><span class="comment">//#define UNTITLED1_A_H</span></span><br><span class="line"><span class="comment">//#include "b.h"</span></span><br><span class="line"><span class="comment">//class A</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//   B *b;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="comment">//#endif //UNTITLED1_A_H</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A *a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_B_H</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_A_H</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    B b&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一行就是<code>第十四行</code>的<code>class B</code>的<strong>编译</strong>, 那么问题来了<code>第16行</code>的<code>A</code>是啥东西??.</p><p>这里报错报了两行 我大胆推测一下 <code>class B</code>的<strong>编译</strong>的出错后, 依然在继续这个过程, 到了<code>class A</code>的时候<br>发现其中的<code>B</code>又是啥呢? 推测不同头文件编译互不影响 所以出现了两行报错</p><p>我们回到<code>class B</code>的头文件在<code>class B</code>的前面加上一行<code>class A;</code> 得到如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_A_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNTITLED1_B_H</span></span><br><span class="line"><span class="comment">//#ifndef UNTITLED1_A_H</span></span><br><span class="line"><span class="comment">//#define UNTITLED1_A_H</span></span><br><span class="line"><span class="comment">//#include "b.h"</span></span><br><span class="line"><span class="comment">//class A</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//   B *b;</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="comment">//#endif //UNTITLED1_A_H</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A *a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_B_H</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    B *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//UNTITLED1_A_H</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a&#123;&#125;;</span><br><span class="line">    B b&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里你会发现A的报错消失了, 因为这次在<strong>编译</strong><code>class B</code>的时候事先知道了<code>A</code>是一个类并且你必须把<br><code>class B</code>之中的这一句<code>A *a;</code>写成指针, 因为指针大小确定, 而且没有初始化, 所以<strong>编译</strong>就能通过, 如果你写成<br><code>A a;</code>依然会报错, 因为不知道A具体是个啥 最起码的内存都没法分配</p><p>好的下面继续, 你发现虽然A的报错消失了 但是<code>B</code>的报错还在, 我这里依然推测下, 不同头文件之间的<strong>编译</strong>互不影响,<br>所以依然不知道<code>B</code>是什么此时按照上面操作加入<code>class B;</code>前置声明, <strong>编译</strong>正确通过.</p><p>虽然两个头文件<strong>编译</strong>互不影响, 但是既然是main.cpp把他们引进来的 就同时对main.cpp起作用 自然就知道了A和B是啥</p><p>虽然这个问题网上答案很多, 但我对此还是很多不理解, 所以在做某些推测的情况下, 分析出来了这些原因. 如果有误,请直接评论中指出. 这也算是本人的第一篇写的认真的博客</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写在前头 本文中的&lt;strong&gt;编译&lt;/strong&gt;二字基本都带加粗, 因为目前为止我还没做学到过&lt;strong&gt;编译&lt;/strong&gt;器相关的东西,&lt;br&gt;姑且将&lt;code&gt;那个执行过程&lt;/code&gt;称为&lt;strong&gt;编译&lt;/strong&gt;, 所以加粗&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP踩坑" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E8%B8%A9%E5%9D%91/"/>
    
    
      <category term="CPP踩坑记" scheme="http://blog.lsmg.xyz/tags/CPP%E8%B8%A9%E5%9D%91%E8%AE%B0/"/>
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>CMAKE</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-CMAKE/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-CMAKE/</id>
    <published>2020-02-06T09:07:45.000Z</published>
    <updated>2020-02-19T14:35:15.526Z</updated>
    
    <content type="html"><![CDATA[<p>CMAKE并不打算专门去学, 所以就用到哪里学到哪里</p><p>今天clion写项目 遇到一个问题 明明写了aux_source_directory 却依然提示没有加入. 后来查了下, 并不推荐使用那个命令.<br>可能会存在一些问题<br><a href="https://cmake.org/cmake/help/latest/command/aux_source_directory.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/latest/command/aux_source_directory.html</a></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必须片段</span></span><br><span class="line"><span class="comment"># CMake 最低版本号要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span> (VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="comment"># 项目信息</span></span><br><span class="line"><span class="keyword">project</span> (Demo1)</span><br><span class="line"><span class="comment"># 指定生成目标</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo main.cc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多文件</span></span><br><span class="line"><span class="comment"># 如果一味地在add_executable中添加源文件, 会导致太长了</span></span><br><span class="line"><span class="comment"># 将dir目录中所有源文件保存在变量中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR_SOURCE)</span><br><span class="line"><span class="comment"># 将变量赋值给Demo</span></span><br><span class="line"><span class="keyword">add_executable</span>(Demo <span class="variable">$&#123;DIR_SOURCE&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多文件多目录</span></span><br><span class="line"><span class="comment"># 需要在主目录和子文件夹中都编写CMakeLists.txt文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主文件添加子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(dir1)</span><br><span class="line"><span class="comment"># 添加链接库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Demo Foo)</span><br><span class="line"></span><br><span class="line"><span class="comment"># dir1目录中</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(. DIR1_SOURCE)</span><br><span class="line"><span class="comment"># 生成链接库 Foo 在主文件中添加即可</span></span><br><span class="line"><span class="keyword">add_library</span>(Foo <span class="variable">$&#123;DIR1_SOURCE&#125;</span>)</span><br></pre></td></tr></table></figure><h1 id="CMAKE和MAKE之间的区别"><a href="#CMAKE和MAKE之间的区别" class="headerlink" title="CMAKE和MAKE之间的区别"></a>CMAKE和MAKE之间的区别</h1><p><a href="https://my.oschina.net/xunxun/blog/86781" target="_blank" rel="noopener">博客原文</a></p><p>自己的理解<br>通过为cmake编写CMakeList文件, cmake即可按照规则生成相应的Makefile文件<br>然后make读取Makefile文件就可以按照规则将源代码编译</p><p>总的来说cmake就是为make生成Makefile文件, (Makefile文件可以自己编写, 也可以用Cmake生成)<br>应该是编写CMakeList的代码量少于或者简单于Makefile, 简化了操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CMAKE并不打算专门去学, 所以就用到哪里学到哪里&lt;/p&gt;
&lt;p&gt;今天clion写项目 遇到一个问题 明明写了aux_source_directory 却依然提示没有加入. 后来查了下, 并不推荐使用那个命令.&lt;br&gt;可能会存在一些问题&lt;br&gt;&lt;a href=&quot;https
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>字节对齐</title>
    <link href="http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/"/>
    <id>http://blog.lsmg.xyz/2020/02/CPP-CPP%E9%87%8D%E7%82%B9-%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90/</id>
    <published>2020-02-06T03:38:08.000Z</published>
    <updated>2020-02-07T08:38:13.076Z</updated>
    
    <content type="html"><![CDATA[<p>以前在牛客碰到不少字节对齐的题目, 当时只是为了记住而记住 今天我在学习自定义TCP二进制数据包<br>的时候 遇到了必须考虑下字节对齐的情景.</p><p><strong>解释</strong><br>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。–百度百科</p><p><strong>原因</strong><br>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况<br>但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。–百度百科</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> foo1;</span><br><span class="line">    <span class="keyword">int</span> foo2;</span><br><span class="line">    short foo3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(Foo) = <span class="number">12</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">char</span>) + <span class="keyword">sizeof</span>(<span class="keyword">int</span>) + <span class="keyword">sizeof</span>(short) = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>说明内存中并不是连续存储的这三个变量;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Foo foo1&#123;<span class="string">'1'</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">write</span>(fd, &amp;foo1, <span class="keyword">sizeof</span>(foo1));</span><br></pre></td></tr></table></figure><p>// hexdump 查看<br>0000000 5631 0000 0002 0000 0003 0000<br>对应图示如下<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png" alt=""></p><p>第一字节 0x31 正好是 ‘1’ <em>蓝色区域</em><br>二三四字节 为填充 <em>红色区域</em><br>因为sizeof(int)=4所以foo2的偏移量是四的倍数 , 故需要填充三个字节 3+1 = 4</p><p>第五六七八字节 0x02对应2 <em>灰色区域</em><br>这里没有填充是因为sizeof(short)=2所以foo3的偏移量是2的倍数 由于偏移量是8 所以不需要填充</p><p>第九十字节 0x03 对应3<br>第十一十二字节填充<em>黑色区域</em><br>因为此结构中最大的sizeof()=4所以需要将字节数对齐到4的倍数 目前10字节 所以需要填充2字节到<br>12字节满足四的倍数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以前在牛客碰到不少字节对齐的题目, 当时只是为了记住而记住 今天我在学习自定义TCP二进制数据包&lt;br&gt;的时候 遇到了必须考虑下字节对齐的情景.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释&lt;/strong&gt;&lt;br&gt;现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>大二寒假及下学期学习记录</title>
    <link href="http://blog.lsmg.xyz/2020/02/%E5%A4%A7%E4%BA%8C%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.lsmg.xyz/2020/02/%E5%A4%A7%E4%BA%8C%E5%AF%92%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/</id>
    <published>2020-02-01T09:30:32.000Z</published>
    <updated>2020-02-19T14:35:24.292Z</updated>
    
    <content type="html"><![CDATA[<p>现在是<code>2020年2月1日17:32:50</code> 寒假过半? 目前还不知道寒假什么时候开学. 为了自己能够前往心目中的公司, 学习是必不可少的.<br>学习的同时 应该要注意总结, 防止一天或者一周下来白忙活<br>我们寒假开始是一月九号 到我开始寒假学习的一月二十三号 这些天没有学习用来玩了, 好在后面拾了回来<br>从二十三号到现在二月一号, 每天学习的长度和质量总算是在慢慢上升<br>距离下一个寒假只剩下一年的时间了, 需要更加的努力, 为了大三暑假能够进入心中的公司 大三寒假的实习必不可少了. 加倍努力吧</p><p>这篇博客的标题起初是<code>大二寒假学习记录</code>后来改成了<code>大二寒假及下学期学习记录</code>寒假的学习必不可少, 下学期更要抓紧时间了.</p><h1 id="二月"><a href="#二月" class="headerlink" title="二月"></a>二月</h1><h2 id="一日2020年2月1日17-39-59"><a href="#一日2020年2月1日17-39-59" class="headerlink" title="一日2020年2月1日17:39:59"></a>一日2020年2月1日17:39:59</h2><p>前几天把博客从我自己的服务器迁移到了coding上, 方便以后我乱搞服务器, 现在服务器上没有重要的内容了<br>至于实际的学习方面, 我开始整理我的博客<a href="https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/">主要是这篇</a>这篇现在算告一段落了, 主要是把自己以前学过的用一用. 空洞的写下api<br>理解不是很深刻.<a href="https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/">这两天修改的这一篇</a>. 第二篇自己缺少的东西很多, 由于当时学习到了后面实在是学不下去了.<br>所以现在把后面的部分重新写了一下. 高级部分的线程和进程的部分 实在是太走马观花. 等我顺序学到了 再多写一些例子</p><p>今天的话, 练习了下poll系统调用, 写了一个poll的demo, 然后是整理了下信号的部分, 信号这里整理的依然很少 平时用到的不多, 需要多加使用<br>主要是定时器这里了 定时器把原来的内容删掉了 从新写目前只写完了socket定时</p><p>接下来打算还是多写一些项目 多思考一些 等我整理完了高级部分 就准备去看开源项目?每次看开源项目都感觉自己差的太多, 不知道从哪里看起<br>所以搭配着别人的笔记学习下看源码. 当然看源码之前还是要会大概的使用. 高级部分自然包括了libevent的使用部分</p><p>跑去写项目了</p><h2 id="二日2020年2月2日18-03-23"><a href="#二日2020年2月2日18-03-23" class="headerlink" title="二日2020年2月2日18:03:23"></a>二日2020年2月2日18:03:23</h2><p>罪过罪过, 昨天晚上十一点半 玩了一把军团TD 结果玩到了十二点半 ….. 最后一点半才睡觉<br>今天早上小十一点才起床.<br>我依稀记得我八点被闹钟叫起来emm 然后想着定八点半的闹钟 再睡一会, 结果闹钟没定我就睡着了.</p><p>起来后整理了整理吃了午饭, 就下午小一点了, 打开高级部分 学习<code>信号SIGALRM定时</code></p><p>代码量就400行 一直到我写今天的博客 才算完工</p><p><strong>先写一下遇到的一个问题吧</strong><br>首先表现出来的是<code>超时后 服务器没有断开连接</code><br>然后我去打断点, 发现不是定时器链表部分的问题. 是定时信号没有触发<code>epoll_wait</code>.<br>这里我看了下代码, 发现定时器没有启动加上了<code>alarm(5)</code>, 我本意是理解了书上的代码 再去自己写, 结果还是理解的不深刻, 竟然丢了启动定时器的函数.<br>然后我又运行了下<code>发现还是没有运行到</code><br>然后发现<code>epoll_wait 返回-1 设置EINTR</code>, 后来查阅了下说是被信号处理器中断, 思考可能是与IDE下断点有关??????<br>最后发现自己没有把信号的管道添加到<code>epollfd</code>中再一细看发现丢了关于信号管道的四行代码…</p><p>这个问题应该是很容易排查. 事后感觉应该这样思考<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/epoll%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.png" alt=""><br>以后尽量总结正确的思考模式, 虽然不知道有没有用 但要试一试.</p><p><strong>项目收获方面</strong><br>虽然这个项目只有400多行代码, 但我自己是绝对写不出来的. 只能尽量总结书上代码的好处</p><ol><li>首先肯定是使用alarm超时产生信号SIGALRM来触发回调函数 实现定时</li><li>信号回调函数, 没有直接去触发定时器tick函数, 而是通过一个管道传到了epollfd中, 然后从epollfd的函数中触发相关的if 再去调用tick函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">()</span> <span class="comment">//真正的生效部分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    timer_lst.tick();</span><br><span class="line">    alarm(TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> save_errno = errno;</span><br><span class="line">    <span class="keyword">int</span> msg = sig;</span><br><span class="line">    send(pipefd[<span class="number">1</span>], (<span class="keyword">char</span>*)&amp;msg, <span class="number">1</span>, <span class="number">0</span>); <span class="comment">// pipefd[0]注册进了epoll中 接受到来的信号</span></span><br><span class="line">    errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig)</span><span class="comment">// 信号添加</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line">    sa.sa_flags |= SA_RESTART;</span><br><span class="line">    sa.sa_handler = sig_handler;</span><br><span class="line">    sigfillset(&amp;sa.sa_mask);</span><br><span class="line">    exit_if(sigaction(sig, &amp;sa, <span class="literal">nullptr</span>) == <span class="number">-1</span>, <span class="string">"add sig error"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> signals[<span class="number">1024</span>]; <span class="comment">// 信号接收, 可能存在多个信号 所以用返回的字节数来逐个取出信号</span></span><br><span class="line">ret = recv(sockfd, signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>); 取出后使用<span class="keyword">switch</span>来分离信号</span><br></pre></td></tr></table></figure></li><li>将大部分常量 #define<br>大概只能总结出这一些来了, 完整的代码我贴在github上吧</li></ol><h2 id="五日-2020年2月6日09-16-23"><a href="#五日-2020年2月6日09-16-23" class="headerlink" title="五日 2020年2月6日09:16:23"></a>五日 2020年2月6日09:16:23</h2><p>三和四号 基本都在玩FF14, 发现自己并不是玩游戏了, 感觉被FF14玩了, 就是那种感觉累了不想玩了, 但却离自己定的小目标远 然后坚持<br>emm 其实感觉这个时候应该下游戏.<br>想想自己这大学一年半玩过的游戏 血族我算是玩的时间最长的大概前前后后我玩了五年, 应该是上半年把 我弃坑了. 游戏后面太氪了, 不得不退游了.<br>后面崩三啥的也玩过, 发现自己并不适合肝的游戏. 最近一个月入坑了fgo, 开始的几个星期还是玩的累了, 自己太肝了, 最近这几天感觉休闲了不少,<br>心态也正常了, 所以暂且会玩一玩.</p><p>主要还是后面这些吧, 我发现自己逐渐有了一个念头: 累了就去玩会游戏, 就去看会直播, 刷刷B站. 后来我感觉这些浪费时间就去搜索了一下<br><strong>玩游戏算浪费时间吗</strong>, 刚才去找了下. 没找到我之前看过的那篇. 结论就是为什么自己不是累了就去小睡一下, 或者看看书,再或者刷刷新的科技圈<br>长长见识? 自己尝试了看书, 发现自己并不是太抗拒. 以后试试把.</p><p>最后自己作为一个想开发游戏的人, 总感觉不玩游戏是不合适的, 但要玩的适度, 毕竟自己还有一年的时间就要找寒假实习, 为了自己的大三暑假进入大厂打下基础.<br>平衡好才是上策.</p><p>接下文, 我发现自己有点?(自信点把点去掉)好高骛远了, 好高骛远会消磨一个人的兴趣和信心. 最终决定不做什么大游戏, 不研究什么框架, 先用自己所会的写一个小游戏,<br>一是为了试着重新拾起兴趣, 二是如果只学而不去写项目, 没有太大收获的</p><p>昨天一天都是策划和编写一个游戏, 游戏逻辑十分的简单. 猜数字 初期的流程图我大概画了下, 姑且算作第一版吧 下面放出来, 我后面可以逐渐丰富这个东西 加上日志登录<br>断线重连等等功能.感觉还是可以的~~ 尽管逻辑很简单.<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%B5%81%E7%A8%8B1.png" alt=""><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%911.png" alt=""></p><p>听说在写代码前规划好, 可以更好地组织代码, 昨天尝试了下感觉还不错. 我在写代码前把游戏的流程图画了一下, 然后标上了哪里会有什么数据交互,<br>之后我去写了数据包头格式<br><strong>头部</strong></p><table><thead><tr><th>偏移量</th><th>长度</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>4</td><td>封包总大小</td></tr><tr><td>4</td><td>2</td><td>头部长度</td></tr><tr><td>6</td><td>2</td><td>操作码</td></tr></tbody></table><p><strong>操作码</strong></p><table><thead><tr><th>代码</th><th>含义</th><th>数据格式</th></tr></thead><tbody><tr><td>00</td><td>登录</td><td></td></tr><tr><td>01</td><td>桌位信息(服务器发送桌位列表)</td><td>[1000-0-4][1001-0-4]</td></tr><tr><td>02</td><td>桌位操作信息(客户端加入 退出桌位)</td><td>1000</td></tr><tr><td>03</td><td>服务器桌位操作信息反馈(加入退出成功1 加入退出失败0)</td><td>1</td></tr><tr><td>04</td><td>准备</td><td>无</td></tr><tr><td>05</td><td>取消准备</td><td>无</td></tr><tr><td>06</td><td>服务器广播桌位信息</td><td>4[11][10][00][00] (桌位总数, 有人1 准备1)</td></tr><tr><td>A1</td><td>服务器广播游戏开始</td><td>空</td></tr><tr><td>A2</td><td>服务器下发轮到的客户端</td><td>空</td></tr><tr><td>A3</td><td>客户端发送猜测的数字</td><td>50</td></tr><tr><td>A4</td><td>服务器发送猜测数字反馈 (数据合理1, 数据非法0)</td><td>1</td></tr><tr><td>A5</td><td>服务器广播游戏状态</td><td>50-0-75[A][B] (A玩家猜出50 当前范围 0到75 B玩家准备)</td></tr></tbody></table><p>然后草拟了一下 用到的类 用到的数据结构 分几个类 怎么联系起来, 最终我才去写代码, 感觉比一边写<br>一边想要好不少. 写的过程中也发现了一些问题</p><ol><li><code>EPOLLRDHUP</code>这个绑定在listenfd还是newfd?? 如果是newfd还能理解下原理, listenfd就有点理解不了.(试了下, 是newfd)</li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo *a;</span><br><span class="line">Foos b[<span class="number">3</span>];</span><br><span class="line">b[<span class="number">1</span>] = *a;</span><br><span class="line"><span class="comment">// 修改a不会影响b[1], 这个问题听到过, 自己真正试了试才发现如此</span></span><br></pre></td></tr></table></figure></li></ol><p>姑且昨天的就补上这些吧. 今天打算把游戏的服务器跑起来</p><h2 id="六日-2020年2月6日22-12-36"><a href="#六日-2020年2月6日22-12-36" class="headerlink" title="六日 2020年2月6日22:12:36"></a>六日 2020年2月6日22:12:36</h2><p>忙忙碌碌的一天就又要结束了. 今天一天把剩下的一部分逻辑代码写了一部分. 主要是写自定义协议的序列化和反序列化. 起初打算<br>用char* body 来存储, 按照上面定义的格式传输. 后来一想, 这样我就不就是在原地打转吗. 就去网上找了找相关的代码, 看看别人怎么写的</p><p>主要是看的这一篇博客<a href="https://blog.csdn.net/ACb0y/article/details/61421006" target="_blank" rel="noopener">手把手教你实现自定义的应用层协议</a><br>看了之后收获不少. 收获总结在下面吧</p><ol><li>两个头文件互相include<br> 这个是今天了解的最奇葩的一个问题, 如果两个头文件互相include 会出问题. 这个明天开一篇 采坑博客<br> 与此连带的还有class 前置声明, 再者可以到编译相关的问题</li><li>今天了解了一下CMAKE和MAKE的区别和联系, 总算知道了为啥好多安装的时候先cmake 再 make</li><li>还是关于CMAKE 稍微整理了点CMAKE的使用. 随用随整理, 目前不打算一次性整理太多</li><li>Git操作不熟练. 我本地写好了代码文件, commit 然后从服务器pull了一个仅包含readme的仓库, 然后reset<br> 自己写的代码文件全没了, 只剩下README.md 还好之前整理过reflog, 明天也需要在整理下</li><li>安装了jsoncpp, 亿图图示等一些软件. 写了下关于字节对齐的问题. 亿图图示目前感觉挺不错</li></ol><p>代码方面的收获 主要就是看的那篇博客学到的.</p><ol><li>首先就是学会了自定了协议 序列化和反序列化怎么写 代码更美. 虽然可能我看的博客可能不是最好的,<br> 但对我目前来说足够美了, 不过写一遍远远不够.</li><li>学到了巧妙地对 <code>uint8_t*</code>类型的指针(指向流数据缓冲区)转换成<code>uint16_t*</code>等指针类型, 进行解引用 得到原本的数据, 然后对<br>  <code>uint8_t*</code>类型的指针<code>+2</code>就可以跳过一个<code>uint16_t</code>, 虽然这些能够理解, 但实际应用这是第一次</li><li>对于如何更好的组织一个数据结构 有了更深的体会.</li><li>使用vector来存储剩余的包字节, 相比使用一个定长数组进行strcpy 方便了不少</li><li>使用erase擦除也是第一次实际应用</li><li>更好的使用指针</li></ol><p>定一下明天的任务吧, 试运行</p><ol><li>定义游戏的json格式, 把所有的json都定义出来 √</li><li>游戏完成度达到能够正确解析包并分发到合理的部分即可 √</li><li>写一遍采坑博客-头文件互相引用 √</li><li>针对今天Git遇到的文件 在做研究下√</li><li>简单学习下jsoncpp的使用√</li></ol><h2 id="七日-2020年2月7日10-14-53"><a href="#七日-2020年2月7日10-14-53" class="headerlink" title="七日 2020年2月7日10:14:53"></a>七日 2020年2月7日10:14:53</h2><p>2020年2月7日10:14:53<br>今天博客写的格外早, 主要是又遇到一个奇葩问题(其实是我自己使用有误)<br>我昨天最后发现代码跑不起来, 就没有管, 今天看了下跑不起来是因为<code>未定义引用</code><br>好吧, 未定义引用, 我检查了一下发现不对啊, 我加上了<br><code>target_link_libraries(Guess -ljsoncpp network game)</code><br>我当时是这样写的, 结果就是报错<code>未定义引用</code>, 然后我把报错的部分另开一个项目放进去<br>运行起来没问题?????.<br>然后我把报错的代码放在我项目的main文件中, 结果原来的报错也消失了 main中的也没报错?????<br>最后阴差阳错发现这个博客<a href="https://blog.csdn.net/qq_33249383/article/details/88908218" target="_blank" rel="noopener">初入职常见问题：gcc编译时对’xxxx’未定义的引用</a>. 我发现其中的一段话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这个主要的原因是gcc编译的时候，各个文件依赖顺序的问题。</span><br><span class="line">在gcc编译的时候，如果文件a依赖于文件b，那么编译的时候必须把a放前面，b放后面。</span><br><span class="line">例如:在main.c中使用了pthread库相关函数，那么编译的时候必须是main.c在前，-lpthread在后。 gcc main.c -lpthread -o a.out 。</span><br></pre></td></tr></table></figure><p>虽然使用的是cmake然后make 不确定编译器, 但我感觉应该试一试. 因为我的软件是编译<code>network.a</code>的时候报错,<br>结果我改成了如下<br><code>target_link_libraries(Guess network game -ljsoncpp)</code><br>发现报错消失了……</p><p>以前一直没有在意这里的顺序问题. 现在知道了问题所在 去搜索target_link_libraries顺序问题<br>找到了一堆解释 哎….</p><p>2020年2月7日18:10:20<br>终于把头文件互相引用给搞明白了, 感觉这篇博客写的还可以吧, 就发到了<a href="https://blog.csdn.net/qq_26790181/article/details/104213520" target="_blank" rel="noopener">csdn上面</a>,自己的博客上也会发的. 就先这样吧<br>今天的第三项任务完成了, 概第四项任务了Git</p><p>2020年2月7日22:17:41<br>今天的任务完成了 还发现一个联系git的网站… 真的是纯偶然发现的<a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">这个</a><br>大创那里今天看了下文档 找了找模板 还可以吧 明天的话</p><ol><li>游戏把服务器端写完 一半</li><li>把找到的大创模板改到springboot上面去  后续再套</li><li>练习并搞懂两道中等算法题目</li><li>在有时间的话把牛客整理了</li></ol><h2 id="八日九日-2020年2月9日18-04-35"><a href="#八日九日-2020年2月9日18-04-35" class="headerlink" title="八日九日 2020年2月9日18:04:35"></a>八日九日 2020年2月9日18:04:35</h2><p>简单写下吧, 昨天 不小心挂彩了, 还好运气还好, 没有太大的伤, 不然特别时期真的难搞.<br>不幸中的万幸</p><p>今天一天都没写代码 或许明天会好一些把</p><h1 id="十日"><a href="#十日" class="headerlink" title="十日"></a>十日</h1><p>2020年2月10日10:02:22<br>今天问题不大了, 继续写游戏的服务器<br>写完服务器后, 做算法题吧</p><h1 id="十四日"><a href="#十四日" class="headerlink" title="十四日"></a>十四日</h1><p>昨天基本问题就不大了, 眼睛周围青了一圈成了大熊猫, 经过四天的休息 看东西倒是不流眼泪了.<br>今天的话, 实际的学习方面有</p><p>终于自己还是要找开源项目看看了, 不过今天2020年2月14日17:08:40头脑不是很清醒, 中午没有睡好. 看了个大概就没看了<br><a href="http://tengine.taobao.org/book/chapter_02.html" target="_blank" rel="noopener">nginx剖析</a></p><p>偶尔发现了一本书, 这不就是我想要看的吗!!!!!!, 准备看这本书 这本书从输入网址到网页返回都很详细的写了写<br><img src="https://pic2.zhimg.com/v2-1336c859990173751b77ad9eb4318602_r.jpg" alt=""></p><h1 id="十五日"><a href="#十五日" class="headerlink" title="十五日"></a>十五日</h1><p>理论上大二寒假就要过完了. 昨天晚上想了很多</p><p>先说一下游戏把: 感觉自己不喜欢玩手机游戏了, 手机游戏非肝即氪 自己没有时间去肝游戏, 肝游戏不会给你工作, 自己没有钱去氪金, 自己又非.抱着这种念头时间长了, 自己对游戏更加提不起兴趣了. 而我又想去做游戏, 一个不想玩游戏的人能做游戏吗? 虽说我的不想玩是在各种因素长时间影响下形成的.</p><p>再说下我对编程吧: 怎么说呢, 我在大二上学期的上半学期之前, 都很喜欢写代码的, 我能在电脑前面坐上一整天. 后来我对代码提不起兴趣了. 原因的话昨天晚上整理了下.</p><ol><li>目的不同了: 我在大二上学期的上半学期之前(包括大一整个学期)都是抱着解决某个问题去写软件的, 说起来是为自己写代码?首先就是我学的Javaweb为了解决校园网登录难的问题, 我用Java写一个客户端, 同时配上了后台和下载站(用的阿里云的OSS). 我记得的那段时间真的快乐. 后面我又为解决手动签到的问题, 做了个签到软件, 也是如此.——后来我学习的目的就是为了增进自己的知识(目的只有一个–进入大公司), 变成了为了学而学(之所以为了学而学是感觉时间真的有限, 我想在大三暑假能够实习, 我只有一年半的时间), 而不是之前, 通过做自己喜欢的东西不会了就去补一补. 长时间这样学习我大二上整个学期一个正经的项目都没有, 长时间为了学而学消磨了我的兴趣??</li><li>我发现我现在好像失去了对编程的乐趣, 现在写项目总想写出更优的结构, 总想写出大项目, 然而我的能力不足. 想实现和无法实现的思想一直持续着, 也是消磨的原因之一? 我现在在想我是不是期初就对linux服务器不感兴趣? 可我感觉当初自己确实想去的, 我想着游戏行业的人员兴趣基本相同, 能够一起做游戏,一边骂着策划脑洞一边做2333, 而不是做自己不喜欢的网站后端, 我发现目前自己都是一个人学习, 一个人做着, 何谈团队的乐趣?</li></ol><p>症状就如上了, 自己也得想想办法了.</p><ol><li>首要任务找个人(找个团队)一起做游戏吧, 自己一个人的话, 说不上我向往的一起写代码的氛围</li><li>找到团队之后, 就能通过一边做游戏一边学习自己的不足了</li><li>我长时间的学习, 做不出自己满意的项目也是原因之一吧.</li><li>手机游戏的话, 暂时不去玩网游了. 我自己更适合单机? 找人做独立游戏?? emm不错</li></ol><h1 id="十六日"><a href="#十六日" class="headerlink" title="十六日"></a>十六日</h1><p>爆肝学习了一天3dmax , 现在是会基本的操作 能够完成一些简单的建模了.</p><p>从B站找个那个课程也是很不错<br><a href="https://www.bilibili.com/video/av18210293/" target="_blank" rel="noopener">3Dmax2018零基础入门教程（第一，二，三，四，五阶段）</a></p><p>一天的事件我就从 P0看到了    P51 过得很快, 但感觉掌握的还能接受</p><hr><table><thead><tr><th>按键</th><th>功能</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td>shift</td><td>绘制直线</td></tr><tr><td>删除键</td><td>可以回退一次</td></tr><tr><td></td><td></td></tr><tr><td>W</td><td>移动</td></tr><tr><td>E</td><td>旋转</td></tr><tr><td>R</td><td>缩放</td></tr><tr><td></td><td></td></tr><tr><td>F3</td><td>线框显示模式</td></tr><tr><td>F4</td><td>实体+线框限时模式</td></tr><tr><td></td><td></td></tr><tr><td>Shift</td><td>按住可以复制</td></tr><tr><td></td><td></td></tr><tr><td>Alt+T+A</td><td>阵列</td></tr><tr><td>Alt+T+M</td><td>镜像</td></tr><tr><td>Alt+A+对齐</td><td></td></tr><tr><td>Shitf+I</td><td>间隔工具</td></tr><tr><td></td><td></td></tr><tr><td>Ctrl+X</td><td>专家模式, 隐藏所有多余的东西 获得最大的空间</td></tr><tr><td>Alt+X</td><td>半透明显示</td></tr><tr><td>Ctrl+Shift+X</td><td>变换虚拟体显示切换 可以看到变换虚拟体的明显变化</td></tr><tr><td>O</td><td>自适应降级</td></tr></tbody></table><p><strong>编辑样条线-&gt;顶点</strong><br>优化 在线上添加点<br>焊接 连接两点<br>自动焊接 两点在距离之内自动焊接</p><p><strong>车削修改器</strong><br>将二维图形 指定一个轴然后旋转 得到立体图形</p><p><strong>可编辑多边形</strong><br><em>细分曲面</em><br>迭代次数2-3<br>无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)<br><em>细分置换-经常使用置换网格WSM修改器</em><br>需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图<br><em>绘制变形-未学-用于雕刻地形</em><br><strong>倒角剖面和扫描的区别</strong></p><ol><li>结合点不同</li><li>倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓</li><li>倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.</li></ol><hr><p>好了暑假也算是结束了</p><p>哦对了 我还在做一个游戏 从YouTube上看到一个打砖块游戏.<br>这只是开始, 因为我是做服务器的所以我要把游戏改成双人联机哒!!!!目前进展还不错</p><p>我打算模仿一个知乎大佬在知乎更新下专栏? 貌似可以诶</p><p>网上讲解服务器的不少 讲解客户端的不少  讲解一套的就少了</p><p>好了博客整理下 寒假结束了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在是&lt;code&gt;2020年2月1日17:32:50&lt;/code&gt; 寒假过半? 目前还不知道寒假什么时候开学. 为了自己能够前往心目中的公司, 学习是必不可少的.&lt;br&gt;学习的同时 应该要注意总结, 防止一天或者一周下来白忙活&lt;br&gt;我们寒假开始是一月九号 到我开始寒假学习
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://blog.lsmg.xyz/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>编程规范</title>
    <link href="http://blog.lsmg.xyz/2020/01/CPP-CPP%E9%87%8D%E7%82%B9-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <id>http://blog.lsmg.xyz/2020/01/CPP-CPP%E9%87%8D%E7%82%B9-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</id>
    <published>2020-01-23T11:35:50.502Z</published>
    <updated>2020-01-23T11:34:45.214Z</updated>
    
    <content type="html"><![CDATA[<p><strong>第一点</strong><br>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="keyword">namespace</span> foo_bar &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;  <span class="comment">// namespace foo_bar</span></span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Function2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace myproject</span></span><br></pre></td></tr></table></figure><p><strong>第二点</strong><br>局部变量应当声明和初始化同时进行, 推荐使用C++11的花括号</p><p><em>如果在循环中, 不要将对象的声明放入其中</em>, 每次进入作用域都会调用构造函数, 每次退出都会调用析构函数</p><p><strong>第三点-类相关</strong><br>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p><p>不要定义隐式类型转换. </p><p>对于转换运算符和单参数构造函数, 请使用 explicit 关键字.</p><ul><li>单参数构造函数有可能会被无意地用作隐式类型转换.</li></ul><p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p><ul><li>MyClass(const MyClass&amp;) = delete;<br>MyClass&amp; operator=(const MyClass&amp;) = delete;</li></ul><p>仅当<code>只有</code>数据成员的时候<code>struct</code>, <code>其他一律</code>使用class</p><p>使用组合常常比使用继承更合理</p><ul><li>所有的继承<code>必须是public</code>, </li></ul><p>多重继承(真正需要的时候很少)</p><ul><li>最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.</li></ul><p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量</p><ul><li>重载运算符, 容易造成代码混乱, 因为没有统一的重载规范</li></ul><p>数据成员都必须是私有的</p><p><strong>第四点-函数相关</strong></p><p>输入参数在先, 后跟输出参数.</p><p>编写简短函数</p><p>所有按引用传递的参数必须加上 const.</p><p>函数重载</p><ul><li>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,<br>而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</li><li>如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.</li></ul><p>省却参数</p><p>函数返回类型后置语法</p><ul><li><code>auto foo(int x) -&gt; int</code> 对于简单的类型, 优点体现不出</li><li>对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别?????.</li></ul><p><strong>杂项</strong><br>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p><p><strong>第五点命名-版本最多的地方</strong></p><p>文件命名</p><ul><li>全部小写包含<code>_</code>最好</li><li>C++ 文件要以 .cc 结尾, 头文件以 .h 结尾.</li></ul><p>类型名称 - 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数</p><ul><li>类型名称的每个单词首字母均大写, 不包含下划线<code>MyExcitingClass</code></li></ul><p>变量命名</p><ul><li>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾</li></ul><p>常量命名</p><ul><li>字母k开头</li><li>声明为 constexpr 或 const</li></ul><p>函数命名</p><ul><li>每个单词首字母大写, 没有下划线</li><li>首字母缩写的单词, 经常对其的第一个字母大写</li></ul><p>命名空间命名</p><ul><li>小写字母命名</li></ul><p>枚举命名</p><ul><li>枚举的命名应当和 常量 或 宏 一致: kEnumName</li></ul><p><strong>第六点-格式</strong></p><p>缩进两个空格</p><p>函数定义与声明</p><ul><li>左圆括号总是和函数名在同一行.(没有标准,,,,,,,,,, emmm 我想我还是换行吧 不过对于else换行挺难受的)</li><li>函数名和左圆括号间永远没有空格.</li><li>圆括号与参数间没有空格.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;第一点&lt;/strong&gt;&lt;br&gt;有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. &lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP重点" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E9%87%8D%E7%82%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>游戏知识-服务器-服务器通信</title>
    <link href="http://blog.lsmg.xyz/2019/12/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1/"/>
    <id>http://blog.lsmg.xyz/2019/12/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E6%9C%8D%E5%8A%A1%E5%99%A8-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1/</id>
    <published>2019-12-22T12:50:02.000Z</published>
    <updated>2020-01-03T12:40:21.234Z</updated>
    
    <content type="html"><![CDATA[<p>由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面<br><a href="https://gameinstitute.qq.com/course/detail/10096" target="_blank" rel="noopener">服务器通信</a></p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>作业型-单纯多个client对一个server .. 比如我开始写过的聊天室程序</p><h1 id="CS通信"><a href="#CS通信" class="headerlink" title="CS通信"></a>CS通信</h1><p><img src="" alt="浏览器访问过程"><br>DNS协议-基于UDP协议</p><p>TCP<br>面向连接的可靠的有时序性的-流式协议<br>窗口管理<br>流量控制<br>数据确认<br>UDP<br>无连接不保证可靠性的无法保证时序-报文协议</p><p>QQ-CS<br>网络状况较好-UDP????-好吧还是处理了<br>网络状况差-TCP<br>大文件-TCP-TCP适合大文件交互, 因为他保持连接流式协议~</p><p>微信-CS<br>前台运行-TCP长连接<br>后台运行-TCP短连接<br>查看文章-HTTP(TCP短连接)</p><p>QQ-早期产品, 花最少的前~榨干性能<br>微信-腾讯后期产品</p><hr><p>字符串<br>自定义<br>Protobuf</p><p>序列化反序列化.</p><p>UDP协议-不要让单个包的数据量超过1K, 否则会由于分片等 导致一个大包一旦一个分片失败就都失败</p><p>存在的问题</p><ol><li>客户端和服务端数据一直对不上<br>可能是字节序的问题 - 字节序转换(网络字节数传送)</li><li>服务器发送的数据延迟-小包<br>NAGLE算法-小包并不是立即发送-等存多了在一起发送-可以禁用掉~~</li><li>数据较大或者网络波动<br>发送缓冲区慢了.. 适当加大发送缓冲区</li></ol><p>非阻塞IO<br>O_NONBLOCK<br>多路复用<br>select<br>poll<br>epoll</p><h1 id="SS通信"><a href="#SS通信" class="headerlink" title="SS通信"></a>SS通信</h1><p><img src="" alt="服务器间通信"><br>TCP-最常用<br>UDP-非关键数据-日志服务-内网通信网络状况好可以超过MTU<br>非SOCKET通信-进程间通信?-管道-信号-共享内存-信息队列-文件..</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面&lt;br&gt;&lt;a href=&quot;https://gameinstitute.qq.com/course/detail/10096&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;服务器通信&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="游戏知识" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="服务器" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>游戏知识-杂谈-如何进入游戏开发行业</title>
    <link href="http://blog.lsmg.xyz/2019/12/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E6%9D%82%E8%B0%88-%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E8%A1%8C%E4%B8%9A/"/>
    <id>http://blog.lsmg.xyz/2019/12/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86-%E6%9D%82%E8%B0%88-%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E8%A1%8C%E4%B8%9A/</id>
    <published>2019-12-22T12:50:02.000Z</published>
    <updated>2020-01-03T12:40:21.235Z</updated>
    
    <content type="html"><![CDATA[<p>由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面<br><a href="https://gameinstitute.qq.com/course/detail/10156" target="_blank" rel="noopener">想做游戏吗？如何开始我的游戏开发职业生涯</a></p><a id="more"></a><p>做游戏不会重复做同样的工作, 项目不同</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面&lt;br&gt;&lt;a href=&quot;https://gameinstitute.qq.com/course/detail/10156&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;想做游戏吗？如何开始我的游戏开发职业生涯&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="游戏知识" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/"/>
    
      <category term="杂谈" scheme="http://blog.lsmg.xyz/categories/%E6%B8%B8%E6%88%8F%E7%9F%A5%E8%AF%86/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>指针</title>
    <link href="http://blog.lsmg.xyz/2019/11/CPP-CPP%E5%9F%BA%E7%A1%80-%E6%8C%87%E9%92%88/"/>
    <id>http://blog.lsmg.xyz/2019/11/CPP-CPP%E5%9F%BA%E7%A1%80-%E6%8C%87%E9%92%88/</id>
    <published>2019-11-07T14:26:22.000Z</published>
    <updated>2020-01-23T11:35:12.218Z</updated>
    
    <content type="html"><![CDATA[<p>指针的话, 自己是要学会自己去理解各种组合. 首先只要定义复杂指针肯定会涉及到运算符优先级<br>根据运算符优先级判断这个定义的含义</p><h1 id="指针的定义识别"><a href="#指针的定义识别" class="headerlink" title="指针的定义识别"></a>指针的定义识别</h1><h2 id="由运算符优先级判断"><a href="#由运算符优先级判断" class="headerlink" title="由运算符优先级判断"></a>由运算符优先级判断</h2><p>下面列出常见到的运算符</p><p><code>[]</code>中括号这个的优先级最高, 跟括号并列.(排除域运算符).<br>    从左到右的结合性 -意味着<code>p[]</code>中<code>[]</code>会先跟<code>p结合</code>而不是中括号右边的内容<br><code>()</code>与之结合成为函数<br>    从左到右的结合性<br><code>*</code>其次是这个符号<br>    从右到左的结合性</p><p>两个大头<br><code>int *p[3]</code>和<code>int (*p)[3]</code><br>前者由于<code>[]</code>的优先级更高p与之结合说明p是<strong>数组*</strong>得到p本质是什么 数组OR指针*<br>再与<code>*</code>结合说明<strong>数组中的元素</strong>是<strong>指针*</strong>第二次结合 如果第一次是数组-则为数组中的内容, 第一次是指针-则为指针的指向*<br>再与int结合 说明数组中<strong>指针指向</strong>的是int</p><p>后者<code>*</code>先与p结合说明p是一个<strong>指针</strong><br>再与<code>[]</code>结合说明<strong>指针指向</strong>的内容是<strong>数组</strong><br>再与int结合说明<strong>数组中的内容</strong>是int</p><hr><p>本质上定义函数相关的也可以这样理解<br><code>int p(int)</code>和<code>int (*p)(int)</code><br>前者p先与<code>()</code>结合说明p是一个<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p><p>后者p先与<code>*</code>结合说明p是一个<strong>指针</strong><br>与<code>()</code>结合说明<strong>指针指向</strong>的是<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p><h2 id="判断指针的类型"><a href="#判断指针的类型" class="headerlink" title="判断指针的类型"></a>判断指针的类型</h2><p>去除指针声明语句中的指针名称, 剩下的部分就是指针的类型.<br><code>int* p</code>得到<code>int*</code>, 说明指针的类型是<code>int*</code><br><code>int (*p)[3]</code> 说明指针的类型是<code>int (*)[3]</code></p><h2 id="指针指向的类型"><a href="#指针指向的类型" class="headerlink" title="指针指向的类型"></a>指针指向的类型</h2><p>去除指针声明语句中的指针名称, 以及名称左边的指针声明符<em>, 剩下的部分是指针指向的类型<br>`int</em> p<code>得到</code>int<code>说明指针指向的类型就是</code>int<code></code>int (*p)[3]<code>得到</code>int()[3]<code>说明指针指向的类型就是</code>int()[3]`</p><h2 id="指针的值"><a href="#指针的值" class="headerlink" title="指针的值"></a>指针的值</h2><p>指针存储的即为指向一个内存区域的地址值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;指针的话, 自己是要学会自己去理解各种组合. 首先只要定义复杂指针肯定会涉及到运算符优先级&lt;br&gt;根据运算符优先级判断这个定义的含义&lt;/p&gt;
&lt;h1 id=&quot;指针的定义识别&quot;&gt;&lt;a href=&quot;#指针的定义识别&quot; class=&quot;headerlink&quot; title=&quot;指针的定
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP基础" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>C++薄书整理</title>
    <link href="http://blog.lsmg.xyz/2019/10/CPP-CPP%E5%9F%BA%E7%A1%80-2/"/>
    <id>http://blog.lsmg.xyz/2019/10/CPP-CPP%E5%9F%BA%E7%A1%80-2/</id>
    <published>2019-10-20T11:13:22.000Z</published>
    <updated>2020-01-31T08:07:47.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义新量"><a href="#定义新量" class="headerlink" title="定义新量"></a>定义新量</h1><p>auto 自动根据初始值的类型进行自动类型推导.<br>decltype 根据表达式的类型定义对象</p><p>右值引用, 操纵右值对象<br><code>std::move()</code>, 可以将一个</p><p><strong>枚举</strong><br>不限定作用域的定义<br>enum color {red, green, blue};<br>限定在类型内部的作用域<br>enum class color {red, green, blue};<br><code>color a = color::red</code></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>数组传参的长度处理</p><ul><li>直接传递数组长度</li><li>使用C风格字符串(默认结尾有标志)</li><li>使用C++11的新函数begin()和end()同时传递首尾地址</li></ul><p>函数指针<br><code>bool (*pf)(int, int)</code> 可以指向<br><code>bool max(int a,int b)</code><br>调用 <code>pf(1, 1)</code>即可<br>常用于函数的参数是一个函数的返回值</p><p><strong>Lambda</strong><br><code>[]() -&gt; return type {statements}</code><br>中括号代表lambda引导, 其中的captures子句在同一作用域下lambda主体捕获(访问)哪些对象<br>以及如何捕获这些对象</p><ul><li>可以为空, 不会访问外围对象</li><li>[=] 代表用值捕获的方式</li><li>[&amp;] 代表引用捕获</li></ul><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p><strong>辅助函数</strong><br>定义辅助函数, 有点像Java里面的重写toString()函数(最常见的代表的例子)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">os &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元函数</strong><br>一个类的辅助函数从概念上可以看成类的接口, 虽然和类的关系很密切, 但并不是类的成员, 所以不能直接访问私有成员<br>C++ 中可以将该类函数声明为该类的友元.<br>这样就能访问到类的非公有成员.<br>在函数的前面加上<code>friend</code>关键字<br><strong>友元类</strong><br>如果A想访问B的私有成员, 可以在B内声明<code>friend class A</code>, 这样就可以在B内访问A的私有成员<br><em>友元关系是单向的, 不具有交换性, 同时也不具有传递性</em></p><p><strong>构造函数</strong><br>默认构造函数没有参数, 或者所有的参数都具有默认值<br>C++11允许在显示定义构造函数的情况下使用默认构造函数<br>需要在默认构造函数后面加上<code>= default</code><br><em>使用默认构造函数创建类对象时, 切忌在对象名后I使用圆括号, 成了一个函数声明</em></p><p><strong>初始值列表</strong><br>T(int a, int b):a_(a), b_(b){}<br>引用和const修饰的必须用初始值列表初始化, 初始的顺序取决于数据成员在类内的定义顺序,<br>而非初始值列表的顺序</p><p><strong>简化构造函数</strong><br>实际将自己的带参构造函数, 给定默认值, 这样就实现了默认构造函数和带参构造函数的合并</p><p><strong>复制构造函数</strong><br>参数为该类的引用</p><p><strong>委托构造函数</strong><br>减少构造函数代码量<br>实际就是一个构造函数后面加上<code>:</code>调用另一个构造函数, 同时传入参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> bar1_;</span><br><span class="line"><span class="keyword">int</span> bar2_;</span><br><span class="line">A(<span class="keyword">int</span> b1):A(b1, <span class="number">2</span>)&#123;&#125;</span><br><span class="line">A(<span class="keyword">int</span> b1, <span class="keyword">int</span> b2):bar1_(b1), bar2_(b2)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运算符重载</strong><br>T operator /(A, B);<br>双目运算符两个参数<br>单目运算符一个参数<br>对于二元运算符, 左侧运算对象传递给第一个参数, 右侧运算对象传递给第二个参数.</p><p>运算符重载的声明和定义的分离<br>放在类成员中的运算符重载, 需要算入默认的this指针参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>+(<span class="keyword">const</span> Test&amp; right);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAB</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a_;</span><br><span class="line"><span class="keyword">int</span> b_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line">Test::Test(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    a_ = a;</span><br><span class="line">    b_ = b;</span><br><span class="line">&#125;</span><br><span class="line">Test&amp; Test::<span class="keyword">operator</span>+(<span class="keyword">const</span> Test&amp; right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Test <span class="title">test</span><span class="params">(<span class="keyword">this</span>-&gt;a_ + right.a_, <span class="keyword">this</span>-&gt;b_ + right.b_)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test::PrintAB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a_, b_);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">test1</span><span class="params">(<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Test <span class="title">test2</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    Test test = test1 + test2;</span><br><span class="line">    test.PrintAB();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ++ -- </span></span><br><span class="line">Test&amp; <span class="keyword">operator</span>++(); <span class="comment">// 前置版本</span></span><br><span class="line">Test <span class="keyword">operator</span>++(<span class="keyword">int</span>); <span class="comment">// 后置版本</span></span><br></pre></td></tr></table></figure><p><strong>类成员指针</strong><br><em>数据成员指针</em> (private不能通过指针访问)<br>其值是数据成员所在地址相对于对象起始地址的偏移值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A T::*p1 = &amp;T::x</span><br><span class="line"><span class="keyword">int</span> A::*p1 = &amp;A::value</span><br><span class="line">A a;</span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line">a.*p = ......................;</span><br></pre></td></tr></table></figure><p>p1指向T类中的 A类型的x数据成员<br><code>A T::</code>可以用<code>auto</code></p><p><em>成员函数指针</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (A::*pf)();</span><br><span class="line">pf = &amp;A::GetValue;</span><br><span class="line"><span class="comment">// 当然可以使用auto 来简化</span></span><br><span class="line"><span class="keyword">auto</span> pf2 = &amp;A::GetValue;</span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line">(a.*pf)();</span><br></pre></td></tr></table></figure><hr><p>统一初始化<br><code>X x1 = {0} 和 X x2 {0}</code> 这两种是不同的实现!!, 大多数情况下这两个是相通的, 然而当<br><code>explicit构造函数</code>存在的时候<code>前者的初始化是错误的</code></p><p><code>int x{0} int x= 0 int x(0)</code> 最后一个是错误的可能会和函数声明冲突</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">z</span><span class="params">(x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还存在一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; a1&#123;<span class="number">0</span>&#125;; <span class="comment">// OK</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; a3 = <span class="number">0</span>; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>这个错误的原因是copy-initialization引起的<br>这个copy-initialization发生在<code>T x = a</code>的声明, 下面我把原博客的部分重要英文替换成中文或代码描述<br><code>std::atomic&lt;int&gt; a3 = 0</code> 从<code>int类型</code>赋值到<code>可能是 cv-qualified</code>的<code>class type</code><br><a href="https://stackoverflow.com/questions/27527642/what-does-cv-qualified-mean" target="_blank" rel="noopener">cv-qualified</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ***cv-qualified***</span></span><br><span class="line"><span class="comment">// non cv_qualified</span></span><br><span class="line"><span class="keyword">int</span> first; </span><br><span class="line"><span class="keyword">char</span> *second; </span><br><span class="line"></span><br><span class="line"><span class="comment">// cv-qualified </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> third; </span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">char</span> * fourth;</span><br></pre></td></tr></table></figure><p><code>std::atomic&lt;int&gt; a3 = 0</code> 满足了这个条件属于<code>copy-initialization</code><br><a href="https://www.quora.com/What-is-the-difference-between-copy-initialization-and-direct-initialization-of-objects-in-c++" target="_blank" rel="noopener">copy-initialization</a><br><a href="https://blog.csdn.net/ljianhui/article/details/9245661" target="_blank" rel="noopener">直接初始化和复制初始化的区别</a><br>直接初始化会直接用参数生成对象, 而复制初始化会<code>用参数生成临时对象, 然后将这个对象复制到正要创建的对象</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        A () &#123; &#125; <span class="comment">//直接初始化会调用这个构造函数</span></span><br><span class="line">        A (<span class="keyword">const</span> A&amp; a) &#123; &#125; <span class="comment">//复制初始化会调用这个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来需要通过<code>std::atomic&lt;int&gt;(int)</code>把0转换成成一个纯右值(prvalue)的临时对象<br><a href="https://zh.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener">纯右值</a><br><a href="https://www.cnblogs.com/zpcdbky/p/5275959.html" target="_blank" rel="noopener">纯右值</a><br>然后再将这个临时对象用直接初始化(调用复制构造函数), 然而<code>std::atomic&lt;int&gt;</code>把拷贝<br>构造函数给禁用了, 就会出错<br><code>std::atomic&lt;int&gt; a3 {0}</code>这个会直接调用接收int的构造函数</p><p>回到<code>X x1 = {0}</code>这里, 这个表达式是一个复制构造, 用一个braced-init-list(指的{0}).<br>这里有两个阶段<br>首先是会把单个参数的构造函数汇总起来(得到A-list)供选择, 如果其中没有合适的构造函数, 再将候选列表<br>转换为所有构造函数</p><p>如果如果A-list没有构造函数, 并且class T存在默认构造函数, 第一阶段就会被忽略<br>如果在一个使用<code>{}</code>的初始化, 并且选择到了<code>explicit 构造函数头上</code>就会报错</p><p><code>explicit</code>可以防止在调用某个成员函数的时候, 实参类型(通过构造函数之一)自动转换成相应参数,<br>但此时这个函数需要其他的成员变量参与到函数运行, 恰巧这时所需要的其他成员变量没有得到合适的初始化, 就会发生错误(没有得到合适初始化的原因就是, 自动调用了不合适的构造函数生成了这个函数所需要的参数(一般是对象))</p><p>@2019年10月26日21:25:58@算是第一次解决一个环环相扣的问题, 精力有点不足了<br><a href="https://zhuanlan.zhihu.com/p/21102748" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21102748</a> 后续会继续进行理解<br><a href="https://blog.csdn.net/spaceyqy/article/details/22730939" target="_blank" rel="noopener">这里还发现一个</a></p><h1 id="模板-泛型-动态内存-数据结构"><a href="#模板-泛型-动态内存-数据结构" class="headerlink" title="模板, 泛型 动态内存, 数据结构"></a>模板, 泛型 动态内存, 数据结构</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">const</span> T&amp; <span class="title">GetMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; GetMax(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; GetMax&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 显示指定模板类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/C%2B%2B%E5%86%85%E5%AD%98.png" alt=""><br>C++堆的内存需要手动new和delete, 如果一个对象new出来没有在能被释放的时候释放就会造成–<strong>内存泄漏</strong>(需要及时delete不需要的对象)<br>一个指向动态内存的指针, 在动态内存被释放后, 指针依然指向原来的地址–<strong>空悬指针</strong>(释放内存后将相应的指针设置为nullptr)</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义新量&quot;&gt;&lt;a href=&quot;#定义新量&quot; class=&quot;headerlink&quot; title=&quot;定义新量&quot;&gt;&lt;/a&gt;定义新量&lt;/h1&gt;&lt;p&gt;auto 自动根据初始值的类型进行自动类型推导.&lt;br&gt;decltype 根据表达式的类型定义对象&lt;/p&gt;
&lt;p&gt;右值引用,
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP基础" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>牛客整理</title>
    <link href="http://blog.lsmg.xyz/2019/10/CPP-CPP%E5%9F%BA%E7%A1%80-%E7%89%9B%E5%AE%A2/"/>
    <id>http://blog.lsmg.xyz/2019/10/CPP-CPP%E5%9F%BA%E7%A1%80-%E7%89%9B%E5%AE%A2/</id>
    <published>2019-10-19T04:31:37.000Z</published>
    <updated>2020-01-23T11:35:08.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运算出结果类"><a href="#运算出结果类" class="headerlink" title="运算出结果类"></a>运算出结果类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">200</span>;</span><br><span class="line">a+=<span class="number">27</span>;sum+=a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br></pre></td></tr></table></figure><p>a为 -128~127<br> 127  = 0111 1111<br>“128”= 1000 0000 (-128的补码)</p><p>关于1000 0000代表-128 我偶然发现一个博客有种恍然大悟的感觉<br><a href="https://blog.csdn.net/daiyutage/article/details/8575248" target="_blank" rel="noopener">浅析为什么char类型的范围是 —128~+127</a><br>这个博客实在是写的太好了</p><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a,b,c,d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c,%c,%d,%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c,%c,%c,%c"</span>,a,b,c,d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>%c进行输入会进行转化后存入<br>输入 1 即认为输入 ‘1’ 转换成49存入</p><hr><h1 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h1><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。<br>凡是含有纯虚函数的类叫做 抽象类 。这种类不能声明对象，只是作为基类为派生类服务.<br>除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</p><h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><p>静态成员可以作为默认实参</p><h1 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h1><h1 id="基础中的基础"><a href="#基础中的基础" class="headerlink" title="基础中的基础"></a>基础中的基础</h1><p>这部分有些只保留题目, 不做解析 便于自己想象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> k = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">while</span> (k &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">--k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面三个函数全部错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void test1()</span><br><span class="line">&#123;</span><br><span class="line">    unsigned char array[MAX_CHAR+1],i; &#x2F;&#x2F; 这个函数在于MAX_CHAR可能会大于255导致i永远无法达到</span><br><span class="line">    for(i&#x3D;0;i&lt;&#x3D;MAX_CHAR;i++)&#123;</span><br><span class="line">        array[i]&#x3D;i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">char*test2()</span><br><span class="line">&#123;</span><br><span class="line">    char p[] &#x3D; &quot;hello world&quot;;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">char *p &#x3D;test2();</span><br><span class="line">void test3()&#123;</span><br><span class="line">    char str[10];</span><br><span class="line">    str++;</span><br><span class="line">    *str&#x3D;&#39;0&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="基础中的Api"><a href="#基础中的Api" class="headerlink" title="基础中的Api"></a>基础中的Api</h1><p>虽然自己还没用过, 但还是要积累</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">4</span>;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'#'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始看到这个题目, 为putchar是放到缓冲区中, 结果就是正常的输出</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;运算出结果类&quot;&gt;&lt;a href=&quot;#运算出结果类&quot; class=&quot;headerlink&quot; title=&quot;运算出结果类&quot;&gt;&lt;/a&gt;运算出结果类&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="CPP基础" scheme="http://blog.lsmg.xyz/categories/CPP/CPP%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="http://blog.lsmg.xyz/2019/10/CPP-%E6%95%B0%E6%8D%AE%E5%BA%93-MongoDB-MongoDB%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.lsmg.xyz/2019/10/CPP-%E6%95%B0%E6%8D%AE%E5%BA%93-MongoDB-MongoDB%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2019-10-13T11:25:28.000Z</published>
    <updated>2020-01-23T11:34:36.336Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://docs.mongodb.com/images/mongodb-logo.png" alt=""></p><a id="more"></a><h1 id="服务器相关"><a href="#服务器相关" class="headerlink" title="服务器相关"></a>服务器相关</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>在mongodb中基本的概念是文档、集合、数据库</p><ul><li>数据库<br>一个mongodb中可以建立多个数据库。</li><li>集合<br>集合就是 MongoDB 文档组 集合处于数据库中 文档处于集合中</li><li>文档<br>文档是一组键值(key-value)对(即 BSON)<br>文档对应数据记录的行</li></ul><h2 id="安装驱动到Centos"><a href="#安装驱动到Centos" class="headerlink" title="安装驱动到Centos"></a>安装驱动到Centos</h2><p><strong>升级cmake</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget https://cmake.org/files/v3.6/cmake-3.6.2.tar.gz    </span><br><span class="line">tar xvf cmake-3.6.2.tar.gz &amp;&amp; cd cmake-3.6.2/</span><br><span class="line">./bootstrap</span><br><span class="line"></span><br><span class="line">gmake</span><br><span class="line">gmake install（需要在su命令下执行，或者直接使用root账户安装）</span><br><span class="line">/usr/local/bin/cmake --version</span><br><span class="line"></span><br><span class="line">yum remove cmake -y</span><br><span class="line">ln -s /usr/local/bin/cmake /usr/bin/</span><br><span class="line">cmake --version</span><br></pre></td></tr></table></figure><p><strong>安装</strong></p><p><a href="http://mongoc.org/libmongoc/current/installing.html" target="_blank" rel="noopener">官方文档</a></p><h2 id="安装驱动到Centos-1"><a href="#安装驱动到Centos-1" class="headerlink" title="安装驱动到Centos"></a>安装驱动到Centos</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br><span class="line"></span><br><span class="line">yum install clang</span><br><span class="line"></span><br><span class="line"># 安装boost</span><br><span class="line">yum -y install gcc-c++ python-devel bzip2-devel zlib-devel</span><br><span class="line">tar zxvf 安装包</span><br><span class="line">sudo .&#x2F;bootstrap.sh --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;boost</span><br><span class="line">sudo .&#x2F;b2 install</span><br><span class="line">进入 目录下的tools&#x2F;build</span><br><span class="line">sudo .&#x2F;bootstrap.sh</span><br><span class="line">sudo .&#x2F;b2 install --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;boost</span><br><span class="line"></span><br><span class="line">wget https:&#x2F;&#x2F;cmake.org&#x2F;files&#x2F;v3.5&#x2F;cmake-3.5.2.tar.gz</span><br><span class="line">tar -zxvf cmake-3.5.2.tar.gz</span><br><span class="line">cd cmake-3.5.2</span><br><span class="line">.&#x2F;bootstrap</span><br><span class="line">gmake</span><br><span class="line">gmake install</span><br><span class="line"></span><br><span class="line"># 删除原来cmake版本，建立软连接，测试</span><br><span class="line">yum remove cmake -y</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;cmake &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">cmake --version</span><br><span class="line"></span><br><span class="line"># 安装pip</span><br><span class="line">yum install python-pip</span><br><span class="line">pip install --upgrade pip</span><br><span class="line"></span><br><span class="line"># 安装py3</span><br><span class="line">https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000015628625</span><br></pre></td></tr></table></figure><h2 id="安装到Ubuntu-18-04"><a href="#安装到Ubuntu-18-04" class="headerlink" title="安装到Ubuntu 18.04"></a>安装到Ubuntu 18.04</h2><p><a href="https://docs.mongodb.com/manual/administration/install-on-linux/" target="_blank" rel="noopener">整理自官方文档</a></p><ul><li>导入公共秘钥, 另你的系统”信任”下面的包<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -</span><br></pre></td></tr></table></figure>这一步需要显示OK</li><li>导入第三方MongoDB源<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list</span><br></pre></td></tr></table></figure></li><li>导入源之后更新<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li><li>安装MongoDB稳定版本包(我安装的时候稳定版本为4.2)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y mongodb-org=4.2.0 mongodb-org-server=4.2.0 mongodb-org-shell=4.2.0 mongodb-org-mongos=4.2.0 mongodb-org-tools=4.2.0</span><br></pre></td></tr></table></figure></li><li>禁用apt-get自动更新MongoDB<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo "mongodb-org hold" | sudo dpkg --set-selections</span><br><span class="line">echo "mongodb-org-server hold" | sudo dpkg --set-selections</span><br><span class="line">echo "mongodb-org-shell hold" | sudo dpkg --set-selections</span><br><span class="line">echo "mongodb-org-mongos hold" | sudo dpkg --set-selections</span><br><span class="line">echo "mongodb-org-tools hold" | sudo dpkg --set-selections</span><br></pre></td></tr></table></figure><h2 id="基础shell操作"><a href="#基础shell操作" class="headerlink" title="基础shell操作"></a>基础shell操作</h2></li></ul><p><strong>启动 关闭 重启</strong><br><code>sudo service mongod start(stop\restart)</code></p><p><em>启动成功标志</em><br>日志文件<code>/var/log/mongodb/mongod.log</code>中显示<code>waiting for connections on port 27017</code></p><p><strong>进入交互式命令行</strong><br><code>mongo</code></p><p><strong>指定端口运行 默认27017</strong><br><code>mongo --port 28015</code></p><p><strong>非安装机通过shell连接安装机</strong><br><a href="https://docs.mongodb.com/manual/mongo/#mongodb-instance-on-a-remote-host" target="_blank" rel="noopener">直连</a><br><a href="https://docs.mongodb.com/manual/mongo/#mongodb-instance-with-authentication" target="_blank" rel="noopener">带登录验证</a></p><hr><p><strong>显示你正在使用的数据库</strong><br><code>db</code><br><strong>切换数据库</strong><br><code>use &lt;database&gt;</code></p><h3 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h3><p><strong>C</strong></p><p><em>插入一个文档</em><br><code>db.collection.insertOne()</code><br>这里的collection代指的一个集合, 集合的名字可以自定义如果集合并不存在你的数据库中 则自动创建这个集合.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.insertOne(</span><br><span class="line">   &#123; item: "canvas", qty: 100, tags: ["cotton"]&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><hr><p><em>插入多个文档</em><br><code>db.inventory.insertMany()</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.inventory.insertMany([</span><br><span class="line">   &#123; item: "journal", qty: 25, tags: ["blank", "red"]&#125;,</span><br><span class="line">   &#123; item: "mat", qty: 85, tags: ["gray"]&#125;,</span><br><span class="line">   &#123; item: "mousepad", qty: 25, tags: ["gel", "blue"]&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><hr><p><em>插入任意项的文档</em><br><code>db.collection.insert()</code></p><hr><p><em>_id项</em><br>每一个文档都有自己独一的id 如果插入文档的时候没有指定则会生成随机的<code>_id</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; "_id" : ObjectId("5da325520e80dfd9258a29be"), "x" : 1 &#125;</span><br></pre></td></tr></table></figure><p>可以通过在插入的时候指定<code>&quot;_id&quot;: xxxx</code>来自定义id</p><p><a href="https://docs.mongodb.com/manual/reference/insert-methods/#additional-methods-for-inserts" target="_blank" rel="noopener">额外的方法</a></p><p><strong>R</strong><br><code>db.collection.find({ item: &quot;canvas&quot; })</code><br><a href="https://docs.mongodb.com/manual/core/document/#document-query-filter" target="_blank" rel="noopener">拦截器-</a>在collection中查找含有<code>item: &quot;canvas&quot;</code>的文档, 并打印<br>如果不含<code>{ item: &quot;canvas&quot; }</code>则代表打印所有的文档</p><p><code>db.collection.find({status: {$in: [ &quot;A&quot;, &quot;D&quot; ]}})</code><br><code>status: {$in: [ &quot;A&quot;, &quot;D&quot; ]}</code>意为A, D不在此status中</p><p><code>db.inventory.find( { status: &quot;A&quot;, qty: { $lt: 30 } } )</code><br><code>qty: { $lt: 30 }</code>意为此qty的值少于30</p><p><code>db.inventory.find( { $or: [ { status: &quot;A&quot; }, { qty: { $lt: 30 } } ] } )</code><br><code>{$or: [{ status: &quot;A&quot; }, { qty: { $lt: 30 }}]}</code>符合二者之一</p><p><a href="https://docs.mongodb.com/manual/tutorial/query-embedded-documents/" target="_blank" rel="noopener">2019年10月13日21:58:24 - 开头</a></p><h1 id="C-Driver"><a href="#C-Driver" class="headerlink" title="C++ Driver"></a>C++ Driver</h1><p><a href="http://mongocxx.org/mongocxx-v3/installation/" target="_blank" rel="noopener">照着官方文档安装了下</a><br>期间遇到了两个坑一个是我没有安装Git导致提示无法克隆<br>还有就是最后阶段我没安装pkg-config 导致的无法找到头文件</p><p>接下来看一些简单的教程</p><h2 id="CRUD-1"><a href="#CRUD-1" class="headerlink" title="CRUD"></a>CRUD</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bsoncxx/json.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mongocxx/client.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mongocxx/stdx.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mongocxx/uri.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bsoncxx/builder/stream/helpers.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mongocxx/instance.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bsoncxx/builder/stream/document.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::stream::close_array;</span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::stream::close_document;</span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::stream::document;</span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::stream::finalize;</span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::stream::open_array;</span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::stream::open_document;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> builder = document&#123;&#125;;</span><br><span class="line"></span><br><span class="line">bsoncxx::document::value doc_value = builder</span><br><span class="line">&lt;&lt; <span class="string">"name"</span> &lt;&lt; <span class="string">"Lsmg"</span></span><br><span class="line">&lt;&lt; <span class="string">"type"</span> &lt;&lt; <span class="string">"Lemon"</span></span><br><span class="line">&lt;&lt; <span class="string">"count"</span> &lt;&lt; <span class="number">1</span></span><br><span class="line">&lt;&lt; <span class="string">"versions"</span> &lt;&lt; open_array</span><br><span class="line">&lt;&lt; <span class="string">"v3.2"</span> &lt;&lt; <span class="string">"v3.0"</span> &lt;&lt; <span class="string">"v2.6"</span></span><br><span class="line">&lt;&lt; close_array</span><br><span class="line">&lt;&lt; <span class="string">"info"</span> &lt;&lt; open_document</span><br><span class="line">&lt;&lt; <span class="string">"x"</span> &lt;&lt; <span class="number">203</span></span><br><span class="line">&lt;&lt; <span class="string">"y"</span> &lt;&lt; <span class="number">102</span></span><br><span class="line">&lt;&lt; close_document</span><br><span class="line">&lt;&lt; finalize;</span><br><span class="line"></span><br><span class="line">bsoncxx::document::view view_test = doc_value.view();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印插入内容制定key的value</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name = view_test[<span class="string">"name"</span>].get_utf8().value.to_string();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取插入ID</span></span><br><span class="line"><span class="keyword">auto</span> result = coll_test.insert_one(view_test);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> id1 = result-&gt;inserted_id().get_oid().value.to_string();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; id1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_many</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 插入多个</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;bsoncxx::document::value&gt; documents;</span><br><span class="line">documents.reserve(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">documents.push_back(document&#123;&#125; &lt;&lt; <span class="string">"i"</span> &lt;&lt; i &lt;&lt; finalize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> result = coll_test.insert_many(documents);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取多个的返回ID</span></span><br><span class="line"><span class="keyword">auto</span> id_maps = result-&gt;inserted_ids();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter : id_maps)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; iter.second.get_oid().value.to_string() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line">mongocxx::<span class="built_in">cursor</span> <span class="built_in">cursor</span> = coll_test.<span class="built_in">find</span>(&#123;&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> doc : <span class="built_in">cursor</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; bsoncxx::to_json(doc) &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_one</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">coll_test.update_one(document&#123;&#125; &lt;&lt; <span class="string">"i"</span> &lt;&lt; <span class="number">9</span> &lt;&lt; finalize,</span><br><span class="line">document&#123;&#125; &lt;&lt; <span class="string">"$set"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class="line"><span class="string">"i"</span> &lt;&lt; <span class="number">110</span> &lt;&lt; close_document &lt;&lt; finalize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_many</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">coll_test.update_many(document&#123;&#125; &lt;&lt; <span class="string">"i"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class="line">           <span class="string">"$lt"</span> &lt;&lt; <span class="number">8</span> &lt;&lt; close_document &lt;&lt; finalize,</span><br><span class="line">document&#123;&#125; &lt;&lt; <span class="string">"$inc"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class="line">           <span class="string">"i"</span> &lt;&lt; <span class="number">100</span> &lt;&lt; close_document &lt;&lt; finalize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_one</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">coll_test.delete_one(document&#123;&#125; &lt;&lt; <span class="string">"i"</span> &lt;&lt; <span class="number">110</span> &lt;&lt; finalize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete_many</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 删除存在 i： 0 的文档</span></span><br><span class="line">coll_test.delete_many(document&#123;&#125; &lt;&lt; <span class="string">"i"</span> &lt;&lt; <span class="number">0</span> &lt;&lt; finalize);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (&gt;) 大于 - $gt</span></span><br><span class="line"><span class="comment"> * (&lt;) 小于 - $lt</span></span><br><span class="line"><span class="comment"> * (&gt;=) 大于等于 - $gte</span></span><br><span class="line"><span class="comment"> * (&lt;= ) 小于等于 - $lte</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 i大于3小于8的文档</span></span><br><span class="line">coll_test.delete_many(document&#123;&#125; &lt;&lt; <span class="string">"i"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class="line">                                 <span class="string">"$gt"</span> &lt;&lt; <span class="number">0</span> &lt;&lt;</span><br><span class="line">                                 <span class="string">"$lt"</span> &lt;&lt; <span class="number">200</span> &lt;&lt;</span><br><span class="line">                                 close_document &lt;&lt; finalize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_index</span><span class="params">(mongocxx::collection coll_test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 代表生序 -1代表降序</span></span><br><span class="line"><span class="keyword">auto</span> index_specification = document&#123;&#125; &lt;&lt; <span class="string">"i"</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; finalize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// move的本质就是帮助编译器选择重载函数, 告诉编译器"请尽量把此参数当做右值来处理"</span></span><br><span class="line">coll_test.create_index(<span class="built_in">std</span>::<span class="built_in">move</span>(index_specification));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mongocxx::instance instance&#123;&#125;;</span><br><span class="line">mongocxx::client client&#123;mongocxx::uri&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line">mongocxx::database db = client[<span class="string">"mydb"</span>];</span><br><span class="line">mongocxx::collection coll_test = db[<span class="string">"test"</span>];</span><br><span class="line"></span><br><span class="line">create_index(coll_test);</span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span>(coll_test);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程安全相关"><a href="#线程安全相关" class="headerlink" title="线程安全相关"></a>线程安全相关</h2><p>不能同时对一个client的多个线程同时操作.<br>同时只能有一个线程对一个client操作, 包括对<code>mongocxx::client</code>的<code>mongocxx::client_session</code>, <code>mongocxx::database, mongocxx::collection</code>, and <code>mongocxx::cursor</code>同样如此</p><p>简单解决可以通过用同一个<code>mongocxx::uri</code>生成多个<code>mongocxx::client</code>来解决这个问题</p><p>最好的解决方法用<code>mongocxx::uri</code>生成一个<code>mongocxx::pool</code> 通过<code>mongocxx::pool</code>的<code>acquire()</code>来获取操作的client<br>官方demo如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mongocxx::instance instance&#123;&#125;;</span><br><span class="line">mongocxx::pool pool&#123;mongocxx::uri&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> threadfunc = [](mongocxx::client&amp; client, <span class="built_in">std</span>::<span class="built_in">string</span> dbname) &#123;</span><br><span class="line">  <span class="keyword">auto</span> col = client[dbname][<span class="string">"col"</span>].insert_one(&#123;&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Great! Using the pool allows the clients to be synchronized while sharing only one</span></span><br><span class="line"><span class="comment">// background monitoring thread.</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span> <span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">auto</span> c = pool.acquire();</span></span></span><br><span class="line"><span class="function"><span class="params">  threadfunc(*c, <span class="string">"db1"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  threadfunc(*c, <span class="string">"db2"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span> <span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">auto</span> c = pool.acquire();</span></span></span><br><span class="line"><span class="function"><span class="params">  threadfunc(*c, <span class="string">"db2"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">  threadfunc(*c, <span class="string">"db1"</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br></pre></td></tr></table></figure><p>关于fork的安全性<br><code>Neither a mongocxx::client or a mongocxx::pool can be safely copied when forking. Because of this, any client or pool must be created after forking, not before.</code></p><p>官方建议使用<code>mongocxx::pool</code>而不是<code>mongocxx::client</code> 即使你的应用只有一个线程<br><code>mongocxx::client</code> 每60S会检查一次自己监控的cluster, 使用前者会有专门的线程来进行检查而且是10S一次</p><p><code>mongocxx::pool</code>可以用于多线程中, 也能用来创建客户端. 然而每个<code>mongocxx::client</code>只能被一个线程使用<code>最大默认为100 最小默认为0</code></p><h2 id="BSON"><a href="#BSON" class="headerlink" title="BSON"></a>BSON</h2><p><strong>Document Builders</strong><br>一共提供了三个接口来创建文档<br>官网上提到<code>这三个接口会得到同样的结果, 选择哪个完全是由于美学</code></p><p><em>“One-off” builder functions</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> bsoncxx::builder::basic::kvp;</span><br><span class="line"><span class="comment">// &#123; "hello": "world" &#125;</span></span><br><span class="line">bsoncxx::document::value document = bsoncxx::builder::basic::make_document(kvp(<span class="string">"hello"</span>, <span class="string">"world"</span>));</span><br></pre></td></tr></table></figure><p><em>Basic builder</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> bsoncxx::builder::basic::kvp;</span><br><span class="line"><span class="comment">// &#123; "hello" : "world" &#125;</span></span><br><span class="line">bsoncxx::builder::basic::document basic_builder&#123;&#125;;</span><br><span class="line">basic_builder.append(kvp(<span class="string">"hello"</span>, <span class="string">"world"</span>));</span><br><span class="line">bsoncxx::document::value document = basic_builder.extract();</span><br><span class="line"></span><br><span class="line"><span class="comment">// basic::document builds a BSON document.</span></span><br><span class="line"><span class="keyword">auto</span> doc = builder::basic::document&#123;&#125;;</span><br><span class="line"><span class="comment">// 通过使用kvp(k, v) 来 append 键值对 to a document </span></span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::basic::kvp;</span><br><span class="line"></span><br><span class="line">doc.append(k, v); <span class="comment">// 插入一般的键值对</span></span><br><span class="line"><span class="comment">// 对于k一般为string</span></span><br><span class="line"><span class="comment">// 对于v则包含多种情况 可以使用 bsoncxx::types命名空间里的如下类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_eod</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_double</span>;</span> <span class="comment">// types::b_double&#123;3.14159&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_utf8</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_document</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_array</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_binary</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_undefined</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_oid</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_bool</span>;</span> <span class="comment">// types::b_bool&#123;false&#125;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_date</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_null</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_regex</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_dbpointer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_code</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_symbol</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_codewscope</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_int32</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_timestamp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_int64</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_decimal128</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_minkey</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">b_maxkey</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入k v (v是数组)</span></span><br><span class="line">arr.append(<span class="string">"hello"</span>);</span><br><span class="line">arr.append(<span class="literal">false</span>, types::b_bool&#123;<span class="literal">true</span>&#125;, types::b_double&#123;<span class="number">1.234</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can get a view of the resulting bson by calling view()</span></span><br><span class="line"><span class="keyword">auto</span> v = doc.view();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use 'v' so we don't get compiler warnings.</span></span><br><span class="line"><span class="keyword">return</span> v.empty() ? EXIT_FAILURE : EXIT_SUCCESS;</span><br></pre></td></tr></table></figure><p><em>Stream builder</em><br>我现在最喜欢的方法, 不过官方不建议这样, 因为需要保持这个流不被重新初始化, 这样在跨行生成的时候有困难.<br>官方建议使用上面的两个方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; "hello" : "world" &#125;</span></span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::stream;</span><br><span class="line">bsoncxx::document::value document = stream::document&#123;&#125; &lt;&lt; <span class="string">"hello"</span> &lt;&lt; <span class="string">"world"</span> &lt;&lt; stream::finalize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此外还有</span></span><br><span class="line"><span class="keyword">using</span> builder::stream::open_document; <span class="comment">// &#123;</span></span><br><span class="line"><span class="keyword">using</span> builder::stream::close_document;<span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">using</span> builder::stream::open_array; <span class="comment">// [</span></span><br><span class="line"><span class="keyword">using</span> builder::stream::close_array;<span class="comment">// ]</span></span><br></pre></td></tr></table></figure><p><strong>Building arrays</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> elements = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> array_builder = bsoncxx::builder::basic::<span class="built_in">array</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element : elements) &#123;</span><br><span class="line">    array_builder.append(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用lambda来构建 k, v (v是数组)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; "foo" : [ 1, 2, 3 ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::basic::kvp;</span><br><span class="line"><span class="keyword">using</span> bsoncxx::builder::basic::sub_array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> elements = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> doc = bsoncxx::builder::basic::document&#123;&#125;;</span><br><span class="line">doc.append(kvp(<span class="string">"foo"</span>, [&amp;elements](sub_array child) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element : elements) &#123;</span><br><span class="line">        child.append(element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>通过使用流来生成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123; "subdocs" : [ &#123; "key" : 1 &#125;, &#123; "key" : 2 &#125;, &#123; "key" : 3 &#125; ], "another_key" : 42 &#125;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> bsoncxx;</span><br><span class="line"></span><br><span class="line">builder::stream::document builder&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> in_array = builder &lt;&lt; <span class="string">"subdocs"</span> &lt;&lt; builder::stream::open_array;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; e : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;) &#123;</span><br><span class="line">    in_array = in_array &lt;&lt; builder::stream::open_document &lt;&lt; <span class="string">"key"</span> &lt;&lt; e</span><br><span class="line">                        &lt;&lt; builder::stream::close_document;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> after_array = in_array &lt;&lt; builder::stream::close_array;</span><br><span class="line"></span><br><span class="line">after_array &lt;&lt; <span class="string">"another_key"</span> &lt;&lt; <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">document::value doc = after_array &lt;&lt; builder::stream::finalize;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; to_json(doc) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://docs.mongodb.com/images/mongodb-logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="数据库" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MongoDB" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%95%B0%E6%8D%AE%E5%BA%93/MongoDB/"/>
    
    
      <category term="Mysql" scheme="http://blog.lsmg.xyz/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器编程读书记录-高级部分</title>
    <link href="http://blog.lsmg.xyz/2019/08/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/"/>
    <id>http://blog.lsmg.xyz/2019/08/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/</id>
    <published>2019-08-18T12:34:39.000Z</published>
    <updated>2020-02-25T14:25:05.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-I-O复用"><a href="#第九章-I-O复用" class="headerlink" title="第九章 I/O复用"></a>第九章 I/O复用</h1><p>I/O复用使得程序能同时监听多个文件描述符.</p><ul><li>客户端程序需要同时处理多个socket 非阻塞connect技术</li><li>客户端程序同时处理用户输入和网络连接 聊天室程序</li><li>TCP服务器要同时处理监听socket和连接socket</li><li>同时处理TCP和UDP请求 - 回射服务器</li><li>同时监听多个端口, 或者处理多种服务 - xinetd服务器</li></ul><p>常用手段<code>select</code>, <code>poll</code>, <code>epoll</code></p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="comment">// nfds - 被监听的文件描述符总数</span></span><br><span class="line"><span class="comment">// 后面三个分别指向 可读, 可写, 异常等事件对应的文件描述符集合</span></span><br><span class="line"><span class="comment">// timeval select超时时间 如果传递0 则为非阻塞, 设置为NULL则为阻塞</span></span><br><span class="line"><span class="comment">// 成功返回就绪(可读, 可写, 异常)文件描述符的总数, 没有则返回0 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作fd_set的宏</span></span><br><span class="line">FD_ZERO(fd_set* fdset);</span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set* fdset);</span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set* fdset);</span><br><span class="line">FD_ISSET(<span class="keyword">int</span> fd, fd_set* fdset);</span><br><span class="line"><span class="comment">// 设置 timeval 超时时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> tv_sec; <span class="comment">// 秒</span></span><br><span class="line"><span class="keyword">long</span> tv_usec; <span class="comment">// 微秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>select</strong></p><p>文件描述符就绪条件</p><ul><li>socket内核接收缓存区中的字节数大于或等于 其低水位标记</li><li>socket通信的对方关闭连接, 对socket的读操作返回0</li><li>监听socket上有新的连接请求</li><li>socket上有未处理的错误, 可以使用getsockopt来读取和清除错误</li><li>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记</li><li>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</li><li>socket使用非阻塞connect 连接成功或失败后<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2></li></ul><p><strong>poll</strong><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B1.png" alt=""><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B2.png" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// fds 结构体类型数组 指定我们感兴趣的文件描述符上发生的可读可写和异常事件\</span></span><br><span class="line"><span class="comment">// nfds 遍历结合大小 左闭右开</span></span><br><span class="line"><span class="comment">// timeout 单位为毫秒 -1 为阻塞 0 为立即返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line">short events;  <span class="comment">//注册的事件, 告知poll监听fd上的哪些事件</span></span><br><span class="line">short revents; <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> exit_if(r, ...) \</span></span><br><span class="line">&#123;   \</span><br><span class="line">    <span class="keyword">if</span> (r)  \</span><br><span class="line">    &#123;   \</span><br><span class="line">        <span class="built_in">printf</span>(__VA_ARGS__);    \</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"errno no: %d, error msg is %s"</span>, errno, strerror(errno));    \</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);    \</span><br><span class="line">    &#125;   \</span><br><span class="line">&#125;   \</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ip_;</span><br><span class="line">    <span class="keyword">int</span> port_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">8001</span>;</span><br><span class="line">    <span class="keyword">char</span> ip[] = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    exit_if(listenfd &lt; <span class="number">0</span>, <span class="string">"socket error\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(listenfd, (struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    exit_if(ret == <span class="number">-1</span>, <span class="string">"bind error\n"</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br><span class="line">    exit_if(ret == <span class="number">-1</span>, <span class="string">"listen error\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_CLIENTS = <span class="number">1024</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">polls</span>[<span class="title">MAX_CLIENTS</span>] = &#123;</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">client_info</span> <span class="title">clientsinfo</span>[<span class="title">MAX_CLIENTS</span>] = &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    polls[<span class="number">3</span>].fd = listenfd;</span><br><span class="line">    polls[<span class="number">3</span>].events = POLLIN | POLLRDHUP;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = poll(polls, MAX_CLIENTS + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        exit_if(ret == <span class="number">-1</span>, <span class="string">"poll error\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= MAX_CLIENTS; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> fd = polls[i].fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (polls[i].revents &amp; POLLRDHUP)</span><br><span class="line">            &#123;</span><br><span class="line">                polls[i].events = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"close fd-%d from %s:%d\n"</span>, fd, clientsinfo[fd].ip_, clientsinfo[fd].port_);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (polls[i].revents &amp; POLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (fd == listenfd)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">                    <span class="keyword">socklen_t</span> client_addresslen = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> clientfd = accept(listenfd, (struct sockaddr*)&amp;client_address,</span><br><span class="line">                            &amp;client_addresslen);</span><br><span class="line"></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> <span class="title">client_info</span> *<span class="title">clientinfo</span> = &amp;<span class="title">clientsinfo</span>[<span class="title">clientfd</span>];</span></span><br><span class="line"></span><br><span class="line">                    clientinfo-&gt;ip_ = inet_ntoa(client_address.sin_addr);</span><br><span class="line">                    clientinfo-&gt;port_ = ntohs(client_address.sin_port);</span><br><span class="line"></span><br><span class="line">                    exit_if(clientfd &lt; <span class="number">0</span>, <span class="string">"accpet error, from %s:%d\n"</span>, clientinfo-&gt;ip_,</span><br><span class="line">                            clientinfo-&gt;port_);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"accept from %s:%d\n"</span>, clientinfo-&gt;ip_, clientinfo-&gt;port_);</span><br><span class="line"></span><br><span class="line">                    polls[clientfd].fd = clientfd;</span><br><span class="line">                    polls[clientfd].events = POLLIN | POLLRDHUP;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">1024</span>];</span><br><span class="line">                    <span class="built_in">memset</span>(<span class="built_in">buffer</span>, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(<span class="built_in">buffer</span>));</span><br><span class="line"></span><br><span class="line">                    ret = <span class="built_in">read</span>(fd, <span class="built_in">buffer</span>, <span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">close</span>(fd);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"recv from %s:%d:\n%s\n"</span>, clientsinfo[fd].ip_,</span><br><span class="line">                               clientsinfo[fd].port_, <span class="built_in">buffer</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p><strong>epoll</strong></p><p>epoll是Linux特有的I/O复用函数, 实现上与select,poll有很大的差异</p><ul><li>epoll使用一组函数完成任务</li><li>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中</li><li>epoll无需每次调用都传入文件描述符集或事件集.</li></ul><p>有特定的文件描述符创建函数, 来标识这个事件表<code>epoll_create()</code><br><code>epoll_ctl()</code> 用来操作这个内核事件表<br><code>epoll_wait()</code> 为主要函数 成功返回就绪的文件描述符个数 失败返回-1<br>如果<code>epoll_wait()</code>函数检测到事件,就将所有就绪的事件从内核事件表(由第一个参数, epoll_create返回的结果) 中复制到第二个参数event指向的数组中, 这个数组只用于输出<code>epoll_wait</code>检测到的就绪事件.</p><p><em>event不同于select和poll的数组参数 既用于传入用户注册的事件, 又用于输出内核检测到的就绪事件, 提高了效率</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引poll返回的就绪文件描述符</span></span><br><span class="line"><span class="keyword">int</span> ret = poll(fds, MAX_EVENT_NUMBER - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = fds[i].fd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引epoll返回的就绪文件描述符</span></span><br><span class="line"><span class="keyword">int</span> ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER,  <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="comment">// sockfd 一定就绪 ?????</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LT和ET模式</strong><br>LT(电平触发, 默认的工作模式)<br>LT模式下的epoll相当于一个效率较高的poll<br>epoll_wait将会一只通知一个事件知道这个事件被处理</p><p>ET(边沿触发, epoll的高效工作模式)模式<br>当向epoll内核事件表中注册一个文件描述符上的EPOLLET事件的时候, epoll将用ET模式来操作这个<br>文件描述符<br>epoll_wait只会通知一次, 不论这个事件有没有完成</p><p>ET模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 123456789-123456789-123456789</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of content: 123456789</span><br><span class="line">get 9bytes of content: -12345678</span><br><span class="line">get 9bytes of content: 9-1234567</span><br><span class="line">get 4bytes of content: 89</span><br><span class="line">read later</span><br></pre></td></tr></table></figure><p>LT模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 123456789-123456789-123456789</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of contents: 123456789</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of contents: -12345678</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of contents: 9-1234567</span><br><span class="line">event trigger once</span><br><span class="line">get 4bytes of contents: 89</span><br></pre></td></tr></table></figure><p>ET模式有任务到来就必须做完, 因为后续将不会继续通知这个事件, 所以ET是epoll的高效工作模式<br>LT模式只要事件没被处理就会一直通知</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// size 参数只是给内核一个提示, 事件表需要多大</span></span><br><span class="line"><span class="comment">// 函数返回其他所有epoll系统调用的第一个参数, 来指定要访问的内核事件表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epfd 为 epoll_create的返回值</span></span><br><span class="line"><span class="comment">// op为操作类型</span></span><br><span class="line"><span class="comment">// - EPOLL_CTL_ADD 向事件表中注册fd上的事件</span></span><br><span class="line"><span class="comment">// - EPOLL_CTL_MOD 修改fd上的注册事件</span></span><br><span class="line"><span class="comment">// - EPOLL_CTL_DEL 删除fd上的注册事件</span></span><br><span class="line"><span class="comment">// fd 为要操作的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">_uint32_t</span> events; <span class="comment">// epoll事件</span></span><br><span class="line"><span class="keyword">epoll_data_t</span> data; <span class="comment">// 用户数据 是一个联合体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span>* ptr; <span class="comment">// ptr fd 不能同时使用</span></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">uint32_t</span> u32;</span><br><span class="line"><span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="keyword">epoll_data_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// maxevents监听事件数 必须大于0</span></span><br><span class="line"><span class="comment">// timeout 为-1 表示阻塞</span></span><br><span class="line"><span class="comment">// 成功返回就绪的文件描述符个数 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="三种IO复用的比较"><a href="#三种IO复用的比较" class="headerlink" title="三种IO复用的比较"></a>三种IO复用的比较</h2><p><code>select</code>以及<code>poll</code>和<code>epoll</code><br>相同</p><ul><li>都能同时监听多个文件描述符, 都将等待timeout参数指定的超时时间, 直到一个或多个文件描述符上有事件发生.</li><li>返回值为就绪的文件描述符数量, 返回0则表示没有事件发生</li><li><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%B8%89%E7%A7%8DIO%E5%A4%8D%E7%94%A8%E6%AF%94%E8%BE%83.png" alt=""></li></ul><h2 id="I-O-复用的高级应用-非阻塞connect"><a href="#I-O-复用的高级应用-非阻塞connect" class="headerlink" title="I/O 复用的高级应用, 非阻塞connect"></a>I/O 复用的高级应用, 非阻塞connect</h2><p>connect出错的时候会返回一个errno值 EINPROGRESS - 表示对非阻塞socket调用connect, 连接又没有立即建立的时候, 这时可以调用select和poll函数来监听这个连接失败的socket上的可写事件.</p><p>当函数返回的时候, 可以用getsockopt来读取错误码, 并清楚该socket上的错误. 错误码为0表示成功</p><h1 id="第十章信号"><a href="#第十章信号" class="headerlink" title="第十章信号"></a>第十章信号</h1><h2 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h2><p>发送信号Api</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pid &gt; 0 发送给PID为pid标识的进程</span></span><br><span class="line"><span class="comment">//  0 发送给本进程组的其他进程</span></span><br><span class="line"><span class="comment">// -1 发送给进程以外的所有进程, 但发送者需要有对目标进程发送信号的权限</span></span><br><span class="line"><span class="comment">// &lt; -1 发送给组ID为 -pid 的进程组中的所有成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 出错信息 EINVAL 无效信号, EPERM 该进程没有权限给任何一个目标进程 ESRCH 目标进程(组) 不存在</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><p>接收信号Api</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">_sighandler_t</span>)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/signum.h&gt; // 此头文件中有所有的linux可用信号</span></span></span><br><span class="line"><span class="comment">// 忽略目标信号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_DFL ((_sighandler_t) 0)</span></span><br><span class="line"><span class="comment">// 使用信号的默认处理方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIG_IGN ((_sighandler_t) 1)</span></span><br></pre></td></tr></table></figure><p>常用信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SIGHUP 控制终端挂起</span><br><span class="line">SIGPIPE 往读端被关闭的管道或者socket连接中写数据</span><br><span class="line">SIGURG socket连接上收到紧急数据</span><br><span class="line">SIGALRM 由alarm或setitimer设置的实时闹钟超时引起</span><br><span class="line">SIGCHLD 子进程状态变化</span><br></pre></td></tr></table></figure><p>信号函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为一个信号设置处理函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// _handler 指定sig的处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">_sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">__sighandler_t</span> _handler)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> sig, struct sigaction* act, struct sigaction* oact)</span></span></span><br></pre></td></tr></table></figure><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>信号是用户, 系统, 或者进程发送给目标进程的信息, 以通知目标进程某个状态的改变或者系统异常.<br>产生条件</p><ul><li>对于前台进程<br>用户可以通过输入特殊的终端字符来给它发送信号, CTRL+C 通常为一个中断信号 <code>SIGINT</code></li><li>系统异常<br>浮点异常和非法内存段的访问</li><li>系统状态变化<br>由alarm定时器到期将引起<code>SIGALRM</code>信号</li><li>运行kill命令或调用kill函数</li></ul><p><em>服务器必须处理(至少忽略) 一些常见的信号, 以免异常终止</em></p><p>中断系统调用?</p><h1 id="第十一章定时器"><a href="#第十一章定时器" class="headerlink" title="第十一章定时器"></a>第十一章定时器</h1><h2 id="socket选项SO-RCVTIMEO-和-SO-SNDTIMEO"><a href="#socket选项SO-RCVTIMEO-和-SO-SNDTIMEO" class="headerlink" title="socket选项SO_RCVTIMEO 和 SO_SNDTIMEO"></a>socket选项<code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code></h2><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/SO_RCVTIMEO%E5%92%8CSO_SNDTIMEO%E9%80%89%E9%A1%B9%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt=""></p><p>使用示例, 通过设置对应的SO_SNDTIMEO 得到超时后的路线</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timeout_connect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ip, <span class="keyword">const</span> <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">int</span> sec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    address.sin_addr.s_addr = inet_addr(ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    exit_if(sockfd &lt; <span class="number">0</span>, <span class="string">"socket error\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>&#123;</span>&#125;;</span><br><span class="line">    timeout.tv_sec = sec;</span><br><span class="line">    timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">socklen_t</span> timeout_len = <span class="keyword">sizeof</span>(timeout);</span><br><span class="line"></span><br><span class="line">    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, timeout_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">connect</span>(sockfd, (struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 当 errno为EINPROGRESS 说明 等待了 10S后依然无法连接成功 实现了定时器</span></span><br><span class="line">        <span class="keyword">if</span> (errno == EINPROGRESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"connecting timeout, process timeout logic\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error occur when connecting to server\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    exit_if(argc &lt;= <span class="number">2</span>, <span class="string">"wrong number of parameters\n"</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd = timeout_connect(ip, port, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SIGALRM信号-基于升序链表的定时器"><a href="#SIGALRM信号-基于升序链表的定时器" class="headerlink" title="SIGALRM信号-基于升序链表的定时器"></a>SIGALRM信号-基于升序链表的定时器</h2><p>由alarm和setitimer函数设定的实时闹钟一旦超时, 将会触发SIGALRM信号, 用信号处理函数处理定时任务<br> 相关的代码放在了github上 代码还是很多的就不放上来了<a href="https://github.com/rjd67441/Notes-HighPerformanceLinuxServerProgramming/tree/master/12.%20%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%9511-2%E5%92%8C11-3%E5%8F%8A11-4%20%E9%93%BE%E8%A1%A8%E5%AE%9A%E6%97%B6%E5%99%A8%2C%20%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5" target="_blank" rel="noopener">连接</a></p><p>总结放在了 日记的博客上 链接后面再甩出来</p><h2 id="IO复用系统调用的超时参数"><a href="#IO复用系统调用的超时参数" class="headerlink" title="IO复用系统调用的超时参数"></a>IO复用系统调用的超时参数</h2><h2 id="高性能定时器"><a href="#高性能定时器" class="headerlink" title="高性能定时器"></a>高性能定时器</h2><h2 id="时间轮"><a href="#时间轮" class="headerlink" title="# 时间轮"></a># 时间轮</h2><h2 id="时间堆"><a href="#时间堆" class="headerlink" title="# 时间堆"></a># 时间堆</h2><h1 id="第十二章高性能IO框架库"><a href="#第十二章高性能IO框架库" class="headerlink" title="第十二章高性能IO框架库"></a>第十二章高性能IO框架库</h1><p>另出一篇博客</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第九章-I-O复用&quot;&gt;&lt;a href=&quot;#第九章-I-O复用&quot; class=&quot;headerlink&quot; title=&quot;第九章 I/O复用&quot;&gt;&lt;/a&gt;第九章 I/O复用&lt;/h1&gt;&lt;p&gt;I/O复用使得程序能同时监听多个文件描述符.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端程序需
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器编程读书记录-初级部分</title>
    <link href="http://blog.lsmg.xyz/2019/08/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/"/>
    <id>http://blog.lsmg.xyz/2019/08/CPP-%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/</id>
    <published>2019-08-17T12:34:39.000Z</published>
    <updated>2020-02-02T11:07:28.755Z</updated>
    
    <content type="html"><![CDATA[<p>开头选了这本书, 看到这本书是他人总结三大本后自己写的, 先求个理解大概.<br>话说别人推荐的c++服务器咋都是c语言…..<br>2019年8月17日20:37:53</p><p>每学习一部分就写一个demo</p><a id="more"></a><p>分了三篇</p><h1 id="第一篇TCP-IP协议详解"><a href="#第一篇TCP-IP协议详解" class="headerlink" title="第一篇TCP/IP协议详解"></a>第一篇TCP/IP协议详解</h1><h2 id="第一章-TCP-IP协议族"><a href="#第一章-TCP-IP协议族" class="headerlink" title="第一章 TCP/IP协议族"></a>第一章 TCP/IP协议族</h2><h3 id="TCP-IP协议族体系结构和主要协议"><a href="#TCP-IP协议族体系结构和主要协议" class="headerlink" title="TCP/IP协议族体系结构和主要协议"></a>TCP/IP协议族体系结构和主要协议</h3><p>协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接</p><p>见得最多就是这四层结构了, 不过这本书写得更加详细一些<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg" alt=""></p><p>同样七层是osi参考模型, 简化后得到四层<br><img src="https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=3a1768f4c6fc1e17e9b284632bf99d66/0dd7912397dda144d48ab350bbb7d0a20df48655.jpg" alt=""><br>不同层次之间, 通过接口互相交流, 这样方便了各层次的修改</p><p><strong>应用层</strong><br>负责处理应用程序的逻辑</p><p><strong>表示层</strong><br>定义了数据的格式及加密</p><p><strong>会话层</strong><br>它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的</p><p><strong>传输层</strong><br>为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.<br>此层存在两大协议TCP协议和UDP协议<br><em>TCP协议</em><br>TCP协议(Transmission Control Protocol 传输控制协议) - 为应用层提供<code>可靠的, 面向连接, 基于流的服</code><br>通过<code>超时重传</code>和<code>数据确认</code>等确保数据正常送达.<br>TCP需要存储一些必要的状态, 可靠的协议<br><em>UDP协议</em><br>UPD协议(User Datagram Protocol 用户数据报协议) - 为应用层提供<code>不可靠的, 无连接的, 基于数据报的服务</code><br>一般需要自己处理<code>数据确认</code>和<code>超时重传</code>的问题<br>通信两者不存储状态, 每次发送都需要指定地址信息. <code>有自己的长度</code></p><p><strong>网络层</strong><br>实现了数据包的选路和转发.  只有数据包到不了目标地址, 就<code>下一跳</code>(hop by hop), 选择最近的.<br><em>IP协议(Internet Protocol)</em> 以及 <em>ICMP协议(Internet Control Message Protocol)</em><br>后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)</p><p><strong>数据链路层</strong><br>实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.<br>存在两个协议 <em>ARP协议(Address Resolve Protocol, 地址解析协议)</em>. 还有<em>RARP(Reverse ~, 逆地址解析协议)</em>.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议<strong>ARP欺骗, 可能与这个有关, 目前不去学习</strong></p><p><strong>封装</strong><br>上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.<br>被TCP封装的数据成为 <code>TCP报文段</code></p><ul><li>内核部分发送成功后删除数据</li></ul><p>被UDP封装的数据成为 <code>UDP数据报</code></p><ul><li>发送后即删除</li></ul><p>再经IP封装后成为<code>IP数据报</code><br>最后经过数据链路层封装后为 <code>帧</code></p><p>下面的操作都将在如下环境进行<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C.png" alt=""></p><p><strong>ARP</strong><br>ARP协议能实现任意网络层地址到任意物理地址的转换</p><h2 id="第二章-IP协议详解"><a href="#第二章-IP协议详解" class="headerlink" title="第二章 IP协议详解"></a>第二章 IP协议详解</h2><p>IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一<br>IP协议为上层协议提供无状态, 无连接, 不可靠的服务</p><h1 id="第二篇深入解析高性能服务器编程"><a href="#第二篇深入解析高性能服务器编程" class="headerlink" title="第二篇深入解析高性能服务器编程"></a>第二篇深入解析高性能服务器编程</h1><h2 id="第五章Linux网络编程基础API"><a href="#第五章Linux网络编程基础API" class="headerlink" title="第五章Linux网络编程基础API"></a>第五章Linux网络编程基础API</h2><p>socket基础api位于 <code>sys/socket.h</code> 头文件中<br>socket最开始的含义是 一个IP地址和端口对. 唯一的表示了TCP通信的一段<br>网络信息api <code>netdb.h</code>头文件中</p><h3 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h3><p>字节序分为 <code>大端字节序</code>和<code>小端字节序</code><br>由于大多数PC采用小端字节序(高位存在高地址处), 所以小端字节序又称为主机字节序</p><p>为了防止不同机器字节序不同导致的错乱问题. 规定传输的时候统一为 大端字节序(网络字节序).<br>这样主机会根据自己的情况决定 - 是否转换接收到的数据的字节序</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><strong>基础连接</strong><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93.jpg" alt=""><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88%E5%9C%B0%E5%9D%80%E6%97%8F.jpg" alt=""></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主机序和网络字节序转换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>; <span class="comment">// host to network long</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="keyword">int</span> <span class="title">htons</span> <span class="params">(<span class="keyword">unsigned</span> short <span class="keyword">int</span> hostlong)</span></span>; <span class="comment">// host to network short</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="keyword">int</span> <span class="title">htons</span> <span class="params">(<span class="keyword">unsigned</span> short <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP地址转换函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONE</span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span>  <span class="title">inet_addr</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* strptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* cp, struct in_addr* inp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回一个静态变量地址值, 所以多次调用会导致覆盖</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族</span></span><br><span class="line"><span class="comment">// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> * src, <span class="keyword">void</span>* dst)</span></span>;</span><br><span class="line"><span class="comment">// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span>*  src, <span class="keyword">char</span>* dst, <span class="keyword">socklen_t</span> cnt)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 命名 监听 socket</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// domain指定使用那个协议族 PF_INET PF_INET6</span></span><br><span class="line"><span class="comment">// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)</span></span><br><span class="line"><span class="comment">// protocol设置为默认的0</span></span><br><span class="line"><span class="comment">// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket为socket文件描述符</span></span><br><span class="line"><span class="comment">// my_addr 为地址信息</span></span><br><span class="line"><span class="comment">// addrlen为socket地址长度</span></span><br><span class="line"><span class="comment">// 成功返回0 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">const</span> struct sockaddr* my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backlog表示队列最大的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// 接受连接 失败返回-1 成功时返回socket</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">socklen_t</span>* addrlen)</span></span></span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起连接</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 第三个参数为 地址指定的长度</span></span><br><span class="line"><span class="comment">// 成功返回0 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr * serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数为保存的socket</span></span><br><span class="line"><span class="comment">// 并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才能关闭(需要查阅)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即关闭</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 第二个参数为可选值 </span></span><br><span class="line"><span class="comment">//SHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃</span></span><br><span class="line"><span class="comment">//SHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去</span></span><br><span class="line"><span class="comment">//SHUT_RDWR 同时关闭读和写</span></span><br><span class="line"><span class="comment">// 成功返回0 失败为-1 设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span></span><br></pre></td></tr></table></figure><p><strong>基础TCP</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取sockfd的数据</span></span><br><span class="line"><span class="comment">// buf 指定读缓冲区的位置</span></span><br><span class="line"><span class="comment">// len 指定读缓冲区的大小</span></span><br><span class="line"><span class="comment">// flags 参数较多</span></span><br><span class="line"><span class="comment">// 成功的时候返回读取到的长度, 可能小于预期长度, 需要多次读取.   读取到0 通信对方已经关闭连接, 错误返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 发送</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项名</th><th>含义</th><th>可用于发送</th><th>可用于接收</th></tr></thead><tbody><tr><td>MSG_CONFIRM</td><td>指示链路层协议持续监听, 直到得到答复.(仅能用于SOCK_DGRAM和SOCK_RAW类型的socket)</td><td>Y</td><td>N</td></tr><tr><td>MSG_DONTROUTE</td><td>不查看路由表, 直接将数据发送给本地的局域网络的主机(代表发送者知道目标主机就在本地网络中)</td><td>Y</td><td>N</td></tr><tr><td>MSG_DONTWAIT</td><td>非阻塞</td><td>Y</td><td>Y</td></tr><tr><td>MSG_MORE</td><td>告知内核有更多的数据要发送, 等到数据写入缓冲区完毕后,一并发送.减少短小的报文提高传输效率</td><td>Y</td><td>N</td></tr><tr><td>MSG_WAITALL</td><td>读操作一直等待到读取到指定字节后才会返回</td><td>N</td><td>Y</td></tr><tr><td>MSG_PEEK</td><td>看一下内缓存数据, 并不会影响数据</td><td>N</td><td>Y</td></tr><tr><td>MSG_OOB</td><td>发送或接收紧急数据</td><td>Y</td><td>Y</td></tr><tr><td>MSG_NOSIGNAL</td><td>向读关闭的管道或者socket连接中写入数据不会触发SIGPIPE信号</td><td>Y</td><td>N</td></tr></tbody></table><p><strong>基础UDP</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.</span></span><br><span class="line"><span class="comment">// 不过recvfrom和sendto 也可以用于 面向STREAM的连接, 这样可以省略发送和接收端的socket地址</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr* src_addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, ing flags, <span class="keyword">const</span> struct sockaddr* dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>通用读写函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inclued <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr* msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr* msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* socket address --- 指向socket地址结构变量, 对于TCP连接需要设置为NULL*/</span></span><br><span class="line"><span class="keyword">void</span>* msg_name; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">socklen_t</span> msg_namelen;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分散的内存块 --- 对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由</span></span><br><span class="line"><span class="comment">     * msg_iov指向的数组指定, 称为分散读(scatter read)  ---对于sendmsg而言, msg_iovlen块的分散内存中</span></span><br><span class="line"><span class="comment">     * 的数据将一并发送称为集中写(gather write);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>* <span class="title">msg_iov</span>;</span></span><br><span class="line"><span class="keyword">int</span> msg_iovlen; <span class="comment">/* 分散内存块的数量*/</span></span><br><span class="line"><span class="keyword">void</span>* msg_control; <span class="comment">/* 指向辅助数据的起始位置*/</span></span><br><span class="line"><span class="keyword">socklen_t</span> msg_controllen; <span class="comment">/* 辅助数据的大小*/</span></span><br><span class="line"><span class="keyword">int</span> msg_flags; <span class="comment">/* 复制函数的flags参数, 并在调用过程中更新*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">void</span>* iov_base <span class="comment">/* 内存起始地址*/</span></span><br><span class="line"><span class="keyword">size_t</span> iov_len <span class="comment">/* 这块内存长度*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其他Api</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 用于判断 sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据, </span></span><br><span class="line"><span class="comment">// 是的话返回1, 不是返回0</span></span><br><span class="line"><span class="comment">// 这样就可以选择带MSG_OOB标志的recv调用来接收带外数据. </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockatmark</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getsockname 获取sockfd对应的本端socket地址, 存入address指定的内存中, 长度存入address_len中 成功返回0失败返回-1</span></span><br><span class="line"><span class="comment">// getpeername 获取远端的信息, 同上</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下函数头文件均相同*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度</span></span><br><span class="line"><span class="comment">// 成功时返回0 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">void</span>* option_value, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">socklen_t</span> <span class="keyword">restrict</span> option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">void</span>* option_value, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">socklen_t</span> <span class="keyword">restrict</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>SO_REUSEADDR</th><th>重用本地地址</th><th>sock被设置此属性后, 即使sock在被bind()后处于TIME_WAIT状态, 此时与他绑定的socket地址依然能够立即重用来绑定新的sock</th></tr></thead><tbody><tr><td>SO_RCVBUF</td><td>TCP接收缓冲区大小</td><td>最小值为256字节. 设置完后系统会自动加倍你所设定的值. 多出来的一倍将用用作空闲缓冲区处理拥塞</td></tr><tr><td>SO_SNDBUF</td><td>TCP发送缓冲区大小</td><td>最小值为2048字节</td></tr><tr><td>SO_RCVLOWAT</td><td>接收的低水位标记</td><td>默认为1字节, 当TCP接收缓冲区中可读数据的总数大于其低水位标记时, IO复用系统调用将通知应用程序可以从对应的socket上读取数据</td></tr><tr><td>SO_SNDLOWAT</td><td>发送的高水位标记</td><td>默认为1字节, 当TCP发送缓冲区中空闲空间大于低水位标记的时候可以写入数据</td></tr><tr><td>SO_LINGER</td><td></td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> l_onoff <span class="comment">/* 开启非0, 关闭为0*/</span></span><br><span class="line"><span class="keyword">int</span> l_linger; <span class="comment">/* 滞留时间*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当onoff为0的时候此项不起作用, close调用默认行为关闭socket</span></span><br><span class="line"><span class="comment">* 当onoff不为0 且linger为0, close将立即返回, TCP将丢弃发送缓冲区的残留数据, 同时发送一个复位报文段</span></span><br><span class="line"><span class="comment">* 当onoff不为0 且linger大于0 . 当socket阻塞的时候close将会等待TCP模块发送完残留数据并得到确认后关 </span></span><br><span class="line"><span class="comment">* 闭, 如果是处于非阻塞则立即关闭</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/socket%E9%80%89%E9%A1%B9.jpg" alt=""><br><strong>网络信息API</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// 通过主机名查找ip</span></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ip获取主机完整信息 </span></span><br><span class="line"><span class="comment">// type为IP地址类型 AF_INET和AF_INET6</span></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> *h_name;<span class="comment">/* Official name of host.  */</span></span><br><span class="line">  <span class="keyword">char</span> **h_aliases;<span class="comment">/* Alias list.  */</span></span><br><span class="line">  <span class="keyword">int</span> h_addrtype;<span class="comment">/* Host address type.  */</span></span><br><span class="line">  <span class="keyword">int</span> h_length;<span class="comment">/* Length of address.  */</span></span><br><span class="line">  <span class="keyword">char</span> **h_addr_list;<span class="comment">/* List of addresses from name server.  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"非法输入\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hostptr</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    hostptr = gethostbyname(name);</span><br><span class="line">    <span class="keyword">if</span> (hostptr == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"输入存在错误 或无法获取\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Official name of hostptr: %s\n"</span>, hostptr-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> **pptr;</span><br><span class="line">    <span class="keyword">char</span> inet_addr[INET_ADDRSTRLEN];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Alias list:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (pptr = hostptr-&gt;h_aliases; *pptr != <span class="literal">nullptr</span>; ++pptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\t%s\n"</span>, *pptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (hostptr-&gt;h_addrtype)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> AF_INET:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"List of addresses from name server:\n"</span>);</span><br><span class="line">            <span class="keyword">for</span> (pptr = hostptr-&gt;h_addr_list; *pptr != <span class="literal">nullptr</span>; ++pptr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"\t%s\n"</span>,</span><br><span class="line">                        inet_ntop(hostptr-&gt;h_addrtype, *pptr, inet_addr, <span class="keyword">sizeof</span>(inet_addr)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"unknow address type\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">./run baidu.com</span></span><br><span class="line"><span class="comment">Official name of hostptr: baidu.com</span></span><br><span class="line"><span class="comment">Alias list:</span></span><br><span class="line"><span class="comment">List of addresses from name server:</span></span><br><span class="line"><span class="comment">39.156.69.79</span></span><br><span class="line"><span class="comment">220.181.38.148</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以下两个函数通过读取/etc/services文件 来获取服务信息 以下内容来自维基百科</p><p>Service文件是现代操作系统在etc目录下的一个配置文件，记录网络服务名对应的端口号与协议 其用途如下</p><ul><li>通过TCP/IP的API函数（声明在netdb.h中）直接查到网络服务名与端口号、使用协议的对应关系。如getservbyname(“serve”,”tcp”)获取端口号;getservbyport（htons（port），“tcp”）获取端口和协议上的服务名</li><li>如果用户在这个文件中维护所有使用的网络服务名字、端口、协议，那么可以一目了然的获悉哪些端口号用于哪个服务，哪些端口号是空闲的<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// 根据名称获取某个服务的完整信息</span></span><br><span class="line"><span class="function">struct servent <span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据端口号获取服务信息</span></span><br><span class="line"><span class="function">struct servent <span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span>* s_name; <span class="comment">/* 服务名称*/</span></span><br><span class="line"><span class="keyword">char</span> ** s_aliases; <span class="comment">/* 服务的别名列表*/</span></span><br><span class="line"><span class="keyword">int</span> s_port; <span class="comment">/* 端口号*/</span></span><br><span class="line"><span class="keyword">char</span>* s_proto; <span class="comment">/* 服务类型, 通常为TCP或UDP*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// 内部使用的gethostbyname 和 getserverbyname</span></span><br><span class="line"><span class="comment">// hostname 用于接收主机名, 也可以用来接收字符串表示的IP地址(点分十进制, 十六进制字符串)</span></span><br><span class="line"><span class="comment">// service 用于接收服务名, 字符串表示的十进制端口号</span></span><br><span class="line"><span class="comment">// hints参数 对getaddrinfo的输出进行更准确的控制, 可以设置为NULL, 允许反馈各种有用的结果</span></span><br><span class="line"><span class="comment">// result 指向一个链表, 用于存储getaddrinfo的反馈结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hostname, <span class="keyword">const</span> <span class="keyword">char</span>* service, <span class="keyword">const</span> struct addrinfo* hints, struct addrinfo** result)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">struct addrinfo</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ai_flags;</span><br><span class="line"><span class="keyword">int</span> ai_family;</span><br><span class="line"><span class="keyword">int</span> ai_socktype; <span class="comment">/* 服务类型, SOCK_STREAM或者SOCK_DGRAM*/</span></span><br><span class="line"><span class="keyword">int</span> ai_protocol;</span><br><span class="line"><span class="keyword">socklen_t</span> ai_addrlen;</span><br><span class="line"><span class="keyword">char</span>* ai_canonname; <span class="comment">/* 主机的别名*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>* <span class="title">ai_addr</span>;</span> <span class="comment">/* 指向socket地址*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>* <span class="title">ai_next</span>;</span> <span class="comment">/* 指向下一个结构体*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要手动的释放堆内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo* res)</span></span>;</span><br></pre></td></tr></table></figure><img src="https://ftp.bmp.ovh/imgs/2019/08/7ebedb14d8eedeac.png" alt=""></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// host 存储返回的主机名</span></span><br><span class="line"><span class="comment">// serv存储返回的服务名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr* sockaddr, <span class="keyword">socklen_t</span> addrlen, <span class="keyword">char</span>* host, <span class="keyword">socklen_t</span> hostlen, <span class="keyword">char</span>* serv</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">socklen_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://ftp.bmp.ovh/imgs/2019/08/bc7196e9a30d5152.png" alt=""></p><p>测试<br>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet ip port #来连接服务器的此端口</span><br><span class="line">netstat -nt | grep port #来查看此端口的监听</span><br></pre></td></tr></table></figure><h2 id="第六章高级IO函数"><a href="#第六章高级IO函数" class="headerlink" title="第六章高级IO函数"></a>第六章高级IO函数</h2><p>Linux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件自然限制了他的使用频率<br><em>文件描述符</em><br>文件描述符在是一个非负整数。是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表。<br>STDOUT_FILENO(值为1)- 值为1的文件描述符为标准输出, 关闭STDOUT_FILENO后用dup即可返回最小可用值(目前为, 1) 这样输出就重定向到了调用dup的参数指向的文件</p><h3 id="创建文件描述符-pipe-dup-dup2-splice-select"><a href="#创建文件描述符-pipe-dup-dup2-splice-select" class="headerlink" title="创建文件描述符 - pipe dup dup2 splice select"></a>创建文件描述符 - pipe dup dup2 splice select</h3><p><strong>pipe函数</strong><br>这个函数可用于创建一个管道, 实现进程间的通信. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="comment">// 参数文件描述符数组 fd[0] 读出 fd[1]写入 单向管道</span></span><br><span class="line"><span class="comment">// 成功返回0, 并将一对打开的文件描述符填入其参数指向的数组</span></span><br><span class="line"><span class="comment">// 失败返回-1 errno</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向管道</span></span><br><span class="line"><span class="comment">// 第一个参数为 协议PF_UNIX(书上是AF_UNIX)感觉这里指明协议使用PF更好一些</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>学习了后面的内容了解到了进程间通信, 回来补上一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, fds);</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> a[] = <span class="string">"123"</span>;</span><br><span class="line">        send(fds[<span class="number">1</span>], a, <span class="built_in">strlen</span>(a), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">char</span> b[<span class="number">20</span>] &#123;&#125;;</span><br><span class="line">        recv(fds[<span class="number">0</span>], b, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dup和dup2函数</strong><br>复制一个现有的文件描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回的文件描述符总是取系统当前可用的最小整数值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="comment">// 可以用newfd来制定新的文件描述符, 如果newfd已经被打开则先关闭</span></span><br><span class="line"><span class="comment">// 如果newfd==oldfd 则不关闭newfd直接返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure><p>dup函数创建一个新的文件描述符, 新的文件描述符和原有的file_descriptor共同指向相同的目标.<br>回来补上例子, 这个例子由于关掉了<code>STDOUT_FILENO</code>dup最小的即为<code>STDOUT_FILENO</code>所以<br>标准输出都到了这个文件之中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> filefd = <span class="built_in">open</span>(<span class="string">"/home/lsmg/1.txt"</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">close</span>(STDOUT_FILENO);</span><br><span class="line">    dup(filefd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"123\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写数据-readv-writev-mmap-munmap"><a href="#读写数据-readv-writev-mmap-munmap" class="headerlink" title="读写数据 - readv writev mmap munmap"></a>读写数据 - readv writev mmap munmap</h3><p><strong>readv/writev</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="comment">// count 为 vector的长度, 即为有多少块内存</span></span><br><span class="line"><span class="comment">// 成功时返回写入\读取的长度 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* <span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* <span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span>* iov_base <span class="comment">/* 内存起始地址*/</span></span><br><span class="line"><span class="keyword">size_t</span> iov_len <span class="comment">/* 这块内存长度*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回来补上一个使用例子, 这个例子将一个int的内存表示写入到了文件之中<br>使用hexdump查看这个文件<code>0000000 86a0 0001</code>可以看到<code>186a0</code>即为100000</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2020年1月7日16:52:11</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> file = <span class="built_in">open</span>(<span class="string">"/home/lsmg/1.txt"</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">100000</span>;</span><br><span class="line">    iovec temp_iovec&#123;&#125;;</span><br><span class="line">    temp_iovec.iov_base = &amp;temp;</span><br><span class="line">    temp_iovec.iov_len = <span class="keyword">sizeof</span>(temp);</span><br><span class="line">    writev(file, &amp;temp_iovec, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendfile函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="comment">// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span>* offset, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line">O_RDONLY只读模式</span><br><span class="line">O_WRONLY只写模式</span><br><span class="line">O_RDWR读写模式</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(file_name, flag)</span></span>;</span><br></pre></td></tr></table></figure><p>stat结构体, 可用fstat生成, <strong>简直就是文件的身份证</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>       st_dev;     <span class="comment">/* ID of device containing file -文件所在设备的ID*/</span></span><br><span class="line">    <span class="keyword">ino_t</span>       st_ino;     <span class="comment">/* inode number -inode节点号*/</span></span><br><span class="line">    <span class="keyword">mode_t</span>      st_mode;    <span class="comment">/* protection -保护模式?*/</span></span><br><span class="line">    <span class="keyword">nlink_t</span>     st_nlink;   <span class="comment">/* number of hard links -链向此文件的连接数(硬连接)*/</span></span><br><span class="line">    <span class="keyword">uid_t</span>       st_uid;     <span class="comment">/* user ID of owner -user id*/</span></span><br><span class="line">    <span class="keyword">gid_t</span>       st_gid;     <span class="comment">/* group ID of owner - group id*/</span></span><br><span class="line">    <span class="keyword">dev_t</span>       st_rdev;    <span class="comment">/* device ID (if special file) -设备号，针对设备文件*/</span></span><br><span class="line">    <span class="keyword">off_t</span>       st_size;    <span class="comment">/* total size, in bytes -文件大小，字节为单位*/</span></span><br><span class="line">    <span class="keyword">blksize_t</span>   st_blksize; <span class="comment">/* blocksize for filesystem I/O -系统块的大小*/</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span>    st_blocks;  <span class="comment">/* number of blocks allocated -文件所占块数*/</span></span><br><span class="line">    <span class="keyword">time_t</span>      st_atime;   <span class="comment">/* time of last access -最近存取时间*/</span></span><br><span class="line">    <span class="keyword">time_t</span>      st_mtime;   <span class="comment">/* time of last modification -最近修改时间*/</span></span><br><span class="line">    <span class="keyword">time_t</span>      st_ctime;   <span class="comment">/* time of last status change - */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>身份证</strong>生成函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数需要调用open生成文件描述符</span></span><br><span class="line"><span class="comment">// 下面其他两个为文件全路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> filedes, struct stat *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当路径指向为符号链接的时候, lstat为符号链接的信息. stat为符号链接指向文件信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* ln -s source dist  建立软连接, 类似快捷方式, 也叫符号链接</span></span><br><span class="line"><span class="comment">* ln source dist  建立硬链接, 同一个文件使用多个不同的别名, 指向同一个文件数据块, 只要硬链接不被完全</span></span><br><span class="line"><span class="comment">* 删除就可以正常访问</span></span><br><span class="line"><span class="comment">* 文件数据块 - 文件的真正数据是一个文件数据块, 打开的`文件`指向这个数据块, 就是说</span></span><br><span class="line"><span class="comment">* `文件`本身就类似快捷方式, 指向文件存在的区域.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> <strong>mmap和munmap函数</strong></p><p><code>mmap</code>创建一块进程通讯共享的内存(可以将文件映射入其中), <code>munmap</code>释放这块内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start 内存起始位置, 如果为NULL则系统分配一个地址 length为长度</span></span><br><span class="line"><span class="comment">// port参数 PROT_READ(可读) PROT_WRITE(可写) PROT_EXEC(可执行), PROT_NONE(不可访问)</span></span><br><span class="line"><span class="comment">// flag参数 内存被修改后的行为</span></span><br><span class="line"><span class="comment">// - MAP_SHARED 进程间共享内存, 对内存的修改反映到映射文件中</span></span><br><span class="line"><span class="comment">// - MAP_PRIVATE 为调用进程私有, 对该内存段的修改不会反映到文件中</span></span><br><span class="line"><span class="comment">// - MAP_ANONUMOUS 不是从文件映射而来, 内容被初始化为0, 最后两个参数被忽略</span></span><br><span class="line"><span class="comment">// 成功返回区域指针, 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> port, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0 失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>splice函数</strong><br>用于在两个文件名描述符之间移动数据, 0拷贝操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// fd_in 为文件描述符, 如果为管道文件描述符则 off_in必须为NULL, 否则为读取开始偏移位置</span></span><br><span class="line"><span class="comment">// len为指定移动的数据长度, flags参数控制数据如何移动.</span></span><br><span class="line"><span class="comment">// - SPLICE_F_NONBLOCK 非阻塞splice操作, 但会受文件描述符自身的阻塞</span></span><br><span class="line"><span class="comment">// - SPLICE_F_MORE 给内核一个提示, 后续的splice调用将读取更多的数据???????</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="keyword">int</span> fd_in, <span class="keyword">loff_t</span>* off_in, <span class="keyword">int</span> fd_out, <span class="keyword">loff_t</span>* off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用splice函数  实现echo服务器</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the parmerters is wrong\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"the port is %d the ip is %s\n"</span>, port, ip);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(sockfd, (sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sockfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> clientfd&#123;&#125;;</span><br><span class="line">    sockaddr_in client_address&#123;&#125;;</span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"></span><br><span class="line">    clientfd = accept(sockfd, (sockaddr*)&amp;client_address, &amp;client_addrlen);</span><br><span class="line">    <span class="keyword">if</span> (clientfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"accept error\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"a new connection from %s:%d success\n"</span>, inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));</span><br><span class="line">        <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">        pipe(fds);</span><br><span class="line">        ret = splice(clientfd, <span class="literal">nullptr</span>, fds[<span class="number">1</span>], <span class="literal">nullptr</span>, <span class="number">32768</span>, SPLICE_F_MORE);</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ret = splice(fds[<span class="number">0</span>], <span class="literal">nullptr</span>, clientfd, <span class="literal">nullptr</span>, <span class="number">32768</span>, SPLICE_F_MORE);</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(clientfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>select 函数</strong><br>select函数在第二个参数列表 可读的时候返回<br>或者是等到了规定的时间返回</p><p>返回之后 第二个参数指向fdset的集合 被修改为可读的fd列表<br>这就需要每次返回后都更新 fdset集合</p><p>返回后 此函数的返回值为可读的fd数量, 遍历fdset集合 同时使用FD_ISSET判断fdset[i] 是否在其中<br>然后判断此fd是否为listenfd 如果是则接受新的连接 如果不是说明是已经接受的其他fd 判断是有数据可读<br>还是此连接断开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; </span></span></span><br><span class="line"><span class="comment">// maxfdp 最大数 FD_SETSIZE</span></span><br><span class="line"><span class="comment">// struct fd_set 一个集合,可以存储多个文件描述符</span></span><br><span class="line"><span class="comment">// - FD_ZERO(&amp;fd_set) 清空 -FD_SET(fd, &amp;fd_set) 放入fd FD_CLR(fd, &amp;fd_set)从其中清除fd</span></span><br><span class="line"><span class="comment">// - FD_ISSET(fd, &amp;fd_set) 判断是否在其中</span></span><br><span class="line"><span class="comment">// readfds  需要监视的文件描述符读变化, 其中的文件描述符可读的时候返回</span></span><br><span class="line"><span class="comment">// writefds 需要监视的文件描述符写变化, 其中的文件描述符可写的时候返回</span></span><br><span class="line"><span class="comment">// errorfds 错误</span></span><br><span class="line"><span class="comment">// timeout 传入NULL为阻塞, 设置为0秒0微秒则变为非阻塞函数</span></span><br><span class="line"><span class="comment">// 返回值 负值为错误 等待超时说明文件无变化返回0 有变化返回正值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> exit_if(r, ...) \</span></span><br><span class="line">&#123;   \</span><br><span class="line">    <span class="keyword">if</span> (r)  \</span><br><span class="line">    &#123;   \</span><br><span class="line">        <span class="built_in">printf</span>(__VA_ARGS__);    \</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"errno no: %d, error msg is %s"</span>, errno, strerror(errno));    \</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);    \</span><br><span class="line">    &#125;   \</span><br><span class="line">&#125;   \</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> keyboard_fd = <span class="built_in">open</span>(<span class="string">"/dev/tty"</span>, O_RDONLY | O_NONBLOCK);</span><br><span class="line">    exit_if(keyboard_fd &lt; <span class="number">0</span>, <span class="string">"open keyboard fd error\n"</span>);</span><br><span class="line">    fd_set readfd;</span><br><span class="line">    <span class="keyword">char</span> recv_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_ZERO(&amp;readfd);</span><br><span class="line">        FD_SET(<span class="number">0</span>, &amp;readfd);</span><br><span class="line"></span><br><span class="line">        timeval timeout &#123;<span class="number">5</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = select(keyboard_fd + <span class="number">1</span>, &amp;readfd, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line">        exit_if(ret == <span class="number">-1</span>, <span class="string">"select error\n"</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(keyboard_fd, &amp;readfd))</span><br><span class="line">            &#123;</span><br><span class="line">                recv_buffer = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">read</span>(keyboard_fd, &amp;recv_buffer, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">'\n'</span> == recv_buffer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">'q'</span> == recv_buffer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"the input is %c\n"</span>, recv_buffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"timeout\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第七章Linux服务器程序规范"><a href="#第七章Linux服务器程序规范" class="headerlink" title="第七章Linux服务器程序规范"></a>第七章Linux服务器程序规范</h2><ul><li>Linux程序服务器 一般以后台进程形式运行.  后台进程又称为守护进程(daemon). 他没有控制终端, 因而不会意外的接收到用户输入. 守护进程的父进程通常都是init进程(PID为1的进程)</li><li>Linux服务器程序有一套日志系统, 他至少能输出日志到文件. 日志这东西太重要了,排错对比全靠它.</li><li>Linux服务器程序一般以某个专门的非root身份运行. 比如mysqld有自己的账户mysql.</li><li>Linux服务器程序一般都有自己的配置文件, 而不是把所有配置都写死在代码里面, 方便后续的更改.</li><li>Linux服务器程序通常在启动的时候生成一个PID文件并存入/var/run 目录中, 以记录改后台进程的PID.</li><li>Linux服务器程序通常需要考虑系统资源和限制, 预测自己的承受能力</li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service rsyslog restart // 启动守护进程</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="comment">// priority参数是所谓的设施值(记录日志信息来源, 默认为LOG_USER)与日志级别的按位或</span></span><br><span class="line"><span class="comment">// - 0 LOG_EMERG  /* 系统不可用*/</span></span><br><span class="line"><span class="comment">// - 1 LOG_ALERT   /* 报警需要立即采取行动*/</span></span><br><span class="line"><span class="comment">// - 2 LOG_CRIT /* 非常严重的情况*/</span></span><br><span class="line"><span class="comment">// - 3 LOG_ERR  /* 错误*/</span></span><br><span class="line"><span class="comment">// - 4 LOG_WARNING /* 警告*/</span></span><br><span class="line"><span class="comment">// - 5 LOG_NOTICE /* 通知*/</span></span><br><span class="line"><span class="comment">// - 6 LOG_INFO /* 信息*/</span></span><br><span class="line"><span class="comment">//  -7 LOG_DEBUG /* 调试*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span>* message, .....)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ident 位于日志的时间后 通常为名字</span></span><br><span class="line"><span class="comment">// logopt 对后续 syslog调用的行为进行配置</span></span><br><span class="line"><span class="comment">// -  0x01 LOG_PID  /* 在日志信息中包含程序PID*/</span></span><br><span class="line"><span class="comment">// -  0x02 LOG_CONS /* 如果信息不能记录到日志文件, 则打印到终端*/</span></span><br><span class="line"><span class="comment">// -  0x04 LOG_ODELAY /* 延迟打开日志功能直到第一次调用syslog*/</span></span><br><span class="line"><span class="comment">// -  0x08 LOG_NDELAY /* 不延迟打开日志功能*/</span></span><br><span class="line"><span class="comment">// facility参数可以修改syslog函数中的默认设施值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ident, <span class="keyword">int</span> logopt, <span class="keyword">int</span> facility)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maskpri 一共八位 0000-0000</span></span><br><span class="line"><span class="comment">// 如果将最后一个0置为1 表示 记录0级别的日志</span></span><br><span class="line"><span class="comment">// 如果将最后两个0都置为1 表示记录0和1级别的日志</span></span><br><span class="line"><span class="comment">// 可以通过LOG_MASK() 宏设定 比如LOG_MASK(LOG_CRIT) 表示将倒数第三个0置为1, 表示只记录LOG_CRIT</span></span><br><span class="line"><span class="comment">// 如果直接设置setlogmask(3); 3的二进制最后两个数均为1 则记录 0和1级别的日志</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭日志功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="用户信息-切换用户"><a href="#用户信息-切换用户" class="headerlink" title="用户信息, 切换用户"></a>用户信息, 切换用户</h3><p>UID - 真实用户ID<br>EUID - 有效用户ID - 方便资源访问<br>GID - 真实组ID<br>EGID - 有效组ID</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> euid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br></pre></td></tr></table></figure><p>可以通过 <code>setuid</code>和<code>setgid</code>切换用户 <strong>root用户uid和gid均为0</strong></p><h3 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h3><p>PGID - 进程组ID(Linux下每个进程隶属于一个进程组)</p><p>#include &lt;unistd.h&gt;<br>pid_t getpgid(pid_t pid); 成功时返回pid所属的pgid 失败返回-1<br>int setpgid(pid_t pid, pid_t pgid);</p><p><strong>会话</strong><br>一些有关联的进程组将形成一个会话<br>略过</p><p><strong>查看进程关系</strong><br>ps和less</p><p><strong>资源限制</strong><br>略<br><strong>改变目录</strong><br>略</p><h2 id="第八章高性能服务器程序框架"><a href="#第八章高性能服务器程序框架" class="headerlink" title="第八章高性能服务器程序框架"></a>第八章高性能服务器程序框架</h2><p><strong>服务器模型-CS模型</strong></p><p><strong>优点</strong></p><ul><li>实现起来简单</li></ul><p><strong>缺点</strong></p><ul><li>服务器是通信的中心, 访问过大的时候会导致响应过慢</li></ul><p>模式图<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%BE8-2%20TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt=""></p><p>编写的demo 没有用到fork函数. 后续待完善</p><p><strong>服务器框架 IO模型</strong></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png" alt=""></p><p>这个模型大概能够理解, 自己也算是学了半年的Javaweb.</p><p>socket在创建的时候默认是阻塞的, 不过可以通过传<code>SOCK_NONBLOCK</code>参解决<br>非阻塞调用都会立即返回 但可能事件没有发生(recv没有接收到信息), 没有发生和出错都会<code>返回-1</code> 所以需要通过<code>errno</code>来区分这些错误.<br><strong>事件未发生</strong><br>accept, send,recv errno被设置为 <code>EAGAIN(再来一次)</code>或<code>EWOULDBLOCK(期望阻塞)</code><br>connect 被设置为 <code>EINPROGRESS(正在处理中)</code></p><p>需要在事件已经发生的情况下 去调用非阻塞IO, 才能提高性能</p><p>常用IO复用函数 <code>select</code> <code>poll</code> <code>epoll_wait</code> 将在第九章后面说明<br>信号将在第十章说明</p><p><strong>两种高效的事件处理模式和并发模式</strong><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Reactor%E6%A8%A1%E5%BC%8F.png" alt=""></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Proactor%E6%A8%A1%E5%BC%8F.png" alt=""></p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E7%94%A8%E5%90%8C%E6%AD%A5IO%E6%A8%A1%E6%8B%9F%E5%87%BA%E7%9A%84Proactor%E6%A8%A1%E5%BC%8F.png" alt=""></p><p>程序分为计算密集型(CPU使用很多, IO资源使用很少)和IO密集型(反过来).<br>前者使用并发编程反而会降低效率, 后者则会提升效率<br>并发编程有多进程和多线程两种方式</p><p>并发模式 - IO单元和多个逻辑单元之间协调完成任务的方法.<br>服务器主要有两种并发模式</p><ul><li>半同步/半异步模式</li><li>领导者/追随者模式</li></ul><p><strong>半同步/半异步模式</strong><br>在IO模型中, 异步和同步的区分是内核向应用程序通知的是何种IO事件(就绪事件还是完成事件), 以及由谁来完成IO读写(应用程序还是内核)</p><p>而在这里(并发模式)<br>同步指的是完全按照代码序列的顺序执行 - 按照同步方式运行的线程称为同步线程<br>异步需要系统事件(中断, 信号)来驱动 - 按照异步方式运行的线程称为异步线程<br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5.png" alt=""></p><p>服务器(需要较好的实时性且能同时处理多个客户请求) - 一般使用同步线程和异步线程来实现,即为半同步/半异步模式<br>同步线程 - 处理客户逻辑, 处理请求队列中的对象<br>异步线程 - 处理IO事件, 接收到客户请求后将其封装成请求对象并插入请求队列</p><p>半同步/半异步模式 存在变体 <code>半同步/半反应堆模式</code><br><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F.png" alt=""></p><p>异步线程 - 主线程 - 负责监听所有socket上的事件</p><p><strong>领导者/追随者模式</strong><br>略</p><p><strong>高效编程方法 - 有限状态机</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态独立的有限状态机</span></span><br><span class="line">STATE_MACHINE(Package _pack) &#123;</span><br><span class="line"></span><br><span class="line">PackageType _type = _pack.GetType();</span><br><span class="line"><span class="keyword">switch</span>(_type) &#123;</span><br><span class="line"><span class="keyword">case</span> type_A:</span><br><span class="line">xxxx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> type_B:</span><br><span class="line">xxxx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带状态转移的有限状态机</span></span><br><span class="line">STATE_MACHINE() &#123;</span><br><span class="line">State cur_State = type_A;</span><br><span class="line"><span class="keyword">while</span>(cur_State != type_C) &#123;</span><br><span class="line"></span><br><span class="line">Package _pack = getNewPackage();</span><br><span class="line"><span class="keyword">switch</span>(cur_State) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> type_A:</span><br><span class="line">process_package_state_A(_pack);</span><br><span class="line">cur_State = type_B;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> type_B:</span><br><span class="line">xxxx;</span><br><span class="line">cur_State = type_C;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>花了小一个小时 终于一个字母一个字母的抄完了那个5000多字的代码<br>@2019年9月8日22:08:46@</p><h3 id="提高服务器性能的其他建议-池-数据复制-上下文切换和锁"><a href="#提高服务器性能的其他建议-池-数据复制-上下文切换和锁" class="headerlink" title="提高服务器性能的其他建议 池 数据复制 上下文切换和锁"></a>提高服务器性能的其他建议 池 数据复制 上下文切换和锁</h3><p><strong>池</strong> - 用空间换取时间<br>进程池和线程池</p><p><strong>数据复制</strong> - 高性能的服务器应该尽量避免不必要的复制</p><p><strong>上下文切换和锁</strong><br>减少<code>锁</code>的作用区域. 不应该创建太多的工作进程, 而是使用专门的业务逻辑线程.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开头选了这本书, 看到这本书是他人总结三大本后自己写的, 先求个理解大概.&lt;br&gt;话说别人推荐的c++服务器咋都是c语言…..&lt;br&gt;2019年8月17日20:37:53&lt;/p&gt;
&lt;p&gt;每学习一部分就写一个demo&lt;/p&gt;
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
      <category term="服务器编程-书籍记录" scheme="http://blog.lsmg.xyz/categories/CPP/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B-%E4%B9%A6%E7%B1%8D%E8%AE%B0%E5%BD%95/"/>
    
    
  </entry>
  
</feed>
