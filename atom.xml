<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lsmg的大学之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.lsmg.xyz/"/>
  <updated>2021-02-01T09:59:38.370Z</updated>
  <id>http://blog.lsmg.xyz/</id>
  
  <author>
    <name>Lsmg</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器访问URL到显示</title>
    <link href="http://blog.lsmg.xyz/2021/02/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEURL%E5%88%B0%E6%98%BE%E7%A4%BA/"/>
    <id>http://blog.lsmg.xyz/2021/02/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AEURL%E5%88%B0%E6%98%BE%E7%A4%BA/</id>
    <published>2021-02-01T08:55:22.000Z</published>
    <updated>2021-02-01T09:59:38.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/base/ip-wireshark.png" alt=""></p><p>浏览器访问虚拟机创建的nginx默认网页</p><p>浏览器根据输入的URL中的IP 进行三次握手建立TCP连接 然后浏览器发送GET请求 服务器回复GET请求 获取各种文件</p><p>一般服务器对<code>GET /</code>默认返回index.html页面 <code>https://www.baidu.com/index.html</code>自己加上index后同样可以访问 但是<code>https://www.qq.com/index.html</code>却不行 所以还是跟服务器处理逻辑有关</p><p>返回了html页面后浏览器解析其中的内容, 请求css, js, 图片资源等文件 然后进行渲染显示出网页</p><p>文件传输完毕后TCP四次挥手关闭连接</p><p>如果使用的是域名访问, 则需要访问DNS服务器解析域名获得IP地址, 这样HTTP请求头部还会包含一些特殊的头部如HOST等</p><p>HTTP访问的默认端口均为80端口</p><h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><p>https进行域名解析后, ip+443端口连接服务器</p><p>测试时访问的连接为<code>https://m.baidu.com/?pu=sz%401321_480</code> 百度精简版页面, 修改了host防止负载均衡等策略ip不对应</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/base/https-wireshark.png" alt=""></p><p>504 505 506 三个包进行TCP三次握手与<code>110.242.68.9:443</code>建立连接</p><p>507 客户端发送Client Hello 发送随机的key1和自己支持的加密方法</p><p>508 ACK应答</p><p>509 510 511 服务端发送Server Hello 发送随机的key2和选定的加密方法</p><p>512 服务端发送证书</p><p>513 ACK应答</p><p>514 服务器发送Server Key Exchange</p><p>515 服务器发送Server Hello Done</p><p>516 ACK应答</p><p>518 客户端发送Client Key Exchange, Change Clipher Spec, Finished</p><p>519 客户端发送经过加密的GET请求(Wireshark进行了解密)</p><p>520 521 进行ACK应答</p><p>522 523 524 服务端发送New Session Ticket, Change Clipher Spec, Finished</p><p>556 服务器回复GET请求</p><p>客户端向服务器发送请求(随机数key1 和支持的加密算法)</p><p>服务器回复数字证书(随机数key2 选择的双方支持算法 证书)</p><p>客户端验证数字证书可靠性, 使用CA的公钥解密加密后的证书. 验证证书的合法性</p><p>客户端生成随机数key3, 根据key1, key2, key3生成会话秘钥, 用服务器发送的证书加密key3发送给服务器</p><p>服务器解密key3同样根据key1, key2, key3生成会话秘钥</p><p>后续就通过会话密钥进行加密数据和解密数据</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;http&quot;&gt;&lt;a href=&quot;#http&quot; class=&quot;headerlink&quot; title=&quot;http&quot;&gt;&lt;/a&gt;http&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://lsmg-img.oss-cn-beijing.aliyuncs.com/base/ip
      
    
    </summary>
    
    
      <category term="基础知识" scheme="http://blog.lsmg.xyz/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker使用</title>
    <link href="http://blog.lsmg.xyz/2021/01/Linux-docker/"/>
    <id>http://blog.lsmg.xyz/2021/01/Linux-docker/</id>
    <published>2021-01-31T15:34:22.000Z</published>
    <updated>2021-01-31T16:39:49.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h1><p>创建容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum install docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 配置镜像加速</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker pull mysql # 拉取镜像</span><br><span class="line"></span><br><span class="line">docker run -itd --name mysql-live -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456789 mysql # 创建容器</span><br><span class="line"></span><br><span class="line">docker ps # 查看容器状态</span><br></pre></td></tr></table></figure><p>配置远程账号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql-live bash # 进入容器</span><br><span class="line"></span><br><span class="line">mysql -uroot -p123456789</span><br><span class="line"></span><br><span class="line">CREATE USER 'lsmg'@'%' IDENTIFIED WITH mysql_native_password BY '123456789'; # 创建远程用户</span><br><span class="line"></span><br><span class="line">GRANT ALL PRIVILEGES ON *.* TO 'lsmg'@'%';</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h1 id="导出导入文件"><a href="#导出导入文件" class="headerlink" title="导出导入文件"></a>导出导入文件</h1><p>从容器导出文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导出mysql容器的sql导出文件</span></span><br><span class="line"></span><br><span class="line">docker cp mysql-live:/live_user.sql /root</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装Mysql&quot;&gt;&lt;a href=&quot;#安装Mysql&quot; class=&quot;headerlink&quot; title=&quot;安装Mysql&quot;&gt;&lt;/a&gt;安装Mysql&lt;/h1&gt;&lt;p&gt;创建容器&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="docker" scheme="http://blog.lsmg.xyz/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>左值引用和右值引用</title>
    <link href="http://blog.lsmg.xyz/2021/01/CPP-&amp;AND&amp;&amp;/"/>
    <id>http://blog.lsmg.xyz/2021/01/CPP-&amp;AND&amp;&amp;/</id>
    <published>2021-01-15T09:27:27.000Z</published>
    <updated>2021-01-15T09:27:21.180Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>.*_case</title>
    <link href="http://blog.lsmg.xyz/2021/01/CPP-cast/"/>
    <id>http://blog.lsmg.xyz/2021/01/CPP-cast/</id>
    <published>2021-01-14T13:27:27.000Z</published>
    <updated>2021-01-29T09:50:04.136Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used" target="_blank" rel="noopener">https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used</a>?</p><h1 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h1><ol><li>普通类型转换 int-&gt;float</li><li>pointer to void<em>, void</em> to pointer</li><li>向上类型转换不是必须的, 但是向下转换只要不是虚拟继承就能使用</li></ol><h1 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h1><p>只用来处理多态下的指针和引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PrintName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Animal\r\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintName</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog\r\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintName</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cat\r\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestCast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Animal* animal = new Animal(); // not dog not cat</span></span><br><span class="line"><span class="comment">// Animal* animal = new Dog(); // Dog not cat</span></span><br><span class="line">Animal* animal = <span class="keyword">new</span> Cat(); <span class="comment">// not dog Cat</span></span><br><span class="line"></span><br><span class="line">Dog* dog = <span class="keyword">dynamic_cast</span>&lt;Dog*&gt;(animal);</span><br><span class="line">Cat* cat = <span class="keyword">dynamic_cast</span>&lt;Cat*&gt;(animal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dog)</span><br><span class="line">&#123;</span><br><span class="line">dog-&gt;PrintName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"not dog\r\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cat)</span><br><span class="line">&#123;</span><br><span class="line">cat-&gt;PrintName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"not cat\r\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h1><p>可以用来对变量移除和添加const, 其他的cast都无法做到 (static_cast可以添加const但是不能去除)</p><p>将const变量移除const是未定义的, 将<code>非const的变量</code>的<code>const引用</code>是安全的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>* ap1 = &amp;a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ap2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span>*&gt;(ap1); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* ap3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(ap2); <span class="comment">// invalid static_cast from type 'const int*' to type 'int*'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* ap4 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(ap2); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><ul><li><p>ex1.将const成员函数的this指针去除const来修改成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.geeksforgeeks.org/const_cast-in-c-type-casting-operators/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="keyword">int</span> roll; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="comment">// constructor </span></span><br><span class="line">student(<span class="keyword">int</span> r):roll(r) &#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// A const function that changes roll with the help of const_cast </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">( <span class="keyword">const_cast</span> &lt;student*&gt; (<span class="keyword">this</span>) )-&gt;roll = <span class="number">5</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRoll</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> roll; &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="function">student <span class="title">s</span><span class="params">(<span class="number">3</span>)</span></span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Old roll number: "</span> &lt;&lt; s.getRoll() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">s.fun(); </span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"New roll number: "</span> &lt;&lt; s.getRoll() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//$ Old roll number: 3</span></span><br><span class="line"><span class="comment">//$ New roll number: 5</span></span><br></pre></td></tr></table></figure></li><li><p>ex2.去除参数的const, 来调用非const参数的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>* ptr)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">return</span> (*ptr + <span class="number">10</span>); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">10</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *ptr = &amp;val; </span><br><span class="line"><span class="keyword">int</span> *ptr1 = <span class="keyword">const_cast</span> &lt;<span class="keyword">int</span> *&gt;(ptr); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fun(ptr1); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//$ 20</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> short uint16;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read Bytes returns that 2 bytes got read. </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ByteBuffer::ReadUInt16</span><span class="params">(uint16&amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ReadBytes(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;val), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span>* bp1 = &amp;b; <span class="comment">//  cannot convert 'int*' to 'char*' in initialization</span></span><br><span class="line"><span class="keyword">char</span>* bp2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;b); <span class="comment">// invalid static_cast from type 'int*' to type 'char*'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* bp3 = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;b); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-const-cast-and-reinterpret-cast-be-used&quot; target=
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣1.12-N322. 零钱兑换</title>
    <link href="http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A31.12-N322.%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
    <id>http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A31.12-N322.%20%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</id>
    <published>2021-01-12T14:10:02.000Z</published>
    <updated>2021-01-12T14:02:04.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h1><p>Difficulty: <strong>中等</strong></p><p>给定不同面额的硬币 <code>coins</code> 和一个总金额 <code>amount</code>。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 &#x3D; 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1], amount &#x3D; 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1], amount &#x3D; 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coins &#x3D; [1], amount &#x3D; 2</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 2&lt;sup&gt;31&lt;/sup&gt; - 1</code></li><li><code>0 &lt;= amount &lt;= 10&lt;sup&gt;4&lt;/sup&gt;</code></li></ul><h2 id="Solution-dp自顶向下"><a href="#Solution-dp自顶向下" class="headerlink" title="Solution - dp自顶向下"></a>Solution - dp自顶向下</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">​<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; table;</span><br><span class="line">    <span class="comment">// map&lt;int, int&gt; table;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (amount &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (table[amount] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> table[amount];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = dp(coins, amount - coins[i]);</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">min</span>(temp + <span class="number">1</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = (result == INT_MAX ? <span class="number">-1</span> : result);</span><br><span class="line">        table[amount] = result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &lt; <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        table.resize(amount + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp(coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;322-零钱兑换&quot;&gt;&lt;a href=&quot;#322-零钱兑换&quot; class=&quot;headerlink&quot; title=&quot;322. 零钱兑换&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/coin-change/&quot; targe
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://blog.lsmg.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣2.2-H72.编辑距离</title>
    <link href="http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A32.2-H72.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A32.2-H72.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</id>
    <published>2021-01-12T14:10:02.000Z</published>
    <updated>2021-02-02T04:59:47.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></h1><p>Difficulty: <strong>困难</strong></p><p>给你两个单词 <code>word1</code> 和 <code>word2</code>，请你计算出将 <code>word1</code> 转换成 <code>word2</code>所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：word1 &#x3D; &quot;intention&quot;, word2 &#x3D; &quot;execution&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">intention -&gt; inention (删除 &#39;t&#39;)</span><br><span class="line">inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)</span><br><span class="line">enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)</span><br><span class="line">exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)</span><br><span class="line">exection -&gt; execution (插入 &#39;u&#39;)</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= word1.length, word2.length &lt;= 500</code></li><li><code>word1</code> 和 <code>word2</code> 由小写英文字母组成</li></ul><h2 id="Solution-回溯"><a href="#Solution-回溯" class="headerlink" title="Solution 回溯"></a>Solution 回溯</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> min_time = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        minDistance(word1, word2, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> min_time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2, <span class="keyword">int</span> ws1, <span class="keyword">int</span> ws2, <span class="keyword">int</span> time)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (time &gt;= min_time)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ws2 == word2.length() || ws1 == word1.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">min</span>(ws1, ws2); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i] != word2[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            time += word1.length() &gt; word2.length() ? word1.length() - word2.length() :  word2.length() - word1.length();</span><br><span class="line">            <span class="keyword">if</span> (time &lt; min_time)</span><br><span class="line">            &#123;</span><br><span class="line">                min_time = time;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1[ws1] == word2[ws2])</span><br><span class="line">            &#123;</span><br><span class="line">                minDistance(word1, word2, ws1 + <span class="number">1</span>, ws2 + <span class="number">1</span>, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> back = word1[ws1];</span><br><span class="line">                word1[ws1] = word2[ws2];</span><br><span class="line">                minDistance(word1, word2, ws1 + <span class="number">1</span>, ws2 + <span class="number">1</span>, time + <span class="number">1</span>);</span><br><span class="line">                word1[ws1] = back;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">string</span> back_str = word1;</span><br><span class="line">                word1.erase(ws1, <span class="number">1</span>);</span><br><span class="line">                minDistance(word1, word2, ws1, ws2, time + <span class="number">1</span>);</span><br><span class="line">                word1 = back_str;</span><br><span class="line"></span><br><span class="line">                word1.insert(ws1, <span class="number">1</span>, word2[ws2]);</span><br><span class="line">                minDistance(word1, word2, ws1 + <span class="number">1</span>, ws2 + <span class="number">1</span>, time + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution-DP备忘录"><a href="#Solution-DP备忘录" class="headerlink" title="Solution DP备忘录"></a>Solution DP备忘录</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">​<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; bwl;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minDistance(word1, word2, word1.length() - <span class="number">1</span>, word2.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; word1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; word2, <span class="keyword">int</span> ws1, <span class="keyword">int</span> ws2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ws1 == <span class="number">-1</span>) <span class="keyword">return</span> ws2 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws2 == <span class="number">-1</span>) <span class="keyword">return</span> ws1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> key = to_string(ws1) + <span class="string">"#"</span> + to_string(ws2);</span><br><span class="line">        <span class="keyword">if</span> (bwl.<span class="built_in">find</span>(key) != bwl.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> bwl[key];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (word1[ws1] == word2[ws2])</span><br><span class="line">        &#123;</span><br><span class="line">            bwl[key] = minDistance(word1, word2, ws1 - <span class="number">1</span>, ws2 - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            bwl[key] = <span class="built_in">min</span>(&#123;</span><br><span class="line">                minDistance(word1, word2, ws1, ws2 - <span class="number">1</span>), <span class="comment">// 插入</span></span><br><span class="line">                minDistance(word1, word2, ws1 - <span class="number">1</span>, ws2 - <span class="number">1</span>), <span class="comment">// 替换</span></span><br><span class="line">                minDistance(word1, word2, ws1 - <span class="number">1</span>, ws2) <span class="comment">// 删除</span></span><br><span class="line">            &#125;) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bwl[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Solution-DP-Table"><a href="#Solution-DP-Table" class="headerlink" title="Solution DP Table"></a>Solution DP Table</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word2.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]  = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= word1.length(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ws1 = <span class="number">1</span>; ws1 &lt;= word1.length(); ++ws1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ws2 = <span class="number">1</span>; ws2 &lt;= word2.length(); ++ws2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[ws1 - <span class="number">1</span>] == word2[ws2 - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[ws1][ws2] = dp[ws1 - <span class="number">1</span>][ws2 - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[ws1][ws2] = <span class="built_in">min</span>(&#123;</span><br><span class="line">                        dp[ws1 - <span class="number">1</span>][ws2 - <span class="number">1</span>],</span><br><span class="line">                        dp[ws1][ws2 - <span class="number">1</span>],</span><br><span class="line">                        dp[ws1 - <span class="number">1</span>][ws2]</span><br><span class="line">                    &#125;) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用回溯法的代码超时了, 而且回溯解法里面对字符串进行了实打实的修改</p><p>从回溯法转向DP备忘录优化了一个参数 使用返回值返回答案而不是单独的time参数. DP备忘录由于使用了递归所以使用的空间大, 效率也低 </p><p>观察DP备忘录<br><code>dp[ws1][ws2]</code>只跟<code>dp[ws1-1][ws2-1]</code>, <code>dp[ws1][ws2-1]</code>和<code>dp[ws1-1][ws2]</code>有关进而自然的转向DP Table</p><p>Dp Table这里数组一般都需要多开一行+一列 对应代码里面的<code>length()+1</code>, 否则下标0含有两层意思 一是空串时长度为0 二是非空串是含有0这个有效下标</p><p>所以将非空串的下标改为从1开始</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;72-编辑距离&quot;&gt;&lt;a href=&quot;#72-编辑距离&quot; class=&quot;headerlink&quot; title=&quot;72. 编辑距离&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/edit-distance/&quot; target
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="动态规划" scheme="http://blog.lsmg.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣1.10-N652. 寻找重复的子树</title>
    <link href="http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A31.10-N652.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/"/>
    <id>http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A31.10-N652.%20%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/</id>
    <published>2021-01-10T02:10:02.000Z</published>
    <updated>2021-01-10T02:11:44.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="652-寻找重复的子树"><a href="#652-寻找重复的子树" class="headerlink" title="652. 寻找重复的子树"></a><a href="https://leetcode-cn.com/problems/find-duplicate-subtrees/" target="_blank" rel="noopener">652. 寻找重复的子树</a></h1><p>Difficulty: <strong>中等</strong></p><p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p><p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   3</span><br><span class="line"> &#x2F;   &#x2F; \</span><br><span class="line">4   2   4</span><br><span class="line">   &#x2F;</span><br><span class="line">  4</span><br></pre></td></tr></table></figure><p>下面是两个重复的子树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2</span><br><span class="line"> &#x2F;</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>因此，你需要以列表的形式返回上述重复子树的根结点。</p><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">​<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; result_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; node_map_;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        solve(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">solve</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> left = solve(root-&gt;left);</span><br><span class="line">        <span class="built_in">string</span> right = solve(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> sum = left + <span class="string">","</span> + right + <span class="string">","</span> + to_string(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node_map_.<span class="built_in">find</span>(sum) == node_map_.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            node_map_.insert(&#123;sum, <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (node_map_[sum] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result_.push_back(root);</span><br><span class="line">            &#125;</span><br><span class="line">            node_map_[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;652-寻找重复的子树&quot;&gt;&lt;a href=&quot;#652-寻找重复的子树&quot; class=&quot;headerlink&quot; title=&quot;652. 寻找重复的子树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/find-dupli
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="二叉树" scheme="http://blog.lsmg.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux-IO状态相关命令</title>
    <link href="http://blog.lsmg.xyz/2021/01/Linux-IO%E7%8A%B6%E6%80%81%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.lsmg.xyz/2021/01/Linux-IO%E7%8A%B6%E6%80%81%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</id>
    <published>2021-01-09T10:53:22.000Z</published>
    <updated>2021-01-09T10:23:39.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yum install sysstat -y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@fish ~]# iostat</span><br><span class="line">Linux 4.18.0-193.6.3.el8_2.x86_6401&#x2F;09&#x2F;2021 _x86_64_(4 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.06    0.02    0.08    0.01    0.00   99.84</span><br><span class="line"></span><br><span class="line">Device             tps    kB_read&#x2F;s    kB_wrtn&#x2F;s    kB_read    kB_wrtn</span><br><span class="line">sda               0.00         1.68         0.00    3520393       3015</span><br><span class="line">sdb               0.16         0.81         2.68    1702968    5612922</span><br><span class="line">dm-0              0.17         0.79         2.78    1656682    5811573</span><br><span class="line">dm-1              0.00         0.00         0.01       4404      10828</span><br><span class="line">dm-2              0.00         0.00         0.00       1193       2209</span><br></pre></td></tr></table></figure><h1 id="df"><a href="#df" class="headerlink" title="df"></a>df</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@fish ~]# df -h</span><br><span class="line">Filesystem           Size  Used Avail Use% Mounted on</span><br><span class="line">devtmpfs             1.8G     0  1.8G   0% &#x2F;dev</span><br><span class="line">tmpfs                1.8G   84K  1.8G   1% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs                1.8G   40M  1.8G   3% &#x2F;run</span><br><span class="line">tmpfs                1.8G     0  1.8G   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">&#x2F;dev&#x2F;mapper&#x2F;cl-root   19G   13G  6.5G  67% &#x2F;</span><br><span class="line">&#x2F;dev&#x2F;sda             112G   34G   79G  30% &#x2F;nas1</span><br><span class="line">&#x2F;dev&#x2F;mapper&#x2F;cl-home  4.0G   61M  4.0G   2% &#x2F;home</span><br><span class="line">&#x2F;dev&#x2F;sdb1            2.0G  211M  1.6G  12% &#x2F;boot</span><br><span class="line">tmpfs                368M     0  368M   0% &#x2F;run&#x2F;user&#x2F;0</span><br></pre></td></tr></table></figure><h1 id="du"><a href="#du" class="headerlink" title="du"></a>du</h1><p>estimate file space usage</p><p>估计文件空间使用量 默认察看当前目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@fish ~]# du -h</span><br><span class="line">8.0K.&#x2F;book</span><br><span class="line">244K.&#x2F;.halo&#x2F;logs</span><br><span class="line">72K.&#x2F;.halo&#x2F;db</span><br><span class="line">36K.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source&#x2F;plugins&#x2F;prism&#x2F;css</span><br><span class="line">152K.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source&#x2F;plugins&#x2F;prism&#x2F;js</span><br><span class="line">188K.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source&#x2F;plugins&#x2F;prism</span><br><span class="line">900K.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source&#x2F;plugins&#x2F;gallery&#x2F;fonts</span><br><span class="line">32K.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source&#x2F;plugins&#x2F;gallery&#x2F;css&#x2F;images</span><br><span class="line">104K.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source&#x2F;plugins&#x2F;gallery&#x2F;css</span><br><span class="line">56K.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source&#x2F;plugins&#x2F;gallery&#x2F;js&#x2F;ie</span><br><span class="line">180K.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source&#x2F;plugins&#x2F;gallery&#x2F;js</span><br><span class="line">1.2M.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source&#x2F;plugins&#x2F;gallery</span><br><span class="line">1.4M.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source&#x2F;plugins</span><br><span class="line">72K.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source&#x2F;images</span><br><span class="line">1.1M.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source&#x2F;fonts</span><br><span class="line">80K.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source&#x2F;css</span><br><span class="line">356K.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source&#x2F;js</span><br><span class="line">2.9M.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;source</span><br><span class="line">24K.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole&#x2F;module</span><br><span class="line">3.1M.&#x2F;.halo&#x2F;templates&#x2F;themes&#x2F;anatole</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iostat&quot;&gt;&lt;a href=&quot;#iostat&quot; class=&quot;headerlink&quot; title=&quot;iostat&quot;&gt;&lt;/a&gt;iostat&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="iostat" scheme="http://blog.lsmg.xyz/tags/iostat/"/>
    
      <category term="df" scheme="http://blog.lsmg.xyz/tags/df/"/>
    
      <category term="du" scheme="http://blog.lsmg.xyz/tags/du/"/>
    
  </entry>
  
  <entry>
    <title>Linux-进程线程状态相关命令</title>
    <link href="http://blog.lsmg.xyz/2021/01/Linux-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.lsmg.xyz/2021/01/Linux-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</id>
    <published>2021-01-09T02:53:22.000Z</published>
    <updated>2021-01-09T10:16:37.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="top"><a href="#top" class="headerlink" title="top"></a>top</h1><p>Linux下的任务管理器</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux/top.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 察看多核心CPU各个核心的情况</span><br><span class="line"></span><br><span class="line">P 按照CPU使用率排行</span><br><span class="line">T 按照CPU使用时间排行</span><br><span class="line">M 按照物理内存使用率排行</span><br><span class="line"></span><br><span class="line">top -p xx 察看指定pid的信息</span><br></pre></td></tr></table></figure><h1 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h1><p>更加现代的top 有颜色 支持鼠标 杀进程极其方便</p><p><img src="https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux/htop.png" alt=""></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install epel-release</span><br><span class="line"></span><br><span class="line">sudo yum install htop</span><br></pre></td></tr></table></figure><h1 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h1><p>跟踪进程运行时使用的系统调用和信号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-t          每行前加上输出信息</span><br><span class="line"></span><br><span class="line">-tt         the time printed will include the microseconds.</span><br><span class="line"></span><br><span class="line">-ttt        开头部分将打印为自该纪元以来的秒数。 the time printed will include the microseconds</span><br><span class="line"></span><br><span class="line">-T          显示系统调用所需时间</span><br><span class="line"></span><br><span class="line">-o          输出文件</span><br><span class="line"></span><br><span class="line">-p          指定pid</span><br><span class="line"></span><br><span class="line">-f -F       跟踪fork和vfork</span><br></pre></td></tr></table></figure><p>strace -T -tt -p $(lsof -i tcp:4000 -t) -o /root/live.log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">17:27:51.212449 accept(5, &#123;sa_family&#x3D;AF_INET6, sin6_port&#x3D;htons(1596), inet_pton(AF_INET6, &quot;::ffff:10.4.168.250&quot;, &amp;sin6_addr), sin6_flowinfo&#x3D;htonl(0), sin6_scope_id&#x3D;0&#125;, [46-&gt;28]) &#x3D; 7 &lt;0.000046&gt;</span><br><span class="line">17:27:51.212686 write(1, &quot;[INFO ][ TcpServer.cpp:56 ]: cre&quot;..., 95) &#x3D; 95 &lt;0.000048&gt;</span><br><span class="line">17:27:51.212842 epoll_ctl(3, EPOLL_CTL_ADD, 7, &#123;EPOLLIN, &#123;u32&#x3D;17383160, u64&#x3D;17383160&#125;&#125;) &#x3D; 0 &lt;0.000058&gt;</span><br><span class="line">17:27:51.213006 epoll_wait(3, [&#123;EPOLLIN, &#123;u32&#x3D;17383160, u64&#x3D;17383160&#125;&#125;], 50, 20) &#x3D; 1 &lt;0.000028&gt;</span><br><span class="line">17:27:51.213131 recvfrom(7, &quot;GET &#x2F;lsmg HTTP&#x2F;1.1\r\nHost: live.l&quot;..., 4096, 0, NULL, NULL) &#x3D; 358 &lt;0.000031&gt;</span><br><span class="line">17:27:51.213295 write(1, &quot;[INFO ][ main.cpp:67 ]: connecti&quot;..., 105) &#x3D; 105 &lt;0.000038&gt;</span><br><span class="line">17:27:51.213461 write(1, &quot;[INFO ][ RtmpServerConnection.cp&quot;..., 144) &#x3D; 144 &lt;0.000040&gt;</span><br><span class="line">17:27:51.213648 sendto(7, &quot;HTTP&#x2F;1.1 200 OK\r\nServer: FISH_LI&quot;..., 703, 0, NULL, 0) &#x3D; 703 &lt;0.000091&gt;</span><br><span class="line">17:27:51.213886 sendto(7, &quot;35d\r\n\0\0\0&lt;\10\0\3N\1-!\0\0\0\0\257\1!\fT-\3754\21\10\35\343&quot;..., 868, 0, NULL, 0) &#x3D; 868 &lt;0.000030&gt;</span><br><span class="line">17:27:51.214032 epoll_wait(3, [&#123;EPOLLIN, &#123;u32&#x3D;17360872, u64&#x3D;17360872&#125;&#125;], 50, 20) &#x3D; 1 &lt;0.005512&gt;</span><br><span class="line">17:27:51.219659 recvfrom(6, &quot;D\0\0\n\0&#125;\354\t&#39;\1\0\0S\0\0&#125;\343A\232\3534LG\377\363 \0\0\3\0\1,&quot;..., 4096, 0, NULL, NULL) &#x3D; 4096 &lt;0.000057&gt;</span><br><span class="line">17:27:51.219857 epoll_wait(3, [&#123;EPOLLIN, &#123;u32&#x3D;17360872, u64&#x3D;17360872&#125;&#125;], 50, 20) &#x3D; 1 &lt;0.000028&gt;</span><br><span class="line">17:27:51.219978 recvfrom(6, &quot;\266S\231C\363J\342(\304\274]\3361\354:~\37r\363\332&#39;\366\30\276\261\344\1\312\242\230R\t&quot;..., 4096, 0, NULL, NULL) &#x3D; 4096 &lt;0.000029&gt;</span><br><span class="line">17:27:51.220117 epoll_wait(3, [&#123;EPOLLIN, &#123;u32&#x3D;17360872, u64&#x3D;17360872&#125;&#125;], 50, 20) &#x3D; 1 &lt;0.000026&gt;</span><br><span class="line">17:27:51.220237 recvfrom(6, &quot;\0014O2hll\300&quot;, 8, 0, NULL, NULL) &#x3D; 8 &lt;0.000026&gt;</span><br><span class="line">17:27:51.220371 epoll_wait(3, [&#123;EPOLLIN, &#123;u32&#x3D;17360872, u64&#x3D;17360872&#125;&#125;], 50, 20) &#x3D; 1 &lt;0.000025&gt;</span><br><span class="line">17:27:51.220504 recvfrom(6, &quot;h\304\23\227&#39;c\341\355\263\330n\245\0021\3048\\\331n\226y\313\370Bu\371\242&#x3D;\233\250\316\226&quot;..., 4096, 0, NULL, NULL) &#x3D; 4096 &lt;0.000029&gt;</span><br><span class="line">17:27:51.220641 epoll_wait(3, [&#123;EPOLLIN, &#123;u32&#x3D;17360872, u64&#x3D;17360872&#125;&#125;], 50, 20) &#x3D; 1 &lt;0.000025&gt;</span><br><span class="line">17:27:51.220762 recvfrom(6, &quot;\207&quot;, 1, 0, NULL, NULL) &#x3D; 1 &lt;0.000026&gt;</span><br><span class="line">17:27:51.220895 epoll_wait(3, [&#123;EPOLLIN, &#123;u32&#x3D;17360872, u64&#x3D;17360872&#125;&#125;], 50, 20) &#x3D; 1 &lt;0.000025&gt;</span><br><span class="line">17:27:51.221010 recvfrom(6, &quot;\324\304\260-\337\316\3261\311\260F\256\233\377\302\327\236\366\2249\3\361\273\r0H|\3415C]I&quot;..., 4096, 0, NULL, NULL) &#x3D; 4096 &lt;0.000027&gt;</span><br></pre></td></tr></table></figure><h1 id="pstack"><a href="#pstack" class="headerlink" title="pstack"></a>pstack</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@fish ~]# pstack $(lsof -i tcp:4000 -t)</span><br><span class="line">#0  0x00007f8b40e5b17b in epoll_wait (epfd&#x3D;3, events&#x3D;0x108dfb0, maxevents&#x3D;50, timeout&#x3D;20) at ..&#x2F;sysdeps&#x2F;unix&#x2F;sysv&#x2F;linux&#x2F;epoll_wait.c:30</span><br><span class="line">#1  0x0000000000446668 in Epoll::LoopOnce (this&#x3D;0x108df80, timeout&#x3D;20, active_channels&#x3D;0x7ffcbd1242f8) at &#x2F;tmp&#x2F;tmp.p1UxXqj1vP&#x2F;network&#x2F;multiplexing&#x2F;Epoll.cpp:18</span><br><span class="line">#2  0x0000000000443d9c in EventLoop::Loop (this&#x3D;0x7ffcbd1242f0) at &#x2F;tmp&#x2F;tmp.p1UxXqj1vP&#x2F;network&#x2F;EventLoop.cpp:31</span><br><span class="line">#3  0x0000000000438d48 in main (argc&#x3D;3, argv&#x3D;0x7ffcbd1244d8) at &#x2F;tmp&#x2F;tmp.p1UxXqj1vP&#x2F;main.cpp:106</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;top&quot;&gt;&lt;a href=&quot;#top&quot; class=&quot;headerlink&quot; title=&quot;top&quot;&gt;&lt;/a&gt;top&lt;/h1&gt;&lt;p&gt;Linux下的任务管理器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lsmg-img.oss-cn-beijing.aliy
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="top" scheme="http://blog.lsmg.xyz/tags/top/"/>
    
      <category term="htop" scheme="http://blog.lsmg.xyz/tags/htop/"/>
    
      <category term="strace" scheme="http://blog.lsmg.xyz/tags/strace/"/>
    
      <category term="pstack" scheme="http://blog.lsmg.xyz/tags/pstack/"/>
    
  </entry>
  
  <entry>
    <title>力扣1.9-N105&amp;N106</title>
    <link href="http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A31.9-N105&amp;N106/"/>
    <id>http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A31.9-N105&amp;N106/</id>
    <published>2021-01-09T01:31:02.000Z</published>
    <updated>2021-01-09T02:28:02.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h1><p>Difficulty: <strong>中等</strong></p><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>(), </span><br><span class="line">        inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="keyword">int</span> preb, <span class="keyword">int</span> pree,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> inb, <span class="keyword">int</span> ine)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preb == pree)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(preorder[preb]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> in_root;</span><br><span class="line">        <span class="keyword">for</span> (in_root = inb; in_root &lt; ine; ++in_root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (preorder[preb] == inorder[in_root])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = in_root - inb;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = build(preorder, preb + <span class="number">1</span>, preb + <span class="number">1</span> + num, inorder, inb, in_root);</span><br><span class="line">        root-&gt;right = build(preorder, preb + <span class="number">1</span> + num, pree, inorder, in_root + <span class="number">1</span>, ine);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="106-从中序与后序遍历序列构造二叉树"><a href="#106-从中序与后序遍历序列构造二叉树" class="headerlink" title="106. 从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></h1><p>Difficulty: <strong>中等</strong></p><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p><strong>注意:</strong><br>你可以假设树中没有重复的元素。</p><p>例如，给出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder &#x3D; [9,15,7,20,3]</span><br></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">​<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.<span class="built_in">size</span>(), postorder, <span class="number">0</span>, postorder.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> inb, <span class="keyword">int</span> ine, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> pob, <span class="keyword">int</span> poe)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inb == ine)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(postorder[poe - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> in_root;</span><br><span class="line">        <span class="keyword">for</span> (in_root = inb; in_root &lt; ine; ++in_root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[in_root] == postorder[poe - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = in_root - inb;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = build(inorder, inb, in_root, postorder, pob, pob + num);</span><br><span class="line">        root-&gt;right = build(inorder, in_root + <span class="number">1</span>, ine, postorder, pob + num, poe - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;105-从前序与中序遍历序列构造二叉树&quot;&gt;&lt;a href=&quot;#105-从前序与中序遍历序列构造二叉树&quot; class=&quot;headerlink&quot; title=&quot;105. 从前序与中序遍历序列构造二叉树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="二叉树" scheme="http://blog.lsmg.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>力扣1.8-H24.两两交换链表中的节点&amp;E26.删除排序数组中的重复项</title>
    <link href="http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A31.8-H24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9&amp;E26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <id>http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A31.8-H24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9&amp;E26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</id>
    <published>2021-01-08T08:21:02.000Z</published>
    <updated>2021-01-09T02:27:34.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h1><p>Difficulty: <strong>中等</strong></p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head &#x3D; [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* temp = node-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!temp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* back = temp-&gt;next;</span><br><span class="line">        temp-&gt;next = node;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = swapPairs(back);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></h1><p>Difficulty: <strong>简单</strong></p><p>给定一个排序数组，你需要在 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len &#x3D; removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">​<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == num)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = nums[i];</span><br><span class="line">            nums[t++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;24-两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#24-两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;24. 两两交换链表中的节点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/swap
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="二叉树" scheme="http://blog.lsmg.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>力扣1.7-N17&amp;N19&amp;E21</title>
    <link href="http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A31.7-N17&amp;N19&amp;E21/"/>
    <id>http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A31.7-N17&amp;N19&amp;E21/</id>
    <published>2021-01-07T08:21:02.000Z</published>
    <updated>2021-01-09T02:27:27.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h1><p>Difficulty: <strong>中等</strong></p><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt=""></p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h2 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">​<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (digits.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            solve(digits, <span class="number">0</span>, <span class="string">""</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; digits, <span class="keyword">int</span> sub, <span class="built_in">string</span> temp, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sub == digits.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> <span class="built_in">begin</span> = (digits[sub] - <span class="string">'2'</span>) * <span class="number">3</span> + <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">switch</span> (digits[sub])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'4'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'5'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'6'</span>:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">char</span> a = <span class="built_in">begin</span> + i;</span><br><span class="line">                        solve(digits, sub + <span class="number">1</span>, temp + a, result);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'7'</span>:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">char</span> a = <span class="built_in">begin</span> + i;</span><br><span class="line">                        solve(digits, sub + <span class="number">1</span>, temp + a, result);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'8'</span>:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">begin</span> += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">char</span> a = <span class="built_in">begin</span> + i;</span><br><span class="line">                        solve(digits, sub + <span class="number">1</span>, temp + a, result);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'9'</span>:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">begin</span> += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">char</span> a = <span class="built_in">begin</span> + i;</span><br><span class="line">                        solve(digits, sub + <span class="number">1</span>, temp + a, result);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></h1><p>Difficulty: <strong>中等</strong></p><p>给定一个链表，删除链表的倒数第 _n _个节点，并且返回链表的头结点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>n</em> 保证是有效的。</p><p><strong>进阶：</strong></p><p>你能尝试使用一趟扫描实现吗？</p><h2 id="Solution1-1"><a href="#Solution1-1" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">​<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* node = head;</span><br><span class="line">        ListNode* temp = node;</span><br><span class="line">        ListNode* last_temp = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> now_sub = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (now_sub == n - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                last_temp = temp;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">                now_sub++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp == head)</span><br><span class="line">        &#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            last_temp-&gt;next = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h1><p>Difficulty: <strong>简单</strong></p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 &#x3D; [], l2 &#x3D; [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><h2 id="Solution1-2"><a href="#Solution1-2" class="headerlink" title="Solution1"></a>Solution1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">​<span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* head = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            head = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            head = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l1 || l2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!l1)</span><br><span class="line">            &#123;</span><br><span class="line">                temp-&gt;next = l2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!l2)</span><br><span class="line">            &#123;</span><br><span class="line">                temp-&gt;next = l1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)</span><br><span class="line">                &#123;</span><br><span class="line">                    temp-&gt;next = l1;</span><br><span class="line">                    l1 = l1-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    temp-&gt;next = l2;</span><br><span class="line">                    l2 = l2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;17-电话号码的字母组合&quot;&gt;&lt;a href=&quot;#17-电话号码的字母组合&quot; class=&quot;headerlink&quot; title=&quot;17. 电话号码的字母组合&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/letter-
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="二叉树" scheme="http://blog.lsmg.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>pthread&amp;thread</title>
    <link href="http://blog.lsmg.xyz/2021/01/CPP-pthread&amp;thread/"/>
    <id>http://blog.lsmg.xyz/2021/01/CPP-pthread&amp;thread/</id>
    <published>2021-01-03T03:27:27.000Z</published>
    <updated>2021-01-14T13:43:00.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h1><h2 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PthreadLinux</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> thread1; <span class="comment">// 存储线程标识</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_attr_t</span> thread1_attr;</span><br><span class="line">pthread_attr_init(&amp;thread1_attr);</span><br><span class="line"></span><br><span class="line">pthread_create(&amp;thread1, &amp;thread1_attr, Func, <span class="literal">nullptr</span>); <span class="comment">// 使用指定属性初始化线程</span></span><br><span class="line">    <span class="comment">// pthread_create(&amp;thread1, nullptr, Func, nullptr); 使用默认属性初始化线程</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"thread1-%d\n"</span>, thread1); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">pthread_join(<span class="number">1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Func</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span></span>&#123;<span class="built_in">printf</span>(<span class="string">"bar\n"</span>);&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PthreadCpp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">thread1</span><span class="params">(Func, <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">thread1.join();</span><br><span class="line"></span><br><span class="line">Foo foo;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">thread2</span><span class="params">(<span class="built_in">std</span>::bind(&amp;Foo::Bar, &amp;foo))</span></span>;</span><br><span class="line">thread2.join();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">thread3</span><span class="params">([&amp;foo]()&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">foo.Bar();</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;)</span></span>;</span><br><span class="line">thread3.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><h2 id="pthread-1"><a href="#pthread-1" class="headerlink" title="pthread"></a>pthread</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutexattr_t</span> mutex_attr;</span><br><span class="line">pthread_mutex_init(&amp;mutex, &amp;mutex_attr);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br></pre></td></tr></table></figure><h2 id="thread-1"><a href="#thread-1" class="headerlink" title="thread"></a>thread</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::mutex mutex1;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_guard</span><span class="params">(mutex1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><h2 id="pthread-2"><a href="#pthread-2" class="headerlink" title="pthread"></a>pthread</h2><h2 id="thread-2"><a href="#thread-2" class="headerlink" title="thread"></a>thread</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex condition_mutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConditionCpp</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">unique_lock</span><span class="params">(condition_mutex)</span></span>;</span><br><span class="line">var.wait(unique_lock);</span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ConditionCpp id : %d\n"</span>, id);</span><br><span class="line"></span><br><span class="line">unique_lock.unlock();</span><br><span class="line">var.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConditionCpp1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">threads.reserve(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">threads.emplace_back([i]()</span><br><span class="line">&#123;</span><br><span class="line">ConditionCpp(i);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var.notify_one();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : threads)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (thread.joinable())</span><br><span class="line">&#123;</span><br><span class="line">thread.join();</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConditionCpp id : 0</span></span><br><span class="line"><span class="comment">// ConditionCpp id : 1</span></span><br><span class="line"><span class="comment">// ConditionCpp id : 2</span></span><br><span class="line"><span class="comment">// ConditionCpp id : 3</span></span><br><span class="line"><span class="comment">// ConditionCpp id : 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Process finished with exit code 0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程创建&quot;&gt;&lt;a href=&quot;#线程创建&quot; class=&quot;headerlink&quot; title=&quot;线程创建&quot;&gt;&lt;/a&gt;线程创建&lt;/h1&gt;&lt;h2 id=&quot;pthread&quot;&gt;&lt;a href=&quot;#pthread&quot; class=&quot;headerlink&quot; title=&quot;pth
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>Shell脚本编写</title>
    <link href="http://blog.lsmg.xyz/2021/01/Linux-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/"/>
    <id>http://blog.lsmg.xyz/2021/01/Linux-shell%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99/</id>
    <published>2021-01-02T14:00:22.000Z</published>
    <updated>2021-01-02T14:39:15.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一行-解释器"><a href="#第一行-解释器" class="headerlink" title="第一行 - 解释器"></a>第一行 - 解释器</h1><ol><li><code>#!/bin/bash</code> 这个通常见于脚本的第一行, <code>#!</code>算是个约定了 说明脚本需要什么解释器</li><li><code>/bin/sh xx.sh</code> 这种是执行的时候指定, 脚本第一行的那个就失效了</li></ol><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>规范</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><p>shell变量类型</p><ul><li>局部变量</li><li>环境变量</li><li>shell变量-shell内置特殊变量</li></ul><p>变量定义 注意 不能随便加空格 下面的等号两侧不能加空格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接赋值</span></span><br><span class="line">xxx="lsmg"</span><br><span class="line">xxx = "lsmg" # 错误</span><br><span class="line">xxx="Jigokubana" # 随意修改</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 语句赋值</span></span><br><span class="line">for skill in Ada Coffe Action Java</span><br><span class="line">do</span><br><span class="line">    echo "I am good at $&#123;skill&#125;Script"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用变量</span></span><br><span class="line">echo $xxx</span><br><span class="line">echo $&#123;xxx&#125; # &#123;&#125; 用于标记边界</span><br><span class="line">echo "my name is $&#123;xxx&#125;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> const</span></span><br><span class="line">readonly xxx="lsmg" </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除变量</span></span><br><span class="line">unset xxx; 不能用于删除只读变量</span><br></pre></td></tr></table></figure><h1 id="单引号-双引号-反引号"><a href="#单引号-双引号-反引号" class="headerlink" title="单引号 双引号 反引号"></a>单引号 双引号 反引号</h1><p>单引号将剥夺其中的所有字符的特殊含义</p><p>双引号中的<code>$</code>（参数替换）和`（命令替换）有特殊含义</p><p>反引号与$()功能相同会执行其中的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aaa="aaa"</span><br><span class="line"></span><br><span class="line">b1="$aaa"</span><br><span class="line">b2=`$aaa` # 会先进行取变量值 $aaa -&gt; aaa</span><br><span class="line">b3='$aaa'</span><br><span class="line"></span><br><span class="line">echo $b1 # aaa</span><br><span class="line">echo $b2 # aaa: command not found </span><br><span class="line">echo $b3 # $aaa</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一行-解释器&quot;&gt;&lt;a href=&quot;#第一行-解释器&quot; class=&quot;headerlink&quot; title=&quot;第一行 - 解释器&quot;&gt;&lt;/a&gt;第一行 - 解释器&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;#!/bin/bash&lt;/code&gt; 这个通常见于脚本的第一行, &lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://blog.lsmg.xyz/categories/Linux/"/>
    
    
      <category term="Shell" scheme="http://blog.lsmg.xyz/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>力扣1.2-N654.最大二叉树</title>
    <link href="http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A31.2-N654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A31.2-N654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-01-02T08:21:02.000Z</published>
    <updated>2021-01-02T14:06:32.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="654-最大二叉树"><a href="#654-最大二叉树" class="headerlink" title="654. 最大二叉树"></a><a href="https://leetcode-cn.com/problems/maximum-binary-tree/" target="_blank" rel="noopener">654. 最大二叉树</a></h1><p>Difficulty: <strong>中等</strong></p><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ol><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ol><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p><strong>示例 ：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,2,1,6,0,5]</span><br><span class="line">输出：返回下面这棵树的根节点：</span><br><span class="line"></span><br><span class="line">      6</span><br><span class="line">    &#x2F;   \</span><br><span class="line">   3     5</span><br><span class="line">    \    &#x2F; </span><br><span class="line">     2  0   </span><br><span class="line">       \</span><br><span class="line">        1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>给定的数组的大小在 [1, 1000] 之间。</li></ol><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetMaxSub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[result])</span><br><span class="line">            &#123;</span><br><span class="line">                result = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_sub = GetMaxSub(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[max_sub]);</span><br><span class="line"></span><br><span class="line">        ConstructMaximumBinaryTree(nums, <span class="number">0</span>, max_sub, nums.<span class="built_in">size</span>(), root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ConstructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; mid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l_max = GetMaxSub(nums, left, mid);</span><br><span class="line">            root-&gt;left = <span class="keyword">new</span> TreeNode(nums[l_max]);</span><br><span class="line">            ConstructMaximumBinaryTree(nums, left, l_max, mid, root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (mid + <span class="number">1</span> &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r_max = GetMaxSub(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">            root-&gt;right = <span class="keyword">new</span> TreeNode(nums[r_max]);</span><br><span class="line">            ConstructMaximumBinaryTree(nums, mid + <span class="number">1</span>, r_max, right, root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>自己的第一个思路就是通过ConstructMaximumBinaryTree给传入的root节点构造左子树和右子树</p><p>然后递归的给root的左子树和右子树构造子树</p><p>每次传入left mid right将数组切分为两段 左段构造root的左子树 右段构造root的右子树</p><h2 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> constructMaximumBinaryTree(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left + <span class="number">1</span> &gt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max_sub = left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt; right; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[max_sub])</span><br><span class="line">            &#123;</span><br><span class="line">                max_sub = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> TreeNode(nums[max_sub]);</span><br><span class="line">        node-&gt;left = constructMaximumBinaryTree(nums, left, max_sub);</span><br><span class="line">        node-&gt;right = constructMaximumBinaryTree(nums, max_sub + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>题解的答案更加的简洁每次的constructMaximumBinaryTree仅负责构造一个节点返回回去成为左节点或者右节点</p><p>同时给构造出的节点赋值左节点和右节点.</p><p>相对我的代码构造左节点和右节点 这里淡化了左右节点的区别. 通过传入的参数即可知道是左右节点然后赋值给left right</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;654-最大二叉树&quot;&gt;&lt;a href=&quot;#654-最大二叉树&quot; class=&quot;headerlink&quot; title=&quot;654. 最大二叉树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-binary-t
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="二叉树" scheme="http://blog.lsmg.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>力扣1.1-N6Z字形变换&amp;E13罗马数字转整数</title>
    <link href="http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A31.1-N6&amp;E13/"/>
    <id>http://blog.lsmg.xyz/2021/01/%E5%8A%9B%E6%89%A31.1-N6&amp;E13/</id>
    <published>2021-01-01T11:06:02.000Z</published>
    <updated>2021-01-02T08:21:15.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. 罗马数字转整数</a></h1><p>Difficulty: <strong>简单</strong></p><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li></ul><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li><li>IC 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li><li>关于罗马数字的详尽书写规则，可以参考 。</li></ul><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> k[] = &#123;<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> v[] = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span> ,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> s_sub = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> k_sub = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (s_sub &lt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (;i &lt; k[k_sub].length(); ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[s_sub + i] != k[k_sub][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    k_sub++;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag)</span><br><span class="line">            &#123;</span><br><span class="line">                s_sub += i;</span><br><span class="line">                result += v[k_sub];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一次写出的代码没有通过是因为使用了Map存储的kv然后使用iterator++遍历, 然而iterator遍历并不是按照初始化的顺序而是按照k的大小</p><h2 id="代码2-样例"><a href="#代码2-样例" class="headerlink" title="代码2 - 样例"></a>代码2 - 样例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m[<span class="number">256</span>];</span><br><span class="line">        m[<span class="string">'I'</span>] = <span class="number">1</span>;</span><br><span class="line">        m[<span class="string">'V'</span>] = <span class="number">5</span>;</span><br><span class="line">        m[<span class="string">'X'</span>] = <span class="number">10</span>;</span><br><span class="line">        m[<span class="string">'L'</span>] = <span class="number">50</span>;</span><br><span class="line">        m[<span class="string">'C'</span>] = <span class="number">100</span>;</span><br><span class="line">        m[<span class="string">'D'</span>] = <span class="number">500</span>;</span><br><span class="line">        m[<span class="string">'M'</span>] = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[s[i]]&gt;=m[s[i+<span class="number">1</span>]])</span><br><span class="line">            &#123;</span><br><span class="line">                result+=m[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result-=m[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据的原理是 把一个小值放在大值的左边，就是做减法，否则为加法。</p><p>此外样例中的m数组设计的也是很巧妙, 只初始化自己要使用的部分, <strong>打破了我数组需要连续使用的思维定式</strong></p><h1 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. Z 字形变换</a></h1><p>Difficulty: <strong>中等</strong></p><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p><p>比如输入字符串为 <code>&quot;LEETCODEISHIRING&quot;</code> 行数为 3 时，排列如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure><p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p><p>请你实现这个将字符串进行指定行数变换的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;LEETCODEISHIRING&quot;, numRows &#x3D; 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;LEETCODEISHIRING&quot;, numRows &#x3D; 4</span><br><span class="line">输出: &quot;LDREOEIIECIHNTSG&quot;</span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure><h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> numRows)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; <span class="title">vec</span><span class="params">(numRows, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;(s.length(), <span class="string">' '</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> column = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ss = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ss &lt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ss &lt; s.length() &amp;&amp; i &lt; numRows; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                vec[i][column] = s[ss++];</span><br><span class="line">            &#125;</span><br><span class="line">            column++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = numRows - <span class="number">2</span>; ss &lt; s.length() &amp;&amp; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">            &#123;</span><br><span class="line">                vec[i][column] = s[ss++];</span><br><span class="line">                column++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (vec[i][j] != <span class="string">' '</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    result += vec[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;13-罗马数字转整数&quot;&gt;&lt;a href=&quot;#13-罗马数字转整数&quot; class=&quot;headerlink&quot; title=&quot;13. 罗马数字转整数&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/roman-to-inte
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="数组" scheme="http://blog.lsmg.xyz/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>力扣12.16-N450&amp;N701&amp;E700&amp;H98</title>
    <link href="http://blog.lsmg.xyz/2020/12/%E5%8A%9B%E6%89%A312.16-N450&amp;N701&amp;E700&amp;N98/"/>
    <id>http://blog.lsmg.xyz/2020/12/%E5%8A%9B%E6%89%A312.16-N450&amp;N701&amp;E700&amp;N98/</id>
    <published>2020-12-16T01:06:02.000Z</published>
    <updated>2020-12-16T05:21:38.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="450-删除二叉搜索树中的节点"><a href="#450-删除二叉搜索树中的节点" class="headerlink" title="450. 删除二叉搜索树中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></h1><p>Difficulty: <strong>中等</strong></p><p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 *<em>key *</em>对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><ol><li>首先找到需要删除的节点；</li><li>如果找到了，删除它。</li></ol><p><strong>说明：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root &#x3D; [5,3,6,2,4,null,7]</span><br><span class="line">key &#x3D; 3</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   6</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line"></span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   6</span><br><span class="line"> &#x2F;     \</span><br><span class="line">2       7</span><br><span class="line"></span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line">   \   \</span><br><span class="line">    4   7</span><br></pre></td></tr></table></figure><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetMin</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!root-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                root-&gt;val = GetMin(root-&gt;right);</span><br><span class="line">                root-&gt;right = deleteNode(root-&gt;right, root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &gt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></h1><p>Difficulty: <strong>中等</strong></p><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [40,20,60,10,30,50,70], val &#x3D; 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [4,2,7,1,3,null,null,null,null,null,null], val &#x3D; 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定的树上的节点数介于 <code>0</code> 和 <code>10^4</code> 之间</li><li>每个节点都有一个唯一整数值，取值范围从 <code>0</code> 到 <code>10^8</code></li><li><code>-10^8 &lt;= val &lt;= 10^8</code></li><li>新值和原始二叉搜索树中的任意节点值都不同</li></ul><h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &lt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;right = insertIntoBST(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700. 二叉搜索树中的搜索</a></h1><p>Difficulty: <strong>简单</strong></p><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p><p>例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   7</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和值: 2</span><br></pre></td></tr></table></figure><p>你应该返回如下子树:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2     </span><br><span class="line"> &#x2F; \   </span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><p>在上述示例中，如果要找的值是 <code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>。</p><h2 id="代码1-2"><a href="#代码1-2" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h1><p>Difficulty: <strong>中等</strong></p><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><h2 id="代码1-3"><a href="#代码1-3" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root, TreeNode* <span class="built_in">min</span>, TreeNode* <span class="built_in">max</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">min</span> &amp;&amp; root-&gt;val &lt;= <span class="built_in">min</span>-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">max</span> &amp;&amp; root-&gt;val &gt;= <span class="built_in">max</span>-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root-&gt;left, <span class="built_in">min</span>, root) &amp;&amp;</span><br><span class="line">                isValidBST(root-&gt;right, root, <span class="built_in">max</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;450-删除二叉搜索树中的节点&quot;&gt;&lt;a href=&quot;#450-删除二叉搜索树中的节点&quot; class=&quot;headerlink&quot; title=&quot;450. 删除二叉搜索树中的节点&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problem
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="二叉树" scheme="http://blog.lsmg.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>力扣12.12-E226&amp;N116&amp;N114</title>
    <link href="http://blog.lsmg.xyz/2020/12/%E5%8A%9B%E6%89%A312.12-E226&amp;N116&amp;N114/"/>
    <id>http://blog.lsmg.xyz/2020/12/%E5%8A%9B%E6%89%A312.12-E226&amp;N116&amp;N114/</id>
    <published>2020-12-12T01:06:02.000Z</published>
    <updated>2020-12-16T02:28:24.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226. Invert Binary Tree"></a>226. Invert Binary Tree</h1><p>Invert a binary tree.</p><p>Example:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><p>Trivia:<br>This problem was inspired by this original tweet by Max Howell:</p><p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* temp = root-&gt;left;</span><br><span class="line">        root-&gt;left = root-&gt;right;</span><br><span class="line">        root-&gt;right = temp;</span><br><span class="line"></span><br><span class="line">        invertTree(root-&gt;left);</span><br><span class="line">        invertTree(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h1><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><p>struct Node {<br>  int val;<br>  Node *left;<br>  Node *right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><p>进阶：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你只能使用常量级额外空间。</span><br><span class="line">使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，&#39;#&#39; 标志着每一层的结束。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">树中节点的数量少于 4096</span><br><span class="line">-1000 &lt;&#x3D; node.val &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        connectTwoNode(root-&gt;left, root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connectTwoNode</span><span class="params">(Node* node1, Node* node2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node1 || !node2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node1-&gt;next = node2;</span><br><span class="line">        connectTwoNode(node1-&gt;left, node1-&gt;right);</span><br><span class="line">        connectTwoNode(node2-&gt;left, node2-&gt;right);</span><br><span class="line">        connectTwoNode(node1-&gt;right, node2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114. 二叉树展开为链表</h1><p>给定一个二叉树，原地将它展开为一个单链表。</p><p>例如，给定二叉树</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   5</span><br><span class="line"> &#x2F; \   \</span><br><span class="line">3   4   6</span><br></pre></td></tr></table></figure><p>将其展开为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flatten(root-&gt;left);</span><br><span class="line">        flatten(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        TreeNode* right = root-&gt;right;</span><br><span class="line">        root-&gt;right = root-&gt;left;</span><br><span class="line">        root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* temp = root;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp-&gt;right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;226-Invert-Binary-Tree&quot;&gt;&lt;a href=&quot;#226-Invert-Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;226. Invert Binary Tree&quot;&gt;&lt;/a&gt;226. Invert Binary 
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="二叉树" scheme="http://blog.lsmg.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>class struct typename</title>
    <link href="http://blog.lsmg.xyz/2020/12/CPP-class%20struct%20typename/"/>
    <id>http://blog.lsmg.xyz/2020/12/CPP-class%20struct%20typename/</id>
    <published>2020-12-08T11:08:08.000Z</published>
    <updated>2020-12-11T08:38:07.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="class-和-struct的区别"><a href="#class-和-struct的区别" class="headerlink" title="class 和 struct的区别"></a>class 和 struct的区别</h1><ol><li>class默认访问权限是private, struct默认访问权限是public</li><li>class默认private继承, struct默认public继承</li><li>class可以使用模板, struct不能使用模板</li><li>struct在没有构造函数, 可以使用大括号初始化. class则要求全部public下才能大括号初始化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo1</span> &#123;</span>&#125; foo1;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo2</span> &#123;</span>&#125; foo2;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo3</span> &#123;</span><span class="keyword">int</span> a; <span class="keyword">int</span> b;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo4</span>&#123;</span><span class="keyword">int</span> a; <span class="keyword">int</span> b;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo44</span>&#123;</span><span class="keyword">public</span>: <span class="keyword">int</span> a; <span class="keyword">int</span> b;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof struct-Foo1: %zu\n"</span>, <span class="keyword">sizeof</span> foo1); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof class-Foo2: %zu\n"</span>, <span class="keyword">sizeof</span> foo2); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    Foo3 foo3 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="comment">// Foo4 foo4 = &#123;1, 2&#125;; error: could not convert ‘&#123;1, 2&#125;’ from ‘&lt;brace-enclosed initializer list&gt;’ to ‘Foo4’</span></span><br><span class="line">    Foo44 foo44 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="typename-class"><a href="#typename-class" class="headerlink" title="typename class"></a>typename class</h1><p><a href="https://stackoverflow.com/questions/2023977/difference-of-keywords-typename-and-class-in-templates" target="_blank" rel="noopener">https://stackoverflow.com/questions/2023977/difference-of-keywords-typename-and-class-in-templates</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;class-和-struct的区别&quot;&gt;&lt;a href=&quot;#class-和-struct的区别&quot; class=&quot;headerlink&quot; title=&quot;class 和 struct的区别&quot;&gt;&lt;/a&gt;class 和 struct的区别&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;clas
      
    
    </summary>
    
    
      <category term="CPP" scheme="http://blog.lsmg.xyz/categories/CPP/"/>
    
    
  </entry>
  
  <entry>
    <title>力扣12.8-E7整数反转&amp;汉诺塔</title>
    <link href="http://blog.lsmg.xyz/2020/12/%E5%8A%9B%E6%89%A312.8-E7%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC&amp;%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    <id>http://blog.lsmg.xyz/2020/12/%E5%8A%9B%E6%89%A312.8-E7%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC&amp;%E6%B1%89%E8%AF%BA%E5%A1%94/</id>
    <published>2020-12-08T04:50:02.000Z</published>
    <updated>2020-12-08T07:33:15.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h1><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p>示例 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><p> 示例 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><p>注意:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-integer" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-integer</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (result &gt; INT_MAX / <span class="number">10</span> || (result == INT_MAX / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 2^31 - 1 = 2147483647</span></span><br><span class="line">            <span class="keyword">if</span> (result &lt; INT_MIN / <span class="number">10</span> || (result == INT_MIN / <span class="number">10</span> &amp;&amp; pop &lt; <span class="number">-8</span>)) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// -2^31 = -2147483648</span></span><br><span class="line">            result = result * <span class="number">10</span> + pop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h1><p>在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p><p>请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</p><p>你需要原地修改栈。</p><p>示例1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [2, 1, 0], B &#x3D; [], C &#x3D; []</span><br><span class="line">输出：C &#x3D; [2, 1, 0]</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A &#x3D; [1, 0], B &#x3D; [], C &#x3D; []</span><br><span class="line">输出：C &#x3D; [1, 0]</span><br></pre></td></tr></table></figure><p>提示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A中盘子的数目不大于14个。</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/hanota-lcci" target="_blank" rel="noopener">https://leetcode-cn.com/problems/hanota-lcci</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h2 id="代码1-1"><a href="#代码1-1" class="headerlink" title="代码1"></a>代码1</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hanota</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">move</span>(n, A, B, C);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            C.push_back(A.back());</span><br><span class="line">            A.pop_back();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">move</span>(n<span class="number">-1</span>, A, C, B);    <span class="comment">// 将A上面n-1个通过C移到B</span></span><br><span class="line">        C.push_back(A.back());  <span class="comment">// 将A最后一个移到C</span></span><br><span class="line">        A.pop_back();          <span class="comment">// 这时，A空了</span></span><br><span class="line">        <span class="built_in">move</span>(n<span class="number">-1</span>, B, A, C);     <span class="comment">// 将B上面n-1个通过空的A移到C</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;整数反转&quot;&gt;&lt;a href=&quot;#整数反转&quot; class=&quot;headerlink&quot; title=&quot;整数反转&quot;&gt;&lt;/a&gt;整数反转&lt;/h1&gt;&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
    
      <category term="力扣每日一题" scheme="http://blog.lsmg.xyz/categories/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="数学" scheme="http://blog.lsmg.xyz/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
