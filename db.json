{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/favicons/android-chrome-192x192.png","path":"favicons/android-chrome-192x192.png","modified":1,"renderable":0},{"_id":"source/favicons/browserconfig.xml","path":"favicons/browserconfig.xml","modified":1,"renderable":0},{"_id":"source/favicons/apple-touch-icon.png","path":"favicons/apple-touch-icon.png","modified":1,"renderable":0},{"_id":"source/favicons/favicon-16x16.png","path":"favicons/favicon-16x16.png","modified":1,"renderable":0},{"_id":"source/favicons/site.webmanifest","path":"favicons/site.webmanifest","modified":1,"renderable":0},{"_id":"source/favicons/favicon-32x32.png","path":"favicons/favicon-32x32.png","modified":1,"renderable":0},{"_id":"source/favicons/favicon.ico","path":"favicons/favicon.ico","modified":1,"renderable":0},{"_id":"source/favicons/mstile-150x150.png","path":"favicons/mstile-150x150.png","modified":1,"renderable":0},{"_id":"themes/ylion/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"source/favicons/android-chrome-512x512.png","path":"favicons/android-chrome-512x512.png","modified":1,"renderable":0},{"_id":"themes/ylion/source/js/highsong.js","path":"js/highsong.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/app.js","path":"js/app.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/base.less","path":"css/base.less","modified":1,"renderable":1},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/thirdParty/busuanzi.min.js","path":"js/thirdParty/busuanzi.min.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/thirdParty/font-awesome.min.css","path":"css/thirdParty/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/ylion/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/pages/archive.less","path":"css/pages/archive.less","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/pages/article-exp.less","path":"css/pages/article-exp.less","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/pages/comments.css","path":"css/pages/comments.css","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/pages/othersPages.less","path":"css/pages/othersPages.less","modified":1,"renderable":1},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/pages/post.less","path":"css/pages/post.less","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.min.js","path":"js/thirdParty/gitment.browser.min.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/thirdParty/highlight.pack.js","path":"js/thirdParty/highlight.pack.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/thirdParty/leancloud.min.js","path":"js/thirdParty/leancloud.min.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/thirdParty/highlight/github.css","path":"css/thirdParty/highlight/github.css","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/thirdParty/highlight/solarized-light.css","path":"css/thirdParty/highlight/solarized-light.css","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.js","path":"js/thirdParty/gitment.browser.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.js.map","path":"js/thirdParty/gitment.browser.js.map","modified":1,"renderable":1},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.min.js.map","path":"js/thirdParty/gitment.browser.min.js.map","modified":1,"renderable":1}],"Cache":[{"_id":"themes/ylion/.gitignore","hash":"6e3a09b0d19dfe679aa416609d58581ea6bfa9b2","modified":1569415848000},{"_id":"source/CNAME","hash":"5d1b3c534b5001bee37dc2a8e8da866b00c2eb73","modified":1582768766363},{"_id":"themes/ylion/404.md","hash":"35eab98f14ba0ce50cba8f63b6e0d80328eb2fd0","modified":1569415848000},{"_id":"themes/ylion/CHANGELOG.md","hash":"c47c138626fe4917696ff5e96e629e78130ca5c6","modified":1569415848000},{"_id":"themes/ylion/LICENSE","hash":"5e65ec894a8c1a584620276b0b2d79a63101201c","modified":1569415848000},{"_id":"themes/ylion/README.md","hash":"31892094943eb72c371dc8df6c197c3403b8ab9a","modified":1569415848000},{"_id":"themes/ylion/_config.yml","hash":"82febd12eb2c96b637bb88f97d0ca8cd50fb816e","modified":1607140462093},{"_id":"themes/ylion/package.json","hash":"dc7a8b087254bfe3f83d09a5a8a0e0ab87885192","modified":1569415848000},{"_id":"source/favicons/android-chrome-192x192.png","hash":"05d291f0be2766b4f46a62fbabdc10b3d6ff092a","modified":1580092054000},{"_id":"source/favicons/browserconfig.xml","hash":"974aea18bda5a95802c06b80126ab1d96d91d708","modified":1580092054000},{"_id":"source/favicons/apple-touch-icon.png","hash":"f208d1156aee20488a1f98d902f5a674a7cc6d84","modified":1580092054000},{"_id":"source/favicons/favicon-16x16.png","hash":"c92eeb1df6654eb34f9cf354e3922a794021e377","modified":1580092054000},{"_id":"themes/ylion/_neededFile/search.ejs","hash":"5aed86cf52b0f0746426cbddbb96913880638d4c","modified":1569415848000},{"_id":"themes/ylion/languages/default.yml","hash":"ee1626dab2f76c04f07b49b3016f7e8354b907df","modified":1569415848000},{"_id":"source/favicons/site.webmanifest","hash":"13e5aa58eb2182d8ace63266856c8cc29c47c083","modified":1580092056000},{"_id":"themes/ylion/languages/ko.yml","hash":"a4dc4646a61974dee8983c9cfd72ff4c4b26fbe3","modified":1569415848000},{"_id":"source/favicons/favicon-32x32.png","hash":"8c3bb4b352237b05f8119644d91099c5288ca2b6","modified":1580092054000},{"_id":"source/favicons/favicon.ico","hash":"7819f8009e037fa738545f5645efc32457ebb9e0","modified":1580092056000},{"_id":"themes/ylion/languages/zh-CN.yml","hash":"267909418b5be5441c4ff44dfdf5003ee4bb9209","modified":1569415848000},{"_id":"source/favicons/mstile-150x150.png","hash":"266c87b17aa65bed8a431b5d88281ce488b03c6f","modified":1580092056000},{"_id":"themes/ylion/languages/zh-TW.yml","hash":"3e0fdbe453d96f3e6467e7aa97e60d1e93196398","modified":1569415848000},{"_id":"themes/ylion/layout/archive.ejs","hash":"913edfb62e33bd4eab564c62304d03833a5378a0","modified":1569415848000},{"_id":"themes/ylion/layout/category.ejs","hash":"ebd05ceb75be73e84ddf085ccfdb24c07162d0fa","modified":1569415848000},{"_id":"themes/ylion/layout/tag.ejs","hash":"9b42656e75c58e7145e52408b51f017f6b6d9464","modified":1569415848000},{"_id":"themes/ylion/layout/layout.ejs","hash":"a6410ed79ed77d83e3bbe064188a50b45a9af739","modified":1569415848000},{"_id":"themes/ylion/layout/index.ejs","hash":"f5dfbcfcdaab7a6c2b77d0d371335c569801352f","modified":1569415848000},{"_id":"themes/ylion/layout/post.ejs","hash":"3475e67bab1ef4c1a782d64cb8bdf7c719c877cb","modified":1582768276416},{"_id":"themes/ylion/layout/page.ejs","hash":"febe98fb69248e8d1638dc83a25a17ee16ebeeca","modified":1569415848000},{"_id":"themes/ylion/source/favicon.ico","hash":"38591b263c047efbb16cd04a51a2d43316e3ebac","modified":1569415848000},{"_id":"source/_posts/CPP-2.md","hash":"9086164038dc52f7a04d243337d45da94772f30f","modified":1607135180244},{"_id":"source/_posts/CPP-CMAKE.md","hash":"53facf22b94f583a6191f806f0c7e85c5e9248c1","modified":1607135180244},{"_id":"source/_posts/CPP-CPP11特性.md","hash":"d4fae6872d42cf3d417a047b553ea348bef74edd","modified":1607135180247},{"_id":"source/_posts/CPP-字节对齐.md","hash":"d118e9def8aefcf11748a0c788c229c3d5292906","modified":1607135180243},{"_id":"source/_posts/CPP-指针.md","hash":"f790d3411b80c18ab49488f8bc0fd2673713be1f","modified":1607135180244},{"_id":"source/_posts/CPP-定义与声明详解.md","hash":"eb15c55a0af9e5bc14ef0a39f7129daee03ace4a","modified":1607135180244},{"_id":"source/_posts/CPP-源码学习-Jsoncpp代码阅读.md","hash":"5c5ca91a6cc90c9c29f545757c5f63d9c36bf20b","modified":1583308364944},{"_id":"source/_posts/CPP-源码学习-Libevent代码初期了解.md","hash":"b9ac4f60cc33600deb8fe5147d894b4728681f49","modified":1583584091301},{"_id":"source/_posts/CPP-牛客.md","hash":"120b55284ddead09d4bd5bc8ba70154ab841de4e","modified":1607135180244},{"_id":"source/_posts/CPP-编程规范.md","hash":"b8928ec001cfe681a729ffeb8ee63ff06ecc81bf","modified":1607135180244},{"_id":"source/_posts/Git-分支管理和实际应用.md","hash":"b22fcda098739caeeda8abc79cec7c58fac1d585","modified":1607135321659},{"_id":"source/_posts/Git-commit规范.md","hash":"43010ae9e5e53b204e06bba95ee69720cf4f3817","modified":1607135321659},{"_id":"source/_posts/Git-基础操作.md","hash":"2e6afadbfc22ea3e073d12fae966a7d48edf5370","modified":1607135320751},{"_id":"source/_posts/Linux-GDB调试.md","hash":"4ccac39af4255d0157a1798430387858c7b81610","modified":1596987161582},{"_id":"source/_posts/Linux-VIM折腾spf13.md","hash":"88770acaeb09be45992849f6174c89c76f12a5fd","modified":1603760641740},{"_id":"source/_posts/Linux-Linux使用.md","hash":"8321f0eade2f53752c9ff140506ac411c57cc53a","modified":1596987045477},{"_id":"source/_posts/Linux-shell脚本编写.md","hash":"990a30ebd5a2e05dab19cfb44e99935908d1653b","modified":1596946249954},{"_id":"source/_posts/Linux-权限相关.md","hash":"90599a34ab570e363ad172beb82c8b8e7f5848ae","modified":1593665252290},{"_id":"source/_posts/假期学习记录-大一暑假.md","hash":"d66df1466c27f7f16a81d8f90363e69eb8f50f34","modified":1607135941887},{"_id":"source/_posts/Linux-网络配置.md","hash":"0d1b717725d5107d0b8820c874ba10a295f5fd60","modified":1595065825588},{"_id":"source/_posts/UE4&3DMAX-3dmax快捷键及基础知识.md","hash":"dd3ea34f610d097c3403346dc8c6ed923efd00e1","modified":1607135856401},{"_id":"source/_posts/假期学习记录-大二寒假.md","hash":"36afb9f4b4eb4bec19dd8fd9db2491eeffd8bff9","modified":1607135941888},{"_id":"source/_posts/UE4&3DMAX-蓝图C++交互.md","hash":"faf82838931f2b1d445549d6d100e84442a0d205","modified":1607135856845},{"_id":"source/_posts/假期学习记录-小方说知识星球.md","hash":"993cc5d728f97d14ee0c28b4c9c4af02138e4389","modified":1607135937534},{"_id":"source/_posts/假期学习记录-大二暑假.md","hash":"875abab0cf73c96e12f7341c033fa84a37b01c2e","modified":1607135941888},{"_id":"source/_posts/分享学习会-HTTP框架底层原理.md","hash":"2d150185acb693e51a1162af8441b10dc50fc794","modified":1604733134243},{"_id":"source/_posts/分享学习会-远程连接宿舍电脑.md","hash":"83b016fb539f7e524eb8b51d4b6042e5837b91b9","modified":1603876619234},{"_id":"source/_posts/分享学习会-cpp入门.md","hash":"da3fdbefbd3e9691d0d0415063cd24c1962dfeb5","modified":1603875357093},{"_id":"source/_posts/分享学习会-抓取接口.md","hash":"6e4a4d3cee2e72639f40e75838cd690c67ee57d8","modified":1603875357093},{"_id":"source/_posts/力扣11.24-N3.无重复字符的最长子串.md","hash":"c20eb4a109024a52ae893ea638610db2a8718edc","modified":1606970342436},{"_id":"source/_posts/力扣11.25-N34.在排序数组中查找元素的第一个和最后一个位置.md","hash":"08840e2a08338bb3199ad7dc32ba646834cb49ec","modified":1606970361362},{"_id":"source/_posts/游戏知识-腾讯游戏学院-如何进入游戏开发行业.md","hash":"d21558281664cd236bd76b2ad66b3e1f6509d9f3","modified":1583417096802},{"_id":"source/_posts/力扣12.3-N1143.最长公共子序列.md","hash":"867948e7e4f07cdad058b7de87b01ce546022885","modified":1607041740272},{"_id":"source/_posts/力扣11.26-H23.合并K个升序链表.md","hash":"487372b7dd6a399ccfb27c0bbbe0c5cf0f85219a","modified":1606970361362},{"_id":"source/_posts/游戏知识-腾讯游戏学院-球球.md","hash":"fa4c5d016a5fbfc1d30a09df93f36a44b5153509","modified":1591151692427},{"_id":"source/_posts/力扣12.1-N5.最长回文子串.md","hash":"0aaefbfa14db50983cd752db277b1559be884cd9","modified":1606970321830},{"_id":"source/_posts/游戏知识-服务器-服务器通信.md","hash":"5ca2b3ae622f33b618bb4a3271836f3d9ea4f3cc","modified":1583417099979},{"_id":"source/_posts/算法90-数据结构简单应用.md","hash":"ddccfc2373bf7e87a84b96d692dcdb7563bd934f","modified":1596986891182},{"_id":"source/_posts/算法91-算法题目记录.md","hash":"254f344e8e0108cb4a3b39c90782c71e6370a92b","modified":1594975985365},{"_id":"source/_posts/网络编程-Socket理论-EPOLL本质.md","hash":"e17dea2ada37665ba561e80c2f78ee55a7bb4c45","modified":1607135223519},{"_id":"source/_posts/网络编程-Socket理论-Send返回值探析.md","hash":"ed851746df2229e4e08896e1a8735c813d82de0c","modified":1607135223519},{"_id":"source/_posts/算法92-算法四.md","hash":"94ae067e99714f2de635158d3a024579da8d4a1e","modified":1604500235474},{"_id":"source/_posts/网络编程-Socket理论-面试题点带面.md","hash":"b32e45b999c77b5fb3cf6a41078bdd71a69fb997","modified":1607135178238},{"_id":"source/_posts/网络编程-TCP状态机.md","hash":"adfd83da9d8e349f181307e090f154136d3ae269","modified":1607135223519},{"_id":"source/_posts/计算机网络-计算机网络笔记整理.md","hash":"7465f8b660ae448ce9ab2b68f81441e16190b996","modified":1594713685981},{"_id":"source/_posts/读书记录100-高性能服务器编程读书记录初级部分.md","hash":"ca61e8a75db034f90056d88499d012125138301f","modified":1607135495592},{"_id":"source/_posts/读书记录101-高性能服务器编程读书记录高级部分.md","hash":"0d55f5ef70b2ce624bbe9c0b72eb483395b13887","modified":1607135495595},{"_id":"source/_posts/读书记录102-高性能服务器编程读书记录进程线程部分.md","hash":"aa49dbf6004e48425f9ea19b0402f6f83defa957","modified":1607135495589},{"_id":"source/_posts/读书记录110-Effective读书记录.md","hash":"9db77e9c321397fa5e2e30551a8334879bae4e5c","modified":1607135495591},{"_id":"source/_posts/读书记录130-代码大全.md","hash":"b4d87d604a1072bcf4ac9d32c531fc0113e48ff4","modified":1607135439407},{"_id":"source/_posts/读书记录115-UNP卷二.md","hash":"61955bcdaa5ed866de9caccdefecc4bb182f8718","modified":1607135495586},{"_id":"source/_posts/读书记录120-Linux多线程服务器.md","hash":"7b18e3d1a115d155e21f4f138415348ec301b5ef","modified":1607135495586},{"_id":"source/_posts/读书记录130-深度探索C++对象模型.md","hash":"f5af93e3669227c4d679da6d34420650c2cec0a6","modified":1607135495586},{"_id":"source/_posts/读书记录140-csapp.md","hash":"b78470fb4706efc1ce4b676161c38e469bef1470","modified":1607135495586},{"_id":"source/_posts/读书记录150-UNP.md","hash":"999583c8cb2ff3ed2e67f53aa4c6365f42dd9cd8","modified":1607135495586},{"_id":"source/_posts/读书记录80-CPPPrimer.md","hash":"067a206bf01113ea5a669956f440a9ea1cabcf17","modified":1607141768530},{"_id":"source/_posts/读书记录99-高性能服务器编程读书记录理论部分.md","hash":"bea96611c23a6435cff20cdf7bae51944a868ae3","modified":1607135495592},{"_id":"source/_posts/采坑记-EPOLLET丢失新连接事件.md","hash":"16a25ff7ffb892f8fa8672a1931063b4ed449ee5","modified":1596470156702},{"_id":"source/_posts/采坑记-头文件互相引用.md","hash":"a5a220efbb36b046b85360cc3e3c08ce0897cd66","modified":1596466983835},{"_id":"source/_posts/采坑记-delete this.md","hash":"132ee15e1310680d37f52e6e9fc909b58f9d096e","modified":1606389837152},{"_id":"source/_posts/采坑记-循环判断之无符号类型.md","hash":"83871a04526db4081188fa4f2f7d36e29ff2f323","modified":1596466980342},{"_id":"source/_posts/项目制作-P2P直播平台.md","hash":"45dfd33bc56dae3dc4c73b379ad1eb0524078e77","modified":1606907485538},{"_id":"source/_posts/项目制作-陀螺球.md","hash":"0447ca1de6311a9645dae6f266f7b9fd93802ff6","modified":1604908929778},{"_id":"themes/ylion/layout/_partial/archive.ejs","hash":"a36b8d1a3ee2442444cba08e6afebde783e3f581","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/after-footer.ejs","hash":"1a11f6c5d8afd45baf6829638ec1b2fbf30be974","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/comments.ejs","hash":"cd927a126c35cfd47abf3a568bcdc2a30b3e6fad","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/gallery.ejs","hash":"3afb29dba43eedcbe55d98131a95de23affe846f","modified":1569415848000},{"_id":"source/favicons/android-chrome-512x512.png","hash":"e02dcf98fa3f146bfdd7bc74046b913627f8abee","modified":1580092054000},{"_id":"themes/ylion/layout/_partial/header.ejs","hash":"fb7534e90746553d4b13f0c81512cdff47104bf7","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/pagination.ejs","hash":"eb0f07bfb4a19a9027ea861904541ecfcb96936a","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/sidebar.ejs","hash":"5989030b7f02af282211a306759ddbdac47536c7","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/article-meta.ejs","hash":"dd844ba05438c5a6b93323f0ccdd0157057c044e","modified":1569415848000},{"_id":"themes/ylion/layout/_widget/archive.ejs","hash":"3d89804f2b5d4a7718125c8fe4b9fde289efd34c","modified":1569415848000},{"_id":"themes/ylion/layout/_widget/category.ejs","hash":"dcd285e44e45d2b4d845c39815db2e1840953f96","modified":1569415848000},{"_id":"themes/ylion/layout/_widget/friends.ejs","hash":"b62e2965c6940ce994cb5db5fd5f32fc9a3401d8","modified":1569415848000},{"_id":"themes/ylion/layout/_widget/notification.ejs","hash":"c32a1a7aebb0714f1415bed286a9a39b79a2c985","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/footer.ejs","hash":"134a566a57942fcbfb06663305de6078702f5b94","modified":1569415848000},{"_id":"themes/ylion/layout/_widget/tagcloud.ejs","hash":"e739c974437ace225251c9a23a5d6ef7adf3f5c5","modified":1569415848000},{"_id":"themes/ylion/layout/_widget/popular.ejs","hash":"3b671d247b2b3ec3560c904263a6b93b4da61d63","modified":1569415848000},{"_id":"themes/ylion/layout/_thirdParty/baidu_an.ejs","hash":"c8ff48ffdc16a94b7d24037a953f7442789a3f86","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/head.ejs","hash":"8af3ec434d29c8e7354cb2e144041e7cbfc85f53","modified":1569415848000},{"_id":"themes/ylion/layout/_thirdParty/google_analytics.ejs","hash":"0d100d7ad555bea422f5c02126bf6fb14fa82a8b","modified":1569415848000},{"_id":"themes/ylion/layout/_thirdParty/google_sitemap.ejs","hash":"4d57bbf3e53a334760e1540eb4b7a2b65268962d","modified":1569415848000},{"_id":"themes/ylion/layout/_thirdParty/mathjax.ejs","hash":"d29b18efe49cae48846f74f53e0a6d1e1e3e98a7","modified":1569415848000},{"_id":"themes/ylion/scripts/filter/emptycode.filter.js","hash":"7c0440d1a4b0f798e060504519cc6a39b5f29e9b","modified":1569415848000},{"_id":"themes/ylion/layout/_thirdParty/baidu_sitemap.ejs","hash":"5fbadc6b28c1f850269381b7dc843dbf10499b51","modified":1569415848000},{"_id":"themes/ylion/scripts/filter/translation.filter.js","hash":"5ec9cde7e4dbd659fe1adb4211c07a375b7049b5","modified":1569415848000},{"_id":"themes/ylion/scripts/helper/getCurPosts.js","hash":"e9d58b03448d74a60978e97c463652af28d9931c","modified":1569415848000},{"_id":"themes/ylion/scripts/generator/index.js","hash":"7df7ea4a2265301644879c9ded9a6e78bb006448","modified":1569415848000},{"_id":"themes/ylion/layout/_thirdParty/disqus.ejs","hash":"67d8349201a7b508c378a7124b295245a0095768","modified":1569415848000},{"_id":"themes/ylion/layout/_thirdParty/duoshuo.ejs","hash":"f2c4f7ec5ea94796f2a7f87b6b04353dfe07300d","modified":1569415848000},{"_id":"themes/ylion/scripts/helper/pickImgs.js","hash":"f26c478a78d94f89611095025d9a2c08065c700f","modified":1569415848000},{"_id":"themes/ylion/scripts/helper/my_paginator.js","hash":"f42b8683428546b914ead3df83cc0a19eaa2712d","modified":1569415848000},{"_id":"themes/ylion/scripts/helper/sortPosts.js","hash":"a6c073157b2fb53cb3ef5825ca3ccd7a38e3d63a","modified":1569415848000},{"_id":"themes/ylion/source/js/highsong.js","hash":"a103f4e3a9b337668fe2c937dd66c4a4963733df","modified":1569415848000},{"_id":"themes/ylion/source/js/app.js","hash":"c257da122c1bff2c989c87a247e962ab6913d991","modified":1569415848000},{"_id":"themes/ylion/source/js/search.js","hash":"553b02d5ea62a97885d4405a6cbbe8685ba27b73","modified":1569415848000},{"_id":"themes/ylion/translate/korean/README_kr.md","hash":"f6c7ab74db9a288656f57ba2d01837f7dd1256a3","modified":1569415848000},{"_id":"themes/ylion/translate/korean/_config_kr.yml","hash":"f86a88597aec2ce2033351dc0dca0b1508d80425","modified":1569415848000},{"_id":"themes/ylion/source/css/_func.less","hash":"c8804cb0effe6177775ba27ff8781431ec0d6282","modified":1569415848000},{"_id":"themes/ylion/source/css/base.less","hash":"1d501cd1b75980e6058de48a664434bdad45c3cc","modified":1569415848000},{"_id":"themes/ylion/source/css/_variable.less","hash":"a113fb91689ef444bd650c04306ad99628f63dc7","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/_head-sections/IE.ejs","hash":"292033d3eaec35593cb229d58eab7043022bd3a5","modified":1569415848000},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/_head-sections/seo.ejs","hash":"4898581e4aff0c1800213f9a05b612105d7a77ee","modified":1569415848000},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/_head-sections/script.ejs","hash":"4ef9cf901a81f59b8788bebba0fb16d74d37d87f","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/_head-sections/style.ejs","hash":"6596c472dc32b194afc96309a6327ea30aab0834","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/_head-sections/title.ejs","hash":"5cf4842a152b85d02ed83206b300d5b5d8998c51","modified":1569415848000},{"_id":"themes/ylion/scripts/generator/lib/generator.js","hash":"68cd4fc227f71bb035ac069c00fc714f4a42da99","modified":1569415848000},{"_id":"themes/ylion/source/js/thirdParty/busuanzi.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1569415848000},{"_id":"themes/ylion/source/css/thirdParty/font-awesome.min.css","hash":"d2c7e3e8ed62f73240fde919253822bc7ce12b15","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_after-footer.less","hash":"2a851257ea9a4fe3157123d7c1f941f974deaa58","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_animation.less","hash":"9393f207f1840f7a1bcd5cc7a3086ae3c6122d66","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_article-meta.less","hash":"5e5318560835ee9922cb7be75e810e99c62549bf","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_footer.less","hash":"41ba98f0688556d880604bcf4e2f471e5b92b40d","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_header.less","hash":"0b26efafd609e62ddda2fa23348bfd43ca7a467e","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_reset.less","hash":"fa0ea262c80660c5cf2f3c84fe74a09ec4c0ac8f","modified":1569415848000},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_media.less","hash":"34b03d8f51e15f746e00b17579310fd6cdc652f9","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_sidebar.less","hash":"dbd121c923141472c84a1fc607d55f8f083edee0","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_pagination.less","hash":"fccf9b341e51cb426753609ac42a5ba140198c24","modified":1569415848000},{"_id":"themes/ylion/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1569415848000},{"_id":"themes/ylion/source/css/pages/archive.less","hash":"4250b13fcfd16045ccd70b40ea74e296111b1b7b","modified":1569415848000},{"_id":"themes/ylion/source/css/pages/article-exp.less","hash":"f87e35ad474eba21029acbda840dc91c9284275d","modified":1569415848000},{"_id":"themes/ylion/source/css/pages/comments.css","hash":"ee7e553676fa58acf12ffbb34decce30f733f4bc","modified":1569415848000},{"_id":"themes/ylion/source/css/pages/othersPages.less","hash":"e346c1fd2a12608e6f1e8a2d98e4652164b4208e","modified":1569415848000},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1569415848000},{"_id":"themes/ylion/source/css/pages/post.less","hash":"b699f3fa3a701e84a32f05396b399b806e9a42f6","modified":1569415848000},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.min.js","hash":"5cb10e77f44ad075512ee4a3fd518d9a5257a80c","modified":1569415848000},{"_id":"themes/ylion/source/js/thirdParty/highlight.pack.js","hash":"3c707416d178e317afa6fc552fc181d08ccc9c8c","modified":1569415848000},{"_id":"themes/ylion/source/js/thirdParty/leancloud.min.js","hash":"f80bcc588670fbf8fe720b7b7c31789b640e649b","modified":1569415848000},{"_id":"themes/ylion/source/css/thirdParty/highlight/github.css","hash":"e5cdc036897bef17b0a40bd3310fb35a202df2b3","modified":1569415848000},{"_id":"themes/ylion/source/css/thirdParty/highlight/solarized-light.css","hash":"10bd5d6b6f332e32edd377f16d3b8ed04713ae81","modified":1569415848000},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.js","hash":"240ce6fc52400cd8b8302cc242e61504e7d86938","modified":1569415848000},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.js.map","hash":"b921d63b0e593bfc456068b40516dc0ea442dc53","modified":1569415848000},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1569415848000},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.min.js.map","hash":"6cd313c386f1dfb5093fb4f71ed29796e01134f4","modified":1569415848000},{"_id":"public/search.xml","hash":"2eeff1b8be0bcf8d42ec7f14396bfbc80749c383","modified":1607180107170},{"_id":"public/atom.xml","hash":"cc9f6c8943fd187e9d60f44f693ae1de616b613c","modified":1607180107170},{"_id":"public/content.json","hash":"9400f9dfdbdcc407248b5c1027a7e7fd7b54904c","modified":1607180107170},{"_id":"public/sitemap.xml","hash":"be4ed87e12aeb7801ac92df1285309ce91a14fb5","modified":1607180107170},{"_id":"public/archives/2019/07/index.html","hash":"f602bc84a65a9ad7c444713af235f4dd0defc547","modified":1607180107170},{"_id":"public/archives/2019/10/index.html","hash":"36cb1d7faabfed936b196cbc81d76f847d2a7f33","modified":1607180107170},{"_id":"public/archives/2019/11/index.html","hash":"6b83292f012e6b9d178c45b0251f43d7b4c2aa14","modified":1607180107170},{"_id":"public/archives/2019/12/index.html","hash":"112dca5b2ee6d788bfaa85404fec558383ba65f1","modified":1607180107170},{"_id":"public/archives/2020/03/page/2/index.html","hash":"ee4d5c600b1154b4dc72d27bf0e997bec1b8f407","modified":1607180107170},{"_id":"public/archives/2020/04/index.html","hash":"1fef3d8f7b294c47812f46dd154d9b1532dbb7b4","modified":1607180107170},{"_id":"public/archives/2020/05/index.html","hash":"278fdf9e00aee358714207f9dee41f58e755b7e7","modified":1607180107170},{"_id":"public/archives/2020/08/index.html","hash":"1956919600c765b852b63b4f079c0805d7eb9d9c","modified":1607180107170},{"_id":"public/archives/2020/09/index.html","hash":"37a9d5c369681dd76f176b1710e2486eac3b6def","modified":1607180107170},{"_id":"public/archives/2020/10/index.html","hash":"34e80f238844bb48a80aa47b273129047d9db0b4","modified":1607180107170},{"_id":"public/categories/CPP/源码学习/index.html","hash":"813666a212d343cde1b7d8fdeedeec8ea28b2e25","modified":1607180107170},{"_id":"public/categories/Git操作/index.html","hash":"1907f9753c5e9b89fb5abb9aa1e517d43cc5dc97","modified":1607180107170},{"_id":"public/categories/UE4-3DMAX/index.html","hash":"19260714992b02055fff463ae57c851cb5f79f44","modified":1607180107170},{"_id":"public/categories/算法/index.html","hash":"76675db9ad21affb6b13f2e7ca307ce38e9fd133","modified":1607180107170},{"_id":"public/categories/计算机网络/index.html","hash":"f3d91a9acf78b67e5ea592112b15419117fb50d0","modified":1607180107170},{"_id":"public/categories/游戏知识/腾讯游戏学院/index.html","hash":"15c3ae7be3bd91863be37f62b462b7f2806ec5e8","modified":1607180107170},{"_id":"public/categories/项目制作/index.html","hash":"f8667ec462dcdb290c07d9f2a2a51c893e8e98f5","modified":1607180107170},{"_id":"public/categories/游戏知识/服务器/index.html","hash":"e3e47001fedfdad29567398fcbd2f4215122a2f5","modified":1607180107170},{"_id":"public/tags/Git操作/index.html","hash":"8e9a096bd5779fd1a2c16b8e45e95123df549fad","modified":1607180107170},{"_id":"public/tags/spf-13/index.html","hash":"e3bffcd85835b44a491704a8789a189016cb44e2","modified":1607180107170},{"_id":"public/tags/Linux/index.html","hash":"4c66042e62a1b7bdfa61007b922e41429a32c776","modified":1607180107170},{"_id":"public/tags/GDB调试/index.html","hash":"c5fc46400dd9915da4175bd95c8a958fc9220326","modified":1607180107170},{"_id":"public/tags/Shell/index.html","hash":"f24583f12c335d1f38a39c8c011b6501ab7e83f6","modified":1607180107170},{"_id":"public/tags/权限管理/index.html","hash":"0d7e5aa7322961baabd4a44cb109951f447c7fa9","modified":1607180107170},{"_id":"public/tags/肉疼/index.html","hash":"7cc82551d8d125b8d0ffcfd418704f608de73b93","modified":1607180107170},{"_id":"public/tags/网络配置/index.html","hash":"0cdfc364df083acb1a87edfeb2d3cea566ad0817","modified":1607180107170},{"_id":"public/tags/小方说/index.html","hash":"4563b216f5747dbd5309ce3e8b218927a974dd19","modified":1607180107170},{"_id":"public/tags/动态规划/index.html","hash":"038e54982601cc9c5392879a46a840dd94a62b22","modified":1607180107170},{"_id":"public/tags/腾讯游戏学院/index.html","hash":"5a4bcedb89faec2c47353dce46695a3159c36aba","modified":1607180107170},{"_id":"public/tags/中心扩散/index.html","hash":"a960718b3b54476614ea9204d31501ad62f57838","modified":1607180107170},{"_id":"public/tags/自底向上/index.html","hash":"63f5e423a1c9fda4787dc4a43d78e5673f234df2","modified":1607180107170},{"_id":"public/tags/陀螺球/index.html","hash":"b0db37f6527203a6466cebae1e77d0978f27e51c","modified":1607180107170},{"_id":"public/2020/12/力扣12.3-N1143.最长公共子序列/index.html","hash":"665b299ef7232f563bcea21749749f714d7b1b0e","modified":1607180107170},{"_id":"public/2020/12/项目制作-P2P直播平台/index.html","hash":"863b051e14efdfbf24e8e9d45378791bdc985a85","modified":1607180107170},{"_id":"public/2020/12/力扣12.1-N5.最长回文子串/index.html","hash":"3092ae15cc4ae52b949db4baa1625fe784685848","modified":1607180107170},{"_id":"public/2020/11/采坑记-delete this/index.html","hash":"4047b67197b4f8869ab62a84aef05265f567926a","modified":1607180107170},{"_id":"public/2020/11/力扣11.26-H23.合并K个升序链表/index.html","hash":"c343a24d7167dfad1e6e8923f566e3e0be67d4c0","modified":1607180107170},{"_id":"public/2020/11/力扣11.25-N34.在排序数组中查找元素的第一个和最后一个位置/index.html","hash":"fea7cf741b17f2dea5b3f564a7cbf2d2e349ba5a","modified":1607180107170},{"_id":"public/2020/11/力扣11.24-N3.无重复字符的最长子串/index.html","hash":"29658a9d3db2758c631230392e925a1bb593aac0","modified":1607180107170},{"_id":"public/2020/11/分享学习会-HTTP框架底层原理/index.html","hash":"f2859c7a1efca5607c4380bfd92b1fd85d5d86b4","modified":1607180107170},{"_id":"public/2020/10/分享学习会-远程连接宿舍电脑/index.html","hash":"f2ff5279fd2a8c6857da339c6ef927dc86129035","modified":1607180107170},{"_id":"public/2020/10/UE4&3DMAX-蓝图C++交互/index.html","hash":"e546cb8beb2eb73514a0a55694edd87bf244f480","modified":1607180107170},{"_id":"public/2020/10/读书记录150-UNP/index.html","hash":"f42d7994f020321a1e07d041d7928fa00b5fd168","modified":1607180107170},{"_id":"public/2020/09/读书记录130-深度探索C++对象模型/index.html","hash":"9f083e686ee6b624ffb7832192489917d8c42a1b","modified":1607180107170},{"_id":"public/2020/09/分享学习会-抓取接口/index.html","hash":"3e95b4978e3bee786cef6ecc536c62e3692f663d","modified":1607180107170},{"_id":"public/2020/08/分享学习会-cpp入门/index.html","hash":"642f0ddfbc45f91370851c60da749a1131e95f9e","modified":1607180107170},{"_id":"public/2020/08/采坑记-EPOLLET丢失新连接事件/index.html","hash":"20877f2c7e49d6a999223900a36a7415a7735b5e","modified":1607180107170},{"_id":"public/2020/07/Linux-网络配置/index.html","hash":"79f7e5d10d698ab303cca0b064f3e04a766c0b87","modified":1607180107170},{"_id":"public/2020/07/算法92-算法四/index.html","hash":"42cd97075e208559539a790c4b8c8ef7ed6872c1","modified":1607180107170},{"_id":"public/2020/07/Linux-VIM折腾spf13/index.html","hash":"22907695056ccc52a64b097cd379661159670f23","modified":1607180107170},{"_id":"public/2020/07/假期学习记录-大二暑假/index.html","hash":"2be470f838069ac55364d12d2d76afc65454d520","modified":1607180107170},{"_id":"public/2020/06/假期学习记录-小方说知识星球/index.html","hash":"d725f6ba61363bdf01507d334742b301117853e2","modified":1607180107170},{"_id":"public/2020/06/计算机网络-计算机网络笔记整理/index.html","hash":"7f5e71ca2a6874fe69498106d681b2dd9294116e","modified":1607180107170},{"_id":"public/2020/06/读书记录140-csapp/index.html","hash":"3964a2749ab011e3c428a06407d8201821c08b92","modified":1607180107170},{"_id":"public/2020/05/读书记录130-代码大全/index.html","hash":"f5c36ab06478464d44dd575bda35d69e83e70fa7","modified":1607180107170},{"_id":"public/2020/06/项目制作-陀螺球/index.html","hash":"55988232efced5132c846a93f70701c3b9beac06","modified":1607180107170},{"_id":"public/2020/05/CPP-编程规范/index.html","hash":"486c1ae9687cf85f54e01cc3ff4268d3519f13dc","modified":1607180107170},{"_id":"public/2020/04/网络编程-Socket理论-面试题点带面/index.html","hash":"43f40631f17ed530d6258d8761b7dac0fd2e91dd","modified":1607180107170},{"_id":"public/2020/03/读书记录120-Linux多线程服务器/index.html","hash":"cf2f1d64bcbab7e835711fa6bc138062961f11a9","modified":1607180107170},{"_id":"public/2020/03/Linux-shell脚本编写/index.html","hash":"2981997e177cb3d90341fda12ca5c47bc921322a","modified":1607180107170},{"_id":"public/2020/03/网络编程-Socket理论-EPOLL本质/index.html","hash":"271b4d850d1a6f779425b9fc3799212f6cd89cd9","modified":1607180107170},{"_id":"public/2020/03/网络编程-TCP状态机/index.html","hash":"76e1f5391a9e14a0adbd4382684bef3808b49f53","modified":1607180107170},{"_id":"public/2020/03/网络编程-Socket理论-Send返回值探析/index.html","hash":"ae26b4a46f0e5efc079a3cd7ea825620827d2e4d","modified":1607180107170},{"_id":"public/2020/03/Linux-Linux使用/index.html","hash":"7e99ac3362ee2bd171a620b3214ea8cdd12670f1","modified":1607180107170},{"_id":"public/2020/03/读书记录115-UNP卷二/index.html","hash":"8b0d5b9cb534c707b7605f55f20c1fce140dedae","modified":1607180107170},{"_id":"public/2020/03/Linux-GDB调试/index.html","hash":"578653768c4f1329e423d12f43bb810d4ce90932","modified":1607180107170},{"_id":"public/2020/03/Linux-权限相关/index.html","hash":"63cac906377cf0a7c5ac9ac04e1512741b34ad9d","modified":1607180107170},{"_id":"public/2020/03/读书记录99-高性能服务器编程读书记录理论部分/index.html","hash":"d894c14ec92f6114d0a181e7dae9f0fe3a3cc8f1","modified":1607180107170},{"_id":"public/2020/03/Git-分支管理和实际应用/index.html","hash":"fa325441a7ae69254eb782e69ea441804df548e2","modified":1607180107170},{"_id":"public/2020/03/采坑记-循环判断之无符号类型/index.html","hash":"d97689d6bad95fe74ff2ac57c3b62debe66d70e3","modified":1607180107170},{"_id":"public/2020/03/游戏知识-腾讯游戏学院-球球/index.html","hash":"f3509f7f44c2a7fd04f2017f5d6041a0f15e33df","modified":1607180107170},{"_id":"public/2020/03/算法91-算法题目记录/index.html","hash":"73e0ca54ab6dc57a87c647c0ed24fcee1dc5384f","modified":1607180107170},{"_id":"public/2020/03/算法90-数据结构简单应用/index.html","hash":"3328d5305d00ea6b270aa927879b3978ee4bb3e4","modified":1607180107170},{"_id":"public/2020/03/CPP-源码学习-Jsoncpp代码阅读/index.html","hash":"0c00358f6532ea33a295627b8b96c461ca7b6379","modified":1607180107170},{"_id":"public/2020/02/CPP-定义与声明详解/index.html","hash":"4ef78eb897fa865be102b98854f6067933b0cccf","modified":1607180107170},{"_id":"public/2020/02/读书记录110-Effective读书记录/index.html","hash":"ab9d968db854b43ad47cb256bf776f9e176fbd0d","modified":1607180107170},{"_id":"public/2020/02/读书记录102-高性能服务器编程读书记录进程线程部分/index.html","hash":"ed2d4afd86567db03eb3fd6e8e367443778d9a10","modified":1607180107170},{"_id":"public/2020/02/Git-commit规范/index.html","hash":"3e95a65a0e9ff1125b699efc2b797e6cf1408b0c","modified":1607180107170},{"_id":"public/2020/02/CPP-CPP11特性/index.html","hash":"de6dbd4a6185e7ed765d8454e2a4c1f4366fd70f","modified":1607180107170},{"_id":"public/2020/02/CPP-源码学习-Libevent代码初期了解/index.html","hash":"8d62187ced6bfd4d67874a1cbead94be547904db","modified":1607180107170},{"_id":"public/2020/02/UE4&3DMAX-3dmax快捷键及基础知识/index.html","hash":"494770ca0528e7142cee05e59336a7b492a17bc3","modified":1607180107170},{"_id":"public/2020/02/Git-基础操作/index.html","hash":"44a110426ba03f7ef746f55a4dd0cd4b66a408f1","modified":1607180107170},{"_id":"public/2020/02/采坑记-头文件互相引用/index.html","hash":"68096037f237b4e041f4c821cd6183a1415ab38c","modified":1607180107170},{"_id":"public/2020/02/CPP-CMAKE/index.html","hash":"f5ac929b20e76496c7a24738a5ed3f54b3152b6d","modified":1607180107170},{"_id":"public/2020/02/CPP-字节对齐/index.html","hash":"c7022a80ebea8088088430f47ce80005b2748f63","modified":1607180107170},{"_id":"public/2020/02/假期学习记录-大二寒假/index.html","hash":"2f4fb77d76e8f6957c55f588a51948cce46ddd67","modified":1607180107170},{"_id":"public/2019/12/游戏知识-腾讯游戏学院-如何进入游戏开发行业/index.html","hash":"f0088eb9de9090f0661d32c5cddfcdcd1beee742","modified":1607180107170},{"_id":"public/2019/12/游戏知识-服务器-服务器通信/index.html","hash":"8b1369f5cc8bd8d52110a9acc5404db3f0881ddf","modified":1607180107170},{"_id":"public/2019/11/CPP-指针/index.html","hash":"aa754304c2be976ca8a8e53e44c439d6cd82ea36","modified":1607180107170},{"_id":"public/2019/10/CPP-2/index.html","hash":"c0e063c2d58f0378bb0dfccf548b9a4594540a65","modified":1607180107170},{"_id":"public/2019/10/CPP-牛客/index.html","hash":"4d78dc7cb3215d1cc582289f14f9a7367a0555fa","modified":1607180107170},{"_id":"public/2019/08/读书记录101-高性能服务器编程读书记录高级部分/index.html","hash":"b6c317390250aae10cd6f7012e15be5b8ba3ed6b","modified":1607180107170},{"_id":"public/2019/08/读书记录100-高性能服务器编程读书记录初级部分/index.html","hash":"16d2ffb1aaf7bacd097d90db1f6e1996df86c639","modified":1607180107170},{"_id":"public/2019/07/假期学习记录-大一暑假/index.html","hash":"8d608748ef666ef930325b784ccf6410c5e4bc40","modified":1607180107170},{"_id":"public/2019/08/读书记录80-CPPPrimer/index.html","hash":"64025d82e85f518eb48a6dc09188fc61078096a5","modified":1607180107170},{"_id":"public/archives/index.html","hash":"c260e7ddd173ce545cd8020f29797d61e489386e","modified":1607180107170},{"_id":"public/archives/page/2/index.html","hash":"71fc358dda84ef208999b92cf802c3806334c011","modified":1607180107170},{"_id":"public/archives/page/3/index.html","hash":"7088a6749551d433b68cf1897036be307f534db8","modified":1607180107170},{"_id":"public/archives/page/5/index.html","hash":"22ee1f51978df741c585758fabf8fad1c2dacbef","modified":1607180107170},{"_id":"public/archives/page/4/index.html","hash":"e8427cbe767973e00e23189a58137435dc1f7249","modified":1607180107170},{"_id":"public/archives/2019/index.html","hash":"e04ba60159ad2be8f3f742ac52179e98d61121a8","modified":1607180107170},{"_id":"public/archives/2019/08/index.html","hash":"f84b8f189d84a234ba3dcaecaa8738cca9d1463d","modified":1607180107170},{"_id":"public/archives/2020/page/2/index.html","hash":"12fde16b1111aa85a0bc75aa3a0df8f542d92511","modified":1607180107170},{"_id":"public/archives/2020/index.html","hash":"248e641c686bd669e80111d8ad82ebc110215ddc","modified":1607180107170},{"_id":"public/archives/2020/page/3/index.html","hash":"0890b6c004663257532899bb237f793781a2de1c","modified":1607180107170},{"_id":"public/archives/2020/page/4/index.html","hash":"2f97400f27bfdc1eef996837414f8f3f8411214a","modified":1607180107170},{"_id":"public/archives/2020/02/index.html","hash":"e3ec8522fb6387d6fb6712d63d3d1fff681a0306","modified":1607180107170},{"_id":"public/archives/2020/03/index.html","hash":"8912131f4f61cac3396b42201c194d06a5d0ce48","modified":1607180107170},{"_id":"public/archives/2020/06/index.html","hash":"692b4d96f52cc3607818562cb4aa6951b1522f3f","modified":1607180107170},{"_id":"public/archives/2020/07/index.html","hash":"42ad529c11f7f7ab969be294ca8c966451d24e00","modified":1607180107170},{"_id":"public/archives/2020/11/index.html","hash":"e696ed7bb71b415c6a05443afc0297b312c9a718","modified":1607180107170},{"_id":"public/archives/2020/12/index.html","hash":"3f47e604d4dd1cfae6fc409e60c8074c12a30691","modified":1607180107170},{"_id":"public/categories/CPP/index.html","hash":"3cfd4dc618d470ec1f59224674b9f0ddbfd724f2","modified":1607180107170},{"_id":"public/categories/Linux/index.html","hash":"d10c164bbe89888da7f08644d971b4dc36381d1c","modified":1607180107170},{"_id":"public/categories/假期学习记录/index.html","hash":"3994fd552eac11382218ad380bdb7a52a154537c","modified":1607180107170},{"_id":"public/categories/力扣每日一题/index.html","hash":"08bb9af0ed0abd3325a565b662137ae03b002446","modified":1607180107170},{"_id":"public/categories/分享会/index.html","hash":"f1bf472f8f90cf484b9a8f127277cdef63ce8e02","modified":1607180107170},{"_id":"public/categories/游戏知识/index.html","hash":"9201bfd3c7b2f16805f715a658809fda6ede46a8","modified":1607180107170},{"_id":"public/categories/网络编程/index.html","hash":"00efdf03606f639bd99aea3e4fe1148d91fb2878","modified":1607180107170},{"_id":"public/categories/读书记录/index.html","hash":"11c23300a4a11fdfcfd5a5422126b835ca30cc14","modified":1607180107170},{"_id":"public/categories/采坑记/index.html","hash":"ebb25ddb92862ebd0598eb44a4c23549940d3b5c","modified":1607180107170},{"_id":"public/categories/网络编程/Socket理论/index.html","hash":"a4a863cd7cc6c2af8ca5ca0f53ac29e764306af1","modified":1607180107170},{"_id":"public/tags/递归分治/index.html","hash":"68ab84e013dac9f81800137b46468d9d7acc7cd3","modified":1607180107170},{"_id":"public/tags/采坑记/index.html","hash":"6ef59d9e0a96bb24073039e7f7a8684a20e7a630","modified":1607180107170},{"_id":"public/page/2/index.html","hash":"75f5ffd70cc84654435ae8bafe70a4bcfa4c0b9d","modified":1607180107170},{"_id":"public/page/3/index.html","hash":"03f714219d72cf7b687dfd8137255f2a19270575","modified":1607180107170},{"_id":"public/page/4/index.html","hash":"43ecc22edb8feb0f816d863033f923418b80ab6b","modified":1607180107170},{"_id":"public/page/5/index.html","hash":"bc02bb19650f90d6842fc194924885d3d81567a9","modified":1607180107170},{"_id":"public/index.html","hash":"3c79b16ebaf41840796225b014771ce0eabfea20","modified":1607180107170},{"_id":"public/favicons/android-chrome-192x192.png","hash":"05d291f0be2766b4f46a62fbabdc10b3d6ff092a","modified":1607180107170},{"_id":"public/favicons/browserconfig.xml","hash":"974aea18bda5a95802c06b80126ab1d96d91d708","modified":1607180107170},{"_id":"public/CNAME","hash":"5d1b3c534b5001bee37dc2a8e8da866b00c2eb73","modified":1607180107170},{"_id":"public/favicons/site.webmanifest","hash":"13e5aa58eb2182d8ace63266856c8cc29c47c083","modified":1607180107170},{"_id":"public/favicons/apple-touch-icon.png","hash":"f208d1156aee20488a1f98d902f5a674a7cc6d84","modified":1607180107170},{"_id":"public/favicons/favicon-16x16.png","hash":"c92eeb1df6654eb34f9cf354e3922a794021e377","modified":1607180107170},{"_id":"public/favicons/favicon-32x32.png","hash":"8c3bb4b352237b05f8119644d91099c5288ca2b6","modified":1607180107170},{"_id":"public/favicons/favicon.ico","hash":"7819f8009e037fa738545f5645efc32457ebb9e0","modified":1607180107170},{"_id":"public/favicons/mstile-150x150.png","hash":"266c87b17aa65bed8a431b5d88281ce488b03c6f","modified":1607180107170},{"_id":"public/favicon.ico","hash":"38591b263c047efbb16cd04a51a2d43316e3ebac","modified":1607180107170},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1607180107170},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1607180107170},{"_id":"public/js/search.js","hash":"600a37dbbc5377e5e7ded6ce993badc30211afee","modified":1607180107170},{"_id":"public/js/highsong.js","hash":"8138f104a8607b93bce3d7c3641e069952f3849b","modified":1607180107170},{"_id":"public/js/thirdParty/busuanzi.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1607180107170},{"_id":"public/css/thirdParty/highlight/github.css","hash":"e5cdc036897bef17b0a40bd3310fb35a202df2b3","modified":1607180107170},{"_id":"public/css/thirdParty/highlight/solarized-light.css","hash":"10bd5d6b6f332e32edd377f16d3b8ed04713ae81","modified":1607180107170},{"_id":"public/js/app.js","hash":"647c1cf899574d9d3c979ade87ba18e1559a8d78","modified":1607180107170},{"_id":"public/css/thirdParty/font-awesome.min.css","hash":"d2c7e3e8ed62f73240fde919253822bc7ce12b15","modified":1607180107170},{"_id":"public/css/pages/comments.css","hash":"ee7e553676fa58acf12ffbb34decce30f733f4bc","modified":1607180107170},{"_id":"public/js/thirdParty/highlight.pack.js","hash":"3c707416d178e317afa6fc552fc181d08ccc9c8c","modified":1607180107170},{"_id":"public/js/thirdParty/gitment.browser.min.js","hash":"5cb10e77f44ad075512ee4a3fd518d9a5257a80c","modified":1607180107170},{"_id":"public/js/thirdParty/leancloud.min.js","hash":"2c4846325ac8f0b036a3b37d2176ed81b3a51d60","modified":1607180107170},{"_id":"public/js/thirdParty/gitment.browser.js","hash":"0711b1ae17b2dd8767ec60dabe5d71b75037cedc","modified":1607180107170},{"_id":"public/favicons/android-chrome-512x512.png","hash":"e02dcf98fa3f146bfdd7bc74046b913627f8abee","modified":1607180107170},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1607180107170},{"_id":"public/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1607180107170},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1607180107170},{"_id":"public/js/thirdParty/gitment.browser.js.map","hash":"b921d63b0e593bfc456068b40516dc0ea442dc53","modified":1607180107170},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1607180107170},{"_id":"public/css/pages/archive.css","hash":"0d7bd6c5971b30d19ae01c8fb99f2b7db090ad22","modified":1607180107170},{"_id":"public/css/pages/article-exp.css","hash":"ff3ff2ca0629ae9c93f9c4dc44571d72342853c1","modified":1607180107170},{"_id":"public/css/pages/othersPages.css","hash":"d374c64bd2cb94613fd25a4902de5382a9ffba8b","modified":1607180107170},{"_id":"public/css/pages/post.css","hash":"8c24a714cb49c1b68ffc9821360d71bc3c97fbd6","modified":1607180107170},{"_id":"public/js/thirdParty/gitment.browser.min.js.map","hash":"6cd313c386f1dfb5093fb4f71ed29796e01134f4","modified":1607180107170},{"_id":"public/css/base.css","hash":"00fdb8e72e44066bfc0b10e85c978025f45c912c","modified":1607180107170}],"Category":[{"name":"CPP","_id":"ckibtjg5r0002f8un0x9660y4"},{"name":"源码学习","parent":"ckibtjg5r0002f8un0x9660y4","_id":"ckibtjg5z000ff8unalx0ew8r"},{"name":"Git操作","_id":"ckibtjg68000qf8un8u54dryz"},{"name":"Linux","_id":"ckibtjg6f0019f8un64ud8skc"},{"name":"假期学习记录","_id":"ckibtjg6o0023f8un172k26up"},{"name":"UE4&3DMAX","_id":"ckibtjg6s002bf8un6pv2894o"},{"name":"分享会","_id":"ckibtjg700034f8un83798r1l"},{"name":"力扣每日一题","_id":"ckibtjg77003rf8un9dusd2c2"},{"name":"游戏知识","_id":"ckibtjg7e004af8ungx6ncyc2"},{"name":"算法","_id":"ckibtjg7j004tf8uneuoec5lp"},{"name":"网络编程","_id":"ckibtjg7k004xf8un9to7b0n6"},{"name":"计算机网络","_id":"ckibtjg7m0055f8un4eul8kg5"},{"name":"读书记录","_id":"ckibtjg7n0056f8unha9y44tm"},{"name":"采坑记","_id":"ckibtjg7t005tf8unere8f0mi"},{"name":"腾讯游戏学院","parent":"ckibtjg7e004af8ungx6ncyc2","_id":"ckibtjg7u005zf8un2ydv3qur"},{"name":"项目制作","_id":"ckibtjg7v0063f8undbwme95x"},{"name":"服务器","parent":"ckibtjg7e004af8ungx6ncyc2","_id":"ckibtjg7w0067f8unemh0bjed"},{"name":"Socket理论","parent":"ckibtjg7k004xf8un9to7b0n6","_id":"ckibtjg7x006df8un7xx6dr6o"}],"Data":[],"Page":[],"Post":[{"title":"CMAKE","date":"2020-02-06T09:07:45.000Z","_content":"CMAKE并不打算专门去学, 所以就用到哪里学到哪里\n\n今天clion写项目 遇到一个问题 明明写了aux_source_directory 却依然提示没有加入. 后来查了下, 并不推荐使用那个命令.\n可能会存在一些问题\nhttps://cmake.org/cmake/help/latest/command/aux_source_directory.html\n\n\n```cmake\n# 必须片段\n# CMake 最低版本号要求\ncmake_minimum_required (VERSION 2.8)\n# 项目信息\nproject (Demo1)\n# 指定生成目标\nadd_executable(Demo main.cc)\n\n# 多文件\n# 如果一味地在add_executable中添加源文件, 会导致太长了\n# 将dir目录中所有源文件保存在变量中\naux_source_directory(. DIR_SOURCE)\n# 将变量赋值给Demo\nadd_executable(Demo ${DIR_SOURCE})\n\n# 多文件多目录\n# 需要在主目录和子文件夹中都编写CMakeLists.txt文件\n\n# 主文件添加子目录\nadd_subdirectory(dir1)\n# 添加链接库\ntarget_link_libraries(Demo Foo)\n\n# dir1目录中\naux_source_directory(. DIR1_SOURCE)\n# 生成链接库 Foo 在主文件中添加即可\nadd_library(Foo ${DIR1_SOURCE})\n```\n\n# CMAKE和MAKE之间的区别\n[博客原文](https://my.oschina.net/xunxun/blog/86781)\n\n自己的理解\n通过为cmake编写CMakeList文件, cmake即可按照规则生成相应的Makefile文件\n然后make读取Makefile文件就可以按照规则将源代码编译\n\n总的来说cmake就是为make生成Makefile文件, (Makefile文件可以自己编写, 也可以用Cmake生成)\n应该是编写CMakeList的代码量少于或者简单于Makefile, 简化了操作","source":"_posts/CPP-CMAKE.md","raw":"---\ntitle: CMAKE\ndate: 2020-02-06 17:07:45\ntags:\ncategories:\n  - CPP\n---\nCMAKE并不打算专门去学, 所以就用到哪里学到哪里\n\n今天clion写项目 遇到一个问题 明明写了aux_source_directory 却依然提示没有加入. 后来查了下, 并不推荐使用那个命令.\n可能会存在一些问题\nhttps://cmake.org/cmake/help/latest/command/aux_source_directory.html\n\n\n```cmake\n# 必须片段\n# CMake 最低版本号要求\ncmake_minimum_required (VERSION 2.8)\n# 项目信息\nproject (Demo1)\n# 指定生成目标\nadd_executable(Demo main.cc)\n\n# 多文件\n# 如果一味地在add_executable中添加源文件, 会导致太长了\n# 将dir目录中所有源文件保存在变量中\naux_source_directory(. DIR_SOURCE)\n# 将变量赋值给Demo\nadd_executable(Demo ${DIR_SOURCE})\n\n# 多文件多目录\n# 需要在主目录和子文件夹中都编写CMakeLists.txt文件\n\n# 主文件添加子目录\nadd_subdirectory(dir1)\n# 添加链接库\ntarget_link_libraries(Demo Foo)\n\n# dir1目录中\naux_source_directory(. DIR1_SOURCE)\n# 生成链接库 Foo 在主文件中添加即可\nadd_library(Foo ${DIR1_SOURCE})\n```\n\n# CMAKE和MAKE之间的区别\n[博客原文](https://my.oschina.net/xunxun/blog/86781)\n\n自己的理解\n通过为cmake编写CMakeList文件, cmake即可按照规则生成相应的Makefile文件\n然后make读取Makefile文件就可以按照规则将源代码编译\n\n总的来说cmake就是为make生成Makefile文件, (Makefile文件可以自己编写, 也可以用Cmake生成)\n应该是编写CMakeList的代码量少于或者简单于Makefile, 简化了操作","slug":"CPP-CMAKE","published":1,"updated":"2020-12-05T02:26:20.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg5l0000f8un42xa68a5","content":"<p>CMAKE并不打算专门去学, 所以就用到哪里学到哪里</p>\n<p>今天clion写项目 遇到一个问题 明明写了aux_source_directory 却依然提示没有加入. 后来查了下, 并不推荐使用那个命令.<br>可能会存在一些问题<br><a href=\"https://cmake.org/cmake/help/latest/command/aux_source_directory.html\" target=\"_blank\" rel=\"noopener\">https://cmake.org/cmake/help/latest/command/aux_source_directory.html</a></p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 必须片段</span></span><br><span class=\"line\"><span class=\"comment\"># CMake 最低版本号要求</span></span><br><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span> (VERSION <span class=\"number\">2.8</span>)</span><br><span class=\"line\"><span class=\"comment\"># 项目信息</span></span><br><span class=\"line\"><span class=\"keyword\">project</span> (Demo1)</span><br><span class=\"line\"><span class=\"comment\"># 指定生成目标</span></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(Demo main.cc)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多文件</span></span><br><span class=\"line\"><span class=\"comment\"># 如果一味地在add_executable中添加源文件, 会导致太长了</span></span><br><span class=\"line\"><span class=\"comment\"># 将dir目录中所有源文件保存在变量中</span></span><br><span class=\"line\"><span class=\"keyword\">aux_source_directory</span>(. DIR_SOURCE)</span><br><span class=\"line\"><span class=\"comment\"># 将变量赋值给Demo</span></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(Demo <span class=\"variable\">$&#123;DIR_SOURCE&#125;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多文件多目录</span></span><br><span class=\"line\"><span class=\"comment\"># 需要在主目录和子文件夹中都编写CMakeLists.txt文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 主文件添加子目录</span></span><br><span class=\"line\"><span class=\"keyword\">add_subdirectory</span>(dir1)</span><br><span class=\"line\"><span class=\"comment\"># 添加链接库</span></span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(Demo Foo)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># dir1目录中</span></span><br><span class=\"line\"><span class=\"keyword\">aux_source_directory</span>(. DIR1_SOURCE)</span><br><span class=\"line\"><span class=\"comment\"># 生成链接库 Foo 在主文件中添加即可</span></span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(Foo <span class=\"variable\">$&#123;DIR1_SOURCE&#125;</span>)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"CMAKE和MAKE之间的区别\"><a href=\"#CMAKE和MAKE之间的区别\" class=\"headerlink\" title=\"CMAKE和MAKE之间的区别\"></a>CMAKE和MAKE之间的区别</h1><p><a href=\"https://my.oschina.net/xunxun/blog/86781\" target=\"_blank\" rel=\"noopener\">博客原文</a></p>\n<p>自己的理解<br>通过为cmake编写CMakeList文件, cmake即可按照规则生成相应的Makefile文件<br>然后make读取Makefile文件就可以按照规则将源代码编译</p>\n<p>总的来说cmake就是为make生成Makefile文件, (Makefile文件可以自己编写, 也可以用Cmake生成)<br>应该是编写CMakeList的代码量少于或者简单于Makefile, 简化了操作</p>\n","site":{"data":{}},"excerpt":"","more":"<p>CMAKE并不打算专门去学, 所以就用到哪里学到哪里</p>\n<p>今天clion写项目 遇到一个问题 明明写了aux_source_directory 却依然提示没有加入. 后来查了下, 并不推荐使用那个命令.<br>可能会存在一些问题<br><a href=\"https://cmake.org/cmake/help/latest/command/aux_source_directory.html\" target=\"_blank\" rel=\"noopener\">https://cmake.org/cmake/help/latest/command/aux_source_directory.html</a></p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 必须片段</span></span><br><span class=\"line\"><span class=\"comment\"># CMake 最低版本号要求</span></span><br><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span> (VERSION <span class=\"number\">2.8</span>)</span><br><span class=\"line\"><span class=\"comment\"># 项目信息</span></span><br><span class=\"line\"><span class=\"keyword\">project</span> (Demo1)</span><br><span class=\"line\"><span class=\"comment\"># 指定生成目标</span></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(Demo main.cc)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多文件</span></span><br><span class=\"line\"><span class=\"comment\"># 如果一味地在add_executable中添加源文件, 会导致太长了</span></span><br><span class=\"line\"><span class=\"comment\"># 将dir目录中所有源文件保存在变量中</span></span><br><span class=\"line\"><span class=\"keyword\">aux_source_directory</span>(. DIR_SOURCE)</span><br><span class=\"line\"><span class=\"comment\"># 将变量赋值给Demo</span></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(Demo <span class=\"variable\">$&#123;DIR_SOURCE&#125;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多文件多目录</span></span><br><span class=\"line\"><span class=\"comment\"># 需要在主目录和子文件夹中都编写CMakeLists.txt文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 主文件添加子目录</span></span><br><span class=\"line\"><span class=\"keyword\">add_subdirectory</span>(dir1)</span><br><span class=\"line\"><span class=\"comment\"># 添加链接库</span></span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(Demo Foo)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># dir1目录中</span></span><br><span class=\"line\"><span class=\"keyword\">aux_source_directory</span>(. DIR1_SOURCE)</span><br><span class=\"line\"><span class=\"comment\"># 生成链接库 Foo 在主文件中添加即可</span></span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(Foo <span class=\"variable\">$&#123;DIR1_SOURCE&#125;</span>)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"CMAKE和MAKE之间的区别\"><a href=\"#CMAKE和MAKE之间的区别\" class=\"headerlink\" title=\"CMAKE和MAKE之间的区别\"></a>CMAKE和MAKE之间的区别</h1><p><a href=\"https://my.oschina.net/xunxun/blog/86781\" target=\"_blank\" rel=\"noopener\">博客原文</a></p>\n<p>自己的理解<br>通过为cmake编写CMakeList文件, cmake即可按照规则生成相应的Makefile文件<br>然后make读取Makefile文件就可以按照规则将源代码编译</p>\n<p>总的来说cmake就是为make生成Makefile文件, (Makefile文件可以自己编写, 也可以用Cmake生成)<br>应该是编写CMakeList的代码量少于或者简单于Makefile, 简化了操作</p>\n"},{"title":"C++薄书整理","date":"2019-10-20T11:13:22.000Z","_content":"\n# 定义新量\n\nauto 自动根据初始值的类型进行自动类型推导.\ndecltype 根据表达式的类型定义对象\n\n右值引用, 操纵右值对象\n`std::move()`, 可以将一个\n\n**枚举**\n不限定作用域的定义\nenum color {red, green, blue};\n限定在类型内部的作用域\nenum class color {red, green, blue};\n`color a = color::red`\n\n# 函数\n数组传参的长度处理\n- 直接传递数组长度\n- 使用C风格字符串(默认结尾有标志)\n- 使用C++11的新函数begin()和end()同时传递首尾地址\n\n函数指针\n`bool (*pf)(int, int)` 可以指向\n`bool max(int a,int b)`\n调用 `pf(1, 1)`即可\n常用于函数的参数是一个函数的返回值\n\n**Lambda**\n`[]() -> return type {statements}`\n中括号代表lambda引导, 其中的captures子句在同一作用域下lambda主体捕获(访问)哪些对象\n以及如何捕获这些对象\n- 可以为空, 不会访问外围对象\n- [=] 代表用值捕获的方式\n- [&] 代表引用捕获\n\n# 类\n**辅助函数**\n定义辅助函数, 有点像Java里面的重写toString()函数(最常见的代表的例子)\n```c++\nostream &print(ostream &os)\n{\n\tos << 1 << endl;\n\treturn os;\n}\n```\n**友元函数**\n一个类的辅助函数从概念上可以看成类的接口, 虽然和类的关系很密切, 但并不是类的成员, 所以不能直接访问私有成员\nC++ 中可以将该类函数声明为该类的友元.\n这样就能访问到类的非公有成员.\n在函数的前面加上`friend`关键字\n**友元类**\n如果A想访问B的私有成员, 可以在B内声明`friend class A`, 这样就可以在B内访问A的私有成员\n*友元关系是单向的, 不具有交换性, 同时也不具有传递性*\n\n**构造函数**\n默认构造函数没有参数, 或者所有的参数都具有默认值\nC++11允许在显示定义构造函数的情况下使用默认构造函数\n需要在默认构造函数后面加上`= default`\n*使用默认构造函数创建类对象时, 切忌在对象名后I使用圆括号, 成了一个函数声明*\n\n**初始值列表**\nT(int a, int b):a_(a), b_(b){}\n引用和const修饰的必须用初始值列表初始化, 初始的顺序取决于数据成员在类内的定义顺序,\n而非初始值列表的顺序\n\n**简化构造函数**\n实际将自己的带参构造函数, 给定默认值, 这样就实现了默认构造函数和带参构造函数的合并\n\n**复制构造函数**\n参数为该类的引用\n\n**委托构造函数**\n减少构造函数代码量\n实际就是一个构造函数后面加上`:`调用另一个构造函数, 同时传入参数\n```c++\nclass A\n{\n\tint bar1_;\n\tint bar2_;\n\tA(int b1):A(b1, 2){}\n\tA(int b1, int b2):bar1_(b1), bar2_(b2){}\n}\n```\n**运算符重载**\nT operator /(A, B);\n双目运算符两个参数\n单目运算符一个参数\n对于二元运算符, 左侧运算对象传递给第一个参数, 右侧运算对象传递给第二个参数.\n\n运算符重载的声明和定义的分离\n放在类成员中的运算符重载, 需要算入默认的this指针参数\n```c++\n// test.h\n#include <cstdio>\nclass Test\n{\npublic:\n    Test(int a, int b);\n    Test& operator+(const Test& right);\n\tvoid PrintAB();\nprivate:\n\tint a_;\n\tint b_;\n};\n// test.cpp\n#include \"test.h\"\nTest::Test(int a, int b)\n{\n    a_ = a;\n    b_ = b;\n}\nTest& Test::operator+(const Test& right)\n{\n    Test test(this->a_ + right.a_, this->b_ + right.b_);\n    return test;\n}\nvoid Test::PrintAB()\n{\n    printf(\"%d %d\\n\", a_, b_);\n}\n// main.cpp\nint main()\n{\n    Test test1(1, 1);\n    Test test2(2, 2);\n    Test test = test1 + test2;\n    test.PrintAB();\n    return 0;\n}\n\n// ++ -- \nTest& operator++(); // 前置版本\nTest operator++(int); // 后置版本\n```\n**类成员指针**\n*数据成员指针* (private不能通过指针访问)\n其值是数据成员所在地址相对于对象起始地址的偏移值\n```c++\nA T::*p1 = &T::x\nint A::*p1 = &A::value\nA a;\n// 使用方式\na.*p = ......................;\n```\np1指向T类中的 A类型的x数据成员\n`A T::`可以用`auto`\n\n*成员函数指针*\n```c++\nint (A::*pf)();\npf = &A::GetValue;\n// 当然可以使用auto 来简化\nauto pf2 = &A::GetValue;\n// 使用方式\n(a.*pf)();\n\n```\n\n----\n统一初始化\n`X x1 = {0} 和 X x2 {0}` 这两种是不同的实现!!, 大多数情况下这两个是相通的, 然而当\n`explicit构造函数`存在的时候`前者的初始化是错误的`\n\n`int x{0} int x= 0 int x(0)` 最后一个是错误的可能会和函数声明冲突\n```c++\nclass A\n{\n\ttypedef int x;\n\tint z(x);\n}\n```\n\n另外还存在一个\n```c++\nstd::atomic<int> a1{0}; // OK\nstd::atomic<int> a2(0); // OK\nstd::atomic<int> a3 = 0; // Error\n```\n这个错误的原因是copy-initialization引起的\n这个copy-initialization发生在`T x = a`的声明, 下面我把原博客的部分重要英文替换成中文或代码描述\n`std::atomic<int> a3 = 0` 从`int类型`赋值到`可能是 cv-qualified`的`class type`\n[cv-qualified](https://stackoverflow.com/questions/27527642/what-does-cv-qualified-mean)\n```c++\n// ***cv-qualified***\n// non cv_qualified\nint first; \nchar *second; \n\n// cv-qualified \nconst int third; \nvolatile char * fourth; \n```\n`std::atomic<int> a3 = 0` 满足了这个条件属于`copy-initialization`\n[copy-initialization](https://www.quora.com/What-is-the-difference-between-copy-initialization-and-direct-initialization-of-objects-in-c++)\n[直接初始化和复制初始化的区别](https://blog.csdn.net/ljianhui/article/details/9245661)\n直接初始化会直接用参数生成对象, 而复制初始化会`用参数生成临时对象, 然后将这个对象复制到正要创建的对象`\n```c++\nclass A\n{\npublic:\n        A () { } //直接初始化会调用这个构造函数\n        A (const A& a) { } //复制初始化会调用这个\n}\n```\n接下来需要通过`std::atomic<int>(int)`把0转换成成一个纯右值(prvalue)的临时对象\n[纯右值](https://zh.cppreference.com/w/cpp/language/value_category)\n[纯右值](https://www.cnblogs.com/zpcdbky/p/5275959.html)\n然后再将这个临时对象用直接初始化(调用复制构造函数), 然而`std::atomic<int>`把拷贝\n构造函数给禁用了, 就会出错\n`std::atomic<int> a3 {0}`这个会直接调用接收int的构造函数\n\n回到`X x1 = {0}`这里, 这个表达式是一个复制构造, 用一个braced-init-list(指的{0}). \n这里有两个阶段\n首先是会把单个参数的构造函数汇总起来(得到A-list)供选择, 如果其中没有合适的构造函数, 再将候选列表\n转换为所有构造函数\n\n如果如果A-list没有构造函数, 并且class T存在默认构造函数, 第一阶段就会被忽略\n如果在一个使用`{}`的初始化, 并且选择到了`explicit 构造函数头上`就会报错\n\n`explicit`可以防止在调用某个成员函数的时候, 实参类型(通过构造函数之一)自动转换成相应参数,\n但此时这个函数需要其他的成员变量参与到函数运行, 恰巧这时所需要的其他成员变量没有得到合适的初始化, 就会发生错误(没有得到合适初始化的原因就是, 自动调用了不合适的构造函数生成了这个函数所需要的参数(一般是对象))\n\n@2019年10月26日21:25:58@算是第一次解决一个环环相扣的问题, 精力有点不足了\nhttps://zhuanlan.zhihu.com/p/21102748 后续会继续进行理解\n[这里还发现一个](https://blog.csdn.net/spaceyqy/article/details/22730939)\n\n# 模板, 泛型 动态内存, 数据结构\n```c++\ntemplate <typename T>\nconst T& GetMax(const T& a, const T& b)\n{\n    return a > b ? a : b;\n}\nint main()\n{\n    std::cout << GetMax(1, 2);\n\tstd::cout << GetMax<int>(1, 2); // 显示指定模板类型\n    return 0; \n}\n```\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/C%2B%2B%E5%86%85%E5%AD%98.png)\nC++堆的内存需要手动new和delete, 如果一个对象new出来没有在能被释放的时候释放就会造成--**内存泄漏**(需要及时delete不需要的对象)\n一个指向动态内存的指针, 在动态内存被释放后, 指针依然指向原来的地址--**空悬指针**(释放内存后将相应的指针设置为nullptr)\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png)\n","source":"_posts/CPP-2.md","raw":"---\ntitle: C++薄书整理\ntags:\n  - null\ncategories:\n  - CPP\ndate: 2019-10-20 19:13:22\n---\n\n# 定义新量\n\nauto 自动根据初始值的类型进行自动类型推导.\ndecltype 根据表达式的类型定义对象\n\n右值引用, 操纵右值对象\n`std::move()`, 可以将一个\n\n**枚举**\n不限定作用域的定义\nenum color {red, green, blue};\n限定在类型内部的作用域\nenum class color {red, green, blue};\n`color a = color::red`\n\n# 函数\n数组传参的长度处理\n- 直接传递数组长度\n- 使用C风格字符串(默认结尾有标志)\n- 使用C++11的新函数begin()和end()同时传递首尾地址\n\n函数指针\n`bool (*pf)(int, int)` 可以指向\n`bool max(int a,int b)`\n调用 `pf(1, 1)`即可\n常用于函数的参数是一个函数的返回值\n\n**Lambda**\n`[]() -> return type {statements}`\n中括号代表lambda引导, 其中的captures子句在同一作用域下lambda主体捕获(访问)哪些对象\n以及如何捕获这些对象\n- 可以为空, 不会访问外围对象\n- [=] 代表用值捕获的方式\n- [&] 代表引用捕获\n\n# 类\n**辅助函数**\n定义辅助函数, 有点像Java里面的重写toString()函数(最常见的代表的例子)\n```c++\nostream &print(ostream &os)\n{\n\tos << 1 << endl;\n\treturn os;\n}\n```\n**友元函数**\n一个类的辅助函数从概念上可以看成类的接口, 虽然和类的关系很密切, 但并不是类的成员, 所以不能直接访问私有成员\nC++ 中可以将该类函数声明为该类的友元.\n这样就能访问到类的非公有成员.\n在函数的前面加上`friend`关键字\n**友元类**\n如果A想访问B的私有成员, 可以在B内声明`friend class A`, 这样就可以在B内访问A的私有成员\n*友元关系是单向的, 不具有交换性, 同时也不具有传递性*\n\n**构造函数**\n默认构造函数没有参数, 或者所有的参数都具有默认值\nC++11允许在显示定义构造函数的情况下使用默认构造函数\n需要在默认构造函数后面加上`= default`\n*使用默认构造函数创建类对象时, 切忌在对象名后I使用圆括号, 成了一个函数声明*\n\n**初始值列表**\nT(int a, int b):a_(a), b_(b){}\n引用和const修饰的必须用初始值列表初始化, 初始的顺序取决于数据成员在类内的定义顺序,\n而非初始值列表的顺序\n\n**简化构造函数**\n实际将自己的带参构造函数, 给定默认值, 这样就实现了默认构造函数和带参构造函数的合并\n\n**复制构造函数**\n参数为该类的引用\n\n**委托构造函数**\n减少构造函数代码量\n实际就是一个构造函数后面加上`:`调用另一个构造函数, 同时传入参数\n```c++\nclass A\n{\n\tint bar1_;\n\tint bar2_;\n\tA(int b1):A(b1, 2){}\n\tA(int b1, int b2):bar1_(b1), bar2_(b2){}\n}\n```\n**运算符重载**\nT operator /(A, B);\n双目运算符两个参数\n单目运算符一个参数\n对于二元运算符, 左侧运算对象传递给第一个参数, 右侧运算对象传递给第二个参数.\n\n运算符重载的声明和定义的分离\n放在类成员中的运算符重载, 需要算入默认的this指针参数\n```c++\n// test.h\n#include <cstdio>\nclass Test\n{\npublic:\n    Test(int a, int b);\n    Test& operator+(const Test& right);\n\tvoid PrintAB();\nprivate:\n\tint a_;\n\tint b_;\n};\n// test.cpp\n#include \"test.h\"\nTest::Test(int a, int b)\n{\n    a_ = a;\n    b_ = b;\n}\nTest& Test::operator+(const Test& right)\n{\n    Test test(this->a_ + right.a_, this->b_ + right.b_);\n    return test;\n}\nvoid Test::PrintAB()\n{\n    printf(\"%d %d\\n\", a_, b_);\n}\n// main.cpp\nint main()\n{\n    Test test1(1, 1);\n    Test test2(2, 2);\n    Test test = test1 + test2;\n    test.PrintAB();\n    return 0;\n}\n\n// ++ -- \nTest& operator++(); // 前置版本\nTest operator++(int); // 后置版本\n```\n**类成员指针**\n*数据成员指针* (private不能通过指针访问)\n其值是数据成员所在地址相对于对象起始地址的偏移值\n```c++\nA T::*p1 = &T::x\nint A::*p1 = &A::value\nA a;\n// 使用方式\na.*p = ......................;\n```\np1指向T类中的 A类型的x数据成员\n`A T::`可以用`auto`\n\n*成员函数指针*\n```c++\nint (A::*pf)();\npf = &A::GetValue;\n// 当然可以使用auto 来简化\nauto pf2 = &A::GetValue;\n// 使用方式\n(a.*pf)();\n\n```\n\n----\n统一初始化\n`X x1 = {0} 和 X x2 {0}` 这两种是不同的实现!!, 大多数情况下这两个是相通的, 然而当\n`explicit构造函数`存在的时候`前者的初始化是错误的`\n\n`int x{0} int x= 0 int x(0)` 最后一个是错误的可能会和函数声明冲突\n```c++\nclass A\n{\n\ttypedef int x;\n\tint z(x);\n}\n```\n\n另外还存在一个\n```c++\nstd::atomic<int> a1{0}; // OK\nstd::atomic<int> a2(0); // OK\nstd::atomic<int> a3 = 0; // Error\n```\n这个错误的原因是copy-initialization引起的\n这个copy-initialization发生在`T x = a`的声明, 下面我把原博客的部分重要英文替换成中文或代码描述\n`std::atomic<int> a3 = 0` 从`int类型`赋值到`可能是 cv-qualified`的`class type`\n[cv-qualified](https://stackoverflow.com/questions/27527642/what-does-cv-qualified-mean)\n```c++\n// ***cv-qualified***\n// non cv_qualified\nint first; \nchar *second; \n\n// cv-qualified \nconst int third; \nvolatile char * fourth; \n```\n`std::atomic<int> a3 = 0` 满足了这个条件属于`copy-initialization`\n[copy-initialization](https://www.quora.com/What-is-the-difference-between-copy-initialization-and-direct-initialization-of-objects-in-c++)\n[直接初始化和复制初始化的区别](https://blog.csdn.net/ljianhui/article/details/9245661)\n直接初始化会直接用参数生成对象, 而复制初始化会`用参数生成临时对象, 然后将这个对象复制到正要创建的对象`\n```c++\nclass A\n{\npublic:\n        A () { } //直接初始化会调用这个构造函数\n        A (const A& a) { } //复制初始化会调用这个\n}\n```\n接下来需要通过`std::atomic<int>(int)`把0转换成成一个纯右值(prvalue)的临时对象\n[纯右值](https://zh.cppreference.com/w/cpp/language/value_category)\n[纯右值](https://www.cnblogs.com/zpcdbky/p/5275959.html)\n然后再将这个临时对象用直接初始化(调用复制构造函数), 然而`std::atomic<int>`把拷贝\n构造函数给禁用了, 就会出错\n`std::atomic<int> a3 {0}`这个会直接调用接收int的构造函数\n\n回到`X x1 = {0}`这里, 这个表达式是一个复制构造, 用一个braced-init-list(指的{0}). \n这里有两个阶段\n首先是会把单个参数的构造函数汇总起来(得到A-list)供选择, 如果其中没有合适的构造函数, 再将候选列表\n转换为所有构造函数\n\n如果如果A-list没有构造函数, 并且class T存在默认构造函数, 第一阶段就会被忽略\n如果在一个使用`{}`的初始化, 并且选择到了`explicit 构造函数头上`就会报错\n\n`explicit`可以防止在调用某个成员函数的时候, 实参类型(通过构造函数之一)自动转换成相应参数,\n但此时这个函数需要其他的成员变量参与到函数运行, 恰巧这时所需要的其他成员变量没有得到合适的初始化, 就会发生错误(没有得到合适初始化的原因就是, 自动调用了不合适的构造函数生成了这个函数所需要的参数(一般是对象))\n\n@2019年10月26日21:25:58@算是第一次解决一个环环相扣的问题, 精力有点不足了\nhttps://zhuanlan.zhihu.com/p/21102748 后续会继续进行理解\n[这里还发现一个](https://blog.csdn.net/spaceyqy/article/details/22730939)\n\n# 模板, 泛型 动态内存, 数据结构\n```c++\ntemplate <typename T>\nconst T& GetMax(const T& a, const T& b)\n{\n    return a > b ? a : b;\n}\nint main()\n{\n    std::cout << GetMax(1, 2);\n\tstd::cout << GetMax<int>(1, 2); // 显示指定模板类型\n    return 0; \n}\n```\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/C%2B%2B%E5%86%85%E5%AD%98.png)\nC++堆的内存需要手动new和delete, 如果一个对象new出来没有在能被释放的时候释放就会造成--**内存泄漏**(需要及时delete不需要的对象)\n一个指向动态内存的指针, 在动态内存被释放后, 指针依然指向原来的地址--**空悬指针**(释放内存后将相应的指针设置为nullptr)\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png)\n","slug":"CPP-2","published":1,"updated":"2020-12-05T02:26:20.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg5p0001f8un6jpo4zuf","content":"<h1 id=\"定义新量\"><a href=\"#定义新量\" class=\"headerlink\" title=\"定义新量\"></a>定义新量</h1><p>auto 自动根据初始值的类型进行自动类型推导.<br>decltype 根据表达式的类型定义对象</p>\n<p>右值引用, 操纵右值对象<br><code>std::move()</code>, 可以将一个</p>\n<p><strong>枚举</strong><br>不限定作用域的定义<br>enum color {red, green, blue};<br>限定在类型内部的作用域<br>enum class color {red, green, blue};<br><code>color a = color::red</code></p>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><p>数组传参的长度处理</p>\n<ul>\n<li>直接传递数组长度</li>\n<li>使用C风格字符串(默认结尾有标志)</li>\n<li>使用C++11的新函数begin()和end()同时传递首尾地址</li>\n</ul>\n<p>函数指针<br><code>bool (*pf)(int, int)</code> 可以指向<br><code>bool max(int a,int b)</code><br>调用 <code>pf(1, 1)</code>即可<br>常用于函数的参数是一个函数的返回值</p>\n<p><strong>Lambda</strong><br><code>[]() -&gt; return type {statements}</code><br>中括号代表lambda引导, 其中的captures子句在同一作用域下lambda主体捕获(访问)哪些对象<br>以及如何捕获这些对象</p>\n<ul>\n<li>可以为空, 不会访问外围对象</li>\n<li>[=] 代表用值捕获的方式</li>\n<li>[&amp;] 代表引用捕获</li>\n</ul>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><p><strong>辅助函数</strong><br>定义辅助函数, 有点像Java里面的重写toString()函数(最常见的代表的例子)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ostream &amp;<span class=\"title\">print</span><span class=\"params\">(ostream &amp;os)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tos &lt;&lt; <span class=\"number\">1</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> os;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>友元函数</strong><br>一个类的辅助函数从概念上可以看成类的接口, 虽然和类的关系很密切, 但并不是类的成员, 所以不能直接访问私有成员<br>C++ 中可以将该类函数声明为该类的友元.<br>这样就能访问到类的非公有成员.<br>在函数的前面加上<code>friend</code>关键字<br><strong>友元类</strong><br>如果A想访问B的私有成员, 可以在B内声明<code>friend class A</code>, 这样就可以在B内访问A的私有成员<br><em>友元关系是单向的, 不具有交换性, 同时也不具有传递性</em></p>\n<p><strong>构造函数</strong><br>默认构造函数没有参数, 或者所有的参数都具有默认值<br>C++11允许在显示定义构造函数的情况下使用默认构造函数<br>需要在默认构造函数后面加上<code>= default</code><br><em>使用默认构造函数创建类对象时, 切忌在对象名后I使用圆括号, 成了一个函数声明</em></p>\n<p><strong>初始值列表</strong><br>T(int a, int b):a_(a), b_(b){}<br>引用和const修饰的必须用初始值列表初始化, 初始的顺序取决于数据成员在类内的定义顺序,<br>而非初始值列表的顺序</p>\n<p><strong>简化构造函数</strong><br>实际将自己的带参构造函数, 给定默认值, 这样就实现了默认构造函数和带参构造函数的合并</p>\n<p><strong>复制构造函数</strong><br>参数为该类的引用</p>\n<p><strong>委托构造函数</strong><br>减少构造函数代码量<br>实际就是一个构造函数后面加上<code>:</code>调用另一个构造函数, 同时传入参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> bar1_;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> bar2_;</span><br><span class=\"line\">\tA(<span class=\"keyword\">int</span> b1):A(b1, <span class=\"number\">2</span>)&#123;&#125;</span><br><span class=\"line\">\tA(<span class=\"keyword\">int</span> b1, <span class=\"keyword\">int</span> b2):bar1_(b1), bar2_(b2)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>运算符重载</strong><br>T operator /(A, B);<br>双目运算符两个参数<br>单目运算符一个参数<br>对于二元运算符, 左侧运算对象传递给第一个参数, 右侧运算对象传递给第二个参数.</p>\n<p>运算符重载的声明和定义的分离<br>放在类成员中的运算符重载, 需要算入默认的this指针参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Test(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b);</span><br><span class=\"line\">    Test&amp; <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Test&amp; right);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintAB</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a_;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// test.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"test.h\"</span></span></span><br><span class=\"line\">Test::Test(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    a_ = a;</span><br><span class=\"line\">    b_ = b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Test&amp; Test::<span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Test&amp; right)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">this</span>-&gt;a_ + right.a_, <span class=\"keyword\">this</span>-&gt;b_ + right.b_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> test;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Test::PrintAB</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\\n\"</span>, a_, b_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">test1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">test2</span><span class=\"params\">(<span class=\"number\">2</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">    Test test = test1 + test2;</span><br><span class=\"line\">    test.PrintAB();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ++ -- </span></span><br><span class=\"line\">Test&amp; <span class=\"keyword\">operator</span>++(); <span class=\"comment\">// 前置版本</span></span><br><span class=\"line\">Test <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>); <span class=\"comment\">// 后置版本</span></span><br></pre></td></tr></table></figure>\n<p><strong>类成员指针</strong><br><em>数据成员指针</em> (private不能通过指针访问)<br>其值是数据成员所在地址相对于对象起始地址的偏移值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A T::*p1 = &amp;T::x</span><br><span class=\"line\"><span class=\"keyword\">int</span> A::*p1 = &amp;A::value</span><br><span class=\"line\">A a;</span><br><span class=\"line\"><span class=\"comment\">// 使用方式</span></span><br><span class=\"line\">a.*p = ......................;</span><br></pre></td></tr></table></figure>\n<p>p1指向T类中的 A类型的x数据成员<br><code>A T::</code>可以用<code>auto</code></p>\n<p><em>成员函数指针</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (A::*pf)();</span><br><span class=\"line\">pf = &amp;A::GetValue;</span><br><span class=\"line\"><span class=\"comment\">// 当然可以使用auto 来简化</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> pf2 = &amp;A::GetValue;</span><br><span class=\"line\"><span class=\"comment\">// 使用方式</span></span><br><span class=\"line\">(a.*pf)();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>统一初始化<br><code>X x1 = {0} 和 X x2 {0}</code> 这两种是不同的实现!!, 大多数情况下这两个是相通的, 然而当<br><code>explicit构造函数</code>存在的时候<code>前者的初始化是错误的</code></p>\n<p><code>int x{0} int x= 0 int x(0)</code> 最后一个是错误的可能会和函数声明冲突</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">z</span><span class=\"params\">(x)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外还存在一个</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::atomic&lt;<span class=\"keyword\">int</span>&gt; a1&#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::atomic&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">a2</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::atomic&lt;<span class=\"keyword\">int</span>&gt; a3 = <span class=\"number\">0</span>; <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>这个错误的原因是copy-initialization引起的<br>这个copy-initialization发生在<code>T x = a</code>的声明, 下面我把原博客的部分重要英文替换成中文或代码描述<br><code>std::atomic&lt;int&gt; a3 = 0</code> 从<code>int类型</code>赋值到<code>可能是 cv-qualified</code>的<code>class type</code><br><a href=\"https://stackoverflow.com/questions/27527642/what-does-cv-qualified-mean\" target=\"_blank\" rel=\"noopener\">cv-qualified</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ***cv-qualified***</span></span><br><span class=\"line\"><span class=\"comment\">// non cv_qualified</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> first; </span><br><span class=\"line\"><span class=\"keyword\">char</span> *second; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cv-qualified </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> third; </span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">char</span> * fourth;</span><br></pre></td></tr></table></figure>\n<p><code>std::atomic&lt;int&gt; a3 = 0</code> 满足了这个条件属于<code>copy-initialization</code><br><a href=\"https://www.quora.com/What-is-the-difference-between-copy-initialization-and-direct-initialization-of-objects-in-c++\" target=\"_blank\" rel=\"noopener\">copy-initialization</a><br><a href=\"https://blog.csdn.net/ljianhui/article/details/9245661\" target=\"_blank\" rel=\"noopener\">直接初始化和复制初始化的区别</a><br>直接初始化会直接用参数生成对象, 而复制初始化会<code>用参数生成临时对象, 然后将这个对象复制到正要创建的对象</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">        A () &#123; &#125; <span class=\"comment\">//直接初始化会调用这个构造函数</span></span><br><span class=\"line\">        A (<span class=\"keyword\">const</span> A&amp; a) &#123; &#125; <span class=\"comment\">//复制初始化会调用这个</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来需要通过<code>std::atomic&lt;int&gt;(int)</code>把0转换成成一个纯右值(prvalue)的临时对象<br><a href=\"https://zh.cppreference.com/w/cpp/language/value_category\" target=\"_blank\" rel=\"noopener\">纯右值</a><br><a href=\"https://www.cnblogs.com/zpcdbky/p/5275959.html\" target=\"_blank\" rel=\"noopener\">纯右值</a><br>然后再将这个临时对象用直接初始化(调用复制构造函数), 然而<code>std::atomic&lt;int&gt;</code>把拷贝<br>构造函数给禁用了, 就会出错<br><code>std::atomic&lt;int&gt; a3 {0}</code>这个会直接调用接收int的构造函数</p>\n<p>回到<code>X x1 = {0}</code>这里, 这个表达式是一个复制构造, 用一个braced-init-list(指的{0}).<br>这里有两个阶段<br>首先是会把单个参数的构造函数汇总起来(得到A-list)供选择, 如果其中没有合适的构造函数, 再将候选列表<br>转换为所有构造函数</p>\n<p>如果如果A-list没有构造函数, 并且class T存在默认构造函数, 第一阶段就会被忽略<br>如果在一个使用<code>{}</code>的初始化, 并且选择到了<code>explicit 构造函数头上</code>就会报错</p>\n<p><code>explicit</code>可以防止在调用某个成员函数的时候, 实参类型(通过构造函数之一)自动转换成相应参数,<br>但此时这个函数需要其他的成员变量参与到函数运行, 恰巧这时所需要的其他成员变量没有得到合适的初始化, 就会发生错误(没有得到合适初始化的原因就是, 自动调用了不合适的构造函数生成了这个函数所需要的参数(一般是对象))</p>\n<p>@2019年10月26日21:25:58@算是第一次解决一个环环相扣的问题, 精力有点不足了<br><a href=\"https://zhuanlan.zhihu.com/p/21102748\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/21102748</a> 后续会继续进行理解<br><a href=\"https://blog.csdn.net/spaceyqy/article/details/22730939\" target=\"_blank\" rel=\"noopener\">这里还发现一个</a></p>\n<h1 id=\"模板-泛型-动态内存-数据结构\"><a href=\"#模板-泛型-动态内存-数据结构\" class=\"headerlink\" title=\"模板, 泛型 动态内存, 数据结构\"></a>模板, 泛型 动态内存, 数据结构</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> T&amp; <span class=\"title\">GetMax</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp; a, <span class=\"keyword\">const</span> T&amp; b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &gt; b ? a : b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; GetMax(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; GetMax&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 显示指定模板类型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/C%2B%2B%E5%86%85%E5%AD%98.png\" alt=\"\"><br>C++堆的内存需要手动new和delete, 如果一个对象new出来没有在能被释放的时候释放就会造成–<strong>内存泄漏</strong>(需要及时delete不需要的对象)<br>一个指向动态内存的指针, 在动态内存被释放后, 指针依然指向原来的地址–<strong>空悬指针</strong>(释放内存后将相应的指针设置为nullptr)</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"定义新量\"><a href=\"#定义新量\" class=\"headerlink\" title=\"定义新量\"></a>定义新量</h1><p>auto 自动根据初始值的类型进行自动类型推导.<br>decltype 根据表达式的类型定义对象</p>\n<p>右值引用, 操纵右值对象<br><code>std::move()</code>, 可以将一个</p>\n<p><strong>枚举</strong><br>不限定作用域的定义<br>enum color {red, green, blue};<br>限定在类型内部的作用域<br>enum class color {red, green, blue};<br><code>color a = color::red</code></p>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><p>数组传参的长度处理</p>\n<ul>\n<li>直接传递数组长度</li>\n<li>使用C风格字符串(默认结尾有标志)</li>\n<li>使用C++11的新函数begin()和end()同时传递首尾地址</li>\n</ul>\n<p>函数指针<br><code>bool (*pf)(int, int)</code> 可以指向<br><code>bool max(int a,int b)</code><br>调用 <code>pf(1, 1)</code>即可<br>常用于函数的参数是一个函数的返回值</p>\n<p><strong>Lambda</strong><br><code>[]() -&gt; return type {statements}</code><br>中括号代表lambda引导, 其中的captures子句在同一作用域下lambda主体捕获(访问)哪些对象<br>以及如何捕获这些对象</p>\n<ul>\n<li>可以为空, 不会访问外围对象</li>\n<li>[=] 代表用值捕获的方式</li>\n<li>[&amp;] 代表引用捕获</li>\n</ul>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><p><strong>辅助函数</strong><br>定义辅助函数, 有点像Java里面的重写toString()函数(最常见的代表的例子)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ostream &amp;<span class=\"title\">print</span><span class=\"params\">(ostream &amp;os)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tos &lt;&lt; <span class=\"number\">1</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> os;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>友元函数</strong><br>一个类的辅助函数从概念上可以看成类的接口, 虽然和类的关系很密切, 但并不是类的成员, 所以不能直接访问私有成员<br>C++ 中可以将该类函数声明为该类的友元.<br>这样就能访问到类的非公有成员.<br>在函数的前面加上<code>friend</code>关键字<br><strong>友元类</strong><br>如果A想访问B的私有成员, 可以在B内声明<code>friend class A</code>, 这样就可以在B内访问A的私有成员<br><em>友元关系是单向的, 不具有交换性, 同时也不具有传递性</em></p>\n<p><strong>构造函数</strong><br>默认构造函数没有参数, 或者所有的参数都具有默认值<br>C++11允许在显示定义构造函数的情况下使用默认构造函数<br>需要在默认构造函数后面加上<code>= default</code><br><em>使用默认构造函数创建类对象时, 切忌在对象名后I使用圆括号, 成了一个函数声明</em></p>\n<p><strong>初始值列表</strong><br>T(int a, int b):a_(a), b_(b){}<br>引用和const修饰的必须用初始值列表初始化, 初始的顺序取决于数据成员在类内的定义顺序,<br>而非初始值列表的顺序</p>\n<p><strong>简化构造函数</strong><br>实际将自己的带参构造函数, 给定默认值, 这样就实现了默认构造函数和带参构造函数的合并</p>\n<p><strong>复制构造函数</strong><br>参数为该类的引用</p>\n<p><strong>委托构造函数</strong><br>减少构造函数代码量<br>实际就是一个构造函数后面加上<code>:</code>调用另一个构造函数, 同时传入参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> bar1_;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> bar2_;</span><br><span class=\"line\">\tA(<span class=\"keyword\">int</span> b1):A(b1, <span class=\"number\">2</span>)&#123;&#125;</span><br><span class=\"line\">\tA(<span class=\"keyword\">int</span> b1, <span class=\"keyword\">int</span> b2):bar1_(b1), bar2_(b2)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>运算符重载</strong><br>T operator /(A, B);<br>双目运算符两个参数<br>单目运算符一个参数<br>对于二元运算符, 左侧运算对象传递给第一个参数, 右侧运算对象传递给第二个参数.</p>\n<p>运算符重载的声明和定义的分离<br>放在类成员中的运算符重载, 需要算入默认的this指针参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Test(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b);</span><br><span class=\"line\">    Test&amp; <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Test&amp; right);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintAB</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a_;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// test.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"test.h\"</span></span></span><br><span class=\"line\">Test::Test(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    a_ = a;</span><br><span class=\"line\">    b_ = b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Test&amp; Test::<span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Test&amp; right)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">this</span>-&gt;a_ + right.a_, <span class=\"keyword\">this</span>-&gt;b_ + right.b_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> test;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Test::PrintAB</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\\n\"</span>, a_, b_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">test1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">test2</span><span class=\"params\">(<span class=\"number\">2</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">    Test test = test1 + test2;</span><br><span class=\"line\">    test.PrintAB();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ++ -- </span></span><br><span class=\"line\">Test&amp; <span class=\"keyword\">operator</span>++(); <span class=\"comment\">// 前置版本</span></span><br><span class=\"line\">Test <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>); <span class=\"comment\">// 后置版本</span></span><br></pre></td></tr></table></figure>\n<p><strong>类成员指针</strong><br><em>数据成员指针</em> (private不能通过指针访问)<br>其值是数据成员所在地址相对于对象起始地址的偏移值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A T::*p1 = &amp;T::x</span><br><span class=\"line\"><span class=\"keyword\">int</span> A::*p1 = &amp;A::value</span><br><span class=\"line\">A a;</span><br><span class=\"line\"><span class=\"comment\">// 使用方式</span></span><br><span class=\"line\">a.*p = ......................;</span><br></pre></td></tr></table></figure>\n<p>p1指向T类中的 A类型的x数据成员<br><code>A T::</code>可以用<code>auto</code></p>\n<p><em>成员函数指针</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (A::*pf)();</span><br><span class=\"line\">pf = &amp;A::GetValue;</span><br><span class=\"line\"><span class=\"comment\">// 当然可以使用auto 来简化</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> pf2 = &amp;A::GetValue;</span><br><span class=\"line\"><span class=\"comment\">// 使用方式</span></span><br><span class=\"line\">(a.*pf)();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>统一初始化<br><code>X x1 = {0} 和 X x2 {0}</code> 这两种是不同的实现!!, 大多数情况下这两个是相通的, 然而当<br><code>explicit构造函数</code>存在的时候<code>前者的初始化是错误的</code></p>\n<p><code>int x{0} int x= 0 int x(0)</code> 最后一个是错误的可能会和函数声明冲突</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">z</span><span class=\"params\">(x)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外还存在一个</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::atomic&lt;<span class=\"keyword\">int</span>&gt; a1&#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::atomic&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">a2</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::atomic&lt;<span class=\"keyword\">int</span>&gt; a3 = <span class=\"number\">0</span>; <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>这个错误的原因是copy-initialization引起的<br>这个copy-initialization发生在<code>T x = a</code>的声明, 下面我把原博客的部分重要英文替换成中文或代码描述<br><code>std::atomic&lt;int&gt; a3 = 0</code> 从<code>int类型</code>赋值到<code>可能是 cv-qualified</code>的<code>class type</code><br><a href=\"https://stackoverflow.com/questions/27527642/what-does-cv-qualified-mean\" target=\"_blank\" rel=\"noopener\">cv-qualified</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ***cv-qualified***</span></span><br><span class=\"line\"><span class=\"comment\">// non cv_qualified</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> first; </span><br><span class=\"line\"><span class=\"keyword\">char</span> *second; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cv-qualified </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> third; </span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">char</span> * fourth;</span><br></pre></td></tr></table></figure>\n<p><code>std::atomic&lt;int&gt; a3 = 0</code> 满足了这个条件属于<code>copy-initialization</code><br><a href=\"https://www.quora.com/What-is-the-difference-between-copy-initialization-and-direct-initialization-of-objects-in-c++\" target=\"_blank\" rel=\"noopener\">copy-initialization</a><br><a href=\"https://blog.csdn.net/ljianhui/article/details/9245661\" target=\"_blank\" rel=\"noopener\">直接初始化和复制初始化的区别</a><br>直接初始化会直接用参数生成对象, 而复制初始化会<code>用参数生成临时对象, 然后将这个对象复制到正要创建的对象</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">        A () &#123; &#125; <span class=\"comment\">//直接初始化会调用这个构造函数</span></span><br><span class=\"line\">        A (<span class=\"keyword\">const</span> A&amp; a) &#123; &#125; <span class=\"comment\">//复制初始化会调用这个</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来需要通过<code>std::atomic&lt;int&gt;(int)</code>把0转换成成一个纯右值(prvalue)的临时对象<br><a href=\"https://zh.cppreference.com/w/cpp/language/value_category\" target=\"_blank\" rel=\"noopener\">纯右值</a><br><a href=\"https://www.cnblogs.com/zpcdbky/p/5275959.html\" target=\"_blank\" rel=\"noopener\">纯右值</a><br>然后再将这个临时对象用直接初始化(调用复制构造函数), 然而<code>std::atomic&lt;int&gt;</code>把拷贝<br>构造函数给禁用了, 就会出错<br><code>std::atomic&lt;int&gt; a3 {0}</code>这个会直接调用接收int的构造函数</p>\n<p>回到<code>X x1 = {0}</code>这里, 这个表达式是一个复制构造, 用一个braced-init-list(指的{0}).<br>这里有两个阶段<br>首先是会把单个参数的构造函数汇总起来(得到A-list)供选择, 如果其中没有合适的构造函数, 再将候选列表<br>转换为所有构造函数</p>\n<p>如果如果A-list没有构造函数, 并且class T存在默认构造函数, 第一阶段就会被忽略<br>如果在一个使用<code>{}</code>的初始化, 并且选择到了<code>explicit 构造函数头上</code>就会报错</p>\n<p><code>explicit</code>可以防止在调用某个成员函数的时候, 实参类型(通过构造函数之一)自动转换成相应参数,<br>但此时这个函数需要其他的成员变量参与到函数运行, 恰巧这时所需要的其他成员变量没有得到合适的初始化, 就会发生错误(没有得到合适初始化的原因就是, 自动调用了不合适的构造函数生成了这个函数所需要的参数(一般是对象))</p>\n<p>@2019年10月26日21:25:58@算是第一次解决一个环环相扣的问题, 精力有点不足了<br><a href=\"https://zhuanlan.zhihu.com/p/21102748\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/21102748</a> 后续会继续进行理解<br><a href=\"https://blog.csdn.net/spaceyqy/article/details/22730939\" target=\"_blank\" rel=\"noopener\">这里还发现一个</a></p>\n<h1 id=\"模板-泛型-动态内存-数据结构\"><a href=\"#模板-泛型-动态内存-数据结构\" class=\"headerlink\" title=\"模板, 泛型 动态内存, 数据结构\"></a>模板, 泛型 动态内存, 数据结构</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> T&amp; <span class=\"title\">GetMax</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp; a, <span class=\"keyword\">const</span> T&amp; b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &gt; b ? a : b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; GetMax(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; GetMax&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 显示指定模板类型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/C%2B%2B%E5%86%85%E5%AD%98.png\" alt=\"\"><br>C++堆的内存需要手动new和delete, 如果一个对象new出来没有在能被释放的时候释放就会造成–<strong>内存泄漏</strong>(需要及时delete不需要的对象)<br>一个指向动态内存的指针, 在动态内存被释放后, 指针依然指向原来的地址–<strong>空悬指针</strong>(释放内存后将相应的指针设置为nullptr)</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png\" alt=\"\"></p>\n"},{"title":"字节对齐","date":"2020-02-06T03:38:08.000Z","img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png","_content":"以前在牛客碰到不少字节对齐的题目, 当时只是为了记住而记住 今天我在学习自定义TCP二进制数据包\n的时候 遇到了必须考虑下字节对齐的情景.\n\n**解释**\n现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。--百度百科\n\n**原因**\n各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况\n但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。--百度百科\n\n\n```c++\nstruct Foo\n{\n\tchar foo1;\n    int foo2;\n    short foo3;\n}\n\nsizeof(Foo) = 12\nsizeof(char) + sizeof(int) + sizeof(short) = 7\n```\n说明内存中并不是连续存储的这三个变量;\n\n```c++\nFoo foo1{'1', 2, 3};\nwrite(fd, &foo1, sizeof(foo1));\n```\n// hexdump 查看\n0000000 5631 0000 0002 0000 0003 0000\n对应图示如下\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png)\n\n第一字节 0x31 正好是 '1' *蓝色区域*\n二三四字节 为填充 *红色区域*\n因为sizeof(int)=4所以foo2的偏移量是四的倍数 , 故需要填充三个字节 3+1 = 4\n\n第五六七八字节 0x02对应2 *灰色区域*\n这里没有填充是因为sizeof(short)=2所以foo3的偏移量是2的倍数 由于偏移量是8 所以不需要填充\n\n第九十字节 0x03 对应3\n第十一十二字节填充*黑色区域*\n因为此结构中最大的sizeof()=4所以需要将字节数对齐到4的倍数 目前10字节 所以需要填充2字节到\n12字节满足四的倍数","source":"_posts/CPP-字节对齐.md","raw":"---\ntitle: 字节对齐\ndate: 2020-02-06 11:38:08\ntags:\ncategories:\n  - CPP\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png\n---\n以前在牛客碰到不少字节对齐的题目, 当时只是为了记住而记住 今天我在学习自定义TCP二进制数据包\n的时候 遇到了必须考虑下字节对齐的情景.\n\n**解释**\n现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。--百度百科\n\n**原因**\n各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况\n但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。--百度百科\n\n\n```c++\nstruct Foo\n{\n\tchar foo1;\n    int foo2;\n    short foo3;\n}\n\nsizeof(Foo) = 12\nsizeof(char) + sizeof(int) + sizeof(short) = 7\n```\n说明内存中并不是连续存储的这三个变量;\n\n```c++\nFoo foo1{'1', 2, 3};\nwrite(fd, &foo1, sizeof(foo1));\n```\n// hexdump 查看\n0000000 5631 0000 0002 0000 0003 0000\n对应图示如下\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png)\n\n第一字节 0x31 正好是 '1' *蓝色区域*\n二三四字节 为填充 *红色区域*\n因为sizeof(int)=4所以foo2的偏移量是四的倍数 , 故需要填充三个字节 3+1 = 4\n\n第五六七八字节 0x02对应2 *灰色区域*\n这里没有填充是因为sizeof(short)=2所以foo3的偏移量是2的倍数 由于偏移量是8 所以不需要填充\n\n第九十字节 0x03 对应3\n第十一十二字节填充*黑色区域*\n因为此结构中最大的sizeof()=4所以需要将字节数对齐到4的倍数 目前10字节 所以需要填充2字节到\n12字节满足四的倍数","slug":"CPP-字节对齐","published":1,"updated":"2020-12-05T02:26:20.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg5s0003f8undi562jyq","content":"<p>以前在牛客碰到不少字节对齐的题目, 当时只是为了记住而记住 今天我在学习自定义TCP二进制数据包<br>的时候 遇到了必须考虑下字节对齐的情景.</p>\n<p><strong>解释</strong><br>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。–百度百科</p>\n<p><strong>原因</strong><br>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况<br>但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。–百度百科</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> foo1;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> foo2;</span><br><span class=\"line\">    short foo3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span>(Foo) = <span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) + <span class=\"keyword\">sizeof</span>(short) = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<p>说明内存中并不是连续存储的这三个变量;</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo foo1&#123;<span class=\"string\">'1'</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">write</span>(fd, &amp;foo1, <span class=\"keyword\">sizeof</span>(foo1));</span><br></pre></td></tr></table></figure>\n<p>// hexdump 查看<br>0000000 5631 0000 0002 0000 0003 0000<br>对应图示如下<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png\" alt=\"\"></p>\n<p>第一字节 0x31 正好是 ‘1’ <em>蓝色区域</em><br>二三四字节 为填充 <em>红色区域</em><br>因为sizeof(int)=4所以foo2的偏移量是四的倍数 , 故需要填充三个字节 3+1 = 4</p>\n<p>第五六七八字节 0x02对应2 <em>灰色区域</em><br>这里没有填充是因为sizeof(short)=2所以foo3的偏移量是2的倍数 由于偏移量是8 所以不需要填充</p>\n<p>第九十字节 0x03 对应3<br>第十一十二字节填充<em>黑色区域</em><br>因为此结构中最大的sizeof()=4所以需要将字节数对齐到4的倍数 目前10字节 所以需要填充2字节到<br>12字节满足四的倍数</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以前在牛客碰到不少字节对齐的题目, 当时只是为了记住而记住 今天我在学习自定义TCP二进制数据包<br>的时候 遇到了必须考虑下字节对齐的情景.</p>\n<p><strong>解释</strong><br>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。–百度百科</p>\n<p><strong>原因</strong><br>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况<br>但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。–百度百科</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> foo1;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> foo2;</span><br><span class=\"line\">    short foo3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span>(Foo) = <span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) + <span class=\"keyword\">sizeof</span>(short) = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<p>说明内存中并不是连续存储的这三个变量;</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo foo1&#123;<span class=\"string\">'1'</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">write</span>(fd, &amp;foo1, <span class=\"keyword\">sizeof</span>(foo1));</span><br></pre></td></tr></table></figure>\n<p>// hexdump 查看<br>0000000 5631 0000 0002 0000 0003 0000<br>对应图示如下<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png\" alt=\"\"></p>\n<p>第一字节 0x31 正好是 ‘1’ <em>蓝色区域</em><br>二三四字节 为填充 <em>红色区域</em><br>因为sizeof(int)=4所以foo2的偏移量是四的倍数 , 故需要填充三个字节 3+1 = 4</p>\n<p>第五六七八字节 0x02对应2 <em>灰色区域</em><br>这里没有填充是因为sizeof(short)=2所以foo3的偏移量是2的倍数 由于偏移量是8 所以不需要填充</p>\n<p>第九十字节 0x03 对应3<br>第十一十二字节填充<em>黑色区域</em><br>因为此结构中最大的sizeof()=4所以需要将字节数对齐到4的倍数 目前10字节 所以需要填充2字节到<br>12字节满足四的倍数</p>\n"},{"title":"CPP11特性","date":"2020-02-19T09:41:27.000Z","_content":"\n# 库新特性\n\n## std::move\n\n用于指示对象可以被移动\n\n- 用于移动字符串 表示不复制字符串而是将内容移动 降低成本 原字符串变量将会未定义\n- 从左值带std::move构造 不会进行别名检查 这就意味着不进行自我赋值检查 导致未定义行为\n\n## std::forward<T>\n\n1. 转发左值为左值或右值 依赖于T\n\n```c++\ntemplate<class T>\nvoid Wrapper(T&& arg)\n{\n    Foo(std::forward<T>(arg));\n}\n\n```\n传递 右值std::string时, 推导T为 std::string\nforward将右值引用传递给Foo\n\n传递 左值const std::string时推导T为 const std::string&\n将const左值引用传递给Foo\n\n传递 左值非const std::string时推导T为 std::string&\n将非const左值引用传递给Foo\n\n2. 转发右值为右值 并禁止右值的转发为左值\n\n\n```c++\n#include <iostream>\n#include <memory>\n#include <utility>\n\nstruct A\n{\n    A(int&& n) { std::cout << \"rvalue overload, n=\" << n << \"\\n\"; }\n    A(int& n) { std::cout << \"lvalue overload, n=\" << n << \"\\n\"; }\n};\n\nclass B\n{\npublic:\n    template<class T1, class T2, class T3>\n    B(T1&& t1, T2&& t2, T3&& t3) :\n        a1_{ std::forward<T1>(t1) },\n        a2_{ std::forward<T2>(t2) },\n        a3_{ std::forward<T3>(t3) }\n    {\n    }\n\nprivate:\n    A a1_, a2_, a3_;\n};\n\ntemplate<class T, class... U>\nstd::unique_ptr<T> make_unique1(U&&... u)\n{\n    return std::unique_ptr<T>(new T(u...));\n}\n\ntemplate<class T, class... U>\nstd::unique_ptr<T> make_unique2(U&&... u)\n{\n    return std::unique_ptr<T>(new T(std::forward<U>(u)...));\n}\n\nint main()\n{\n    int i = 1;\n    make_unique1<B>(2, i, 3);\n    make_unique2<B>(2, i, 3);\n}\n```\nlvalue overload, n=2\nlvalue overload, n=1\nlvalue overload, n=3\n\nrvalue overload, n=2\nlvalue overload, n=1\nrvalue overload, n=3\n\n## <mutex>\n\n目前对于标准库的多线程没有使用的想法. 后面再说.\n\nhttps://zh.cppreference.com/w/cpp/thread\n\n## \n\n\n\n# 语言新特性\n## Lambda\n参考资料\nhttps://zh.cppreference.com/w/cpp/language/lambda\nhttps://blog.csdn.net/qq_34199383/article/details/80469780\n\n```c++\n[ 捕获 ] ( 形参 ) -> ret { 函数体 }\n[ 捕获 ] ( 形参 ) { 函数体 }\n[ 捕获 ] { 函数体 }\n\n& 以引用隐式捕获被使用的自动变量\n= 以复制隐式捕获被使用的自动变量\n\n[&]{};          // OK：默认以引用捕获\n[&, i]{};       // OK：以引用捕获，但 i 以值捕获\n\n[=]{};          // OK：默认以复制捕获\n[=, &i]{};      // OK：以复制捕获，但 i 以引用捕获\n\n[this]{}; // 获取this指针, 如果使用了&和=则会默认包括this\n```\n**使用场景一**\n以sort为代表的函数 需要传入函数的函数\n```c++\n// 原版\nbool compare(int &a, int &b)\n{\n\treturn a > b;\n}\n\nxxx(compare);\n\n// 新版\nxxx([](int a, int b){return a > b;});\n```\n**使用场景二**\n```c++\nauto add = [](int a, int b){return a + b;};\nint bar = add(1, 2);\n```\n\n## 类型特性\nhttps://zh.cppreference.com/w/cpp/types##.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29\n\n神仙的头文件<type_traits> 可以判断一个值是否是某个类型\n\n比如判断一个值\n是不是 整形\n是不是 void\n是不是 数组 等等\n\n目前不知道用在什么地方合适..... 留个连接备用吧\n\n## 花括号初始\n\n## 函数对象\n#### std::function  functional\n```c++\n##include <functional>\n##include <iostream>\n\nvoid PrintA()\n{\n    std::cout << \"A\" << std::endl;\n}\nvoid PrintB(int bar)\n{\n    std::cout << \"B\" << std::endl;\n}\nint main()\n{\n    std::function<void()> FPrintA = PrintA;\n    FPrintA();\n\n    std::function<void(int)> FPrintB = PrintB;\n    FPrintB(1);\n\n// 感觉配合Lambad 挺不错, 在一个函数中经常使用的功能可以这样定义\n    std::function<void()> FLambad = [](){std::cout << \"Lambad\" << std::endl;};\n    FLambad();\n\t\n\t// 不过使用auto貌似更简单\n\tauto ALambad = [](){std::cout << \"Lambad\" << std::endl;};\n    ALambad();\n}\n\n$ A\n$ B\n$ Lambad\n```\n\n#### std::bind std::ref std::cref\n今天在学习\nhttps://github.com/baloonwj/flamingo\n的时候, 从中发现的这个函数. 这个函数跟std::function 一起使用.\n竟然实现了回调函数调用类的成员函数!!!!\n\nhttps://zh.cppreference.com/w/cpp/utility/functional/bind\n\n```c++\n##include <functional>\n##include <cstdio>\n\nvoid f(int n1, int n2, int n3, int n4)\n{\n    printf(\"f function-->n1: %d, n2: %d, n3: %d, n4: %d\\n\", n1, n2, n3, n4);\n}\n\nvoid ff(int &n1, int& n2, const int& n3)\n{\n    printf(\"before ff function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n    n1 = 11;\n    n2 = 22;\n    // n3 = 33; 编译错误\n    printf(\"after ff function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n}\n\nint main()\n{\n    auto f1 = std::bind(f, std::placeholders::_2, std::placeholders::_3, 666, std::placeholders::_1);\n\n    f1(1, 2, 3, 4, 5);\n    // infunction-->n1: 2, n2: 3, n3: 666, n4: 1\n    // 1 绑定_1  2绑定_2  3绑定_3   // 4 5被忽略\n    // 按照 f1的顺序传入参数\n    // 所以调用为 f(2, 3, 666, 1);\n\n    int n1 = 1, n2 = 2, n3 = 3;\n    auto ff1 = std::bind(ff, n1, std::ref(n2), std::cref(n3));\n    n1 = -1;\n    n2 = -2;\n    n3 = -3;\n    printf(\"before ff1 function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n    ff1(n1, n2, n3);\n    printf(\"after ff1 function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n    // before ff1 function-->n1: -1, n2: -2, n3: -3\n    // before ff function-- > n1: 1, n2 : -2, n3 : -3 // 这里说明了值传递 参数是绑定时就决定好了 引用参数还是可以改变的\n    // after ff function-- > n1: 11, n2 : 22, n3 : -3\n    // after ff1 function-- > n1: -1, n2 : 22, n3 : -3 // 引用传入成功改变, 值传入和const引用传入未变\n\n    // std::ref 按引用传入参数 std::cref按const引用传入参数\n}\n```\n\n\n\n#### std::pair utility std::tuple tuple\n\nhttps://zh.cppreference.com/w/cpp/utility/tuple\n\npair是 结构体模板, 可在一个单元中存储两个相异对象. pair是tuple拥有两个元素的特殊情况\n\ntuple是固定大小的异类值(啥是异类值??)汇集\n```c++\nstd::tuple<int, double > GetInfoById(int id)\n{\n    if (id == 0) return std::make_tuple(1, 1.1);\n    if (id == 1) return std::make_tuple(2, 2.2);\n\n    throw std::invalid_argument(\"id\");\n}\n\nint main()\n{\n    auto info = GetInfoById(0);\n\t// 获取指定位置\n    std::cout << \"1:\" << std::get<0>(info)\n            << \" 2:\" << std::get<1>(info) << std::endl;\n\n    int val1;\n    double val2;\n\t// 直接创建引用的tuple\n    std::tie(val1, val2) = GetInfoById(1);\n    std::cout << \"1:\" << val1\n              << \" 2:\" << val2 << std::endl;\n\t\t\t  \n$ 1:1 2:1.1\n$ 1:2 2:2.2\n}\n```","source":"_posts/CPP-CPP11特性.md","raw":"---\ntitle: CPP11特性\ndate: 2020-02-19 17:41:27\ntags:\ncategories:\n - CPP\n---\n\n# 库新特性\n\n## std::move\n\n用于指示对象可以被移动\n\n- 用于移动字符串 表示不复制字符串而是将内容移动 降低成本 原字符串变量将会未定义\n- 从左值带std::move构造 不会进行别名检查 这就意味着不进行自我赋值检查 导致未定义行为\n\n## std::forward<T>\n\n1. 转发左值为左值或右值 依赖于T\n\n```c++\ntemplate<class T>\nvoid Wrapper(T&& arg)\n{\n    Foo(std::forward<T>(arg));\n}\n\n```\n传递 右值std::string时, 推导T为 std::string\nforward将右值引用传递给Foo\n\n传递 左值const std::string时推导T为 const std::string&\n将const左值引用传递给Foo\n\n传递 左值非const std::string时推导T为 std::string&\n将非const左值引用传递给Foo\n\n2. 转发右值为右值 并禁止右值的转发为左值\n\n\n```c++\n#include <iostream>\n#include <memory>\n#include <utility>\n\nstruct A\n{\n    A(int&& n) { std::cout << \"rvalue overload, n=\" << n << \"\\n\"; }\n    A(int& n) { std::cout << \"lvalue overload, n=\" << n << \"\\n\"; }\n};\n\nclass B\n{\npublic:\n    template<class T1, class T2, class T3>\n    B(T1&& t1, T2&& t2, T3&& t3) :\n        a1_{ std::forward<T1>(t1) },\n        a2_{ std::forward<T2>(t2) },\n        a3_{ std::forward<T3>(t3) }\n    {\n    }\n\nprivate:\n    A a1_, a2_, a3_;\n};\n\ntemplate<class T, class... U>\nstd::unique_ptr<T> make_unique1(U&&... u)\n{\n    return std::unique_ptr<T>(new T(u...));\n}\n\ntemplate<class T, class... U>\nstd::unique_ptr<T> make_unique2(U&&... u)\n{\n    return std::unique_ptr<T>(new T(std::forward<U>(u)...));\n}\n\nint main()\n{\n    int i = 1;\n    make_unique1<B>(2, i, 3);\n    make_unique2<B>(2, i, 3);\n}\n```\nlvalue overload, n=2\nlvalue overload, n=1\nlvalue overload, n=3\n\nrvalue overload, n=2\nlvalue overload, n=1\nrvalue overload, n=3\n\n## <mutex>\n\n目前对于标准库的多线程没有使用的想法. 后面再说.\n\nhttps://zh.cppreference.com/w/cpp/thread\n\n## \n\n\n\n# 语言新特性\n## Lambda\n参考资料\nhttps://zh.cppreference.com/w/cpp/language/lambda\nhttps://blog.csdn.net/qq_34199383/article/details/80469780\n\n```c++\n[ 捕获 ] ( 形参 ) -> ret { 函数体 }\n[ 捕获 ] ( 形参 ) { 函数体 }\n[ 捕获 ] { 函数体 }\n\n& 以引用隐式捕获被使用的自动变量\n= 以复制隐式捕获被使用的自动变量\n\n[&]{};          // OK：默认以引用捕获\n[&, i]{};       // OK：以引用捕获，但 i 以值捕获\n\n[=]{};          // OK：默认以复制捕获\n[=, &i]{};      // OK：以复制捕获，但 i 以引用捕获\n\n[this]{}; // 获取this指针, 如果使用了&和=则会默认包括this\n```\n**使用场景一**\n以sort为代表的函数 需要传入函数的函数\n```c++\n// 原版\nbool compare(int &a, int &b)\n{\n\treturn a > b;\n}\n\nxxx(compare);\n\n// 新版\nxxx([](int a, int b){return a > b;});\n```\n**使用场景二**\n```c++\nauto add = [](int a, int b){return a + b;};\nint bar = add(1, 2);\n```\n\n## 类型特性\nhttps://zh.cppreference.com/w/cpp/types##.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29\n\n神仙的头文件<type_traits> 可以判断一个值是否是某个类型\n\n比如判断一个值\n是不是 整形\n是不是 void\n是不是 数组 等等\n\n目前不知道用在什么地方合适..... 留个连接备用吧\n\n## 花括号初始\n\n## 函数对象\n#### std::function  functional\n```c++\n##include <functional>\n##include <iostream>\n\nvoid PrintA()\n{\n    std::cout << \"A\" << std::endl;\n}\nvoid PrintB(int bar)\n{\n    std::cout << \"B\" << std::endl;\n}\nint main()\n{\n    std::function<void()> FPrintA = PrintA;\n    FPrintA();\n\n    std::function<void(int)> FPrintB = PrintB;\n    FPrintB(1);\n\n// 感觉配合Lambad 挺不错, 在一个函数中经常使用的功能可以这样定义\n    std::function<void()> FLambad = [](){std::cout << \"Lambad\" << std::endl;};\n    FLambad();\n\t\n\t// 不过使用auto貌似更简单\n\tauto ALambad = [](){std::cout << \"Lambad\" << std::endl;};\n    ALambad();\n}\n\n$ A\n$ B\n$ Lambad\n```\n\n#### std::bind std::ref std::cref\n今天在学习\nhttps://github.com/baloonwj/flamingo\n的时候, 从中发现的这个函数. 这个函数跟std::function 一起使用.\n竟然实现了回调函数调用类的成员函数!!!!\n\nhttps://zh.cppreference.com/w/cpp/utility/functional/bind\n\n```c++\n##include <functional>\n##include <cstdio>\n\nvoid f(int n1, int n2, int n3, int n4)\n{\n    printf(\"f function-->n1: %d, n2: %d, n3: %d, n4: %d\\n\", n1, n2, n3, n4);\n}\n\nvoid ff(int &n1, int& n2, const int& n3)\n{\n    printf(\"before ff function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n    n1 = 11;\n    n2 = 22;\n    // n3 = 33; 编译错误\n    printf(\"after ff function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n}\n\nint main()\n{\n    auto f1 = std::bind(f, std::placeholders::_2, std::placeholders::_3, 666, std::placeholders::_1);\n\n    f1(1, 2, 3, 4, 5);\n    // infunction-->n1: 2, n2: 3, n3: 666, n4: 1\n    // 1 绑定_1  2绑定_2  3绑定_3   // 4 5被忽略\n    // 按照 f1的顺序传入参数\n    // 所以调用为 f(2, 3, 666, 1);\n\n    int n1 = 1, n2 = 2, n3 = 3;\n    auto ff1 = std::bind(ff, n1, std::ref(n2), std::cref(n3));\n    n1 = -1;\n    n2 = -2;\n    n3 = -3;\n    printf(\"before ff1 function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n    ff1(n1, n2, n3);\n    printf(\"after ff1 function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n    // before ff1 function-->n1: -1, n2: -2, n3: -3\n    // before ff function-- > n1: 1, n2 : -2, n3 : -3 // 这里说明了值传递 参数是绑定时就决定好了 引用参数还是可以改变的\n    // after ff function-- > n1: 11, n2 : 22, n3 : -3\n    // after ff1 function-- > n1: -1, n2 : 22, n3 : -3 // 引用传入成功改变, 值传入和const引用传入未变\n\n    // std::ref 按引用传入参数 std::cref按const引用传入参数\n}\n```\n\n\n\n#### std::pair utility std::tuple tuple\n\nhttps://zh.cppreference.com/w/cpp/utility/tuple\n\npair是 结构体模板, 可在一个单元中存储两个相异对象. pair是tuple拥有两个元素的特殊情况\n\ntuple是固定大小的异类值(啥是异类值??)汇集\n```c++\nstd::tuple<int, double > GetInfoById(int id)\n{\n    if (id == 0) return std::make_tuple(1, 1.1);\n    if (id == 1) return std::make_tuple(2, 2.2);\n\n    throw std::invalid_argument(\"id\");\n}\n\nint main()\n{\n    auto info = GetInfoById(0);\n\t// 获取指定位置\n    std::cout << \"1:\" << std::get<0>(info)\n            << \" 2:\" << std::get<1>(info) << std::endl;\n\n    int val1;\n    double val2;\n\t// 直接创建引用的tuple\n    std::tie(val1, val2) = GetInfoById(1);\n    std::cout << \"1:\" << val1\n              << \" 2:\" << val2 << std::endl;\n\t\t\t  \n$ 1:1 2:1.1\n$ 1:2 2:2.2\n}\n```","slug":"CPP-CPP11特性","published":1,"updated":"2020-12-05T02:26:20.247Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg5t0004f8unawmueadg","content":"<h1 id=\"库新特性\"><a href=\"#库新特性\" class=\"headerlink\" title=\"库新特性\"></a>库新特性</h1><h2 id=\"std-move\"><a href=\"#std-move\" class=\"headerlink\" title=\"std::move\"></a>std::move</h2><p>用于指示对象可以被移动</p>\n<ul>\n<li>用于移动字符串 表示不复制字符串而是将内容移动 降低成本 原字符串变量将会未定义</li>\n<li>从左值带std::move构造 不会进行别名检查 这就意味着不进行自我赋值检查 导致未定义行为</li>\n</ul>\n<h2 id=\"std-forward\"><a href=\"#std-forward\" class=\"headerlink\" title=\"std::forward\"></a>std::forward<T></h2><ol>\n<li>转发左值为左值或右值 依赖于T</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">Wrapper</span>(<span class=\"title\">T</span>&amp;&amp; <span class=\"title\">arg</span>)</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    Foo(<span class=\"built_in\">std</span>::forward&lt;T&gt;(arg));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>传递 右值std::string时, 推导T为 std::string<br>forward将右值引用传递给Foo</p>\n<p>传递 左值const std::string时推导T为 const std::string&amp;<br>将const左值引用传递给Foo</p>\n<p>传递 左值非const std::string时推导T为 std::string&amp;<br>将非const左值引用传递给Foo</p>\n<ol start=\"2\">\n<li>转发右值为右值 并禁止右值的转发为左值</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A(<span class=\"keyword\">int</span>&amp;&amp; n) &#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"rvalue overload, n=\"</span> &lt;&lt; n &lt;&lt; <span class=\"string\">\"\\n\"</span>; &#125;</span><br><span class=\"line\">    A(<span class=\"keyword\">int</span>&amp; n) &#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"lvalue overload, n=\"</span> &lt;&lt; n &lt;&lt; <span class=\"string\">\"\\n\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T1</span>, <span class=\"title\">class</span> <span class=\"title\">T2</span>, <span class=\"title\">class</span> <span class=\"title\">T3</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">B</span>(<span class=\"title\">T1</span>&amp;&amp; <span class=\"title\">t1</span>, <span class=\"title\">T2</span>&amp;&amp; <span class=\"title\">t2</span>, <span class=\"title\">T3</span>&amp;&amp; <span class=\"title\">t3</span>) :</span></span><br><span class=\"line\">        a1_&#123; <span class=\"built_in\">std</span>::forward&lt;T1&gt;(t1) &#125;,</span><br><span class=\"line\">        a2_&#123; <span class=\"built_in\">std</span>::forward&lt;T2&gt;(t2) &#125;,</span><br><span class=\"line\">        a3_&#123; <span class=\"built_in\">std</span>::forward&lt;T3&gt;(t3) &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    A a1_, a2_, a3_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span>... <span class=\"title\">U</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">std</span>:</span>:<span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;T&gt; <span class=\"title\">make_unique1</span><span class=\"params\">(U&amp;&amp;... u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;T&gt;(<span class=\"keyword\">new</span> T(u...));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span>... <span class=\"title\">U</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">std</span>:</span>:<span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;T&gt; <span class=\"title\">make_unique2</span><span class=\"params\">(U&amp;&amp;... u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;T&gt;(<span class=\"keyword\">new</span> T(<span class=\"built_in\">std</span>::forward&lt;U&gt;(u)...));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    make_unique1&lt;B&gt;(<span class=\"number\">2</span>, i, <span class=\"number\">3</span>);</span><br><span class=\"line\">    make_unique2&lt;B&gt;(<span class=\"number\">2</span>, i, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>lvalue overload, n=2<br>lvalue overload, n=1<br>lvalue overload, n=3</p>\n<p>rvalue overload, n=2<br>lvalue overload, n=1<br>rvalue overload, n=3</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><mutex></h2><p>目前对于标准库的多线程没有使用的想法. 后面再说.</p>\n<p><a href=\"https://zh.cppreference.com/w/cpp/thread\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/thread</a></p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h2><h1 id=\"语言新特性\"><a href=\"#语言新特性\" class=\"headerlink\" title=\"语言新特性\"></a>语言新特性</h1><h2 id=\"Lambda\"><a href=\"#Lambda\" class=\"headerlink\" title=\"Lambda\"></a>Lambda</h2><p>参考资料<br><a href=\"https://zh.cppreference.com/w/cpp/language/lambda\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/language/lambda</a><br><a href=\"https://blog.csdn.net/qq_34199383/article/details/80469780\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_34199383/article/details/80469780</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ 捕获 ] ( 形参 ) -&gt; ret &#123; 函数体 &#125;</span><br><span class=\"line\">[ 捕获 ] ( 形参 ) &#123; 函数体 &#125;</span><br><span class=\"line\">[ 捕获 ] &#123; 函数体 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&amp; 以引用隐式捕获被使用的自动变量</span><br><span class=\"line\">= 以复制隐式捕获被使用的自动变量</span><br><span class=\"line\"></span><br><span class=\"line\">[&amp;]&#123;&#125;;          <span class=\"comment\">// OK：默认以引用捕获</span></span><br><span class=\"line\">[&amp;, i]&#123;&#125;;       <span class=\"comment\">// OK：以引用捕获，但 i 以值捕获</span></span><br><span class=\"line\"></span><br><span class=\"line\">[=]&#123;&#125;;          <span class=\"comment\">// OK：默认以复制捕获</span></span><br><span class=\"line\">[=, &amp;i]&#123;&#125;;      <span class=\"comment\">// OK：以复制捕获，但 i 以引用捕获</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">this</span>]&#123;&#125;; <span class=\"comment\">// 获取this指针, 如果使用了&amp;和=则会默认包括this</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用场景一</strong><br>以sort为代表的函数 需要传入函数的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原版</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;a, <span class=\"keyword\">int</span> &amp;b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a &gt; b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">xxx(compare);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新版</span></span><br><span class=\"line\">xxx([](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)&#123;<span class=\"keyword\">return</span> a &gt; b;&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>使用场景二</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> add = [](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)&#123;<span class=\"keyword\">return</span> a + b;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bar = add(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类型特性\"><a href=\"#类型特性\" class=\"headerlink\" title=\"类型特性\"></a>类型特性</h2><p><a href=\"https://zh.cppreference.com/w/cpp/types##.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/types##.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29</a></p>\n<p>神仙的头文件<type_traits> 可以判断一个值是否是某个类型</p>\n<p>比如判断一个值<br>是不是 整形<br>是不是 void<br>是不是 数组 等等</p>\n<p>目前不知道用在什么地方合适….. 留个连接备用吧</p>\n<h2 id=\"花括号初始\"><a href=\"#花括号初始\" class=\"headerlink\" title=\"花括号初始\"></a>花括号初始</h2><h2 id=\"函数对象\"><a href=\"#函数对象\" class=\"headerlink\" title=\"函数对象\"></a>函数对象</h2><h4 id=\"std-function-functional\"><a href=\"#std-function-functional\" class=\"headerlink\" title=\"std::function  functional\"></a>std::function  functional</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\">#<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintA</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintB</span><span class=\"params\">(<span class=\"keyword\">int</span> bar)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; FPrintA = PrintA;</span><br><span class=\"line\">    FPrintA();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>(<span class=\"keyword\">int</span>)&gt; FPrintB = PrintB;</span><br><span class=\"line\">    FPrintB(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 感觉配合Lambad 挺不错, 在一个函数中经常使用的功能可以这样定义</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; FLambad = []()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Lambad\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;;</span><br><span class=\"line\">    FLambad();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 不过使用auto貌似更简单</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> ALambad = []()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Lambad\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;;</span><br><span class=\"line\">    ALambad();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$ A</span><br><span class=\"line\">$ B</span><br><span class=\"line\">$ Lambad</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"std-bind-std-ref-std-cref\"><a href=\"#std-bind-std-ref-std-cref\" class=\"headerlink\" title=\"std::bind std::ref std::cref\"></a>std::bind std::ref std::cref</h4><p>今天在学习<br><a href=\"https://github.com/baloonwj/flamingo\" target=\"_blank\" rel=\"noopener\">https://github.com/baloonwj/flamingo</a><br>的时候, 从中发现的这个函数. 这个函数跟std::function 一起使用.<br>竟然实现了回调函数调用类的成员函数!!!!</p>\n<p><a href=\"https://zh.cppreference.com/w/cpp/utility/functional/bind\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/utility/functional/bind</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\">#<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> n1, <span class=\"keyword\">int</span> n2, <span class=\"keyword\">int</span> n3, <span class=\"keyword\">int</span> n4)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"f function--&gt;n1: %d, n2: %d, n3: %d, n4: %d\\n\"</span>, n1, n2, n3, n4);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ff</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;n1, <span class=\"keyword\">int</span>&amp; n2, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; n3)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"before ff function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">    n1 = <span class=\"number\">11</span>;</span><br><span class=\"line\">    n2 = <span class=\"number\">22</span>;</span><br><span class=\"line\">    <span class=\"comment\">// n3 = 33; 编译错误</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"after ff function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f1 = <span class=\"built_in\">std</span>::bind(f, <span class=\"built_in\">std</span>::placeholders::_2, <span class=\"built_in\">std</span>::placeholders::_3, <span class=\"number\">666</span>, <span class=\"built_in\">std</span>::placeholders::_1);</span><br><span class=\"line\"></span><br><span class=\"line\">    f1(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"comment\">// infunction--&gt;n1: 2, n2: 3, n3: 666, n4: 1</span></span><br><span class=\"line\">    <span class=\"comment\">// 1 绑定_1  2绑定_2  3绑定_3   // 4 5被忽略</span></span><br><span class=\"line\">    <span class=\"comment\">// 按照 f1的顺序传入参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以调用为 f(2, 3, 666, 1);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n1 = <span class=\"number\">1</span>, n2 = <span class=\"number\">2</span>, n3 = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> ff1 = <span class=\"built_in\">std</span>::bind(ff, n1, <span class=\"built_in\">std</span>::ref(n2), <span class=\"built_in\">std</span>::cref(n3));</span><br><span class=\"line\">    n1 = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    n2 = <span class=\"number\">-2</span>;</span><br><span class=\"line\">    n3 = <span class=\"number\">-3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"before ff1 function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">    ff1(n1, n2, n3);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"after ff1 function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">    <span class=\"comment\">// before ff1 function--&gt;n1: -1, n2: -2, n3: -3</span></span><br><span class=\"line\">    <span class=\"comment\">// before ff function-- &gt; n1: 1, n2 : -2, n3 : -3 // 这里说明了值传递 参数是绑定时就决定好了 引用参数还是可以改变的</span></span><br><span class=\"line\">    <span class=\"comment\">// after ff function-- &gt; n1: 11, n2 : 22, n3 : -3</span></span><br><span class=\"line\">    <span class=\"comment\">// after ff1 function-- &gt; n1: -1, n2 : 22, n3 : -3 // 引用传入成功改变, 值传入和const引用传入未变</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// std::ref 按引用传入参数 std::cref按const引用传入参数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"std-pair-utility-std-tuple-tuple\"><a href=\"#std-pair-utility-std-tuple-tuple\" class=\"headerlink\" title=\"std::pair utility std::tuple tuple\"></a>std::pair utility std::tuple tuple</h4><p><a href=\"https://zh.cppreference.com/w/cpp/utility/tuple\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/utility/tuple</a></p>\n<p>pair是 结构体模板, 可在一个单元中存储两个相异对象. pair是tuple拥有两个元素的特殊情况</p>\n<p>tuple是固定大小的异类值(啥是异类值??)汇集</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::tuple&lt;int, double &gt; GetInfoById(int id)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (id == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::make_tuple(<span class=\"number\">1</span>, <span class=\"number\">1.1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (id == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::make_tuple(<span class=\"number\">2</span>, <span class=\"number\">2.2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::invalid_argument(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> info = GetInfoById(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 获取指定位置</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"1:\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">get</span>&lt;<span class=\"number\">0</span>&gt;(info)</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\" 2:\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">get</span>&lt;<span class=\"number\">1</span>&gt;(info) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val1;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> val2;</span><br><span class=\"line\">\t<span class=\"comment\">// 直接创建引用的tuple</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::tie(val1, val2) = GetInfoById(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"1:\"</span> &lt;&lt; val1</span><br><span class=\"line\">              &lt;&lt; <span class=\"string\">\" 2:\"</span> &lt;&lt; val2 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t\t  </span><br><span class=\"line\">$ <span class=\"number\">1</span>:<span class=\"number\">1</span> <span class=\"number\">2</span>:<span class=\"number\">1.1</span></span><br><span class=\"line\">$ <span class=\"number\">1</span>:<span class=\"number\">2</span> <span class=\"number\">2</span>:<span class=\"number\">2.2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"库新特性\"><a href=\"#库新特性\" class=\"headerlink\" title=\"库新特性\"></a>库新特性</h1><h2 id=\"std-move\"><a href=\"#std-move\" class=\"headerlink\" title=\"std::move\"></a>std::move</h2><p>用于指示对象可以被移动</p>\n<ul>\n<li>用于移动字符串 表示不复制字符串而是将内容移动 降低成本 原字符串变量将会未定义</li>\n<li>从左值带std::move构造 不会进行别名检查 这就意味着不进行自我赋值检查 导致未定义行为</li>\n</ul>\n<h2 id=\"std-forward\"><a href=\"#std-forward\" class=\"headerlink\" title=\"std::forward\"></a>std::forward<T></h2><ol>\n<li>转发左值为左值或右值 依赖于T</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">void</span> <span class=\"title\">Wrapper</span>(<span class=\"title\">T</span>&amp;&amp; <span class=\"title\">arg</span>)</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    Foo(<span class=\"built_in\">std</span>::forward&lt;T&gt;(arg));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>传递 右值std::string时, 推导T为 std::string<br>forward将右值引用传递给Foo</p>\n<p>传递 左值const std::string时推导T为 const std::string&amp;<br>将const左值引用传递给Foo</p>\n<p>传递 左值非const std::string时推导T为 std::string&amp;<br>将非const左值引用传递给Foo</p>\n<ol start=\"2\">\n<li>转发右值为右值 并禁止右值的转发为左值</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A(<span class=\"keyword\">int</span>&amp;&amp; n) &#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"rvalue overload, n=\"</span> &lt;&lt; n &lt;&lt; <span class=\"string\">\"\\n\"</span>; &#125;</span><br><span class=\"line\">    A(<span class=\"keyword\">int</span>&amp; n) &#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"lvalue overload, n=\"</span> &lt;&lt; n &lt;&lt; <span class=\"string\">\"\\n\"</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T1</span>, <span class=\"title\">class</span> <span class=\"title\">T2</span>, <span class=\"title\">class</span> <span class=\"title\">T3</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\">    <span class=\"title\">B</span>(<span class=\"title\">T1</span>&amp;&amp; <span class=\"title\">t1</span>, <span class=\"title\">T2</span>&amp;&amp; <span class=\"title\">t2</span>, <span class=\"title\">T3</span>&amp;&amp; <span class=\"title\">t3</span>) :</span></span><br><span class=\"line\">        a1_&#123; <span class=\"built_in\">std</span>::forward&lt;T1&gt;(t1) &#125;,</span><br><span class=\"line\">        a2_&#123; <span class=\"built_in\">std</span>::forward&lt;T2&gt;(t2) &#125;,</span><br><span class=\"line\">        a3_&#123; <span class=\"built_in\">std</span>::forward&lt;T3&gt;(t3) &#125;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    A a1_, a2_, a3_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span>... <span class=\"title\">U</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">std</span>:</span>:<span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;T&gt; <span class=\"title\">make_unique1</span><span class=\"params\">(U&amp;&amp;... u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;T&gt;(<span class=\"keyword\">new</span> T(u...));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>, <span class=\"title\">class</span>... <span class=\"title\">U</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">std</span>:</span>:<span class=\"function\"><span class=\"built_in\">unique_ptr</span>&lt;T&gt; <span class=\"title\">make_unique2</span><span class=\"params\">(U&amp;&amp;... u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;T&gt;(<span class=\"keyword\">new</span> T(<span class=\"built_in\">std</span>::forward&lt;U&gt;(u)...));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    make_unique1&lt;B&gt;(<span class=\"number\">2</span>, i, <span class=\"number\">3</span>);</span><br><span class=\"line\">    make_unique2&lt;B&gt;(<span class=\"number\">2</span>, i, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>lvalue overload, n=2<br>lvalue overload, n=1<br>lvalue overload, n=3</p>\n<p>rvalue overload, n=2<br>lvalue overload, n=1<br>rvalue overload, n=3</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><mutex></h2><p>目前对于标准库的多线程没有使用的想法. 后面再说.</p>\n<p><a href=\"https://zh.cppreference.com/w/cpp/thread\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/thread</a></p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"\"></a></h2><h1 id=\"语言新特性\"><a href=\"#语言新特性\" class=\"headerlink\" title=\"语言新特性\"></a>语言新特性</h1><h2 id=\"Lambda\"><a href=\"#Lambda\" class=\"headerlink\" title=\"Lambda\"></a>Lambda</h2><p>参考资料<br><a href=\"https://zh.cppreference.com/w/cpp/language/lambda\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/language/lambda</a><br><a href=\"https://blog.csdn.net/qq_34199383/article/details/80469780\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_34199383/article/details/80469780</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ 捕获 ] ( 形参 ) -&gt; ret &#123; 函数体 &#125;</span><br><span class=\"line\">[ 捕获 ] ( 形参 ) &#123; 函数体 &#125;</span><br><span class=\"line\">[ 捕获 ] &#123; 函数体 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&amp; 以引用隐式捕获被使用的自动变量</span><br><span class=\"line\">= 以复制隐式捕获被使用的自动变量</span><br><span class=\"line\"></span><br><span class=\"line\">[&amp;]&#123;&#125;;          <span class=\"comment\">// OK：默认以引用捕获</span></span><br><span class=\"line\">[&amp;, i]&#123;&#125;;       <span class=\"comment\">// OK：以引用捕获，但 i 以值捕获</span></span><br><span class=\"line\"></span><br><span class=\"line\">[=]&#123;&#125;;          <span class=\"comment\">// OK：默认以复制捕获</span></span><br><span class=\"line\">[=, &amp;i]&#123;&#125;;      <span class=\"comment\">// OK：以复制捕获，但 i 以引用捕获</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">this</span>]&#123;&#125;; <span class=\"comment\">// 获取this指针, 如果使用了&amp;和=则会默认包括this</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用场景一</strong><br>以sort为代表的函数 需要传入函数的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原版</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;a, <span class=\"keyword\">int</span> &amp;b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a &gt; b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">xxx(compare);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新版</span></span><br><span class=\"line\">xxx([](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)&#123;<span class=\"keyword\">return</span> a &gt; b;&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>使用场景二</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> add = [](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)&#123;<span class=\"keyword\">return</span> a + b;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bar = add(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类型特性\"><a href=\"#类型特性\" class=\"headerlink\" title=\"类型特性\"></a>类型特性</h2><p><a href=\"https://zh.cppreference.com/w/cpp/types##.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/types##.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29</a></p>\n<p>神仙的头文件<type_traits> 可以判断一个值是否是某个类型</p>\n<p>比如判断一个值<br>是不是 整形<br>是不是 void<br>是不是 数组 等等</p>\n<p>目前不知道用在什么地方合适….. 留个连接备用吧</p>\n<h2 id=\"花括号初始\"><a href=\"#花括号初始\" class=\"headerlink\" title=\"花括号初始\"></a>花括号初始</h2><h2 id=\"函数对象\"><a href=\"#函数对象\" class=\"headerlink\" title=\"函数对象\"></a>函数对象</h2><h4 id=\"std-function-functional\"><a href=\"#std-function-functional\" class=\"headerlink\" title=\"std::function  functional\"></a>std::function  functional</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\">#<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintA</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintB</span><span class=\"params\">(<span class=\"keyword\">int</span> bar)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; FPrintA = PrintA;</span><br><span class=\"line\">    FPrintA();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>(<span class=\"keyword\">int</span>)&gt; FPrintB = PrintB;</span><br><span class=\"line\">    FPrintB(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 感觉配合Lambad 挺不错, 在一个函数中经常使用的功能可以这样定义</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; FLambad = []()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Lambad\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;;</span><br><span class=\"line\">    FLambad();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 不过使用auto貌似更简单</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> ALambad = []()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Lambad\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;;</span><br><span class=\"line\">    ALambad();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$ A</span><br><span class=\"line\">$ B</span><br><span class=\"line\">$ Lambad</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"std-bind-std-ref-std-cref\"><a href=\"#std-bind-std-ref-std-cref\" class=\"headerlink\" title=\"std::bind std::ref std::cref\"></a>std::bind std::ref std::cref</h4><p>今天在学习<br><a href=\"https://github.com/baloonwj/flamingo\" target=\"_blank\" rel=\"noopener\">https://github.com/baloonwj/flamingo</a><br>的时候, 从中发现的这个函数. 这个函数跟std::function 一起使用.<br>竟然实现了回调函数调用类的成员函数!!!!</p>\n<p><a href=\"https://zh.cppreference.com/w/cpp/utility/functional/bind\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/utility/functional/bind</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\">#<span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> n1, <span class=\"keyword\">int</span> n2, <span class=\"keyword\">int</span> n3, <span class=\"keyword\">int</span> n4)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"f function--&gt;n1: %d, n2: %d, n3: %d, n4: %d\\n\"</span>, n1, n2, n3, n4);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ff</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;n1, <span class=\"keyword\">int</span>&amp; n2, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; n3)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"before ff function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">    n1 = <span class=\"number\">11</span>;</span><br><span class=\"line\">    n2 = <span class=\"number\">22</span>;</span><br><span class=\"line\">    <span class=\"comment\">// n3 = 33; 编译错误</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"after ff function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f1 = <span class=\"built_in\">std</span>::bind(f, <span class=\"built_in\">std</span>::placeholders::_2, <span class=\"built_in\">std</span>::placeholders::_3, <span class=\"number\">666</span>, <span class=\"built_in\">std</span>::placeholders::_1);</span><br><span class=\"line\"></span><br><span class=\"line\">    f1(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"comment\">// infunction--&gt;n1: 2, n2: 3, n3: 666, n4: 1</span></span><br><span class=\"line\">    <span class=\"comment\">// 1 绑定_1  2绑定_2  3绑定_3   // 4 5被忽略</span></span><br><span class=\"line\">    <span class=\"comment\">// 按照 f1的顺序传入参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以调用为 f(2, 3, 666, 1);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n1 = <span class=\"number\">1</span>, n2 = <span class=\"number\">2</span>, n3 = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> ff1 = <span class=\"built_in\">std</span>::bind(ff, n1, <span class=\"built_in\">std</span>::ref(n2), <span class=\"built_in\">std</span>::cref(n3));</span><br><span class=\"line\">    n1 = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    n2 = <span class=\"number\">-2</span>;</span><br><span class=\"line\">    n3 = <span class=\"number\">-3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"before ff1 function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">    ff1(n1, n2, n3);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"after ff1 function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">    <span class=\"comment\">// before ff1 function--&gt;n1: -1, n2: -2, n3: -3</span></span><br><span class=\"line\">    <span class=\"comment\">// before ff function-- &gt; n1: 1, n2 : -2, n3 : -3 // 这里说明了值传递 参数是绑定时就决定好了 引用参数还是可以改变的</span></span><br><span class=\"line\">    <span class=\"comment\">// after ff function-- &gt; n1: 11, n2 : 22, n3 : -3</span></span><br><span class=\"line\">    <span class=\"comment\">// after ff1 function-- &gt; n1: -1, n2 : 22, n3 : -3 // 引用传入成功改变, 值传入和const引用传入未变</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// std::ref 按引用传入参数 std::cref按const引用传入参数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"std-pair-utility-std-tuple-tuple\"><a href=\"#std-pair-utility-std-tuple-tuple\" class=\"headerlink\" title=\"std::pair utility std::tuple tuple\"></a>std::pair utility std::tuple tuple</h4><p><a href=\"https://zh.cppreference.com/w/cpp/utility/tuple\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/utility/tuple</a></p>\n<p>pair是 结构体模板, 可在一个单元中存储两个相异对象. pair是tuple拥有两个元素的特殊情况</p>\n<p>tuple是固定大小的异类值(啥是异类值??)汇集</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::tuple&lt;int, double &gt; GetInfoById(int id)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (id == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::make_tuple(<span class=\"number\">1</span>, <span class=\"number\">1.1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (id == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::make_tuple(<span class=\"number\">2</span>, <span class=\"number\">2.2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::invalid_argument(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> info = GetInfoById(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 获取指定位置</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"1:\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">get</span>&lt;<span class=\"number\">0</span>&gt;(info)</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\" 2:\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">get</span>&lt;<span class=\"number\">1</span>&gt;(info) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val1;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> val2;</span><br><span class=\"line\">\t<span class=\"comment\">// 直接创建引用的tuple</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::tie(val1, val2) = GetInfoById(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"1:\"</span> &lt;&lt; val1</span><br><span class=\"line\">              &lt;&lt; <span class=\"string\">\" 2:\"</span> &lt;&lt; val2 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t\t  </span><br><span class=\"line\">$ <span class=\"number\">1</span>:<span class=\"number\">1</span> <span class=\"number\">2</span>:<span class=\"number\">1.1</span></span><br><span class=\"line\">$ <span class=\"number\">1</span>:<span class=\"number\">2</span> <span class=\"number\">2</span>:<span class=\"number\">2.2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"指针","date":"2019-11-07T14:26:22.000Z","_content":"\n指针的话, 自己是要学会自己去理解各种组合. 首先只要定义复杂指针肯定会涉及到运算符优先级\n根据运算符优先级判断这个定义的含义\n\n# 指针的定义识别\n## 由运算符优先级判断\n下面列出常见到的运算符\n\n`[]`中括号这个的优先级最高, 跟括号并列.(排除域运算符).\n\t从左到右的结合性 -意味着`p[]`中`[]`会先跟`p结合`而不是中括号右边的内容\n`()`与之结合成为函数\n\t从左到右的结合性\n`*`其次是这个符号\n\t从右到左的结合性\n\n两个大头\n`int *p[3]`和`int (*p)[3]`\n前者由于`[]`的优先级更高p与之结合说明p是**数组***得到p本质是什么 数组OR指针*\n再与`*`结合说明**数组中的元素**是**指针***第二次结合 如果第一次是数组-则为数组中的内容, 第一次是指针-则为指针的指向*\n再与int结合 说明数组中**指针指向**的是int\n\n后者`*`先与p结合说明p是一个**指针**\n再与`[]`结合说明**指针指向**的内容是**数组**\n再与int结合说明**数组中的内容**是int\n\n---\n本质上定义函数相关的也可以这样理解\n`int p(int)`和`int (*p)(int)`\n前者p先与`()`结合说明p是一个**函数**\n在**查看括号中的内容**说明有int的参数\n最后与左侧int结合说明返回类型\n\n后者p先与`*`结合说明p是一个**指针**\n与`()`结合说明**指针指向**的是**函数**\n在**查看括号中的内容**说明有int的参数\n最后与左侧int结合说明返回类型\n\n## 判断指针的类型\n去除指针声明语句中的指针名称, 剩下的部分就是指针的类型.\n`int* p`得到`int*`, 说明指针的类型是`int*`\n`int (*p)[3]` 说明指针的类型是`int (*)[3]`\n\n## 指针指向的类型\n去除指针声明语句中的指针名称, 以及名称左边的指针声明符*, 剩下的部分是指针指向的类型\n`int* p`得到`int`说明指针指向的类型就是`int`\n`int (*p)[3]`得到`int()[3]`说明指针指向的类型就是`int()[3]`\n\n## 指针的值\n指针存储的即为指向一个内存区域的地址值\n","source":"_posts/CPP-指针.md","raw":"---\ntitle: 指针\ntags:\n  - null\ncategories:\n  - CPP\ndate: 2019-11-07 22:26:22\n---\n\n指针的话, 自己是要学会自己去理解各种组合. 首先只要定义复杂指针肯定会涉及到运算符优先级\n根据运算符优先级判断这个定义的含义\n\n# 指针的定义识别\n## 由运算符优先级判断\n下面列出常见到的运算符\n\n`[]`中括号这个的优先级最高, 跟括号并列.(排除域运算符).\n\t从左到右的结合性 -意味着`p[]`中`[]`会先跟`p结合`而不是中括号右边的内容\n`()`与之结合成为函数\n\t从左到右的结合性\n`*`其次是这个符号\n\t从右到左的结合性\n\n两个大头\n`int *p[3]`和`int (*p)[3]`\n前者由于`[]`的优先级更高p与之结合说明p是**数组***得到p本质是什么 数组OR指针*\n再与`*`结合说明**数组中的元素**是**指针***第二次结合 如果第一次是数组-则为数组中的内容, 第一次是指针-则为指针的指向*\n再与int结合 说明数组中**指针指向**的是int\n\n后者`*`先与p结合说明p是一个**指针**\n再与`[]`结合说明**指针指向**的内容是**数组**\n再与int结合说明**数组中的内容**是int\n\n---\n本质上定义函数相关的也可以这样理解\n`int p(int)`和`int (*p)(int)`\n前者p先与`()`结合说明p是一个**函数**\n在**查看括号中的内容**说明有int的参数\n最后与左侧int结合说明返回类型\n\n后者p先与`*`结合说明p是一个**指针**\n与`()`结合说明**指针指向**的是**函数**\n在**查看括号中的内容**说明有int的参数\n最后与左侧int结合说明返回类型\n\n## 判断指针的类型\n去除指针声明语句中的指针名称, 剩下的部分就是指针的类型.\n`int* p`得到`int*`, 说明指针的类型是`int*`\n`int (*p)[3]` 说明指针的类型是`int (*)[3]`\n\n## 指针指向的类型\n去除指针声明语句中的指针名称, 以及名称左边的指针声明符*, 剩下的部分是指针指向的类型\n`int* p`得到`int`说明指针指向的类型就是`int`\n`int (*p)[3]`得到`int()[3]`说明指针指向的类型就是`int()[3]`\n\n## 指针的值\n指针存储的即为指向一个内存区域的地址值\n","slug":"CPP-指针","published":1,"updated":"2020-12-05T02:26:20.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg5t0005f8un9dkneo7a","content":"<p>指针的话, 自己是要学会自己去理解各种组合. 首先只要定义复杂指针肯定会涉及到运算符优先级<br>根据运算符优先级判断这个定义的含义</p>\n<h1 id=\"指针的定义识别\"><a href=\"#指针的定义识别\" class=\"headerlink\" title=\"指针的定义识别\"></a>指针的定义识别</h1><h2 id=\"由运算符优先级判断\"><a href=\"#由运算符优先级判断\" class=\"headerlink\" title=\"由运算符优先级判断\"></a>由运算符优先级判断</h2><p>下面列出常见到的运算符</p>\n<p><code>[]</code>中括号这个的优先级最高, 跟括号并列.(排除域运算符).<br>    从左到右的结合性 -意味着<code>p[]</code>中<code>[]</code>会先跟<code>p结合</code>而不是中括号右边的内容<br><code>()</code>与之结合成为函数<br>    从左到右的结合性<br><code>*</code>其次是这个符号<br>    从右到左的结合性</p>\n<p>两个大头<br><code>int *p[3]</code>和<code>int (*p)[3]</code><br>前者由于<code>[]</code>的优先级更高p与之结合说明p是<strong>数组*</strong>得到p本质是什么 数组OR指针*<br>再与<code>*</code>结合说明<strong>数组中的元素</strong>是<strong>指针*</strong>第二次结合 如果第一次是数组-则为数组中的内容, 第一次是指针-则为指针的指向*<br>再与int结合 说明数组中<strong>指针指向</strong>的是int</p>\n<p>后者<code>*</code>先与p结合说明p是一个<strong>指针</strong><br>再与<code>[]</code>结合说明<strong>指针指向</strong>的内容是<strong>数组</strong><br>再与int结合说明<strong>数组中的内容</strong>是int</p>\n<hr>\n<p>本质上定义函数相关的也可以这样理解<br><code>int p(int)</code>和<code>int (*p)(int)</code><br>前者p先与<code>()</code>结合说明p是一个<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p>\n<p>后者p先与<code>*</code>结合说明p是一个<strong>指针</strong><br>与<code>()</code>结合说明<strong>指针指向</strong>的是<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p>\n<h2 id=\"判断指针的类型\"><a href=\"#判断指针的类型\" class=\"headerlink\" title=\"判断指针的类型\"></a>判断指针的类型</h2><p>去除指针声明语句中的指针名称, 剩下的部分就是指针的类型.<br><code>int* p</code>得到<code>int*</code>, 说明指针的类型是<code>int*</code><br><code>int (*p)[3]</code> 说明指针的类型是<code>int (*)[3]</code></p>\n<h2 id=\"指针指向的类型\"><a href=\"#指针指向的类型\" class=\"headerlink\" title=\"指针指向的类型\"></a>指针指向的类型</h2><p>去除指针声明语句中的指针名称, 以及名称左边的指针声明符<em>, 剩下的部分是指针指向的类型<br>`int</em> p<code>得到</code>int<code>说明指针指向的类型就是</code>int<code></code>int (*p)[3]<code>得到</code>int()[3]<code>说明指针指向的类型就是</code>int()[3]`</p>\n<h2 id=\"指针的值\"><a href=\"#指针的值\" class=\"headerlink\" title=\"指针的值\"></a>指针的值</h2><p>指针存储的即为指向一个内存区域的地址值</p>\n","site":{"data":{}},"excerpt":"","more":"<p>指针的话, 自己是要学会自己去理解各种组合. 首先只要定义复杂指针肯定会涉及到运算符优先级<br>根据运算符优先级判断这个定义的含义</p>\n<h1 id=\"指针的定义识别\"><a href=\"#指针的定义识别\" class=\"headerlink\" title=\"指针的定义识别\"></a>指针的定义识别</h1><h2 id=\"由运算符优先级判断\"><a href=\"#由运算符优先级判断\" class=\"headerlink\" title=\"由运算符优先级判断\"></a>由运算符优先级判断</h2><p>下面列出常见到的运算符</p>\n<p><code>[]</code>中括号这个的优先级最高, 跟括号并列.(排除域运算符).<br>    从左到右的结合性 -意味着<code>p[]</code>中<code>[]</code>会先跟<code>p结合</code>而不是中括号右边的内容<br><code>()</code>与之结合成为函数<br>    从左到右的结合性<br><code>*</code>其次是这个符号<br>    从右到左的结合性</p>\n<p>两个大头<br><code>int *p[3]</code>和<code>int (*p)[3]</code><br>前者由于<code>[]</code>的优先级更高p与之结合说明p是<strong>数组*</strong>得到p本质是什么 数组OR指针*<br>再与<code>*</code>结合说明<strong>数组中的元素</strong>是<strong>指针*</strong>第二次结合 如果第一次是数组-则为数组中的内容, 第一次是指针-则为指针的指向*<br>再与int结合 说明数组中<strong>指针指向</strong>的是int</p>\n<p>后者<code>*</code>先与p结合说明p是一个<strong>指针</strong><br>再与<code>[]</code>结合说明<strong>指针指向</strong>的内容是<strong>数组</strong><br>再与int结合说明<strong>数组中的内容</strong>是int</p>\n<hr>\n<p>本质上定义函数相关的也可以这样理解<br><code>int p(int)</code>和<code>int (*p)(int)</code><br>前者p先与<code>()</code>结合说明p是一个<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p>\n<p>后者p先与<code>*</code>结合说明p是一个<strong>指针</strong><br>与<code>()</code>结合说明<strong>指针指向</strong>的是<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p>\n<h2 id=\"判断指针的类型\"><a href=\"#判断指针的类型\" class=\"headerlink\" title=\"判断指针的类型\"></a>判断指针的类型</h2><p>去除指针声明语句中的指针名称, 剩下的部分就是指针的类型.<br><code>int* p</code>得到<code>int*</code>, 说明指针的类型是<code>int*</code><br><code>int (*p)[3]</code> 说明指针的类型是<code>int (*)[3]</code></p>\n<h2 id=\"指针指向的类型\"><a href=\"#指针指向的类型\" class=\"headerlink\" title=\"指针指向的类型\"></a>指针指向的类型</h2><p>去除指针声明语句中的指针名称, 以及名称左边的指针声明符<em>, 剩下的部分是指针指向的类型<br>`int</em> p<code>得到</code>int<code>说明指针指向的类型就是</code>int<code></code>int (*p)[3]<code>得到</code>int()[3]<code>说明指针指向的类型就是</code>int()[3]`</p>\n<h2 id=\"指针的值\"><a href=\"#指针的值\" class=\"headerlink\" title=\"指针的值\"></a>指针的值</h2><p>指针存储的即为指向一个内存区域的地址值</p>\n"},{"title":"定义与声明详解","date":"2020-02-27T02:38:08.000Z","_content":"# 变量声明和变量定义\n\n变量声明: 用于向程序表明变量的类型和名字\n变量定义: 用于为变量*分配存储空间*, 同时可为变量指定初始值\n\n定义时会自动声明, 变量只能被定义一次, 却可以声明多次\nextern声明不是定义\n\n```c++\nextern int i; // 声明i 但没有定义i\nint i; // 定义且声明i\n\nextern int i = 10; // 定义并声明\n\n// 如果再函数体内部试图初始化一个由extern标记的变量,会引发错误\n```\n\n# extern\n只有extern声明位于函数外部的时候,才能被初始化\n\n**在C++中 可以用来声明全局变量**\n```c++\n// file1.cpp\nint global_int = 1;\n\n// file2.cpp\nextern int global_int;\n// 后面可以直接使用 global_int, 因为他在其他地方定义了\n```","source":"_posts/CPP-定义与声明详解.md","raw":"---\ntitle: 定义与声明详解\ndate: 2020-02-27 10:38:08\ntags:\ncategories:\n - CPP\n---\n# 变量声明和变量定义\n\n变量声明: 用于向程序表明变量的类型和名字\n变量定义: 用于为变量*分配存储空间*, 同时可为变量指定初始值\n\n定义时会自动声明, 变量只能被定义一次, 却可以声明多次\nextern声明不是定义\n\n```c++\nextern int i; // 声明i 但没有定义i\nint i; // 定义且声明i\n\nextern int i = 10; // 定义并声明\n\n// 如果再函数体内部试图初始化一个由extern标记的变量,会引发错误\n```\n\n# extern\n只有extern声明位于函数外部的时候,才能被初始化\n\n**在C++中 可以用来声明全局变量**\n```c++\n// file1.cpp\nint global_int = 1;\n\n// file2.cpp\nextern int global_int;\n// 后面可以直接使用 global_int, 因为他在其他地方定义了\n```","slug":"CPP-定义与声明详解","published":1,"updated":"2020-12-05T02:26:20.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg5v0007f8un18qveu5o","content":"<h1 id=\"变量声明和变量定义\"><a href=\"#变量声明和变量定义\" class=\"headerlink\" title=\"变量声明和变量定义\"></a>变量声明和变量定义</h1><p>变量声明: 用于向程序表明变量的类型和名字<br>变量定义: 用于为变量<em>分配存储空间</em>, 同时可为变量指定初始值</p>\n<p>定义时会自动声明, 变量只能被定义一次, 却可以声明多次<br>extern声明不是定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// 声明i 但没有定义i</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i; <span class=\"comment\">// 定义且声明i</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i = <span class=\"number\">10</span>; <span class=\"comment\">// 定义并声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果再函数体内部试图初始化一个由extern标记的变量,会引发错误</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"extern\"><a href=\"#extern\" class=\"headerlink\" title=\"extern\"></a>extern</h1><p>只有extern声明位于函数外部的时候,才能被初始化</p>\n<p><strong>在C++中 可以用来声明全局变量</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file1.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> global_int = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// file2.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> global_int;</span><br><span class=\"line\"><span class=\"comment\">// 后面可以直接使用 global_int, 因为他在其他地方定义了</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"变量声明和变量定义\"><a href=\"#变量声明和变量定义\" class=\"headerlink\" title=\"变量声明和变量定义\"></a>变量声明和变量定义</h1><p>变量声明: 用于向程序表明变量的类型和名字<br>变量定义: 用于为变量<em>分配存储空间</em>, 同时可为变量指定初始值</p>\n<p>定义时会自动声明, 变量只能被定义一次, 却可以声明多次<br>extern声明不是定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// 声明i 但没有定义i</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i; <span class=\"comment\">// 定义且声明i</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i = <span class=\"number\">10</span>; <span class=\"comment\">// 定义并声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果再函数体内部试图初始化一个由extern标记的变量,会引发错误</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"extern\"><a href=\"#extern\" class=\"headerlink\" title=\"extern\"></a>extern</h1><p>只有extern声明位于函数外部的时候,才能被初始化</p>\n<p><strong>在C++中 可以用来声明全局变量</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file1.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> global_int = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// file2.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> global_int;</span><br><span class=\"line\"><span class=\"comment\">// 后面可以直接使用 global_int, 因为他在其他地方定义了</span></span><br></pre></td></tr></table></figure>"},{"title":"Jsoncpp代码阅读","date":"2020-03-01T02:26:55.000Z","img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/Jsoncpp%E5%B0%81%E9%9D%A2.png","_content":"```c++\nJson::Value root;\nroot[\"action\"] = \"run\";\n```\n首先是 `[]运算符重载` , 统一不同的重载类型\n调用`resolveReference()`进行统一的添加`k`操作\n\n首先会进行 校验参数, 然后将key封装成一个对象CZString (封装过程为将传入指针保存到 CZString对象中的cstr_)\n封装完成后再保存`k v`的`map<CZString, Value>`中查找有无相同的CZString(key)有的话返回Value引用,\n没有则创建新的<CZStrng, 空Value>存入map并返回Value的引用\n\n然后是`=运算符重载`, \"run\"自动转换成Value对象\n转换过程中, 通过`duplicateAndPrefixStringValue()`将\"run\"进行了封装 \n`char* string_; // if allocated_, ptr to { unsigned, char[] }.`\n将长度封装到了一个char指针中, 有点类似自己设计tcp协议...\n\n`=运算符重载`函数将`[]运算符重载`返回的对象引用 中的相关值`swap()`成新的Value对象中的相关值\n\n到这里理解了在Jsoncpp中 一切都是Value 包括<K, V>键值对也是在Value对象中存储\n每一个<k, v>都可以作为一个Value对象, 这样既实现了复杂嵌套Json中 v为对象的情况 妙啊\n\n```c++\n// 每个Value对象中都维护一个union\nunion ValueHolder {\n    LargestInt int_;\n    LargestUInt uint_;\n    double real_;\n    bool bool_;\n    char* string_; // if allocated_, ptr to { unsigned, char[] }.\n\n    // 将所有的存贮着key的CZString保存起来\n\t//  typedef std::map<CZString, Value> ObjectValues; // std::map<CZString, Value> 键值对\n    ObjectValues* map_;\n  } value_;\n```\n\n下面的switch的这个type 会在很多地方被修改掉.\n起初 使用默认构造函数的value type是nullxxx\n然后调用`[]运算符重载`的时候会修改掉 type 为 objectValue\n\n```c++\n// 递归调用 进行处理\nvoid BuiltStyledStreamWriter::writeValue(Value const& value) {\n  switch (value.type()) {\n  case nullValue:\n    pushValue(nullSymbol_);\n    break;\n  case intValue:\n    pushValue(valueToString(value.asLargestInt()));\n    break;\n  case uintValue:\n    pushValue(valueToString(value.asLargestUInt()));\n    break;\n  case realValue:\n    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,\n                            precisionType_));\n    break;\n  case stringValue: {\n    // Is NULL is possible for value.string_? No.\n    char const* str;\n    char const* end;\n    bool ok = value.getString(&str, &end);\n    if (ok)\n      pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end - str),\n                                     emitUTF8_));\n    else\n      pushValue(\"\");\n    break;\n  }\n  case booleanValue:\n    pushValue(valueToString(value.asBool()));\n    break;\n  case arrayValue:\n    writeArrayValue(value);\n    break;\n  case objectValue: {\n    Value::Members members(value.getMemberNames());\n    if (members.empty())\n      pushValue(\"{}\");\n    else {\n      writeWithIndent(\"{\");\n      indent();\n      auto it = members.begin();\n      for (;;) {\n        String const& name = *it;\n        Value const& childValue = value[name];\n        writeCommentBeforeValue(childValue);\n        writeWithIndent(valueToQuotedStringN(\n            name.data(), static_cast<unsigned>(name.length()), emitUTF8_));\n\n        // :\n        *sout_ << colonSymbol_;\n        writeValue(childValue);\n        if (++it == members.end()) {\n          writeCommentAfterValueOnSameLine(childValue);\n          break;\n        }\n        *sout_ << \",\";\n        writeCommentAfterValueOnSameLine(childValue);\n      }\n      unindent();\n      writeWithIndent(\"}\");\n    }\n  } break;\n  }\n}\n```\n\n这次是根据下面的例子分析的\n```c++\nint main() {\n  Json::Value root;\n  Json::Value data;\n  constexpr bool shouldUseOldWay = false;\n\n  // 左侧返回Value的引用\n  root[\"action\"] = \"run\";\n  data[\"number\"] = 1;\n  root[\"data\"] = data;\n\n  if (shouldUseOldWay) {\n    Json::FastWriter writer;\n    const std::string json_file = writer.write(root);\n    std::cout << json_file << std::endl;\n  } else {\n    // 配置文件也是Value对象, 我用我自己.jpg\n    Json::StreamWriterBuilder builder;\n    const std::string json_file = Json::writeString(builder, root);\n    std::cout << json_file << std::endl;\n  }\n  return EXIT_SUCCESS;\n}\n```\n\n算是了解到了这个库的大概工作流程了. 能学到的部分 吃完午饭继续写.\n吃完饭试了试家里的显示器, 家里的显示器还是太老了...... 八年的显示器了 看得我眼花\n还是继续用笔记本吧\n\n1. 首先我很喜欢这种运算符重载的使用形式, 用起来非常的舒服, 需要重载两个运算符 `[]`和`=` 而且\n`=运算符`重载使用的swap交换需要的属性, 感觉不错\n(后来我看了EffectiveC++ 发现这是`=运算符处理自我赋值`太巧了)\n\n2. 针对需要加载配置文件的类 使用了工厂模式\n3. writeValue使用了递归处理.\n4. 统一处理, k v都是Value对象\n5. 将用户的string 拷贝到新的`char*`中 同时在开头增加了长度, 尾部补了0, 没有使用额外的变量去存储`char*`的长度\n不太清楚这样做有什么好处\n6. 常量全部用的 `static constexpr`修饰\n7. 恰当的对象嵌套\n\n\n----\n\n看完了从 Value到Json 接下来看看从Json到Value\n\n```c++\nint main() {\n  const std::string rawJson = R\"({\"Age\": 20, \"Name\": \"colin\"})\";\n  const auto rawJsonLength = static_cast<int>(rawJson.length());\n  constexpr bool shouldUseOldWay = false;\n  JSONCPP_STRING err;\n  Json::Value root;\n\n  if (shouldUseOldWay) {\n    Json::Reader reader;\n    reader.parse(rawJson, root);\n  } else {\n      // 默认构造函数 使用默认的配置\n    Json::CharReaderBuilder builder;\n\n    // 根据builder的配置生成CharReader类\n    const std::unique_ptr<Json::CharReader> reader(builder.newCharReader());\n    if (!reader->parse(rawJson.c_str(), rawJson.c_str() + rawJsonLength, &root,\n                       &err)) {\n      std::cout << \"error\" << std::endl;\n      return EXIT_FAILURE;\n    }\n  }\n  const std::string name = root[\"Name\"].asString();\n  const int age = root[\"Age\"].asInt();\n\n  std::cout << name << std::endl;\n  std::cout << age << std::endl;\n  return EXIT_SUCCESS;\n}\n```\n\n解析的关键在于`parse()`函数 传入字符串的首尾指针, 和一个Value引用\n进入函数后将传入的变量保存到了自己的成员变量中.\n\n慢慢发现 这个库将很多的默认类型 起了别名 可能是为了统一类型 类似UE4也是自己搞了一套\n\n主要是`OurReader`这个负责解析\n```c++\n// 使用了大量的using\nusing Char = char;\nusing Location = const Char*;\n```\n\n解析逻辑就是`parse()`调用`readValue()`\n`readValue()`负责 获取下一次数据类型type_ ->switch(type_) 根据分支决定是否递归再次调用`readValue`\n总算把逻辑看懂了, 代码依然认为很赞\n`readToken()`这个函数贯穿整个解析, 通过这个函数获取到下一次的数据是什么类型, 同时移动相关的状态指针\n`readToken()` 内部大量调用下面的函数 修改当前指针 同时返回字符, 然后switch这个字符判断下一次的数据类型\n比如遇到`{`就是一个对象的开始设置好type并返回 遇到`}`就是对象的结束.....\n```c++\n// 获取current_指向的字符 并自增\nOurReader::Char OurReader::getNextChar()\n{\n  if (current_ == end_)\n    return 0;\n  return *current_++;\n}\n```\n\n一般第一次调用type_会被设置为对象类型, 然后`readValue()`进入`case 对象分支`\n`case对象分支中`\n先进行了一次`readToken()`获取到了k的类型, 然后根据k类型分支 将k的值转换成对应的value\n之后又是一次`readToken()`判断是否存在`:`不存在就是错误\n在之后使用这个方法, 保存`k`的vallue获取`v`的value再次调用`readValue()`填充值 返回后继续走\n```c++\n// 这里保存了name 这个k 将name的 v放入了顶层\nValue& value = currentValue()[name];\nnodes_.push(&value);\nbool ok = readValue();\n```\n读取完`v`的value之后必定是`,`或者`}`又是一次判断 成功判断后一个`k v`就获取完毕了\n\n` using Nodes = std::stack<Value*>`\n后面解析的代码更加的妙不可言, 使用`Nodes nodes_{}`存储当前的value 实现函数之间的操作\n\n代码合理的组织\n比如`case 对象分支`必定是一个`k`一个`:`一个`v` 然后一个分隔符`,`或`}` 这些放入了一个函数\n\n然后获取到`k`之后使用`Value& value = currentValue()[name]`获取`v`\n\n最后依然是递归的使用","source":"_posts/CPP-源码学习-Jsoncpp代码阅读.md","raw":"---\ntitle: Jsoncpp代码阅读\ndate: 2020-03-01 10:26:55\ntags:\ncategories:\n - CPP\n - 源码学习\n \nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/Jsoncpp%E5%B0%81%E9%9D%A2.png\n---\n```c++\nJson::Value root;\nroot[\"action\"] = \"run\";\n```\n首先是 `[]运算符重载` , 统一不同的重载类型\n调用`resolveReference()`进行统一的添加`k`操作\n\n首先会进行 校验参数, 然后将key封装成一个对象CZString (封装过程为将传入指针保存到 CZString对象中的cstr_)\n封装完成后再保存`k v`的`map<CZString, Value>`中查找有无相同的CZString(key)有的话返回Value引用,\n没有则创建新的<CZStrng, 空Value>存入map并返回Value的引用\n\n然后是`=运算符重载`, \"run\"自动转换成Value对象\n转换过程中, 通过`duplicateAndPrefixStringValue()`将\"run\"进行了封装 \n`char* string_; // if allocated_, ptr to { unsigned, char[] }.`\n将长度封装到了一个char指针中, 有点类似自己设计tcp协议...\n\n`=运算符重载`函数将`[]运算符重载`返回的对象引用 中的相关值`swap()`成新的Value对象中的相关值\n\n到这里理解了在Jsoncpp中 一切都是Value 包括<K, V>键值对也是在Value对象中存储\n每一个<k, v>都可以作为一个Value对象, 这样既实现了复杂嵌套Json中 v为对象的情况 妙啊\n\n```c++\n// 每个Value对象中都维护一个union\nunion ValueHolder {\n    LargestInt int_;\n    LargestUInt uint_;\n    double real_;\n    bool bool_;\n    char* string_; // if allocated_, ptr to { unsigned, char[] }.\n\n    // 将所有的存贮着key的CZString保存起来\n\t//  typedef std::map<CZString, Value> ObjectValues; // std::map<CZString, Value> 键值对\n    ObjectValues* map_;\n  } value_;\n```\n\n下面的switch的这个type 会在很多地方被修改掉.\n起初 使用默认构造函数的value type是nullxxx\n然后调用`[]运算符重载`的时候会修改掉 type 为 objectValue\n\n```c++\n// 递归调用 进行处理\nvoid BuiltStyledStreamWriter::writeValue(Value const& value) {\n  switch (value.type()) {\n  case nullValue:\n    pushValue(nullSymbol_);\n    break;\n  case intValue:\n    pushValue(valueToString(value.asLargestInt()));\n    break;\n  case uintValue:\n    pushValue(valueToString(value.asLargestUInt()));\n    break;\n  case realValue:\n    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,\n                            precisionType_));\n    break;\n  case stringValue: {\n    // Is NULL is possible for value.string_? No.\n    char const* str;\n    char const* end;\n    bool ok = value.getString(&str, &end);\n    if (ok)\n      pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end - str),\n                                     emitUTF8_));\n    else\n      pushValue(\"\");\n    break;\n  }\n  case booleanValue:\n    pushValue(valueToString(value.asBool()));\n    break;\n  case arrayValue:\n    writeArrayValue(value);\n    break;\n  case objectValue: {\n    Value::Members members(value.getMemberNames());\n    if (members.empty())\n      pushValue(\"{}\");\n    else {\n      writeWithIndent(\"{\");\n      indent();\n      auto it = members.begin();\n      for (;;) {\n        String const& name = *it;\n        Value const& childValue = value[name];\n        writeCommentBeforeValue(childValue);\n        writeWithIndent(valueToQuotedStringN(\n            name.data(), static_cast<unsigned>(name.length()), emitUTF8_));\n\n        // :\n        *sout_ << colonSymbol_;\n        writeValue(childValue);\n        if (++it == members.end()) {\n          writeCommentAfterValueOnSameLine(childValue);\n          break;\n        }\n        *sout_ << \",\";\n        writeCommentAfterValueOnSameLine(childValue);\n      }\n      unindent();\n      writeWithIndent(\"}\");\n    }\n  } break;\n  }\n}\n```\n\n这次是根据下面的例子分析的\n```c++\nint main() {\n  Json::Value root;\n  Json::Value data;\n  constexpr bool shouldUseOldWay = false;\n\n  // 左侧返回Value的引用\n  root[\"action\"] = \"run\";\n  data[\"number\"] = 1;\n  root[\"data\"] = data;\n\n  if (shouldUseOldWay) {\n    Json::FastWriter writer;\n    const std::string json_file = writer.write(root);\n    std::cout << json_file << std::endl;\n  } else {\n    // 配置文件也是Value对象, 我用我自己.jpg\n    Json::StreamWriterBuilder builder;\n    const std::string json_file = Json::writeString(builder, root);\n    std::cout << json_file << std::endl;\n  }\n  return EXIT_SUCCESS;\n}\n```\n\n算是了解到了这个库的大概工作流程了. 能学到的部分 吃完午饭继续写.\n吃完饭试了试家里的显示器, 家里的显示器还是太老了...... 八年的显示器了 看得我眼花\n还是继续用笔记本吧\n\n1. 首先我很喜欢这种运算符重载的使用形式, 用起来非常的舒服, 需要重载两个运算符 `[]`和`=` 而且\n`=运算符`重载使用的swap交换需要的属性, 感觉不错\n(后来我看了EffectiveC++ 发现这是`=运算符处理自我赋值`太巧了)\n\n2. 针对需要加载配置文件的类 使用了工厂模式\n3. writeValue使用了递归处理.\n4. 统一处理, k v都是Value对象\n5. 将用户的string 拷贝到新的`char*`中 同时在开头增加了长度, 尾部补了0, 没有使用额外的变量去存储`char*`的长度\n不太清楚这样做有什么好处\n6. 常量全部用的 `static constexpr`修饰\n7. 恰当的对象嵌套\n\n\n----\n\n看完了从 Value到Json 接下来看看从Json到Value\n\n```c++\nint main() {\n  const std::string rawJson = R\"({\"Age\": 20, \"Name\": \"colin\"})\";\n  const auto rawJsonLength = static_cast<int>(rawJson.length());\n  constexpr bool shouldUseOldWay = false;\n  JSONCPP_STRING err;\n  Json::Value root;\n\n  if (shouldUseOldWay) {\n    Json::Reader reader;\n    reader.parse(rawJson, root);\n  } else {\n      // 默认构造函数 使用默认的配置\n    Json::CharReaderBuilder builder;\n\n    // 根据builder的配置生成CharReader类\n    const std::unique_ptr<Json::CharReader> reader(builder.newCharReader());\n    if (!reader->parse(rawJson.c_str(), rawJson.c_str() + rawJsonLength, &root,\n                       &err)) {\n      std::cout << \"error\" << std::endl;\n      return EXIT_FAILURE;\n    }\n  }\n  const std::string name = root[\"Name\"].asString();\n  const int age = root[\"Age\"].asInt();\n\n  std::cout << name << std::endl;\n  std::cout << age << std::endl;\n  return EXIT_SUCCESS;\n}\n```\n\n解析的关键在于`parse()`函数 传入字符串的首尾指针, 和一个Value引用\n进入函数后将传入的变量保存到了自己的成员变量中.\n\n慢慢发现 这个库将很多的默认类型 起了别名 可能是为了统一类型 类似UE4也是自己搞了一套\n\n主要是`OurReader`这个负责解析\n```c++\n// 使用了大量的using\nusing Char = char;\nusing Location = const Char*;\n```\n\n解析逻辑就是`parse()`调用`readValue()`\n`readValue()`负责 获取下一次数据类型type_ ->switch(type_) 根据分支决定是否递归再次调用`readValue`\n总算把逻辑看懂了, 代码依然认为很赞\n`readToken()`这个函数贯穿整个解析, 通过这个函数获取到下一次的数据是什么类型, 同时移动相关的状态指针\n`readToken()` 内部大量调用下面的函数 修改当前指针 同时返回字符, 然后switch这个字符判断下一次的数据类型\n比如遇到`{`就是一个对象的开始设置好type并返回 遇到`}`就是对象的结束.....\n```c++\n// 获取current_指向的字符 并自增\nOurReader::Char OurReader::getNextChar()\n{\n  if (current_ == end_)\n    return 0;\n  return *current_++;\n}\n```\n\n一般第一次调用type_会被设置为对象类型, 然后`readValue()`进入`case 对象分支`\n`case对象分支中`\n先进行了一次`readToken()`获取到了k的类型, 然后根据k类型分支 将k的值转换成对应的value\n之后又是一次`readToken()`判断是否存在`:`不存在就是错误\n在之后使用这个方法, 保存`k`的vallue获取`v`的value再次调用`readValue()`填充值 返回后继续走\n```c++\n// 这里保存了name 这个k 将name的 v放入了顶层\nValue& value = currentValue()[name];\nnodes_.push(&value);\nbool ok = readValue();\n```\n读取完`v`的value之后必定是`,`或者`}`又是一次判断 成功判断后一个`k v`就获取完毕了\n\n` using Nodes = std::stack<Value*>`\n后面解析的代码更加的妙不可言, 使用`Nodes nodes_{}`存储当前的value 实现函数之间的操作\n\n代码合理的组织\n比如`case 对象分支`必定是一个`k`一个`:`一个`v` 然后一个分隔符`,`或`}` 这些放入了一个函数\n\n然后获取到`k`之后使用`Value& value = currentValue()[name]`获取`v`\n\n最后依然是递归的使用","slug":"CPP-源码学习-Jsoncpp代码阅读","published":1,"updated":"2020-03-04T07:52:44.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg5x0008f8un1ec504jr","content":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Json::Value root;</span><br><span class=\"line\">root[<span class=\"string\">\"action\"</span>] = <span class=\"string\">\"run\"</span>;</span><br></pre></td></tr></table></figure>\n<p>首先是 <code>[]运算符重载</code> , 统一不同的重载类型<br>调用<code>resolveReference()</code>进行统一的添加<code>k</code>操作</p>\n<p>首先会进行 校验参数, 然后将key封装成一个对象CZString (封装过程为将传入指针保存到 CZString对象中的cstr_)<br>封装完成后再保存<code>k v</code>的<code>map&lt;CZString, Value&gt;</code>中查找有无相同的CZString(key)有的话返回Value引用,<br>没有则创建新的&lt;CZStrng, 空Value&gt;存入map并返回Value的引用</p>\n<p>然后是<code>=运算符重载</code>, “run”自动转换成Value对象<br>转换过程中, 通过<code>duplicateAndPrefixStringValue()</code>将”run”进行了封装<br><code>char* string_; // if allocated_, ptr to { unsigned, char[] }.</code><br>将长度封装到了一个char指针中, 有点类似自己设计tcp协议…</p>\n<p><code>=运算符重载</code>函数将<code>[]运算符重载</code>返回的对象引用 中的相关值<code>swap()</code>成新的Value对象中的相关值</p>\n<p>到这里理解了在Jsoncpp中 一切都是Value 包括&lt;K, V&gt;键值对也是在Value对象中存储<br>每一个&lt;k, v&gt;都可以作为一个Value对象, 这样既实现了复杂嵌套Json中 v为对象的情况 妙啊</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每个Value对象中都维护一个union</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> ValueHolder &#123;</span><br><span class=\"line\">    LargestInt int_;</span><br><span class=\"line\">    LargestUInt uint_;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> real_;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> bool_;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* string_; <span class=\"comment\">// if allocated_, ptr to &#123; unsigned, char[] &#125;.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将所有的存贮着key的CZString保存起来</span></span><br><span class=\"line\">\t<span class=\"comment\">//  typedef std::map&lt;CZString, Value&gt; ObjectValues; // std::map&lt;CZString, Value&gt; 键值对</span></span><br><span class=\"line\">    ObjectValues* map_;</span><br><span class=\"line\">  &#125; value_;</span><br></pre></td></tr></table></figure>\n\n<p>下面的switch的这个type 会在很多地方被修改掉.<br>起初 使用默认构造函数的value type是nullxxx<br>然后调用<code>[]运算符重载</code>的时候会修改掉 type 为 objectValue</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 递归调用 进行处理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BuiltStyledStreamWriter::writeValue</span><span class=\"params\">(Value <span class=\"keyword\">const</span>&amp; value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (value.type()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> nullValue:</span><br><span class=\"line\">    pushValue(nullSymbol_);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> intValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asLargestInt()));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> uintValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asLargestUInt()));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> realValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,</span><br><span class=\"line\">                            precisionType_));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> stringValue: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Is NULL is possible for value.string_? No.</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>* str;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>* <span class=\"built_in\">end</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ok = value.getString(&amp;str, &amp;<span class=\"built_in\">end</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ok)</span><br><span class=\"line\">      pushValue(valueToQuotedStringN(str, <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">unsigned</span>&gt;(<span class=\"built_in\">end</span> - str),</span><br><span class=\"line\">                                     emitUTF8_));</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      pushValue(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> booleanValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asBool()));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> arrayValue:</span><br><span class=\"line\">    writeArrayValue(value);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> objectValue: &#123;</span><br><span class=\"line\">    <span class=\"function\">Value::Members <span class=\"title\">members</span><span class=\"params\">(value.getMemberNames())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (members.empty())</span><br><span class=\"line\">      pushValue(<span class=\"string\">\"&#123;&#125;\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      writeWithIndent(<span class=\"string\">\"&#123;\"</span>);</span><br><span class=\"line\">      indent();</span><br><span class=\"line\">      <span class=\"keyword\">auto</span> it = members.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> <span class=\"keyword\">const</span>&amp; name = *it;</span><br><span class=\"line\">        Value <span class=\"keyword\">const</span>&amp; childValue = value[name];</span><br><span class=\"line\">        writeCommentBeforeValue(childValue);</span><br><span class=\"line\">        writeWithIndent(valueToQuotedStringN(</span><br><span class=\"line\">            name.data(), <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">unsigned</span>&gt;(name.length()), emitUTF8_));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// :</span></span><br><span class=\"line\">        *sout_ &lt;&lt; colonSymbol_;</span><br><span class=\"line\">        writeValue(childValue);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++it == members.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">          writeCommentAfterValueOnSameLine(childValue);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        *sout_ &lt;&lt; <span class=\"string\">\",\"</span>;</span><br><span class=\"line\">        writeCommentAfterValueOnSameLine(childValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      unindent();</span><br><span class=\"line\">      writeWithIndent(<span class=\"string\">\"&#125;\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这次是根据下面的例子分析的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Json::Value root;</span><br><span class=\"line\">  Json::Value data;</span><br><span class=\"line\">  <span class=\"keyword\">constexpr</span> <span class=\"keyword\">bool</span> shouldUseOldWay = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 左侧返回Value的引用</span></span><br><span class=\"line\">  root[<span class=\"string\">\"action\"</span>] = <span class=\"string\">\"run\"</span>;</span><br><span class=\"line\">  data[<span class=\"string\">\"number\"</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  root[<span class=\"string\">\"data\"</span>] = data;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldUseOldWay) &#123;</span><br><span class=\"line\">    Json::FastWriter writer;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> json_file = writer.<span class=\"built_in\">write</span>(root);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; json_file &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 配置文件也是Value对象, 我用我自己.jpg</span></span><br><span class=\"line\">    Json::StreamWriterBuilder builder;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> json_file = Json::writeString(builder, root);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; json_file &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>算是了解到了这个库的大概工作流程了. 能学到的部分 吃完午饭继续写.<br>吃完饭试了试家里的显示器, 家里的显示器还是太老了…… 八年的显示器了 看得我眼花<br>还是继续用笔记本吧</p>\n<ol>\n<li><p>首先我很喜欢这种运算符重载的使用形式, 用起来非常的舒服, 需要重载两个运算符 <code>[]</code>和<code>=</code> 而且<br><code>=运算符</code>重载使用的swap交换需要的属性, 感觉不错<br>(后来我看了EffectiveC++ 发现这是<code>=运算符处理自我赋值</code>太巧了)</p>\n</li>\n<li><p>针对需要加载配置文件的类 使用了工厂模式</p>\n</li>\n<li><p>writeValue使用了递归处理.</p>\n</li>\n<li><p>统一处理, k v都是Value对象</p>\n</li>\n<li><p>将用户的string 拷贝到新的<code>char*</code>中 同时在开头增加了长度, 尾部补了0, 没有使用额外的变量去存储<code>char*</code>的长度<br>不太清楚这样做有什么好处</p>\n</li>\n<li><p>常量全部用的 <code>static constexpr</code>修饰</p>\n</li>\n<li><p>恰当的对象嵌套</p>\n</li>\n</ol>\n<hr>\n<p>看完了从 Value到Json 接下来看看从Json到Value</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> rawJson = <span class=\"string\">R\"(&#123;\"Age\": 20, \"Name\": \"colin\"&#125;)\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> rawJsonLength = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(rawJson.length());</span><br><span class=\"line\">  <span class=\"keyword\">constexpr</span> <span class=\"keyword\">bool</span> shouldUseOldWay = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  JSONCPP_STRING err;</span><br><span class=\"line\">  Json::Value root;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldUseOldWay) &#123;</span><br><span class=\"line\">    Json::Reader reader;</span><br><span class=\"line\">    reader.parse(rawJson, root);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 默认构造函数 使用默认的配置</span></span><br><span class=\"line\">    Json::CharReaderBuilder builder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据builder的配置生成CharReader类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Json::CharReader&gt; <span class=\"title\">reader</span><span class=\"params\">(builder.newCharReader())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!reader-&gt;parse(rawJson.c_str(), rawJson.c_str() + rawJsonLength, &amp;root,</span><br><span class=\"line\">                       &amp;err)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name = root[<span class=\"string\">\"Name\"</span>].asString();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> age = root[<span class=\"string\">\"Age\"</span>].asInt();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; age &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解析的关键在于<code>parse()</code>函数 传入字符串的首尾指针, 和一个Value引用<br>进入函数后将传入的变量保存到了自己的成员变量中.</p>\n<p>慢慢发现 这个库将很多的默认类型 起了别名 可能是为了统一类型 类似UE4也是自己搞了一套</p>\n<p>主要是<code>OurReader</code>这个负责解析</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用了大量的using</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> Char = <span class=\"keyword\">char</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Location = <span class=\"keyword\">const</span> Char*;</span><br></pre></td></tr></table></figure>\n\n<p>解析逻辑就是<code>parse()</code>调用<code>readValue()</code><br><code>readValue()</code>负责 获取下一次数据类型type_ -&gt;switch(type_) 根据分支决定是否递归再次调用<code>readValue</code><br>总算把逻辑看懂了, 代码依然认为很赞<br><code>readToken()</code>这个函数贯穿整个解析, 通过这个函数获取到下一次的数据是什么类型, 同时移动相关的状态指针<br><code>readToken()</code> 内部大量调用下面的函数 修改当前指针 同时返回字符, 然后switch这个字符判断下一次的数据类型<br>比如遇到<code>{</code>就是一个对象的开始设置好type并返回 遇到<code>}</code>就是对象的结束…..</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取current_指向的字符 并自增</span></span><br><span class=\"line\"><span class=\"function\">OurReader::Char <span class=\"title\">OurReader::getNextChar</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (current_ == end_)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *current_++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一般第一次调用type_会被设置为对象类型, 然后<code>readValue()</code>进入<code>case 对象分支</code><br><code>case对象分支中</code><br>先进行了一次<code>readToken()</code>获取到了k的类型, 然后根据k类型分支 将k的值转换成对应的value<br>之后又是一次<code>readToken()</code>判断是否存在<code>:</code>不存在就是错误<br>在之后使用这个方法, 保存<code>k</code>的vallue获取<code>v</code>的value再次调用<code>readValue()</code>填充值 返回后继续走</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里保存了name 这个k 将name的 v放入了顶层</span></span><br><span class=\"line\">Value&amp; value = currentValue()[name];</span><br><span class=\"line\">nodes_.push(&amp;value);</span><br><span class=\"line\"><span class=\"keyword\">bool</span> ok = readValue();</span><br></pre></td></tr></table></figure>\n<p>读取完<code>v</code>的value之后必定是<code>,</code>或者<code>}</code>又是一次判断 成功判断后一个<code>k v</code>就获取完毕了</p>\n<p><code>using Nodes = std::stack&lt;Value*&gt;</code><br>后面解析的代码更加的妙不可言, 使用<code>Nodes nodes_{}</code>存储当前的value 实现函数之间的操作</p>\n<p>代码合理的组织<br>比如<code>case 对象分支</code>必定是一个<code>k</code>一个<code>:</code>一个<code>v</code> 然后一个分隔符<code>,</code>或<code>}</code> 这些放入了一个函数</p>\n<p>然后获取到<code>k</code>之后使用<code>Value&amp; value = currentValue()[name]</code>获取<code>v</code></p>\n<p>最后依然是递归的使用</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Json::Value root;</span><br><span class=\"line\">root[<span class=\"string\">\"action\"</span>] = <span class=\"string\">\"run\"</span>;</span><br></pre></td></tr></table></figure>\n<p>首先是 <code>[]运算符重载</code> , 统一不同的重载类型<br>调用<code>resolveReference()</code>进行统一的添加<code>k</code>操作</p>\n<p>首先会进行 校验参数, 然后将key封装成一个对象CZString (封装过程为将传入指针保存到 CZString对象中的cstr_)<br>封装完成后再保存<code>k v</code>的<code>map&lt;CZString, Value&gt;</code>中查找有无相同的CZString(key)有的话返回Value引用,<br>没有则创建新的&lt;CZStrng, 空Value&gt;存入map并返回Value的引用</p>\n<p>然后是<code>=运算符重载</code>, “run”自动转换成Value对象<br>转换过程中, 通过<code>duplicateAndPrefixStringValue()</code>将”run”进行了封装<br><code>char* string_; // if allocated_, ptr to { unsigned, char[] }.</code><br>将长度封装到了一个char指针中, 有点类似自己设计tcp协议…</p>\n<p><code>=运算符重载</code>函数将<code>[]运算符重载</code>返回的对象引用 中的相关值<code>swap()</code>成新的Value对象中的相关值</p>\n<p>到这里理解了在Jsoncpp中 一切都是Value 包括&lt;K, V&gt;键值对也是在Value对象中存储<br>每一个&lt;k, v&gt;都可以作为一个Value对象, 这样既实现了复杂嵌套Json中 v为对象的情况 妙啊</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每个Value对象中都维护一个union</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> ValueHolder &#123;</span><br><span class=\"line\">    LargestInt int_;</span><br><span class=\"line\">    LargestUInt uint_;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> real_;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> bool_;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* string_; <span class=\"comment\">// if allocated_, ptr to &#123; unsigned, char[] &#125;.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将所有的存贮着key的CZString保存起来</span></span><br><span class=\"line\">\t<span class=\"comment\">//  typedef std::map&lt;CZString, Value&gt; ObjectValues; // std::map&lt;CZString, Value&gt; 键值对</span></span><br><span class=\"line\">    ObjectValues* map_;</span><br><span class=\"line\">  &#125; value_;</span><br></pre></td></tr></table></figure>\n\n<p>下面的switch的这个type 会在很多地方被修改掉.<br>起初 使用默认构造函数的value type是nullxxx<br>然后调用<code>[]运算符重载</code>的时候会修改掉 type 为 objectValue</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 递归调用 进行处理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BuiltStyledStreamWriter::writeValue</span><span class=\"params\">(Value <span class=\"keyword\">const</span>&amp; value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (value.type()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> nullValue:</span><br><span class=\"line\">    pushValue(nullSymbol_);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> intValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asLargestInt()));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> uintValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asLargestUInt()));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> realValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,</span><br><span class=\"line\">                            precisionType_));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> stringValue: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Is NULL is possible for value.string_? No.</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>* str;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>* <span class=\"built_in\">end</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ok = value.getString(&amp;str, &amp;<span class=\"built_in\">end</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ok)</span><br><span class=\"line\">      pushValue(valueToQuotedStringN(str, <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">unsigned</span>&gt;(<span class=\"built_in\">end</span> - str),</span><br><span class=\"line\">                                     emitUTF8_));</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      pushValue(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> booleanValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asBool()));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> arrayValue:</span><br><span class=\"line\">    writeArrayValue(value);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> objectValue: &#123;</span><br><span class=\"line\">    <span class=\"function\">Value::Members <span class=\"title\">members</span><span class=\"params\">(value.getMemberNames())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (members.empty())</span><br><span class=\"line\">      pushValue(<span class=\"string\">\"&#123;&#125;\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      writeWithIndent(<span class=\"string\">\"&#123;\"</span>);</span><br><span class=\"line\">      indent();</span><br><span class=\"line\">      <span class=\"keyword\">auto</span> it = members.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> <span class=\"keyword\">const</span>&amp; name = *it;</span><br><span class=\"line\">        Value <span class=\"keyword\">const</span>&amp; childValue = value[name];</span><br><span class=\"line\">        writeCommentBeforeValue(childValue);</span><br><span class=\"line\">        writeWithIndent(valueToQuotedStringN(</span><br><span class=\"line\">            name.data(), <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">unsigned</span>&gt;(name.length()), emitUTF8_));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// :</span></span><br><span class=\"line\">        *sout_ &lt;&lt; colonSymbol_;</span><br><span class=\"line\">        writeValue(childValue);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++it == members.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">          writeCommentAfterValueOnSameLine(childValue);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        *sout_ &lt;&lt; <span class=\"string\">\",\"</span>;</span><br><span class=\"line\">        writeCommentAfterValueOnSameLine(childValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      unindent();</span><br><span class=\"line\">      writeWithIndent(<span class=\"string\">\"&#125;\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这次是根据下面的例子分析的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Json::Value root;</span><br><span class=\"line\">  Json::Value data;</span><br><span class=\"line\">  <span class=\"keyword\">constexpr</span> <span class=\"keyword\">bool</span> shouldUseOldWay = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 左侧返回Value的引用</span></span><br><span class=\"line\">  root[<span class=\"string\">\"action\"</span>] = <span class=\"string\">\"run\"</span>;</span><br><span class=\"line\">  data[<span class=\"string\">\"number\"</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  root[<span class=\"string\">\"data\"</span>] = data;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldUseOldWay) &#123;</span><br><span class=\"line\">    Json::FastWriter writer;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> json_file = writer.<span class=\"built_in\">write</span>(root);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; json_file &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 配置文件也是Value对象, 我用我自己.jpg</span></span><br><span class=\"line\">    Json::StreamWriterBuilder builder;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> json_file = Json::writeString(builder, root);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; json_file &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>算是了解到了这个库的大概工作流程了. 能学到的部分 吃完午饭继续写.<br>吃完饭试了试家里的显示器, 家里的显示器还是太老了…… 八年的显示器了 看得我眼花<br>还是继续用笔记本吧</p>\n<ol>\n<li><p>首先我很喜欢这种运算符重载的使用形式, 用起来非常的舒服, 需要重载两个运算符 <code>[]</code>和<code>=</code> 而且<br><code>=运算符</code>重载使用的swap交换需要的属性, 感觉不错<br>(后来我看了EffectiveC++ 发现这是<code>=运算符处理自我赋值</code>太巧了)</p>\n</li>\n<li><p>针对需要加载配置文件的类 使用了工厂模式</p>\n</li>\n<li><p>writeValue使用了递归处理.</p>\n</li>\n<li><p>统一处理, k v都是Value对象</p>\n</li>\n<li><p>将用户的string 拷贝到新的<code>char*</code>中 同时在开头增加了长度, 尾部补了0, 没有使用额外的变量去存储<code>char*</code>的长度<br>不太清楚这样做有什么好处</p>\n</li>\n<li><p>常量全部用的 <code>static constexpr</code>修饰</p>\n</li>\n<li><p>恰当的对象嵌套</p>\n</li>\n</ol>\n<hr>\n<p>看完了从 Value到Json 接下来看看从Json到Value</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> rawJson = <span class=\"string\">R\"(&#123;\"Age\": 20, \"Name\": \"colin\"&#125;)\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> rawJsonLength = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(rawJson.length());</span><br><span class=\"line\">  <span class=\"keyword\">constexpr</span> <span class=\"keyword\">bool</span> shouldUseOldWay = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  JSONCPP_STRING err;</span><br><span class=\"line\">  Json::Value root;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldUseOldWay) &#123;</span><br><span class=\"line\">    Json::Reader reader;</span><br><span class=\"line\">    reader.parse(rawJson, root);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 默认构造函数 使用默认的配置</span></span><br><span class=\"line\">    Json::CharReaderBuilder builder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据builder的配置生成CharReader类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Json::CharReader&gt; <span class=\"title\">reader</span><span class=\"params\">(builder.newCharReader())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!reader-&gt;parse(rawJson.c_str(), rawJson.c_str() + rawJsonLength, &amp;root,</span><br><span class=\"line\">                       &amp;err)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name = root[<span class=\"string\">\"Name\"</span>].asString();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> age = root[<span class=\"string\">\"Age\"</span>].asInt();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; age &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解析的关键在于<code>parse()</code>函数 传入字符串的首尾指针, 和一个Value引用<br>进入函数后将传入的变量保存到了自己的成员变量中.</p>\n<p>慢慢发现 这个库将很多的默认类型 起了别名 可能是为了统一类型 类似UE4也是自己搞了一套</p>\n<p>主要是<code>OurReader</code>这个负责解析</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用了大量的using</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> Char = <span class=\"keyword\">char</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Location = <span class=\"keyword\">const</span> Char*;</span><br></pre></td></tr></table></figure>\n\n<p>解析逻辑就是<code>parse()</code>调用<code>readValue()</code><br><code>readValue()</code>负责 获取下一次数据类型type_ -&gt;switch(type_) 根据分支决定是否递归再次调用<code>readValue</code><br>总算把逻辑看懂了, 代码依然认为很赞<br><code>readToken()</code>这个函数贯穿整个解析, 通过这个函数获取到下一次的数据是什么类型, 同时移动相关的状态指针<br><code>readToken()</code> 内部大量调用下面的函数 修改当前指针 同时返回字符, 然后switch这个字符判断下一次的数据类型<br>比如遇到<code>{</code>就是一个对象的开始设置好type并返回 遇到<code>}</code>就是对象的结束…..</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取current_指向的字符 并自增</span></span><br><span class=\"line\"><span class=\"function\">OurReader::Char <span class=\"title\">OurReader::getNextChar</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (current_ == end_)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *current_++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一般第一次调用type_会被设置为对象类型, 然后<code>readValue()</code>进入<code>case 对象分支</code><br><code>case对象分支中</code><br>先进行了一次<code>readToken()</code>获取到了k的类型, 然后根据k类型分支 将k的值转换成对应的value<br>之后又是一次<code>readToken()</code>判断是否存在<code>:</code>不存在就是错误<br>在之后使用这个方法, 保存<code>k</code>的vallue获取<code>v</code>的value再次调用<code>readValue()</code>填充值 返回后继续走</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里保存了name 这个k 将name的 v放入了顶层</span></span><br><span class=\"line\">Value&amp; value = currentValue()[name];</span><br><span class=\"line\">nodes_.push(&amp;value);</span><br><span class=\"line\"><span class=\"keyword\">bool</span> ok = readValue();</span><br></pre></td></tr></table></figure>\n<p>读取完<code>v</code>的value之后必定是<code>,</code>或者<code>}</code>又是一次判断 成功判断后一个<code>k v</code>就获取完毕了</p>\n<p><code>using Nodes = std::stack&lt;Value*&gt;</code><br>后面解析的代码更加的妙不可言, 使用<code>Nodes nodes_{}</code>存储当前的value 实现函数之间的操作</p>\n<p>代码合理的组织<br>比如<code>case 对象分支</code>必定是一个<code>k</code>一个<code>:</code>一个<code>v</code> 然后一个分隔符<code>,</code>或<code>}</code> 这些放入了一个函数</p>\n<p>然后获取到<code>k</code>之后使用<code>Value&amp; value = currentValue()[name]</code>获取<code>v</code></p>\n<p>最后依然是递归的使用</p>\n"},{"title":"Libevent代码初期了解","date":"2020-02-19T06:56:55.000Z","img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Libevent%E5%B0%81%E9%9D%A2.png","_content":"学习来源\n<Linux 高性能服务器编程>\n# I/O框架库概述\n## Reactor模式\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-1IO%E6%A1%86%E6%9E%B6%E7%BB%84%E7%BB%84%E4%BB%B6.png)\n句柄(Handler)\n由于统一了事件源, 一个事件一般跟一个句柄绑定在一起, 事件就绪之后 会通过句柄通知这一个事件.\n在Linux中 I/O 事件对应的句柄->文件描述符, 信号事件->信号值\n\n事件多路分发器(EventDemultiplexer)\n事件的到来是随机的, 异步的. 所以只能通过一个循环一直等待事件并进行处理 --- 事件循环\n一般通过IO复用实现 select poll epoll_wait\n\n事件处理器(EventHandle)\n具体事件处理器(ConcreteEventHandler)\n事件处理器执行事件对应的业务逻辑, 通常包含一个或多个handler_event回调函数, 这些回调函数在事件循环中被执行\n\nReactor\nhandler_events: 执行事件循环 重复等待事件, 然后依次调用对应的事件处理器\nregister_handler: 向事件多路分发器中注册事件\nremove_handler: 从中删除一个事件\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-2%20IO%E6%A1%86%E6%9E%B6%E5%BA%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE.png)\n\n## Libevent源码分析\n```c++\n#include <sys/signal.h>\n#include <event.h>\n#include <cstdio>\n\nvoid signal_cb(int fd, short event, void* argc)\n{\n    event_base* base = (event_base*)argc;\n    timeval delay = {2, 0};\n\n    printf(\"Caught an interrupt signal\\n\");\n    event_base_loopexit(base, &delay);\n}\n\nvoid timeout_cb(int fd, short event, void* argc)\n{\n    printf(\"timeout\\n\");\n}\nint main()\n{\n    // 相当于创建一个Reactor实例\n    event_base* base = event_init();\n    \n    event* signal_event = evsignal_new(base, SIGINT, signal_cb, base);\n    event_add(signal_event, nullptr);\n    \n    event* timeout_event = evtimer_new(base, timeout_cb, nullptr);\n    timeval tv{1, 0};\n    event_add(timeout_event, &tv);\n    \n    event_base_dispatch(base);\n    event_free(signal_event);\n    event_free(timeout_event);\n    event_base_free(base);\n}\n```\n创建一个事件处理器 然后为绑定上相应的回调函数.\n然后把这个事件处理器注册到事件队列中中,\n\n然后事件多路分发器依靠循环一直等待事件的到来, 事件到来后通知相应的事件处理器\nReactor则管理这些\n\n首先要去了解下 `事件处理器` 对应的就是event这个结构体\n```c++\nstruct event {\n\tstruct event_callback ev_evcallback;\n\n\t// 事件处理器从属的 event_base\n\tstruct event_base *ev_base;\n\t// 信号值 或者 文件描述符\n\tevutil_socket_t ev_fd;\n\t// 定时器的超时时间\n\tstruct timeval ev_timeout;\n\t\n\t// 仅用于定时事件\n\tunion {\n\t\t// 队列--指出在通用定时器中的位置\n\t\tTAILQ_ENTRY(event) ev_next_with_common_timeout;\n\t\t// 时间堆--指出了在时间堆中的位置\n\t\tint min_heap_idx;\n\t} ev_timeout_pos;\n\n\tunion {\n\t\tstruct {\n\t\t\t// 通过这个成员 将具有相同文件描述符的IO事件处理器串联起来\n\t\t\tLIST_ENTRY (event) ev_io_next;\n\t\t\tstruct timeval ev_timeout;\n\t\t} ev_io;\n\t\tstruct {\n\t\t\t// 相同信号的串联起来\n\t\t\tLIST_ENTRY (event) ev_signal_next;\n\t\t\tshort ev_ncalls;\n\t\t\t/* Allows deletes in callback */\n\t\t\tshort *ev_pncalls;\n\t\t} ev_signal;\n\t} ev_;\n\n\t// 事件类型, 可以通过位处理设置非互斥事件\n\tshort ev_events;\n\t// 当前激活事件的类型, 说明被激活的原因\n\tshort ev_res;\n};\n```\n可以看到其中有很多的属性, 三种事件对应的不同的属性.\n\n这些属性的填充函数\n`evsignal_new``evtimer_new`是宏 统一调用`event_new`\n`event_new`调用`event_assign`来进行主要的填充\n\n\n```\n//@通过宏封装注册函数\n\n一个事件生成函数 经过宏的封装(可以自动填充某些此事件用不到的参数)可以更方便的对应不同事件的生成, 既统一了注册, 又方便用户调用\n```\n属性之一便是回调函数, 事件回调函数有自己的规定\n```\n//@统一事件回调函数\n\nvoid (*callback)(evutil_socket_t, short, void *)\n这样能够统一回调函数的格式, 同时方便管理\n```\n事件处理器创建完毕, 该把事件处理器添加到事件注册队列. 样例代码中通过的`event_add`函数来实现将事件处理器添加到事件注册队列\n`event_add`实际由`event_add_nolock_`实现 所以接下来是`event_add_nolock_`函数的说明\n\n```\n//@事件处理器的分发实现\n将传入的event按照不同类型的事件处理器 分别处理\n(因为event_new已经填充了ev_events说明事件类型)\n\nIO事件 添加绑定\n信号事件 绑定相应的信号\n定时器 放入相关的的时间管理数据结构中\n```\n使用`event_queue_insert_inserted`进行注册\n这里的代码2.1.11 与书上的差别较大, 少了多一半的功能, 也没有被抽成函数, 暂不知道对应的功能代码去了哪里\n照书上来说`event_queue_insert_inserted`实现的是将事件处理器加入到`event_base`的某个事件队列中. 对于新添加的IO和信号事件处理器, 还需要让事件多路分发器来监听对应的事件, 然后建立相应的映射关系. 分别使用`evmap_io_add_`和`evmap_signal_add_`(相当于图中的`register_event`)建立映射. \n\n`evmap_io_add_`中有一个结构体`event_io_map`\n`event_io_map`会根据不同的平台最终对应不同的数据结构\n\n`evmap_io_add_`函数\n函数中用到的东西, 我目前吸收不了....... 总之是为将IO事件处理器加入到`event_base`的事件队列中实现的\n\n`eventop`结构体 是`event_base`中封装IO复用机制的结构体, 提供了统一的接口\n```c++\n// 为给定的event_base声明后端的结构体\nstruct eventop {\n\t// 后端IO复用技术的名称\n\tconst char *name;\n\n\t// 初始化 函数需要初始化所有要用的属性\n\t// 返回的指针会被event_init存储在event_base.evbase\n\t// 失败后返回NULL\n\tvoid *(*init)(struct event_base *);\n\t// 注册事件\n\tint (*add)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);\n\t// 删除事件\n\tint (*del)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);\n\t// 等待事件\n\tint (*dispatch)(struct event_base *, struct timeval *);\n\t// 释放IO复用机制使用的资源\n\tvoid (*dealloc)(struct event_base *);\n\t// 标记fork后是否需要重新初始化event_base的标志位\n\tint need_reinit;\n\t// 用于设定io复用技术支持的一些特性\n\tenum event_method_feature features;\n\t// 额外内存的分配\n\tsize_t fdinfo_len;\n};\n```\n\n`event_base`是Libevent的Reactor. 超长结构体 删除了我不理解的部分\n```c++\nstruct event_base {\n\t// 记录选择的I/O复用机制\n\tconst struct eventop *evsel;\n\t// 指向IO复用机制真正存储的数据\n\tvoid *evbase;\n\n\t// 事件变换队列 如果一个文件描述符上注册的事件被多次修改, 则可以使用缓冲避免重复的系统调用\n\t// 比如epoll_ctl, 仅能用于时间复杂度O(1)的IO复用技术\n\tstruct event_changelist changelist;\n\n\t// 信号的后端处理机制\n\tconst struct eventop *evsigsel;\n\t// 信号事件处理器使用的数据结构, 其中封装了socketpair创建的管道. 用于信号处理函数和\n\t// 事件多路分发器之间的通信, 统一事件源的思路\n\tstruct evsig_info sig;\n\n\t// 添加到event_base的虚拟(所有, 激活)事件数量, 虚拟(所有, 激活)事件最大数量\n\tint virtual_event_count;\n\tint virtual_event_count_max;\n\tint event_count;\n\tint event_count_max;\n\tint event_count_active;\n\tint event_count_active_max;\n\n\t// 处理完事件后 是否退出循环\n\tint event_gotterm;\n\t// 是否立即终止循环\n\tint event_break;\n\t// 是否启动一个新的事件循环\n\tint event_continue;\n\n\t// 当前正在处理的活动事件队列的优先级\n\tint event_running_priority;\n\n\t// 标记事件循环是否已经启动, 防止重入\n\tint running_loop;\n\n\t// 活动事件队列数组. 索引值越小的队列优先级越高. 高优先级的活动事件队列中的事件处理器被优先处理\n\tstruct evcallback_list *activequeues;\n\t// 活动事件队列数组的大小 说明有nactivequeues个不同优先级的活动事件队列\n\tint nactivequeues;\n\t/** A list of event_callbacks that should become active the next time\n\t * we process events, but not this time. */\n\tstruct evcallback_list active_later_queue;\n\n\t// 共同超时逻辑\n\n\t// 管理通用定时器队列 实体数量 总数\n\tstruct common_timeout_list **common_timeout_queues;\n\tint n_common_timeouts;\n\tint n_common_timeouts_allocated;\n\n\t// 文件描述符和IO事件之间的映射关系表\n\tstruct event_io_map io;\n\t// 信号值和信号事件之间的映射关系表\n\tstruct event_signal_map sigmap;\n\t// 时间堆\n\tstruct min_heap timeheap;\n\n\t// 管理系统时间的成员\n\tstruct timeval tv_cache;\n\tstruct evutil_monotonic_timer monotonic_timer;\n\tstruct timeval tv_clock_diff;\n\ttime_t last_updated_clock_diff;\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\t// 多线程支持\n\t\n\t// 当前运行该event_base的事件循环的线程\n\tunsigned long th_owner_id;\n\t// 独占锁\n\tvoid *th_base_lock;\n\t// 当前事件循环正在执行哪个事件处理器的回调函数\n\tvoid *current_event_cond;\n\t// 等待的线程数\n\tint current_event_waiters;\n#endif\n\t// 正在处理的事件处理器的回调函数\n\tstruct event_callback *current_event;\n};\n```\n\n事件循环, libevent的动力, 即事件循环\n\n这次读了一下helloworld的 这一部分代码\n```c++\nstatic void\nlistener_cb(struct evconnlistener *listener, evutil_socket_t fd,\n    struct sockaddr *sa, int socklen, void *user_data)\n{\n\tstruct event_base *base = user_data;\n\tstruct bufferevent *bev;\n\n\tbev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);\n\tif (!bev) {\n\t\tfprintf(stderr, \"Error constructing bufferevent!\");\n\t\tevent_base_loopbreak(base);\n\t\treturn;\n\t}\n\t// 设置新创建的bufferevent的 读写回调函数 启动写事件 禁用读事件\n\tbufferevent_setcb(bev, NULL, conn_writecb, conn_eventcb, NULL);\n\tbufferevent_enable(bev, EV_WRITE);\n\tbufferevent_disable(bev, EV_READ);\n\n\tbufferevent_write(bev, MESSAGE, strlen(MESSAGE));\n}\n```\nbufferevent_socket_new 创建了读和写event 设置了真实的回调函数`bufferevent_writecb`等 然后\nbufferevent_enable是真正的事件注册函数， 将上面生成的event注册进入eventbase\n`EV_WRITE`对应的epoll事件是`EPOLLOUT`\n`bufferevent_write`将要写出的数据放入到缓冲区中。 一旦epollwait返回了 就去调用`bufferevent_writecb`将缓冲区\n的内容写出， 然后同时调用用户设置的回调函数\n\n\n2020年3月7日20:26:02\n这次又读了下 系统是怎么区分不同事件来调用回调函数的, 结果返现框架将系统的事件类型对应成自己的事件类型\n```c++\nif (what & (EPOLLHUP|EPOLLERR)) {\n\tev = EV_READ | EV_WRITE;\n} else {\n\tif (what & EPOLLIN)\n\t\tev |= EV_READ;\n\tif (what & EPOLLOUT)\n\t\tev |= EV_WRITE;\n\tif (what & EPOLLRDHUP)\n\t\tev |= EV_CLOSED;\n}\n```\n然后传入`evmap_io_active_`函数, 进而将ev保存到`ev_res`中然后直接作为参数 传给了回调函数","source":"_posts/CPP-源码学习-Libevent代码初期了解.md","raw":"---\ntitle: Libevent代码初期了解\ndate: 2020-02-19 14:56:55\ntags:\ncategories:\n - CPP\n - 源码学习\n \nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Libevent%E5%B0%81%E9%9D%A2.png\n---\n学习来源\n<Linux 高性能服务器编程>\n# I/O框架库概述\n## Reactor模式\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-1IO%E6%A1%86%E6%9E%B6%E7%BB%84%E7%BB%84%E4%BB%B6.png)\n句柄(Handler)\n由于统一了事件源, 一个事件一般跟一个句柄绑定在一起, 事件就绪之后 会通过句柄通知这一个事件.\n在Linux中 I/O 事件对应的句柄->文件描述符, 信号事件->信号值\n\n事件多路分发器(EventDemultiplexer)\n事件的到来是随机的, 异步的. 所以只能通过一个循环一直等待事件并进行处理 --- 事件循环\n一般通过IO复用实现 select poll epoll_wait\n\n事件处理器(EventHandle)\n具体事件处理器(ConcreteEventHandler)\n事件处理器执行事件对应的业务逻辑, 通常包含一个或多个handler_event回调函数, 这些回调函数在事件循环中被执行\n\nReactor\nhandler_events: 执行事件循环 重复等待事件, 然后依次调用对应的事件处理器\nregister_handler: 向事件多路分发器中注册事件\nremove_handler: 从中删除一个事件\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-2%20IO%E6%A1%86%E6%9E%B6%E5%BA%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE.png)\n\n## Libevent源码分析\n```c++\n#include <sys/signal.h>\n#include <event.h>\n#include <cstdio>\n\nvoid signal_cb(int fd, short event, void* argc)\n{\n    event_base* base = (event_base*)argc;\n    timeval delay = {2, 0};\n\n    printf(\"Caught an interrupt signal\\n\");\n    event_base_loopexit(base, &delay);\n}\n\nvoid timeout_cb(int fd, short event, void* argc)\n{\n    printf(\"timeout\\n\");\n}\nint main()\n{\n    // 相当于创建一个Reactor实例\n    event_base* base = event_init();\n    \n    event* signal_event = evsignal_new(base, SIGINT, signal_cb, base);\n    event_add(signal_event, nullptr);\n    \n    event* timeout_event = evtimer_new(base, timeout_cb, nullptr);\n    timeval tv{1, 0};\n    event_add(timeout_event, &tv);\n    \n    event_base_dispatch(base);\n    event_free(signal_event);\n    event_free(timeout_event);\n    event_base_free(base);\n}\n```\n创建一个事件处理器 然后为绑定上相应的回调函数.\n然后把这个事件处理器注册到事件队列中中,\n\n然后事件多路分发器依靠循环一直等待事件的到来, 事件到来后通知相应的事件处理器\nReactor则管理这些\n\n首先要去了解下 `事件处理器` 对应的就是event这个结构体\n```c++\nstruct event {\n\tstruct event_callback ev_evcallback;\n\n\t// 事件处理器从属的 event_base\n\tstruct event_base *ev_base;\n\t// 信号值 或者 文件描述符\n\tevutil_socket_t ev_fd;\n\t// 定时器的超时时间\n\tstruct timeval ev_timeout;\n\t\n\t// 仅用于定时事件\n\tunion {\n\t\t// 队列--指出在通用定时器中的位置\n\t\tTAILQ_ENTRY(event) ev_next_with_common_timeout;\n\t\t// 时间堆--指出了在时间堆中的位置\n\t\tint min_heap_idx;\n\t} ev_timeout_pos;\n\n\tunion {\n\t\tstruct {\n\t\t\t// 通过这个成员 将具有相同文件描述符的IO事件处理器串联起来\n\t\t\tLIST_ENTRY (event) ev_io_next;\n\t\t\tstruct timeval ev_timeout;\n\t\t} ev_io;\n\t\tstruct {\n\t\t\t// 相同信号的串联起来\n\t\t\tLIST_ENTRY (event) ev_signal_next;\n\t\t\tshort ev_ncalls;\n\t\t\t/* Allows deletes in callback */\n\t\t\tshort *ev_pncalls;\n\t\t} ev_signal;\n\t} ev_;\n\n\t// 事件类型, 可以通过位处理设置非互斥事件\n\tshort ev_events;\n\t// 当前激活事件的类型, 说明被激活的原因\n\tshort ev_res;\n};\n```\n可以看到其中有很多的属性, 三种事件对应的不同的属性.\n\n这些属性的填充函数\n`evsignal_new``evtimer_new`是宏 统一调用`event_new`\n`event_new`调用`event_assign`来进行主要的填充\n\n\n```\n//@通过宏封装注册函数\n\n一个事件生成函数 经过宏的封装(可以自动填充某些此事件用不到的参数)可以更方便的对应不同事件的生成, 既统一了注册, 又方便用户调用\n```\n属性之一便是回调函数, 事件回调函数有自己的规定\n```\n//@统一事件回调函数\n\nvoid (*callback)(evutil_socket_t, short, void *)\n这样能够统一回调函数的格式, 同时方便管理\n```\n事件处理器创建完毕, 该把事件处理器添加到事件注册队列. 样例代码中通过的`event_add`函数来实现将事件处理器添加到事件注册队列\n`event_add`实际由`event_add_nolock_`实现 所以接下来是`event_add_nolock_`函数的说明\n\n```\n//@事件处理器的分发实现\n将传入的event按照不同类型的事件处理器 分别处理\n(因为event_new已经填充了ev_events说明事件类型)\n\nIO事件 添加绑定\n信号事件 绑定相应的信号\n定时器 放入相关的的时间管理数据结构中\n```\n使用`event_queue_insert_inserted`进行注册\n这里的代码2.1.11 与书上的差别较大, 少了多一半的功能, 也没有被抽成函数, 暂不知道对应的功能代码去了哪里\n照书上来说`event_queue_insert_inserted`实现的是将事件处理器加入到`event_base`的某个事件队列中. 对于新添加的IO和信号事件处理器, 还需要让事件多路分发器来监听对应的事件, 然后建立相应的映射关系. 分别使用`evmap_io_add_`和`evmap_signal_add_`(相当于图中的`register_event`)建立映射. \n\n`evmap_io_add_`中有一个结构体`event_io_map`\n`event_io_map`会根据不同的平台最终对应不同的数据结构\n\n`evmap_io_add_`函数\n函数中用到的东西, 我目前吸收不了....... 总之是为将IO事件处理器加入到`event_base`的事件队列中实现的\n\n`eventop`结构体 是`event_base`中封装IO复用机制的结构体, 提供了统一的接口\n```c++\n// 为给定的event_base声明后端的结构体\nstruct eventop {\n\t// 后端IO复用技术的名称\n\tconst char *name;\n\n\t// 初始化 函数需要初始化所有要用的属性\n\t// 返回的指针会被event_init存储在event_base.evbase\n\t// 失败后返回NULL\n\tvoid *(*init)(struct event_base *);\n\t// 注册事件\n\tint (*add)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);\n\t// 删除事件\n\tint (*del)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);\n\t// 等待事件\n\tint (*dispatch)(struct event_base *, struct timeval *);\n\t// 释放IO复用机制使用的资源\n\tvoid (*dealloc)(struct event_base *);\n\t// 标记fork后是否需要重新初始化event_base的标志位\n\tint need_reinit;\n\t// 用于设定io复用技术支持的一些特性\n\tenum event_method_feature features;\n\t// 额外内存的分配\n\tsize_t fdinfo_len;\n};\n```\n\n`event_base`是Libevent的Reactor. 超长结构体 删除了我不理解的部分\n```c++\nstruct event_base {\n\t// 记录选择的I/O复用机制\n\tconst struct eventop *evsel;\n\t// 指向IO复用机制真正存储的数据\n\tvoid *evbase;\n\n\t// 事件变换队列 如果一个文件描述符上注册的事件被多次修改, 则可以使用缓冲避免重复的系统调用\n\t// 比如epoll_ctl, 仅能用于时间复杂度O(1)的IO复用技术\n\tstruct event_changelist changelist;\n\n\t// 信号的后端处理机制\n\tconst struct eventop *evsigsel;\n\t// 信号事件处理器使用的数据结构, 其中封装了socketpair创建的管道. 用于信号处理函数和\n\t// 事件多路分发器之间的通信, 统一事件源的思路\n\tstruct evsig_info sig;\n\n\t// 添加到event_base的虚拟(所有, 激活)事件数量, 虚拟(所有, 激活)事件最大数量\n\tint virtual_event_count;\n\tint virtual_event_count_max;\n\tint event_count;\n\tint event_count_max;\n\tint event_count_active;\n\tint event_count_active_max;\n\n\t// 处理完事件后 是否退出循环\n\tint event_gotterm;\n\t// 是否立即终止循环\n\tint event_break;\n\t// 是否启动一个新的事件循环\n\tint event_continue;\n\n\t// 当前正在处理的活动事件队列的优先级\n\tint event_running_priority;\n\n\t// 标记事件循环是否已经启动, 防止重入\n\tint running_loop;\n\n\t// 活动事件队列数组. 索引值越小的队列优先级越高. 高优先级的活动事件队列中的事件处理器被优先处理\n\tstruct evcallback_list *activequeues;\n\t// 活动事件队列数组的大小 说明有nactivequeues个不同优先级的活动事件队列\n\tint nactivequeues;\n\t/** A list of event_callbacks that should become active the next time\n\t * we process events, but not this time. */\n\tstruct evcallback_list active_later_queue;\n\n\t// 共同超时逻辑\n\n\t// 管理通用定时器队列 实体数量 总数\n\tstruct common_timeout_list **common_timeout_queues;\n\tint n_common_timeouts;\n\tint n_common_timeouts_allocated;\n\n\t// 文件描述符和IO事件之间的映射关系表\n\tstruct event_io_map io;\n\t// 信号值和信号事件之间的映射关系表\n\tstruct event_signal_map sigmap;\n\t// 时间堆\n\tstruct min_heap timeheap;\n\n\t// 管理系统时间的成员\n\tstruct timeval tv_cache;\n\tstruct evutil_monotonic_timer monotonic_timer;\n\tstruct timeval tv_clock_diff;\n\ttime_t last_updated_clock_diff;\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\t// 多线程支持\n\t\n\t// 当前运行该event_base的事件循环的线程\n\tunsigned long th_owner_id;\n\t// 独占锁\n\tvoid *th_base_lock;\n\t// 当前事件循环正在执行哪个事件处理器的回调函数\n\tvoid *current_event_cond;\n\t// 等待的线程数\n\tint current_event_waiters;\n#endif\n\t// 正在处理的事件处理器的回调函数\n\tstruct event_callback *current_event;\n};\n```\n\n事件循环, libevent的动力, 即事件循环\n\n这次读了一下helloworld的 这一部分代码\n```c++\nstatic void\nlistener_cb(struct evconnlistener *listener, evutil_socket_t fd,\n    struct sockaddr *sa, int socklen, void *user_data)\n{\n\tstruct event_base *base = user_data;\n\tstruct bufferevent *bev;\n\n\tbev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);\n\tif (!bev) {\n\t\tfprintf(stderr, \"Error constructing bufferevent!\");\n\t\tevent_base_loopbreak(base);\n\t\treturn;\n\t}\n\t// 设置新创建的bufferevent的 读写回调函数 启动写事件 禁用读事件\n\tbufferevent_setcb(bev, NULL, conn_writecb, conn_eventcb, NULL);\n\tbufferevent_enable(bev, EV_WRITE);\n\tbufferevent_disable(bev, EV_READ);\n\n\tbufferevent_write(bev, MESSAGE, strlen(MESSAGE));\n}\n```\nbufferevent_socket_new 创建了读和写event 设置了真实的回调函数`bufferevent_writecb`等 然后\nbufferevent_enable是真正的事件注册函数， 将上面生成的event注册进入eventbase\n`EV_WRITE`对应的epoll事件是`EPOLLOUT`\n`bufferevent_write`将要写出的数据放入到缓冲区中。 一旦epollwait返回了 就去调用`bufferevent_writecb`将缓冲区\n的内容写出， 然后同时调用用户设置的回调函数\n\n\n2020年3月7日20:26:02\n这次又读了下 系统是怎么区分不同事件来调用回调函数的, 结果返现框架将系统的事件类型对应成自己的事件类型\n```c++\nif (what & (EPOLLHUP|EPOLLERR)) {\n\tev = EV_READ | EV_WRITE;\n} else {\n\tif (what & EPOLLIN)\n\t\tev |= EV_READ;\n\tif (what & EPOLLOUT)\n\t\tev |= EV_WRITE;\n\tif (what & EPOLLRDHUP)\n\t\tev |= EV_CLOSED;\n}\n```\n然后传入`evmap_io_active_`函数, 进而将ev保存到`ev_res`中然后直接作为参数 传给了回调函数","slug":"CPP-源码学习-Libevent代码初期了解","published":1,"updated":"2020-03-07T12:28:11.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg5y000bf8unacel1w0l","content":"<p>学习来源<br>&lt;Linux 高性能服务器编程&gt;</p>\n<h1 id=\"I-O框架库概述\"><a href=\"#I-O框架库概述\" class=\"headerlink\" title=\"I/O框架库概述\"></a>I/O框架库概述</h1><h2 id=\"Reactor模式\"><a href=\"#Reactor模式\" class=\"headerlink\" title=\"Reactor模式\"></a>Reactor模式</h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-1IO%E6%A1%86%E6%9E%B6%E7%BB%84%E7%BB%84%E4%BB%B6.png\" alt=\"\"><br>句柄(Handler)<br>由于统一了事件源, 一个事件一般跟一个句柄绑定在一起, 事件就绪之后 会通过句柄通知这一个事件.<br>在Linux中 I/O 事件对应的句柄-&gt;文件描述符, 信号事件-&gt;信号值</p>\n<p>事件多路分发器(EventDemultiplexer)<br>事件的到来是随机的, 异步的. 所以只能通过一个循环一直等待事件并进行处理 — 事件循环<br>一般通过IO复用实现 select poll epoll_wait</p>\n<p>事件处理器(EventHandle)<br>具体事件处理器(ConcreteEventHandler)<br>事件处理器执行事件对应的业务逻辑, 通常包含一个或多个handler_event回调函数, 这些回调函数在事件循环中被执行</p>\n<p>Reactor<br>handler_events: 执行事件循环 重复等待事件, 然后依次调用对应的事件处理器<br>register_handler: 向事件多路分发器中注册事件<br>remove_handler: 从中删除一个事件</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-2%20IO%E6%A1%86%E6%9E%B6%E5%BA%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE.png\" alt=\"\"></p>\n<h2 id=\"Libevent源码分析\"><a href=\"#Libevent源码分析\" class=\"headerlink\" title=\"Libevent源码分析\"></a>Libevent源码分析</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/signal.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;event.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">signal_cb</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, short event, <span class=\"keyword\">void</span>* argc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    event_base* base = (event_base*)argc;</span><br><span class=\"line\">    timeval <span class=\"built_in\">delay</span> = &#123;<span class=\"number\">2</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Caught an interrupt signal\\n\"</span>);</span><br><span class=\"line\">    event_base_loopexit(base, &amp;<span class=\"built_in\">delay</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">timeout_cb</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, short event, <span class=\"keyword\">void</span>* argc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"timeout\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 相当于创建一个Reactor实例</span></span><br><span class=\"line\">    event_base* base = event_init();</span><br><span class=\"line\">    </span><br><span class=\"line\">    event* signal_event = evsignal_new(base, SIGINT, signal_cb, base);</span><br><span class=\"line\">    event_add(signal_event, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    event* timeout_event = evtimer_new(base, timeout_cb, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    timeval tv&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    event_add(timeout_event, &amp;tv);</span><br><span class=\"line\">    </span><br><span class=\"line\">    event_base_dispatch(base);</span><br><span class=\"line\">    event_free(signal_event);</span><br><span class=\"line\">    event_free(timeout_event);</span><br><span class=\"line\">    event_base_free(base);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建一个事件处理器 然后为绑定上相应的回调函数.<br>然后把这个事件处理器注册到事件队列中中,</p>\n<p>然后事件多路分发器依靠循环一直等待事件的到来, 事件到来后通知相应的事件处理器<br>Reactor则管理这些</p>\n<p>首先要去了解下 <code>事件处理器</code> 对应的就是event这个结构体</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_callback</span> <span class=\"title\">ev_evcallback</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 事件处理器从属的 event_base</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_base</span> *<span class=\"title\">ev_base</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 信号值 或者 文件描述符</span></span><br><span class=\"line\">\t<span class=\"keyword\">evutil_socket_t</span> ev_fd;</span><br><span class=\"line\">\t<span class=\"comment\">// 定时器的超时时间</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">ev_timeout</span>;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 仅用于定时事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 队列--指出在通用定时器中的位置</span></span><br><span class=\"line\">\t\tTAILQ_ENTRY(event) ev_next_with_common_timeout;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 时间堆--指出了在时间堆中的位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> min_heap_idx;</span><br><span class=\"line\">\t&#125; ev_timeout_pos;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 通过这个成员 将具有相同文件描述符的IO事件处理器串联起来</span></span><br><span class=\"line\">\t\t\tLIST_ENTRY (event) ev_io_next;</span><br><span class=\"line\">\t\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">ev_timeout</span>;</span></span><br><span class=\"line\">\t\t&#125; ev_io;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 相同信号的串联起来</span></span><br><span class=\"line\">\t\t\tLIST_ENTRY (event) ev_signal_next;</span><br><span class=\"line\">\t\t\tshort ev_ncalls;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* Allows deletes in callback */</span></span><br><span class=\"line\">\t\t\tshort *ev_pncalls;</span><br><span class=\"line\">\t\t&#125; ev_signal;</span><br><span class=\"line\">\t&#125; ev_;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 事件类型, 可以通过位处理设置非互斥事件</span></span><br><span class=\"line\">\tshort ev_events;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前激活事件的类型, 说明被激活的原因</span></span><br><span class=\"line\">\tshort ev_res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到其中有很多的属性, 三种事件对应的不同的属性.</p>\n<p>这些属性的填充函数<br><code>evsignal_new``evtimer_new</code>是宏 统一调用<code>event_new</code><br><code>event_new</code>调用<code>event_assign</code>来进行主要的填充</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;@通过宏封装注册函数</span><br><span class=\"line\"></span><br><span class=\"line\">一个事件生成函数 经过宏的封装(可以自动填充某些此事件用不到的参数)可以更方便的对应不同事件的生成, 既统一了注册, 又方便用户调用</span><br></pre></td></tr></table></figure>\n<p>属性之一便是回调函数, 事件回调函数有自己的规定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;@统一事件回调函数</span><br><span class=\"line\"></span><br><span class=\"line\">void (*callback)(evutil_socket_t, short, void *)</span><br><span class=\"line\">这样能够统一回调函数的格式, 同时方便管理</span><br></pre></td></tr></table></figure>\n<p>事件处理器创建完毕, 该把事件处理器添加到事件注册队列. 样例代码中通过的<code>event_add</code>函数来实现将事件处理器添加到事件注册队列<br><code>event_add</code>实际由<code>event_add_nolock_</code>实现 所以接下来是<code>event_add_nolock_</code>函数的说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;@事件处理器的分发实现</span><br><span class=\"line\">将传入的event按照不同类型的事件处理器 分别处理</span><br><span class=\"line\">(因为event_new已经填充了ev_events说明事件类型)</span><br><span class=\"line\"></span><br><span class=\"line\">IO事件 添加绑定</span><br><span class=\"line\">信号事件 绑定相应的信号</span><br><span class=\"line\">定时器 放入相关的的时间管理数据结构中</span><br></pre></td></tr></table></figure>\n<p>使用<code>event_queue_insert_inserted</code>进行注册<br>这里的代码2.1.11 与书上的差别较大, 少了多一半的功能, 也没有被抽成函数, 暂不知道对应的功能代码去了哪里<br>照书上来说<code>event_queue_insert_inserted</code>实现的是将事件处理器加入到<code>event_base</code>的某个事件队列中. 对于新添加的IO和信号事件处理器, 还需要让事件多路分发器来监听对应的事件, 然后建立相应的映射关系. 分别使用<code>evmap_io_add_</code>和<code>evmap_signal_add_</code>(相当于图中的<code>register_event</code>)建立映射. </p>\n<p><code>evmap_io_add_</code>中有一个结构体<code>event_io_map</code><br><code>event_io_map</code>会根据不同的平台最终对应不同的数据结构</p>\n<p><code>evmap_io_add_</code>函数<br>函数中用到的东西, 我目前吸收不了……. 总之是为将IO事件处理器加入到<code>event_base</code>的事件队列中实现的</p>\n<p><code>eventop</code>结构体 是<code>event_base</code>中封装IO复用机制的结构体, 提供了统一的接口</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为给定的event_base声明后端的结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventop</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 后端IO复用技术的名称</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 初始化 函数需要初始化所有要用的属性</span></span><br><span class=\"line\">\t<span class=\"comment\">// 返回的指针会被event_init存储在event_base.evbase</span></span><br><span class=\"line\">\t<span class=\"comment\">// 失败后返回NULL</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *(*init)(struct event_base *);</span><br><span class=\"line\">\t<span class=\"comment\">// 注册事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*add)(struct event_base *, <span class=\"keyword\">evutil_socket_t</span> fd, short old, short events, <span class=\"keyword\">void</span> *fdinfo);</span><br><span class=\"line\">\t<span class=\"comment\">// 删除事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*del)(struct event_base *, <span class=\"keyword\">evutil_socket_t</span> fd, short old, short events, <span class=\"keyword\">void</span> *fdinfo);</span><br><span class=\"line\">\t<span class=\"comment\">// 等待事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*dispatch)(struct event_base *, struct timeval *);</span><br><span class=\"line\">\t<span class=\"comment\">// 释放IO复用机制使用的资源</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*dealloc)(struct event_base *);</span><br><span class=\"line\">\t<span class=\"comment\">// 标记fork后是否需要重新初始化event_base的标志位</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> need_reinit;</span><br><span class=\"line\">\t<span class=\"comment\">// 用于设定io复用技术支持的一些特性</span></span><br><span class=\"line\">\t<span class=\"keyword\">enum</span> event_method_feature features;</span><br><span class=\"line\">\t<span class=\"comment\">// 额外内存的分配</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> fdinfo_len;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>event_base</code>是Libevent的Reactor. 超长结构体 删除了我不理解的部分</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_base</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 记录选择的I/O复用机制</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventop</span> *<span class=\"title\">evsel</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向IO复用机制真正存储的数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *evbase;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 事件变换队列 如果一个文件描述符上注册的事件被多次修改, 则可以使用缓冲避免重复的系统调用</span></span><br><span class=\"line\">\t<span class=\"comment\">// 比如epoll_ctl, 仅能用于时间复杂度O(1)的IO复用技术</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_changelist</span> <span class=\"title\">changelist</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 信号的后端处理机制</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventop</span> *<span class=\"title\">evsigsel</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 信号事件处理器使用的数据结构, 其中封装了socketpair创建的管道. 用于信号处理函数和</span></span><br><span class=\"line\">\t<span class=\"comment\">// 事件多路分发器之间的通信, 统一事件源的思路</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evsig_info</span> <span class=\"title\">sig</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 添加到event_base的虚拟(所有, 激活)事件数量, 虚拟(所有, 激活)事件最大数量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> virtual_event_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> virtual_event_count_max;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count_max;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count_active;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count_active_max;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 处理完事件后 是否退出循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_gotterm;</span><br><span class=\"line\">\t<span class=\"comment\">// 是否立即终止循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_break;</span><br><span class=\"line\">\t<span class=\"comment\">// 是否启动一个新的事件循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_continue;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 当前正在处理的活动事件队列的优先级</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_running_priority;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 标记事件循环是否已经启动, 防止重入</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> running_loop;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 活动事件队列数组. 索引值越小的队列优先级越高. 高优先级的活动事件队列中的事件处理器被优先处理</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evcallback_list</span> *<span class=\"title\">activequeues</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 活动事件队列数组的大小 说明有nactivequeues个不同优先级的活动事件队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nactivequeues;</span><br><span class=\"line\">\t<span class=\"comment\">/** A list of event_callbacks that should become active the next time</span></span><br><span class=\"line\"><span class=\"comment\">\t * we process events, but not this time. */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evcallback_list</span> <span class=\"title\">active_later_queue</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 共同超时逻辑</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 管理通用定时器队列 实体数量 总数</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">common_timeout_list</span> **<span class=\"title\">common_timeout_queues</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n_common_timeouts;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n_common_timeouts_allocated;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 文件描述符和IO事件之间的映射关系表</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_io_map</span> <span class=\"title\">io</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 信号值和信号事件之间的映射关系表</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_signal_map</span> <span class=\"title\">sigmap</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 时间堆</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">min_heap</span> <span class=\"title\">timeheap</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 管理系统时间的成员</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv_cache</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evutil_monotonic_timer</span> <span class=\"title\">monotonic_timer</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv_clock_diff</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">time_t</span> last_updated_clock_diff;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> EVENT__DISABLE_THREAD_SUPPORT</span></span><br><span class=\"line\">\t<span class=\"comment\">// 多线程支持</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 当前运行该event_base的事件循环的线程</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> th_owner_id;</span><br><span class=\"line\">\t<span class=\"comment\">// 独占锁</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *th_base_lock;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前事件循环正在执行哪个事件处理器的回调函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *current_event_cond;</span><br><span class=\"line\">\t<span class=\"comment\">// 等待的线程数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> current_event_waiters;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"comment\">// 正在处理的事件处理器的回调函数</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_callback</span> *<span class=\"title\">current_event</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>事件循环, libevent的动力, 即事件循环</p>\n<p>这次读了一下helloworld的 这一部分代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span><br><span class=\"line\">listener_cb(struct evconnlistener *listener, <span class=\"keyword\">evutil_socket_t</span> fd,</span><br><span class=\"line\">    struct sockaddr *sa, <span class=\"keyword\">int</span> socklen, <span class=\"keyword\">void</span> *user_data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_base</span> *<span class=\"title\">base</span> = <span class=\"title\">user_data</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bufferevent</span> *<span class=\"title\">bev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tbev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!bev) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"Error constructing bufferevent!\"</span>);</span><br><span class=\"line\">\t\tevent_base_loopbreak(base);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置新创建的bufferevent的 读写回调函数 启动写事件 禁用读事件</span></span><br><span class=\"line\">\tbufferevent_setcb(bev, <span class=\"literal\">NULL</span>, conn_writecb, conn_eventcb, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\tbufferevent_enable(bev, EV_WRITE);</span><br><span class=\"line\">\tbufferevent_disable(bev, EV_READ);</span><br><span class=\"line\"></span><br><span class=\"line\">\tbufferevent_write(bev, MESSAGE, <span class=\"built_in\">strlen</span>(MESSAGE));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bufferevent_socket_new 创建了读和写event 设置了真实的回调函数<code>bufferevent_writecb</code>等 然后<br>bufferevent_enable是真正的事件注册函数， 将上面生成的event注册进入eventbase<br><code>EV_WRITE</code>对应的epoll事件是<code>EPOLLOUT</code><br><code>bufferevent_write</code>将要写出的数据放入到缓冲区中。 一旦epollwait返回了 就去调用<code>bufferevent_writecb</code>将缓冲区<br>的内容写出， 然后同时调用用户设置的回调函数</p>\n<p>2020年3月7日20:26:02<br>这次又读了下 系统是怎么区分不同事件来调用回调函数的, 结果返现框架将系统的事件类型对应成自己的事件类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (what &amp; (EPOLLHUP|EPOLLERR)) &#123;</span><br><span class=\"line\">\tev = EV_READ | EV_WRITE;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (what &amp; EPOLLIN)</span><br><span class=\"line\">\t\tev |= EV_READ;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (what &amp; EPOLLOUT)</span><br><span class=\"line\">\t\tev |= EV_WRITE;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (what &amp; EPOLLRDHUP)</span><br><span class=\"line\">\t\tev |= EV_CLOSED;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后传入<code>evmap_io_active_</code>函数, 进而将ev保存到<code>ev_res</code>中然后直接作为参数 传给了回调函数</p>\n","site":{"data":{}},"excerpt":"","more":"<p>学习来源<br>&lt;Linux 高性能服务器编程&gt;</p>\n<h1 id=\"I-O框架库概述\"><a href=\"#I-O框架库概述\" class=\"headerlink\" title=\"I/O框架库概述\"></a>I/O框架库概述</h1><h2 id=\"Reactor模式\"><a href=\"#Reactor模式\" class=\"headerlink\" title=\"Reactor模式\"></a>Reactor模式</h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-1IO%E6%A1%86%E6%9E%B6%E7%BB%84%E7%BB%84%E4%BB%B6.png\" alt=\"\"><br>句柄(Handler)<br>由于统一了事件源, 一个事件一般跟一个句柄绑定在一起, 事件就绪之后 会通过句柄通知这一个事件.<br>在Linux中 I/O 事件对应的句柄-&gt;文件描述符, 信号事件-&gt;信号值</p>\n<p>事件多路分发器(EventDemultiplexer)<br>事件的到来是随机的, 异步的. 所以只能通过一个循环一直等待事件并进行处理 — 事件循环<br>一般通过IO复用实现 select poll epoll_wait</p>\n<p>事件处理器(EventHandle)<br>具体事件处理器(ConcreteEventHandler)<br>事件处理器执行事件对应的业务逻辑, 通常包含一个或多个handler_event回调函数, 这些回调函数在事件循环中被执行</p>\n<p>Reactor<br>handler_events: 执行事件循环 重复等待事件, 然后依次调用对应的事件处理器<br>register_handler: 向事件多路分发器中注册事件<br>remove_handler: 从中删除一个事件</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-2%20IO%E6%A1%86%E6%9E%B6%E5%BA%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE.png\" alt=\"\"></p>\n<h2 id=\"Libevent源码分析\"><a href=\"#Libevent源码分析\" class=\"headerlink\" title=\"Libevent源码分析\"></a>Libevent源码分析</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/signal.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;event.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">signal_cb</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, short event, <span class=\"keyword\">void</span>* argc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    event_base* base = (event_base*)argc;</span><br><span class=\"line\">    timeval <span class=\"built_in\">delay</span> = &#123;<span class=\"number\">2</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Caught an interrupt signal\\n\"</span>);</span><br><span class=\"line\">    event_base_loopexit(base, &amp;<span class=\"built_in\">delay</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">timeout_cb</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, short event, <span class=\"keyword\">void</span>* argc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"timeout\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 相当于创建一个Reactor实例</span></span><br><span class=\"line\">    event_base* base = event_init();</span><br><span class=\"line\">    </span><br><span class=\"line\">    event* signal_event = evsignal_new(base, SIGINT, signal_cb, base);</span><br><span class=\"line\">    event_add(signal_event, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    event* timeout_event = evtimer_new(base, timeout_cb, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    timeval tv&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    event_add(timeout_event, &amp;tv);</span><br><span class=\"line\">    </span><br><span class=\"line\">    event_base_dispatch(base);</span><br><span class=\"line\">    event_free(signal_event);</span><br><span class=\"line\">    event_free(timeout_event);</span><br><span class=\"line\">    event_base_free(base);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建一个事件处理器 然后为绑定上相应的回调函数.<br>然后把这个事件处理器注册到事件队列中中,</p>\n<p>然后事件多路分发器依靠循环一直等待事件的到来, 事件到来后通知相应的事件处理器<br>Reactor则管理这些</p>\n<p>首先要去了解下 <code>事件处理器</code> 对应的就是event这个结构体</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_callback</span> <span class=\"title\">ev_evcallback</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 事件处理器从属的 event_base</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_base</span> *<span class=\"title\">ev_base</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 信号值 或者 文件描述符</span></span><br><span class=\"line\">\t<span class=\"keyword\">evutil_socket_t</span> ev_fd;</span><br><span class=\"line\">\t<span class=\"comment\">// 定时器的超时时间</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">ev_timeout</span>;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 仅用于定时事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 队列--指出在通用定时器中的位置</span></span><br><span class=\"line\">\t\tTAILQ_ENTRY(event) ev_next_with_common_timeout;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 时间堆--指出了在时间堆中的位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> min_heap_idx;</span><br><span class=\"line\">\t&#125; ev_timeout_pos;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 通过这个成员 将具有相同文件描述符的IO事件处理器串联起来</span></span><br><span class=\"line\">\t\t\tLIST_ENTRY (event) ev_io_next;</span><br><span class=\"line\">\t\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">ev_timeout</span>;</span></span><br><span class=\"line\">\t\t&#125; ev_io;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 相同信号的串联起来</span></span><br><span class=\"line\">\t\t\tLIST_ENTRY (event) ev_signal_next;</span><br><span class=\"line\">\t\t\tshort ev_ncalls;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* Allows deletes in callback */</span></span><br><span class=\"line\">\t\t\tshort *ev_pncalls;</span><br><span class=\"line\">\t\t&#125; ev_signal;</span><br><span class=\"line\">\t&#125; ev_;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 事件类型, 可以通过位处理设置非互斥事件</span></span><br><span class=\"line\">\tshort ev_events;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前激活事件的类型, 说明被激活的原因</span></span><br><span class=\"line\">\tshort ev_res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到其中有很多的属性, 三种事件对应的不同的属性.</p>\n<p>这些属性的填充函数<br><code>evsignal_new``evtimer_new</code>是宏 统一调用<code>event_new</code><br><code>event_new</code>调用<code>event_assign</code>来进行主要的填充</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;@通过宏封装注册函数</span><br><span class=\"line\"></span><br><span class=\"line\">一个事件生成函数 经过宏的封装(可以自动填充某些此事件用不到的参数)可以更方便的对应不同事件的生成, 既统一了注册, 又方便用户调用</span><br></pre></td></tr></table></figure>\n<p>属性之一便是回调函数, 事件回调函数有自己的规定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;@统一事件回调函数</span><br><span class=\"line\"></span><br><span class=\"line\">void (*callback)(evutil_socket_t, short, void *)</span><br><span class=\"line\">这样能够统一回调函数的格式, 同时方便管理</span><br></pre></td></tr></table></figure>\n<p>事件处理器创建完毕, 该把事件处理器添加到事件注册队列. 样例代码中通过的<code>event_add</code>函数来实现将事件处理器添加到事件注册队列<br><code>event_add</code>实际由<code>event_add_nolock_</code>实现 所以接下来是<code>event_add_nolock_</code>函数的说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;@事件处理器的分发实现</span><br><span class=\"line\">将传入的event按照不同类型的事件处理器 分别处理</span><br><span class=\"line\">(因为event_new已经填充了ev_events说明事件类型)</span><br><span class=\"line\"></span><br><span class=\"line\">IO事件 添加绑定</span><br><span class=\"line\">信号事件 绑定相应的信号</span><br><span class=\"line\">定时器 放入相关的的时间管理数据结构中</span><br></pre></td></tr></table></figure>\n<p>使用<code>event_queue_insert_inserted</code>进行注册<br>这里的代码2.1.11 与书上的差别较大, 少了多一半的功能, 也没有被抽成函数, 暂不知道对应的功能代码去了哪里<br>照书上来说<code>event_queue_insert_inserted</code>实现的是将事件处理器加入到<code>event_base</code>的某个事件队列中. 对于新添加的IO和信号事件处理器, 还需要让事件多路分发器来监听对应的事件, 然后建立相应的映射关系. 分别使用<code>evmap_io_add_</code>和<code>evmap_signal_add_</code>(相当于图中的<code>register_event</code>)建立映射. </p>\n<p><code>evmap_io_add_</code>中有一个结构体<code>event_io_map</code><br><code>event_io_map</code>会根据不同的平台最终对应不同的数据结构</p>\n<p><code>evmap_io_add_</code>函数<br>函数中用到的东西, 我目前吸收不了……. 总之是为将IO事件处理器加入到<code>event_base</code>的事件队列中实现的</p>\n<p><code>eventop</code>结构体 是<code>event_base</code>中封装IO复用机制的结构体, 提供了统一的接口</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为给定的event_base声明后端的结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventop</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 后端IO复用技术的名称</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 初始化 函数需要初始化所有要用的属性</span></span><br><span class=\"line\">\t<span class=\"comment\">// 返回的指针会被event_init存储在event_base.evbase</span></span><br><span class=\"line\">\t<span class=\"comment\">// 失败后返回NULL</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *(*init)(struct event_base *);</span><br><span class=\"line\">\t<span class=\"comment\">// 注册事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*add)(struct event_base *, <span class=\"keyword\">evutil_socket_t</span> fd, short old, short events, <span class=\"keyword\">void</span> *fdinfo);</span><br><span class=\"line\">\t<span class=\"comment\">// 删除事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*del)(struct event_base *, <span class=\"keyword\">evutil_socket_t</span> fd, short old, short events, <span class=\"keyword\">void</span> *fdinfo);</span><br><span class=\"line\">\t<span class=\"comment\">// 等待事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*dispatch)(struct event_base *, struct timeval *);</span><br><span class=\"line\">\t<span class=\"comment\">// 释放IO复用机制使用的资源</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*dealloc)(struct event_base *);</span><br><span class=\"line\">\t<span class=\"comment\">// 标记fork后是否需要重新初始化event_base的标志位</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> need_reinit;</span><br><span class=\"line\">\t<span class=\"comment\">// 用于设定io复用技术支持的一些特性</span></span><br><span class=\"line\">\t<span class=\"keyword\">enum</span> event_method_feature features;</span><br><span class=\"line\">\t<span class=\"comment\">// 额外内存的分配</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> fdinfo_len;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>event_base</code>是Libevent的Reactor. 超长结构体 删除了我不理解的部分</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_base</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 记录选择的I/O复用机制</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventop</span> *<span class=\"title\">evsel</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向IO复用机制真正存储的数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *evbase;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 事件变换队列 如果一个文件描述符上注册的事件被多次修改, 则可以使用缓冲避免重复的系统调用</span></span><br><span class=\"line\">\t<span class=\"comment\">// 比如epoll_ctl, 仅能用于时间复杂度O(1)的IO复用技术</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_changelist</span> <span class=\"title\">changelist</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 信号的后端处理机制</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventop</span> *<span class=\"title\">evsigsel</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 信号事件处理器使用的数据结构, 其中封装了socketpair创建的管道. 用于信号处理函数和</span></span><br><span class=\"line\">\t<span class=\"comment\">// 事件多路分发器之间的通信, 统一事件源的思路</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evsig_info</span> <span class=\"title\">sig</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 添加到event_base的虚拟(所有, 激活)事件数量, 虚拟(所有, 激活)事件最大数量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> virtual_event_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> virtual_event_count_max;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count_max;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count_active;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count_active_max;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 处理完事件后 是否退出循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_gotterm;</span><br><span class=\"line\">\t<span class=\"comment\">// 是否立即终止循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_break;</span><br><span class=\"line\">\t<span class=\"comment\">// 是否启动一个新的事件循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_continue;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 当前正在处理的活动事件队列的优先级</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_running_priority;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 标记事件循环是否已经启动, 防止重入</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> running_loop;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 活动事件队列数组. 索引值越小的队列优先级越高. 高优先级的活动事件队列中的事件处理器被优先处理</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evcallback_list</span> *<span class=\"title\">activequeues</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 活动事件队列数组的大小 说明有nactivequeues个不同优先级的活动事件队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nactivequeues;</span><br><span class=\"line\">\t<span class=\"comment\">/** A list of event_callbacks that should become active the next time</span></span><br><span class=\"line\"><span class=\"comment\">\t * we process events, but not this time. */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evcallback_list</span> <span class=\"title\">active_later_queue</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 共同超时逻辑</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 管理通用定时器队列 实体数量 总数</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">common_timeout_list</span> **<span class=\"title\">common_timeout_queues</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n_common_timeouts;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n_common_timeouts_allocated;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 文件描述符和IO事件之间的映射关系表</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_io_map</span> <span class=\"title\">io</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 信号值和信号事件之间的映射关系表</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_signal_map</span> <span class=\"title\">sigmap</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 时间堆</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">min_heap</span> <span class=\"title\">timeheap</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 管理系统时间的成员</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv_cache</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evutil_monotonic_timer</span> <span class=\"title\">monotonic_timer</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv_clock_diff</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">time_t</span> last_updated_clock_diff;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> EVENT__DISABLE_THREAD_SUPPORT</span></span><br><span class=\"line\">\t<span class=\"comment\">// 多线程支持</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 当前运行该event_base的事件循环的线程</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> th_owner_id;</span><br><span class=\"line\">\t<span class=\"comment\">// 独占锁</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *th_base_lock;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前事件循环正在执行哪个事件处理器的回调函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *current_event_cond;</span><br><span class=\"line\">\t<span class=\"comment\">// 等待的线程数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> current_event_waiters;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"comment\">// 正在处理的事件处理器的回调函数</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_callback</span> *<span class=\"title\">current_event</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>事件循环, libevent的动力, 即事件循环</p>\n<p>这次读了一下helloworld的 这一部分代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span><br><span class=\"line\">listener_cb(struct evconnlistener *listener, <span class=\"keyword\">evutil_socket_t</span> fd,</span><br><span class=\"line\">    struct sockaddr *sa, <span class=\"keyword\">int</span> socklen, <span class=\"keyword\">void</span> *user_data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_base</span> *<span class=\"title\">base</span> = <span class=\"title\">user_data</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bufferevent</span> *<span class=\"title\">bev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tbev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!bev) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"Error constructing bufferevent!\"</span>);</span><br><span class=\"line\">\t\tevent_base_loopbreak(base);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置新创建的bufferevent的 读写回调函数 启动写事件 禁用读事件</span></span><br><span class=\"line\">\tbufferevent_setcb(bev, <span class=\"literal\">NULL</span>, conn_writecb, conn_eventcb, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\tbufferevent_enable(bev, EV_WRITE);</span><br><span class=\"line\">\tbufferevent_disable(bev, EV_READ);</span><br><span class=\"line\"></span><br><span class=\"line\">\tbufferevent_write(bev, MESSAGE, <span class=\"built_in\">strlen</span>(MESSAGE));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bufferevent_socket_new 创建了读和写event 设置了真实的回调函数<code>bufferevent_writecb</code>等 然后<br>bufferevent_enable是真正的事件注册函数， 将上面生成的event注册进入eventbase<br><code>EV_WRITE</code>对应的epoll事件是<code>EPOLLOUT</code><br><code>bufferevent_write</code>将要写出的数据放入到缓冲区中。 一旦epollwait返回了 就去调用<code>bufferevent_writecb</code>将缓冲区<br>的内容写出， 然后同时调用用户设置的回调函数</p>\n<p>2020年3月7日20:26:02<br>这次又读了下 系统是怎么区分不同事件来调用回调函数的, 结果返现框架将系统的事件类型对应成自己的事件类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (what &amp; (EPOLLHUP|EPOLLERR)) &#123;</span><br><span class=\"line\">\tev = EV_READ | EV_WRITE;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (what &amp; EPOLLIN)</span><br><span class=\"line\">\t\tev |= EV_READ;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (what &amp; EPOLLOUT)</span><br><span class=\"line\">\t\tev |= EV_WRITE;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (what &amp; EPOLLRDHUP)</span><br><span class=\"line\">\t\tev |= EV_CLOSED;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后传入<code>evmap_io_active_</code>函数, 进而将ev保存到<code>ev_res</code>中然后直接作为参数 传给了回调函数</p>\n"},{"title":"牛客整理","date":"2019-10-19T04:31:37.000Z","_content":"\n# 运算出结果类\n```c++\nchar a=101;\nint sum=200;\na+=27;sum+=a;\nprintf(\"%d\\n\",sum);\n```\na为 -128~127 \n 127  = 0111 1111\n\"128\"= 1000 0000 (-128的补码)\n\n关于1000 0000代表-128 我偶然发现一个博客有种恍然大悟的感觉\n[浅析为什么char类型的范围是 —128~+127](https://blog.csdn.net/daiyutage/article/details/8575248)\n这个博客实在是写的太好了\n\n---\n```c++\nchar a,b,c,d;\nscanf(\"%c,%c,%d,%d\",&a,&b,&c,&d);\nprintf(\"%c,%c,%c,%c\",a,b,c,d);\n}\n```\n%c进行输入会进行转化后存入\n输入 1 即认为输入 '1' 转换成49存入\n\n---\n\n# 类相关\n## 虚函数\n纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。\n凡是含有纯虚函数的类叫做 抽象类 。这种类不能声明对象，只是作为基类为派生类服务.\n除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。\n\n## 静态\n静态成员可以作为默认实参\n\n# 定义类\n\n# 基础中的基础\n这部分有些只保留题目, 不做解析 便于自己想象\n```c++\nunsigned int k = 20;\nwhile (k >= 0)\n{\n\t--k;\n}\n```\n\n下面三个函数全部错误\n```\nvoid test1()\n{\n    unsigned char array[MAX_CHAR+1],i; // 这个函数在于MAX_CHAR可能会大于255导致i永远无法达到\n    for(i=0;i<=MAX_CHAR;i++){\n        array[i]=i;\n    }\n}\nchar*test2()\n{\n    char p[] = \"hello world\";\n    return p;\n}\nchar *p =test2();\nvoid test3(){\n    char str[10];\n    str++;\n    *str='0';\n}\n```\n---\n\n# 基础中的Api\n虽然自己还没用过, 但还是要积累\n```c++\nfor(i=4;i>1;i--)\n{\n\tfor(j=1;j<i;j++)\n\t{\n\t\tputchar('#');\n\t}\n}\n```\n开始看到这个题目, 为putchar是放到缓冲区中, 结果就是正常的输出\n","source":"_posts/CPP-牛客.md","raw":"---\ntitle: 牛客整理\ntags:\n  - null\ncategories:\n  - CPP\ndate: 2019-10-19 12:31:37\n---\n\n# 运算出结果类\n```c++\nchar a=101;\nint sum=200;\na+=27;sum+=a;\nprintf(\"%d\\n\",sum);\n```\na为 -128~127 \n 127  = 0111 1111\n\"128\"= 1000 0000 (-128的补码)\n\n关于1000 0000代表-128 我偶然发现一个博客有种恍然大悟的感觉\n[浅析为什么char类型的范围是 —128~+127](https://blog.csdn.net/daiyutage/article/details/8575248)\n这个博客实在是写的太好了\n\n---\n```c++\nchar a,b,c,d;\nscanf(\"%c,%c,%d,%d\",&a,&b,&c,&d);\nprintf(\"%c,%c,%c,%c\",a,b,c,d);\n}\n```\n%c进行输入会进行转化后存入\n输入 1 即认为输入 '1' 转换成49存入\n\n---\n\n# 类相关\n## 虚函数\n纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。\n凡是含有纯虚函数的类叫做 抽象类 。这种类不能声明对象，只是作为基类为派生类服务.\n除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。\n\n## 静态\n静态成员可以作为默认实参\n\n# 定义类\n\n# 基础中的基础\n这部分有些只保留题目, 不做解析 便于自己想象\n```c++\nunsigned int k = 20;\nwhile (k >= 0)\n{\n\t--k;\n}\n```\n\n下面三个函数全部错误\n```\nvoid test1()\n{\n    unsigned char array[MAX_CHAR+1],i; // 这个函数在于MAX_CHAR可能会大于255导致i永远无法达到\n    for(i=0;i<=MAX_CHAR;i++){\n        array[i]=i;\n    }\n}\nchar*test2()\n{\n    char p[] = \"hello world\";\n    return p;\n}\nchar *p =test2();\nvoid test3(){\n    char str[10];\n    str++;\n    *str='0';\n}\n```\n---\n\n# 基础中的Api\n虽然自己还没用过, 但还是要积累\n```c++\nfor(i=4;i>1;i--)\n{\n\tfor(j=1;j<i;j++)\n\t{\n\t\tputchar('#');\n\t}\n}\n```\n开始看到这个题目, 为putchar是放到缓冲区中, 结果就是正常的输出\n","slug":"CPP-牛客","published":1,"updated":"2020-12-05T02:26:20.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg5z000df8un7lugd7j4","content":"<h1 id=\"运算出结果类\"><a href=\"#运算出结果类\" class=\"headerlink\" title=\"运算出结果类\"></a>运算出结果类</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a=<span class=\"number\">101</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum=<span class=\"number\">200</span>;</span><br><span class=\"line\">a+=<span class=\"number\">27</span>;sum+=a;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,sum);</span><br></pre></td></tr></table></figure>\n<p>a为 -128~127<br> 127  = 0111 1111<br>“128”= 1000 0000 (-128的补码)</p>\n<p>关于1000 0000代表-128 我偶然发现一个博客有种恍然大悟的感觉<br><a href=\"https://blog.csdn.net/daiyutage/article/details/8575248\" target=\"_blank\" rel=\"noopener\">浅析为什么char类型的范围是 —128~+127</a><br>这个博客实在是写的太好了</p>\n<hr>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a,b,c,d;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c,%c,%d,%d\"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%c,%c,%c,%c\"</span>,a,b,c,d);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>%c进行输入会进行转化后存入<br>输入 1 即认为输入 ‘1’ 转换成49存入</p>\n<hr>\n<h1 id=\"类相关\"><a href=\"#类相关\" class=\"headerlink\" title=\"类相关\"></a>类相关</h1><h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。<br>凡是含有纯虚函数的类叫做 抽象类 。这种类不能声明对象，只是作为基类为派生类服务.<br>除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</p>\n<h2 id=\"静态\"><a href=\"#静态\" class=\"headerlink\" title=\"静态\"></a>静态</h2><p>静态成员可以作为默认实参</p>\n<h1 id=\"定义类\"><a href=\"#定义类\" class=\"headerlink\" title=\"定义类\"></a>定义类</h1><h1 id=\"基础中的基础\"><a href=\"#基础中的基础\" class=\"headerlink\" title=\"基础中的基础\"></a>基础中的基础</h1><p>这部分有些只保留题目, 不做解析 便于自己想象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> k = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (k &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t--k;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面三个函数全部错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test1()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned char array[MAX_CHAR+1],i; &#x2F;&#x2F; 这个函数在于MAX_CHAR可能会大于255导致i永远无法达到</span><br><span class=\"line\">    for(i&#x3D;0;i&lt;&#x3D;MAX_CHAR;i++)&#123;</span><br><span class=\"line\">        array[i]&#x3D;i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">char*test2()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char p[] &#x3D; &quot;hello world&quot;;</span><br><span class=\"line\">    return p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">char *p &#x3D;test2();</span><br><span class=\"line\">void test3()&#123;</span><br><span class=\"line\">    char str[10];</span><br><span class=\"line\">    str++;</span><br><span class=\"line\">    *str&#x3D;&#39;0&#39;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"基础中的Api\"><a href=\"#基础中的Api\" class=\"headerlink\" title=\"基础中的Api\"></a>基础中的Api</h1><p>虽然自己还没用过, 但还是要积累</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">4</span>;i&gt;<span class=\"number\">1</span>;i--)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(j=<span class=\"number\">1</span>;j&lt;i;j++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">putchar</span>(<span class=\"string\">'#'</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>开始看到这个题目, 为putchar是放到缓冲区中, 结果就是正常的输出</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"运算出结果类\"><a href=\"#运算出结果类\" class=\"headerlink\" title=\"运算出结果类\"></a>运算出结果类</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a=<span class=\"number\">101</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum=<span class=\"number\">200</span>;</span><br><span class=\"line\">a+=<span class=\"number\">27</span>;sum+=a;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,sum);</span><br></pre></td></tr></table></figure>\n<p>a为 -128~127<br> 127  = 0111 1111<br>“128”= 1000 0000 (-128的补码)</p>\n<p>关于1000 0000代表-128 我偶然发现一个博客有种恍然大悟的感觉<br><a href=\"https://blog.csdn.net/daiyutage/article/details/8575248\" target=\"_blank\" rel=\"noopener\">浅析为什么char类型的范围是 —128~+127</a><br>这个博客实在是写的太好了</p>\n<hr>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a,b,c,d;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c,%c,%d,%d\"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%c,%c,%c,%c\"</span>,a,b,c,d);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>%c进行输入会进行转化后存入<br>输入 1 即认为输入 ‘1’ 转换成49存入</p>\n<hr>\n<h1 id=\"类相关\"><a href=\"#类相关\" class=\"headerlink\" title=\"类相关\"></a>类相关</h1><h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。<br>凡是含有纯虚函数的类叫做 抽象类 。这种类不能声明对象，只是作为基类为派生类服务.<br>除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</p>\n<h2 id=\"静态\"><a href=\"#静态\" class=\"headerlink\" title=\"静态\"></a>静态</h2><p>静态成员可以作为默认实参</p>\n<h1 id=\"定义类\"><a href=\"#定义类\" class=\"headerlink\" title=\"定义类\"></a>定义类</h1><h1 id=\"基础中的基础\"><a href=\"#基础中的基础\" class=\"headerlink\" title=\"基础中的基础\"></a>基础中的基础</h1><p>这部分有些只保留题目, 不做解析 便于自己想象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> k = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (k &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t--k;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面三个函数全部错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test1()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned char array[MAX_CHAR+1],i; &#x2F;&#x2F; 这个函数在于MAX_CHAR可能会大于255导致i永远无法达到</span><br><span class=\"line\">    for(i&#x3D;0;i&lt;&#x3D;MAX_CHAR;i++)&#123;</span><br><span class=\"line\">        array[i]&#x3D;i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">char*test2()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char p[] &#x3D; &quot;hello world&quot;;</span><br><span class=\"line\">    return p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">char *p &#x3D;test2();</span><br><span class=\"line\">void test3()&#123;</span><br><span class=\"line\">    char str[10];</span><br><span class=\"line\">    str++;</span><br><span class=\"line\">    *str&#x3D;&#39;0&#39;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"基础中的Api\"><a href=\"#基础中的Api\" class=\"headerlink\" title=\"基础中的Api\"></a>基础中的Api</h1><p>虽然自己还没用过, 但还是要积累</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">4</span>;i&gt;<span class=\"number\">1</span>;i--)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(j=<span class=\"number\">1</span>;j&lt;i;j++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">putchar</span>(<span class=\"string\">'#'</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>开始看到这个题目, 为putchar是放到缓冲区中, 结果就是正常的输出</p>\n"},{"title":"编程规范","date":"2020-05-02T09:03:25.194Z","_content":"\n**第一点**\n有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. \n```c++\n// 推荐\nnamespace myproject {\nnamespace foo_bar {\nvoid Function1();\nvoid Function2();\n}  // namespace foo_bar\n}  // namespace myproject\n\n// 不推荐\nnamespace myproject {\nclass FooBar {\n public:\n  static void Function1();\n  static void Function2();\n};\n}  // namespace myproject\n```\n\n**第二点**\n局部变量应当声明和初始化同时进行, 推荐使用C++11的花括号\n\n*如果在循环中, 不要将对象的声明放入其中*, 每次进入作用域都会调用构造函数, 每次退出都会调用析构函数\n\n**第三点-类相关**\n不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.\n\n不要定义隐式类型转换. \n\n对于转换运算符和单参数构造函数, 请使用 explicit 关键字.\n- 单参数构造函数有可能会被无意地用作隐式类型转换.\n\n如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.\n- MyClass(const MyClass&) = delete;\n- MyClass& operator=(const MyClass&) = delete;\n\n仅当`只有`数据成员的时候`struct`, `其他一律`使用class\n\n使用组合常常比使用继承更合理\n- 所有的继承`必须是public`, \n\n多重继承(真正需要的时候很少)\n- 最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.\n\n除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量\n- 重载运算符, 容易造成代码混乱, 因为没有统一的重载规范\n\n数据成员都必须是私有的\n\n**第四点-函数相关**\n\n输入参数在先, 后跟输出参数.\n\n编写简短函数\n\n所有按引用传递的参数必须加上 const.\n\n函数重载\n- 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,\n而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.\n- 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.\n\n省却参数\n\n函数返回类型后置语法\n- `auto foo(int x) -> int` 对于简单的类型, 优点体现不出\n- 对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别?????.\n\n**杂项**\n在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。\n\n**第五点命名-版本最多的地方**\n\n文件命名\n- 全部小写包含`_`最好\n- C++ 文件要以 .cc 结尾, 头文件以 .h 结尾.\n\n类型名称 - 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数\n- 类型名称的每个单词首字母均大写, 不包含下划线`MyExcitingClass`\n\n变量命名\n- 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾\n\n常量命名\n- 全部大写\n- 声明为 constexpr 或 const\n\n函数命名\n- 每个单词首字母大写, 没有下划线\n- 首字母缩写的单词, 经常对其的第一个字母大写\n\n命名空间命名\n- 小写字母命名\n\n枚举命名\n- 枚举的命名应当和 常量 或 宏 一致\n\n**第六点-格式**\n\n缩进四个空格\n\n函数定义与声明\n- 左圆括号总是和函数名在同一行.(没有标准,,,,,,,,,, emmm 我想我还是换行吧)\n- 函数名和左圆括号间永远没有空格.\n- 圆括号与参数间没有空格.\n\n","source":"_posts/CPP-编程规范.md","raw":"title: 编程规范\ntags:\n  - null\ncategories:\n  - CPP\ndate: 2019-10-2518:06:46\n---\n\n**第一点**\n有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. \n```c++\n// 推荐\nnamespace myproject {\nnamespace foo_bar {\nvoid Function1();\nvoid Function2();\n}  // namespace foo_bar\n}  // namespace myproject\n\n// 不推荐\nnamespace myproject {\nclass FooBar {\n public:\n  static void Function1();\n  static void Function2();\n};\n}  // namespace myproject\n```\n\n**第二点**\n局部变量应当声明和初始化同时进行, 推荐使用C++11的花括号\n\n*如果在循环中, 不要将对象的声明放入其中*, 每次进入作用域都会调用构造函数, 每次退出都会调用析构函数\n\n**第三点-类相关**\n不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.\n\n不要定义隐式类型转换. \n\n对于转换运算符和单参数构造函数, 请使用 explicit 关键字.\n- 单参数构造函数有可能会被无意地用作隐式类型转换.\n\n如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.\n- MyClass(const MyClass&) = delete;\n- MyClass& operator=(const MyClass&) = delete;\n\n仅当`只有`数据成员的时候`struct`, `其他一律`使用class\n\n使用组合常常比使用继承更合理\n- 所有的继承`必须是public`, \n\n多重继承(真正需要的时候很少)\n- 最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.\n\n除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量\n- 重载运算符, 容易造成代码混乱, 因为没有统一的重载规范\n\n数据成员都必须是私有的\n\n**第四点-函数相关**\n\n输入参数在先, 后跟输出参数.\n\n编写简短函数\n\n所有按引用传递的参数必须加上 const.\n\n函数重载\n- 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,\n而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.\n- 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.\n\n省却参数\n\n函数返回类型后置语法\n- `auto foo(int x) -> int` 对于简单的类型, 优点体现不出\n- 对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别?????.\n\n**杂项**\n在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。\n\n**第五点命名-版本最多的地方**\n\n文件命名\n- 全部小写包含`_`最好\n- C++ 文件要以 .cc 结尾, 头文件以 .h 结尾.\n\n类型名称 - 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数\n- 类型名称的每个单词首字母均大写, 不包含下划线`MyExcitingClass`\n\n变量命名\n- 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾\n\n常量命名\n- 全部大写\n- 声明为 constexpr 或 const\n\n函数命名\n- 每个单词首字母大写, 没有下划线\n- 首字母缩写的单词, 经常对其的第一个字母大写\n\n命名空间命名\n- 小写字母命名\n\n枚举命名\n- 枚举的命名应当和 常量 或 宏 一致\n\n**第六点-格式**\n\n缩进四个空格\n\n函数定义与声明\n- 左圆括号总是和函数名在同一行.(没有标准,,,,,,,,,, emmm 我想我还是换行吧)\n- 函数名和左圆括号间永远没有空格.\n- 圆括号与参数间没有空格.\n\n","slug":"CPP-编程规范","published":1,"updated":"2020-12-05T02:26:20.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg60000gf8unap3ebblh","content":"<p><strong>第一点</strong><br>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 推荐</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> myproject &#123;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> foo_bar &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Function1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Function2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace foo_bar</span></span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace myproject</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不推荐</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> myproject &#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooBar</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Function1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Function2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace myproject</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>第二点</strong><br>局部变量应当声明和初始化同时进行, 推荐使用C++11的花括号</p>\n<p><em>如果在循环中, 不要将对象的声明放入其中</em>, 每次进入作用域都会调用构造函数, 每次退出都会调用析构函数</p>\n<p><strong>第三点-类相关</strong><br>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p>\n<p>不要定义隐式类型转换. </p>\n<p>对于转换运算符和单参数构造函数, 请使用 explicit 关键字.</p>\n<ul>\n<li>单参数构造函数有可能会被无意地用作隐式类型转换.</li>\n</ul>\n<p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p>\n<ul>\n<li>MyClass(const MyClass&amp;) = delete;</li>\n<li>MyClass&amp; operator=(const MyClass&amp;) = delete;</li>\n</ul>\n<p>仅当<code>只有</code>数据成员的时候<code>struct</code>, <code>其他一律</code>使用class</p>\n<p>使用组合常常比使用继承更合理</p>\n<ul>\n<li>所有的继承<code>必须是public</code>, </li>\n</ul>\n<p>多重继承(真正需要的时候很少)</p>\n<ul>\n<li>最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.</li>\n</ul>\n<p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量</p>\n<ul>\n<li>重载运算符, 容易造成代码混乱, 因为没有统一的重载规范</li>\n</ul>\n<p>数据成员都必须是私有的</p>\n<p><strong>第四点-函数相关</strong></p>\n<p>输入参数在先, 后跟输出参数.</p>\n<p>编写简短函数</p>\n<p>所有按引用传递的参数必须加上 const.</p>\n<p>函数重载</p>\n<ul>\n<li>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,<br>而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</li>\n<li>如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.</li>\n</ul>\n<p>省却参数</p>\n<p>函数返回类型后置语法</p>\n<ul>\n<li><code>auto foo(int x) -&gt; int</code> 对于简单的类型, 优点体现不出</li>\n<li>对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别?????.</li>\n</ul>\n<p><strong>杂项</strong><br>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p>\n<p><strong>第五点命名-版本最多的地方</strong></p>\n<p>文件命名</p>\n<ul>\n<li>全部小写包含<code>_</code>最好</li>\n<li>C++ 文件要以 .cc 结尾, 头文件以 .h 结尾.</li>\n</ul>\n<p>类型名称 - 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数</p>\n<ul>\n<li>类型名称的每个单词首字母均大写, 不包含下划线<code>MyExcitingClass</code></li>\n</ul>\n<p>变量命名</p>\n<ul>\n<li>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾</li>\n</ul>\n<p>常量命名</p>\n<ul>\n<li>全部大写</li>\n<li>声明为 constexpr 或 const</li>\n</ul>\n<p>函数命名</p>\n<ul>\n<li>每个单词首字母大写, 没有下划线</li>\n<li>首字母缩写的单词, 经常对其的第一个字母大写</li>\n</ul>\n<p>命名空间命名</p>\n<ul>\n<li>小写字母命名</li>\n</ul>\n<p>枚举命名</p>\n<ul>\n<li>枚举的命名应当和 常量 或 宏 一致</li>\n</ul>\n<p><strong>第六点-格式</strong></p>\n<p>缩进四个空格</p>\n<p>函数定义与声明</p>\n<ul>\n<li>左圆括号总是和函数名在同一行.(没有标准,,,,,,,,,, emmm 我想我还是换行吧)</li>\n<li>函数名和左圆括号间永远没有空格.</li>\n<li>圆括号与参数间没有空格.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>第一点</strong><br>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 推荐</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> myproject &#123;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> foo_bar &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Function1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Function2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace foo_bar</span></span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace myproject</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不推荐</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> myproject &#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooBar</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Function1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Function2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace myproject</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>第二点</strong><br>局部变量应当声明和初始化同时进行, 推荐使用C++11的花括号</p>\n<p><em>如果在循环中, 不要将对象的声明放入其中</em>, 每次进入作用域都会调用构造函数, 每次退出都会调用析构函数</p>\n<p><strong>第三点-类相关</strong><br>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p>\n<p>不要定义隐式类型转换. </p>\n<p>对于转换运算符和单参数构造函数, 请使用 explicit 关键字.</p>\n<ul>\n<li>单参数构造函数有可能会被无意地用作隐式类型转换.</li>\n</ul>\n<p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p>\n<ul>\n<li>MyClass(const MyClass&amp;) = delete;</li>\n<li>MyClass&amp; operator=(const MyClass&amp;) = delete;</li>\n</ul>\n<p>仅当<code>只有</code>数据成员的时候<code>struct</code>, <code>其他一律</code>使用class</p>\n<p>使用组合常常比使用继承更合理</p>\n<ul>\n<li>所有的继承<code>必须是public</code>, </li>\n</ul>\n<p>多重继承(真正需要的时候很少)</p>\n<ul>\n<li>最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.</li>\n</ul>\n<p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量</p>\n<ul>\n<li>重载运算符, 容易造成代码混乱, 因为没有统一的重载规范</li>\n</ul>\n<p>数据成员都必须是私有的</p>\n<p><strong>第四点-函数相关</strong></p>\n<p>输入参数在先, 后跟输出参数.</p>\n<p>编写简短函数</p>\n<p>所有按引用传递的参数必须加上 const.</p>\n<p>函数重载</p>\n<ul>\n<li>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,<br>而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</li>\n<li>如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.</li>\n</ul>\n<p>省却参数</p>\n<p>函数返回类型后置语法</p>\n<ul>\n<li><code>auto foo(int x) -&gt; int</code> 对于简单的类型, 优点体现不出</li>\n<li>对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别?????.</li>\n</ul>\n<p><strong>杂项</strong><br>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p>\n<p><strong>第五点命名-版本最多的地方</strong></p>\n<p>文件命名</p>\n<ul>\n<li>全部小写包含<code>_</code>最好</li>\n<li>C++ 文件要以 .cc 结尾, 头文件以 .h 结尾.</li>\n</ul>\n<p>类型名称 - 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数</p>\n<ul>\n<li>类型名称的每个单词首字母均大写, 不包含下划线<code>MyExcitingClass</code></li>\n</ul>\n<p>变量命名</p>\n<ul>\n<li>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾</li>\n</ul>\n<p>常量命名</p>\n<ul>\n<li>全部大写</li>\n<li>声明为 constexpr 或 const</li>\n</ul>\n<p>函数命名</p>\n<ul>\n<li>每个单词首字母大写, 没有下划线</li>\n<li>首字母缩写的单词, 经常对其的第一个字母大写</li>\n</ul>\n<p>命名空间命名</p>\n<ul>\n<li>小写字母命名</li>\n</ul>\n<p>枚举命名</p>\n<ul>\n<li>枚举的命名应当和 常量 或 宏 一致</li>\n</ul>\n<p><strong>第六点-格式</strong></p>\n<p>缩进四个空格</p>\n<p>函数定义与声明</p>\n<ul>\n<li>左圆括号总是和函数名在同一行.(没有标准,,,,,,,,,, emmm 我想我还是换行吧)</li>\n<li>函数名和左圆括号间永远没有空格.</li>\n<li>圆括号与参数间没有空格.</li>\n</ul>\n"},{"title":"分支管理和实际应用","date":"2020-03-06T11:34:25.000Z","_content":"\n2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄... 来更新下\n2020年7月29日10:53:32 更新 删除一些无意义的话....\n\n# 分支管理\n\n`git checkout -b dev`相当于一下两条命令\n`git branch dev` 分支创建\n`git checkout dev` 分支切换\n\n`git branch -d dev` 分支删除\n\n`git branch` 查看当前所有分支\n\n`git merge dev` 将制定的dev分支合并到当前的分支\n\n**冲突解决**\n\n`git merge dev` 将制定的dev分支合并到当前的分支\n```\n1 111111111111111\n2 222222222222222\n3 333333333333333\n4 444444444444444\n5 <<<<<<< HEAD  # 我在master分支下添加了6666666 并提交\n6 6666666\n7 =======\n8 7777777\n9 >>>>>>> deb # 我在deb分支下添加了7777777 并提交\n```\n最后需要我手动修改这个文件为自己需要的内容 然后提交即可\n  \n**分支管理**\n\n通常Git会使用`Fast forward`模式 这样删除分支后会丢失分支的信息\n可以再merge的时候加入`--no-ff`这样就能解决问题\n`git merge --no-ff -m \"merge with no-ff\" dev`\n由于禁用`Fast forward`后\n会生成新的commit所以需要加入` -m \"merge with no-ff\"`\n\n**暂存代码**\n\ngit stash 可以储存当前的工作区 恢复到上一次commit后\ngit stash list 查看储存的工作区列表\ngit stash apply stash@{0} 恢复指定的储存\ngit stash pop 恢复并drop最近的存储 慎用这个 建议使用上边的\n\n  \n# 实际工作中分支的应用\n[主要参考](https://zhuanlan.zhihu.com/p/38772378)\n\n**主分支**\n- **master**: 这个分支最稳定, 相当于放的可发布版本\n- **develop**: 开发分支, 平行于master分支, 负责合并各种`用于开发子功能`的分支\n\n**支持分支**:解决某个问题, 结束后合并回`master`或`develop`分支\n- **feature**功能分支, 用于开发一个个子功能, 来自`develop`合并到`develop`去\n- **release**:发布分支, 用于修改版本号等小修改, 来自`develop`分支合并到`master`分支\n- **hotfixes**:紧急修复bug分支, 从`master`创建, 合并回`develop`分支和`master`分支\n![](https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg)\n\n\n[Git 分支管理规范](https://juejin.im/post/5d82e1f3e51d4561d044cd88#heading-14)\n\n[Git 基础 - 打标签](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE)\n\n\n**develop分支完成了操作, 准备发布新的版本**\n```shell\n# 从 develop 分支上创建 release 分支:\n# 命名规则如下 release-事件-版本\ngit checkout –b release-20190919-v1.0.0 develop\n\n# 修复完release的bug后再次提交修改:\ngit checkout release-20190919-v1.0.0\n# 提交本地修改, 如果没有修改bug 可以跳过\ngit add .\ngit commit –m “提交日志”\n# 推送 release 分支\ngit push origin release-20190919-v1.0.0\n\n# 发布新版本\n# 合并 release 分支到 master 分支:\ngit checkout master\ngit merge --no-ff release-20190919-v1.0.0\n# 合并 release 分支到 develop 分支:\ngit checkout develop\ngit merge --no-ff release-20190919-v1.0.0\n# 在 master 分支上创建标签:\ngit tag tag-20190919-v1.0.0\n# 删除本地 release 分支:\ngit branch –d release-20190919-v1.0.0\n# 删除远程 release 分支:\ngit push origin :release-20190919-v1.0.0\n```\n\n新版本完成之后\n```shell\n# 推送master分支\ngit push origin master\n\n# 注意上边打的tag需要手动提交 默认push不会提交tag\ngit push origin [tag name]\n# 也可以给push增加参数\ngit push origin --tags\n```\n\n# 本地和远程分支和tag的删除\n```shell\n# 本地\ngit tag -d xxx\ngit branch -d xxx\n\n# 远程\ngit push origin :refs/tags/xxx\ngit push origin :xxx\n```","source":"_posts/Git-分支管理和实际应用.md","raw":"---\ntitle: 分支管理和实际应用\ndate: 2020-03-06 19:34:25\ncategories: \n- Git操作\ntags:\n- Git操作\n---\n\n2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄... 来更新下\n2020年7月29日10:53:32 更新 删除一些无意义的话....\n\n# 分支管理\n\n`git checkout -b dev`相当于一下两条命令\n`git branch dev` 分支创建\n`git checkout dev` 分支切换\n\n`git branch -d dev` 分支删除\n\n`git branch` 查看当前所有分支\n\n`git merge dev` 将制定的dev分支合并到当前的分支\n\n**冲突解决**\n\n`git merge dev` 将制定的dev分支合并到当前的分支\n```\n1 111111111111111\n2 222222222222222\n3 333333333333333\n4 444444444444444\n5 <<<<<<< HEAD  # 我在master分支下添加了6666666 并提交\n6 6666666\n7 =======\n8 7777777\n9 >>>>>>> deb # 我在deb分支下添加了7777777 并提交\n```\n最后需要我手动修改这个文件为自己需要的内容 然后提交即可\n  \n**分支管理**\n\n通常Git会使用`Fast forward`模式 这样删除分支后会丢失分支的信息\n可以再merge的时候加入`--no-ff`这样就能解决问题\n`git merge --no-ff -m \"merge with no-ff\" dev`\n由于禁用`Fast forward`后\n会生成新的commit所以需要加入` -m \"merge with no-ff\"`\n\n**暂存代码**\n\ngit stash 可以储存当前的工作区 恢复到上一次commit后\ngit stash list 查看储存的工作区列表\ngit stash apply stash@{0} 恢复指定的储存\ngit stash pop 恢复并drop最近的存储 慎用这个 建议使用上边的\n\n  \n# 实际工作中分支的应用\n[主要参考](https://zhuanlan.zhihu.com/p/38772378)\n\n**主分支**\n- **master**: 这个分支最稳定, 相当于放的可发布版本\n- **develop**: 开发分支, 平行于master分支, 负责合并各种`用于开发子功能`的分支\n\n**支持分支**:解决某个问题, 结束后合并回`master`或`develop`分支\n- **feature**功能分支, 用于开发一个个子功能, 来自`develop`合并到`develop`去\n- **release**:发布分支, 用于修改版本号等小修改, 来自`develop`分支合并到`master`分支\n- **hotfixes**:紧急修复bug分支, 从`master`创建, 合并回`develop`分支和`master`分支\n![](https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg)\n\n\n[Git 分支管理规范](https://juejin.im/post/5d82e1f3e51d4561d044cd88#heading-14)\n\n[Git 基础 - 打标签](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE)\n\n\n**develop分支完成了操作, 准备发布新的版本**\n```shell\n# 从 develop 分支上创建 release 分支:\n# 命名规则如下 release-事件-版本\ngit checkout –b release-20190919-v1.0.0 develop\n\n# 修复完release的bug后再次提交修改:\ngit checkout release-20190919-v1.0.0\n# 提交本地修改, 如果没有修改bug 可以跳过\ngit add .\ngit commit –m “提交日志”\n# 推送 release 分支\ngit push origin release-20190919-v1.0.0\n\n# 发布新版本\n# 合并 release 分支到 master 分支:\ngit checkout master\ngit merge --no-ff release-20190919-v1.0.0\n# 合并 release 分支到 develop 分支:\ngit checkout develop\ngit merge --no-ff release-20190919-v1.0.0\n# 在 master 分支上创建标签:\ngit tag tag-20190919-v1.0.0\n# 删除本地 release 分支:\ngit branch –d release-20190919-v1.0.0\n# 删除远程 release 分支:\ngit push origin :release-20190919-v1.0.0\n```\n\n新版本完成之后\n```shell\n# 推送master分支\ngit push origin master\n\n# 注意上边打的tag需要手动提交 默认push不会提交tag\ngit push origin [tag name]\n# 也可以给push增加参数\ngit push origin --tags\n```\n\n# 本地和远程分支和tag的删除\n```shell\n# 本地\ngit tag -d xxx\ngit branch -d xxx\n\n# 远程\ngit push origin :refs/tags/xxx\ngit push origin :xxx\n```","slug":"Git-分支管理和实际应用","published":1,"updated":"2020-12-05T02:28:41.659Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg60000if8un07wg4z95","content":"<p>2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄… 来更新下<br>2020年7月29日10:53:32 更新 删除一些无意义的话….</p>\n<h1 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h1><p><code>git checkout -b dev</code>相当于一下两条命令<br><code>git branch dev</code> 分支创建<br><code>git checkout dev</code> 分支切换</p>\n<p><code>git branch -d dev</code> 分支删除</p>\n<p><code>git branch</code> 查看当前所有分支</p>\n<p><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p>\n<p><strong>冲突解决</strong></p>\n<p><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 111111111111111</span><br><span class=\"line\">2 222222222222222</span><br><span class=\"line\">3 333333333333333</span><br><span class=\"line\">4 444444444444444</span><br><span class=\"line\">5 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  # 我在master分支下添加了6666666 并提交</span><br><span class=\"line\">6 6666666</span><br><span class=\"line\">7 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">8 7777777</span><br><span class=\"line\">9 &gt;&gt;&gt;&gt;&gt;&gt;&gt; deb # 我在deb分支下添加了7777777 并提交</span><br></pre></td></tr></table></figure>\n<p>最后需要我手动修改这个文件为自己需要的内容 然后提交即可</p>\n<p><strong>分支管理</strong></p>\n<p>通常Git会使用<code>Fast forward</code>模式 这样删除分支后会丢失分支的信息<br>可以再merge的时候加入<code>--no-ff</code>这样就能解决问题<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>由于禁用<code>Fast forward</code>后<br>会生成新的commit所以需要加入<code>-m &quot;merge with no-ff&quot;</code></p>\n<p><strong>暂存代码</strong></p>\n<p>git stash 可以储存当前的工作区 恢复到上一次commit后<br>git stash list 查看储存的工作区列表<br>git stash apply stash@{0} 恢复指定的储存<br>git stash pop 恢复并drop最近的存储 慎用这个 建议使用上边的</p>\n<h1 id=\"实际工作中分支的应用\"><a href=\"#实际工作中分支的应用\" class=\"headerlink\" title=\"实际工作中分支的应用\"></a>实际工作中分支的应用</h1><p><a href=\"https://zhuanlan.zhihu.com/p/38772378\" target=\"_blank\" rel=\"noopener\">主要参考</a></p>\n<p><strong>主分支</strong></p>\n<ul>\n<li><strong>master</strong>: 这个分支最稳定, 相当于放的可发布版本</li>\n<li><strong>develop</strong>: 开发分支, 平行于master分支, 负责合并各种<code>用于开发子功能</code>的分支</li>\n</ul>\n<p><strong>支持分支</strong>:解决某个问题, 结束后合并回<code>master</code>或<code>develop</code>分支</p>\n<ul>\n<li><strong>feature</strong>功能分支, 用于开发一个个子功能, 来自<code>develop</code>合并到<code>develop</code>去</li>\n<li><strong>release</strong>:发布分支, 用于修改版本号等小修改, 来自<code>develop</code>分支合并到<code>master</code>分支</li>\n<li><strong>hotfixes</strong>:紧急修复bug分支, 从<code>master</code>创建, 合并回<code>develop</code>分支和<code>master</code>分支<br><img src=\"https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg\" alt=\"\"></li>\n</ul>\n<p><a href=\"https://juejin.im/post/5d82e1f3e51d4561d044cd88#heading-14\" target=\"_blank\" rel=\"noopener\">Git 分支管理规范</a></p>\n<p><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE\" target=\"_blank\" rel=\"noopener\">Git 基础 - 打标签</a></p>\n<p><strong>develop分支完成了操作, 准备发布新的版本</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 从 develop 分支上创建 release 分支:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 命名规则如下 release-事件-版本</span></span><br><span class=\"line\">git checkout –b release-20190919-v1.0.0 develop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 修复完release的bug后再次提交修改:</span></span><br><span class=\"line\">git checkout release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 提交本地修改, 如果没有修改bug 可以跳过</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit –m “提交日志”</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 推送 release 分支</span></span><br><span class=\"line\">git push origin release-20190919-v1.0.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 发布新版本</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 合并 release 分支到 master 分支:</span></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge --no-ff release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 合并 release 分支到 develop 分支:</span></span><br><span class=\"line\">git checkout develop</span><br><span class=\"line\">git merge --no-ff release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在 master 分支上创建标签:</span></span><br><span class=\"line\">git tag tag-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 删除本地 release 分支:</span></span><br><span class=\"line\">git branch –d release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 删除远程 release 分支:</span></span><br><span class=\"line\">git push origin :release-20190919-v1.0.0</span><br></pre></td></tr></table></figure>\n\n<p>新版本完成之后</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 推送master分支</span></span><br><span class=\"line\">git push origin master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意上边打的tag需要手动提交 默认push不会提交tag</span></span><br><span class=\"line\">git push origin [tag name]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 也可以给push增加参数</span></span><br><span class=\"line\">git push origin --tags</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"本地和远程分支和tag的删除\"><a href=\"#本地和远程分支和tag的删除\" class=\"headerlink\" title=\"本地和远程分支和tag的删除\"></a>本地和远程分支和tag的删除</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 本地</span></span><br><span class=\"line\">git tag -d xxx</span><br><span class=\"line\">git branch -d xxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 远程</span></span><br><span class=\"line\">git push origin :refs/tags/xxx</span><br><span class=\"line\">git push origin :xxx</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄… 来更新下<br>2020年7月29日10:53:32 更新 删除一些无意义的话….</p>\n<h1 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h1><p><code>git checkout -b dev</code>相当于一下两条命令<br><code>git branch dev</code> 分支创建<br><code>git checkout dev</code> 分支切换</p>\n<p><code>git branch -d dev</code> 分支删除</p>\n<p><code>git branch</code> 查看当前所有分支</p>\n<p><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p>\n<p><strong>冲突解决</strong></p>\n<p><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 111111111111111</span><br><span class=\"line\">2 222222222222222</span><br><span class=\"line\">3 333333333333333</span><br><span class=\"line\">4 444444444444444</span><br><span class=\"line\">5 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  # 我在master分支下添加了6666666 并提交</span><br><span class=\"line\">6 6666666</span><br><span class=\"line\">7 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">8 7777777</span><br><span class=\"line\">9 &gt;&gt;&gt;&gt;&gt;&gt;&gt; deb # 我在deb分支下添加了7777777 并提交</span><br></pre></td></tr></table></figure>\n<p>最后需要我手动修改这个文件为自己需要的内容 然后提交即可</p>\n<p><strong>分支管理</strong></p>\n<p>通常Git会使用<code>Fast forward</code>模式 这样删除分支后会丢失分支的信息<br>可以再merge的时候加入<code>--no-ff</code>这样就能解决问题<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>由于禁用<code>Fast forward</code>后<br>会生成新的commit所以需要加入<code>-m &quot;merge with no-ff&quot;</code></p>\n<p><strong>暂存代码</strong></p>\n<p>git stash 可以储存当前的工作区 恢复到上一次commit后<br>git stash list 查看储存的工作区列表<br>git stash apply stash@{0} 恢复指定的储存<br>git stash pop 恢复并drop最近的存储 慎用这个 建议使用上边的</p>\n<h1 id=\"实际工作中分支的应用\"><a href=\"#实际工作中分支的应用\" class=\"headerlink\" title=\"实际工作中分支的应用\"></a>实际工作中分支的应用</h1><p><a href=\"https://zhuanlan.zhihu.com/p/38772378\" target=\"_blank\" rel=\"noopener\">主要参考</a></p>\n<p><strong>主分支</strong></p>\n<ul>\n<li><strong>master</strong>: 这个分支最稳定, 相当于放的可发布版本</li>\n<li><strong>develop</strong>: 开发分支, 平行于master分支, 负责合并各种<code>用于开发子功能</code>的分支</li>\n</ul>\n<p><strong>支持分支</strong>:解决某个问题, 结束后合并回<code>master</code>或<code>develop</code>分支</p>\n<ul>\n<li><strong>feature</strong>功能分支, 用于开发一个个子功能, 来自<code>develop</code>合并到<code>develop</code>去</li>\n<li><strong>release</strong>:发布分支, 用于修改版本号等小修改, 来自<code>develop</code>分支合并到<code>master</code>分支</li>\n<li><strong>hotfixes</strong>:紧急修复bug分支, 从<code>master</code>创建, 合并回<code>develop</code>分支和<code>master</code>分支<br><img src=\"https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg\" alt=\"\"></li>\n</ul>\n<p><a href=\"https://juejin.im/post/5d82e1f3e51d4561d044cd88#heading-14\" target=\"_blank\" rel=\"noopener\">Git 分支管理规范</a></p>\n<p><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE\" target=\"_blank\" rel=\"noopener\">Git 基础 - 打标签</a></p>\n<p><strong>develop分支完成了操作, 准备发布新的版本</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 从 develop 分支上创建 release 分支:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 命名规则如下 release-事件-版本</span></span><br><span class=\"line\">git checkout –b release-20190919-v1.0.0 develop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 修复完release的bug后再次提交修改:</span></span><br><span class=\"line\">git checkout release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 提交本地修改, 如果没有修改bug 可以跳过</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit –m “提交日志”</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 推送 release 分支</span></span><br><span class=\"line\">git push origin release-20190919-v1.0.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 发布新版本</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 合并 release 分支到 master 分支:</span></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge --no-ff release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 合并 release 分支到 develop 分支:</span></span><br><span class=\"line\">git checkout develop</span><br><span class=\"line\">git merge --no-ff release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在 master 分支上创建标签:</span></span><br><span class=\"line\">git tag tag-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 删除本地 release 分支:</span></span><br><span class=\"line\">git branch –d release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 删除远程 release 分支:</span></span><br><span class=\"line\">git push origin :release-20190919-v1.0.0</span><br></pre></td></tr></table></figure>\n\n<p>新版本完成之后</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 推送master分支</span></span><br><span class=\"line\">git push origin master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意上边打的tag需要手动提交 默认push不会提交tag</span></span><br><span class=\"line\">git push origin [tag name]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 也可以给push增加参数</span></span><br><span class=\"line\">git push origin --tags</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"本地和远程分支和tag的删除\"><a href=\"#本地和远程分支和tag的删除\" class=\"headerlink\" title=\"本地和远程分支和tag的删除\"></a>本地和远程分支和tag的删除</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 本地</span></span><br><span class=\"line\">git tag -d xxx</span><br><span class=\"line\">git branch -d xxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 远程</span></span><br><span class=\"line\">git push origin :refs/tags/xxx</span><br><span class=\"line\">git push origin :xxx</span><br></pre></td></tr></table></figure>"},{"title":"commit规范","date":"2020-02-22T04:22:02.000Z","_content":"# commit 规范\n[阮一峰 Commit message 和 Change log 编写指南](https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n\nAngular 规范.\n每个commit message 包括三分部\nHeader Body 和 Footer\n```\n<type>(<scope>): <subject> // 必须\n// 空一行\n<body> // 非必须\n// 空一行\n<footer> //非必须\n```\n**Header**\n1. type 必需 - 说明commit的类别, 只允许下面七个标识\n\n- feat：新功能（feature）\n- fix：修补bug\n- docs：文档（documentation）\n- style： 格式（不影响代码运行的变动）\n- refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n- test：增加测试\n- chore：构建过程或辅助工具的变动\n\n2. scope 非必需 - 用于说明 commit影响的范围\n比如登录、注册、充值逻辑等等，视项目不同而不同。\n\n3. subject 必需 - commit 目的的简短描述 \n- 不超过50字符 \n- 第一人称现在时动词开头\n- 首字母小写\n- 句尾不加句号\n\n**Body**\n本次commit的详细描述, 可以分成多行\n\n**Footer**\n只用于两种情况 目前用不动 不摘了","source":"_posts/Git-commit规范.md","raw":"---\ntitle: commit规范\ndate: 2020-02-22 12:22:02\ncategories: \n- Git操作\ntags:\n---\n# commit 规范\n[阮一峰 Commit message 和 Change log 编写指南](https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n\nAngular 规范.\n每个commit message 包括三分部\nHeader Body 和 Footer\n```\n<type>(<scope>): <subject> // 必须\n// 空一行\n<body> // 非必须\n// 空一行\n<footer> //非必须\n```\n**Header**\n1. type 必需 - 说明commit的类别, 只允许下面七个标识\n\n- feat：新功能（feature）\n- fix：修补bug\n- docs：文档（documentation）\n- style： 格式（不影响代码运行的变动）\n- refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n- test：增加测试\n- chore：构建过程或辅助工具的变动\n\n2. scope 非必需 - 用于说明 commit影响的范围\n比如登录、注册、充值逻辑等等，视项目不同而不同。\n\n3. subject 必需 - commit 目的的简短描述 \n- 不超过50字符 \n- 第一人称现在时动词开头\n- 首字母小写\n- 句尾不加句号\n\n**Body**\n本次commit的详细描述, 可以分成多行\n\n**Footer**\n只用于两种情况 目前用不动 不摘了","slug":"Git-commit规范","published":1,"updated":"2020-12-05T02:28:41.659Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg66000lf8un9e1zebks","content":"<h1 id=\"commit-规范\"><a href=\"#commit-规范\" class=\"headerlink\" title=\"commit 规范\"></a>commit 规范</h1><p><a href=\"https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"noopener\">阮一峰 Commit message 和 Change log 编写指南</a></p>\n<p>Angular 规范.<br>每个commit message 包括三分部<br>Header Body 和 Footer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; &#x2F;&#x2F; 必须</span><br><span class=\"line\">&#x2F;&#x2F; 空一行</span><br><span class=\"line\">&lt;body&gt; &#x2F;&#x2F; 非必须</span><br><span class=\"line\">&#x2F;&#x2F; 空一行</span><br><span class=\"line\">&lt;footer&gt; &#x2F;&#x2F;非必须</span><br></pre></td></tr></table></figure>\n<p><strong>Header</strong></p>\n<ol>\n<li>type 必需 - 说明commit的类别, 只允许下面七个标识</li>\n</ol>\n<ul>\n<li>feat：新功能（feature）</li>\n<li>fix：修补bug</li>\n<li>docs：文档（documentation）</li>\n<li>style： 格式（不影响代码运行的变动）</li>\n<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>\n<li>test：增加测试</li>\n<li>chore：构建过程或辅助工具的变动</li>\n</ul>\n<ol start=\"2\">\n<li><p>scope 非必需 - 用于说明 commit影响的范围<br>比如登录、注册、充值逻辑等等，视项目不同而不同。</p>\n</li>\n<li><p>subject 必需 - commit 目的的简短描述 </p>\n</li>\n</ol>\n<ul>\n<li>不超过50字符 </li>\n<li>第一人称现在时动词开头</li>\n<li>首字母小写</li>\n<li>句尾不加句号</li>\n</ul>\n<p><strong>Body</strong><br>本次commit的详细描述, 可以分成多行</p>\n<p><strong>Footer</strong><br>只用于两种情况 目前用不动 不摘了</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"commit-规范\"><a href=\"#commit-规范\" class=\"headerlink\" title=\"commit 规范\"></a>commit 规范</h1><p><a href=\"https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"noopener\">阮一峰 Commit message 和 Change log 编写指南</a></p>\n<p>Angular 规范.<br>每个commit message 包括三分部<br>Header Body 和 Footer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; &#x2F;&#x2F; 必须</span><br><span class=\"line\">&#x2F;&#x2F; 空一行</span><br><span class=\"line\">&lt;body&gt; &#x2F;&#x2F; 非必须</span><br><span class=\"line\">&#x2F;&#x2F; 空一行</span><br><span class=\"line\">&lt;footer&gt; &#x2F;&#x2F;非必须</span><br></pre></td></tr></table></figure>\n<p><strong>Header</strong></p>\n<ol>\n<li>type 必需 - 说明commit的类别, 只允许下面七个标识</li>\n</ol>\n<ul>\n<li>feat：新功能（feature）</li>\n<li>fix：修补bug</li>\n<li>docs：文档（documentation）</li>\n<li>style： 格式（不影响代码运行的变动）</li>\n<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>\n<li>test：增加测试</li>\n<li>chore：构建过程或辅助工具的变动</li>\n</ul>\n<ol start=\"2\">\n<li><p>scope 非必需 - 用于说明 commit影响的范围<br>比如登录、注册、充值逻辑等等，视项目不同而不同。</p>\n</li>\n<li><p>subject 必需 - commit 目的的简短描述 </p>\n</li>\n</ol>\n<ul>\n<li>不超过50字符 </li>\n<li>第一人称现在时动词开头</li>\n<li>首字母小写</li>\n<li>句尾不加句号</li>\n</ul>\n<p><strong>Body</strong><br>本次commit的详细描述, 可以分成多行</p>\n<p><strong>Footer</strong><br>只用于两种情况 目前用不动 不摘了</p>\n"},{"title":"Git的基础使用","date":"2020-02-07T10:24:42.000Z","_content":"2020年8月9日23:06:10 删除已经熟记的部分命令 精简博客\n\n# git设置代理\n\n下面设置http代理只对http链接有效, 如果你的库绑定了ssh链接 则无效\n```shell\nexport http_proxy=http://127.0.0.1:1080\nexport https_proxy=http://127.0.0.1:1080\n\ncurl cip.cc # 查询当前的状态\n\nIP\t: xxx.xxx.xxx.xxx\n地址\t: 中国  xx  xx\n运营商\t: 联通\n数据二\t: xxx | 联通\n数据三\t: 中国xxxx | 联通\nURL\t: http://www.cip.cc/xxx.xxx.xxx.xxx\n```\n\n\n# 命令总结\n\n密钥生成\n```\n# -t Specifies the type of key to create.  The possible values are\n#“dsa”, “ecdsa”, “ed25519”, or “rsa”.\n# -C 生成注释 ...所以后面的邮箱就是个注释\nssh-keygen -t rsa -C \"youremail@example.com\"\n```\n\n```\ngit remote add origin  # origin 意为远程库的名字, git的默认叫法\ngit log --pretty=oneline # 简单显示\n```\n\n```\n# 注意reset是恢复到上一个版本 即为你上一次commit版本或者pull最近的一次\n\ngit checkout --<filename> # 恢复工作区, 可用于恢复修改和恢复勿删文件\ngit reset HEAD <file> # 恢复暂存区\ngit reset HEAD^ # 恢复版本库\ngit reset --hard <hash版本号 即为log中的一串英文字母, 只需要前几个字母即可>\ngit reflog # 所有版本日志\n\ngit rm 从版本库中删除文件\n```\n```\ngit push -u origin master # 带上 -u 以后提交就不需要加入origin master, 类似记忆功能\n\ngit checkout -b dev 相当于一下两条命令\ngit branch dev  分支创建\ngit checkout dev  分支切换\n\ngit branch -d dev   分支删除\ngit branch   查看当前所有分支\ngit merge dev  将制定的dev分支合并到当前的分支\n```\n\n# 基础的操作\n\n`git status`告诉你 你修改了哪些文件 但是你想知道你怎么修改了这些文件, 做了什么改动\n\n这时候就需要`git diff`\n```\n$git diff\n-------提示如下-----------\ndiff --git a/test.txt b/test.txt\nindex 0858ae8..8c14912 100644\n--- a/test.txt\n+++ b/test.txt\n@@ -1,3 +1,4 @@\n 111111111111111\n 222222222222222\n 333333333333333\n+444444444444444\n```\n\n# 时光穿梭机\n**在commit之间切换**\nGit还可以在不同commit间切换, 当然你必须知道进行过哪些commit, 你不能自己都记在脑子里吧, 所以也存在相关的命令`git log`来查看你的commit记录\n```\nlsmg@ubuntu:~/temp$ git log\ncommit ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -> master)\nAuthor: ***********\nDate:   Sat Dec 7 21:06:42 2019 -0800\n    ver 0.02\n\ncommit 603260e28ac0cc8fb8e4243120eb00bca83585d2\nAuthor: ***********\nDate:   Sat Dec 7 20:57:58 2019 -0800\n    ver 0.01\n\nlsmg@ubuntu:~/temp$ git log --pretty=oneline # 简洁显示\nee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -> master) ver 0.02\n603260e28ac0cc8fb8e4243120eb00bca83585d2 ver 0.01\n```\n上面的`HEAD`代表当前版本, 上一个版本为`HEAD^`, 上上一个版本为`HEAD^^`如此类推\n回到前N个版本`HEAD~N`\n`git reset --hard HEAD^` 回到上一个版本.\n这时你当前版本将会丢失, 使用`git log`也不会查看到原来的版本信息\n这时使用`git reflog`来查看你的所有版本日志\n```\nlsmg@ubuntu:~/temp$ git reset --hard 603260e28ac0cc8fb8e4243120eb00bca83585d2\nHEAD 现在位于 603260e ver 0.01\nlsmg@ubuntu:~/temp$ git log\ncommit 603260e28ac0cc8fb8e4243120eb00bca83585d2 (HEAD -> master)\nAuthor: rjd67441 <rjd67441@hotmail.com>\nDate:   Sat Dec 7 20:57:58 2019 -0800\n\n    ver 0.01\nlsmg@ubuntu:~/temp$ git reflog \n603260e (HEAD -> master) HEAD@{0}: reset: moving to 603260e28ac0cc8fb8e4243120eb00bca83585d2\nee4400f HEAD@{1}: commit: ver 0.02\n603260e (HEAD -> master) HEAD@{2}: commit (initial): ver 0.01\nlsmg@ubuntu:~/temp$ git reset --hard ee4400f\nHEAD 现在位于 ee4400f ver 0.02\n```\n\n**撤销修改**\n\n工作区中的撤销\n`git checkout -- <filename>`\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n暂存区中的撤销\n`git reset HEAD <file>`\n版本库的撤销\n`git reset HEAD^` 乖乖回退一次\n\n**删除文件**\n\n删除本地文件后\n确实需要从版本库中删除\n`git rm`删除然后`git commit`提交即可\n误删除需要使用`git chechout -- <filename>`来恢复","source":"_posts/Git-基础操作.md","raw":"---\ntitle: Git的基础使用\ndate: 2020-02-07 18:24:42\ncategories: \n- Git操作\ntags:\n---\n2020年8月9日23:06:10 删除已经熟记的部分命令 精简博客\n\n# git设置代理\n\n下面设置http代理只对http链接有效, 如果你的库绑定了ssh链接 则无效\n```shell\nexport http_proxy=http://127.0.0.1:1080\nexport https_proxy=http://127.0.0.1:1080\n\ncurl cip.cc # 查询当前的状态\n\nIP\t: xxx.xxx.xxx.xxx\n地址\t: 中国  xx  xx\n运营商\t: 联通\n数据二\t: xxx | 联通\n数据三\t: 中国xxxx | 联通\nURL\t: http://www.cip.cc/xxx.xxx.xxx.xxx\n```\n\n\n# 命令总结\n\n密钥生成\n```\n# -t Specifies the type of key to create.  The possible values are\n#“dsa”, “ecdsa”, “ed25519”, or “rsa”.\n# -C 生成注释 ...所以后面的邮箱就是个注释\nssh-keygen -t rsa -C \"youremail@example.com\"\n```\n\n```\ngit remote add origin  # origin 意为远程库的名字, git的默认叫法\ngit log --pretty=oneline # 简单显示\n```\n\n```\n# 注意reset是恢复到上一个版本 即为你上一次commit版本或者pull最近的一次\n\ngit checkout --<filename> # 恢复工作区, 可用于恢复修改和恢复勿删文件\ngit reset HEAD <file> # 恢复暂存区\ngit reset HEAD^ # 恢复版本库\ngit reset --hard <hash版本号 即为log中的一串英文字母, 只需要前几个字母即可>\ngit reflog # 所有版本日志\n\ngit rm 从版本库中删除文件\n```\n```\ngit push -u origin master # 带上 -u 以后提交就不需要加入origin master, 类似记忆功能\n\ngit checkout -b dev 相当于一下两条命令\ngit branch dev  分支创建\ngit checkout dev  分支切换\n\ngit branch -d dev   分支删除\ngit branch   查看当前所有分支\ngit merge dev  将制定的dev分支合并到当前的分支\n```\n\n# 基础的操作\n\n`git status`告诉你 你修改了哪些文件 但是你想知道你怎么修改了这些文件, 做了什么改动\n\n这时候就需要`git diff`\n```\n$git diff\n-------提示如下-----------\ndiff --git a/test.txt b/test.txt\nindex 0858ae8..8c14912 100644\n--- a/test.txt\n+++ b/test.txt\n@@ -1,3 +1,4 @@\n 111111111111111\n 222222222222222\n 333333333333333\n+444444444444444\n```\n\n# 时光穿梭机\n**在commit之间切换**\nGit还可以在不同commit间切换, 当然你必须知道进行过哪些commit, 你不能自己都记在脑子里吧, 所以也存在相关的命令`git log`来查看你的commit记录\n```\nlsmg@ubuntu:~/temp$ git log\ncommit ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -> master)\nAuthor: ***********\nDate:   Sat Dec 7 21:06:42 2019 -0800\n    ver 0.02\n\ncommit 603260e28ac0cc8fb8e4243120eb00bca83585d2\nAuthor: ***********\nDate:   Sat Dec 7 20:57:58 2019 -0800\n    ver 0.01\n\nlsmg@ubuntu:~/temp$ git log --pretty=oneline # 简洁显示\nee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -> master) ver 0.02\n603260e28ac0cc8fb8e4243120eb00bca83585d2 ver 0.01\n```\n上面的`HEAD`代表当前版本, 上一个版本为`HEAD^`, 上上一个版本为`HEAD^^`如此类推\n回到前N个版本`HEAD~N`\n`git reset --hard HEAD^` 回到上一个版本.\n这时你当前版本将会丢失, 使用`git log`也不会查看到原来的版本信息\n这时使用`git reflog`来查看你的所有版本日志\n```\nlsmg@ubuntu:~/temp$ git reset --hard 603260e28ac0cc8fb8e4243120eb00bca83585d2\nHEAD 现在位于 603260e ver 0.01\nlsmg@ubuntu:~/temp$ git log\ncommit 603260e28ac0cc8fb8e4243120eb00bca83585d2 (HEAD -> master)\nAuthor: rjd67441 <rjd67441@hotmail.com>\nDate:   Sat Dec 7 20:57:58 2019 -0800\n\n    ver 0.01\nlsmg@ubuntu:~/temp$ git reflog \n603260e (HEAD -> master) HEAD@{0}: reset: moving to 603260e28ac0cc8fb8e4243120eb00bca83585d2\nee4400f HEAD@{1}: commit: ver 0.02\n603260e (HEAD -> master) HEAD@{2}: commit (initial): ver 0.01\nlsmg@ubuntu:~/temp$ git reset --hard ee4400f\nHEAD 现在位于 ee4400f ver 0.02\n```\n\n**撤销修改**\n\n工作区中的撤销\n`git checkout -- <filename>`\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n暂存区中的撤销\n`git reset HEAD <file>`\n版本库的撤销\n`git reset HEAD^` 乖乖回退一次\n\n**删除文件**\n\n删除本地文件后\n确实需要从版本库中删除\n`git rm`删除然后`git commit`提交即可\n误删除需要使用`git chechout -- <filename>`来恢复","slug":"Git-基础操作","published":1,"updated":"2020-12-05T02:28:40.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg67000of8unffxb4ise","content":"<p>2020年8月9日23:06:10 删除已经熟记的部分命令 精简博客</p>\n<h1 id=\"git设置代理\"><a href=\"#git设置代理\" class=\"headerlink\" title=\"git设置代理\"></a>git设置代理</h1><p>下面设置http代理只对http链接有效, 如果你的库绑定了ssh链接 则无效</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export http_proxy=http://127.0.0.1:1080</span><br><span class=\"line\">export https_proxy=http://127.0.0.1:1080</span><br><span class=\"line\"></span><br><span class=\"line\">curl cip.cc # 查询当前的状态</span><br><span class=\"line\"></span><br><span class=\"line\">IP\t: xxx.xxx.xxx.xxx</span><br><span class=\"line\">地址\t: 中国  xx  xx</span><br><span class=\"line\">运营商\t: 联通</span><br><span class=\"line\">数据二\t: xxx | 联通</span><br><span class=\"line\">数据三\t: 中国xxxx | 联通</span><br><span class=\"line\">URL\t: http://www.cip.cc/xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"命令总结\"><a href=\"#命令总结\" class=\"headerlink\" title=\"命令总结\"></a>命令总结</h1><p>密钥生成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -t Specifies the type of key to create.  The possible values are</span><br><span class=\"line\">#“dsa”, “ecdsa”, “ed25519”, or “rsa”.</span><br><span class=\"line\"># -C 生成注释 ...所以后面的邮箱就是个注释</span><br><span class=\"line\">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin  # origin 意为远程库的名字, git的默认叫法</span><br><span class=\"line\">git log --pretty&#x3D;oneline # 简单显示</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 注意reset是恢复到上一个版本 即为你上一次commit版本或者pull最近的一次</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout --&lt;filename&gt; # 恢复工作区, 可用于恢复修改和恢复勿删文件</span><br><span class=\"line\">git reset HEAD &lt;file&gt; # 恢复暂存区</span><br><span class=\"line\">git reset HEAD^ # 恢复版本库</span><br><span class=\"line\">git reset --hard &lt;hash版本号 即为log中的一串英文字母, 只需要前几个字母即可&gt;</span><br><span class=\"line\">git reflog # 所有版本日志</span><br><span class=\"line\"></span><br><span class=\"line\">git rm 从版本库中删除文件</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master # 带上 -u 以后提交就不需要加入origin master, 类似记忆功能</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout -b dev 相当于一下两条命令</span><br><span class=\"line\">git branch dev  分支创建</span><br><span class=\"line\">git checkout dev  分支切换</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -d dev   分支删除</span><br><span class=\"line\">git branch   查看当前所有分支</span><br><span class=\"line\">git merge dev  将制定的dev分支合并到当前的分支</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"基础的操作\"><a href=\"#基础的操作\" class=\"headerlink\" title=\"基础的操作\"></a>基础的操作</h1><p><code>git status</code>告诉你 你修改了哪些文件 但是你想知道你怎么修改了这些文件, 做了什么改动</p>\n<p>这时候就需要<code>git diff</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git diff</span><br><span class=\"line\">-------提示如下-----------</span><br><span class=\"line\">diff --git a&#x2F;test.txt b&#x2F;test.txt</span><br><span class=\"line\">index 0858ae8..8c14912 100644</span><br><span class=\"line\">--- a&#x2F;test.txt</span><br><span class=\"line\">+++ b&#x2F;test.txt</span><br><span class=\"line\">@@ -1,3 +1,4 @@</span><br><span class=\"line\"> 111111111111111</span><br><span class=\"line\"> 222222222222222</span><br><span class=\"line\"> 333333333333333</span><br><span class=\"line\">+444444444444444</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"时光穿梭机\"><a href=\"#时光穿梭机\" class=\"headerlink\" title=\"时光穿梭机\"></a>时光穿梭机</h1><p><strong>在commit之间切换</strong><br>Git还可以在不同commit间切换, 当然你必须知道进行过哪些commit, 你不能自己都记在脑子里吧, 所以也存在相关的命令<code>git log</code>来查看你的commit记录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git log</span><br><span class=\"line\">commit ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master)</span><br><span class=\"line\">Author: ***********</span><br><span class=\"line\">Date:   Sat Dec 7 21:06:42 2019 -0800</span><br><span class=\"line\">    ver 0.02</span><br><span class=\"line\"></span><br><span class=\"line\">commit 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class=\"line\">Author: ***********</span><br><span class=\"line\">Date:   Sat Dec 7 20:57:58 2019 -0800</span><br><span class=\"line\">    ver 0.01</span><br><span class=\"line\"></span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git log --pretty&#x3D;oneline # 简洁显示</span><br><span class=\"line\">ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master) ver 0.02</span><br><span class=\"line\">603260e28ac0cc8fb8e4243120eb00bca83585d2 ver 0.01</span><br></pre></td></tr></table></figure>\n<p>上面的<code>HEAD</code>代表当前版本, 上一个版本为<code>HEAD^</code>, 上上一个版本为<code>HEAD^^</code>如此类推<br>回到前N个版本<code>HEAD~N</code><br><code>git reset --hard HEAD^</code> 回到上一个版本.<br>这时你当前版本将会丢失, 使用<code>git log</code>也不会查看到原来的版本信息<br>这时使用<code>git reflog</code>来查看你的所有版本日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git reset --hard 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class=\"line\">HEAD 现在位于 603260e ver 0.01</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git log</span><br><span class=\"line\">commit 603260e28ac0cc8fb8e4243120eb00bca83585d2 (HEAD -&gt; master)</span><br><span class=\"line\">Author: rjd67441 &lt;rjd67441@hotmail.com&gt;</span><br><span class=\"line\">Date:   Sat Dec 7 20:57:58 2019 -0800</span><br><span class=\"line\"></span><br><span class=\"line\">    ver 0.01</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git reflog </span><br><span class=\"line\">603260e (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class=\"line\">ee4400f HEAD@&#123;1&#125;: commit: ver 0.02</span><br><span class=\"line\">603260e (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): ver 0.01</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git reset --hard ee4400f</span><br><span class=\"line\">HEAD 现在位于 ee4400f ver 0.02</span><br></pre></td></tr></table></figure>\n\n<p><strong>撤销修改</strong></p>\n<p>工作区中的撤销<br><code>git checkout -- &lt;filename&gt;</code><br>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。<br>暂存区中的撤销<br><code>git reset HEAD &lt;file&gt;</code><br>版本库的撤销<br><code>git reset HEAD^</code> 乖乖回退一次</p>\n<p><strong>删除文件</strong></p>\n<p>删除本地文件后<br>确实需要从版本库中删除<br><code>git rm</code>删除然后<code>git commit</code>提交即可<br>误删除需要使用<code>git chechout -- &lt;filename&gt;</code>来恢复</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2020年8月9日23:06:10 删除已经熟记的部分命令 精简博客</p>\n<h1 id=\"git设置代理\"><a href=\"#git设置代理\" class=\"headerlink\" title=\"git设置代理\"></a>git设置代理</h1><p>下面设置http代理只对http链接有效, 如果你的库绑定了ssh链接 则无效</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export http_proxy=http://127.0.0.1:1080</span><br><span class=\"line\">export https_proxy=http://127.0.0.1:1080</span><br><span class=\"line\"></span><br><span class=\"line\">curl cip.cc # 查询当前的状态</span><br><span class=\"line\"></span><br><span class=\"line\">IP\t: xxx.xxx.xxx.xxx</span><br><span class=\"line\">地址\t: 中国  xx  xx</span><br><span class=\"line\">运营商\t: 联通</span><br><span class=\"line\">数据二\t: xxx | 联通</span><br><span class=\"line\">数据三\t: 中国xxxx | 联通</span><br><span class=\"line\">URL\t: http://www.cip.cc/xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"命令总结\"><a href=\"#命令总结\" class=\"headerlink\" title=\"命令总结\"></a>命令总结</h1><p>密钥生成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -t Specifies the type of key to create.  The possible values are</span><br><span class=\"line\">#“dsa”, “ecdsa”, “ed25519”, or “rsa”.</span><br><span class=\"line\"># -C 生成注释 ...所以后面的邮箱就是个注释</span><br><span class=\"line\">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add origin  # origin 意为远程库的名字, git的默认叫法</span><br><span class=\"line\">git log --pretty&#x3D;oneline # 简单显示</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 注意reset是恢复到上一个版本 即为你上一次commit版本或者pull最近的一次</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout --&lt;filename&gt; # 恢复工作区, 可用于恢复修改和恢复勿删文件</span><br><span class=\"line\">git reset HEAD &lt;file&gt; # 恢复暂存区</span><br><span class=\"line\">git reset HEAD^ # 恢复版本库</span><br><span class=\"line\">git reset --hard &lt;hash版本号 即为log中的一串英文字母, 只需要前几个字母即可&gt;</span><br><span class=\"line\">git reflog # 所有版本日志</span><br><span class=\"line\"></span><br><span class=\"line\">git rm 从版本库中删除文件</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master # 带上 -u 以后提交就不需要加入origin master, 类似记忆功能</span><br><span class=\"line\"></span><br><span class=\"line\">git checkout -b dev 相当于一下两条命令</span><br><span class=\"line\">git branch dev  分支创建</span><br><span class=\"line\">git checkout dev  分支切换</span><br><span class=\"line\"></span><br><span class=\"line\">git branch -d dev   分支删除</span><br><span class=\"line\">git branch   查看当前所有分支</span><br><span class=\"line\">git merge dev  将制定的dev分支合并到当前的分支</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"基础的操作\"><a href=\"#基础的操作\" class=\"headerlink\" title=\"基础的操作\"></a>基础的操作</h1><p><code>git status</code>告诉你 你修改了哪些文件 但是你想知道你怎么修改了这些文件, 做了什么改动</p>\n<p>这时候就需要<code>git diff</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git diff</span><br><span class=\"line\">-------提示如下-----------</span><br><span class=\"line\">diff --git a&#x2F;test.txt b&#x2F;test.txt</span><br><span class=\"line\">index 0858ae8..8c14912 100644</span><br><span class=\"line\">--- a&#x2F;test.txt</span><br><span class=\"line\">+++ b&#x2F;test.txt</span><br><span class=\"line\">@@ -1,3 +1,4 @@</span><br><span class=\"line\"> 111111111111111</span><br><span class=\"line\"> 222222222222222</span><br><span class=\"line\"> 333333333333333</span><br><span class=\"line\">+444444444444444</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"时光穿梭机\"><a href=\"#时光穿梭机\" class=\"headerlink\" title=\"时光穿梭机\"></a>时光穿梭机</h1><p><strong>在commit之间切换</strong><br>Git还可以在不同commit间切换, 当然你必须知道进行过哪些commit, 你不能自己都记在脑子里吧, 所以也存在相关的命令<code>git log</code>来查看你的commit记录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git log</span><br><span class=\"line\">commit ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master)</span><br><span class=\"line\">Author: ***********</span><br><span class=\"line\">Date:   Sat Dec 7 21:06:42 2019 -0800</span><br><span class=\"line\">    ver 0.02</span><br><span class=\"line\"></span><br><span class=\"line\">commit 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class=\"line\">Author: ***********</span><br><span class=\"line\">Date:   Sat Dec 7 20:57:58 2019 -0800</span><br><span class=\"line\">    ver 0.01</span><br><span class=\"line\"></span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git log --pretty&#x3D;oneline # 简洁显示</span><br><span class=\"line\">ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master) ver 0.02</span><br><span class=\"line\">603260e28ac0cc8fb8e4243120eb00bca83585d2 ver 0.01</span><br></pre></td></tr></table></figure>\n<p>上面的<code>HEAD</code>代表当前版本, 上一个版本为<code>HEAD^</code>, 上上一个版本为<code>HEAD^^</code>如此类推<br>回到前N个版本<code>HEAD~N</code><br><code>git reset --hard HEAD^</code> 回到上一个版本.<br>这时你当前版本将会丢失, 使用<code>git log</code>也不会查看到原来的版本信息<br>这时使用<code>git reflog</code>来查看你的所有版本日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git reset --hard 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class=\"line\">HEAD 现在位于 603260e ver 0.01</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git log</span><br><span class=\"line\">commit 603260e28ac0cc8fb8e4243120eb00bca83585d2 (HEAD -&gt; master)</span><br><span class=\"line\">Author: rjd67441 &lt;rjd67441@hotmail.com&gt;</span><br><span class=\"line\">Date:   Sat Dec 7 20:57:58 2019 -0800</span><br><span class=\"line\"></span><br><span class=\"line\">    ver 0.01</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git reflog </span><br><span class=\"line\">603260e (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class=\"line\">ee4400f HEAD@&#123;1&#125;: commit: ver 0.02</span><br><span class=\"line\">603260e (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): ver 0.01</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git reset --hard ee4400f</span><br><span class=\"line\">HEAD 现在位于 ee4400f ver 0.02</span><br></pre></td></tr></table></figure>\n\n<p><strong>撤销修改</strong></p>\n<p>工作区中的撤销<br><code>git checkout -- &lt;filename&gt;</code><br>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。<br>暂存区中的撤销<br><code>git reset HEAD &lt;file&gt;</code><br>版本库的撤销<br><code>git reset HEAD^</code> 乖乖回退一次</p>\n<p><strong>删除文件</strong></p>\n<p>删除本地文件后<br>确实需要从版本库中删除<br><code>git rm</code>删除然后<code>git commit</code>提交即可<br>误删除需要使用<code>git chechout -- &lt;filename&gt;</code>来恢复</p>\n"},{"title":"VIM(spf-13)使用","date":"2020-07-05T12:31:22.000Z","_content":"\nhttps://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html vim分屏\n\n# 乱码解决\n中文乱码\n\n修改locale.conf确实解决了 但我想要的是阿里云那种显示英文中文却不是乱码\n\n最终`vim /etc/vconsole.conf`将cn改为us就解决了....\n\n中间也尝试安装语言包, 记得是已经安装 最终是修改上面那个之后就好了\n\n# 基本操作\n```shell\nR           进入替换模式\n\ne           光标后移一个单词 连续的符号也算一个单词 <<\nE           光标后移一个单词 无视符号\n\nb           光标前移一个单词 连续的符号也算一个单词 <<\nB           光标前移一个单词 无视符号\n\nyy或Y       复制整行          \np           光标之后粘贴\nP大写           光标之前粘贴\n\n# 2020年7月30日10:14:18\nctrl+r      重做撤销内容\nu           撤销\n\n^           本行第一个非空格字符\n$           本行最后一个非空格字符\nG           文件尾\ngg          文件头\n\n# 2020年10月27日08:51:36\nV选中行后\nSHIFT + . 缩进\nSHIFT + , 取消缩进\n\n:1,10> 1~10行缩进\n:1,10< 1~10行取消缩进\n```\n\n\n# 注释 NERDCommenter\n\n```\n,c<space>   当前行注释和切换注释\n\n,cs         块注释当前选中或当前行\nv           小写v进入多字符选择模式\nV           大写V进入多行选择\n```\n\n# 文件导航工具 NERDTree\n```shell\nctrl + e    打开文件导航\no           打开文件, 目录, 标签\ngo          打开文件, 目录, 标签, 但光标仍位于导航栏\n\nR           刷新根目录下所有文件\nr           刷新当前目录下文件\n\n# 2020年7月30日16:22:01\n--------------------------------------\nt           在新tab中打开选中节点书签\nT           同上 但焦点仍在当前tab\n\ngt, gT      在tab之间切换\n\n:tabc       关闭当前tab\n:tabo       关闭其他tab\n:tabs       查看所有打开的tab\n-----------------------------------------\ni           在新的split中打开选择文件 两个部分水平切割\ngi          同上 焦点仍位于导航栏\ns           在新的split中打开选择文件 垂直切割\ngs          同上 焦点仍位于导航栏\n\nctrl+w w    顺序切换, 两个窗口的时候非常方便\nctrl+w hjkl 对应左 下 上 有\n\nctrl+w c    关闭当前split\nctrl+w o    关闭其他split\n-----------------------------------------\n\n\ntab         补全菜单向下移动\nspace       补全为当前单词 附带一个空格\n```","source":"_posts/Linux-VIM折腾spf13.md","raw":"---\ntitle: VIM(spf-13)使用\ndate: 2020-07-05 20:31:22\ncategories: \n- Linux\ntags:\n- spf-13\n---\n\nhttps://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html vim分屏\n\n# 乱码解决\n中文乱码\n\n修改locale.conf确实解决了 但我想要的是阿里云那种显示英文中文却不是乱码\n\n最终`vim /etc/vconsole.conf`将cn改为us就解决了....\n\n中间也尝试安装语言包, 记得是已经安装 最终是修改上面那个之后就好了\n\n# 基本操作\n```shell\nR           进入替换模式\n\ne           光标后移一个单词 连续的符号也算一个单词 <<\nE           光标后移一个单词 无视符号\n\nb           光标前移一个单词 连续的符号也算一个单词 <<\nB           光标前移一个单词 无视符号\n\nyy或Y       复制整行          \np           光标之后粘贴\nP大写           光标之前粘贴\n\n# 2020年7月30日10:14:18\nctrl+r      重做撤销内容\nu           撤销\n\n^           本行第一个非空格字符\n$           本行最后一个非空格字符\nG           文件尾\ngg          文件头\n\n# 2020年10月27日08:51:36\nV选中行后\nSHIFT + . 缩进\nSHIFT + , 取消缩进\n\n:1,10> 1~10行缩进\n:1,10< 1~10行取消缩进\n```\n\n\n# 注释 NERDCommenter\n\n```\n,c<space>   当前行注释和切换注释\n\n,cs         块注释当前选中或当前行\nv           小写v进入多字符选择模式\nV           大写V进入多行选择\n```\n\n# 文件导航工具 NERDTree\n```shell\nctrl + e    打开文件导航\no           打开文件, 目录, 标签\ngo          打开文件, 目录, 标签, 但光标仍位于导航栏\n\nR           刷新根目录下所有文件\nr           刷新当前目录下文件\n\n# 2020年7月30日16:22:01\n--------------------------------------\nt           在新tab中打开选中节点书签\nT           同上 但焦点仍在当前tab\n\ngt, gT      在tab之间切换\n\n:tabc       关闭当前tab\n:tabo       关闭其他tab\n:tabs       查看所有打开的tab\n-----------------------------------------\ni           在新的split中打开选择文件 两个部分水平切割\ngi          同上 焦点仍位于导航栏\ns           在新的split中打开选择文件 垂直切割\ngs          同上 焦点仍位于导航栏\n\nctrl+w w    顺序切换, 两个窗口的时候非常方便\nctrl+w hjkl 对应左 下 上 有\n\nctrl+w c    关闭当前split\nctrl+w o    关闭其他split\n-----------------------------------------\n\n\ntab         补全菜单向下移动\nspace       补全为当前单词 附带一个空格\n```","slug":"Linux-VIM折腾spf13","published":1,"updated":"2020-10-27T01:04:01.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg68000rf8uncjvn3rta","content":"<p><a href=\"https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html</a> vim分屏</p>\n<h1 id=\"乱码解决\"><a href=\"#乱码解决\" class=\"headerlink\" title=\"乱码解决\"></a>乱码解决</h1><p>中文乱码</p>\n<p>修改locale.conf确实解决了 但我想要的是阿里云那种显示英文中文却不是乱码</p>\n<p>最终<code>vim /etc/vconsole.conf</code>将cn改为us就解决了….</p>\n<p>中间也尝试安装语言包, 记得是已经安装 最终是修改上面那个之后就好了</p>\n<h1 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R           进入替换模式</span><br><span class=\"line\"></span><br><span class=\"line\">e           光标后移一个单词 连续的符号也算一个单词 &lt;&lt;</span><br><span class=\"line\">E           光标后移一个单词 无视符号</span><br><span class=\"line\"></span><br><span class=\"line\">b           光标前移一个单词 连续的符号也算一个单词 &lt;&lt;</span><br><span class=\"line\">B           光标前移一个单词 无视符号</span><br><span class=\"line\"></span><br><span class=\"line\">yy或Y       复制整行          </span><br><span class=\"line\">p           光标之后粘贴</span><br><span class=\"line\">P大写           光标之前粘贴</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 2020年7月30日10:14:18</span></span><br><span class=\"line\">ctrl+r      重做撤销内容</span><br><span class=\"line\">u           撤销</span><br><span class=\"line\"></span><br><span class=\"line\">^           本行第一个非空格字符</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">           本行最后一个非空格字符</span></span><br><span class=\"line\">G           文件尾</span><br><span class=\"line\">gg          文件头</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 2020年10月27日08:51:36</span></span><br><span class=\"line\">V选中行后</span><br><span class=\"line\">SHIFT + . 缩进</span><br><span class=\"line\">SHIFT + , 取消缩进</span><br><span class=\"line\"></span><br><span class=\"line\">:1,10&gt; 1~10行缩进</span><br><span class=\"line\">:1,10&lt; 1~10行取消缩进</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"注释-NERDCommenter\"><a href=\"#注释-NERDCommenter\" class=\"headerlink\" title=\"注释 NERDCommenter\"></a>注释 NERDCommenter</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">,c&lt;space&gt;   当前行注释和切换注释</span><br><span class=\"line\"></span><br><span class=\"line\">,cs         块注释当前选中或当前行</span><br><span class=\"line\">v           小写v进入多字符选择模式</span><br><span class=\"line\">V           大写V进入多行选择</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"文件导航工具-NERDTree\"><a href=\"#文件导航工具-NERDTree\" class=\"headerlink\" title=\"文件导航工具 NERDTree\"></a>文件导航工具 NERDTree</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctrl + e    打开文件导航</span><br><span class=\"line\">o           打开文件, 目录, 标签</span><br><span class=\"line\">go          打开文件, 目录, 标签, 但光标仍位于导航栏</span><br><span class=\"line\"></span><br><span class=\"line\">R           刷新根目录下所有文件</span><br><span class=\"line\">r           刷新当前目录下文件</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 2020年7月30日16:22:01</span></span><br><span class=\"line\">--------------------------------------</span><br><span class=\"line\">t           在新tab中打开选中节点书签</span><br><span class=\"line\">T           同上 但焦点仍在当前tab</span><br><span class=\"line\"></span><br><span class=\"line\">gt, gT      在tab之间切换</span><br><span class=\"line\"></span><br><span class=\"line\">:tabc       关闭当前tab</span><br><span class=\"line\">:tabo       关闭其他tab</span><br><span class=\"line\">:tabs       查看所有打开的tab</span><br><span class=\"line\">-----------------------------------------</span><br><span class=\"line\">i           在新的split中打开选择文件 两个部分水平切割</span><br><span class=\"line\">gi          同上 焦点仍位于导航栏</span><br><span class=\"line\">s           在新的split中打开选择文件 垂直切割</span><br><span class=\"line\">gs          同上 焦点仍位于导航栏</span><br><span class=\"line\"></span><br><span class=\"line\">ctrl+w w    顺序切换, 两个窗口的时候非常方便</span><br><span class=\"line\">ctrl+w hjkl 对应左 下 上 有</span><br><span class=\"line\"></span><br><span class=\"line\">ctrl+w c    关闭当前split</span><br><span class=\"line\">ctrl+w o    关闭其他split</span><br><span class=\"line\">-----------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">tab         补全菜单向下移动</span><br><span class=\"line\">space       补全为当前单词 附带一个空格</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/floatedclouds/archive/2011/11/10/2245008.html</a> vim分屏</p>\n<h1 id=\"乱码解决\"><a href=\"#乱码解决\" class=\"headerlink\" title=\"乱码解决\"></a>乱码解决</h1><p>中文乱码</p>\n<p>修改locale.conf确实解决了 但我想要的是阿里云那种显示英文中文却不是乱码</p>\n<p>最终<code>vim /etc/vconsole.conf</code>将cn改为us就解决了….</p>\n<p>中间也尝试安装语言包, 记得是已经安装 最终是修改上面那个之后就好了</p>\n<h1 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R           进入替换模式</span><br><span class=\"line\"></span><br><span class=\"line\">e           光标后移一个单词 连续的符号也算一个单词 &lt;&lt;</span><br><span class=\"line\">E           光标后移一个单词 无视符号</span><br><span class=\"line\"></span><br><span class=\"line\">b           光标前移一个单词 连续的符号也算一个单词 &lt;&lt;</span><br><span class=\"line\">B           光标前移一个单词 无视符号</span><br><span class=\"line\"></span><br><span class=\"line\">yy或Y       复制整行          </span><br><span class=\"line\">p           光标之后粘贴</span><br><span class=\"line\">P大写           光标之前粘贴</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 2020年7月30日10:14:18</span></span><br><span class=\"line\">ctrl+r      重做撤销内容</span><br><span class=\"line\">u           撤销</span><br><span class=\"line\"></span><br><span class=\"line\">^           本行第一个非空格字符</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">           本行最后一个非空格字符</span></span><br><span class=\"line\">G           文件尾</span><br><span class=\"line\">gg          文件头</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 2020年10月27日08:51:36</span></span><br><span class=\"line\">V选中行后</span><br><span class=\"line\">SHIFT + . 缩进</span><br><span class=\"line\">SHIFT + , 取消缩进</span><br><span class=\"line\"></span><br><span class=\"line\">:1,10&gt; 1~10行缩进</span><br><span class=\"line\">:1,10&lt; 1~10行取消缩进</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"注释-NERDCommenter\"><a href=\"#注释-NERDCommenter\" class=\"headerlink\" title=\"注释 NERDCommenter\"></a>注释 NERDCommenter</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">,c&lt;space&gt;   当前行注释和切换注释</span><br><span class=\"line\"></span><br><span class=\"line\">,cs         块注释当前选中或当前行</span><br><span class=\"line\">v           小写v进入多字符选择模式</span><br><span class=\"line\">V           大写V进入多行选择</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"文件导航工具-NERDTree\"><a href=\"#文件导航工具-NERDTree\" class=\"headerlink\" title=\"文件导航工具 NERDTree\"></a>文件导航工具 NERDTree</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctrl + e    打开文件导航</span><br><span class=\"line\">o           打开文件, 目录, 标签</span><br><span class=\"line\">go          打开文件, 目录, 标签, 但光标仍位于导航栏</span><br><span class=\"line\"></span><br><span class=\"line\">R           刷新根目录下所有文件</span><br><span class=\"line\">r           刷新当前目录下文件</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 2020年7月30日16:22:01</span></span><br><span class=\"line\">--------------------------------------</span><br><span class=\"line\">t           在新tab中打开选中节点书签</span><br><span class=\"line\">T           同上 但焦点仍在当前tab</span><br><span class=\"line\"></span><br><span class=\"line\">gt, gT      在tab之间切换</span><br><span class=\"line\"></span><br><span class=\"line\">:tabc       关闭当前tab</span><br><span class=\"line\">:tabo       关闭其他tab</span><br><span class=\"line\">:tabs       查看所有打开的tab</span><br><span class=\"line\">-----------------------------------------</span><br><span class=\"line\">i           在新的split中打开选择文件 两个部分水平切割</span><br><span class=\"line\">gi          同上 焦点仍位于导航栏</span><br><span class=\"line\">s           在新的split中打开选择文件 垂直切割</span><br><span class=\"line\">gs          同上 焦点仍位于导航栏</span><br><span class=\"line\"></span><br><span class=\"line\">ctrl+w w    顺序切换, 两个窗口的时候非常方便</span><br><span class=\"line\">ctrl+w hjkl 对应左 下 上 有</span><br><span class=\"line\"></span><br><span class=\"line\">ctrl+w c    关闭当前split</span><br><span class=\"line\">ctrl+w o    关闭其他split</span><br><span class=\"line\">-----------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">tab         补全菜单向下移动</span><br><span class=\"line\">space       补全为当前单词 附带一个空格</span><br></pre></td></tr></table></figure>"},{"title":"GDB调试","date":"2020-03-14T07:09:20.000Z","_content":"\nhttps://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\n\n对多线程的支持\nset follow-fork-mode [parent|child]\nset detach-on-fork [on|off]\n\n| follow-fork-mode | detach-on-fork | 说明 |\n| --- | --- | --- |\n| parent | on | 只调试主进程 |\n| child | on | 只调试子进程 |\n| parent | off | 同时调试父子进程, gdb跟踪父进程, 子进程阻塞在fork位置 |\n| child | off | 同上 gdb跟踪子进程, 父进程阻塞 |\n\n进程间切换\n| 命令 | 功能 |\n| --- | --- |\n| info inferiors | 查询正在调试的进程 |\n| inferior \\<number> | 切换进程 |\n\n\n| 运行命令 | 缩写 | 功能 |\n| --- | --- | --- |\n| run | r | 运行程序 |\n| continue | c | 继续执行到下有一个断点处 |\n| next | n | 单步跟踪, 不进入函数 |\n| step | s | 会进入函数 |\n| until | | 运行程序直到退出循环体 |\n| until + 行号 | | 运行至某行 |\n| finish | | 运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回以及参数等信息 |\n| call 函数(参数) | | 调试程序中的可见参数, 并传递参数 |\n| quit | q | 退出 |\n\n| 设置断点 | 缩写 | 功能 |\n| --- | --- |--- |\n| break n | b n | 在第n行设置断点, b xx.cpp:500(xx.cpp文件第500行) |\n| b fn if a>b | | 在函数f 或者行号n 设置条件断点 |\n| break func | b func | 在函数func()的入口处设置断点 |\n| delete 断点号n | | 删除第n个断点 |\n| disable 断点号n | | 暂停第n个断点 |\n| enable 断点号n | | 开始第n的断点 |\n| clear 行号n | | 清除第n行的断点 |\n| info b | | 显示断点设置情况 |\n| delete breakpoints | | 清除所有断点 |\n\n| 查看源代码 | 缩写 | 功能 |\n| --- | --- | --- |\n| list | l | 默认显示10行 |\n| list 行号 | | 以行号为中心的前后十行代码 |\n| list 函数名 | | 列出函数名所在函数的代码 |\n| list | | 不带参数, 接着上一次的list命令输出下边的内容 |\n\n| 打印表达式 | 功能 |\n| --- | --- |\n| print p | |\n| p a | 显示a的值 |\n| p ++a | a的值 |\n| p func(22) | 以整数22作为参数调用 后打印 |\n| p func(a) | 将变量a作为参数 |\n| display 表达式 | 每次单步运行后就打印表达式的值 |\n| watch 表达式 | 设置检视点, 一旦被监视的表达式值改变就强行终止正在被调试的程序 |\n| whatis | 查询变量或函数 |\n| info function | 查询函数 |\n| info local | 显示当前堆栈页的所有变量 |\n\n\n| 查询运行信息 | 功能 |\n| --- | --- |\n| where/bt | 当前运行的堆栈列表 |\n| bt backtrace | 显示当前的调用堆栈 |\n| up/down | 改变堆栈的显示深度 |\n| set args [args]| 指定程序运行参数 |\n| show args| 查看程序参数 |\n| info program | 查看程序是否运行, 进程号, 被暂停原因 |\n\n\n# 安装DebugInfo\n```\ncat /etc/yum.repos.d/CentOS-Debug.repo\n\n[debug]\nname=CentOS-$releasever - DebugInfo\nbaseurl=http://debuginfo.centos.org/$releasever/$basearch/\ngpgcheck=0\nenabled=1 # 重点是这个 \nprotect=1\npriority=1\n\n\n安装 kernel-debuginfo\nyum --enablerepo=base-debug install -y kernel-debuginfo-$(uname -r)\n\n安装glibc, 提示缺少其他的也是如此安装\ndebuginfo-install glibc\n```","source":"_posts/Linux-GDB调试.md","raw":"---\ntitle: GDB调试\ndate: 2020-03-14 15:09:20\ncategories: \n- Linux\ntags:\n- GDB调试\n---\n\nhttps://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\n\n对多线程的支持\nset follow-fork-mode [parent|child]\nset detach-on-fork [on|off]\n\n| follow-fork-mode | detach-on-fork | 说明 |\n| --- | --- | --- |\n| parent | on | 只调试主进程 |\n| child | on | 只调试子进程 |\n| parent | off | 同时调试父子进程, gdb跟踪父进程, 子进程阻塞在fork位置 |\n| child | off | 同上 gdb跟踪子进程, 父进程阻塞 |\n\n进程间切换\n| 命令 | 功能 |\n| --- | --- |\n| info inferiors | 查询正在调试的进程 |\n| inferior \\<number> | 切换进程 |\n\n\n| 运行命令 | 缩写 | 功能 |\n| --- | --- | --- |\n| run | r | 运行程序 |\n| continue | c | 继续执行到下有一个断点处 |\n| next | n | 单步跟踪, 不进入函数 |\n| step | s | 会进入函数 |\n| until | | 运行程序直到退出循环体 |\n| until + 行号 | | 运行至某行 |\n| finish | | 运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回以及参数等信息 |\n| call 函数(参数) | | 调试程序中的可见参数, 并传递参数 |\n| quit | q | 退出 |\n\n| 设置断点 | 缩写 | 功能 |\n| --- | --- |--- |\n| break n | b n | 在第n行设置断点, b xx.cpp:500(xx.cpp文件第500行) |\n| b fn if a>b | | 在函数f 或者行号n 设置条件断点 |\n| break func | b func | 在函数func()的入口处设置断点 |\n| delete 断点号n | | 删除第n个断点 |\n| disable 断点号n | | 暂停第n个断点 |\n| enable 断点号n | | 开始第n的断点 |\n| clear 行号n | | 清除第n行的断点 |\n| info b | | 显示断点设置情况 |\n| delete breakpoints | | 清除所有断点 |\n\n| 查看源代码 | 缩写 | 功能 |\n| --- | --- | --- |\n| list | l | 默认显示10行 |\n| list 行号 | | 以行号为中心的前后十行代码 |\n| list 函数名 | | 列出函数名所在函数的代码 |\n| list | | 不带参数, 接着上一次的list命令输出下边的内容 |\n\n| 打印表达式 | 功能 |\n| --- | --- |\n| print p | |\n| p a | 显示a的值 |\n| p ++a | a的值 |\n| p func(22) | 以整数22作为参数调用 后打印 |\n| p func(a) | 将变量a作为参数 |\n| display 表达式 | 每次单步运行后就打印表达式的值 |\n| watch 表达式 | 设置检视点, 一旦被监视的表达式值改变就强行终止正在被调试的程序 |\n| whatis | 查询变量或函数 |\n| info function | 查询函数 |\n| info local | 显示当前堆栈页的所有变量 |\n\n\n| 查询运行信息 | 功能 |\n| --- | --- |\n| where/bt | 当前运行的堆栈列表 |\n| bt backtrace | 显示当前的调用堆栈 |\n| up/down | 改变堆栈的显示深度 |\n| set args [args]| 指定程序运行参数 |\n| show args| 查看程序参数 |\n| info program | 查看程序是否运行, 进程号, 被暂停原因 |\n\n\n# 安装DebugInfo\n```\ncat /etc/yum.repos.d/CentOS-Debug.repo\n\n[debug]\nname=CentOS-$releasever - DebugInfo\nbaseurl=http://debuginfo.centos.org/$releasever/$basearch/\ngpgcheck=0\nenabled=1 # 重点是这个 \nprotect=1\npriority=1\n\n\n安装 kernel-debuginfo\nyum --enablerepo=base-debug install -y kernel-debuginfo-$(uname -r)\n\n安装glibc, 提示缺少其他的也是如此安装\ndebuginfo-install glibc\n```","slug":"Linux-GDB调试","published":1,"updated":"2020-08-09T15:32:41.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg69000tf8un101rdnyu","content":"<p><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\" target=\"_blank\" rel=\"noopener\">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p>\n<p>对多线程的支持<br>set follow-fork-mode [parent|child]<br>set detach-on-fork [on|off]</p>\n<table>\n<thead>\n<tr>\n<th>follow-fork-mode</th>\n<th>detach-on-fork</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>parent</td>\n<td>on</td>\n<td>只调试主进程</td>\n</tr>\n<tr>\n<td>child</td>\n<td>on</td>\n<td>只调试子进程</td>\n</tr>\n<tr>\n<td>parent</td>\n<td>off</td>\n<td>同时调试父子进程, gdb跟踪父进程, 子进程阻塞在fork位置</td>\n</tr>\n<tr>\n<td>child</td>\n<td>off</td>\n<td>同上 gdb跟踪子进程, 父进程阻塞</td>\n</tr>\n</tbody></table>\n<p>进程间切换<br>| 命令 | 功能 |<br>| — | — |<br>| info inferiors | 查询正在调试的进程 |<br>| inferior &lt;number&gt; | 切换进程 |</p>\n<table>\n<thead>\n<tr>\n<th>运行命令</th>\n<th>缩写</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>run</td>\n<td>r</td>\n<td>运行程序</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>c</td>\n<td>继续执行到下有一个断点处</td>\n</tr>\n<tr>\n<td>next</td>\n<td>n</td>\n<td>单步跟踪, 不进入函数</td>\n</tr>\n<tr>\n<td>step</td>\n<td>s</td>\n<td>会进入函数</td>\n</tr>\n<tr>\n<td>until</td>\n<td></td>\n<td>运行程序直到退出循环体</td>\n</tr>\n<tr>\n<td>until + 行号</td>\n<td></td>\n<td>运行至某行</td>\n</tr>\n<tr>\n<td>finish</td>\n<td></td>\n<td>运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回以及参数等信息</td>\n</tr>\n<tr>\n<td>call 函数(参数)</td>\n<td></td>\n<td>调试程序中的可见参数, 并传递参数</td>\n</tr>\n<tr>\n<td>quit</td>\n<td>q</td>\n<td>退出</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>设置断点</th>\n<th>缩写</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>break n</td>\n<td>b n</td>\n<td>在第n行设置断点, b xx.cpp:500(xx.cpp文件第500行)</td>\n</tr>\n<tr>\n<td>b fn if a&gt;b</td>\n<td></td>\n<td>在函数f 或者行号n 设置条件断点</td>\n</tr>\n<tr>\n<td>break func</td>\n<td>b func</td>\n<td>在函数func()的入口处设置断点</td>\n</tr>\n<tr>\n<td>delete 断点号n</td>\n<td></td>\n<td>删除第n个断点</td>\n</tr>\n<tr>\n<td>disable 断点号n</td>\n<td></td>\n<td>暂停第n个断点</td>\n</tr>\n<tr>\n<td>enable 断点号n</td>\n<td></td>\n<td>开始第n的断点</td>\n</tr>\n<tr>\n<td>clear 行号n</td>\n<td></td>\n<td>清除第n行的断点</td>\n</tr>\n<tr>\n<td>info b</td>\n<td></td>\n<td>显示断点设置情况</td>\n</tr>\n<tr>\n<td>delete breakpoints</td>\n<td></td>\n<td>清除所有断点</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查看源代码</th>\n<th>缩写</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>list</td>\n<td>l</td>\n<td>默认显示10行</td>\n</tr>\n<tr>\n<td>list 行号</td>\n<td></td>\n<td>以行号为中心的前后十行代码</td>\n</tr>\n<tr>\n<td>list 函数名</td>\n<td></td>\n<td>列出函数名所在函数的代码</td>\n</tr>\n<tr>\n<td>list</td>\n<td></td>\n<td>不带参数, 接着上一次的list命令输出下边的内容</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>打印表达式</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>print p</td>\n<td></td>\n</tr>\n<tr>\n<td>p a</td>\n<td>显示a的值</td>\n</tr>\n<tr>\n<td>p ++a</td>\n<td>a的值</td>\n</tr>\n<tr>\n<td>p func(22)</td>\n<td>以整数22作为参数调用 后打印</td>\n</tr>\n<tr>\n<td>p func(a)</td>\n<td>将变量a作为参数</td>\n</tr>\n<tr>\n<td>display 表达式</td>\n<td>每次单步运行后就打印表达式的值</td>\n</tr>\n<tr>\n<td>watch 表达式</td>\n<td>设置检视点, 一旦被监视的表达式值改变就强行终止正在被调试的程序</td>\n</tr>\n<tr>\n<td>whatis</td>\n<td>查询变量或函数</td>\n</tr>\n<tr>\n<td>info function</td>\n<td>查询函数</td>\n</tr>\n<tr>\n<td>info local</td>\n<td>显示当前堆栈页的所有变量</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查询运行信息</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>where/bt</td>\n<td>当前运行的堆栈列表</td>\n</tr>\n<tr>\n<td>bt backtrace</td>\n<td>显示当前的调用堆栈</td>\n</tr>\n<tr>\n<td>up/down</td>\n<td>改变堆栈的显示深度</td>\n</tr>\n<tr>\n<td>set args [args]</td>\n<td>指定程序运行参数</td>\n</tr>\n<tr>\n<td>show args</td>\n<td>查看程序参数</td>\n</tr>\n<tr>\n<td>info program</td>\n<td>查看程序是否运行, 进程号, 被暂停原因</td>\n</tr>\n</tbody></table>\n<h1 id=\"安装DebugInfo\"><a href=\"#安装DebugInfo\" class=\"headerlink\" title=\"安装DebugInfo\"></a>安装DebugInfo</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Debug.repo</span><br><span class=\"line\"></span><br><span class=\"line\">[debug]</span><br><span class=\"line\">name&#x3D;CentOS-$releasever - DebugInfo</span><br><span class=\"line\">baseurl&#x3D;http:&#x2F;&#x2F;debuginfo.centos.org&#x2F;$releasever&#x2F;$basearch&#x2F;</span><br><span class=\"line\">gpgcheck&#x3D;0</span><br><span class=\"line\">enabled&#x3D;1 # 重点是这个 </span><br><span class=\"line\">protect&#x3D;1</span><br><span class=\"line\">priority&#x3D;1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">安装 kernel-debuginfo</span><br><span class=\"line\">yum --enablerepo&#x3D;base-debug install -y kernel-debuginfo-$(uname -r)</span><br><span class=\"line\"></span><br><span class=\"line\">安装glibc, 提示缺少其他的也是如此安装</span><br><span class=\"line\">debuginfo-install glibc</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\" target=\"_blank\" rel=\"noopener\">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p>\n<p>对多线程的支持<br>set follow-fork-mode [parent|child]<br>set detach-on-fork [on|off]</p>\n<table>\n<thead>\n<tr>\n<th>follow-fork-mode</th>\n<th>detach-on-fork</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>parent</td>\n<td>on</td>\n<td>只调试主进程</td>\n</tr>\n<tr>\n<td>child</td>\n<td>on</td>\n<td>只调试子进程</td>\n</tr>\n<tr>\n<td>parent</td>\n<td>off</td>\n<td>同时调试父子进程, gdb跟踪父进程, 子进程阻塞在fork位置</td>\n</tr>\n<tr>\n<td>child</td>\n<td>off</td>\n<td>同上 gdb跟踪子进程, 父进程阻塞</td>\n</tr>\n</tbody></table>\n<p>进程间切换<br>| 命令 | 功能 |<br>| — | — |<br>| info inferiors | 查询正在调试的进程 |<br>| inferior &lt;number&gt; | 切换进程 |</p>\n<table>\n<thead>\n<tr>\n<th>运行命令</th>\n<th>缩写</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>run</td>\n<td>r</td>\n<td>运行程序</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>c</td>\n<td>继续执行到下有一个断点处</td>\n</tr>\n<tr>\n<td>next</td>\n<td>n</td>\n<td>单步跟踪, 不进入函数</td>\n</tr>\n<tr>\n<td>step</td>\n<td>s</td>\n<td>会进入函数</td>\n</tr>\n<tr>\n<td>until</td>\n<td></td>\n<td>运行程序直到退出循环体</td>\n</tr>\n<tr>\n<td>until + 行号</td>\n<td></td>\n<td>运行至某行</td>\n</tr>\n<tr>\n<td>finish</td>\n<td></td>\n<td>运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回以及参数等信息</td>\n</tr>\n<tr>\n<td>call 函数(参数)</td>\n<td></td>\n<td>调试程序中的可见参数, 并传递参数</td>\n</tr>\n<tr>\n<td>quit</td>\n<td>q</td>\n<td>退出</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>设置断点</th>\n<th>缩写</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>break n</td>\n<td>b n</td>\n<td>在第n行设置断点, b xx.cpp:500(xx.cpp文件第500行)</td>\n</tr>\n<tr>\n<td>b fn if a&gt;b</td>\n<td></td>\n<td>在函数f 或者行号n 设置条件断点</td>\n</tr>\n<tr>\n<td>break func</td>\n<td>b func</td>\n<td>在函数func()的入口处设置断点</td>\n</tr>\n<tr>\n<td>delete 断点号n</td>\n<td></td>\n<td>删除第n个断点</td>\n</tr>\n<tr>\n<td>disable 断点号n</td>\n<td></td>\n<td>暂停第n个断点</td>\n</tr>\n<tr>\n<td>enable 断点号n</td>\n<td></td>\n<td>开始第n的断点</td>\n</tr>\n<tr>\n<td>clear 行号n</td>\n<td></td>\n<td>清除第n行的断点</td>\n</tr>\n<tr>\n<td>info b</td>\n<td></td>\n<td>显示断点设置情况</td>\n</tr>\n<tr>\n<td>delete breakpoints</td>\n<td></td>\n<td>清除所有断点</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查看源代码</th>\n<th>缩写</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>list</td>\n<td>l</td>\n<td>默认显示10行</td>\n</tr>\n<tr>\n<td>list 行号</td>\n<td></td>\n<td>以行号为中心的前后十行代码</td>\n</tr>\n<tr>\n<td>list 函数名</td>\n<td></td>\n<td>列出函数名所在函数的代码</td>\n</tr>\n<tr>\n<td>list</td>\n<td></td>\n<td>不带参数, 接着上一次的list命令输出下边的内容</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>打印表达式</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>print p</td>\n<td></td>\n</tr>\n<tr>\n<td>p a</td>\n<td>显示a的值</td>\n</tr>\n<tr>\n<td>p ++a</td>\n<td>a的值</td>\n</tr>\n<tr>\n<td>p func(22)</td>\n<td>以整数22作为参数调用 后打印</td>\n</tr>\n<tr>\n<td>p func(a)</td>\n<td>将变量a作为参数</td>\n</tr>\n<tr>\n<td>display 表达式</td>\n<td>每次单步运行后就打印表达式的值</td>\n</tr>\n<tr>\n<td>watch 表达式</td>\n<td>设置检视点, 一旦被监视的表达式值改变就强行终止正在被调试的程序</td>\n</tr>\n<tr>\n<td>whatis</td>\n<td>查询变量或函数</td>\n</tr>\n<tr>\n<td>info function</td>\n<td>查询函数</td>\n</tr>\n<tr>\n<td>info local</td>\n<td>显示当前堆栈页的所有变量</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查询运行信息</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>where/bt</td>\n<td>当前运行的堆栈列表</td>\n</tr>\n<tr>\n<td>bt backtrace</td>\n<td>显示当前的调用堆栈</td>\n</tr>\n<tr>\n<td>up/down</td>\n<td>改变堆栈的显示深度</td>\n</tr>\n<tr>\n<td>set args [args]</td>\n<td>指定程序运行参数</td>\n</tr>\n<tr>\n<td>show args</td>\n<td>查看程序参数</td>\n</tr>\n<tr>\n<td>info program</td>\n<td>查看程序是否运行, 进程号, 被暂停原因</td>\n</tr>\n</tbody></table>\n<h1 id=\"安装DebugInfo\"><a href=\"#安装DebugInfo\" class=\"headerlink\" title=\"安装DebugInfo\"></a>安装DebugInfo</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Debug.repo</span><br><span class=\"line\"></span><br><span class=\"line\">[debug]</span><br><span class=\"line\">name&#x3D;CentOS-$releasever - DebugInfo</span><br><span class=\"line\">baseurl&#x3D;http:&#x2F;&#x2F;debuginfo.centos.org&#x2F;$releasever&#x2F;$basearch&#x2F;</span><br><span class=\"line\">gpgcheck&#x3D;0</span><br><span class=\"line\">enabled&#x3D;1 # 重点是这个 </span><br><span class=\"line\">protect&#x3D;1</span><br><span class=\"line\">priority&#x3D;1</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">安装 kernel-debuginfo</span><br><span class=\"line\">yum --enablerepo&#x3D;base-debug install -y kernel-debuginfo-$(uname -r)</span><br><span class=\"line\"></span><br><span class=\"line\">安装glibc, 提示缺少其他的也是如此安装</span><br><span class=\"line\">debuginfo-install glibc</span><br></pre></td></tr></table></figure>"},{"title":"Linux的使用","date":"2020-03-17T04:29:20.000Z","_content":"\n| 命令 | 功能 |\n| --- | --- |\n| cp -r | 复制目录 |\n| cd - | 切换到上一个工作目录 |\n\n\n| 查找 | 功能 |\n| --- | --- |\n| find ./ -name \"core*\" | xargs file | 搜寻目录或文件 |\n| find ./ -name '*.o' | 查找目标文件夹是否有obj文件 |\n| find ./ -name \"*.o\" \\| xargs rm -f | 递归删除当前目录所有obj文件 |\n\n\n| 查看文件内容 | 功能 | 一般用法|\n| --- | --- | --- |\n| cat -n | 显示的同时显示行号 | 使用管道 ls \\| cat -n |\n| head -10 filename | 查看前十行 | |\n| tail -10 failname | 查看后十行 ||\n| diff file1 file2 | 查看文件差别 ||\n| tail -f filename | 动态显示文本的最新信息 ||\n\n\n| 给文件增加别名 | 功能 |\n| ln a b | 创建硬链接, 删除一个另一个仍能使用 |\n| ln -s a b | 创建符号链接(软连接) 删除源后另一个无法使用 |\n\n\n命令行快捷键\nCtl-U   删除光标到行首的所有字符 `$ 1111 222  --> $ `\nCtl-W   删除光标到前边最近一个空格之间的字符 `$ 1111 222 --> $ 1111`\n\n\n","source":"_posts/Linux-Linux使用.md","raw":"---\ntitle: Linux的使用\ndate: 2020-03-17 12:29:20\ncategories: \n- Linux\ntags:\n- Linux\n---\n\n| 命令 | 功能 |\n| --- | --- |\n| cp -r | 复制目录 |\n| cd - | 切换到上一个工作目录 |\n\n\n| 查找 | 功能 |\n| --- | --- |\n| find ./ -name \"core*\" | xargs file | 搜寻目录或文件 |\n| find ./ -name '*.o' | 查找目标文件夹是否有obj文件 |\n| find ./ -name \"*.o\" \\| xargs rm -f | 递归删除当前目录所有obj文件 |\n\n\n| 查看文件内容 | 功能 | 一般用法|\n| --- | --- | --- |\n| cat -n | 显示的同时显示行号 | 使用管道 ls \\| cat -n |\n| head -10 filename | 查看前十行 | |\n| tail -10 failname | 查看后十行 ||\n| diff file1 file2 | 查看文件差别 ||\n| tail -f filename | 动态显示文本的最新信息 ||\n\n\n| 给文件增加别名 | 功能 |\n| ln a b | 创建硬链接, 删除一个另一个仍能使用 |\n| ln -s a b | 创建符号链接(软连接) 删除源后另一个无法使用 |\n\n\n命令行快捷键\nCtl-U   删除光标到行首的所有字符 `$ 1111 222  --> $ `\nCtl-W   删除光标到前边最近一个空格之间的字符 `$ 1111 222 --> $ 1111`\n\n\n","slug":"Linux-Linux使用","published":1,"updated":"2020-08-09T15:30:45.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6b000yf8un2fkkhkgf","content":"<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cp -r</td>\n<td>复制目录</td>\n</tr>\n<tr>\n<td>cd -</td>\n<td>切换到上一个工作目录</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查找</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>find ./ -name “core*”</td>\n<td>xargs file</td>\n</tr>\n<tr>\n<td>find ./ -name ‘*.o’</td>\n<td>查找目标文件夹是否有obj文件</td>\n</tr>\n<tr>\n<td>find ./ -name “*.o” | xargs rm -f</td>\n<td>递归删除当前目录所有obj文件</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查看文件内容</th>\n<th>功能</th>\n<th>一般用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cat -n</td>\n<td>显示的同时显示行号</td>\n<td>使用管道 ls | cat -n</td>\n</tr>\n<tr>\n<td>head -10 filename</td>\n<td>查看前十行</td>\n<td></td>\n</tr>\n<tr>\n<td>tail -10 failname</td>\n<td>查看后十行</td>\n<td></td>\n</tr>\n<tr>\n<td>diff file1 file2</td>\n<td>查看文件差别</td>\n<td></td>\n</tr>\n<tr>\n<td>tail -f filename</td>\n<td>动态显示文本的最新信息</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>| 给文件增加别名 | 功能 |<br>| ln a b | 创建硬链接, 删除一个另一个仍能使用 |<br>| ln -s a b | 创建符号链接(软连接) 删除源后另一个无法使用 |</p>\n<p>命令行快捷键<br>Ctl-U   删除光标到行首的所有字符 <code>$ 1111 222  --&gt; $</code><br>Ctl-W   删除光标到前边最近一个空格之间的字符 <code>$ 1111 222 --&gt; $ 1111</code></p>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cp -r</td>\n<td>复制目录</td>\n</tr>\n<tr>\n<td>cd -</td>\n<td>切换到上一个工作目录</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查找</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>find ./ -name “core*”</td>\n<td>xargs file</td>\n</tr>\n<tr>\n<td>find ./ -name ‘*.o’</td>\n<td>查找目标文件夹是否有obj文件</td>\n</tr>\n<tr>\n<td>find ./ -name “*.o” | xargs rm -f</td>\n<td>递归删除当前目录所有obj文件</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查看文件内容</th>\n<th>功能</th>\n<th>一般用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cat -n</td>\n<td>显示的同时显示行号</td>\n<td>使用管道 ls | cat -n</td>\n</tr>\n<tr>\n<td>head -10 filename</td>\n<td>查看前十行</td>\n<td></td>\n</tr>\n<tr>\n<td>tail -10 failname</td>\n<td>查看后十行</td>\n<td></td>\n</tr>\n<tr>\n<td>diff file1 file2</td>\n<td>查看文件差别</td>\n<td></td>\n</tr>\n<tr>\n<td>tail -f filename</td>\n<td>动态显示文本的最新信息</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>| 给文件增加别名 | 功能 |<br>| ln a b | 创建硬链接, 删除一个另一个仍能使用 |<br>| ln -s a b | 创建符号链接(软连接) 删除源后另一个无法使用 |</p>\n<p>命令行快捷键<br>Ctl-U   删除光标到行首的所有字符 <code>$ 1111 222  --&gt; $</code><br>Ctl-W   删除光标到前边最近一个空格之间的字符 <code>$ 1111 222 --&gt; $ 1111</code></p>\n"},{"title":"Shell脚本编写","date":"2020-03-26T09:30:22.000Z","_content":"\n由于阿里云服务器github速度异常缓慢, 自己想把一个shell, 改成本地版本发现不是很容易.\n所以咕咕咕很久的shell脚本, 算是开始学了. 感觉入门应该不会太难把\n\n我先来我最喜欢的入门网站 菜鸟教程!\n\n既然写的是脚本就需要解释器了\n1. `#!/bin/bash` 这个通常见于脚本的第一行, `#!`算是个约定了 说明脚本需要什么解释器\n2. `/bin/sh xx.sh` 这种是执行的时候指定, 脚本第一行的那个就失效了\n\n**shell变量-挺正常的规定**\n- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\n- 中间不能有空格，可以使用下划线（_）。\n- 不能使用标点符号。\n- 不能使用bash里的关键字（可用help命令查看保留关键字）。\n\nshell变量类型\n- 局部变量\n- 环境变量\n- shell变量-shell内置特殊变量\n\n变量定义 *注意 不能随便加空格 下面的等号两侧不能加空格*\n```shell\n# 直接赋值\nxxx=\"lsmg\"\nxxx = \"lsmg\" # 错误\nxxx=\"Jigokubana\" # 随意修改\n\n# 语句赋值\nfor skill in Ada Coffe Action Java\ndo\n    echo \"I am good at ${skill}Script\"\ndone\n\n# 使用变量\necho $xxx\necho ${xxx} # {} 用于标记边界\necho \"my name is ${xxx}\"\n\n# const\nreadonly xxx=\"lsmg\" \n\n # 删除变量\nunset xxx; 不能用于删除只读变量\n```\n\n单双引号字符串\n```shell\n# shell 双引号字符串\n# # 可以含有转义字符 和变量\nxxx1=\"\\\"lsmg\\\"\"\necho xxx1 # $ \"lsmg\"\n\n\n# shell单引号字符串\n# # 会原样输出, 无视变量. 即使转义也不能出现单一的单引号 但可以成对出现 用于拼接字符串\nxxx2='lsmg' \n\n# 拼接双引号变量双引号输出 单引号变量单引号输出\nyour_name=\"runoob\"\n# # 使用双引号拼接\ngreeting=\"hello, \"$your_name\" !\"\ngreeting_1=\"hello, ${your_name} !\"\necho $greeting  $greeting_1 # hello, runoob ! hello, runoob !\n# # 使用单引号拼接\ngreeting_2='hello, '$your_name' !'\ngreeting_3='hello, ${your_name} !'\necho $greeting_2  $greeting_3 # hello, runoob ! hello, ${your_name} !\n```\n\n字符串操作\n```shell\nurl=\"https://blog.lsmg.xyz\"\n\necho ${#url} # 输出长度 21\n\n# 注意单引号\necho `expr index \"$url\" go` # 输出 字符 g o的位置 哪个先出现就输出哪个\n\n# 字符串截取\n# # 范围截取\necho #{url:0:5} # 输出 https 第二个数字代表字符个数 不是范围\n\n# # #截取删除左边字符, 保留右侧字符\necho #{url#*//} # blog.lsmg.xyz\n\n```\n\n数组\n```shell\n# 空格分隔\nname=(lsmg Lsmg Jigokubana);\n\n# 你甚至可以 不连续定义\nnickname[0]=lsmg\nnickname[2]=Lsmg\n\n# 读取\necho ${nickname[0] nickname[1] nickname[2]}\n# 输出所有\necho ${name[@]}\n# 取得数组元素个数\necho ${#name[@]}\n# 取得单个元素长度\necho ${#name[1]}\n```\n\n参数\n```shell\n$0\n$1\n$2\n# .... 为具体某个参数\n\n$# # 参数个数 不包括$0\n$@ # 参数数组 解析为一个数组\n$* # 参数字符串 解析为一整个字符串\n\n```","source":"_posts/Linux-shell脚本编写.md","raw":"---\ntitle: Shell脚本编写\ndate: 2020-03-26 17:30:22\ncategories: \n- Linux\ntags:\n- Shell\n---\n\n由于阿里云服务器github速度异常缓慢, 自己想把一个shell, 改成本地版本发现不是很容易.\n所以咕咕咕很久的shell脚本, 算是开始学了. 感觉入门应该不会太难把\n\n我先来我最喜欢的入门网站 菜鸟教程!\n\n既然写的是脚本就需要解释器了\n1. `#!/bin/bash` 这个通常见于脚本的第一行, `#!`算是个约定了 说明脚本需要什么解释器\n2. `/bin/sh xx.sh` 这种是执行的时候指定, 脚本第一行的那个就失效了\n\n**shell变量-挺正常的规定**\n- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。\n- 中间不能有空格，可以使用下划线（_）。\n- 不能使用标点符号。\n- 不能使用bash里的关键字（可用help命令查看保留关键字）。\n\nshell变量类型\n- 局部变量\n- 环境变量\n- shell变量-shell内置特殊变量\n\n变量定义 *注意 不能随便加空格 下面的等号两侧不能加空格*\n```shell\n# 直接赋值\nxxx=\"lsmg\"\nxxx = \"lsmg\" # 错误\nxxx=\"Jigokubana\" # 随意修改\n\n# 语句赋值\nfor skill in Ada Coffe Action Java\ndo\n    echo \"I am good at ${skill}Script\"\ndone\n\n# 使用变量\necho $xxx\necho ${xxx} # {} 用于标记边界\necho \"my name is ${xxx}\"\n\n# const\nreadonly xxx=\"lsmg\" \n\n # 删除变量\nunset xxx; 不能用于删除只读变量\n```\n\n单双引号字符串\n```shell\n# shell 双引号字符串\n# # 可以含有转义字符 和变量\nxxx1=\"\\\"lsmg\\\"\"\necho xxx1 # $ \"lsmg\"\n\n\n# shell单引号字符串\n# # 会原样输出, 无视变量. 即使转义也不能出现单一的单引号 但可以成对出现 用于拼接字符串\nxxx2='lsmg' \n\n# 拼接双引号变量双引号输出 单引号变量单引号输出\nyour_name=\"runoob\"\n# # 使用双引号拼接\ngreeting=\"hello, \"$your_name\" !\"\ngreeting_1=\"hello, ${your_name} !\"\necho $greeting  $greeting_1 # hello, runoob ! hello, runoob !\n# # 使用单引号拼接\ngreeting_2='hello, '$your_name' !'\ngreeting_3='hello, ${your_name} !'\necho $greeting_2  $greeting_3 # hello, runoob ! hello, ${your_name} !\n```\n\n字符串操作\n```shell\nurl=\"https://blog.lsmg.xyz\"\n\necho ${#url} # 输出长度 21\n\n# 注意单引号\necho `expr index \"$url\" go` # 输出 字符 g o的位置 哪个先出现就输出哪个\n\n# 字符串截取\n# # 范围截取\necho #{url:0:5} # 输出 https 第二个数字代表字符个数 不是范围\n\n# # #截取删除左边字符, 保留右侧字符\necho #{url#*//} # blog.lsmg.xyz\n\n```\n\n数组\n```shell\n# 空格分隔\nname=(lsmg Lsmg Jigokubana);\n\n# 你甚至可以 不连续定义\nnickname[0]=lsmg\nnickname[2]=Lsmg\n\n# 读取\necho ${nickname[0] nickname[1] nickname[2]}\n# 输出所有\necho ${name[@]}\n# 取得数组元素个数\necho ${#name[@]}\n# 取得单个元素长度\necho ${#name[1]}\n```\n\n参数\n```shell\n$0\n$1\n$2\n# .... 为具体某个参数\n\n$# # 参数个数 不包括$0\n$@ # 参数数组 解析为一个数组\n$* # 参数字符串 解析为一整个字符串\n\n```","slug":"Linux-shell脚本编写","published":1,"updated":"2020-08-09T04:10:49.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6c0010f8un22z588aq","content":"<p>由于阿里云服务器github速度异常缓慢, 自己想把一个shell, 改成本地版本发现不是很容易.<br>所以咕咕咕很久的shell脚本, 算是开始学了. 感觉入门应该不会太难把</p>\n<p>我先来我最喜欢的入门网站 菜鸟教程!</p>\n<p>既然写的是脚本就需要解释器了</p>\n<ol>\n<li><code>#!/bin/bash</code> 这个通常见于脚本的第一行, <code>#!</code>算是个约定了 说明脚本需要什么解释器</li>\n<li><code>/bin/sh xx.sh</code> 这种是执行的时候指定, 脚本第一行的那个就失效了</li>\n</ol>\n<p><strong>shell变量-挺正常的规定</strong></p>\n<ul>\n<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>\n<li>中间不能有空格，可以使用下划线（_）。</li>\n<li>不能使用标点符号。</li>\n<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>\n</ul>\n<p>shell变量类型</p>\n<ul>\n<li>局部变量</li>\n<li>环境变量</li>\n<li>shell变量-shell内置特殊变量</li>\n</ul>\n<p>变量定义 <em>注意 不能随便加空格 下面的等号两侧不能加空格</em></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 直接赋值</span></span><br><span class=\"line\">xxx=\"lsmg\"</span><br><span class=\"line\">xxx = \"lsmg\" # 错误</span><br><span class=\"line\">xxx=\"Jigokubana\" # 随意修改</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 语句赋值</span></span><br><span class=\"line\">for skill in Ada Coffe Action Java</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"I am good at $&#123;skill&#125;Script\"</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用变量</span></span><br><span class=\"line\">echo $xxx</span><br><span class=\"line\">echo $&#123;xxx&#125; # &#123;&#125; 用于标记边界</span><br><span class=\"line\">echo \"my name is $&#123;xxx&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> const</span></span><br><span class=\"line\">readonly xxx=\"lsmg\" </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"> #</span><span class=\"bash\"> 删除变量</span></span><br><span class=\"line\">unset xxx; 不能用于删除只读变量</span><br></pre></td></tr></table></figure>\n\n<p>单双引号字符串</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> shell 双引号字符串</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"comment\"># 可以含有转义字符 和变量</span></span></span><br><span class=\"line\">xxx1=\"\\\"lsmg\\\"\"</span><br><span class=\"line\">echo xxx1 # $ \"lsmg\"</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> shell单引号字符串</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"comment\"># 会原样输出, 无视变量. 即使转义也不能出现单一的单引号 但可以成对出现 用于拼接字符串</span></span></span><br><span class=\"line\">xxx2='lsmg' </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 拼接双引号变量双引号输出 单引号变量单引号输出</span></span><br><span class=\"line\">your_name=\"runoob\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"comment\"># 使用双引号拼接</span></span></span><br><span class=\"line\">greeting=\"hello, \"$your_name\" !\"</span><br><span class=\"line\">greeting_1=\"hello, $&#123;your_name&#125; !\"</span><br><span class=\"line\">echo $greeting  $greeting_1 # hello, runoob ! hello, runoob !</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"comment\"># 使用单引号拼接</span></span></span><br><span class=\"line\">greeting_2='hello, '$your_name' !'</span><br><span class=\"line\">greeting_3='hello, $&#123;your_name&#125; !'</span><br><span class=\"line\">echo $greeting_2  $greeting_3 # hello, runoob ! hello, $&#123;your_name&#125; !</span><br></pre></td></tr></table></figure>\n\n<p>字符串操作</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url=\"https://blog.lsmg.xyz\"</span><br><span class=\"line\"></span><br><span class=\"line\">echo $&#123;#url&#125; # 输出长度 21</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意单引号</span></span><br><span class=\"line\">echo `expr index \"$url\" go` # 输出 字符 g o的位置 哪个先出现就输出哪个</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 字符串截取</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"comment\"># 范围截取</span></span></span><br><span class=\"line\">echo #&#123;url:0:5&#125; # 输出 https 第二个数字代表字符个数 不是范围</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"comment\"># #截取删除左边字符, 保留右侧字符</span></span></span><br><span class=\"line\">echo #&#123;url#*//&#125; # blog.lsmg.xyz</span><br></pre></td></tr></table></figure>\n\n<p>数组</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 空格分隔</span></span><br><span class=\"line\">name=(lsmg Lsmg Jigokubana);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 你甚至可以 不连续定义</span></span><br><span class=\"line\">nickname[0]=lsmg</span><br><span class=\"line\">nickname[2]=Lsmg</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 读取</span></span><br><span class=\"line\">echo $&#123;nickname[0] nickname[1] nickname[2]&#125;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输出所有</span></span><br><span class=\"line\">echo $&#123;name[@]&#125;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 取得数组元素个数</span></span><br><span class=\"line\">echo $&#123;#name[@]&#125;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 取得单个元素长度</span></span><br><span class=\"line\">echo $&#123;#name[1]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">0</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">1</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">2</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> .... 为具体某个参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"><span class=\"comment\"># # 参数个数 不包括$0</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">@ <span class=\"comment\"># 参数数组 解析为一个数组</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">* <span class=\"comment\"># 参数字符串 解析为一整个字符串</span></span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>由于阿里云服务器github速度异常缓慢, 自己想把一个shell, 改成本地版本发现不是很容易.<br>所以咕咕咕很久的shell脚本, 算是开始学了. 感觉入门应该不会太难把</p>\n<p>我先来我最喜欢的入门网站 菜鸟教程!</p>\n<p>既然写的是脚本就需要解释器了</p>\n<ol>\n<li><code>#!/bin/bash</code> 这个通常见于脚本的第一行, <code>#!</code>算是个约定了 说明脚本需要什么解释器</li>\n<li><code>/bin/sh xx.sh</code> 这种是执行的时候指定, 脚本第一行的那个就失效了</li>\n</ol>\n<p><strong>shell变量-挺正常的规定</strong></p>\n<ul>\n<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li>\n<li>中间不能有空格，可以使用下划线（_）。</li>\n<li>不能使用标点符号。</li>\n<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li>\n</ul>\n<p>shell变量类型</p>\n<ul>\n<li>局部变量</li>\n<li>环境变量</li>\n<li>shell变量-shell内置特殊变量</li>\n</ul>\n<p>变量定义 <em>注意 不能随便加空格 下面的等号两侧不能加空格</em></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 直接赋值</span></span><br><span class=\"line\">xxx=\"lsmg\"</span><br><span class=\"line\">xxx = \"lsmg\" # 错误</span><br><span class=\"line\">xxx=\"Jigokubana\" # 随意修改</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 语句赋值</span></span><br><span class=\"line\">for skill in Ada Coffe Action Java</span><br><span class=\"line\">do</span><br><span class=\"line\">    echo \"I am good at $&#123;skill&#125;Script\"</span><br><span class=\"line\">done</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 使用变量</span></span><br><span class=\"line\">echo $xxx</span><br><span class=\"line\">echo $&#123;xxx&#125; # &#123;&#125; 用于标记边界</span><br><span class=\"line\">echo \"my name is $&#123;xxx&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> const</span></span><br><span class=\"line\">readonly xxx=\"lsmg\" </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"> #</span><span class=\"bash\"> 删除变量</span></span><br><span class=\"line\">unset xxx; 不能用于删除只读变量</span><br></pre></td></tr></table></figure>\n\n<p>单双引号字符串</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> shell 双引号字符串</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"comment\"># 可以含有转义字符 和变量</span></span></span><br><span class=\"line\">xxx1=\"\\\"lsmg\\\"\"</span><br><span class=\"line\">echo xxx1 # $ \"lsmg\"</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> shell单引号字符串</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"comment\"># 会原样输出, 无视变量. 即使转义也不能出现单一的单引号 但可以成对出现 用于拼接字符串</span></span></span><br><span class=\"line\">xxx2='lsmg' </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 拼接双引号变量双引号输出 单引号变量单引号输出</span></span><br><span class=\"line\">your_name=\"runoob\"</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"comment\"># 使用双引号拼接</span></span></span><br><span class=\"line\">greeting=\"hello, \"$your_name\" !\"</span><br><span class=\"line\">greeting_1=\"hello, $&#123;your_name&#125; !\"</span><br><span class=\"line\">echo $greeting  $greeting_1 # hello, runoob ! hello, runoob !</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"comment\"># 使用单引号拼接</span></span></span><br><span class=\"line\">greeting_2='hello, '$your_name' !'</span><br><span class=\"line\">greeting_3='hello, $&#123;your_name&#125; !'</span><br><span class=\"line\">echo $greeting_2  $greeting_3 # hello, runoob ! hello, $&#123;your_name&#125; !</span><br></pre></td></tr></table></figure>\n\n<p>字符串操作</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url=\"https://blog.lsmg.xyz\"</span><br><span class=\"line\"></span><br><span class=\"line\">echo $&#123;#url&#125; # 输出长度 21</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意单引号</span></span><br><span class=\"line\">echo `expr index \"$url\" go` # 输出 字符 g o的位置 哪个先出现就输出哪个</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 字符串截取</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"comment\"># 范围截取</span></span></span><br><span class=\"line\">echo #&#123;url:0:5&#125; # 输出 https 第二个数字代表字符个数 不是范围</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> <span class=\"comment\"># #截取删除左边字符, 保留右侧字符</span></span></span><br><span class=\"line\">echo #&#123;url#*//&#125; # blog.lsmg.xyz</span><br></pre></td></tr></table></figure>\n\n<p>数组</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 空格分隔</span></span><br><span class=\"line\">name=(lsmg Lsmg Jigokubana);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 你甚至可以 不连续定义</span></span><br><span class=\"line\">nickname[0]=lsmg</span><br><span class=\"line\">nickname[2]=Lsmg</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 读取</span></span><br><span class=\"line\">echo $&#123;nickname[0] nickname[1] nickname[2]&#125;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 输出所有</span></span><br><span class=\"line\">echo $&#123;name[@]&#125;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 取得数组元素个数</span></span><br><span class=\"line\">echo $&#123;#name[@]&#125;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 取得单个元素长度</span></span><br><span class=\"line\">echo $&#123;#name[1]&#125;</span><br></pre></td></tr></table></figure>\n\n<p>参数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">0</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">1</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">2</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> .... 为具体某个参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"><span class=\"comment\"># # 参数个数 不包括$0</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">@ <span class=\"comment\"># 参数数组 解析为一个数组</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">* <span class=\"comment\"># 参数字符串 解析为一整个字符串</span></span></span><br></pre></td></tr></table></figure>"},{"title":"权限管理","date":"2020-03-14T07:09:20.000Z","_content":"\n`drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs`\n档案权限类型\n连接数\n档案拥有者\n档案所属群组\n档案容量\n档案最后被修改时间\n档名\n\n文件类型和权限\n`drwxr-xr-x`\n\n第一位 d 表明档案类型是 目录\n\n| 字符 | 含义 |\n| --- | --- |\n| d | 目录 |\n| - | 文件 |\n| \\| | 链接文件 |\n| b | 设备文件中可供存储的周边设备, 可随机读取设备 |\n| c | 序列号设备, 如键盘鼠标, 一次性读取设备 |\n\n\n后面每三位一组 为`rwx`的组合 分别代表 `读`, `写`, `执行`\n三组 第一组`文件拥有者权限` 第二组`群组中账号权限` 第三组`非本人且没有加入本群组的其他账号权限`\n\n第三部分表示这个文件的`拥有者账号`\n第四部分表示这个文件`所属群组`\n\n相关命令\n-chgrp 改变文件所属群组\n-chown 改变文件拥有者\n-chmod 改变文件权限\n\n","source":"_posts/Linux-权限相关.md","raw":"---\ntitle: 权限管理\ndate: 2020-03-14 15:09:20\ncategories: \n- Linux\ntags:\n- 权限管理\n---\n\n`drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs`\n档案权限类型\n连接数\n档案拥有者\n档案所属群组\n档案容量\n档案最后被修改时间\n档名\n\n文件类型和权限\n`drwxr-xr-x`\n\n第一位 d 表明档案类型是 目录\n\n| 字符 | 含义 |\n| --- | --- |\n| d | 目录 |\n| - | 文件 |\n| \\| | 链接文件 |\n| b | 设备文件中可供存储的周边设备, 可随机读取设备 |\n| c | 序列号设备, 如键盘鼠标, 一次性读取设备 |\n\n\n后面每三位一组 为`rwx`的组合 分别代表 `读`, `写`, `执行`\n三组 第一组`文件拥有者权限` 第二组`群组中账号权限` 第三组`非本人且没有加入本群组的其他账号权限`\n\n第三部分表示这个文件的`拥有者账号`\n第四部分表示这个文件`所属群组`\n\n相关命令\n-chgrp 改变文件所属群组\n-chown 改变文件拥有者\n-chmod 改变文件权限\n\n","slug":"Linux-权限相关","published":1,"updated":"2020-07-02T04:47:32.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6e0013f8un7yeg2paw","content":"<p><code>drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs</code><br>档案权限类型<br>连接数<br>档案拥有者<br>档案所属群组<br>档案容量<br>档案最后被修改时间<br>档名</p>\n<p>文件类型和权限<br><code>drwxr-xr-x</code></p>\n<p>第一位 d 表明档案类型是 目录</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>d</td>\n<td>目录</td>\n</tr>\n<tr>\n<td>-</td>\n<td>文件</td>\n</tr>\n<tr>\n<td>|</td>\n<td>链接文件</td>\n</tr>\n<tr>\n<td>b</td>\n<td>设备文件中可供存储的周边设备, 可随机读取设备</td>\n</tr>\n<tr>\n<td>c</td>\n<td>序列号设备, 如键盘鼠标, 一次性读取设备</td>\n</tr>\n</tbody></table>\n<p>后面每三位一组 为<code>rwx</code>的组合 分别代表 <code>读</code>, <code>写</code>, <code>执行</code><br>三组 第一组<code>文件拥有者权限</code> 第二组<code>群组中账号权限</code> 第三组<code>非本人且没有加入本群组的其他账号权限</code></p>\n<p>第三部分表示这个文件的<code>拥有者账号</code><br>第四部分表示这个文件<code>所属群组</code></p>\n<p>相关命令<br>-chgrp 改变文件所属群组<br>-chown 改变文件拥有者<br>-chmod 改变文件权限</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs</code><br>档案权限类型<br>连接数<br>档案拥有者<br>档案所属群组<br>档案容量<br>档案最后被修改时间<br>档名</p>\n<p>文件类型和权限<br><code>drwxr-xr-x</code></p>\n<p>第一位 d 表明档案类型是 目录</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>d</td>\n<td>目录</td>\n</tr>\n<tr>\n<td>-</td>\n<td>文件</td>\n</tr>\n<tr>\n<td>|</td>\n<td>链接文件</td>\n</tr>\n<tr>\n<td>b</td>\n<td>设备文件中可供存储的周边设备, 可随机读取设备</td>\n</tr>\n<tr>\n<td>c</td>\n<td>序列号设备, 如键盘鼠标, 一次性读取设备</td>\n</tr>\n</tbody></table>\n<p>后面每三位一组 为<code>rwx</code>的组合 分别代表 <code>读</code>, <code>写</code>, <code>执行</code><br>三组 第一组<code>文件拥有者权限</code> 第二组<code>群组中账号权限</code> 第三组<code>非本人且没有加入本群组的其他账号权限</code></p>\n<p>第三部分表示这个文件的<code>拥有者账号</code><br>第四部分表示这个文件<code>所属群组</code></p>\n<p>相关命令<br>-chgrp 改变文件所属群组<br>-chown 改变文件拥有者<br>-chmod 改变文件权限</p>\n"},{"title":"暑假学习记录与总结","date":"2019-07-13T04:13:22.000Z","_content":"<div class=\"alert-red\">では、ゲームを始(はじ)めましょう</div>\n\n自己与研究生无缘了, 不过嘛, 是好是坏我也不知道, 现在也只能多学点技术, 去工作了, 这个暑假很重要, 所以将会每天记录下.\n\n[在线图床](https://imgurl.org/)\n[设计模式主要学习](https://blog.csdn.net/lovelion/article/details/17517213)\n设计模式次要补充 -- head first java 设计模式\n\n<!--more-->\n## 总结\n\n![](暑假学习记录与总结/4.png)\n总结一下这个暑假都干了什么, 马上就要开学了.\n七月十三日到七月十九日, 这是第一周了.这一周伴随着到处参观, 收货很少了. 那时我还在主用Java, 主要的是学习了一些设计模式, 这一周的时间对我学习C++ 帮助也是有的. 暑假学习设计模式也是出于换语言的考虑. \n第一天(七月十三日)可以说是看的最多的了解了什么是耦合和解耦, 一些简单的设计模式(简单工厂, 工厂方法, 抽象工厂, 单例模式). \n第二天(七月十四日) 开始初步试验大创项目的实现, 当时遇到一个BUG, 我需要返回一个东西, 但我还是需要返回后将他删除, 首先就是将他”复制了一份”, 然后删除, 却发现返回去的都是空的,了解到了Java如何进行深拷贝.\n七月十六日看了下Java编程思想的多态部分, 然后主要时间修改网络助手的开机启动设置, 这样开机启动设置就没有问题了.\n七月十七日收拾家伙, 休息了休息准备回家, 结果虽然我确认了好几次自己有没有带全家伙, 鼠标笔记本都带上了,\n七月十八日到达北京去我姐那里暂住了, 结果发现我…..光带回了一个鼠标, 鼠标的接收器还在USB分线器上(吐血) 然后开始了一个开源项目的阅读. 云收藏(SpringBoot框架). 发现了自己没有看懂的东西(Stirng ...), 就去了解下JDK从5-8每次更新加入的内容,了解到那个叫做可变参数需要搭配增强for循环使用\n七月十九日-七月二十日我终于实现了自己理想….怎么说呢北方最大的漫展依然没有我想象的大, 等我有机会既定要去一次南方\n\n七月二十一日到七月二十七日写了个后端练手(一个失物招领) . 使用了丝袜哥写Api文档, SpringJpa作为持久层? 这几天放松了玩了几天游戏可惜了.\n七月二十八日总结两个小项目比较靠近项目的地方, 统一返回类型, 预定义数据, SpringJpa.\n.学习了 接口 内部类 持有对象. 通过查看源码解决了一个Bug,\n七月二十九日到八月二日 编写二手交易后台.\n\n想去了解下大数据相关内容\n八月三日到八月九日 看了下关于大数据的内容, 并不是很感兴趣.\n八月十日到八月十五日 主要是写算法题目, 然后寻找自己是佛要从事游戏服务器编程\n八月十六日到八月二十四日 上午复习高数, 下午看C++\n@2019年8月24日18:21:07@\n\n\n## 大纲\n设计模式不求多, 但求会用, 极大概率调整设计模式的学习.\n此外需要刷一些常用的算法\n\n```\n7.13-7.19\n<复用类, 多态>\n---六个创建型模式\n- 简单工厂模式\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n- 原型模式(略过)\n- 建造者模式(略过)\n7.20-7.26\n<接口, 内部类, 持有对象>\n---七个结构型模式\n- 适配器模式\n- 桥接模式\n- 组合模式\n- 外观模式\n7.27-8.02\n<类型信息, 泛型>\n- 装饰模式\n- 享元模式(略过)\n- 代理模式\n8.03-8.09\n<数组, 容器深入研究>\n---十一个行为型模式\n- 职责链模式\n- 命令模式\n- 解释器模式(略过)\n- 迭代器模式\n- 中介者模式(略过)\n- 备忘录模式(略过)\n- 观察者模式\n8.10-8.16\n<IO, 枚举类型>\n- 状态模式\n- 策略模式\n- 模板方法模式\n- 访问者模(略过)\n8.17-8.23\n<注解, 并发>\n\n```\n# では、ゲームを始(はじ)めましょう\n## 7.13-7.19\n```\n7.13-7.19\n<复用类, 多态>\n---六个创建型模式\n- 简单工厂模式\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n```\n### 7月13日\n\n```\n- 简单工厂模式\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n```\n\n2019年7月13日12:21:17\n上午参观参观参观...... 重置了下, 这个暑期表格.今天开始第一天的打卡.下午还有参观, 然后就可以开始学了\n\n下午有b站血族直播\n下午看了一个项目, 自己不会的还是太多,,,,,, 给了源码都看不太懂.\n还是先继续看几个设计模式吧, 设计模式目前想的是, 了解大概, 等到时用到了再去详细学习\n\n#### 耦合与解耦\n耦合: 两个或两个以上的体系之间互相结合, 互相影响, 产生的一个联合起来解决问题的体系.\n这种体系, 不利于修改, 修改一个体系可能会影响到另一个体系, 使得另一个体系需要做出修改.\n解耦: 将体系之间的联系降到最低, 各司其职, 修改本身的时候, 不需要去动其他的体系\n\n#### 简单工厂模式\n简单工厂模式不属于GoF 23种设计模式\n通过设计一个父类(产品类), 由他派生出多个子类(具体产品类), 通过一个工厂类, 提供给工厂类生产方法不同的参数, 由工厂类return相应的子类, 由父类接受.\n\n解决问题: 通过工厂类, 只需要记住参数, 就可以产生相应的子类,\n存在问题: 不符合开闭原则, 每次产生新的产品, 都需要去修改相应的工厂生产方法.\n\n#### 工厂方法模式\n与简单工厂有些相似之处: 均存在一个产品父类和多个产品子类.\n不同之处在于 工厂方法模式, 设置了工厂父类, 通过派生出不同的工厂子类来return相应的子类.\n\n解决问题: 解决了简单工厂模式的开闭原则, 每次产生新的产品, 只需要派生一个相应的子类即可\n存在问题: 系统中由于新产品的产生, 类的个数将会成对增加, 会有更多的类需要处理\n\n#### 抽象工厂模式\n抽象工厂模式解决了工厂方法模式某些情况下 导致的类成对增加情况\n一个抽象工厂里包含了这个\"工厂\"的所有产品--这对应了一个产品族\n可以派生出多个工厂来实现多品牌产品--形成了一个等级结构\n![引用自上文博客](https://img-blog.csdn.net/20130713162941328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n#### 单例模式\n这个模式理解起来很容易, 但是效果却十分的不错, 之前用过一次所以详细写一下.\n**饿汉式单例模式**\n饿汉式单例模式 无延迟加载 不需要解决多线程问题\n```java\n/**\n * @ClassName singletonpattern.Connect\n * @Description\n * 饿汉式单例模式 无延迟加载 不需要解决多线程问题\n * Author lsmg\n * Date 2019/5/21 13:25\n * @Version 1.0\n **/\npublic class Connect {\n    private static final Connect instance = new Connect();\n\n    private Connect(){\n\n    }\n\n    public static Connect getInstance(){\n        return instance;\n    }\n}\n```\n**懒汉式单例模式**\n```java\npackage singletonpattern;\n懒汉式单例模式 实现了延迟加载,但需要解决多线程问题\n/**\n * @ClassName singletonpattern.Connect1_2\n * @Description TODO\n * 懒汉式单例模式 实现了延迟加载,但需要解决多线程问题\n * Author lsmg\n * Date 2019/5/21 13:30\n * @Version 1.0\n **/\npublic class Connect1_2 {\n    private static Connect1_2  connect1_2;\n\n    private Connect1_2(){}\n\n    //这种方式会造成多线程访问的时候实例化多个对象\n//    public  static singletonpattern.Connect1_2 getInstance(){\n//        if(connect1_2 == null){\n//            connect1_2 = new singletonpattern.Connect1_2();\n//        }\n//\n//        return connect1_2;\n//    }\n\n    //这种方式虽然确保了只有一个线程进入, 但是降低了多线程的性能\n//    public synchronized static singletonpattern.Connect1_2 getInstance(){\n//        if(connect1_2 == null){\n//            connect1_2 = new singletonpattern.Connect1_2();\n//        }\n//\n//        return connect1_2;\n//    }\n\n\n    //这种方式需要在private \"volatile\" static singletonpattern.Connect1_2 connect1_2 这样同样降低效率\n//    public synchronized static singletonpattern.Connect1_2 getInstance(){\n//        if(connect1_2 == null){\n//\n//            synchronized (singletonpattern.Connect1_2.class){\n//                if(connect1_2 == null){\n//                    connect1_2 = new singletonpattern.Connect1_2();\n//                }\n//            }\n//\n//        }\n//\n//        return connect1_2;\n//    }\n```\n**使用IoDH方法结合二者优点**\n由于静态单例对象没有作为Singleton的成员变量直接初始化, 当调用`getInstance()`方法的时候, 会加载内部类HolderClass, 其中的static 由Java虚拟机保证线程安全性, 这样就结合了`饿汉式单例模式的线程安全`和`懒汉式单例模式的延迟加载`\n\n```java\n//Initialization on Demand Holder\nclass Singleton {\n\tprivate Singleton() {\n\t}\n\t\n\tprivate static class HolderClass {\n            private final static Singleton instance = new Singleton();\n\t}\n\t\n\tpublic static Singleton getInstance() {\n\t    return HolderClass.instance;\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t    Singleton s1, s2; \n        s1 = Singleton.getInstance();\n\t    s2 = Singleton.getInstance();\n\t    System.out.println(s1==s2);\n\t}\n}\n```\n@2019年7月13日19:07:46 设计模式暂时到这里, 去写写代码吧@\n\n### 7月14日\n```\n复用类看了一部分, 目前还差final部分\n```\n@2019年7月14日09:43:46@\n\n下午看了看大创项目的实现, 选择了高德地图api. 中午的时候太困了 搞得我没有仔细看\n目前决定采用[动态延展路径](https://lbs.amap.com/api/amap-ui/demos/amap-ui-pathsimplifier/expand-path)  解决问题, path由ajax 异步获取更新.\n#### 小插曲-Java List深浅拷贝\n```java\n@Service(\"droneStatusService\")\npublic class DroneStatusServiceImpl implements DroneStatusService {\n\n    private Logger logger = LoggerFactory.getLogger(DroneStatusServiceImpl.class);\n\n    private List<DroneStatus> droneStatusList = new ArrayList<>();\n/**删除其他代码**/\n    @Override\n    public List<DroneStatus> listDroneStatus() {\n        List<DroneStatus> theDroneStatusList = droneStatusList;\n\t\tdroneStatusList.clear(); /**这样导致了我的return list一直为空**/\n        logger.info(\"清除一次信息list共\"+theDroneStatusList.size()+\"条\");\n\n        return theDroneStatusList;\n    }\n}\n```\n第一印象这样写, 排查方法就是想到了关于Java引用的部分.\n对于list的拷贝 `遍历循环复制`和`List的构造方法`和`list.addAll()`以及`System.arraycopy()` 这些全部是`浅复制`他们指向了同一片内存区域\n\n深复制的实现方法另实体类 实现Cloneable接口 重写clone方法\n```java\n@Override\npublic Object clone() {\n\tEntity entity = null;\n\ttry {\n\t\tentity = (Entity)  super.clone();\n\t} catch (CloneNotSupportedException e) {\n\t\te.printStackTrace();\n\t}\n\treturn entity;\n}\n```\n\n然后我写了一个工具类\n```java\npublic static List<Entity> deepCopy(List<Entity> originList) {\n\tList<Entity> entityList = new ArrayList<>();\n\tfor(Entity entity : originList) {\n\t\tentityList.add((Entity) entity.clone());\n\t}\n\n\treturn entityList;\n}\n```\n通过这个工具类实现深复制\n\t\n `IDEA CTRL+ALT+T`收获这个快捷键\n![](https://i.bmp.ovh/imgs/2019/07/9fe10225fe9a52a5.png)\n@2019年7月14日17:47:23@\n\n大创先告一段落了, 等和他们对接吧, 基本功能显示路径已经做好了.\n@2019年7月14日20:29:30@\n复用类看完了\n@2019年7月14日21:14:12@\n\n### 7月15日\n把GGO通关了, 游戏就告一段落了.\n\n### 7月16日\n```\n多态\n```\n把编程思想-多态看一下吧\n\n多态这里怎么说呢, 重要的是思想吧, 自己没用过太多, 都是一些框架需要\n@2019年7月16日08:42:35@\n\n把书里的内容过了一遍, 怎么感觉不是很实用. 但是也说了一些小问题. 继承这种东西, 自己代码里都没有用太多.\n@2019年7月16日09:25:47@\n\n改了一部分BUG, 小软件的开机启动设置修改了下, 貌似可以了.\n@2019年7月16日17:39:40@\n\n### 7月17日\n上午收拾了下,  下午的话休息了休息, 晚上去吃了顿好的, 收拾回家的东西\n\n### 7月18日\n上午坐了一上午的车, 下午到了北京, 然后把电脑的内存条换上了(现在是16G的内存了, 够用了). **难受的是, 光带了鼠标没有带鼠标的接收器!!!!!!!(我以为插件可以代替接收器, 结果插线也得要接收器... 算了吧)**\n\n#### 下午继续看了一部分 云收藏的源码看到了这个下面一个函数\n```java\npublic static void main(String[] args) {\n\tSystem.out.println(getMessage(\"1\", \"2\", \"3\", \"4\"));\n}\n\npublic static String getMessage(String template, String... keys) {\n\tint count = 0;\n\tStringBuilder templateBuilder = new StringBuilder(template);\n\tfor (String key : keys) {\n\t\ttemplateBuilder.append(key);\n\t}\n\ttemplate = templateBuilder.toString();\n\treturn template;\n}\n```\n重点不是函数的功能, 而是`String...`这不是写错了. 我去网上查了下, 这样这个函数就可以接受多个参数了\n`getMessage(\"template\", \"a\", \"b\", \"c\")` 接受参数后用 增强for循环以此取出就好\n\n`是从Java 5开始，Java语言对方法参数支持一种新写法，叫可变长度参数列表`\n\n正好在这里去搜集下每次Java更新, 所提供的新特性\n\n#### JDK5 新特性\n\n#自动装箱与拆箱\n```Java\nInteger a = new Integer(10); \n//这个问题不大\nInteger b = 100; //这里就把一个int自动转成了 integer类型(自动装箱)\n//这里用到了 Integer的 valueOf()方法 实现的自动装箱\nb += 100; //b = b + 100; 用intValue()来自动拆箱\n//实现方式 b = Integer.valueOf(b.intValue() + 200); \n```\n\n#枚举类型\n```Java\nswitch \n// switch可以 switch枚举类型\n```\n\n#静态导入\n```Java\nimport static java.lang.Math.pow; \n//静态导入的必须是静态方法\nSystem.out.println(Math.pow(2, 3)); //未使用静态导入\nSystem.out.println(pow(2, 3)); //使用静态导入\n```\n\n#可变参数\n```Java\n//可以在方法参数的类型中 加入三个`...`, 这样在方法体内可以使用for的增强循环来获得传入的多个参数.\npublic static void main(String[] args) {\n\tSystem.out.println(getMessage(\"1\", \"2\", \"3\", \"4\"));\n}\n\npublic static String getMessage(String template, String... keys) {\n\tint count = 0;\n\tStringBuilder templateBuilder = new StringBuilder(template);\n\tfor (String key : keys) {\n\t\ttemplateBuilder.append(key);\n\t}\n\ttemplate = templateBuilder.toString();\n\treturn template;\n}\n```\n\n#增强for循环\n#泛型 (Generic Type)\n#内省\n\n\n#### JDK6 新特性\n\n#Desktop类和SystemTray类\n第一个`Desktop`类\n可以用来打开系统默认浏览器浏览指定的URL\n打开系统默认邮件客户端给指定的邮箱发邮件\n用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件)\n用系统默认的打印机打印文档\n第二个`SystemTray`类\n可以用来在系统托盘区创建一个托盘程序.\nJava的UI方面就不写太多了\n\n@2019年7月18日20:47:07@\n\n#### Springboot配置文件\n在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式\n其中{profile}对应你的环境标识\n\n下面列举三个文件\n`application-dev.properties`：开发环境\n`application-test.properties`：测试环境\n`application-prod.properties`：生产环境\n至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。\n`spring.profiles.active=dev`\n\n### 7月19日\n今天的话在北京待了一天, 去看了看北方最大的漫展IDO, 怎么说呢比我想象的要小一点, 不过比徐州那个好太多了. 以后有机会的话就去南方了.\n\n## 7.20-7.26\n```\n<接口, 内部类, 持有对象>\n---七个结构型模式\n- 适配器模式\n- 桥接模式\n- 组合模式\n- 外观模式\n```\n\n### 7月20日\n今天还是胳膊有些疼, 昨天拿的东西不少, 背的也不少.走的路也不少.....\n@2019年7月20日19:39:08@\n\n现在来看一些东西吧. 上个寒假在家里留了一本Java编程思想.\n\n### 7月21日\n写了个新的小项目, 正好来练练手. 新项目单独列出一篇博客.\n\n### 7月22日\n在家里午觉睡不着我凑, 改下小项目的问题.\n@去看一下设计模式吧@\n\n#### 适配器模式\n这个设计模式怎么说呢, 挺简单的.\n就是 新建一个适配器类Adapter  引用一个需要适配的类Adaptee 这个类实现客户端的接口Target\n\n这样客户端直接调用接口 相关转换工作在接口中完成.\n\n## 7.27-8.02\n\n```\n<类型信息, 泛型>\n- 装饰模式\n- 享元模式(略过)\n- 代理模式\n```\n\n### 7月28日\n从7.23-7.25 写了个小项目, 失物招领的后端. \n总的来说有 \n#### 统一反应类型\n将所有的返回结果, 写在一个类中\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951.png)\n\n预先定义的异常信息, 则使用了enum\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952.png)\n\n封装反回数据, 使用Object\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953.png)\n\n这样处理后就可以\n```java\nreturn new ResponseData(ExceptionMsg.DEL_FAILED);\n\nreturn new ResponseData(ExceptionMsg.DEL_FAILED);\n\nreturn  new ResponseData(ExceptionMsg.SUCCESS, lostAndFoundInfo);\n```\n\n来统一返回类型\n\n#### Spring Jpa的方便\n\n配置完毕后, 去编写相应的实体类\n```yml\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/lostandfound?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8&useSSL=true\nspring.datasource.username=root\nspring.datasource.password=root\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\nspring.jpa.properties.hibernate.hbm2ddl.auto=update\n\n# create：只要每次加载 Hibernate 时就都会删除上一次生成的表，然后根据 model 类再重新来生成新表. \n# create-drop：每次加载 Hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭，表就自动删除。\n# update：最常用的属性，第一次加载 Hibernate 时根据 model 类会自动建立起表的结构（前提是先建立# # 好数据库），以后加载 Hibernate 时根据 model 类自动更新表结构，即使表结构改变了，但表中的行仍然存在，不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。\n#validate ：每次加载 Hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n        \n```\n```java\n@Entity //这里可以通过value属性指定表名, 如果不指定则为类名\npublic class User {\n\n    @Id\n    @GeneratedValue //默认情况下会创建新表来存储id位置, 如果指定 strategy= GenerationType.IDENTITY 则会在一张表中存储位置id\n    private Long id;\n    @Column(nullable = false， unique = true)\n    private String userName;\n    @Column(nullable = false)\n    private String passWord;\n    @Column(nullable = false， unique = true)\n    private String email;\n    @Column(nullable = true， unique = true)\n    private String nickName;\n    @Column(nullable = false)\n    private String regTime;\n    //省略 getter settet 方法、构造方法  在这里getter setter 影响 Controller 的 return的内容. 有get方法才会在json中含有该项, 如果不想让该项出现在json中 则不需要写对应的get方法\n}\n```\n\n最后编写实体类对应的repository接口 继承 JpaRepository<model, Long>\n\n就可使用自带的一些方法.\n\n#### 去继续学习吧\n\n<接口, 内部类, 持有对象>\n\n重写Readable导致的bug.\n再Main方法里产生随机单词, 导致异常`BufferOverflowException` , 首先思考的是每次调用`read()`方法应该会传入一个新的`CharBuffer`吧(实际并不是, 后面说)\n\n\n```java\n// Main.java\npublic static void main(String[] args) {\n\n\tScanner scanner = new Scanner(new RandomWords(100000));\n\n\twhile (scanner.hasNext()) {\n\t\tSystem.out.println(scanner.next());\n\t}\n}\n\n// RandomWords.java\npublic class RandomWords implements Readable {\n\n\tprivate static Random random = new Random(100);\n\n\tprivate static final char[] CAPITALS =\n\t\t\t\"ABCDEFGHIGKLMNOPQRSTUVWXYZ\".toCharArray();\n\n\tprivate static final char[] LOWERS =\n\t\t\t\"abcdefghigklmnopqrstuvwxyz\".toCharArray();\n\t\n\n\tprivate int count;\n\n\tpublic RandomWords(int count) {\n\t\tthis.count = count;\n\t}\n\n\t@Override\n\tpublic int read(CharBuffer cb) throws IOException {\n\t\tif(count-- == 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);\n\n\t\tint maxCount = 4;\n\n\t\tfor (int i = 0; i < maxCount; i++) {\n\t\t\tcb.append(LOWERS[random.nextInt(LOWERS.length)]);\n\n\t\t\t//System.out.println(cb.limit() + \" - \" + cb.position());\n\t\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);\n\n\t\t}\n\n\t\tcb.append(\" \");\n\t\treturn 10;\n\t}\n}\n```\n\n来到报错位置, 这一段是CharBuffer源码里的部分, 发现是由于position >= limit导致的异常, 然后查找得到这两个值得获取方法position()和limit();\n```java\nfinal int nextPutIndex() {                          // package-private\n\tif (position >= limit)\n\t\tthrow new BufferOverflowException();\n\treturn position++;\n}\n```\n在RandomWords.java代码加入 `System.out.println(cb.limit() + \" - \" + cb.position());` 位置见上文注释代码\n\n经过打印发现\n```\nAyAvFkNuM\n1024 - 1002\n1024 - 1004\n1024 - 1006\n1024 - 1008\nRcEsZqFwO\n1024 - 1012\n1024 - 1014\n1024 - 1016\n1024 - 1018\nHxEsXaStX\n1024 - 1022\n1024 - 1024\n```\nposition属性并没有随着每次调用read() 方法重置, 所以每次调用read()方法传入的是同一个 `CharBuffer`. 回到Scanner源码\n```java\n//Scanner.java\n\n//通过查找找到调用read()方法的地方\n\nprivate void readInput() {\n        if (buf.limit() == buf.capacity())\n            makeSpace();\n\n        // Prepare to receive data\n        int p = buf.position();\n        buf.position(buf.limit());\n        buf.limit(buf.capacity());\n\n        int n = 0;\n        try { //这里调用了source.read()  source就是构造方法传入的在RandomWords对象\n            n = source.read(buf);\n        } catch (IOException ioe) {\n            lastException = ioe;\n            n = -1;\n        }\n\n        if (n == -1) {\n            sourceClosed = true;\n            needInput = false;\n        }\n\n        if (n > 0)\n            needInput = false;\n\n        // Restore current position and limit for reading\n        buf.limit(buf.position());\n        buf.position(p);\n    }\n```\n\n发现其传入了`buf`参数, 查找`buf`来到\n```java\nprivate Scanner(Readable source, Pattern pattern) {\n\tassert source != null : \"source should not be null\";\n\tassert pattern != null : \"pattern should not be null\";\n\tthis.source = source;\n\tdelimPattern = pattern;\n\tbuf = CharBuffer.allocate(BUFFER_SIZE);\n\tbuf.limit(0);\n\tmatcher = delimPattern.matcher(buf);\n\tmatcher.useTransparentBounds(true);\n\tmatcher.useAnchoringBounds(false);\n\tuseLocale(Locale.getDefault(Locale.Category.FORMAT));\n}\n```\n发现是这个构造方法 对buf进行的赋值, 而\t`Scanner(Readable source)`这个构造方法也只是调用的上一个构造方法.\n\n所以问题解决了, 由于我是在一开始就实例化了一个`Scanner对象`. 导致传入`read()`方法的`buf`都是同一个 才导致的上文报错.\n\n@2019年7月28日19:18:23@\n\n囫囵吞枣的看完了接口\n看了一部分内部类. 感觉很没有实感..\n联系的太少了, 对他所说的没有感到`原来如此`\n\n### 7月29日-8月2日\n\n又写了一个二手交易的后台, 马上今天是八月二号, 这个假期也过了小一半了. \n\n最近也看了看大数据相关的, 等这几天多看看关于大数据的, 也许我会选大数据专业emmm\n@2019年8月2日20:22:20@\n去看看ElasticSearch吧, 二手交易还差一个搜索\n\n\n设置ip地址\n关闭防火墙\n关闭保护\n删除映射管理文件\n关机-->克隆四台电脑\n@2019年8月2日23:42:36@\n\n\n## 8.3-8.9\n\n### 8月3日\n\n大数据相关的删掉了, 移动到了单独的一篇博客\n\n### 8月4日\n\n大数据相关的删掉了, 移动到了单独的一篇博客\n\n### 8月8日\n\n继续学习大数据相关内容, 刷了一道算法题.待会看看Java IO流\n\n*暑期计划就到此了, 自己对于将来从事什么, 还是有些迷茫, 还是多去刷刷算法题目, 找找自己的路再走吧*","source":"_posts/假期学习记录-大一暑假.md","raw":"---\ntitle: 暑假学习记录与总结\ntags:\ncategories:\n  - 假期学习记录\ndate: 2019-07-13 12:13:22\n---\n<div class=\"alert-red\">では、ゲームを始(はじ)めましょう</div>\n\n自己与研究生无缘了, 不过嘛, 是好是坏我也不知道, 现在也只能多学点技术, 去工作了, 这个暑假很重要, 所以将会每天记录下.\n\n[在线图床](https://imgurl.org/)\n[设计模式主要学习](https://blog.csdn.net/lovelion/article/details/17517213)\n设计模式次要补充 -- head first java 设计模式\n\n<!--more-->\n## 总结\n\n![](暑假学习记录与总结/4.png)\n总结一下这个暑假都干了什么, 马上就要开学了.\n七月十三日到七月十九日, 这是第一周了.这一周伴随着到处参观, 收货很少了. 那时我还在主用Java, 主要的是学习了一些设计模式, 这一周的时间对我学习C++ 帮助也是有的. 暑假学习设计模式也是出于换语言的考虑. \n第一天(七月十三日)可以说是看的最多的了解了什么是耦合和解耦, 一些简单的设计模式(简单工厂, 工厂方法, 抽象工厂, 单例模式). \n第二天(七月十四日) 开始初步试验大创项目的实现, 当时遇到一个BUG, 我需要返回一个东西, 但我还是需要返回后将他删除, 首先就是将他”复制了一份”, 然后删除, 却发现返回去的都是空的,了解到了Java如何进行深拷贝.\n七月十六日看了下Java编程思想的多态部分, 然后主要时间修改网络助手的开机启动设置, 这样开机启动设置就没有问题了.\n七月十七日收拾家伙, 休息了休息准备回家, 结果虽然我确认了好几次自己有没有带全家伙, 鼠标笔记本都带上了,\n七月十八日到达北京去我姐那里暂住了, 结果发现我…..光带回了一个鼠标, 鼠标的接收器还在USB分线器上(吐血) 然后开始了一个开源项目的阅读. 云收藏(SpringBoot框架). 发现了自己没有看懂的东西(Stirng ...), 就去了解下JDK从5-8每次更新加入的内容,了解到那个叫做可变参数需要搭配增强for循环使用\n七月十九日-七月二十日我终于实现了自己理想….怎么说呢北方最大的漫展依然没有我想象的大, 等我有机会既定要去一次南方\n\n七月二十一日到七月二十七日写了个后端练手(一个失物招领) . 使用了丝袜哥写Api文档, SpringJpa作为持久层? 这几天放松了玩了几天游戏可惜了.\n七月二十八日总结两个小项目比较靠近项目的地方, 统一返回类型, 预定义数据, SpringJpa.\n.学习了 接口 内部类 持有对象. 通过查看源码解决了一个Bug,\n七月二十九日到八月二日 编写二手交易后台.\n\n想去了解下大数据相关内容\n八月三日到八月九日 看了下关于大数据的内容, 并不是很感兴趣.\n八月十日到八月十五日 主要是写算法题目, 然后寻找自己是佛要从事游戏服务器编程\n八月十六日到八月二十四日 上午复习高数, 下午看C++\n@2019年8月24日18:21:07@\n\n\n## 大纲\n设计模式不求多, 但求会用, 极大概率调整设计模式的学习.\n此外需要刷一些常用的算法\n\n```\n7.13-7.19\n<复用类, 多态>\n---六个创建型模式\n- 简单工厂模式\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n- 原型模式(略过)\n- 建造者模式(略过)\n7.20-7.26\n<接口, 内部类, 持有对象>\n---七个结构型模式\n- 适配器模式\n- 桥接模式\n- 组合模式\n- 外观模式\n7.27-8.02\n<类型信息, 泛型>\n- 装饰模式\n- 享元模式(略过)\n- 代理模式\n8.03-8.09\n<数组, 容器深入研究>\n---十一个行为型模式\n- 职责链模式\n- 命令模式\n- 解释器模式(略过)\n- 迭代器模式\n- 中介者模式(略过)\n- 备忘录模式(略过)\n- 观察者模式\n8.10-8.16\n<IO, 枚举类型>\n- 状态模式\n- 策略模式\n- 模板方法模式\n- 访问者模(略过)\n8.17-8.23\n<注解, 并发>\n\n```\n# では、ゲームを始(はじ)めましょう\n## 7.13-7.19\n```\n7.13-7.19\n<复用类, 多态>\n---六个创建型模式\n- 简单工厂模式\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n```\n### 7月13日\n\n```\n- 简单工厂模式\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n```\n\n2019年7月13日12:21:17\n上午参观参观参观...... 重置了下, 这个暑期表格.今天开始第一天的打卡.下午还有参观, 然后就可以开始学了\n\n下午有b站血族直播\n下午看了一个项目, 自己不会的还是太多,,,,,, 给了源码都看不太懂.\n还是先继续看几个设计模式吧, 设计模式目前想的是, 了解大概, 等到时用到了再去详细学习\n\n#### 耦合与解耦\n耦合: 两个或两个以上的体系之间互相结合, 互相影响, 产生的一个联合起来解决问题的体系.\n这种体系, 不利于修改, 修改一个体系可能会影响到另一个体系, 使得另一个体系需要做出修改.\n解耦: 将体系之间的联系降到最低, 各司其职, 修改本身的时候, 不需要去动其他的体系\n\n#### 简单工厂模式\n简单工厂模式不属于GoF 23种设计模式\n通过设计一个父类(产品类), 由他派生出多个子类(具体产品类), 通过一个工厂类, 提供给工厂类生产方法不同的参数, 由工厂类return相应的子类, 由父类接受.\n\n解决问题: 通过工厂类, 只需要记住参数, 就可以产生相应的子类,\n存在问题: 不符合开闭原则, 每次产生新的产品, 都需要去修改相应的工厂生产方法.\n\n#### 工厂方法模式\n与简单工厂有些相似之处: 均存在一个产品父类和多个产品子类.\n不同之处在于 工厂方法模式, 设置了工厂父类, 通过派生出不同的工厂子类来return相应的子类.\n\n解决问题: 解决了简单工厂模式的开闭原则, 每次产生新的产品, 只需要派生一个相应的子类即可\n存在问题: 系统中由于新产品的产生, 类的个数将会成对增加, 会有更多的类需要处理\n\n#### 抽象工厂模式\n抽象工厂模式解决了工厂方法模式某些情况下 导致的类成对增加情况\n一个抽象工厂里包含了这个\"工厂\"的所有产品--这对应了一个产品族\n可以派生出多个工厂来实现多品牌产品--形成了一个等级结构\n![引用自上文博客](https://img-blog.csdn.net/20130713162941328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n#### 单例模式\n这个模式理解起来很容易, 但是效果却十分的不错, 之前用过一次所以详细写一下.\n**饿汉式单例模式**\n饿汉式单例模式 无延迟加载 不需要解决多线程问题\n```java\n/**\n * @ClassName singletonpattern.Connect\n * @Description\n * 饿汉式单例模式 无延迟加载 不需要解决多线程问题\n * Author lsmg\n * Date 2019/5/21 13:25\n * @Version 1.0\n **/\npublic class Connect {\n    private static final Connect instance = new Connect();\n\n    private Connect(){\n\n    }\n\n    public static Connect getInstance(){\n        return instance;\n    }\n}\n```\n**懒汉式单例模式**\n```java\npackage singletonpattern;\n懒汉式单例模式 实现了延迟加载,但需要解决多线程问题\n/**\n * @ClassName singletonpattern.Connect1_2\n * @Description TODO\n * 懒汉式单例模式 实现了延迟加载,但需要解决多线程问题\n * Author lsmg\n * Date 2019/5/21 13:30\n * @Version 1.0\n **/\npublic class Connect1_2 {\n    private static Connect1_2  connect1_2;\n\n    private Connect1_2(){}\n\n    //这种方式会造成多线程访问的时候实例化多个对象\n//    public  static singletonpattern.Connect1_2 getInstance(){\n//        if(connect1_2 == null){\n//            connect1_2 = new singletonpattern.Connect1_2();\n//        }\n//\n//        return connect1_2;\n//    }\n\n    //这种方式虽然确保了只有一个线程进入, 但是降低了多线程的性能\n//    public synchronized static singletonpattern.Connect1_2 getInstance(){\n//        if(connect1_2 == null){\n//            connect1_2 = new singletonpattern.Connect1_2();\n//        }\n//\n//        return connect1_2;\n//    }\n\n\n    //这种方式需要在private \"volatile\" static singletonpattern.Connect1_2 connect1_2 这样同样降低效率\n//    public synchronized static singletonpattern.Connect1_2 getInstance(){\n//        if(connect1_2 == null){\n//\n//            synchronized (singletonpattern.Connect1_2.class){\n//                if(connect1_2 == null){\n//                    connect1_2 = new singletonpattern.Connect1_2();\n//                }\n//            }\n//\n//        }\n//\n//        return connect1_2;\n//    }\n```\n**使用IoDH方法结合二者优点**\n由于静态单例对象没有作为Singleton的成员变量直接初始化, 当调用`getInstance()`方法的时候, 会加载内部类HolderClass, 其中的static 由Java虚拟机保证线程安全性, 这样就结合了`饿汉式单例模式的线程安全`和`懒汉式单例模式的延迟加载`\n\n```java\n//Initialization on Demand Holder\nclass Singleton {\n\tprivate Singleton() {\n\t}\n\t\n\tprivate static class HolderClass {\n            private final static Singleton instance = new Singleton();\n\t}\n\t\n\tpublic static Singleton getInstance() {\n\t    return HolderClass.instance;\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t    Singleton s1, s2; \n        s1 = Singleton.getInstance();\n\t    s2 = Singleton.getInstance();\n\t    System.out.println(s1==s2);\n\t}\n}\n```\n@2019年7月13日19:07:46 设计模式暂时到这里, 去写写代码吧@\n\n### 7月14日\n```\n复用类看了一部分, 目前还差final部分\n```\n@2019年7月14日09:43:46@\n\n下午看了看大创项目的实现, 选择了高德地图api. 中午的时候太困了 搞得我没有仔细看\n目前决定采用[动态延展路径](https://lbs.amap.com/api/amap-ui/demos/amap-ui-pathsimplifier/expand-path)  解决问题, path由ajax 异步获取更新.\n#### 小插曲-Java List深浅拷贝\n```java\n@Service(\"droneStatusService\")\npublic class DroneStatusServiceImpl implements DroneStatusService {\n\n    private Logger logger = LoggerFactory.getLogger(DroneStatusServiceImpl.class);\n\n    private List<DroneStatus> droneStatusList = new ArrayList<>();\n/**删除其他代码**/\n    @Override\n    public List<DroneStatus> listDroneStatus() {\n        List<DroneStatus> theDroneStatusList = droneStatusList;\n\t\tdroneStatusList.clear(); /**这样导致了我的return list一直为空**/\n        logger.info(\"清除一次信息list共\"+theDroneStatusList.size()+\"条\");\n\n        return theDroneStatusList;\n    }\n}\n```\n第一印象这样写, 排查方法就是想到了关于Java引用的部分.\n对于list的拷贝 `遍历循环复制`和`List的构造方法`和`list.addAll()`以及`System.arraycopy()` 这些全部是`浅复制`他们指向了同一片内存区域\n\n深复制的实现方法另实体类 实现Cloneable接口 重写clone方法\n```java\n@Override\npublic Object clone() {\n\tEntity entity = null;\n\ttry {\n\t\tentity = (Entity)  super.clone();\n\t} catch (CloneNotSupportedException e) {\n\t\te.printStackTrace();\n\t}\n\treturn entity;\n}\n```\n\n然后我写了一个工具类\n```java\npublic static List<Entity> deepCopy(List<Entity> originList) {\n\tList<Entity> entityList = new ArrayList<>();\n\tfor(Entity entity : originList) {\n\t\tentityList.add((Entity) entity.clone());\n\t}\n\n\treturn entityList;\n}\n```\n通过这个工具类实现深复制\n\t\n `IDEA CTRL+ALT+T`收获这个快捷键\n![](https://i.bmp.ovh/imgs/2019/07/9fe10225fe9a52a5.png)\n@2019年7月14日17:47:23@\n\n大创先告一段落了, 等和他们对接吧, 基本功能显示路径已经做好了.\n@2019年7月14日20:29:30@\n复用类看完了\n@2019年7月14日21:14:12@\n\n### 7月15日\n把GGO通关了, 游戏就告一段落了.\n\n### 7月16日\n```\n多态\n```\n把编程思想-多态看一下吧\n\n多态这里怎么说呢, 重要的是思想吧, 自己没用过太多, 都是一些框架需要\n@2019年7月16日08:42:35@\n\n把书里的内容过了一遍, 怎么感觉不是很实用. 但是也说了一些小问题. 继承这种东西, 自己代码里都没有用太多.\n@2019年7月16日09:25:47@\n\n改了一部分BUG, 小软件的开机启动设置修改了下, 貌似可以了.\n@2019年7月16日17:39:40@\n\n### 7月17日\n上午收拾了下,  下午的话休息了休息, 晚上去吃了顿好的, 收拾回家的东西\n\n### 7月18日\n上午坐了一上午的车, 下午到了北京, 然后把电脑的内存条换上了(现在是16G的内存了, 够用了). **难受的是, 光带了鼠标没有带鼠标的接收器!!!!!!!(我以为插件可以代替接收器, 结果插线也得要接收器... 算了吧)**\n\n#### 下午继续看了一部分 云收藏的源码看到了这个下面一个函数\n```java\npublic static void main(String[] args) {\n\tSystem.out.println(getMessage(\"1\", \"2\", \"3\", \"4\"));\n}\n\npublic static String getMessage(String template, String... keys) {\n\tint count = 0;\n\tStringBuilder templateBuilder = new StringBuilder(template);\n\tfor (String key : keys) {\n\t\ttemplateBuilder.append(key);\n\t}\n\ttemplate = templateBuilder.toString();\n\treturn template;\n}\n```\n重点不是函数的功能, 而是`String...`这不是写错了. 我去网上查了下, 这样这个函数就可以接受多个参数了\n`getMessage(\"template\", \"a\", \"b\", \"c\")` 接受参数后用 增强for循环以此取出就好\n\n`是从Java 5开始，Java语言对方法参数支持一种新写法，叫可变长度参数列表`\n\n正好在这里去搜集下每次Java更新, 所提供的新特性\n\n#### JDK5 新特性\n\n#自动装箱与拆箱\n```Java\nInteger a = new Integer(10); \n//这个问题不大\nInteger b = 100; //这里就把一个int自动转成了 integer类型(自动装箱)\n//这里用到了 Integer的 valueOf()方法 实现的自动装箱\nb += 100; //b = b + 100; 用intValue()来自动拆箱\n//实现方式 b = Integer.valueOf(b.intValue() + 200); \n```\n\n#枚举类型\n```Java\nswitch \n// switch可以 switch枚举类型\n```\n\n#静态导入\n```Java\nimport static java.lang.Math.pow; \n//静态导入的必须是静态方法\nSystem.out.println(Math.pow(2, 3)); //未使用静态导入\nSystem.out.println(pow(2, 3)); //使用静态导入\n```\n\n#可变参数\n```Java\n//可以在方法参数的类型中 加入三个`...`, 这样在方法体内可以使用for的增强循环来获得传入的多个参数.\npublic static void main(String[] args) {\n\tSystem.out.println(getMessage(\"1\", \"2\", \"3\", \"4\"));\n}\n\npublic static String getMessage(String template, String... keys) {\n\tint count = 0;\n\tStringBuilder templateBuilder = new StringBuilder(template);\n\tfor (String key : keys) {\n\t\ttemplateBuilder.append(key);\n\t}\n\ttemplate = templateBuilder.toString();\n\treturn template;\n}\n```\n\n#增强for循环\n#泛型 (Generic Type)\n#内省\n\n\n#### JDK6 新特性\n\n#Desktop类和SystemTray类\n第一个`Desktop`类\n可以用来打开系统默认浏览器浏览指定的URL\n打开系统默认邮件客户端给指定的邮箱发邮件\n用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件)\n用系统默认的打印机打印文档\n第二个`SystemTray`类\n可以用来在系统托盘区创建一个托盘程序.\nJava的UI方面就不写太多了\n\n@2019年7月18日20:47:07@\n\n#### Springboot配置文件\n在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式\n其中{profile}对应你的环境标识\n\n下面列举三个文件\n`application-dev.properties`：开发环境\n`application-test.properties`：测试环境\n`application-prod.properties`：生产环境\n至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。\n`spring.profiles.active=dev`\n\n### 7月19日\n今天的话在北京待了一天, 去看了看北方最大的漫展IDO, 怎么说呢比我想象的要小一点, 不过比徐州那个好太多了. 以后有机会的话就去南方了.\n\n## 7.20-7.26\n```\n<接口, 内部类, 持有对象>\n---七个结构型模式\n- 适配器模式\n- 桥接模式\n- 组合模式\n- 外观模式\n```\n\n### 7月20日\n今天还是胳膊有些疼, 昨天拿的东西不少, 背的也不少.走的路也不少.....\n@2019年7月20日19:39:08@\n\n现在来看一些东西吧. 上个寒假在家里留了一本Java编程思想.\n\n### 7月21日\n写了个新的小项目, 正好来练练手. 新项目单独列出一篇博客.\n\n### 7月22日\n在家里午觉睡不着我凑, 改下小项目的问题.\n@去看一下设计模式吧@\n\n#### 适配器模式\n这个设计模式怎么说呢, 挺简单的.\n就是 新建一个适配器类Adapter  引用一个需要适配的类Adaptee 这个类实现客户端的接口Target\n\n这样客户端直接调用接口 相关转换工作在接口中完成.\n\n## 7.27-8.02\n\n```\n<类型信息, 泛型>\n- 装饰模式\n- 享元模式(略过)\n- 代理模式\n```\n\n### 7月28日\n从7.23-7.25 写了个小项目, 失物招领的后端. \n总的来说有 \n#### 统一反应类型\n将所有的返回结果, 写在一个类中\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951.png)\n\n预先定义的异常信息, 则使用了enum\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952.png)\n\n封装反回数据, 使用Object\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953.png)\n\n这样处理后就可以\n```java\nreturn new ResponseData(ExceptionMsg.DEL_FAILED);\n\nreturn new ResponseData(ExceptionMsg.DEL_FAILED);\n\nreturn  new ResponseData(ExceptionMsg.SUCCESS, lostAndFoundInfo);\n```\n\n来统一返回类型\n\n#### Spring Jpa的方便\n\n配置完毕后, 去编写相应的实体类\n```yml\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/lostandfound?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8&useSSL=true\nspring.datasource.username=root\nspring.datasource.password=root\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\nspring.jpa.properties.hibernate.hbm2ddl.auto=update\n\n# create：只要每次加载 Hibernate 时就都会删除上一次生成的表，然后根据 model 类再重新来生成新表. \n# create-drop：每次加载 Hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭，表就自动删除。\n# update：最常用的属性，第一次加载 Hibernate 时根据 model 类会自动建立起表的结构（前提是先建立# # 好数据库），以后加载 Hibernate 时根据 model 类自动更新表结构，即使表结构改变了，但表中的行仍然存在，不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。\n#validate ：每次加载 Hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n        \n```\n```java\n@Entity //这里可以通过value属性指定表名, 如果不指定则为类名\npublic class User {\n\n    @Id\n    @GeneratedValue //默认情况下会创建新表来存储id位置, 如果指定 strategy= GenerationType.IDENTITY 则会在一张表中存储位置id\n    private Long id;\n    @Column(nullable = false， unique = true)\n    private String userName;\n    @Column(nullable = false)\n    private String passWord;\n    @Column(nullable = false， unique = true)\n    private String email;\n    @Column(nullable = true， unique = true)\n    private String nickName;\n    @Column(nullable = false)\n    private String regTime;\n    //省略 getter settet 方法、构造方法  在这里getter setter 影响 Controller 的 return的内容. 有get方法才会在json中含有该项, 如果不想让该项出现在json中 则不需要写对应的get方法\n}\n```\n\n最后编写实体类对应的repository接口 继承 JpaRepository<model, Long>\n\n就可使用自带的一些方法.\n\n#### 去继续学习吧\n\n<接口, 内部类, 持有对象>\n\n重写Readable导致的bug.\n再Main方法里产生随机单词, 导致异常`BufferOverflowException` , 首先思考的是每次调用`read()`方法应该会传入一个新的`CharBuffer`吧(实际并不是, 后面说)\n\n\n```java\n// Main.java\npublic static void main(String[] args) {\n\n\tScanner scanner = new Scanner(new RandomWords(100000));\n\n\twhile (scanner.hasNext()) {\n\t\tSystem.out.println(scanner.next());\n\t}\n}\n\n// RandomWords.java\npublic class RandomWords implements Readable {\n\n\tprivate static Random random = new Random(100);\n\n\tprivate static final char[] CAPITALS =\n\t\t\t\"ABCDEFGHIGKLMNOPQRSTUVWXYZ\".toCharArray();\n\n\tprivate static final char[] LOWERS =\n\t\t\t\"abcdefghigklmnopqrstuvwxyz\".toCharArray();\n\t\n\n\tprivate int count;\n\n\tpublic RandomWords(int count) {\n\t\tthis.count = count;\n\t}\n\n\t@Override\n\tpublic int read(CharBuffer cb) throws IOException {\n\t\tif(count-- == 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);\n\n\t\tint maxCount = 4;\n\n\t\tfor (int i = 0; i < maxCount; i++) {\n\t\t\tcb.append(LOWERS[random.nextInt(LOWERS.length)]);\n\n\t\t\t//System.out.println(cb.limit() + \" - \" + cb.position());\n\t\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);\n\n\t\t}\n\n\t\tcb.append(\" \");\n\t\treturn 10;\n\t}\n}\n```\n\n来到报错位置, 这一段是CharBuffer源码里的部分, 发现是由于position >= limit导致的异常, 然后查找得到这两个值得获取方法position()和limit();\n```java\nfinal int nextPutIndex() {                          // package-private\n\tif (position >= limit)\n\t\tthrow new BufferOverflowException();\n\treturn position++;\n}\n```\n在RandomWords.java代码加入 `System.out.println(cb.limit() + \" - \" + cb.position());` 位置见上文注释代码\n\n经过打印发现\n```\nAyAvFkNuM\n1024 - 1002\n1024 - 1004\n1024 - 1006\n1024 - 1008\nRcEsZqFwO\n1024 - 1012\n1024 - 1014\n1024 - 1016\n1024 - 1018\nHxEsXaStX\n1024 - 1022\n1024 - 1024\n```\nposition属性并没有随着每次调用read() 方法重置, 所以每次调用read()方法传入的是同一个 `CharBuffer`. 回到Scanner源码\n```java\n//Scanner.java\n\n//通过查找找到调用read()方法的地方\n\nprivate void readInput() {\n        if (buf.limit() == buf.capacity())\n            makeSpace();\n\n        // Prepare to receive data\n        int p = buf.position();\n        buf.position(buf.limit());\n        buf.limit(buf.capacity());\n\n        int n = 0;\n        try { //这里调用了source.read()  source就是构造方法传入的在RandomWords对象\n            n = source.read(buf);\n        } catch (IOException ioe) {\n            lastException = ioe;\n            n = -1;\n        }\n\n        if (n == -1) {\n            sourceClosed = true;\n            needInput = false;\n        }\n\n        if (n > 0)\n            needInput = false;\n\n        // Restore current position and limit for reading\n        buf.limit(buf.position());\n        buf.position(p);\n    }\n```\n\n发现其传入了`buf`参数, 查找`buf`来到\n```java\nprivate Scanner(Readable source, Pattern pattern) {\n\tassert source != null : \"source should not be null\";\n\tassert pattern != null : \"pattern should not be null\";\n\tthis.source = source;\n\tdelimPattern = pattern;\n\tbuf = CharBuffer.allocate(BUFFER_SIZE);\n\tbuf.limit(0);\n\tmatcher = delimPattern.matcher(buf);\n\tmatcher.useTransparentBounds(true);\n\tmatcher.useAnchoringBounds(false);\n\tuseLocale(Locale.getDefault(Locale.Category.FORMAT));\n}\n```\n发现是这个构造方法 对buf进行的赋值, 而\t`Scanner(Readable source)`这个构造方法也只是调用的上一个构造方法.\n\n所以问题解决了, 由于我是在一开始就实例化了一个`Scanner对象`. 导致传入`read()`方法的`buf`都是同一个 才导致的上文报错.\n\n@2019年7月28日19:18:23@\n\n囫囵吞枣的看完了接口\n看了一部分内部类. 感觉很没有实感..\n联系的太少了, 对他所说的没有感到`原来如此`\n\n### 7月29日-8月2日\n\n又写了一个二手交易的后台, 马上今天是八月二号, 这个假期也过了小一半了. \n\n最近也看了看大数据相关的, 等这几天多看看关于大数据的, 也许我会选大数据专业emmm\n@2019年8月2日20:22:20@\n去看看ElasticSearch吧, 二手交易还差一个搜索\n\n\n设置ip地址\n关闭防火墙\n关闭保护\n删除映射管理文件\n关机-->克隆四台电脑\n@2019年8月2日23:42:36@\n\n\n## 8.3-8.9\n\n### 8月3日\n\n大数据相关的删掉了, 移动到了单独的一篇博客\n\n### 8月4日\n\n大数据相关的删掉了, 移动到了单独的一篇博客\n\n### 8月8日\n\n继续学习大数据相关内容, 刷了一道算法题.待会看看Java IO流\n\n*暑期计划就到此了, 自己对于将来从事什么, 还是有些迷茫, 还是多去刷刷算法题目, 找找自己的路再走吧*","slug":"假期学习记录-大一暑假","published":1,"updated":"2020-12-05T02:39:01.887Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6f0017f8und42g4zl7","content":"<div class=\"alert-red\">では、ゲームを始(はじ)めましょう</div>\n\n<p>自己与研究生无缘了, 不过嘛, 是好是坏我也不知道, 现在也只能多学点技术, 去工作了, 这个暑假很重要, 所以将会每天记录下.</p>\n<p><a href=\"https://imgurl.org/\" target=\"_blank\" rel=\"noopener\">在线图床</a><br><a href=\"https://blog.csdn.net/lovelion/article/details/17517213\" target=\"_blank\" rel=\"noopener\">设计模式主要学习</a><br>设计模式次要补充 – head first java 设计模式</p>\n<a id=\"more\"></a>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/4.png\" alt=\"\"><br>总结一下这个暑假都干了什么, 马上就要开学了.<br>七月十三日到七月十九日, 这是第一周了.这一周伴随着到处参观, 收货很少了. 那时我还在主用Java, 主要的是学习了一些设计模式, 这一周的时间对我学习C++ 帮助也是有的. 暑假学习设计模式也是出于换语言的考虑.<br>第一天(七月十三日)可以说是看的最多的了解了什么是耦合和解耦, 一些简单的设计模式(简单工厂, 工厂方法, 抽象工厂, 单例模式).<br>第二天(七月十四日) 开始初步试验大创项目的实现, 当时遇到一个BUG, 我需要返回一个东西, 但我还是需要返回后将他删除, 首先就是将他”复制了一份”, 然后删除, 却发现返回去的都是空的,了解到了Java如何进行深拷贝.<br>七月十六日看了下Java编程思想的多态部分, 然后主要时间修改网络助手的开机启动设置, 这样开机启动设置就没有问题了.<br>七月十七日收拾家伙, 休息了休息准备回家, 结果虽然我确认了好几次自己有没有带全家伙, 鼠标笔记本都带上了,<br>七月十八日到达北京去我姐那里暂住了, 结果发现我…..光带回了一个鼠标, 鼠标的接收器还在USB分线器上(吐血) 然后开始了一个开源项目的阅读. 云收藏(SpringBoot框架). 发现了自己没有看懂的东西(Stirng …), 就去了解下JDK从5-8每次更新加入的内容,了解到那个叫做可变参数需要搭配增强for循环使用<br>七月十九日-七月二十日我终于实现了自己理想….怎么说呢北方最大的漫展依然没有我想象的大, 等我有机会既定要去一次南方</p>\n<p>七月二十一日到七月二十七日写了个后端练手(一个失物招领) . 使用了丝袜哥写Api文档, SpringJpa作为持久层? 这几天放松了玩了几天游戏可惜了.<br>七月二十八日总结两个小项目比较靠近项目的地方, 统一返回类型, 预定义数据, SpringJpa.<br>.学习了 接口 内部类 持有对象. 通过查看源码解决了一个Bug,<br>七月二十九日到八月二日 编写二手交易后台.</p>\n<p>想去了解下大数据相关内容<br>八月三日到八月九日 看了下关于大数据的内容, 并不是很感兴趣.<br>八月十日到八月十五日 主要是写算法题目, 然后寻找自己是佛要从事游戏服务器编程<br>八月十六日到八月二十四日 上午复习高数, 下午看C++<br>@2019年8月24日18:21:07@</p>\n<h2 id=\"大纲\"><a href=\"#大纲\" class=\"headerlink\" title=\"大纲\"></a>大纲</h2><p>设计模式不求多, 但求会用, 极大概率调整设计模式的学习.<br>此外需要刷一些常用的算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7.13-7.19</span><br><span class=\"line\">&lt;复用类, 多态&gt;</span><br><span class=\"line\">---六个创建型模式</span><br><span class=\"line\">- 简单工厂模式</span><br><span class=\"line\">- 工厂方法模式</span><br><span class=\"line\">- 抽象工厂模式</span><br><span class=\"line\">- 单例模式</span><br><span class=\"line\">- 原型模式(略过)</span><br><span class=\"line\">- 建造者模式(略过)</span><br><span class=\"line\">7.20-7.26</span><br><span class=\"line\">&lt;接口, 内部类, 持有对象&gt;</span><br><span class=\"line\">---七个结构型模式</span><br><span class=\"line\">- 适配器模式</span><br><span class=\"line\">- 桥接模式</span><br><span class=\"line\">- 组合模式</span><br><span class=\"line\">- 外观模式</span><br><span class=\"line\">7.27-8.02</span><br><span class=\"line\">&lt;类型信息, 泛型&gt;</span><br><span class=\"line\">- 装饰模式</span><br><span class=\"line\">- 享元模式(略过)</span><br><span class=\"line\">- 代理模式</span><br><span class=\"line\">8.03-8.09</span><br><span class=\"line\">&lt;数组, 容器深入研究&gt;</span><br><span class=\"line\">---十一个行为型模式</span><br><span class=\"line\">- 职责链模式</span><br><span class=\"line\">- 命令模式</span><br><span class=\"line\">- 解释器模式(略过)</span><br><span class=\"line\">- 迭代器模式</span><br><span class=\"line\">- 中介者模式(略过)</span><br><span class=\"line\">- 备忘录模式(略过)</span><br><span class=\"line\">- 观察者模式</span><br><span class=\"line\">8.10-8.16</span><br><span class=\"line\">&lt;IO, 枚举类型&gt;</span><br><span class=\"line\">- 状态模式</span><br><span class=\"line\">- 策略模式</span><br><span class=\"line\">- 模板方法模式</span><br><span class=\"line\">- 访问者模(略过)</span><br><span class=\"line\">8.17-8.23</span><br><span class=\"line\">&lt;注解, 并发&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"では、ゲームを始-はじ-めましょう\"><a href=\"#では、ゲームを始-はじ-めましょう\" class=\"headerlink\" title=\"では、ゲームを始(はじ)めましょう\"></a>では、ゲームを始(はじ)めましょう</h1><h2 id=\"7-13-7-19\"><a href=\"#7-13-7-19\" class=\"headerlink\" title=\"7.13-7.19\"></a>7.13-7.19</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7.13-7.19</span><br><span class=\"line\">&lt;复用类, 多态&gt;</span><br><span class=\"line\">---六个创建型模式</span><br><span class=\"line\">- 简单工厂模式</span><br><span class=\"line\">- 工厂方法模式</span><br><span class=\"line\">- 抽象工厂模式</span><br><span class=\"line\">- 单例模式</span><br></pre></td></tr></table></figure>\n<h3 id=\"7月13日\"><a href=\"#7月13日\" class=\"headerlink\" title=\"7月13日\"></a>7月13日</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 简单工厂模式</span><br><span class=\"line\">- 工厂方法模式</span><br><span class=\"line\">- 抽象工厂模式</span><br><span class=\"line\">- 单例模式</span><br></pre></td></tr></table></figure>\n\n<p>2019年7月13日12:21:17<br>上午参观参观参观…… 重置了下, 这个暑期表格.今天开始第一天的打卡.下午还有参观, 然后就可以开始学了</p>\n<p>下午有b站血族直播<br>下午看了一个项目, 自己不会的还是太多,,,,,, 给了源码都看不太懂.<br>还是先继续看几个设计模式吧, 设计模式目前想的是, 了解大概, 等到时用到了再去详细学习</p>\n<h4 id=\"耦合与解耦\"><a href=\"#耦合与解耦\" class=\"headerlink\" title=\"耦合与解耦\"></a>耦合与解耦</h4><p>耦合: 两个或两个以上的体系之间互相结合, 互相影响, 产生的一个联合起来解决问题的体系.<br>这种体系, 不利于修改, 修改一个体系可能会影响到另一个体系, 使得另一个体系需要做出修改.<br>解耦: 将体系之间的联系降到最低, 各司其职, 修改本身的时候, 不需要去动其他的体系</p>\n<h4 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h4><p>简单工厂模式不属于GoF 23种设计模式<br>通过设计一个父类(产品类), 由他派生出多个子类(具体产品类), 通过一个工厂类, 提供给工厂类生产方法不同的参数, 由工厂类return相应的子类, 由父类接受.</p>\n<p>解决问题: 通过工厂类, 只需要记住参数, 就可以产生相应的子类,<br>存在问题: 不符合开闭原则, 每次产生新的产品, 都需要去修改相应的工厂生产方法.</p>\n<h4 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h4><p>与简单工厂有些相似之处: 均存在一个产品父类和多个产品子类.<br>不同之处在于 工厂方法模式, 设置了工厂父类, 通过派生出不同的工厂子类来return相应的子类.</p>\n<p>解决问题: 解决了简单工厂模式的开闭原则, 每次产生新的产品, 只需要派生一个相应的子类即可<br>存在问题: 系统中由于新产品的产生, 类的个数将会成对增加, 会有更多的类需要处理</p>\n<h4 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h4><p>抽象工厂模式解决了工厂方法模式某些情况下 导致的类成对增加情况<br>一个抽象工厂里包含了这个”工厂”的所有产品–这对应了一个产品族<br>可以派生出多个工厂来实现多品牌产品–形成了一个等级结构<br><img src=\"https://img-blog.csdn.net/20130713162941328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"引用自上文博客\"><span class=\"img-alt\">引用自上文博客</span></p>\n<h4 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h4><p>这个模式理解起来很容易, 但是效果却十分的不错, 之前用过一次所以详细写一下.<br><strong>饿汉式单例模式</strong><br>饿汉式单例模式 无延迟加载 不需要解决多线程问题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span> singletonpattern.Connect</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span></span></span><br><span class=\"line\"><span class=\"comment\"> * 饿汉式单例模式 无延迟加载 不需要解决多线程问题</span></span><br><span class=\"line\"><span class=\"comment\"> * Author lsmg</span></span><br><span class=\"line\"><span class=\"comment\"> * Date 2019/5/21 13:25</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Connect instance = <span class=\"keyword\">new</span> Connect();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Connect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connect <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>懒汉式单例模式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> singletonpattern;</span><br><span class=\"line\">懒汉式单例模式 实现了延迟加载,但需要解决多线程问题</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span> singletonpattern.Connect1_2</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span> TODO</span></span><br><span class=\"line\"><span class=\"comment\"> * 懒汉式单例模式 实现了延迟加载,但需要解决多线程问题</span></span><br><span class=\"line\"><span class=\"comment\"> * Author lsmg</span></span><br><span class=\"line\"><span class=\"comment\"> * Date 2019/5/21 13:30</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connect1_2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Connect1_2  connect1_2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Connect1_2</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这种方式会造成多线程访问的时候实例化多个对象</span></span><br><span class=\"line\"><span class=\"comment\">//    public  static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        return connect1_2;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这种方式虽然确保了只有一个线程进入, 但是降低了多线程的性能</span></span><br><span class=\"line\"><span class=\"comment\">//    public synchronized static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        return connect1_2;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这种方式需要在private \"volatile\" static singletonpattern.Connect1_2 connect1_2 这样同样降低效率</span></span><br><span class=\"line\"><span class=\"comment\">//    public synchronized static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//            synchronized (singletonpattern.Connect1_2.class)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                    connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class=\"line\"><span class=\"comment\">//                &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        return connect1_2;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用IoDH方法结合二者优点</strong><br>由于静态单例对象没有作为Singleton的成员变量直接初始化, 当调用<code>getInstance()</code>方法的时候, 会加载内部类HolderClass, 其中的static 由Java虚拟机保证线程安全性, 这样就结合了<code>饿汉式单例模式的线程安全</code>和<code>懒汉式单例模式的延迟加载</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Initialization on Demand Holder</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HolderClass</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> HolderClass.instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">\t    Singleton s1, s2; </span><br><span class=\"line\">        s1 = Singleton.getInstance();</span><br><span class=\"line\">\t    s2 = Singleton.getInstance();</span><br><span class=\"line\">\t    System.out.println(s1==s2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@2019年7月13日19:07:46 设计模式暂时到这里, 去写写代码吧@</p>\n<h3 id=\"7月14日\"><a href=\"#7月14日\" class=\"headerlink\" title=\"7月14日\"></a>7月14日</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">复用类看了一部分, 目前还差final部分</span><br></pre></td></tr></table></figure>\n<p>@2019年7月14日09:43:46@</p>\n<p>下午看了看大创项目的实现, 选择了高德地图api. 中午的时候太困了 搞得我没有仔细看<br>目前决定采用<a href=\"https://lbs.amap.com/api/amap-ui/demos/amap-ui-pathsimplifier/expand-path\" target=\"_blank\" rel=\"noopener\">动态延展路径</a>  解决问题, path由ajax 异步获取更新.</p>\n<h4 id=\"小插曲-Java-List深浅拷贝\"><a href=\"#小插曲-Java-List深浅拷贝\" class=\"headerlink\" title=\"小插曲-Java List深浅拷贝\"></a>小插曲-Java List深浅拷贝</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span>(<span class=\"string\">\"droneStatusService\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DroneStatusServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">DroneStatusService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Logger logger = LoggerFactory.getLogger(DroneStatusServiceImpl<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;DroneStatus&gt; droneStatusList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">/**删除其他代码**/</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;DroneStatus&gt; <span class=\"title\">listDroneStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;DroneStatus&gt; theDroneStatusList = droneStatusList;</span><br><span class=\"line\">\t\tdroneStatusList.clear(); <span class=\"comment\">/**这样导致了我的return list一直为空**/</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">\"清除一次信息list共\"</span>+theDroneStatusList.size()+<span class=\"string\">\"条\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> theDroneStatusList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一印象这样写, 排查方法就是想到了关于Java引用的部分.<br>对于list的拷贝 <code>遍历循环复制</code>和<code>List的构造方法</code>和<code>list.addAll()</code>以及<code>System.arraycopy()</code> 这些全部是<code>浅复制</code>他们指向了同一片内存区域</p>\n<p>深复制的实现方法另实体类 实现Cloneable接口 重写clone方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tEntity entity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tentity = (Entity)  <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> entity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我写了一个工具类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Entity&gt; <span class=\"title\">deepCopy</span><span class=\"params\">(List&lt;Entity&gt; originList)</span> </span>&#123;</span><br><span class=\"line\">\tList&lt;Entity&gt; entityList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(Entity entity : originList) &#123;</span><br><span class=\"line\">\t\tentityList.add((Entity) entity.clone());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> entityList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这个工具类实现深复制</p>\n<p> <code>IDEA CTRL+ALT+T</code>收获这个快捷键<br><img src=\"https://i.bmp.ovh/imgs/2019/07/9fe10225fe9a52a5.png\" alt=\"\"><br>@2019年7月14日17:47:23@</p>\n<p>大创先告一段落了, 等和他们对接吧, 基本功能显示路径已经做好了.<br>@2019年7月14日20:29:30@<br>复用类看完了<br>@2019年7月14日21:14:12@</p>\n<h3 id=\"7月15日\"><a href=\"#7月15日\" class=\"headerlink\" title=\"7月15日\"></a>7月15日</h3><p>把GGO通关了, 游戏就告一段落了.</p>\n<h3 id=\"7月16日\"><a href=\"#7月16日\" class=\"headerlink\" title=\"7月16日\"></a>7月16日</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多态</span><br></pre></td></tr></table></figure>\n<p>把编程思想-多态看一下吧</p>\n<p>多态这里怎么说呢, 重要的是思想吧, 自己没用过太多, 都是一些框架需要<br>@2019年7月16日08:42:35@</p>\n<p>把书里的内容过了一遍, 怎么感觉不是很实用. 但是也说了一些小问题. 继承这种东西, 自己代码里都没有用太多.<br>@2019年7月16日09:25:47@</p>\n<p>改了一部分BUG, 小软件的开机启动设置修改了下, 貌似可以了.<br>@2019年7月16日17:39:40@</p>\n<h3 id=\"7月17日\"><a href=\"#7月17日\" class=\"headerlink\" title=\"7月17日\"></a>7月17日</h3><p>上午收拾了下,  下午的话休息了休息, 晚上去吃了顿好的, 收拾回家的东西</p>\n<h3 id=\"7月18日\"><a href=\"#7月18日\" class=\"headerlink\" title=\"7月18日\"></a>7月18日</h3><p>上午坐了一上午的车, 下午到了北京, 然后把电脑的内存条换上了(现在是16G的内存了, 够用了). <strong>难受的是, 光带了鼠标没有带鼠标的接收器!!!!!!!(我以为插件可以代替接收器, 结果插线也得要接收器… 算了吧)</strong></p>\n<h4 id=\"下午继续看了一部分-云收藏的源码看到了这个下面一个函数\"><a href=\"#下午继续看了一部分-云收藏的源码看到了这个下面一个函数\" class=\"headerlink\" title=\"下午继续看了一部分 云收藏的源码看到了这个下面一个函数\"></a>下午继续看了一部分 云收藏的源码看到了这个下面一个函数</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\tSystem.out.println(getMessage(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\"4\"</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getMessage</span><span class=\"params\">(String template, String... keys)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tStringBuilder templateBuilder = <span class=\"keyword\">new</span> StringBuilder(template);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">\t\ttemplateBuilder.append(key);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttemplate = templateBuilder.toString();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> template;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重点不是函数的功能, 而是<code>String...</code>这不是写错了. 我去网上查了下, 这样这个函数就可以接受多个参数了<br><code>getMessage(&quot;template&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code> 接受参数后用 增强for循环以此取出就好</p>\n<p><code>是从Java 5开始，Java语言对方法参数支持一种新写法，叫可变长度参数列表</code></p>\n<p>正好在这里去搜集下每次Java更新, 所提供的新特性</p>\n<h4 id=\"JDK5-新特性\"><a href=\"#JDK5-新特性\" class=\"headerlink\" title=\"JDK5 新特性\"></a>JDK5 新特性</h4><p>#自动装箱与拆箱</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"keyword\">new</span> Integer(<span class=\"number\">10</span>); </span><br><span class=\"line\"><span class=\"comment\">//这个问题不大</span></span><br><span class=\"line\">Integer b = <span class=\"number\">100</span>; <span class=\"comment\">//这里就把一个int自动转成了 integer类型(自动装箱)</span></span><br><span class=\"line\"><span class=\"comment\">//这里用到了 Integer的 valueOf()方法 实现的自动装箱</span></span><br><span class=\"line\">b += <span class=\"number\">100</span>; <span class=\"comment\">//b = b + 100; 用intValue()来自动拆箱</span></span><br><span class=\"line\"><span class=\"comment\">//实现方式 b = Integer.valueOf(b.intValue() + 200);</span></span><br></pre></td></tr></table></figure>\n\n<p>#枚举类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> </span><br><span class=\"line\"><span class=\"comment\">// switch可以 switch枚举类型</span></span><br></pre></td></tr></table></figure>\n\n<p>#静态导入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> java.lang.Math.pow; </span><br><span class=\"line\"><span class=\"comment\">//静态导入的必须是静态方法</span></span><br><span class=\"line\">System.out.println(Math.pow(<span class=\"number\">2</span>, <span class=\"number\">3</span>)); <span class=\"comment\">//未使用静态导入</span></span><br><span class=\"line\">System.out.println(pow(<span class=\"number\">2</span>, <span class=\"number\">3</span>)); <span class=\"comment\">//使用静态导入</span></span><br></pre></td></tr></table></figure>\n\n<p>#可变参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以在方法参数的类型中 加入三个`...`, 这样在方法体内可以使用for的增强循环来获得传入的多个参数.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\tSystem.out.println(getMessage(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\"4\"</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getMessage</span><span class=\"params\">(String template, String... keys)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tStringBuilder templateBuilder = <span class=\"keyword\">new</span> StringBuilder(template);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">\t\ttemplateBuilder.append(key);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttemplate = templateBuilder.toString();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> template;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>#增强for循环<br>#泛型 (Generic Type)<br>#内省</p>\n<h4 id=\"JDK6-新特性\"><a href=\"#JDK6-新特性\" class=\"headerlink\" title=\"JDK6 新特性\"></a>JDK6 新特性</h4><p>#Desktop类和SystemTray类<br>第一个<code>Desktop</code>类<br>可以用来打开系统默认浏览器浏览指定的URL<br>打开系统默认邮件客户端给指定的邮箱发邮件<br>用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件)<br>用系统默认的打印机打印文档<br>第二个<code>SystemTray</code>类<br>可以用来在系统托盘区创建一个托盘程序.<br>Java的UI方面就不写太多了</p>\n<p>@2019年7月18日20:47:07@</p>\n<h4 id=\"Springboot配置文件\"><a href=\"#Springboot配置文件\" class=\"headerlink\" title=\"Springboot配置文件\"></a>Springboot配置文件</h4><p>在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式<br>其中{profile}对应你的环境标识</p>\n<p>下面列举三个文件<br><code>application-dev.properties</code>：开发环境<br><code>application-test.properties</code>：测试环境<br><code>application-prod.properties</code>：生产环境<br>至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。<br><code>spring.profiles.active=dev</code></p>\n<h3 id=\"7月19日\"><a href=\"#7月19日\" class=\"headerlink\" title=\"7月19日\"></a>7月19日</h3><p>今天的话在北京待了一天, 去看了看北方最大的漫展IDO, 怎么说呢比我想象的要小一点, 不过比徐州那个好太多了. 以后有机会的话就去南方了.</p>\n<h2 id=\"7-20-7-26\"><a href=\"#7-20-7-26\" class=\"headerlink\" title=\"7.20-7.26\"></a>7.20-7.26</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;接口, 内部类, 持有对象&gt;</span><br><span class=\"line\">---七个结构型模式</span><br><span class=\"line\">- 适配器模式</span><br><span class=\"line\">- 桥接模式</span><br><span class=\"line\">- 组合模式</span><br><span class=\"line\">- 外观模式</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7月20日\"><a href=\"#7月20日\" class=\"headerlink\" title=\"7月20日\"></a>7月20日</h3><p>今天还是胳膊有些疼, 昨天拿的东西不少, 背的也不少.走的路也不少…..<br>@2019年7月20日19:39:08@</p>\n<p>现在来看一些东西吧. 上个寒假在家里留了一本Java编程思想.</p>\n<h3 id=\"7月21日\"><a href=\"#7月21日\" class=\"headerlink\" title=\"7月21日\"></a>7月21日</h3><p>写了个新的小项目, 正好来练练手. 新项目单独列出一篇博客.</p>\n<h3 id=\"7月22日\"><a href=\"#7月22日\" class=\"headerlink\" title=\"7月22日\"></a>7月22日</h3><p>在家里午觉睡不着我凑, 改下小项目的问题.<br>@去看一下设计模式吧@</p>\n<h4 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h4><p>这个设计模式怎么说呢, 挺简单的.<br>就是 新建一个适配器类Adapter  引用一个需要适配的类Adaptee 这个类实现客户端的接口Target</p>\n<p>这样客户端直接调用接口 相关转换工作在接口中完成.</p>\n<h2 id=\"7-27-8-02\"><a href=\"#7-27-8-02\" class=\"headerlink\" title=\"7.27-8.02\"></a>7.27-8.02</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;类型信息, 泛型&gt;</span><br><span class=\"line\">- 装饰模式</span><br><span class=\"line\">- 享元模式(略过)</span><br><span class=\"line\">- 代理模式</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7月28日\"><a href=\"#7月28日\" class=\"headerlink\" title=\"7月28日\"></a>7月28日</h3><p>从7.23-7.25 写了个小项目, 失物招领的后端.<br>总的来说有 </p>\n<h4 id=\"统一反应类型\"><a href=\"#统一反应类型\" class=\"headerlink\" title=\"统一反应类型\"></a>统一反应类型</h4><p>将所有的返回结果, 写在一个类中</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951.png\" alt=\"\"></p>\n<p>预先定义的异常信息, 则使用了enum</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952.png\" alt=\"\"></p>\n<p>封装反回数据, 使用Object</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953.png\" alt=\"\"></p>\n<p>这样处理后就可以</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseData(ExceptionMsg.DEL_FAILED);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseData(ExceptionMsg.DEL_FAILED);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> ResponseData(ExceptionMsg.SUCCESS, lostAndFoundInfo);</span><br></pre></td></tr></table></figure>\n\n<p>来统一返回类型</p>\n<h4 id=\"Spring-Jpa的方便\"><a href=\"#Spring-Jpa的方便\" class=\"headerlink\" title=\"Spring Jpa的方便\"></a>Spring Jpa的方便</h4><p>配置完毕后, 去编写相应的实体类</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/lostandfound?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class=\"line\"><span class=\"string\">spring.datasource.username=root</span></span><br><span class=\"line\"><span class=\"string\">spring.datasource.password=root</span></span><br><span class=\"line\"><span class=\"string\">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># create：只要每次加载 Hibernate 时就都会删除上一次生成的表，然后根据 model 类再重新来生成新表. </span></span><br><span class=\"line\"><span class=\"comment\"># create-drop：每次加载 Hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭，表就自动删除。</span></span><br><span class=\"line\"><span class=\"comment\"># update：最常用的属性，第一次加载 Hibernate 时根据 model 类会自动建立起表的结构（前提是先建立# # 好数据库），以后加载 Hibernate 时根据 model 类自动更新表结构，即使表结构改变了，但表中的行仍然存在，不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。</span></span><br><span class=\"line\"><span class=\"comment\">#validate ：每次加载 Hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</span></span><br><span class=\"line\"><span class=\"string\">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span> <span class=\"comment\">//这里可以通过value属性指定表名, 如果不指定则为类名</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span> <span class=\"comment\">//默认情况下会创建新表来存储id位置, 如果指定 strategy= GenerationType.IDENTITY 则会在一张表中存储位置id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>， unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String passWord;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>， unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String email;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">true</span>， unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String nickName;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String regTime;</span><br><span class=\"line\">    <span class=\"comment\">//省略 getter settet 方法、构造方法  在这里getter setter 影响 Controller 的 return的内容. 有get方法才会在json中含有该项, 如果不想让该项出现在json中 则不需要写对应的get方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后编写实体类对应的repository接口 继承 JpaRepository&lt;model, Long&gt;</p>\n<p>就可使用自带的一些方法.</p>\n<h4 id=\"去继续学习吧\"><a href=\"#去继续学习吧\" class=\"headerlink\" title=\"去继续学习吧\"></a>去继续学习吧</h4><p>&lt;接口, 内部类, 持有对象&gt;</p>\n<p>重写Readable导致的bug.<br>再Main方法里产生随机单词, 导致异常<code>BufferOverflowException</code> , 首先思考的是每次调用<code>read()</code>方法应该会传入一个新的<code>CharBuffer</code>吧(实际并不是, 后面说)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tScanner scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> RandomWords(<span class=\"number\">100000</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(scanner.next());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RandomWords.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWords</span> <span class=\"keyword\">implements</span> <span class=\"title\">Readable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random random = <span class=\"keyword\">new</span> Random(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] CAPITALS =</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"ABCDEFGHIGKLMNOPQRSTUVWXYZ\"</span>.toCharArray();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] LOWERS =</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"abcdefghigklmnopqrstuvwxyz\"</span>.toCharArray();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RandomWords</span><span class=\"params\">(<span class=\"keyword\">int</span> count)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.count = count;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(CharBuffer cb)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(count-- == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> maxCount = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxCount; i++) &#123;</span><br><span class=\"line\">\t\t\tcb.append(LOWERS[random.nextInt(LOWERS.length)]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//System.out.println(cb.limit() + \" - \" + cb.position());</span></span><br><span class=\"line\">\t\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcb.append(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来到报错位置, 这一段是CharBuffer源码里的部分, 发现是由于position &gt;= limit导致的异常, 然后查找得到这两个值得获取方法position()和limit();</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">nextPutIndex</span><span class=\"params\">()</span> </span>&#123;                          <span class=\"comment\">// package-private</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (position &gt;= limit)</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BufferOverflowException();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> position++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在RandomWords.java代码加入 <code>System.out.println(cb.limit() + &quot; - &quot; + cb.position());</code> 位置见上文注释代码</p>\n<p>经过打印发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AyAvFkNuM</span><br><span class=\"line\">1024 - 1002</span><br><span class=\"line\">1024 - 1004</span><br><span class=\"line\">1024 - 1006</span><br><span class=\"line\">1024 - 1008</span><br><span class=\"line\">RcEsZqFwO</span><br><span class=\"line\">1024 - 1012</span><br><span class=\"line\">1024 - 1014</span><br><span class=\"line\">1024 - 1016</span><br><span class=\"line\">1024 - 1018</span><br><span class=\"line\">HxEsXaStX</span><br><span class=\"line\">1024 - 1022</span><br><span class=\"line\">1024 - 1024</span><br></pre></td></tr></table></figure>\n<p>position属性并没有随着每次调用read() 方法重置, 所以每次调用read()方法传入的是同一个 <code>CharBuffer</code>. 回到Scanner源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Scanner.java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过查找找到调用read()方法的地方</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readInput</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buf.limit() == buf.capacity())</span><br><span class=\"line\">            makeSpace();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Prepare to receive data</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = buf.position();</span><br><span class=\"line\">        buf.position(buf.limit());</span><br><span class=\"line\">        buf.limit(buf.capacity());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123; <span class=\"comment\">//这里调用了source.read()  source就是构造方法传入的在RandomWords对象</span></span><br><span class=\"line\">            n = source.read(buf);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            lastException = ioe;</span><br><span class=\"line\">            n = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            sourceClosed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            needInput = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            needInput = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Restore current position and limit for reading</span></span><br><span class=\"line\">        buf.limit(buf.position());</span><br><span class=\"line\">        buf.position(p);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现其传入了<code>buf</code>参数, 查找<code>buf</code>来到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Scanner</span><span class=\"params\">(Readable source, Pattern pattern)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">assert</span> source != <span class=\"keyword\">null</span> : <span class=\"string\">\"source should not be null\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">assert</span> pattern != <span class=\"keyword\">null</span> : <span class=\"string\">\"pattern should not be null\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.source = source;</span><br><span class=\"line\">\tdelimPattern = pattern;</span><br><span class=\"line\">\tbuf = CharBuffer.allocate(BUFFER_SIZE);</span><br><span class=\"line\">\tbuf.limit(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tmatcher = delimPattern.matcher(buf);</span><br><span class=\"line\">\tmatcher.useTransparentBounds(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\tmatcher.useAnchoringBounds(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\tuseLocale(Locale.getDefault(Locale.Category.FORMAT));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发现是这个构造方法 对buf进行的赋值, 而    <code>Scanner(Readable source)</code>这个构造方法也只是调用的上一个构造方法.</p>\n<p>所以问题解决了, 由于我是在一开始就实例化了一个<code>Scanner对象</code>. 导致传入<code>read()</code>方法的<code>buf</code>都是同一个 才导致的上文报错.</p>\n<p>@2019年7月28日19:18:23@</p>\n<p>囫囵吞枣的看完了接口<br>看了一部分内部类. 感觉很没有实感..<br>联系的太少了, 对他所说的没有感到<code>原来如此</code></p>\n<h3 id=\"7月29日-8月2日\"><a href=\"#7月29日-8月2日\" class=\"headerlink\" title=\"7月29日-8月2日\"></a>7月29日-8月2日</h3><p>又写了一个二手交易的后台, 马上今天是八月二号, 这个假期也过了小一半了. </p>\n<p>最近也看了看大数据相关的, 等这几天多看看关于大数据的, 也许我会选大数据专业emmm<br>@2019年8月2日20:22:20@<br>去看看ElasticSearch吧, 二手交易还差一个搜索</p>\n<p>设置ip地址<br>关闭防火墙<br>关闭保护<br>删除映射管理文件<br>关机–&gt;克隆四台电脑<br>@2019年8月2日23:42:36@</p>\n<h2 id=\"8-3-8-9\"><a href=\"#8-3-8-9\" class=\"headerlink\" title=\"8.3-8.9\"></a>8.3-8.9</h2><h3 id=\"8月3日\"><a href=\"#8月3日\" class=\"headerlink\" title=\"8月3日\"></a>8月3日</h3><p>大数据相关的删掉了, 移动到了单独的一篇博客</p>\n<h3 id=\"8月4日\"><a href=\"#8月4日\" class=\"headerlink\" title=\"8月4日\"></a>8月4日</h3><p>大数据相关的删掉了, 移动到了单独的一篇博客</p>\n<h3 id=\"8月8日\"><a href=\"#8月8日\" class=\"headerlink\" title=\"8月8日\"></a>8月8日</h3><p>继续学习大数据相关内容, 刷了一道算法题.待会看看Java IO流</p>\n<p><em>暑期计划就到此了, 自己对于将来从事什么, 还是有些迷茫, 还是多去刷刷算法题目, 找找自己的路再走吧</em></p>\n","site":{"data":{}},"excerpt":"<div class=\"alert-red\">では、ゲームを始(はじ)めましょう</div>\n\n<p>自己与研究生无缘了, 不过嘛, 是好是坏我也不知道, 现在也只能多学点技术, 去工作了, 这个暑假很重要, 所以将会每天记录下.</p>\n<p><a href=\"https://imgurl.org/\" target=\"_blank\" rel=\"noopener\">在线图床</a><br><a href=\"https://blog.csdn.net/lovelion/article/details/17517213\" target=\"_blank\" rel=\"noopener\">设计模式主要学习</a><br>设计模式次要补充 – head first java 设计模式</p>","more":"<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/4.png\" alt=\"\"><br>总结一下这个暑假都干了什么, 马上就要开学了.<br>七月十三日到七月十九日, 这是第一周了.这一周伴随着到处参观, 收货很少了. 那时我还在主用Java, 主要的是学习了一些设计模式, 这一周的时间对我学习C++ 帮助也是有的. 暑假学习设计模式也是出于换语言的考虑.<br>第一天(七月十三日)可以说是看的最多的了解了什么是耦合和解耦, 一些简单的设计模式(简单工厂, 工厂方法, 抽象工厂, 单例模式).<br>第二天(七月十四日) 开始初步试验大创项目的实现, 当时遇到一个BUG, 我需要返回一个东西, 但我还是需要返回后将他删除, 首先就是将他”复制了一份”, 然后删除, 却发现返回去的都是空的,了解到了Java如何进行深拷贝.<br>七月十六日看了下Java编程思想的多态部分, 然后主要时间修改网络助手的开机启动设置, 这样开机启动设置就没有问题了.<br>七月十七日收拾家伙, 休息了休息准备回家, 结果虽然我确认了好几次自己有没有带全家伙, 鼠标笔记本都带上了,<br>七月十八日到达北京去我姐那里暂住了, 结果发现我…..光带回了一个鼠标, 鼠标的接收器还在USB分线器上(吐血) 然后开始了一个开源项目的阅读. 云收藏(SpringBoot框架). 发现了自己没有看懂的东西(Stirng …), 就去了解下JDK从5-8每次更新加入的内容,了解到那个叫做可变参数需要搭配增强for循环使用<br>七月十九日-七月二十日我终于实现了自己理想….怎么说呢北方最大的漫展依然没有我想象的大, 等我有机会既定要去一次南方</p>\n<p>七月二十一日到七月二十七日写了个后端练手(一个失物招领) . 使用了丝袜哥写Api文档, SpringJpa作为持久层? 这几天放松了玩了几天游戏可惜了.<br>七月二十八日总结两个小项目比较靠近项目的地方, 统一返回类型, 预定义数据, SpringJpa.<br>.学习了 接口 内部类 持有对象. 通过查看源码解决了一个Bug,<br>七月二十九日到八月二日 编写二手交易后台.</p>\n<p>想去了解下大数据相关内容<br>八月三日到八月九日 看了下关于大数据的内容, 并不是很感兴趣.<br>八月十日到八月十五日 主要是写算法题目, 然后寻找自己是佛要从事游戏服务器编程<br>八月十六日到八月二十四日 上午复习高数, 下午看C++<br>@2019年8月24日18:21:07@</p>\n<h2 id=\"大纲\"><a href=\"#大纲\" class=\"headerlink\" title=\"大纲\"></a>大纲</h2><p>设计模式不求多, 但求会用, 极大概率调整设计模式的学习.<br>此外需要刷一些常用的算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7.13-7.19</span><br><span class=\"line\">&lt;复用类, 多态&gt;</span><br><span class=\"line\">---六个创建型模式</span><br><span class=\"line\">- 简单工厂模式</span><br><span class=\"line\">- 工厂方法模式</span><br><span class=\"line\">- 抽象工厂模式</span><br><span class=\"line\">- 单例模式</span><br><span class=\"line\">- 原型模式(略过)</span><br><span class=\"line\">- 建造者模式(略过)</span><br><span class=\"line\">7.20-7.26</span><br><span class=\"line\">&lt;接口, 内部类, 持有对象&gt;</span><br><span class=\"line\">---七个结构型模式</span><br><span class=\"line\">- 适配器模式</span><br><span class=\"line\">- 桥接模式</span><br><span class=\"line\">- 组合模式</span><br><span class=\"line\">- 外观模式</span><br><span class=\"line\">7.27-8.02</span><br><span class=\"line\">&lt;类型信息, 泛型&gt;</span><br><span class=\"line\">- 装饰模式</span><br><span class=\"line\">- 享元模式(略过)</span><br><span class=\"line\">- 代理模式</span><br><span class=\"line\">8.03-8.09</span><br><span class=\"line\">&lt;数组, 容器深入研究&gt;</span><br><span class=\"line\">---十一个行为型模式</span><br><span class=\"line\">- 职责链模式</span><br><span class=\"line\">- 命令模式</span><br><span class=\"line\">- 解释器模式(略过)</span><br><span class=\"line\">- 迭代器模式</span><br><span class=\"line\">- 中介者模式(略过)</span><br><span class=\"line\">- 备忘录模式(略过)</span><br><span class=\"line\">- 观察者模式</span><br><span class=\"line\">8.10-8.16</span><br><span class=\"line\">&lt;IO, 枚举类型&gt;</span><br><span class=\"line\">- 状态模式</span><br><span class=\"line\">- 策略模式</span><br><span class=\"line\">- 模板方法模式</span><br><span class=\"line\">- 访问者模(略过)</span><br><span class=\"line\">8.17-8.23</span><br><span class=\"line\">&lt;注解, 并发&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"では、ゲームを始-はじ-めましょう\"><a href=\"#では、ゲームを始-はじ-めましょう\" class=\"headerlink\" title=\"では、ゲームを始(はじ)めましょう\"></a>では、ゲームを始(はじ)めましょう</h1><h2 id=\"7-13-7-19\"><a href=\"#7-13-7-19\" class=\"headerlink\" title=\"7.13-7.19\"></a>7.13-7.19</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7.13-7.19</span><br><span class=\"line\">&lt;复用类, 多态&gt;</span><br><span class=\"line\">---六个创建型模式</span><br><span class=\"line\">- 简单工厂模式</span><br><span class=\"line\">- 工厂方法模式</span><br><span class=\"line\">- 抽象工厂模式</span><br><span class=\"line\">- 单例模式</span><br></pre></td></tr></table></figure>\n<h3 id=\"7月13日\"><a href=\"#7月13日\" class=\"headerlink\" title=\"7月13日\"></a>7月13日</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 简单工厂模式</span><br><span class=\"line\">- 工厂方法模式</span><br><span class=\"line\">- 抽象工厂模式</span><br><span class=\"line\">- 单例模式</span><br></pre></td></tr></table></figure>\n\n<p>2019年7月13日12:21:17<br>上午参观参观参观…… 重置了下, 这个暑期表格.今天开始第一天的打卡.下午还有参观, 然后就可以开始学了</p>\n<p>下午有b站血族直播<br>下午看了一个项目, 自己不会的还是太多,,,,,, 给了源码都看不太懂.<br>还是先继续看几个设计模式吧, 设计模式目前想的是, 了解大概, 等到时用到了再去详细学习</p>\n<h4 id=\"耦合与解耦\"><a href=\"#耦合与解耦\" class=\"headerlink\" title=\"耦合与解耦\"></a>耦合与解耦</h4><p>耦合: 两个或两个以上的体系之间互相结合, 互相影响, 产生的一个联合起来解决问题的体系.<br>这种体系, 不利于修改, 修改一个体系可能会影响到另一个体系, 使得另一个体系需要做出修改.<br>解耦: 将体系之间的联系降到最低, 各司其职, 修改本身的时候, 不需要去动其他的体系</p>\n<h4 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h4><p>简单工厂模式不属于GoF 23种设计模式<br>通过设计一个父类(产品类), 由他派生出多个子类(具体产品类), 通过一个工厂类, 提供给工厂类生产方法不同的参数, 由工厂类return相应的子类, 由父类接受.</p>\n<p>解决问题: 通过工厂类, 只需要记住参数, 就可以产生相应的子类,<br>存在问题: 不符合开闭原则, 每次产生新的产品, 都需要去修改相应的工厂生产方法.</p>\n<h4 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h4><p>与简单工厂有些相似之处: 均存在一个产品父类和多个产品子类.<br>不同之处在于 工厂方法模式, 设置了工厂父类, 通过派生出不同的工厂子类来return相应的子类.</p>\n<p>解决问题: 解决了简单工厂模式的开闭原则, 每次产生新的产品, 只需要派生一个相应的子类即可<br>存在问题: 系统中由于新产品的产生, 类的个数将会成对增加, 会有更多的类需要处理</p>\n<h4 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h4><p>抽象工厂模式解决了工厂方法模式某些情况下 导致的类成对增加情况<br>一个抽象工厂里包含了这个”工厂”的所有产品–这对应了一个产品族<br>可以派生出多个工厂来实现多品牌产品–形成了一个等级结构<br><img src=\"https://img-blog.csdn.net/20130713162941328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"引用自上文博客\"></p>\n<h4 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h4><p>这个模式理解起来很容易, 但是效果却十分的不错, 之前用过一次所以详细写一下.<br><strong>饿汉式单例模式</strong><br>饿汉式单例模式 无延迟加载 不需要解决多线程问题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span> singletonpattern.Connect</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span></span></span><br><span class=\"line\"><span class=\"comment\"> * 饿汉式单例模式 无延迟加载 不需要解决多线程问题</span></span><br><span class=\"line\"><span class=\"comment\"> * Author lsmg</span></span><br><span class=\"line\"><span class=\"comment\"> * Date 2019/5/21 13:25</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Connect instance = <span class=\"keyword\">new</span> Connect();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Connect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connect <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>懒汉式单例模式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> singletonpattern;</span><br><span class=\"line\">懒汉式单例模式 实现了延迟加载,但需要解决多线程问题</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span> singletonpattern.Connect1_2</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span> TODO</span></span><br><span class=\"line\"><span class=\"comment\"> * 懒汉式单例模式 实现了延迟加载,但需要解决多线程问题</span></span><br><span class=\"line\"><span class=\"comment\"> * Author lsmg</span></span><br><span class=\"line\"><span class=\"comment\"> * Date 2019/5/21 13:30</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connect1_2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Connect1_2  connect1_2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Connect1_2</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这种方式会造成多线程访问的时候实例化多个对象</span></span><br><span class=\"line\"><span class=\"comment\">//    public  static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        return connect1_2;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这种方式虽然确保了只有一个线程进入, 但是降低了多线程的性能</span></span><br><span class=\"line\"><span class=\"comment\">//    public synchronized static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        return connect1_2;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这种方式需要在private \"volatile\" static singletonpattern.Connect1_2 connect1_2 这样同样降低效率</span></span><br><span class=\"line\"><span class=\"comment\">//    public synchronized static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//            synchronized (singletonpattern.Connect1_2.class)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                    connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class=\"line\"><span class=\"comment\">//                &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        return connect1_2;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用IoDH方法结合二者优点</strong><br>由于静态单例对象没有作为Singleton的成员变量直接初始化, 当调用<code>getInstance()</code>方法的时候, 会加载内部类HolderClass, 其中的static 由Java虚拟机保证线程安全性, 这样就结合了<code>饿汉式单例模式的线程安全</code>和<code>懒汉式单例模式的延迟加载</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Initialization on Demand Holder</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HolderClass</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> HolderClass.instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">\t    Singleton s1, s2; </span><br><span class=\"line\">        s1 = Singleton.getInstance();</span><br><span class=\"line\">\t    s2 = Singleton.getInstance();</span><br><span class=\"line\">\t    System.out.println(s1==s2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@2019年7月13日19:07:46 设计模式暂时到这里, 去写写代码吧@</p>\n<h3 id=\"7月14日\"><a href=\"#7月14日\" class=\"headerlink\" title=\"7月14日\"></a>7月14日</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">复用类看了一部分, 目前还差final部分</span><br></pre></td></tr></table></figure>\n<p>@2019年7月14日09:43:46@</p>\n<p>下午看了看大创项目的实现, 选择了高德地图api. 中午的时候太困了 搞得我没有仔细看<br>目前决定采用<a href=\"https://lbs.amap.com/api/amap-ui/demos/amap-ui-pathsimplifier/expand-path\" target=\"_blank\" rel=\"noopener\">动态延展路径</a>  解决问题, path由ajax 异步获取更新.</p>\n<h4 id=\"小插曲-Java-List深浅拷贝\"><a href=\"#小插曲-Java-List深浅拷贝\" class=\"headerlink\" title=\"小插曲-Java List深浅拷贝\"></a>小插曲-Java List深浅拷贝</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span>(<span class=\"string\">\"droneStatusService\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DroneStatusServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">DroneStatusService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Logger logger = LoggerFactory.getLogger(DroneStatusServiceImpl<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;DroneStatus&gt; droneStatusList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">/**删除其他代码**/</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;DroneStatus&gt; <span class=\"title\">listDroneStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;DroneStatus&gt; theDroneStatusList = droneStatusList;</span><br><span class=\"line\">\t\tdroneStatusList.clear(); <span class=\"comment\">/**这样导致了我的return list一直为空**/</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">\"清除一次信息list共\"</span>+theDroneStatusList.size()+<span class=\"string\">\"条\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> theDroneStatusList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一印象这样写, 排查方法就是想到了关于Java引用的部分.<br>对于list的拷贝 <code>遍历循环复制</code>和<code>List的构造方法</code>和<code>list.addAll()</code>以及<code>System.arraycopy()</code> 这些全部是<code>浅复制</code>他们指向了同一片内存区域</p>\n<p>深复制的实现方法另实体类 实现Cloneable接口 重写clone方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tEntity entity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tentity = (Entity)  <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> entity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我写了一个工具类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Entity&gt; <span class=\"title\">deepCopy</span><span class=\"params\">(List&lt;Entity&gt; originList)</span> </span>&#123;</span><br><span class=\"line\">\tList&lt;Entity&gt; entityList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(Entity entity : originList) &#123;</span><br><span class=\"line\">\t\tentityList.add((Entity) entity.clone());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> entityList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这个工具类实现深复制</p>\n<p> <code>IDEA CTRL+ALT+T</code>收获这个快捷键<br><img src=\"https://i.bmp.ovh/imgs/2019/07/9fe10225fe9a52a5.png\" alt=\"\"><br>@2019年7月14日17:47:23@</p>\n<p>大创先告一段落了, 等和他们对接吧, 基本功能显示路径已经做好了.<br>@2019年7月14日20:29:30@<br>复用类看完了<br>@2019年7月14日21:14:12@</p>\n<h3 id=\"7月15日\"><a href=\"#7月15日\" class=\"headerlink\" title=\"7月15日\"></a>7月15日</h3><p>把GGO通关了, 游戏就告一段落了.</p>\n<h3 id=\"7月16日\"><a href=\"#7月16日\" class=\"headerlink\" title=\"7月16日\"></a>7月16日</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多态</span><br></pre></td></tr></table></figure>\n<p>把编程思想-多态看一下吧</p>\n<p>多态这里怎么说呢, 重要的是思想吧, 自己没用过太多, 都是一些框架需要<br>@2019年7月16日08:42:35@</p>\n<p>把书里的内容过了一遍, 怎么感觉不是很实用. 但是也说了一些小问题. 继承这种东西, 自己代码里都没有用太多.<br>@2019年7月16日09:25:47@</p>\n<p>改了一部分BUG, 小软件的开机启动设置修改了下, 貌似可以了.<br>@2019年7月16日17:39:40@</p>\n<h3 id=\"7月17日\"><a href=\"#7月17日\" class=\"headerlink\" title=\"7月17日\"></a>7月17日</h3><p>上午收拾了下,  下午的话休息了休息, 晚上去吃了顿好的, 收拾回家的东西</p>\n<h3 id=\"7月18日\"><a href=\"#7月18日\" class=\"headerlink\" title=\"7月18日\"></a>7月18日</h3><p>上午坐了一上午的车, 下午到了北京, 然后把电脑的内存条换上了(现在是16G的内存了, 够用了). <strong>难受的是, 光带了鼠标没有带鼠标的接收器!!!!!!!(我以为插件可以代替接收器, 结果插线也得要接收器… 算了吧)</strong></p>\n<h4 id=\"下午继续看了一部分-云收藏的源码看到了这个下面一个函数\"><a href=\"#下午继续看了一部分-云收藏的源码看到了这个下面一个函数\" class=\"headerlink\" title=\"下午继续看了一部分 云收藏的源码看到了这个下面一个函数\"></a>下午继续看了一部分 云收藏的源码看到了这个下面一个函数</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\tSystem.out.println(getMessage(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\"4\"</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getMessage</span><span class=\"params\">(String template, String... keys)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tStringBuilder templateBuilder = <span class=\"keyword\">new</span> StringBuilder(template);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">\t\ttemplateBuilder.append(key);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttemplate = templateBuilder.toString();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> template;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重点不是函数的功能, 而是<code>String...</code>这不是写错了. 我去网上查了下, 这样这个函数就可以接受多个参数了<br><code>getMessage(&quot;template&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code> 接受参数后用 增强for循环以此取出就好</p>\n<p><code>是从Java 5开始，Java语言对方法参数支持一种新写法，叫可变长度参数列表</code></p>\n<p>正好在这里去搜集下每次Java更新, 所提供的新特性</p>\n<h4 id=\"JDK5-新特性\"><a href=\"#JDK5-新特性\" class=\"headerlink\" title=\"JDK5 新特性\"></a>JDK5 新特性</h4><p>#自动装箱与拆箱</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"keyword\">new</span> Integer(<span class=\"number\">10</span>); </span><br><span class=\"line\"><span class=\"comment\">//这个问题不大</span></span><br><span class=\"line\">Integer b = <span class=\"number\">100</span>; <span class=\"comment\">//这里就把一个int自动转成了 integer类型(自动装箱)</span></span><br><span class=\"line\"><span class=\"comment\">//这里用到了 Integer的 valueOf()方法 实现的自动装箱</span></span><br><span class=\"line\">b += <span class=\"number\">100</span>; <span class=\"comment\">//b = b + 100; 用intValue()来自动拆箱</span></span><br><span class=\"line\"><span class=\"comment\">//实现方式 b = Integer.valueOf(b.intValue() + 200);</span></span><br></pre></td></tr></table></figure>\n\n<p>#枚举类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> </span><br><span class=\"line\"><span class=\"comment\">// switch可以 switch枚举类型</span></span><br></pre></td></tr></table></figure>\n\n<p>#静态导入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> java.lang.Math.pow; </span><br><span class=\"line\"><span class=\"comment\">//静态导入的必须是静态方法</span></span><br><span class=\"line\">System.out.println(Math.pow(<span class=\"number\">2</span>, <span class=\"number\">3</span>)); <span class=\"comment\">//未使用静态导入</span></span><br><span class=\"line\">System.out.println(pow(<span class=\"number\">2</span>, <span class=\"number\">3</span>)); <span class=\"comment\">//使用静态导入</span></span><br></pre></td></tr></table></figure>\n\n<p>#可变参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以在方法参数的类型中 加入三个`...`, 这样在方法体内可以使用for的增强循环来获得传入的多个参数.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\tSystem.out.println(getMessage(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\"4\"</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getMessage</span><span class=\"params\">(String template, String... keys)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tStringBuilder templateBuilder = <span class=\"keyword\">new</span> StringBuilder(template);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">\t\ttemplateBuilder.append(key);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttemplate = templateBuilder.toString();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> template;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>#增强for循环<br>#泛型 (Generic Type)<br>#内省</p>\n<h4 id=\"JDK6-新特性\"><a href=\"#JDK6-新特性\" class=\"headerlink\" title=\"JDK6 新特性\"></a>JDK6 新特性</h4><p>#Desktop类和SystemTray类<br>第一个<code>Desktop</code>类<br>可以用来打开系统默认浏览器浏览指定的URL<br>打开系统默认邮件客户端给指定的邮箱发邮件<br>用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件)<br>用系统默认的打印机打印文档<br>第二个<code>SystemTray</code>类<br>可以用来在系统托盘区创建一个托盘程序.<br>Java的UI方面就不写太多了</p>\n<p>@2019年7月18日20:47:07@</p>\n<h4 id=\"Springboot配置文件\"><a href=\"#Springboot配置文件\" class=\"headerlink\" title=\"Springboot配置文件\"></a>Springboot配置文件</h4><p>在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式<br>其中{profile}对应你的环境标识</p>\n<p>下面列举三个文件<br><code>application-dev.properties</code>：开发环境<br><code>application-test.properties</code>：测试环境<br><code>application-prod.properties</code>：生产环境<br>至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。<br><code>spring.profiles.active=dev</code></p>\n<h3 id=\"7月19日\"><a href=\"#7月19日\" class=\"headerlink\" title=\"7月19日\"></a>7月19日</h3><p>今天的话在北京待了一天, 去看了看北方最大的漫展IDO, 怎么说呢比我想象的要小一点, 不过比徐州那个好太多了. 以后有机会的话就去南方了.</p>\n<h2 id=\"7-20-7-26\"><a href=\"#7-20-7-26\" class=\"headerlink\" title=\"7.20-7.26\"></a>7.20-7.26</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;接口, 内部类, 持有对象&gt;</span><br><span class=\"line\">---七个结构型模式</span><br><span class=\"line\">- 适配器模式</span><br><span class=\"line\">- 桥接模式</span><br><span class=\"line\">- 组合模式</span><br><span class=\"line\">- 外观模式</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7月20日\"><a href=\"#7月20日\" class=\"headerlink\" title=\"7月20日\"></a>7月20日</h3><p>今天还是胳膊有些疼, 昨天拿的东西不少, 背的也不少.走的路也不少…..<br>@2019年7月20日19:39:08@</p>\n<p>现在来看一些东西吧. 上个寒假在家里留了一本Java编程思想.</p>\n<h3 id=\"7月21日\"><a href=\"#7月21日\" class=\"headerlink\" title=\"7月21日\"></a>7月21日</h3><p>写了个新的小项目, 正好来练练手. 新项目单独列出一篇博客.</p>\n<h3 id=\"7月22日\"><a href=\"#7月22日\" class=\"headerlink\" title=\"7月22日\"></a>7月22日</h3><p>在家里午觉睡不着我凑, 改下小项目的问题.<br>@去看一下设计模式吧@</p>\n<h4 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h4><p>这个设计模式怎么说呢, 挺简单的.<br>就是 新建一个适配器类Adapter  引用一个需要适配的类Adaptee 这个类实现客户端的接口Target</p>\n<p>这样客户端直接调用接口 相关转换工作在接口中完成.</p>\n<h2 id=\"7-27-8-02\"><a href=\"#7-27-8-02\" class=\"headerlink\" title=\"7.27-8.02\"></a>7.27-8.02</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;类型信息, 泛型&gt;</span><br><span class=\"line\">- 装饰模式</span><br><span class=\"line\">- 享元模式(略过)</span><br><span class=\"line\">- 代理模式</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7月28日\"><a href=\"#7月28日\" class=\"headerlink\" title=\"7月28日\"></a>7月28日</h3><p>从7.23-7.25 写了个小项目, 失物招领的后端.<br>总的来说有 </p>\n<h4 id=\"统一反应类型\"><a href=\"#统一反应类型\" class=\"headerlink\" title=\"统一反应类型\"></a>统一反应类型</h4><p>将所有的返回结果, 写在一个类中</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951.png\" alt=\"\"></p>\n<p>预先定义的异常信息, 则使用了enum</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952.png\" alt=\"\"></p>\n<p>封装反回数据, 使用Object</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953.png\" alt=\"\"></p>\n<p>这样处理后就可以</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseData(ExceptionMsg.DEL_FAILED);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseData(ExceptionMsg.DEL_FAILED);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> ResponseData(ExceptionMsg.SUCCESS, lostAndFoundInfo);</span><br></pre></td></tr></table></figure>\n\n<p>来统一返回类型</p>\n<h4 id=\"Spring-Jpa的方便\"><a href=\"#Spring-Jpa的方便\" class=\"headerlink\" title=\"Spring Jpa的方便\"></a>Spring Jpa的方便</h4><p>配置完毕后, 去编写相应的实体类</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/lostandfound?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class=\"line\"><span class=\"string\">spring.datasource.username=root</span></span><br><span class=\"line\"><span class=\"string\">spring.datasource.password=root</span></span><br><span class=\"line\"><span class=\"string\">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># create：只要每次加载 Hibernate 时就都会删除上一次生成的表，然后根据 model 类再重新来生成新表. </span></span><br><span class=\"line\"><span class=\"comment\"># create-drop：每次加载 Hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭，表就自动删除。</span></span><br><span class=\"line\"><span class=\"comment\"># update：最常用的属性，第一次加载 Hibernate 时根据 model 类会自动建立起表的结构（前提是先建立# # 好数据库），以后加载 Hibernate 时根据 model 类自动更新表结构，即使表结构改变了，但表中的行仍然存在，不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。</span></span><br><span class=\"line\"><span class=\"comment\">#validate ：每次加载 Hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</span></span><br><span class=\"line\"><span class=\"string\">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span> <span class=\"comment\">//这里可以通过value属性指定表名, 如果不指定则为类名</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span> <span class=\"comment\">//默认情况下会创建新表来存储id位置, 如果指定 strategy= GenerationType.IDENTITY 则会在一张表中存储位置id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>， unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String passWord;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>， unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String email;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">true</span>， unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String nickName;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String regTime;</span><br><span class=\"line\">    <span class=\"comment\">//省略 getter settet 方法、构造方法  在这里getter setter 影响 Controller 的 return的内容. 有get方法才会在json中含有该项, 如果不想让该项出现在json中 则不需要写对应的get方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后编写实体类对应的repository接口 继承 JpaRepository&lt;model, Long&gt;</p>\n<p>就可使用自带的一些方法.</p>\n<h4 id=\"去继续学习吧\"><a href=\"#去继续学习吧\" class=\"headerlink\" title=\"去继续学习吧\"></a>去继续学习吧</h4><p>&lt;接口, 内部类, 持有对象&gt;</p>\n<p>重写Readable导致的bug.<br>再Main方法里产生随机单词, 导致异常<code>BufferOverflowException</code> , 首先思考的是每次调用<code>read()</code>方法应该会传入一个新的<code>CharBuffer</code>吧(实际并不是, 后面说)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tScanner scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> RandomWords(<span class=\"number\">100000</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(scanner.next());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RandomWords.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWords</span> <span class=\"keyword\">implements</span> <span class=\"title\">Readable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random random = <span class=\"keyword\">new</span> Random(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] CAPITALS =</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"ABCDEFGHIGKLMNOPQRSTUVWXYZ\"</span>.toCharArray();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] LOWERS =</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"abcdefghigklmnopqrstuvwxyz\"</span>.toCharArray();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RandomWords</span><span class=\"params\">(<span class=\"keyword\">int</span> count)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.count = count;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(CharBuffer cb)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(count-- == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> maxCount = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxCount; i++) &#123;</span><br><span class=\"line\">\t\t\tcb.append(LOWERS[random.nextInt(LOWERS.length)]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//System.out.println(cb.limit() + \" - \" + cb.position());</span></span><br><span class=\"line\">\t\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcb.append(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来到报错位置, 这一段是CharBuffer源码里的部分, 发现是由于position &gt;= limit导致的异常, 然后查找得到这两个值得获取方法position()和limit();</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">nextPutIndex</span><span class=\"params\">()</span> </span>&#123;                          <span class=\"comment\">// package-private</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (position &gt;= limit)</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BufferOverflowException();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> position++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在RandomWords.java代码加入 <code>System.out.println(cb.limit() + &quot; - &quot; + cb.position());</code> 位置见上文注释代码</p>\n<p>经过打印发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AyAvFkNuM</span><br><span class=\"line\">1024 - 1002</span><br><span class=\"line\">1024 - 1004</span><br><span class=\"line\">1024 - 1006</span><br><span class=\"line\">1024 - 1008</span><br><span class=\"line\">RcEsZqFwO</span><br><span class=\"line\">1024 - 1012</span><br><span class=\"line\">1024 - 1014</span><br><span class=\"line\">1024 - 1016</span><br><span class=\"line\">1024 - 1018</span><br><span class=\"line\">HxEsXaStX</span><br><span class=\"line\">1024 - 1022</span><br><span class=\"line\">1024 - 1024</span><br></pre></td></tr></table></figure>\n<p>position属性并没有随着每次调用read() 方法重置, 所以每次调用read()方法传入的是同一个 <code>CharBuffer</code>. 回到Scanner源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Scanner.java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过查找找到调用read()方法的地方</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readInput</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buf.limit() == buf.capacity())</span><br><span class=\"line\">            makeSpace();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Prepare to receive data</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = buf.position();</span><br><span class=\"line\">        buf.position(buf.limit());</span><br><span class=\"line\">        buf.limit(buf.capacity());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123; <span class=\"comment\">//这里调用了source.read()  source就是构造方法传入的在RandomWords对象</span></span><br><span class=\"line\">            n = source.read(buf);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            lastException = ioe;</span><br><span class=\"line\">            n = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            sourceClosed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            needInput = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            needInput = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Restore current position and limit for reading</span></span><br><span class=\"line\">        buf.limit(buf.position());</span><br><span class=\"line\">        buf.position(p);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现其传入了<code>buf</code>参数, 查找<code>buf</code>来到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Scanner</span><span class=\"params\">(Readable source, Pattern pattern)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">assert</span> source != <span class=\"keyword\">null</span> : <span class=\"string\">\"source should not be null\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">assert</span> pattern != <span class=\"keyword\">null</span> : <span class=\"string\">\"pattern should not be null\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.source = source;</span><br><span class=\"line\">\tdelimPattern = pattern;</span><br><span class=\"line\">\tbuf = CharBuffer.allocate(BUFFER_SIZE);</span><br><span class=\"line\">\tbuf.limit(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tmatcher = delimPattern.matcher(buf);</span><br><span class=\"line\">\tmatcher.useTransparentBounds(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\tmatcher.useAnchoringBounds(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\tuseLocale(Locale.getDefault(Locale.Category.FORMAT));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发现是这个构造方法 对buf进行的赋值, 而    <code>Scanner(Readable source)</code>这个构造方法也只是调用的上一个构造方法.</p>\n<p>所以问题解决了, 由于我是在一开始就实例化了一个<code>Scanner对象</code>. 导致传入<code>read()</code>方法的<code>buf</code>都是同一个 才导致的上文报错.</p>\n<p>@2019年7月28日19:18:23@</p>\n<p>囫囵吞枣的看完了接口<br>看了一部分内部类. 感觉很没有实感..<br>联系的太少了, 对他所说的没有感到<code>原来如此</code></p>\n<h3 id=\"7月29日-8月2日\"><a href=\"#7月29日-8月2日\" class=\"headerlink\" title=\"7月29日-8月2日\"></a>7月29日-8月2日</h3><p>又写了一个二手交易的后台, 马上今天是八月二号, 这个假期也过了小一半了. </p>\n<p>最近也看了看大数据相关的, 等这几天多看看关于大数据的, 也许我会选大数据专业emmm<br>@2019年8月2日20:22:20@<br>去看看ElasticSearch吧, 二手交易还差一个搜索</p>\n<p>设置ip地址<br>关闭防火墙<br>关闭保护<br>删除映射管理文件<br>关机–&gt;克隆四台电脑<br>@2019年8月2日23:42:36@</p>\n<h2 id=\"8-3-8-9\"><a href=\"#8-3-8-9\" class=\"headerlink\" title=\"8.3-8.9\"></a>8.3-8.9</h2><h3 id=\"8月3日\"><a href=\"#8月3日\" class=\"headerlink\" title=\"8月3日\"></a>8月3日</h3><p>大数据相关的删掉了, 移动到了单独的一篇博客</p>\n<h3 id=\"8月4日\"><a href=\"#8月4日\" class=\"headerlink\" title=\"8月4日\"></a>8月4日</h3><p>大数据相关的删掉了, 移动到了单独的一篇博客</p>\n<h3 id=\"8月8日\"><a href=\"#8月8日\" class=\"headerlink\" title=\"8月8日\"></a>8月8日</h3><p>继续学习大数据相关内容, 刷了一道算法题.待会看看Java IO流</p>\n<p><em>暑期计划就到此了, 自己对于将来从事什么, 还是有些迷茫, 还是多去刷刷算法题目, 找找自己的路再走吧</em></p>"},{"title":"网络配置","date":"2020-07-18T09:39:20.000Z","_content":"\n# 服务器双网卡配置\n内网访问外网\n\n外网接在了校园网上, 不过我的路由器不支持Ipv6, 有没有多余的lan口 只能接在服务器的lan口上\n\n需要设置内网网卡开机启动 固定的Ip地址10.5.1.2 以及子网掩码255.255.255.0\n然后路由器设置固定Ip地址10.5.1.3 子网掩码255.255.255.0 与内网网卡同网段\n\n然后使用`firewall-cmd --add-masquerade --permanent`\n\nMasquerading is useful if the machine is a router and machines connected over an interface in another zone should be able to use the first connection.\n通过另一个区域(zone)的接口 使用默认zone的接口上网\n\nhttps://www.server-world.info/en/note?os=CentOS_7&p=firewalld&f=2\n配置完才发现的神网址.... 好吧 写得非常清楚","source":"_posts/Linux-网络配置.md","raw":"---\ntitle: 网络配置\ndate: 2020-07-18 17:39:20\ncategories: \n- Linux\ntags:\n- 网络配置\n---\n\n# 服务器双网卡配置\n内网访问外网\n\n外网接在了校园网上, 不过我的路由器不支持Ipv6, 有没有多余的lan口 只能接在服务器的lan口上\n\n需要设置内网网卡开机启动 固定的Ip地址10.5.1.2 以及子网掩码255.255.255.0\n然后路由器设置固定Ip地址10.5.1.3 子网掩码255.255.255.0 与内网网卡同网段\n\n然后使用`firewall-cmd --add-masquerade --permanent`\n\nMasquerading is useful if the machine is a router and machines connected over an interface in another zone should be able to use the first connection.\n通过另一个区域(zone)的接口 使用默认zone的接口上网\n\nhttps://www.server-world.info/en/note?os=CentOS_7&p=firewalld&f=2\n配置完才发现的神网址.... 好吧 写得非常清楚","slug":"Linux-网络配置","published":1,"updated":"2020-07-18T09:50:25.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6g001af8unclfyey67","content":"<h1 id=\"服务器双网卡配置\"><a href=\"#服务器双网卡配置\" class=\"headerlink\" title=\"服务器双网卡配置\"></a>服务器双网卡配置</h1><p>内网访问外网</p>\n<p>外网接在了校园网上, 不过我的路由器不支持Ipv6, 有没有多余的lan口 只能接在服务器的lan口上</p>\n<p>需要设置内网网卡开机启动 固定的Ip地址10.5.1.2 以及子网掩码255.255.255.0<br>然后路由器设置固定Ip地址10.5.1.3 子网掩码255.255.255.0 与内网网卡同网段</p>\n<p>然后使用<code>firewall-cmd --add-masquerade --permanent</code></p>\n<p>Masquerading is useful if the machine is a router and machines connected over an interface in another zone should be able to use the first connection.<br>通过另一个区域(zone)的接口 使用默认zone的接口上网</p>\n<p><a href=\"https://www.server-world.info/en/note?os=CentOS_7&amp;p=firewalld&amp;f=2\" target=\"_blank\" rel=\"noopener\">https://www.server-world.info/en/note?os=CentOS_7&amp;p=firewalld&amp;f=2</a><br>配置完才发现的神网址…. 好吧 写得非常清楚</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"服务器双网卡配置\"><a href=\"#服务器双网卡配置\" class=\"headerlink\" title=\"服务器双网卡配置\"></a>服务器双网卡配置</h1><p>内网访问外网</p>\n<p>外网接在了校园网上, 不过我的路由器不支持Ipv6, 有没有多余的lan口 只能接在服务器的lan口上</p>\n<p>需要设置内网网卡开机启动 固定的Ip地址10.5.1.2 以及子网掩码255.255.255.0<br>然后路由器设置固定Ip地址10.5.1.3 子网掩码255.255.255.0 与内网网卡同网段</p>\n<p>然后使用<code>firewall-cmd --add-masquerade --permanent</code></p>\n<p>Masquerading is useful if the machine is a router and machines connected over an interface in another zone should be able to use the first connection.<br>通过另一个区域(zone)的接口 使用默认zone的接口上网</p>\n<p><a href=\"https://www.server-world.info/en/note?os=CentOS_7&amp;p=firewalld&amp;f=2\" target=\"_blank\" rel=\"noopener\">https://www.server-world.info/en/note?os=CentOS_7&amp;p=firewalld&amp;f=2</a><br>配置完才发现的神网址…. 好吧 写得非常清楚</p>\n"},{"title":"3DMAX快捷键及基础知识","date":"2020-02-16T08:37:08.000Z","img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/3dmax%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.jpg","_content":"\n由于自己日后可能需要使用3d建模, 所以今天学习了下. 为了速成 看的B站的一个视频. 感觉效果还行吧.\n基础的建模可以完成了, 后续需要的话 再继续学习\n\n|按键|功能|\n|---|---|\n|||\n|shift|绘制直线|\n|删除键|可以回退一次|\n|||\n|W|移动|\n|E|旋转|\n|R|缩放|\n|||\n|F3|线框显示模式|\n|F4|实体+线框限时模式|\n|||\n|Shift|按住可以复制|\n|||\n|Alt+T+A|阵列|\n|Alt+T+M|镜像|\n|Alt+A+对齐|\n|Shitf+I|间隔工具|\n|||\n|Ctrl+X|专家模式, 隐藏所有多余的东西 获得最大的空间|\n|Alt+X|半透明显示|\n|Ctrl+Shift+X|变换虚拟体显示切换 可以看到变换虚拟体的明显变化|\n|O|自适应降级|\n\n**编辑样条线->顶点**\n优化 在线上添加点\n焊接 连接两点\n自动焊接 两点在距离之内自动焊接\n\n**车削修改器**\n将二维图形 指定一个轴然后旋转 得到立体图形\n\n**可编辑多边形**\n*细分曲面*\n迭代次数2-3\n无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)\n*细分置换-经常使用置换网格WSM修改器*\n需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图\n*绘制变形-未学-用于雕刻地形*\n**倒角剖面和扫描的区别**\n1. 结合点不同\n2. 倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓\n3. 倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.","source":"_posts/UE4&3DMAX-3dmax快捷键及基础知识.md","raw":"---\ntitle: 3DMAX快捷键及基础知识\ndate: 2020-02-16 16:37:08\ncategories:\n  - UE4&3DMAX\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/3dmax%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.jpg\n---\n\n由于自己日后可能需要使用3d建模, 所以今天学习了下. 为了速成 看的B站的一个视频. 感觉效果还行吧.\n基础的建模可以完成了, 后续需要的话 再继续学习\n\n|按键|功能|\n|---|---|\n|||\n|shift|绘制直线|\n|删除键|可以回退一次|\n|||\n|W|移动|\n|E|旋转|\n|R|缩放|\n|||\n|F3|线框显示模式|\n|F4|实体+线框限时模式|\n|||\n|Shift|按住可以复制|\n|||\n|Alt+T+A|阵列|\n|Alt+T+M|镜像|\n|Alt+A+对齐|\n|Shitf+I|间隔工具|\n|||\n|Ctrl+X|专家模式, 隐藏所有多余的东西 获得最大的空间|\n|Alt+X|半透明显示|\n|Ctrl+Shift+X|变换虚拟体显示切换 可以看到变换虚拟体的明显变化|\n|O|自适应降级|\n\n**编辑样条线->顶点**\n优化 在线上添加点\n焊接 连接两点\n自动焊接 两点在距离之内自动焊接\n\n**车削修改器**\n将二维图形 指定一个轴然后旋转 得到立体图形\n\n**可编辑多边形**\n*细分曲面*\n迭代次数2-3\n无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)\n*细分置换-经常使用置换网格WSM修改器*\n需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图\n*绘制变形-未学-用于雕刻地形*\n**倒角剖面和扫描的区别**\n1. 结合点不同\n2. 倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓\n3. 倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.","slug":"UE4&3DMAX-3dmax快捷键及基础知识","published":1,"updated":"2020-12-05T02:37:36.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6h001df8un8geihcsq","content":"<p>由于自己日后可能需要使用3d建模, 所以今天学习了下. 为了速成 看的B站的一个视频. 感觉效果还行吧.<br>基础的建模可以完成了, 后续需要的话 再继续学习</p>\n<table>\n<thead>\n<tr>\n<th>按键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shift</td>\n<td>绘制直线</td>\n</tr>\n<tr>\n<td>删除键</td>\n<td>可以回退一次</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>W</td>\n<td>移动</td>\n</tr>\n<tr>\n<td>E</td>\n<td>旋转</td>\n</tr>\n<tr>\n<td>R</td>\n<td>缩放</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>F3</td>\n<td>线框显示模式</td>\n</tr>\n<tr>\n<td>F4</td>\n<td>实体+线框限时模式</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Shift</td>\n<td>按住可以复制</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Alt+T+A</td>\n<td>阵列</td>\n</tr>\n<tr>\n<td>Alt+T+M</td>\n<td>镜像</td>\n</tr>\n<tr>\n<td>Alt+A+对齐</td>\n<td></td>\n</tr>\n<tr>\n<td>Shitf+I</td>\n<td>间隔工具</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Ctrl+X</td>\n<td>专家模式, 隐藏所有多余的东西 获得最大的空间</td>\n</tr>\n<tr>\n<td>Alt+X</td>\n<td>半透明显示</td>\n</tr>\n<tr>\n<td>Ctrl+Shift+X</td>\n<td>变换虚拟体显示切换 可以看到变换虚拟体的明显变化</td>\n</tr>\n<tr>\n<td>O</td>\n<td>自适应降级</td>\n</tr>\n</tbody></table>\n<p><strong>编辑样条线-&gt;顶点</strong><br>优化 在线上添加点<br>焊接 连接两点<br>自动焊接 两点在距离之内自动焊接</p>\n<p><strong>车削修改器</strong><br>将二维图形 指定一个轴然后旋转 得到立体图形</p>\n<p><strong>可编辑多边形</strong><br><em>细分曲面</em><br>迭代次数2-3<br>无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)<br><em>细分置换-经常使用置换网格WSM修改器</em><br>需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图<br><em>绘制变形-未学-用于雕刻地形</em><br><strong>倒角剖面和扫描的区别</strong></p>\n<ol>\n<li>结合点不同</li>\n<li>倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓</li>\n<li>倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>由于自己日后可能需要使用3d建模, 所以今天学习了下. 为了速成 看的B站的一个视频. 感觉效果还行吧.<br>基础的建模可以完成了, 后续需要的话 再继续学习</p>\n<table>\n<thead>\n<tr>\n<th>按键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shift</td>\n<td>绘制直线</td>\n</tr>\n<tr>\n<td>删除键</td>\n<td>可以回退一次</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>W</td>\n<td>移动</td>\n</tr>\n<tr>\n<td>E</td>\n<td>旋转</td>\n</tr>\n<tr>\n<td>R</td>\n<td>缩放</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>F3</td>\n<td>线框显示模式</td>\n</tr>\n<tr>\n<td>F4</td>\n<td>实体+线框限时模式</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Shift</td>\n<td>按住可以复制</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Alt+T+A</td>\n<td>阵列</td>\n</tr>\n<tr>\n<td>Alt+T+M</td>\n<td>镜像</td>\n</tr>\n<tr>\n<td>Alt+A+对齐</td>\n<td></td>\n</tr>\n<tr>\n<td>Shitf+I</td>\n<td>间隔工具</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Ctrl+X</td>\n<td>专家模式, 隐藏所有多余的东西 获得最大的空间</td>\n</tr>\n<tr>\n<td>Alt+X</td>\n<td>半透明显示</td>\n</tr>\n<tr>\n<td>Ctrl+Shift+X</td>\n<td>变换虚拟体显示切换 可以看到变换虚拟体的明显变化</td>\n</tr>\n<tr>\n<td>O</td>\n<td>自适应降级</td>\n</tr>\n</tbody></table>\n<p><strong>编辑样条线-&gt;顶点</strong><br>优化 在线上添加点<br>焊接 连接两点<br>自动焊接 两点在距离之内自动焊接</p>\n<p><strong>车削修改器</strong><br>将二维图形 指定一个轴然后旋转 得到立体图形</p>\n<p><strong>可编辑多边形</strong><br><em>细分曲面</em><br>迭代次数2-3<br>无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)<br><em>细分置换-经常使用置换网格WSM修改器</em><br>需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图<br><em>绘制变形-未学-用于雕刻地形</em><br><strong>倒角剖面和扫描的区别</strong></p>\n<ol>\n<li>结合点不同</li>\n<li>倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓</li>\n<li>倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.</li>\n</ol>\n"},{"title":"大二寒假学习记录","date":"2020-02-01T09:30:32.000Z","_content":"\n现在是`2020年2月1日17:32:50` 寒假过半? 目前还不知道寒假什么时候开学. 为了自己能够前往心目中的公司, 学习是必不可少的.\n学习的同时 应该要注意总结, 防止一天或者一周下来白忙活\n我们寒假开始是一月九号 到我开始寒假学习的一月二十三号 这些天没有学习用来玩了, 好在后面拾了回来\n从二十三号到现在二月一号, 每天学习的长度和质量总算是在慢慢上升\n距离下一个寒假只剩下一年的时间了, 需要更加的努力, 为了大三暑假能够进入心中的公司 大三寒假的实习必不可少了. 加倍努力吧\n\n这篇博客的标题起初是`大二寒假学习记录`后来改成了`大二寒假及下学期学习记录`寒假的学习必不可少, 下学期更要抓紧时间了.\n\n# 二月\n## 一日2020年2月1日17:39:59\n\n前几天把博客从我自己的服务器迁移到了coding上, 方便以后我乱搞服务器, 现在服务器上没有重要的内容了\n至于实际的学习方面, 我开始整理我的博客[主要是这篇](https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/)这篇现在算告一段落了, 主要是把自己以前学过的用一用. 空洞的写下api\n理解不是很深刻.[这两天修改的这一篇](https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/). 第二篇自己缺少的东西很多, 由于当时学习到了后面实在是学不下去了.\n所以现在把后面的部分重新写了一下. 高级部分的线程和进程的部分 实在是太走马观花. 等我顺序学到了 再多写一些例子\n\n今天的话, 练习了下poll系统调用, 写了一个poll的demo, 然后是整理了下信号的部分, 信号这里整理的依然很少 平时用到的不多, 需要多加使用\n主要是定时器这里了 定时器把原来的内容删掉了 从新写目前只写完了socket定时\n\n接下来打算还是多写一些项目 多思考一些 等我整理完了高级部分 就准备去看开源项目?每次看开源项目都感觉自己差的太多, 不知道从哪里看起\n所以搭配着别人的笔记学习下看源码. 当然看源码之前还是要会大概的使用. 高级部分自然包括了libevent的使用部分\n\n跑去写项目了\n\n## 二日2020年2月2日18:03:23\n\n罪过罪过, 昨天晚上十一点半 玩了一把军团TD 结果玩到了十二点半 ..... 最后一点半才睡觉\n今天早上小十一点才起床.\n我依稀记得我八点被闹钟叫起来emm 然后想着定八点半的闹钟 再睡一会, 结果闹钟没定我就睡着了.\n\n起来后整理了整理吃了午饭, 就下午小一点了, 打开高级部分 学习`信号SIGALRM定时`\n\n代码量就400行 一直到我写今天的博客 才算完工\n\n**先写一下遇到的一个问题吧**\n首先表现出来的是`超时后 服务器没有断开连接`\n然后我去打断点, 发现不是定时器链表部分的问题. 是定时信号没有触发`epoll_wait`.\n这里我看了下代码, 发现定时器没有启动加上了`alarm(5)`, 我本意是理解了书上的代码 再去自己写, 结果还是理解的不深刻, 竟然丢了启动定时器的函数.\n然后我又运行了下`发现还是没有运行到`\n然后发现`epoll_wait 返回-1 设置EINTR`, 后来查阅了下说是被信号处理器中断, 思考可能是与IDE下断点有关??????\n最后发现自己没有把信号的管道添加到`epollfd`中再一细看发现丢了关于信号管道的四行代码...\n\n这个问题应该是很容易排查. 事后感觉应该这样思考\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/epoll%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.png)\n以后尽量总结正确的思考模式, 虽然不知道有没有用 但要试一试.\n\n**项目收获方面**\n虽然这个项目只有400多行代码, 但我自己是绝对写不出来的. 只能尽量总结书上代码的好处\n1. 首先肯定是使用alarm超时产生信号SIGALRM来触发回调函数 实现定时\n2. 信号回调函数, 没有直接去触发定时器tick函数, 而是通过一个管道传到了epollfd中, 然后从epollfd的函数中触发相关的if 再去调用tick函数\n```c++\nvoid timer_handler() //真正的生效部分\n{\n    timer_lst.tick();\n    alarm(TIMESLOT);\n}\nvoid sig_handler(int sig)\n{\n    int save_errno = errno;\n    int msg = sig;\n    send(pipefd[1], (char*)&msg, 1, 0); // pipefd[0]注册进了epoll中 接受到来的信号\n    errno = save_errno;\n}\n\nvoid addsig(int sig)// 信号添加\n{\n    struct sigaction sa{};\n    sa.sa_flags |= SA_RESTART;\n    sa.sa_handler = sig_handler;\n    sigfillset(&sa.sa_mask);\n    exit_if(sigaction(sig, &sa, nullptr) == -1, \"add sig error\");\n}\n\nchar signals[1024]; // 信号接收, 可能存在多个信号 所以用返回的字节数来逐个取出信号\nret = recv(sockfd, signals, sizeof(signals), 0); 取出后使用switch来分离信号\n```\n3. 将大部分常量 #define\n大概只能总结出这一些来了, 完整的代码我贴在github上吧\n\n## 五日 2020年2月6日09:16:23\n三和四号 基本都在玩FF14, 发现自己并不是玩游戏了, 感觉被FF14玩了, 就是那种感觉累了不想玩了, 但却离自己定的小目标远 然后坚持\nemm 其实感觉这个时候应该下游戏.\n想想自己这大学一年半玩过的游戏 血族我算是玩的时间最长的大概前前后后我玩了五年, 应该是上半年把 我弃坑了. 游戏后面太氪了, 不得不退游了.\n后面崩三啥的也玩过, 发现自己并不适合肝的游戏. 最近一个月入坑了fgo, 开始的几个星期还是玩的累了, 自己太肝了, 最近这几天感觉休闲了不少, \n心态也正常了, 所以暂且会玩一玩.\n\n主要还是后面这些吧, 我发现自己逐渐有了一个念头: 累了就去玩会游戏, 就去看会直播, 刷刷B站. 后来我感觉这些浪费时间就去搜索了一下\n**玩游戏算浪费时间吗**, 刚才去找了下. 没找到我之前看过的那篇. 结论就是为什么自己不是累了就去小睡一下, 或者看看书,再或者刷刷新的科技圈\n长长见识? 自己尝试了看书, 发现自己并不是太抗拒. 以后试试把.\n\n最后自己作为一个想开发游戏的人, 总感觉不玩游戏是不合适的, 但要玩的适度, 毕竟自己还有一年的时间就要找寒假实习, 为了自己的大三暑假进入大厂打下基础.\n平衡好才是上策.\n\n接下文, 我发现自己有点?(自信点把点去掉)好高骛远了, 好高骛远会消磨一个人的兴趣和信心. 最终决定不做什么大游戏, 不研究什么框架, 先用自己所会的写一个小游戏,\n一是为了试着重新拾起兴趣, 二是如果只学而不去写项目, 没有太大收获的\n\n昨天一天都是策划和编写一个游戏, 游戏逻辑十分的简单. 猜数字 初期的流程图我大概画了下, 姑且算作第一版吧 下面放出来, 我后面可以逐渐丰富这个东西 加上日志登录\n断线重连等等功能.感觉还是可以的~~ 尽管逻辑很简单.\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%B5%81%E7%A8%8B1.png)\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%911.png)\n\n听说在写代码前规划好, 可以更好地组织代码, 昨天尝试了下感觉还不错. 我在写代码前把游戏的流程图画了一下, 然后标上了哪里会有什么数据交互,\n之后我去写了数据包头格式\n**头部**\n\n| 偏移量 | 长度 | 含义\n| --- | --- | --- |\n| 0 | 4 | 封包总大小 |\n| 4 | 2 | 头部长度 |\n| 6 | 2 | 操作码 |\n\n**操作码**\n\n| 代码 | 含义 | 数据格式 |\n| --- | --- | --- |\n| 00 | 登录 | |\n| 01 | 桌位信息(服务器发送桌位列表) | [1000-0-4][1001-0-4] |\n| 02 | 桌位操作信息(客户端加入 退出桌位) | 1000 |\n| 03 | 服务器桌位操作信息反馈(加入退出成功1 加入退出失败0) | 1 |\n| 04 | 准备 | 无 |\n| 05 | 取消准备 | 无 |\n| 06 | 服务器广播桌位信息 | 4[11][10][00][00] (桌位总数, 有人1 准备1) |\n| A1 | 服务器广播游戏开始 | 空 |\n| A2 | 服务器下发轮到的客户端 | 空 |\n| A3 | 客户端发送猜测的数字 | 50 |\n| A4 | 服务器发送猜测数字反馈 (数据合理1, 数据非法0) | 1 |\n| A5 | 服务器广播游戏状态 | 50-0-75[A][B] (A玩家猜出50 当前范围 0到75 B玩家准备) |\n\n然后草拟了一下 用到的类 用到的数据结构 分几个类 怎么联系起来, 最终我才去写代码, 感觉比一边写\n一边想要好不少. 写的过程中也发现了一些问题\n1. `EPOLLRDHUP`这个绑定在listenfd还是newfd?? 如果是newfd还能理解下原理, listenfd就有点理解不了.(试了下, 是newfd)\n2. \n```c++\nFoo *a;\nFoos b[3];\nb[1] = *a;\n// 修改a不会影响b[1], 这个问题听到过, 自己真正试了试才发现如此\n```\n\n姑且昨天的就补上这些吧. 今天打算把游戏的服务器跑起来\n\n## 六日 2020年2月6日22:12:36\n忙忙碌碌的一天就又要结束了. 今天一天把剩下的一部分逻辑代码写了一部分. 主要是写自定义协议的序列化和反序列化. 起初打算\n用char* body 来存储, 按照上面定义的格式传输. 后来一想, 这样我就不就是在原地打转吗. 就去网上找了找相关的代码, 看看别人怎么写的\n\n主要是看的这一篇博客[手把手教你实现自定义的应用层协议](https://blog.csdn.net/ACb0y/article/details/61421006)\n看了之后收获不少. 收获总结在下面吧\n\n1. 两个头文件互相include\n\t这个是今天了解的最奇葩的一个问题, 如果两个头文件互相include 会出问题. 这个明天开一篇 采坑博客\n\t与此连带的还有class 前置声明, 再者可以到编译相关的问题\n2. 今天了解了一下CMAKE和MAKE的区别和联系, 总算知道了为啥好多安装的时候先cmake 再 make\n3. 还是关于CMAKE 稍微整理了点CMAKE的使用. 随用随整理, 目前不打算一次性整理太多\n4. Git操作不熟练. 我本地写好了代码文件, commit 然后从服务器pull了一个仅包含readme的仓库, 然后reset\n\t自己写的代码文件全没了, 只剩下README.md 还好之前整理过reflog, 明天也需要在整理下\n5. 安装了jsoncpp, 亿图图示等一些软件. 写了下关于字节对齐的问题. 亿图图示目前感觉挺不错\n\n代码方面的收获 主要就是看的那篇博客学到的.\n1. 首先就是学会了自定了协议 序列化和反序列化怎么写 代码更美. 虽然可能我看的博客可能不是最好的, \n\t但对我目前来说足够美了, 不过写一遍远远不够.\n2. 学到了巧妙地对 `uint8_t*`类型的指针(指向流数据缓冲区)转换成`uint16_t*`等指针类型, 进行解引用 得到原本的数据, 然后对\n\t `uint8_t*`类型的指针`+2`就可以跳过一个`uint16_t`, 虽然这些能够理解, 但实际应用这是第一次\n3. 对于如何更好的组织一个数据结构 有了更深的体会.\n4. 使用vector来存储剩余的包字节, 相比使用一个定长数组进行strcpy 方便了不少\n5. 使用erase擦除也是第一次实际应用\n6. 更好的使用指针\n\n定一下明天的任务吧, 试运行\n1. 定义游戏的json格式, 把所有的json都定义出来 √\n2. 游戏完成度达到能够正确解析包并分发到合理的部分即可 √\n3. 写一遍采坑博客-头文件互相引用 √\n4. 针对今天Git遇到的文件 在做研究下√\n5. 简单学习下jsoncpp的使用√\n\n## 七日 2020年2月7日10:14:53\n2020年2月7日10:14:53\n今天博客写的格外早, 主要是又遇到一个奇葩问题(其实是我自己使用有误)\n我昨天最后发现代码跑不起来, 就没有管, 今天看了下跑不起来是因为`未定义引用`\n好吧, 未定义引用, 我检查了一下发现不对啊, 我加上了\n`target_link_libraries(Guess -ljsoncpp network game)`\n我当时是这样写的, 结果就是报错`未定义引用`, 然后我把报错的部分另开一个项目放进去\n运行起来没问题?????.\n然后我把报错的代码放在我项目的main文件中, 结果原来的报错也消失了 main中的也没报错?????\n最后阴差阳错发现这个博客[初入职常见问题：gcc编译时对’xxxx’未定义的引用](https://blog.csdn.net/qq_33249383/article/details/88908218). 我发现其中的一段话\n```\n这个主要的原因是gcc编译的时候，各个文件依赖顺序的问题。\n在gcc编译的时候，如果文件a依赖于文件b，那么编译的时候必须把a放前面，b放后面。\n例如:在main.c中使用了pthread库相关函数，那么编译的时候必须是main.c在前，-lpthread在后。 gcc main.c -lpthread -o a.out 。\n```\n虽然使用的是cmake然后make 不确定编译器, 但我感觉应该试一试. 因为我的软件是编译`network.a`的时候报错,\n结果我改成了如下\n`target_link_libraries(Guess network game -ljsoncpp)`\n发现报错消失了......\n\n以前一直没有在意这里的顺序问题. 现在知道了问题所在 去搜索target_link_libraries顺序问题\n找到了一堆解释 哎....\n\n2020年2月7日18:10:20\n终于把头文件互相引用给搞明白了, 感觉这篇博客写的还可以吧, 就发到了[csdn上面](https://blog.csdn.net/qq_26790181/article/details/104213520),自己的博客上也会发的. 就先这样吧\n今天的第三项任务完成了, 概第四项任务了Git\n\n2020年2月7日22:17:41\n今天的任务完成了 还发现一个联系git的网站... 真的是纯偶然发现的[这个](https://learngitbranching.js.org/)\n大创那里今天看了下文档 找了找模板 还可以吧 明天的话\n\n1. 游戏把服务器端写完 一半\n2. 把找到的大创模板改到springboot上面去  后续再套\n3. 练习并搞懂两道中等算法题目\n4. 在有时间的话把牛客整理了\n\n## 八日九日 2020年2月9日18:04:35\n简单写下吧, 昨天 不小心挂彩了, 还好运气还好, 没有太大的伤, 不然特别时期真的难搞.\n不幸中的万幸\n\n今天一天都没写代码 或许明天会好一些把\n\n# 十日 \n2020年2月10日10:02:22\n今天问题不大了, 继续写游戏的服务器\n写完服务器后, 做算法题吧\n\n# 十四日\n昨天基本问题就不大了, 眼睛周围青了一圈成了大熊猫, 经过四天的休息 看东西倒是不流眼泪了.\n今天的话, 实际的学习方面有\n\n终于自己还是要找开源项目看看了, 不过今天2020年2月14日17:08:40头脑不是很清醒, 中午没有睡好. 看了个大概就没看了\n[nginx剖析](https://tengine.taobao.org/book/chapter_02.html)\n\n偶尔发现了一本书, 这不就是我想要看的吗!!!!!!, 准备看这本书 这本书从输入网址到网页返回都很详细的写了写\n![](https://pic2.zhimg.com/v2-1336c859990173751b77ad9eb4318602_r.jpg)\n\n# 十五日\n理论上大二寒假就要过完了. 昨天晚上想了很多\n\n先说一下游戏把: 感觉自己不喜欢玩手机游戏了, 手机游戏非肝即氪 自己没有时间去肝游戏, 肝游戏不会给你工作, 自己没有钱去氪金, 自己又非.抱着这种念头时间长了, 自己对游戏更加提不起兴趣了. 而我又想去做游戏, 一个不想玩游戏的人能做游戏吗? 虽说我的不想玩是在各种因素长时间影响下形成的.\n\n\n再说下我对编程吧: 怎么说呢, 我在大二上学期的上半学期之前, 都很喜欢写代码的, 我能在电脑前面坐上一整天. 后来我对代码提不起兴趣了. 原因的话昨天晚上整理了下.\n1. 目的不同了: 我在大二上学期的上半学期之前(包括大一整个学期)都是抱着解决某个问题去写软件的, 说起来是为自己写代码?首先就是我学的Javaweb为了解决校园网登录难的问题, 我用Java写一个客户端, 同时配上了后台和下载站(用的阿里云的OSS). 我记得的那段时间真的快乐. 后面我又为解决手动签到的问题, 做了个签到软件, 也是如此.------后来我学习的目的就是为了增进自己的知识(目的只有一个--进入大公司), 变成了为了学而学(之所以为了学而学是感觉时间真的有限, 我想在大三暑假能够实习, 我只有一年半的时间), 而不是之前, 通过做自己喜欢的东西不会了就去补一补. 长时间这样学习我大二上整个学期一个正经的项目都没有, 长时间为了学而学消磨了我的兴趣??\n2. 我发现我现在好像失去了对编程的乐趣, 现在写项目总想写出更优的结构, 总想写出大项目, 然而我的能力不足. 想实现和无法实现的思想一直持续着, 也是消磨的原因之一? 我现在在想我是不是期初就对linux服务器不感兴趣? 可我感觉当初自己确实想去的, 我想着游戏行业的人员兴趣基本相同, 能够一起做游戏,一边骂着策划脑洞一边做2333, 而不是做自己不喜欢的网站后端, 我发现目前自己都是一个人学习, 一个人做着, 何谈团队的乐趣?\n\n\n症状就如上了, 自己也得想想办法了.\n1. 首要任务找个人(找个团队)一起做游戏吧, 自己一个人的话, 说不上我向往的一起写代码的氛围\n2. 找到团队之后, 就能通过一边做游戏一边学习自己的不足了\n3. 我长时间的学习, 做不出自己满意的项目也是原因之一吧.\n4. 手机游戏的话, 暂时不去玩网游了. 我自己更适合单机? 找人做独立游戏?? emm不错\n\n# 十六日\n爆肝学习了一天3dmax , 现在是会基本的操作 能够完成一些简单的建模了.\n\n从B站找个那个课程也是很不错\n[3Dmax2018零基础入门教程（第一，二，三，四，五阶段）](https://www.bilibili.com/video/av18210293/)\n\n一天的事件我就从 P0看到了\tP51 过得很快, 但感觉掌握的还能接受\n\n-----\n|按键|功能|\n|---|---|\n|||\n|shift|绘制直线|\n|删除键|可以回退一次|\n|||\n|W|移动|\n|E|旋转|\n|R|缩放|\n|||\n|F3|线框显示模式|\n|F4|实体+线框限时模式|\n|||\n|Shift|按住可以复制|\n|||\n|Alt+T+A|阵列|\n|Alt+T+M|镜像|\n|Alt+A+对齐|\n|Shitf+I|间隔工具|\n|||\n|Ctrl+X|专家模式, 隐藏所有多余的东西 获得最大的空间|\n|Alt+X|半透明显示|\n|Ctrl+Shift+X|变换虚拟体显示切换 可以看到变换虚拟体的明显变化|\n|O|自适应降级|\n\n**编辑样条线->顶点**\n优化 在线上添加点\n焊接 连接两点\n自动焊接 两点在距离之内自动焊接\n\n**车削修改器**\n将二维图形 指定一个轴然后旋转 得到立体图形\n\n**可编辑多边形**\n*细分曲面*\n迭代次数2-3\n无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)\n*细分置换-经常使用置换网格WSM修改器*\n需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图\n*绘制变形-未学-用于雕刻地形*\n**倒角剖面和扫描的区别**\n1. 结合点不同\n2. 倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓\n3. 倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.\n\n------\n\n好了寒假也算是结束了\n\n哦对了 我还在做一个游戏 从YouTube上看到一个打砖块游戏.\n这只是开始, 因为我是做服务器的所以我要把游戏改成双人联机哒!!!!目前进展还不错\n\n我打算模仿一个知乎大佬在知乎更新下专栏? 貌似可以诶\n\n网上讲解服务器的不少 讲解客户端的不少  讲解一套的就少了\n\n好了博客整理下 寒假结束了","source":"_posts/假期学习记录-大二寒假.md","raw":"---\ntitle: 大二寒假学习记录\ndate: 2020-02-01 17:30:32\ncategories:\n  - 假期学习记录\n---\n\n现在是`2020年2月1日17:32:50` 寒假过半? 目前还不知道寒假什么时候开学. 为了自己能够前往心目中的公司, 学习是必不可少的.\n学习的同时 应该要注意总结, 防止一天或者一周下来白忙活\n我们寒假开始是一月九号 到我开始寒假学习的一月二十三号 这些天没有学习用来玩了, 好在后面拾了回来\n从二十三号到现在二月一号, 每天学习的长度和质量总算是在慢慢上升\n距离下一个寒假只剩下一年的时间了, 需要更加的努力, 为了大三暑假能够进入心中的公司 大三寒假的实习必不可少了. 加倍努力吧\n\n这篇博客的标题起初是`大二寒假学习记录`后来改成了`大二寒假及下学期学习记录`寒假的学习必不可少, 下学期更要抓紧时间了.\n\n# 二月\n## 一日2020年2月1日17:39:59\n\n前几天把博客从我自己的服务器迁移到了coding上, 方便以后我乱搞服务器, 现在服务器上没有重要的内容了\n至于实际的学习方面, 我开始整理我的博客[主要是这篇](https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/)这篇现在算告一段落了, 主要是把自己以前学过的用一用. 空洞的写下api\n理解不是很深刻.[这两天修改的这一篇](https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/). 第二篇自己缺少的东西很多, 由于当时学习到了后面实在是学不下去了.\n所以现在把后面的部分重新写了一下. 高级部分的线程和进程的部分 实在是太走马观花. 等我顺序学到了 再多写一些例子\n\n今天的话, 练习了下poll系统调用, 写了一个poll的demo, 然后是整理了下信号的部分, 信号这里整理的依然很少 平时用到的不多, 需要多加使用\n主要是定时器这里了 定时器把原来的内容删掉了 从新写目前只写完了socket定时\n\n接下来打算还是多写一些项目 多思考一些 等我整理完了高级部分 就准备去看开源项目?每次看开源项目都感觉自己差的太多, 不知道从哪里看起\n所以搭配着别人的笔记学习下看源码. 当然看源码之前还是要会大概的使用. 高级部分自然包括了libevent的使用部分\n\n跑去写项目了\n\n## 二日2020年2月2日18:03:23\n\n罪过罪过, 昨天晚上十一点半 玩了一把军团TD 结果玩到了十二点半 ..... 最后一点半才睡觉\n今天早上小十一点才起床.\n我依稀记得我八点被闹钟叫起来emm 然后想着定八点半的闹钟 再睡一会, 结果闹钟没定我就睡着了.\n\n起来后整理了整理吃了午饭, 就下午小一点了, 打开高级部分 学习`信号SIGALRM定时`\n\n代码量就400行 一直到我写今天的博客 才算完工\n\n**先写一下遇到的一个问题吧**\n首先表现出来的是`超时后 服务器没有断开连接`\n然后我去打断点, 发现不是定时器链表部分的问题. 是定时信号没有触发`epoll_wait`.\n这里我看了下代码, 发现定时器没有启动加上了`alarm(5)`, 我本意是理解了书上的代码 再去自己写, 结果还是理解的不深刻, 竟然丢了启动定时器的函数.\n然后我又运行了下`发现还是没有运行到`\n然后发现`epoll_wait 返回-1 设置EINTR`, 后来查阅了下说是被信号处理器中断, 思考可能是与IDE下断点有关??????\n最后发现自己没有把信号的管道添加到`epollfd`中再一细看发现丢了关于信号管道的四行代码...\n\n这个问题应该是很容易排查. 事后感觉应该这样思考\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/epoll%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.png)\n以后尽量总结正确的思考模式, 虽然不知道有没有用 但要试一试.\n\n**项目收获方面**\n虽然这个项目只有400多行代码, 但我自己是绝对写不出来的. 只能尽量总结书上代码的好处\n1. 首先肯定是使用alarm超时产生信号SIGALRM来触发回调函数 实现定时\n2. 信号回调函数, 没有直接去触发定时器tick函数, 而是通过一个管道传到了epollfd中, 然后从epollfd的函数中触发相关的if 再去调用tick函数\n```c++\nvoid timer_handler() //真正的生效部分\n{\n    timer_lst.tick();\n    alarm(TIMESLOT);\n}\nvoid sig_handler(int sig)\n{\n    int save_errno = errno;\n    int msg = sig;\n    send(pipefd[1], (char*)&msg, 1, 0); // pipefd[0]注册进了epoll中 接受到来的信号\n    errno = save_errno;\n}\n\nvoid addsig(int sig)// 信号添加\n{\n    struct sigaction sa{};\n    sa.sa_flags |= SA_RESTART;\n    sa.sa_handler = sig_handler;\n    sigfillset(&sa.sa_mask);\n    exit_if(sigaction(sig, &sa, nullptr) == -1, \"add sig error\");\n}\n\nchar signals[1024]; // 信号接收, 可能存在多个信号 所以用返回的字节数来逐个取出信号\nret = recv(sockfd, signals, sizeof(signals), 0); 取出后使用switch来分离信号\n```\n3. 将大部分常量 #define\n大概只能总结出这一些来了, 完整的代码我贴在github上吧\n\n## 五日 2020年2月6日09:16:23\n三和四号 基本都在玩FF14, 发现自己并不是玩游戏了, 感觉被FF14玩了, 就是那种感觉累了不想玩了, 但却离自己定的小目标远 然后坚持\nemm 其实感觉这个时候应该下游戏.\n想想自己这大学一年半玩过的游戏 血族我算是玩的时间最长的大概前前后后我玩了五年, 应该是上半年把 我弃坑了. 游戏后面太氪了, 不得不退游了.\n后面崩三啥的也玩过, 发现自己并不适合肝的游戏. 最近一个月入坑了fgo, 开始的几个星期还是玩的累了, 自己太肝了, 最近这几天感觉休闲了不少, \n心态也正常了, 所以暂且会玩一玩.\n\n主要还是后面这些吧, 我发现自己逐渐有了一个念头: 累了就去玩会游戏, 就去看会直播, 刷刷B站. 后来我感觉这些浪费时间就去搜索了一下\n**玩游戏算浪费时间吗**, 刚才去找了下. 没找到我之前看过的那篇. 结论就是为什么自己不是累了就去小睡一下, 或者看看书,再或者刷刷新的科技圈\n长长见识? 自己尝试了看书, 发现自己并不是太抗拒. 以后试试把.\n\n最后自己作为一个想开发游戏的人, 总感觉不玩游戏是不合适的, 但要玩的适度, 毕竟自己还有一年的时间就要找寒假实习, 为了自己的大三暑假进入大厂打下基础.\n平衡好才是上策.\n\n接下文, 我发现自己有点?(自信点把点去掉)好高骛远了, 好高骛远会消磨一个人的兴趣和信心. 最终决定不做什么大游戏, 不研究什么框架, 先用自己所会的写一个小游戏,\n一是为了试着重新拾起兴趣, 二是如果只学而不去写项目, 没有太大收获的\n\n昨天一天都是策划和编写一个游戏, 游戏逻辑十分的简单. 猜数字 初期的流程图我大概画了下, 姑且算作第一版吧 下面放出来, 我后面可以逐渐丰富这个东西 加上日志登录\n断线重连等等功能.感觉还是可以的~~ 尽管逻辑很简单.\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%B5%81%E7%A8%8B1.png)\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%911.png)\n\n听说在写代码前规划好, 可以更好地组织代码, 昨天尝试了下感觉还不错. 我在写代码前把游戏的流程图画了一下, 然后标上了哪里会有什么数据交互,\n之后我去写了数据包头格式\n**头部**\n\n| 偏移量 | 长度 | 含义\n| --- | --- | --- |\n| 0 | 4 | 封包总大小 |\n| 4 | 2 | 头部长度 |\n| 6 | 2 | 操作码 |\n\n**操作码**\n\n| 代码 | 含义 | 数据格式 |\n| --- | --- | --- |\n| 00 | 登录 | |\n| 01 | 桌位信息(服务器发送桌位列表) | [1000-0-4][1001-0-4] |\n| 02 | 桌位操作信息(客户端加入 退出桌位) | 1000 |\n| 03 | 服务器桌位操作信息反馈(加入退出成功1 加入退出失败0) | 1 |\n| 04 | 准备 | 无 |\n| 05 | 取消准备 | 无 |\n| 06 | 服务器广播桌位信息 | 4[11][10][00][00] (桌位总数, 有人1 准备1) |\n| A1 | 服务器广播游戏开始 | 空 |\n| A2 | 服务器下发轮到的客户端 | 空 |\n| A3 | 客户端发送猜测的数字 | 50 |\n| A4 | 服务器发送猜测数字反馈 (数据合理1, 数据非法0) | 1 |\n| A5 | 服务器广播游戏状态 | 50-0-75[A][B] (A玩家猜出50 当前范围 0到75 B玩家准备) |\n\n然后草拟了一下 用到的类 用到的数据结构 分几个类 怎么联系起来, 最终我才去写代码, 感觉比一边写\n一边想要好不少. 写的过程中也发现了一些问题\n1. `EPOLLRDHUP`这个绑定在listenfd还是newfd?? 如果是newfd还能理解下原理, listenfd就有点理解不了.(试了下, 是newfd)\n2. \n```c++\nFoo *a;\nFoos b[3];\nb[1] = *a;\n// 修改a不会影响b[1], 这个问题听到过, 自己真正试了试才发现如此\n```\n\n姑且昨天的就补上这些吧. 今天打算把游戏的服务器跑起来\n\n## 六日 2020年2月6日22:12:36\n忙忙碌碌的一天就又要结束了. 今天一天把剩下的一部分逻辑代码写了一部分. 主要是写自定义协议的序列化和反序列化. 起初打算\n用char* body 来存储, 按照上面定义的格式传输. 后来一想, 这样我就不就是在原地打转吗. 就去网上找了找相关的代码, 看看别人怎么写的\n\n主要是看的这一篇博客[手把手教你实现自定义的应用层协议](https://blog.csdn.net/ACb0y/article/details/61421006)\n看了之后收获不少. 收获总结在下面吧\n\n1. 两个头文件互相include\n\t这个是今天了解的最奇葩的一个问题, 如果两个头文件互相include 会出问题. 这个明天开一篇 采坑博客\n\t与此连带的还有class 前置声明, 再者可以到编译相关的问题\n2. 今天了解了一下CMAKE和MAKE的区别和联系, 总算知道了为啥好多安装的时候先cmake 再 make\n3. 还是关于CMAKE 稍微整理了点CMAKE的使用. 随用随整理, 目前不打算一次性整理太多\n4. Git操作不熟练. 我本地写好了代码文件, commit 然后从服务器pull了一个仅包含readme的仓库, 然后reset\n\t自己写的代码文件全没了, 只剩下README.md 还好之前整理过reflog, 明天也需要在整理下\n5. 安装了jsoncpp, 亿图图示等一些软件. 写了下关于字节对齐的问题. 亿图图示目前感觉挺不错\n\n代码方面的收获 主要就是看的那篇博客学到的.\n1. 首先就是学会了自定了协议 序列化和反序列化怎么写 代码更美. 虽然可能我看的博客可能不是最好的, \n\t但对我目前来说足够美了, 不过写一遍远远不够.\n2. 学到了巧妙地对 `uint8_t*`类型的指针(指向流数据缓冲区)转换成`uint16_t*`等指针类型, 进行解引用 得到原本的数据, 然后对\n\t `uint8_t*`类型的指针`+2`就可以跳过一个`uint16_t`, 虽然这些能够理解, 但实际应用这是第一次\n3. 对于如何更好的组织一个数据结构 有了更深的体会.\n4. 使用vector来存储剩余的包字节, 相比使用一个定长数组进行strcpy 方便了不少\n5. 使用erase擦除也是第一次实际应用\n6. 更好的使用指针\n\n定一下明天的任务吧, 试运行\n1. 定义游戏的json格式, 把所有的json都定义出来 √\n2. 游戏完成度达到能够正确解析包并分发到合理的部分即可 √\n3. 写一遍采坑博客-头文件互相引用 √\n4. 针对今天Git遇到的文件 在做研究下√\n5. 简单学习下jsoncpp的使用√\n\n## 七日 2020年2月7日10:14:53\n2020年2月7日10:14:53\n今天博客写的格外早, 主要是又遇到一个奇葩问题(其实是我自己使用有误)\n我昨天最后发现代码跑不起来, 就没有管, 今天看了下跑不起来是因为`未定义引用`\n好吧, 未定义引用, 我检查了一下发现不对啊, 我加上了\n`target_link_libraries(Guess -ljsoncpp network game)`\n我当时是这样写的, 结果就是报错`未定义引用`, 然后我把报错的部分另开一个项目放进去\n运行起来没问题?????.\n然后我把报错的代码放在我项目的main文件中, 结果原来的报错也消失了 main中的也没报错?????\n最后阴差阳错发现这个博客[初入职常见问题：gcc编译时对’xxxx’未定义的引用](https://blog.csdn.net/qq_33249383/article/details/88908218). 我发现其中的一段话\n```\n这个主要的原因是gcc编译的时候，各个文件依赖顺序的问题。\n在gcc编译的时候，如果文件a依赖于文件b，那么编译的时候必须把a放前面，b放后面。\n例如:在main.c中使用了pthread库相关函数，那么编译的时候必须是main.c在前，-lpthread在后。 gcc main.c -lpthread -o a.out 。\n```\n虽然使用的是cmake然后make 不确定编译器, 但我感觉应该试一试. 因为我的软件是编译`network.a`的时候报错,\n结果我改成了如下\n`target_link_libraries(Guess network game -ljsoncpp)`\n发现报错消失了......\n\n以前一直没有在意这里的顺序问题. 现在知道了问题所在 去搜索target_link_libraries顺序问题\n找到了一堆解释 哎....\n\n2020年2月7日18:10:20\n终于把头文件互相引用给搞明白了, 感觉这篇博客写的还可以吧, 就发到了[csdn上面](https://blog.csdn.net/qq_26790181/article/details/104213520),自己的博客上也会发的. 就先这样吧\n今天的第三项任务完成了, 概第四项任务了Git\n\n2020年2月7日22:17:41\n今天的任务完成了 还发现一个联系git的网站... 真的是纯偶然发现的[这个](https://learngitbranching.js.org/)\n大创那里今天看了下文档 找了找模板 还可以吧 明天的话\n\n1. 游戏把服务器端写完 一半\n2. 把找到的大创模板改到springboot上面去  后续再套\n3. 练习并搞懂两道中等算法题目\n4. 在有时间的话把牛客整理了\n\n## 八日九日 2020年2月9日18:04:35\n简单写下吧, 昨天 不小心挂彩了, 还好运气还好, 没有太大的伤, 不然特别时期真的难搞.\n不幸中的万幸\n\n今天一天都没写代码 或许明天会好一些把\n\n# 十日 \n2020年2月10日10:02:22\n今天问题不大了, 继续写游戏的服务器\n写完服务器后, 做算法题吧\n\n# 十四日\n昨天基本问题就不大了, 眼睛周围青了一圈成了大熊猫, 经过四天的休息 看东西倒是不流眼泪了.\n今天的话, 实际的学习方面有\n\n终于自己还是要找开源项目看看了, 不过今天2020年2月14日17:08:40头脑不是很清醒, 中午没有睡好. 看了个大概就没看了\n[nginx剖析](https://tengine.taobao.org/book/chapter_02.html)\n\n偶尔发现了一本书, 这不就是我想要看的吗!!!!!!, 准备看这本书 这本书从输入网址到网页返回都很详细的写了写\n![](https://pic2.zhimg.com/v2-1336c859990173751b77ad9eb4318602_r.jpg)\n\n# 十五日\n理论上大二寒假就要过完了. 昨天晚上想了很多\n\n先说一下游戏把: 感觉自己不喜欢玩手机游戏了, 手机游戏非肝即氪 自己没有时间去肝游戏, 肝游戏不会给你工作, 自己没有钱去氪金, 自己又非.抱着这种念头时间长了, 自己对游戏更加提不起兴趣了. 而我又想去做游戏, 一个不想玩游戏的人能做游戏吗? 虽说我的不想玩是在各种因素长时间影响下形成的.\n\n\n再说下我对编程吧: 怎么说呢, 我在大二上学期的上半学期之前, 都很喜欢写代码的, 我能在电脑前面坐上一整天. 后来我对代码提不起兴趣了. 原因的话昨天晚上整理了下.\n1. 目的不同了: 我在大二上学期的上半学期之前(包括大一整个学期)都是抱着解决某个问题去写软件的, 说起来是为自己写代码?首先就是我学的Javaweb为了解决校园网登录难的问题, 我用Java写一个客户端, 同时配上了后台和下载站(用的阿里云的OSS). 我记得的那段时间真的快乐. 后面我又为解决手动签到的问题, 做了个签到软件, 也是如此.------后来我学习的目的就是为了增进自己的知识(目的只有一个--进入大公司), 变成了为了学而学(之所以为了学而学是感觉时间真的有限, 我想在大三暑假能够实习, 我只有一年半的时间), 而不是之前, 通过做自己喜欢的东西不会了就去补一补. 长时间这样学习我大二上整个学期一个正经的项目都没有, 长时间为了学而学消磨了我的兴趣??\n2. 我发现我现在好像失去了对编程的乐趣, 现在写项目总想写出更优的结构, 总想写出大项目, 然而我的能力不足. 想实现和无法实现的思想一直持续着, 也是消磨的原因之一? 我现在在想我是不是期初就对linux服务器不感兴趣? 可我感觉当初自己确实想去的, 我想着游戏行业的人员兴趣基本相同, 能够一起做游戏,一边骂着策划脑洞一边做2333, 而不是做自己不喜欢的网站后端, 我发现目前自己都是一个人学习, 一个人做着, 何谈团队的乐趣?\n\n\n症状就如上了, 自己也得想想办法了.\n1. 首要任务找个人(找个团队)一起做游戏吧, 自己一个人的话, 说不上我向往的一起写代码的氛围\n2. 找到团队之后, 就能通过一边做游戏一边学习自己的不足了\n3. 我长时间的学习, 做不出自己满意的项目也是原因之一吧.\n4. 手机游戏的话, 暂时不去玩网游了. 我自己更适合单机? 找人做独立游戏?? emm不错\n\n# 十六日\n爆肝学习了一天3dmax , 现在是会基本的操作 能够完成一些简单的建模了.\n\n从B站找个那个课程也是很不错\n[3Dmax2018零基础入门教程（第一，二，三，四，五阶段）](https://www.bilibili.com/video/av18210293/)\n\n一天的事件我就从 P0看到了\tP51 过得很快, 但感觉掌握的还能接受\n\n-----\n|按键|功能|\n|---|---|\n|||\n|shift|绘制直线|\n|删除键|可以回退一次|\n|||\n|W|移动|\n|E|旋转|\n|R|缩放|\n|||\n|F3|线框显示模式|\n|F4|实体+线框限时模式|\n|||\n|Shift|按住可以复制|\n|||\n|Alt+T+A|阵列|\n|Alt+T+M|镜像|\n|Alt+A+对齐|\n|Shitf+I|间隔工具|\n|||\n|Ctrl+X|专家模式, 隐藏所有多余的东西 获得最大的空间|\n|Alt+X|半透明显示|\n|Ctrl+Shift+X|变换虚拟体显示切换 可以看到变换虚拟体的明显变化|\n|O|自适应降级|\n\n**编辑样条线->顶点**\n优化 在线上添加点\n焊接 连接两点\n自动焊接 两点在距离之内自动焊接\n\n**车削修改器**\n将二维图形 指定一个轴然后旋转 得到立体图形\n\n**可编辑多边形**\n*细分曲面*\n迭代次数2-3\n无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)\n*细分置换-经常使用置换网格WSM修改器*\n需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图\n*绘制变形-未学-用于雕刻地形*\n**倒角剖面和扫描的区别**\n1. 结合点不同\n2. 倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓\n3. 倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.\n\n------\n\n好了寒假也算是结束了\n\n哦对了 我还在做一个游戏 从YouTube上看到一个打砖块游戏.\n这只是开始, 因为我是做服务器的所以我要把游戏改成双人联机哒!!!!目前进展还不错\n\n我打算模仿一个知乎大佬在知乎更新下专栏? 貌似可以诶\n\n网上讲解服务器的不少 讲解客户端的不少  讲解一套的就少了\n\n好了博客整理下 寒假结束了","slug":"假期学习记录-大二寒假","published":1,"updated":"2020-12-05T02:39:01.888Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6i001hf8un48i872t9","content":"<p>现在是<code>2020年2月1日17:32:50</code> 寒假过半? 目前还不知道寒假什么时候开学. 为了自己能够前往心目中的公司, 学习是必不可少的.<br>学习的同时 应该要注意总结, 防止一天或者一周下来白忙活<br>我们寒假开始是一月九号 到我开始寒假学习的一月二十三号 这些天没有学习用来玩了, 好在后面拾了回来<br>从二十三号到现在二月一号, 每天学习的长度和质量总算是在慢慢上升<br>距离下一个寒假只剩下一年的时间了, 需要更加的努力, 为了大三暑假能够进入心中的公司 大三寒假的实习必不可少了. 加倍努力吧</p>\n<p>这篇博客的标题起初是<code>大二寒假学习记录</code>后来改成了<code>大二寒假及下学期学习记录</code>寒假的学习必不可少, 下学期更要抓紧时间了.</p>\n<h1 id=\"二月\"><a href=\"#二月\" class=\"headerlink\" title=\"二月\"></a>二月</h1><h2 id=\"一日2020年2月1日17-39-59\"><a href=\"#一日2020年2月1日17-39-59\" class=\"headerlink\" title=\"一日2020年2月1日17:39:59\"></a>一日2020年2月1日17:39:59</h2><p>前几天把博客从我自己的服务器迁移到了coding上, 方便以后我乱搞服务器, 现在服务器上没有重要的内容了<br>至于实际的学习方面, 我开始整理我的博客<a href=\"https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/\">主要是这篇</a>这篇现在算告一段落了, 主要是把自己以前学过的用一用. 空洞的写下api<br>理解不是很深刻.<a href=\"https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/\">这两天修改的这一篇</a>. 第二篇自己缺少的东西很多, 由于当时学习到了后面实在是学不下去了.<br>所以现在把后面的部分重新写了一下. 高级部分的线程和进程的部分 实在是太走马观花. 等我顺序学到了 再多写一些例子</p>\n<p>今天的话, 练习了下poll系统调用, 写了一个poll的demo, 然后是整理了下信号的部分, 信号这里整理的依然很少 平时用到的不多, 需要多加使用<br>主要是定时器这里了 定时器把原来的内容删掉了 从新写目前只写完了socket定时</p>\n<p>接下来打算还是多写一些项目 多思考一些 等我整理完了高级部分 就准备去看开源项目?每次看开源项目都感觉自己差的太多, 不知道从哪里看起<br>所以搭配着别人的笔记学习下看源码. 当然看源码之前还是要会大概的使用. 高级部分自然包括了libevent的使用部分</p>\n<p>跑去写项目了</p>\n<h2 id=\"二日2020年2月2日18-03-23\"><a href=\"#二日2020年2月2日18-03-23\" class=\"headerlink\" title=\"二日2020年2月2日18:03:23\"></a>二日2020年2月2日18:03:23</h2><p>罪过罪过, 昨天晚上十一点半 玩了一把军团TD 结果玩到了十二点半 ….. 最后一点半才睡觉<br>今天早上小十一点才起床.<br>我依稀记得我八点被闹钟叫起来emm 然后想着定八点半的闹钟 再睡一会, 结果闹钟没定我就睡着了.</p>\n<p>起来后整理了整理吃了午饭, 就下午小一点了, 打开高级部分 学习<code>信号SIGALRM定时</code></p>\n<p>代码量就400行 一直到我写今天的博客 才算完工</p>\n<p><strong>先写一下遇到的一个问题吧</strong><br>首先表现出来的是<code>超时后 服务器没有断开连接</code><br>然后我去打断点, 发现不是定时器链表部分的问题. 是定时信号没有触发<code>epoll_wait</code>.<br>这里我看了下代码, 发现定时器没有启动加上了<code>alarm(5)</code>, 我本意是理解了书上的代码 再去自己写, 结果还是理解的不深刻, 竟然丢了启动定时器的函数.<br>然后我又运行了下<code>发现还是没有运行到</code><br>然后发现<code>epoll_wait 返回-1 设置EINTR</code>, 后来查阅了下说是被信号处理器中断, 思考可能是与IDE下断点有关??????<br>最后发现自己没有把信号的管道添加到<code>epollfd</code>中再一细看发现丢了关于信号管道的四行代码…</p>\n<p>这个问题应该是很容易排查. 事后感觉应该这样思考<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/epoll%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.png\" alt=\"\"><br>以后尽量总结正确的思考模式, 虽然不知道有没有用 但要试一试.</p>\n<p><strong>项目收获方面</strong><br>虽然这个项目只有400多行代码, 但我自己是绝对写不出来的. 只能尽量总结书上代码的好处</p>\n<ol>\n<li>首先肯定是使用alarm超时产生信号SIGALRM来触发回调函数 实现定时</li>\n<li>信号回调函数, 没有直接去触发定时器tick函数, 而是通过一个管道传到了epollfd中, 然后从epollfd的函数中触发相关的if 再去调用tick函数<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">timer_handler</span><span class=\"params\">()</span> <span class=\"comment\">//真正的生效部分</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    timer_lst.tick();</span><br><span class=\"line\">    alarm(TIMESLOT);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sig_handler</span><span class=\"params\">(<span class=\"keyword\">int</span> sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> save_errno = errno;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> msg = sig;</span><br><span class=\"line\">    send(pipefd[<span class=\"number\">1</span>], (<span class=\"keyword\">char</span>*)&amp;msg, <span class=\"number\">1</span>, <span class=\"number\">0</span>); <span class=\"comment\">// pipefd[0]注册进了epoll中 接受到来的信号</span></span><br><span class=\"line\">    errno = save_errno;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addsig</span><span class=\"params\">(<span class=\"keyword\">int</span> sig)</span><span class=\"comment\">// 信号添加</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">sa</span>&#123;</span>&#125;;</span><br><span class=\"line\">    sa.sa_flags |= SA_RESTART;</span><br><span class=\"line\">    sa.sa_handler = sig_handler;</span><br><span class=\"line\">    sigfillset(&amp;sa.sa_mask);</span><br><span class=\"line\">    exit_if(sigaction(sig, &amp;sa, <span class=\"literal\">nullptr</span>) == <span class=\"number\">-1</span>, <span class=\"string\">\"add sig error\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> signals[<span class=\"number\">1024</span>]; <span class=\"comment\">// 信号接收, 可能存在多个信号 所以用返回的字节数来逐个取出信号</span></span><br><span class=\"line\">ret = recv(sockfd, signals, <span class=\"keyword\">sizeof</span>(signals), <span class=\"number\">0</span>); 取出后使用<span class=\"keyword\">switch</span>来分离信号</span><br></pre></td></tr></table></figure></li>\n<li>将大部分常量 #define<br>大概只能总结出这一些来了, 完整的代码我贴在github上吧</li>\n</ol>\n<h2 id=\"五日-2020年2月6日09-16-23\"><a href=\"#五日-2020年2月6日09-16-23\" class=\"headerlink\" title=\"五日 2020年2月6日09:16:23\"></a>五日 2020年2月6日09:16:23</h2><p>三和四号 基本都在玩FF14, 发现自己并不是玩游戏了, 感觉被FF14玩了, 就是那种感觉累了不想玩了, 但却离自己定的小目标远 然后坚持<br>emm 其实感觉这个时候应该下游戏.<br>想想自己这大学一年半玩过的游戏 血族我算是玩的时间最长的大概前前后后我玩了五年, 应该是上半年把 我弃坑了. 游戏后面太氪了, 不得不退游了.<br>后面崩三啥的也玩过, 发现自己并不适合肝的游戏. 最近一个月入坑了fgo, 开始的几个星期还是玩的累了, 自己太肝了, 最近这几天感觉休闲了不少,<br>心态也正常了, 所以暂且会玩一玩.</p>\n<p>主要还是后面这些吧, 我发现自己逐渐有了一个念头: 累了就去玩会游戏, 就去看会直播, 刷刷B站. 后来我感觉这些浪费时间就去搜索了一下<br><strong>玩游戏算浪费时间吗</strong>, 刚才去找了下. 没找到我之前看过的那篇. 结论就是为什么自己不是累了就去小睡一下, 或者看看书,再或者刷刷新的科技圈<br>长长见识? 自己尝试了看书, 发现自己并不是太抗拒. 以后试试把.</p>\n<p>最后自己作为一个想开发游戏的人, 总感觉不玩游戏是不合适的, 但要玩的适度, 毕竟自己还有一年的时间就要找寒假实习, 为了自己的大三暑假进入大厂打下基础.<br>平衡好才是上策.</p>\n<p>接下文, 我发现自己有点?(自信点把点去掉)好高骛远了, 好高骛远会消磨一个人的兴趣和信心. 最终决定不做什么大游戏, 不研究什么框架, 先用自己所会的写一个小游戏,<br>一是为了试着重新拾起兴趣, 二是如果只学而不去写项目, 没有太大收获的</p>\n<p>昨天一天都是策划和编写一个游戏, 游戏逻辑十分的简单. 猜数字 初期的流程图我大概画了下, 姑且算作第一版吧 下面放出来, 我后面可以逐渐丰富这个东西 加上日志登录<br>断线重连等等功能.感觉还是可以的~~ 尽管逻辑很简单.<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%B5%81%E7%A8%8B1.png\" alt=\"\"><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%911.png\" alt=\"\"></p>\n<p>听说在写代码前规划好, 可以更好地组织代码, 昨天尝试了下感觉还不错. 我在写代码前把游戏的流程图画了一下, 然后标上了哪里会有什么数据交互,<br>之后我去写了数据包头格式<br><strong>头部</strong></p>\n<table>\n<thead>\n<tr>\n<th>偏移量</th>\n<th>长度</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>4</td>\n<td>封包总大小</td>\n</tr>\n<tr>\n<td>4</td>\n<td>2</td>\n<td>头部长度</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2</td>\n<td>操作码</td>\n</tr>\n</tbody></table>\n<p><strong>操作码</strong></p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n<th>数据格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>00</td>\n<td>登录</td>\n<td></td>\n</tr>\n<tr>\n<td>01</td>\n<td>桌位信息(服务器发送桌位列表)</td>\n<td>[1000-0-4][1001-0-4]</td>\n</tr>\n<tr>\n<td>02</td>\n<td>桌位操作信息(客户端加入 退出桌位)</td>\n<td>1000</td>\n</tr>\n<tr>\n<td>03</td>\n<td>服务器桌位操作信息反馈(加入退出成功1 加入退出失败0)</td>\n<td>1</td>\n</tr>\n<tr>\n<td>04</td>\n<td>准备</td>\n<td>无</td>\n</tr>\n<tr>\n<td>05</td>\n<td>取消准备</td>\n<td>无</td>\n</tr>\n<tr>\n<td>06</td>\n<td>服务器广播桌位信息</td>\n<td>4[11][10][00][00] (桌位总数, 有人1 准备1)</td>\n</tr>\n<tr>\n<td>A1</td>\n<td>服务器广播游戏开始</td>\n<td>空</td>\n</tr>\n<tr>\n<td>A2</td>\n<td>服务器下发轮到的客户端</td>\n<td>空</td>\n</tr>\n<tr>\n<td>A3</td>\n<td>客户端发送猜测的数字</td>\n<td>50</td>\n</tr>\n<tr>\n<td>A4</td>\n<td>服务器发送猜测数字反馈 (数据合理1, 数据非法0)</td>\n<td>1</td>\n</tr>\n<tr>\n<td>A5</td>\n<td>服务器广播游戏状态</td>\n<td>50-0-75[A][B] (A玩家猜出50 当前范围 0到75 B玩家准备)</td>\n</tr>\n</tbody></table>\n<p>然后草拟了一下 用到的类 用到的数据结构 分几个类 怎么联系起来, 最终我才去写代码, 感觉比一边写<br>一边想要好不少. 写的过程中也发现了一些问题</p>\n<ol>\n<li><code>EPOLLRDHUP</code>这个绑定在listenfd还是newfd?? 如果是newfd还能理解下原理, listenfd就有点理解不了.(试了下, 是newfd)</li>\n<li><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo *a;</span><br><span class=\"line\">Foos b[<span class=\"number\">3</span>];</span><br><span class=\"line\">b[<span class=\"number\">1</span>] = *a;</span><br><span class=\"line\"><span class=\"comment\">// 修改a不会影响b[1], 这个问题听到过, 自己真正试了试才发现如此</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>姑且昨天的就补上这些吧. 今天打算把游戏的服务器跑起来</p>\n<h2 id=\"六日-2020年2月6日22-12-36\"><a href=\"#六日-2020年2月6日22-12-36\" class=\"headerlink\" title=\"六日 2020年2月6日22:12:36\"></a>六日 2020年2月6日22:12:36</h2><p>忙忙碌碌的一天就又要结束了. 今天一天把剩下的一部分逻辑代码写了一部分. 主要是写自定义协议的序列化和反序列化. 起初打算<br>用char* body 来存储, 按照上面定义的格式传输. 后来一想, 这样我就不就是在原地打转吗. 就去网上找了找相关的代码, 看看别人怎么写的</p>\n<p>主要是看的这一篇博客<a href=\"https://blog.csdn.net/ACb0y/article/details/61421006\" target=\"_blank\" rel=\"noopener\">手把手教你实现自定义的应用层协议</a><br>看了之后收获不少. 收获总结在下面吧</p>\n<ol>\n<li>两个头文件互相include<br> 这个是今天了解的最奇葩的一个问题, 如果两个头文件互相include 会出问题. 这个明天开一篇 采坑博客<br> 与此连带的还有class 前置声明, 再者可以到编译相关的问题</li>\n<li>今天了解了一下CMAKE和MAKE的区别和联系, 总算知道了为啥好多安装的时候先cmake 再 make</li>\n<li>还是关于CMAKE 稍微整理了点CMAKE的使用. 随用随整理, 目前不打算一次性整理太多</li>\n<li>Git操作不熟练. 我本地写好了代码文件, commit 然后从服务器pull了一个仅包含readme的仓库, 然后reset<br> 自己写的代码文件全没了, 只剩下README.md 还好之前整理过reflog, 明天也需要在整理下</li>\n<li>安装了jsoncpp, 亿图图示等一些软件. 写了下关于字节对齐的问题. 亿图图示目前感觉挺不错</li>\n</ol>\n<p>代码方面的收获 主要就是看的那篇博客学到的.</p>\n<ol>\n<li>首先就是学会了自定了协议 序列化和反序列化怎么写 代码更美. 虽然可能我看的博客可能不是最好的,<br> 但对我目前来说足够美了, 不过写一遍远远不够.</li>\n<li>学到了巧妙地对 <code>uint8_t*</code>类型的指针(指向流数据缓冲区)转换成<code>uint16_t*</code>等指针类型, 进行解引用 得到原本的数据, 然后对<br>  <code>uint8_t*</code>类型的指针<code>+2</code>就可以跳过一个<code>uint16_t</code>, 虽然这些能够理解, 但实际应用这是第一次</li>\n<li>对于如何更好的组织一个数据结构 有了更深的体会.</li>\n<li>使用vector来存储剩余的包字节, 相比使用一个定长数组进行strcpy 方便了不少</li>\n<li>使用erase擦除也是第一次实际应用</li>\n<li>更好的使用指针</li>\n</ol>\n<p>定一下明天的任务吧, 试运行</p>\n<ol>\n<li>定义游戏的json格式, 把所有的json都定义出来 √</li>\n<li>游戏完成度达到能够正确解析包并分发到合理的部分即可 √</li>\n<li>写一遍采坑博客-头文件互相引用 √</li>\n<li>针对今天Git遇到的文件 在做研究下√</li>\n<li>简单学习下jsoncpp的使用√</li>\n</ol>\n<h2 id=\"七日-2020年2月7日10-14-53\"><a href=\"#七日-2020年2月7日10-14-53\" class=\"headerlink\" title=\"七日 2020年2月7日10:14:53\"></a>七日 2020年2月7日10:14:53</h2><p>2020年2月7日10:14:53<br>今天博客写的格外早, 主要是又遇到一个奇葩问题(其实是我自己使用有误)<br>我昨天最后发现代码跑不起来, 就没有管, 今天看了下跑不起来是因为<code>未定义引用</code><br>好吧, 未定义引用, 我检查了一下发现不对啊, 我加上了<br><code>target_link_libraries(Guess -ljsoncpp network game)</code><br>我当时是这样写的, 结果就是报错<code>未定义引用</code>, 然后我把报错的部分另开一个项目放进去<br>运行起来没问题?????.<br>然后我把报错的代码放在我项目的main文件中, 结果原来的报错也消失了 main中的也没报错?????<br>最后阴差阳错发现这个博客<a href=\"https://blog.csdn.net/qq_33249383/article/details/88908218\" target=\"_blank\" rel=\"noopener\">初入职常见问题：gcc编译时对’xxxx’未定义的引用</a>. 我发现其中的一段话</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个主要的原因是gcc编译的时候，各个文件依赖顺序的问题。</span><br><span class=\"line\">在gcc编译的时候，如果文件a依赖于文件b，那么编译的时候必须把a放前面，b放后面。</span><br><span class=\"line\">例如:在main.c中使用了pthread库相关函数，那么编译的时候必须是main.c在前，-lpthread在后。 gcc main.c -lpthread -o a.out 。</span><br></pre></td></tr></table></figure>\n<p>虽然使用的是cmake然后make 不确定编译器, 但我感觉应该试一试. 因为我的软件是编译<code>network.a</code>的时候报错,<br>结果我改成了如下<br><code>target_link_libraries(Guess network game -ljsoncpp)</code><br>发现报错消失了……</p>\n<p>以前一直没有在意这里的顺序问题. 现在知道了问题所在 去搜索target_link_libraries顺序问题<br>找到了一堆解释 哎….</p>\n<p>2020年2月7日18:10:20<br>终于把头文件互相引用给搞明白了, 感觉这篇博客写的还可以吧, 就发到了<a href=\"https://blog.csdn.net/qq_26790181/article/details/104213520\" target=\"_blank\" rel=\"noopener\">csdn上面</a>,自己的博客上也会发的. 就先这样吧<br>今天的第三项任务完成了, 概第四项任务了Git</p>\n<p>2020年2月7日22:17:41<br>今天的任务完成了 还发现一个联系git的网站… 真的是纯偶然发现的<a href=\"https://learngitbranching.js.org/\" target=\"_blank\" rel=\"noopener\">这个</a><br>大创那里今天看了下文档 找了找模板 还可以吧 明天的话</p>\n<ol>\n<li>游戏把服务器端写完 一半</li>\n<li>把找到的大创模板改到springboot上面去  后续再套</li>\n<li>练习并搞懂两道中等算法题目</li>\n<li>在有时间的话把牛客整理了</li>\n</ol>\n<h2 id=\"八日九日-2020年2月9日18-04-35\"><a href=\"#八日九日-2020年2月9日18-04-35\" class=\"headerlink\" title=\"八日九日 2020年2月9日18:04:35\"></a>八日九日 2020年2月9日18:04:35</h2><p>简单写下吧, 昨天 不小心挂彩了, 还好运气还好, 没有太大的伤, 不然特别时期真的难搞.<br>不幸中的万幸</p>\n<p>今天一天都没写代码 或许明天会好一些把</p>\n<h1 id=\"十日\"><a href=\"#十日\" class=\"headerlink\" title=\"十日\"></a>十日</h1><p>2020年2月10日10:02:22<br>今天问题不大了, 继续写游戏的服务器<br>写完服务器后, 做算法题吧</p>\n<h1 id=\"十四日\"><a href=\"#十四日\" class=\"headerlink\" title=\"十四日\"></a>十四日</h1><p>昨天基本问题就不大了, 眼睛周围青了一圈成了大熊猫, 经过四天的休息 看东西倒是不流眼泪了.<br>今天的话, 实际的学习方面有</p>\n<p>终于自己还是要找开源项目看看了, 不过今天2020年2月14日17:08:40头脑不是很清醒, 中午没有睡好. 看了个大概就没看了<br><a href=\"https://tengine.taobao.org/book/chapter_02.html\" target=\"_blank\" rel=\"noopener\">nginx剖析</a></p>\n<p>偶尔发现了一本书, 这不就是我想要看的吗!!!!!!, 准备看这本书 这本书从输入网址到网页返回都很详细的写了写<br><img src=\"https://pic2.zhimg.com/v2-1336c859990173751b77ad9eb4318602_r.jpg\" alt=\"\"></p>\n<h1 id=\"十五日\"><a href=\"#十五日\" class=\"headerlink\" title=\"十五日\"></a>十五日</h1><p>理论上大二寒假就要过完了. 昨天晚上想了很多</p>\n<p>先说一下游戏把: 感觉自己不喜欢玩手机游戏了, 手机游戏非肝即氪 自己没有时间去肝游戏, 肝游戏不会给你工作, 自己没有钱去氪金, 自己又非.抱着这种念头时间长了, 自己对游戏更加提不起兴趣了. 而我又想去做游戏, 一个不想玩游戏的人能做游戏吗? 虽说我的不想玩是在各种因素长时间影响下形成的.</p>\n<p>再说下我对编程吧: 怎么说呢, 我在大二上学期的上半学期之前, 都很喜欢写代码的, 我能在电脑前面坐上一整天. 后来我对代码提不起兴趣了. 原因的话昨天晚上整理了下.</p>\n<ol>\n<li>目的不同了: 我在大二上学期的上半学期之前(包括大一整个学期)都是抱着解决某个问题去写软件的, 说起来是为自己写代码?首先就是我学的Javaweb为了解决校园网登录难的问题, 我用Java写一个客户端, 同时配上了后台和下载站(用的阿里云的OSS). 我记得的那段时间真的快乐. 后面我又为解决手动签到的问题, 做了个签到软件, 也是如此.——后来我学习的目的就是为了增进自己的知识(目的只有一个–进入大公司), 变成了为了学而学(之所以为了学而学是感觉时间真的有限, 我想在大三暑假能够实习, 我只有一年半的时间), 而不是之前, 通过做自己喜欢的东西不会了就去补一补. 长时间这样学习我大二上整个学期一个正经的项目都没有, 长时间为了学而学消磨了我的兴趣??</li>\n<li>我发现我现在好像失去了对编程的乐趣, 现在写项目总想写出更优的结构, 总想写出大项目, 然而我的能力不足. 想实现和无法实现的思想一直持续着, 也是消磨的原因之一? 我现在在想我是不是期初就对linux服务器不感兴趣? 可我感觉当初自己确实想去的, 我想着游戏行业的人员兴趣基本相同, 能够一起做游戏,一边骂着策划脑洞一边做2333, 而不是做自己不喜欢的网站后端, 我发现目前自己都是一个人学习, 一个人做着, 何谈团队的乐趣?</li>\n</ol>\n<p>症状就如上了, 自己也得想想办法了.</p>\n<ol>\n<li>首要任务找个人(找个团队)一起做游戏吧, 自己一个人的话, 说不上我向往的一起写代码的氛围</li>\n<li>找到团队之后, 就能通过一边做游戏一边学习自己的不足了</li>\n<li>我长时间的学习, 做不出自己满意的项目也是原因之一吧.</li>\n<li>手机游戏的话, 暂时不去玩网游了. 我自己更适合单机? 找人做独立游戏?? emm不错</li>\n</ol>\n<h1 id=\"十六日\"><a href=\"#十六日\" class=\"headerlink\" title=\"十六日\"></a>十六日</h1><p>爆肝学习了一天3dmax , 现在是会基本的操作 能够完成一些简单的建模了.</p>\n<p>从B站找个那个课程也是很不错<br><a href=\"https://www.bilibili.com/video/av18210293/\" target=\"_blank\" rel=\"noopener\">3Dmax2018零基础入门教程（第一，二，三，四，五阶段）</a></p>\n<p>一天的事件我就从 P0看到了    P51 过得很快, 但感觉掌握的还能接受</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>按键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shift</td>\n<td>绘制直线</td>\n</tr>\n<tr>\n<td>删除键</td>\n<td>可以回退一次</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>W</td>\n<td>移动</td>\n</tr>\n<tr>\n<td>E</td>\n<td>旋转</td>\n</tr>\n<tr>\n<td>R</td>\n<td>缩放</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>F3</td>\n<td>线框显示模式</td>\n</tr>\n<tr>\n<td>F4</td>\n<td>实体+线框限时模式</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Shift</td>\n<td>按住可以复制</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Alt+T+A</td>\n<td>阵列</td>\n</tr>\n<tr>\n<td>Alt+T+M</td>\n<td>镜像</td>\n</tr>\n<tr>\n<td>Alt+A+对齐</td>\n<td></td>\n</tr>\n<tr>\n<td>Shitf+I</td>\n<td>间隔工具</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Ctrl+X</td>\n<td>专家模式, 隐藏所有多余的东西 获得最大的空间</td>\n</tr>\n<tr>\n<td>Alt+X</td>\n<td>半透明显示</td>\n</tr>\n<tr>\n<td>Ctrl+Shift+X</td>\n<td>变换虚拟体显示切换 可以看到变换虚拟体的明显变化</td>\n</tr>\n<tr>\n<td>O</td>\n<td>自适应降级</td>\n</tr>\n</tbody></table>\n<p><strong>编辑样条线-&gt;顶点</strong><br>优化 在线上添加点<br>焊接 连接两点<br>自动焊接 两点在距离之内自动焊接</p>\n<p><strong>车削修改器</strong><br>将二维图形 指定一个轴然后旋转 得到立体图形</p>\n<p><strong>可编辑多边形</strong><br><em>细分曲面</em><br>迭代次数2-3<br>无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)<br><em>细分置换-经常使用置换网格WSM修改器</em><br>需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图<br><em>绘制变形-未学-用于雕刻地形</em><br><strong>倒角剖面和扫描的区别</strong></p>\n<ol>\n<li>结合点不同</li>\n<li>倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓</li>\n<li>倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.</li>\n</ol>\n<hr>\n<p>好了寒假也算是结束了</p>\n<p>哦对了 我还在做一个游戏 从YouTube上看到一个打砖块游戏.<br>这只是开始, 因为我是做服务器的所以我要把游戏改成双人联机哒!!!!目前进展还不错</p>\n<p>我打算模仿一个知乎大佬在知乎更新下专栏? 貌似可以诶</p>\n<p>网上讲解服务器的不少 讲解客户端的不少  讲解一套的就少了</p>\n<p>好了博客整理下 寒假结束了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>现在是<code>2020年2月1日17:32:50</code> 寒假过半? 目前还不知道寒假什么时候开学. 为了自己能够前往心目中的公司, 学习是必不可少的.<br>学习的同时 应该要注意总结, 防止一天或者一周下来白忙活<br>我们寒假开始是一月九号 到我开始寒假学习的一月二十三号 这些天没有学习用来玩了, 好在后面拾了回来<br>从二十三号到现在二月一号, 每天学习的长度和质量总算是在慢慢上升<br>距离下一个寒假只剩下一年的时间了, 需要更加的努力, 为了大三暑假能够进入心中的公司 大三寒假的实习必不可少了. 加倍努力吧</p>\n<p>这篇博客的标题起初是<code>大二寒假学习记录</code>后来改成了<code>大二寒假及下学期学习记录</code>寒假的学习必不可少, 下学期更要抓紧时间了.</p>\n<h1 id=\"二月\"><a href=\"#二月\" class=\"headerlink\" title=\"二月\"></a>二月</h1><h2 id=\"一日2020年2月1日17-39-59\"><a href=\"#一日2020年2月1日17-39-59\" class=\"headerlink\" title=\"一日2020年2月1日17:39:59\"></a>一日2020年2月1日17:39:59</h2><p>前几天把博客从我自己的服务器迁移到了coding上, 方便以后我乱搞服务器, 现在服务器上没有重要的内容了<br>至于实际的学习方面, 我开始整理我的博客<a href=\"https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/\">主要是这篇</a>这篇现在算告一段落了, 主要是把自己以前学过的用一用. 空洞的写下api<br>理解不是很深刻.<a href=\"https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/\">这两天修改的这一篇</a>. 第二篇自己缺少的东西很多, 由于当时学习到了后面实在是学不下去了.<br>所以现在把后面的部分重新写了一下. 高级部分的线程和进程的部分 实在是太走马观花. 等我顺序学到了 再多写一些例子</p>\n<p>今天的话, 练习了下poll系统调用, 写了一个poll的demo, 然后是整理了下信号的部分, 信号这里整理的依然很少 平时用到的不多, 需要多加使用<br>主要是定时器这里了 定时器把原来的内容删掉了 从新写目前只写完了socket定时</p>\n<p>接下来打算还是多写一些项目 多思考一些 等我整理完了高级部分 就准备去看开源项目?每次看开源项目都感觉自己差的太多, 不知道从哪里看起<br>所以搭配着别人的笔记学习下看源码. 当然看源码之前还是要会大概的使用. 高级部分自然包括了libevent的使用部分</p>\n<p>跑去写项目了</p>\n<h2 id=\"二日2020年2月2日18-03-23\"><a href=\"#二日2020年2月2日18-03-23\" class=\"headerlink\" title=\"二日2020年2月2日18:03:23\"></a>二日2020年2月2日18:03:23</h2><p>罪过罪过, 昨天晚上十一点半 玩了一把军团TD 结果玩到了十二点半 ….. 最后一点半才睡觉<br>今天早上小十一点才起床.<br>我依稀记得我八点被闹钟叫起来emm 然后想着定八点半的闹钟 再睡一会, 结果闹钟没定我就睡着了.</p>\n<p>起来后整理了整理吃了午饭, 就下午小一点了, 打开高级部分 学习<code>信号SIGALRM定时</code></p>\n<p>代码量就400行 一直到我写今天的博客 才算完工</p>\n<p><strong>先写一下遇到的一个问题吧</strong><br>首先表现出来的是<code>超时后 服务器没有断开连接</code><br>然后我去打断点, 发现不是定时器链表部分的问题. 是定时信号没有触发<code>epoll_wait</code>.<br>这里我看了下代码, 发现定时器没有启动加上了<code>alarm(5)</code>, 我本意是理解了书上的代码 再去自己写, 结果还是理解的不深刻, 竟然丢了启动定时器的函数.<br>然后我又运行了下<code>发现还是没有运行到</code><br>然后发现<code>epoll_wait 返回-1 设置EINTR</code>, 后来查阅了下说是被信号处理器中断, 思考可能是与IDE下断点有关??????<br>最后发现自己没有把信号的管道添加到<code>epollfd</code>中再一细看发现丢了关于信号管道的四行代码…</p>\n<p>这个问题应该是很容易排查. 事后感觉应该这样思考<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/epoll%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.png\" alt=\"\"><br>以后尽量总结正确的思考模式, 虽然不知道有没有用 但要试一试.</p>\n<p><strong>项目收获方面</strong><br>虽然这个项目只有400多行代码, 但我自己是绝对写不出来的. 只能尽量总结书上代码的好处</p>\n<ol>\n<li>首先肯定是使用alarm超时产生信号SIGALRM来触发回调函数 实现定时</li>\n<li>信号回调函数, 没有直接去触发定时器tick函数, 而是通过一个管道传到了epollfd中, 然后从epollfd的函数中触发相关的if 再去调用tick函数<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">timer_handler</span><span class=\"params\">()</span> <span class=\"comment\">//真正的生效部分</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    timer_lst.tick();</span><br><span class=\"line\">    alarm(TIMESLOT);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sig_handler</span><span class=\"params\">(<span class=\"keyword\">int</span> sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> save_errno = errno;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> msg = sig;</span><br><span class=\"line\">    send(pipefd[<span class=\"number\">1</span>], (<span class=\"keyword\">char</span>*)&amp;msg, <span class=\"number\">1</span>, <span class=\"number\">0</span>); <span class=\"comment\">// pipefd[0]注册进了epoll中 接受到来的信号</span></span><br><span class=\"line\">    errno = save_errno;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addsig</span><span class=\"params\">(<span class=\"keyword\">int</span> sig)</span><span class=\"comment\">// 信号添加</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">sa</span>&#123;</span>&#125;;</span><br><span class=\"line\">    sa.sa_flags |= SA_RESTART;</span><br><span class=\"line\">    sa.sa_handler = sig_handler;</span><br><span class=\"line\">    sigfillset(&amp;sa.sa_mask);</span><br><span class=\"line\">    exit_if(sigaction(sig, &amp;sa, <span class=\"literal\">nullptr</span>) == <span class=\"number\">-1</span>, <span class=\"string\">\"add sig error\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> signals[<span class=\"number\">1024</span>]; <span class=\"comment\">// 信号接收, 可能存在多个信号 所以用返回的字节数来逐个取出信号</span></span><br><span class=\"line\">ret = recv(sockfd, signals, <span class=\"keyword\">sizeof</span>(signals), <span class=\"number\">0</span>); 取出后使用<span class=\"keyword\">switch</span>来分离信号</span><br></pre></td></tr></table></figure></li>\n<li>将大部分常量 #define<br>大概只能总结出这一些来了, 完整的代码我贴在github上吧</li>\n</ol>\n<h2 id=\"五日-2020年2月6日09-16-23\"><a href=\"#五日-2020年2月6日09-16-23\" class=\"headerlink\" title=\"五日 2020年2月6日09:16:23\"></a>五日 2020年2月6日09:16:23</h2><p>三和四号 基本都在玩FF14, 发现自己并不是玩游戏了, 感觉被FF14玩了, 就是那种感觉累了不想玩了, 但却离自己定的小目标远 然后坚持<br>emm 其实感觉这个时候应该下游戏.<br>想想自己这大学一年半玩过的游戏 血族我算是玩的时间最长的大概前前后后我玩了五年, 应该是上半年把 我弃坑了. 游戏后面太氪了, 不得不退游了.<br>后面崩三啥的也玩过, 发现自己并不适合肝的游戏. 最近一个月入坑了fgo, 开始的几个星期还是玩的累了, 自己太肝了, 最近这几天感觉休闲了不少,<br>心态也正常了, 所以暂且会玩一玩.</p>\n<p>主要还是后面这些吧, 我发现自己逐渐有了一个念头: 累了就去玩会游戏, 就去看会直播, 刷刷B站. 后来我感觉这些浪费时间就去搜索了一下<br><strong>玩游戏算浪费时间吗</strong>, 刚才去找了下. 没找到我之前看过的那篇. 结论就是为什么自己不是累了就去小睡一下, 或者看看书,再或者刷刷新的科技圈<br>长长见识? 自己尝试了看书, 发现自己并不是太抗拒. 以后试试把.</p>\n<p>最后自己作为一个想开发游戏的人, 总感觉不玩游戏是不合适的, 但要玩的适度, 毕竟自己还有一年的时间就要找寒假实习, 为了自己的大三暑假进入大厂打下基础.<br>平衡好才是上策.</p>\n<p>接下文, 我发现自己有点?(自信点把点去掉)好高骛远了, 好高骛远会消磨一个人的兴趣和信心. 最终决定不做什么大游戏, 不研究什么框架, 先用自己所会的写一个小游戏,<br>一是为了试着重新拾起兴趣, 二是如果只学而不去写项目, 没有太大收获的</p>\n<p>昨天一天都是策划和编写一个游戏, 游戏逻辑十分的简单. 猜数字 初期的流程图我大概画了下, 姑且算作第一版吧 下面放出来, 我后面可以逐渐丰富这个东西 加上日志登录<br>断线重连等等功能.感觉还是可以的~~ 尽管逻辑很简单.<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%B5%81%E7%A8%8B1.png\" alt=\"\"><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%911.png\" alt=\"\"></p>\n<p>听说在写代码前规划好, 可以更好地组织代码, 昨天尝试了下感觉还不错. 我在写代码前把游戏的流程图画了一下, 然后标上了哪里会有什么数据交互,<br>之后我去写了数据包头格式<br><strong>头部</strong></p>\n<table>\n<thead>\n<tr>\n<th>偏移量</th>\n<th>长度</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>4</td>\n<td>封包总大小</td>\n</tr>\n<tr>\n<td>4</td>\n<td>2</td>\n<td>头部长度</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2</td>\n<td>操作码</td>\n</tr>\n</tbody></table>\n<p><strong>操作码</strong></p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n<th>数据格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>00</td>\n<td>登录</td>\n<td></td>\n</tr>\n<tr>\n<td>01</td>\n<td>桌位信息(服务器发送桌位列表)</td>\n<td>[1000-0-4][1001-0-4]</td>\n</tr>\n<tr>\n<td>02</td>\n<td>桌位操作信息(客户端加入 退出桌位)</td>\n<td>1000</td>\n</tr>\n<tr>\n<td>03</td>\n<td>服务器桌位操作信息反馈(加入退出成功1 加入退出失败0)</td>\n<td>1</td>\n</tr>\n<tr>\n<td>04</td>\n<td>准备</td>\n<td>无</td>\n</tr>\n<tr>\n<td>05</td>\n<td>取消准备</td>\n<td>无</td>\n</tr>\n<tr>\n<td>06</td>\n<td>服务器广播桌位信息</td>\n<td>4[11][10][00][00] (桌位总数, 有人1 准备1)</td>\n</tr>\n<tr>\n<td>A1</td>\n<td>服务器广播游戏开始</td>\n<td>空</td>\n</tr>\n<tr>\n<td>A2</td>\n<td>服务器下发轮到的客户端</td>\n<td>空</td>\n</tr>\n<tr>\n<td>A3</td>\n<td>客户端发送猜测的数字</td>\n<td>50</td>\n</tr>\n<tr>\n<td>A4</td>\n<td>服务器发送猜测数字反馈 (数据合理1, 数据非法0)</td>\n<td>1</td>\n</tr>\n<tr>\n<td>A5</td>\n<td>服务器广播游戏状态</td>\n<td>50-0-75[A][B] (A玩家猜出50 当前范围 0到75 B玩家准备)</td>\n</tr>\n</tbody></table>\n<p>然后草拟了一下 用到的类 用到的数据结构 分几个类 怎么联系起来, 最终我才去写代码, 感觉比一边写<br>一边想要好不少. 写的过程中也发现了一些问题</p>\n<ol>\n<li><code>EPOLLRDHUP</code>这个绑定在listenfd还是newfd?? 如果是newfd还能理解下原理, listenfd就有点理解不了.(试了下, 是newfd)</li>\n<li><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo *a;</span><br><span class=\"line\">Foos b[<span class=\"number\">3</span>];</span><br><span class=\"line\">b[<span class=\"number\">1</span>] = *a;</span><br><span class=\"line\"><span class=\"comment\">// 修改a不会影响b[1], 这个问题听到过, 自己真正试了试才发现如此</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>姑且昨天的就补上这些吧. 今天打算把游戏的服务器跑起来</p>\n<h2 id=\"六日-2020年2月6日22-12-36\"><a href=\"#六日-2020年2月6日22-12-36\" class=\"headerlink\" title=\"六日 2020年2月6日22:12:36\"></a>六日 2020年2月6日22:12:36</h2><p>忙忙碌碌的一天就又要结束了. 今天一天把剩下的一部分逻辑代码写了一部分. 主要是写自定义协议的序列化和反序列化. 起初打算<br>用char* body 来存储, 按照上面定义的格式传输. 后来一想, 这样我就不就是在原地打转吗. 就去网上找了找相关的代码, 看看别人怎么写的</p>\n<p>主要是看的这一篇博客<a href=\"https://blog.csdn.net/ACb0y/article/details/61421006\" target=\"_blank\" rel=\"noopener\">手把手教你实现自定义的应用层协议</a><br>看了之后收获不少. 收获总结在下面吧</p>\n<ol>\n<li>两个头文件互相include<br> 这个是今天了解的最奇葩的一个问题, 如果两个头文件互相include 会出问题. 这个明天开一篇 采坑博客<br> 与此连带的还有class 前置声明, 再者可以到编译相关的问题</li>\n<li>今天了解了一下CMAKE和MAKE的区别和联系, 总算知道了为啥好多安装的时候先cmake 再 make</li>\n<li>还是关于CMAKE 稍微整理了点CMAKE的使用. 随用随整理, 目前不打算一次性整理太多</li>\n<li>Git操作不熟练. 我本地写好了代码文件, commit 然后从服务器pull了一个仅包含readme的仓库, 然后reset<br> 自己写的代码文件全没了, 只剩下README.md 还好之前整理过reflog, 明天也需要在整理下</li>\n<li>安装了jsoncpp, 亿图图示等一些软件. 写了下关于字节对齐的问题. 亿图图示目前感觉挺不错</li>\n</ol>\n<p>代码方面的收获 主要就是看的那篇博客学到的.</p>\n<ol>\n<li>首先就是学会了自定了协议 序列化和反序列化怎么写 代码更美. 虽然可能我看的博客可能不是最好的,<br> 但对我目前来说足够美了, 不过写一遍远远不够.</li>\n<li>学到了巧妙地对 <code>uint8_t*</code>类型的指针(指向流数据缓冲区)转换成<code>uint16_t*</code>等指针类型, 进行解引用 得到原本的数据, 然后对<br>  <code>uint8_t*</code>类型的指针<code>+2</code>就可以跳过一个<code>uint16_t</code>, 虽然这些能够理解, 但实际应用这是第一次</li>\n<li>对于如何更好的组织一个数据结构 有了更深的体会.</li>\n<li>使用vector来存储剩余的包字节, 相比使用一个定长数组进行strcpy 方便了不少</li>\n<li>使用erase擦除也是第一次实际应用</li>\n<li>更好的使用指针</li>\n</ol>\n<p>定一下明天的任务吧, 试运行</p>\n<ol>\n<li>定义游戏的json格式, 把所有的json都定义出来 √</li>\n<li>游戏完成度达到能够正确解析包并分发到合理的部分即可 √</li>\n<li>写一遍采坑博客-头文件互相引用 √</li>\n<li>针对今天Git遇到的文件 在做研究下√</li>\n<li>简单学习下jsoncpp的使用√</li>\n</ol>\n<h2 id=\"七日-2020年2月7日10-14-53\"><a href=\"#七日-2020年2月7日10-14-53\" class=\"headerlink\" title=\"七日 2020年2月7日10:14:53\"></a>七日 2020年2月7日10:14:53</h2><p>2020年2月7日10:14:53<br>今天博客写的格外早, 主要是又遇到一个奇葩问题(其实是我自己使用有误)<br>我昨天最后发现代码跑不起来, 就没有管, 今天看了下跑不起来是因为<code>未定义引用</code><br>好吧, 未定义引用, 我检查了一下发现不对啊, 我加上了<br><code>target_link_libraries(Guess -ljsoncpp network game)</code><br>我当时是这样写的, 结果就是报错<code>未定义引用</code>, 然后我把报错的部分另开一个项目放进去<br>运行起来没问题?????.<br>然后我把报错的代码放在我项目的main文件中, 结果原来的报错也消失了 main中的也没报错?????<br>最后阴差阳错发现这个博客<a href=\"https://blog.csdn.net/qq_33249383/article/details/88908218\" target=\"_blank\" rel=\"noopener\">初入职常见问题：gcc编译时对’xxxx’未定义的引用</a>. 我发现其中的一段话</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个主要的原因是gcc编译的时候，各个文件依赖顺序的问题。</span><br><span class=\"line\">在gcc编译的时候，如果文件a依赖于文件b，那么编译的时候必须把a放前面，b放后面。</span><br><span class=\"line\">例如:在main.c中使用了pthread库相关函数，那么编译的时候必须是main.c在前，-lpthread在后。 gcc main.c -lpthread -o a.out 。</span><br></pre></td></tr></table></figure>\n<p>虽然使用的是cmake然后make 不确定编译器, 但我感觉应该试一试. 因为我的软件是编译<code>network.a</code>的时候报错,<br>结果我改成了如下<br><code>target_link_libraries(Guess network game -ljsoncpp)</code><br>发现报错消失了……</p>\n<p>以前一直没有在意这里的顺序问题. 现在知道了问题所在 去搜索target_link_libraries顺序问题<br>找到了一堆解释 哎….</p>\n<p>2020年2月7日18:10:20<br>终于把头文件互相引用给搞明白了, 感觉这篇博客写的还可以吧, 就发到了<a href=\"https://blog.csdn.net/qq_26790181/article/details/104213520\" target=\"_blank\" rel=\"noopener\">csdn上面</a>,自己的博客上也会发的. 就先这样吧<br>今天的第三项任务完成了, 概第四项任务了Git</p>\n<p>2020年2月7日22:17:41<br>今天的任务完成了 还发现一个联系git的网站… 真的是纯偶然发现的<a href=\"https://learngitbranching.js.org/\" target=\"_blank\" rel=\"noopener\">这个</a><br>大创那里今天看了下文档 找了找模板 还可以吧 明天的话</p>\n<ol>\n<li>游戏把服务器端写完 一半</li>\n<li>把找到的大创模板改到springboot上面去  后续再套</li>\n<li>练习并搞懂两道中等算法题目</li>\n<li>在有时间的话把牛客整理了</li>\n</ol>\n<h2 id=\"八日九日-2020年2月9日18-04-35\"><a href=\"#八日九日-2020年2月9日18-04-35\" class=\"headerlink\" title=\"八日九日 2020年2月9日18:04:35\"></a>八日九日 2020年2月9日18:04:35</h2><p>简单写下吧, 昨天 不小心挂彩了, 还好运气还好, 没有太大的伤, 不然特别时期真的难搞.<br>不幸中的万幸</p>\n<p>今天一天都没写代码 或许明天会好一些把</p>\n<h1 id=\"十日\"><a href=\"#十日\" class=\"headerlink\" title=\"十日\"></a>十日</h1><p>2020年2月10日10:02:22<br>今天问题不大了, 继续写游戏的服务器<br>写完服务器后, 做算法题吧</p>\n<h1 id=\"十四日\"><a href=\"#十四日\" class=\"headerlink\" title=\"十四日\"></a>十四日</h1><p>昨天基本问题就不大了, 眼睛周围青了一圈成了大熊猫, 经过四天的休息 看东西倒是不流眼泪了.<br>今天的话, 实际的学习方面有</p>\n<p>终于自己还是要找开源项目看看了, 不过今天2020年2月14日17:08:40头脑不是很清醒, 中午没有睡好. 看了个大概就没看了<br><a href=\"https://tengine.taobao.org/book/chapter_02.html\" target=\"_blank\" rel=\"noopener\">nginx剖析</a></p>\n<p>偶尔发现了一本书, 这不就是我想要看的吗!!!!!!, 准备看这本书 这本书从输入网址到网页返回都很详细的写了写<br><img src=\"https://pic2.zhimg.com/v2-1336c859990173751b77ad9eb4318602_r.jpg\" alt=\"\"></p>\n<h1 id=\"十五日\"><a href=\"#十五日\" class=\"headerlink\" title=\"十五日\"></a>十五日</h1><p>理论上大二寒假就要过完了. 昨天晚上想了很多</p>\n<p>先说一下游戏把: 感觉自己不喜欢玩手机游戏了, 手机游戏非肝即氪 自己没有时间去肝游戏, 肝游戏不会给你工作, 自己没有钱去氪金, 自己又非.抱着这种念头时间长了, 自己对游戏更加提不起兴趣了. 而我又想去做游戏, 一个不想玩游戏的人能做游戏吗? 虽说我的不想玩是在各种因素长时间影响下形成的.</p>\n<p>再说下我对编程吧: 怎么说呢, 我在大二上学期的上半学期之前, 都很喜欢写代码的, 我能在电脑前面坐上一整天. 后来我对代码提不起兴趣了. 原因的话昨天晚上整理了下.</p>\n<ol>\n<li>目的不同了: 我在大二上学期的上半学期之前(包括大一整个学期)都是抱着解决某个问题去写软件的, 说起来是为自己写代码?首先就是我学的Javaweb为了解决校园网登录难的问题, 我用Java写一个客户端, 同时配上了后台和下载站(用的阿里云的OSS). 我记得的那段时间真的快乐. 后面我又为解决手动签到的问题, 做了个签到软件, 也是如此.——后来我学习的目的就是为了增进自己的知识(目的只有一个–进入大公司), 变成了为了学而学(之所以为了学而学是感觉时间真的有限, 我想在大三暑假能够实习, 我只有一年半的时间), 而不是之前, 通过做自己喜欢的东西不会了就去补一补. 长时间这样学习我大二上整个学期一个正经的项目都没有, 长时间为了学而学消磨了我的兴趣??</li>\n<li>我发现我现在好像失去了对编程的乐趣, 现在写项目总想写出更优的结构, 总想写出大项目, 然而我的能力不足. 想实现和无法实现的思想一直持续着, 也是消磨的原因之一? 我现在在想我是不是期初就对linux服务器不感兴趣? 可我感觉当初自己确实想去的, 我想着游戏行业的人员兴趣基本相同, 能够一起做游戏,一边骂着策划脑洞一边做2333, 而不是做自己不喜欢的网站后端, 我发现目前自己都是一个人学习, 一个人做着, 何谈团队的乐趣?</li>\n</ol>\n<p>症状就如上了, 自己也得想想办法了.</p>\n<ol>\n<li>首要任务找个人(找个团队)一起做游戏吧, 自己一个人的话, 说不上我向往的一起写代码的氛围</li>\n<li>找到团队之后, 就能通过一边做游戏一边学习自己的不足了</li>\n<li>我长时间的学习, 做不出自己满意的项目也是原因之一吧.</li>\n<li>手机游戏的话, 暂时不去玩网游了. 我自己更适合单机? 找人做独立游戏?? emm不错</li>\n</ol>\n<h1 id=\"十六日\"><a href=\"#十六日\" class=\"headerlink\" title=\"十六日\"></a>十六日</h1><p>爆肝学习了一天3dmax , 现在是会基本的操作 能够完成一些简单的建模了.</p>\n<p>从B站找个那个课程也是很不错<br><a href=\"https://www.bilibili.com/video/av18210293/\" target=\"_blank\" rel=\"noopener\">3Dmax2018零基础入门教程（第一，二，三，四，五阶段）</a></p>\n<p>一天的事件我就从 P0看到了    P51 过得很快, 但感觉掌握的还能接受</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>按键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shift</td>\n<td>绘制直线</td>\n</tr>\n<tr>\n<td>删除键</td>\n<td>可以回退一次</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>W</td>\n<td>移动</td>\n</tr>\n<tr>\n<td>E</td>\n<td>旋转</td>\n</tr>\n<tr>\n<td>R</td>\n<td>缩放</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>F3</td>\n<td>线框显示模式</td>\n</tr>\n<tr>\n<td>F4</td>\n<td>实体+线框限时模式</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Shift</td>\n<td>按住可以复制</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Alt+T+A</td>\n<td>阵列</td>\n</tr>\n<tr>\n<td>Alt+T+M</td>\n<td>镜像</td>\n</tr>\n<tr>\n<td>Alt+A+对齐</td>\n<td></td>\n</tr>\n<tr>\n<td>Shitf+I</td>\n<td>间隔工具</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Ctrl+X</td>\n<td>专家模式, 隐藏所有多余的东西 获得最大的空间</td>\n</tr>\n<tr>\n<td>Alt+X</td>\n<td>半透明显示</td>\n</tr>\n<tr>\n<td>Ctrl+Shift+X</td>\n<td>变换虚拟体显示切换 可以看到变换虚拟体的明显变化</td>\n</tr>\n<tr>\n<td>O</td>\n<td>自适应降级</td>\n</tr>\n</tbody></table>\n<p><strong>编辑样条线-&gt;顶点</strong><br>优化 在线上添加点<br>焊接 连接两点<br>自动焊接 两点在距离之内自动焊接</p>\n<p><strong>车削修改器</strong><br>将二维图形 指定一个轴然后旋转 得到立体图形</p>\n<p><strong>可编辑多边形</strong><br><em>细分曲面</em><br>迭代次数2-3<br>无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)<br><em>细分置换-经常使用置换网格WSM修改器</em><br>需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图<br><em>绘制变形-未学-用于雕刻地形</em><br><strong>倒角剖面和扫描的区别</strong></p>\n<ol>\n<li>结合点不同</li>\n<li>倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓</li>\n<li>倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.</li>\n</ol>\n<hr>\n<p>好了寒假也算是结束了</p>\n<p>哦对了 我还在做一个游戏 从YouTube上看到一个打砖块游戏.<br>这只是开始, 因为我是做服务器的所以我要把游戏改成双人联机哒!!!!目前进展还不错</p>\n<p>我打算模仿一个知乎大佬在知乎更新下专栏? 貌似可以诶</p>\n<p>网上讲解服务器的不少 讲解客户端的不少  讲解一套的就少了</p>\n<p>好了博客整理下 寒假结束了</p>\n"},{"title":"蓝图与C++交互","date":"2020-10-11T12:31:22.000Z","_content":"\n# 蓝图Widget与C++代码交互-反射\n\n1. 创建UserWidget的C++子类 MyUserWidget\n```c++\n// 用于初始化\nvirtual bool Initialize() override;\n// 绑定到按钮的点击事件\nUFUNCTION() // 必须加不然会导致无反应 日志报错\nvoid ButtonLoginEvent();\n\n// 通过反射获取实例 需要名称保持一致\nUPROPERTY(Meta = (BindWidget))\nUButton* ButtonLogin;\nUPROPERTY(Meta = (BindWidget))\nUTextBlock* TextBlockUsername; // 一个文本框\n\nbool UMyUserWidget::Initialize()\n{\n    if (!Super::Initialize()) // 会报错提示不存在 无影响\n    {\n        return false;\n    }\n\n    // 进行点击函数绑定\n    ButtonLogin->OnClicked.__Internal_AddDynamic(this, &UMyUserWidget::ButtonLoginEvent, FName(\"ButtonLoginEvent\"));\n\n    return true;\n}\n\n// 获取并显示 文本框文字\nvoid UMyUserWidget::ButtonLoginEvent()\n{\n    if (GEngine)\n    {\n        FString Username = TextBlockUsername->GetText().ToString();\n\n        GEngine->AddOnScreenDebugMessage(-1, 20, FColor::Yellow, Username);\n    }\n}\n```\n2. 创建需要绑定的蓝图NewWidgetBlueprint\n3. 打开蓝图后点击File->Reparent Blueprint选择MyUserWidget作为父类\n4. 添加名为ButtonLogin的按钮和TextBlockUsername的文本框 用于反射\n5. 创建HUD的C++子类MyHud\n6. 创建MyHud的蓝图BP_MuHud\n7. 将MyHud的蓝图设置为 GameMode的HUDClass, 这样启动的时候就能创建MuHud蓝图的实例\n```c++\n// 从BP_MuHud中选择 NewWidgetBlueprint蓝图\nUPROPERTY(EditAnywhere, Category = \"UserWidget\")\nTSubclassOf<class UMUserWidget> WidgetClass;\n\n// 启动时创建蓝图实例并显示 设置输入方式\nvoid AMyHUD::BeginPlay()\n{\n    Super::BeginPlay();\n\n    UUserWidget* Widget = CreateWidget<UMyUserWidget>(GetWorld(), WidgetClass);\n    if (Widget != nullptr)\n    {\n        Widget->AddToViewport();\n    }\n\n    APlayerController* MyPlayerController = Cast<APlayerController>(UGameplayStatics::GetPlayerController(GetWorld(), 0));\n\n    // 输入只对UI\n    if (MyPlayerController != nullptr)\n    {\n        MyPlayerController->bShowMouseCursor = true;\n        FInputModeUIOnly InputMode;\n        MyPlayerController->SetInputMode(InputMode);\n    }\n}\n```","source":"_posts/UE4&3DMAX-蓝图C++交互.md","raw":"---\ntitle: 蓝图与C++交互\ndate: 2020-10-11 20:31:22\ncategories: \n- UE4&3DMAX\n---\n\n# 蓝图Widget与C++代码交互-反射\n\n1. 创建UserWidget的C++子类 MyUserWidget\n```c++\n// 用于初始化\nvirtual bool Initialize() override;\n// 绑定到按钮的点击事件\nUFUNCTION() // 必须加不然会导致无反应 日志报错\nvoid ButtonLoginEvent();\n\n// 通过反射获取实例 需要名称保持一致\nUPROPERTY(Meta = (BindWidget))\nUButton* ButtonLogin;\nUPROPERTY(Meta = (BindWidget))\nUTextBlock* TextBlockUsername; // 一个文本框\n\nbool UMyUserWidget::Initialize()\n{\n    if (!Super::Initialize()) // 会报错提示不存在 无影响\n    {\n        return false;\n    }\n\n    // 进行点击函数绑定\n    ButtonLogin->OnClicked.__Internal_AddDynamic(this, &UMyUserWidget::ButtonLoginEvent, FName(\"ButtonLoginEvent\"));\n\n    return true;\n}\n\n// 获取并显示 文本框文字\nvoid UMyUserWidget::ButtonLoginEvent()\n{\n    if (GEngine)\n    {\n        FString Username = TextBlockUsername->GetText().ToString();\n\n        GEngine->AddOnScreenDebugMessage(-1, 20, FColor::Yellow, Username);\n    }\n}\n```\n2. 创建需要绑定的蓝图NewWidgetBlueprint\n3. 打开蓝图后点击File->Reparent Blueprint选择MyUserWidget作为父类\n4. 添加名为ButtonLogin的按钮和TextBlockUsername的文本框 用于反射\n5. 创建HUD的C++子类MyHud\n6. 创建MyHud的蓝图BP_MuHud\n7. 将MyHud的蓝图设置为 GameMode的HUDClass, 这样启动的时候就能创建MuHud蓝图的实例\n```c++\n// 从BP_MuHud中选择 NewWidgetBlueprint蓝图\nUPROPERTY(EditAnywhere, Category = \"UserWidget\")\nTSubclassOf<class UMUserWidget> WidgetClass;\n\n// 启动时创建蓝图实例并显示 设置输入方式\nvoid AMyHUD::BeginPlay()\n{\n    Super::BeginPlay();\n\n    UUserWidget* Widget = CreateWidget<UMyUserWidget>(GetWorld(), WidgetClass);\n    if (Widget != nullptr)\n    {\n        Widget->AddToViewport();\n    }\n\n    APlayerController* MyPlayerController = Cast<APlayerController>(UGameplayStatics::GetPlayerController(GetWorld(), 0));\n\n    // 输入只对UI\n    if (MyPlayerController != nullptr)\n    {\n        MyPlayerController->bShowMouseCursor = true;\n        FInputModeUIOnly InputMode;\n        MyPlayerController->SetInputMode(InputMode);\n    }\n}\n```","slug":"UE4&3DMAX-蓝图C++交互","published":1,"updated":"2020-12-05T02:37:36.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6j001jf8un805r5mfa","content":"<h1 id=\"蓝图Widget与C-代码交互-反射\"><a href=\"#蓝图Widget与C-代码交互-反射\" class=\"headerlink\" title=\"蓝图Widget与C++代码交互-反射\"></a>蓝图Widget与C++代码交互-反射</h1><ol>\n<li>创建UserWidget的C++子类 MyUserWidget<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">Initialize</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 绑定到按钮的点击事件</span></span><br><span class=\"line\">UFUNCTION() <span class=\"comment\">// 必须加不然会导致无反应 日志报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ButtonLoginEvent</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过反射获取实例 需要名称保持一致</span></span><br><span class=\"line\">UPROPERTY(Meta = (BindWidget))</span><br><span class=\"line\">UButton* ButtonLogin;</span><br><span class=\"line\">UPROPERTY(Meta = (BindWidget))</span><br><span class=\"line\">UTextBlock* TextBlockUsername; <span class=\"comment\">// 一个文本框</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">UMyUserWidget::Initialize</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!Super::Initialize()) <span class=\"comment\">// 会报错提示不存在 无影响</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进行点击函数绑定</span></span><br><span class=\"line\">    ButtonLogin-&gt;OnClicked.__Internal_AddDynamic(<span class=\"keyword\">this</span>, &amp;UMyUserWidget::ButtonLoginEvent, FName(<span class=\"string\">\"ButtonLoginEvent\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取并显示 文本框文字</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UMyUserWidget::ButtonLoginEvent</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (GEngine)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        FString Username = TextBlockUsername-&gt;GetText().ToString();</span><br><span class=\"line\"></span><br><span class=\"line\">        GEngine-&gt;AddOnScreenDebugMessage(<span class=\"number\">-1</span>, <span class=\"number\">20</span>, FColor::Yellow, Username);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>创建需要绑定的蓝图NewWidgetBlueprint</li>\n<li>打开蓝图后点击File-&gt;Reparent Blueprint选择MyUserWidget作为父类</li>\n<li>添加名为ButtonLogin的按钮和TextBlockUsername的文本框 用于反射</li>\n<li>创建HUD的C++子类MyHud</li>\n<li>创建MyHud的蓝图BP_MuHud</li>\n<li>将MyHud的蓝图设置为 GameMode的HUDClass, 这样启动的时候就能创建MuHud蓝图的实例<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从BP_MuHud中选择 NewWidgetBlueprint蓝图</span></span><br><span class=\"line\">UPROPERTY(EditAnywhere, Category = <span class=\"string\">\"UserWidget\"</span>)</span><br><span class=\"line\">TSubclassOf&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UMUserWidget</span>&gt; <span class=\"title\">WidgetClass</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动时创建蓝图实例并显示 设置输入方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AMyHUD::BeginPlay</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Super::BeginPlay();</span><br><span class=\"line\"></span><br><span class=\"line\">    UUserWidget* Widget = CreateWidget&lt;UMyUserWidget&gt;(GetWorld(), WidgetClass);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Widget != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Widget-&gt;AddToViewport();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    APlayerController* MyPlayerController = Cast&lt;APlayerController&gt;(UGameplayStatics::GetPlayerController(GetWorld(), <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输入只对UI</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (MyPlayerController != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MyPlayerController-&gt;bShowMouseCursor = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        FInputModeUIOnly InputMode;</span><br><span class=\"line\">        MyPlayerController-&gt;SetInputMode(InputMode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"蓝图Widget与C-代码交互-反射\"><a href=\"#蓝图Widget与C-代码交互-反射\" class=\"headerlink\" title=\"蓝图Widget与C++代码交互-反射\"></a>蓝图Widget与C++代码交互-反射</h1><ol>\n<li>创建UserWidget的C++子类 MyUserWidget<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">bool</span> <span class=\"title\">Initialize</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 绑定到按钮的点击事件</span></span><br><span class=\"line\">UFUNCTION() <span class=\"comment\">// 必须加不然会导致无反应 日志报错</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ButtonLoginEvent</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过反射获取实例 需要名称保持一致</span></span><br><span class=\"line\">UPROPERTY(Meta = (BindWidget))</span><br><span class=\"line\">UButton* ButtonLogin;</span><br><span class=\"line\">UPROPERTY(Meta = (BindWidget))</span><br><span class=\"line\">UTextBlock* TextBlockUsername; <span class=\"comment\">// 一个文本框</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">UMyUserWidget::Initialize</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!Super::Initialize()) <span class=\"comment\">// 会报错提示不存在 无影响</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进行点击函数绑定</span></span><br><span class=\"line\">    ButtonLogin-&gt;OnClicked.__Internal_AddDynamic(<span class=\"keyword\">this</span>, &amp;UMyUserWidget::ButtonLoginEvent, FName(<span class=\"string\">\"ButtonLoginEvent\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取并显示 文本框文字</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">UMyUserWidget::ButtonLoginEvent</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (GEngine)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        FString Username = TextBlockUsername-&gt;GetText().ToString();</span><br><span class=\"line\"></span><br><span class=\"line\">        GEngine-&gt;AddOnScreenDebugMessage(<span class=\"number\">-1</span>, <span class=\"number\">20</span>, FColor::Yellow, Username);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>创建需要绑定的蓝图NewWidgetBlueprint</li>\n<li>打开蓝图后点击File-&gt;Reparent Blueprint选择MyUserWidget作为父类</li>\n<li>添加名为ButtonLogin的按钮和TextBlockUsername的文本框 用于反射</li>\n<li>创建HUD的C++子类MyHud</li>\n<li>创建MyHud的蓝图BP_MuHud</li>\n<li>将MyHud的蓝图设置为 GameMode的HUDClass, 这样启动的时候就能创建MuHud蓝图的实例<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从BP_MuHud中选择 NewWidgetBlueprint蓝图</span></span><br><span class=\"line\">UPROPERTY(EditAnywhere, Category = <span class=\"string\">\"UserWidget\"</span>)</span><br><span class=\"line\">TSubclassOf&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UMUserWidget</span>&gt; <span class=\"title\">WidgetClass</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动时创建蓝图实例并显示 设置输入方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AMyHUD::BeginPlay</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Super::BeginPlay();</span><br><span class=\"line\"></span><br><span class=\"line\">    UUserWidget* Widget = CreateWidget&lt;UMyUserWidget&gt;(GetWorld(), WidgetClass);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Widget != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Widget-&gt;AddToViewport();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    APlayerController* MyPlayerController = Cast&lt;APlayerController&gt;(UGameplayStatics::GetPlayerController(GetWorld(), <span class=\"number\">0</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输入只对UI</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (MyPlayerController != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MyPlayerController-&gt;bShowMouseCursor = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        FInputModeUIOnly InputMode;</span><br><span class=\"line\">        MyPlayerController-&gt;SetInputMode(InputMode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"大二暑假学习规划与记录","date":"2020-07-04T14:08:32.000Z","_content":"\n# 规划\n\n**2020年7月4日22:09:19**\nC++Primer从头到尾看一遍 做习题.  16章+3章.\n两天一章, 力求看透, 看足.  整理笔记.\n\n**2020年7月4日22:11:54**\n微信公众号运营, 整理自己发过的博客.\n\n\n**2020年7月4日22:11:59**\n算法学习, 较快的看完数据结构与算法. 奈何大一下没有好好学.  欠的总归要还\nhttps://next.xuetangx.com/learn/THU08091000384/THU08091000384/1516243/article/1387079\n\nhttps://next.xuetangx.com/learn/THU08091002048/THU08091002048/1515966/article/1373713\n\n\n**2020年7月4日22:26:56**\n晚上看操作系统\nhttps://www.bilibili.com/video/BV1iW411d7hd\n\n\n大概时间规划大概如下.  上午C++基础或与之相关 下午算法 晚上操作系统或与之相关. 具体要等暑假开始实行调整.  最后一个暑假,~~彼岸鱼你可长点心吧~~\n\n\n**2020年7月14日23:52:20**\n留校有点麻烦, 哎.  尽全力想法留校吧.\n\n学习具体的时间安排.\n\n\n**2020年7月17日15:31:42**\n激动人心的一刻!!! 留校申请过了, 感谢老师的帮助. 我还有什么理由不更好好利用暑假呢??\n\n算法最终选择了算法四教材\n\n\n# 2020年7月27日 - 2020年8月2日\n\n\n**2020年7月30日00:31:57**\n没想到第一次记录都是这个时间点了.....  \n原因是使用了更高级的方式... 记录了自己每个时间段干了什么emm\n\n这里用来写总结吧, 最终每个星期插一张图片=, =\n\n\n**2020年7月30日10:11:52**\n\n详细了解并使用exec系列函数\n","source":"_posts/假期学习记录-大二暑假.md","raw":"---\ntitle: 大二暑假学习规划与记录\ndate: 2020-07-04 22:08:32\ncategories:\n  - 假期学习记录\n---\n\n# 规划\n\n**2020年7月4日22:09:19**\nC++Primer从头到尾看一遍 做习题.  16章+3章.\n两天一章, 力求看透, 看足.  整理笔记.\n\n**2020年7月4日22:11:54**\n微信公众号运营, 整理自己发过的博客.\n\n\n**2020年7月4日22:11:59**\n算法学习, 较快的看完数据结构与算法. 奈何大一下没有好好学.  欠的总归要还\nhttps://next.xuetangx.com/learn/THU08091000384/THU08091000384/1516243/article/1387079\n\nhttps://next.xuetangx.com/learn/THU08091002048/THU08091002048/1515966/article/1373713\n\n\n**2020年7月4日22:26:56**\n晚上看操作系统\nhttps://www.bilibili.com/video/BV1iW411d7hd\n\n\n大概时间规划大概如下.  上午C++基础或与之相关 下午算法 晚上操作系统或与之相关. 具体要等暑假开始实行调整.  最后一个暑假,~~彼岸鱼你可长点心吧~~\n\n\n**2020年7月14日23:52:20**\n留校有点麻烦, 哎.  尽全力想法留校吧.\n\n学习具体的时间安排.\n\n\n**2020年7月17日15:31:42**\n激动人心的一刻!!! 留校申请过了, 感谢老师的帮助. 我还有什么理由不更好好利用暑假呢??\n\n算法最终选择了算法四教材\n\n\n# 2020年7月27日 - 2020年8月2日\n\n\n**2020年7月30日00:31:57**\n没想到第一次记录都是这个时间点了.....  \n原因是使用了更高级的方式... 记录了自己每个时间段干了什么emm\n\n这里用来写总结吧, 最终每个星期插一张图片=, =\n\n\n**2020年7月30日10:11:52**\n\n详细了解并使用exec系列函数\n","slug":"假期学习记录-大二暑假","published":1,"updated":"2020-12-05T02:39:01.888Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6k001nf8un7yigfpn2","content":"<h1 id=\"规划\"><a href=\"#规划\" class=\"headerlink\" title=\"规划\"></a>规划</h1><p><strong>2020年7月4日22:09:19</strong><br>C++Primer从头到尾看一遍 做习题.  16章+3章.<br>两天一章, 力求看透, 看足.  整理笔记.</p>\n<p><strong>2020年7月4日22:11:54</strong><br>微信公众号运营, 整理自己发过的博客.</p>\n<p><strong>2020年7月4日22:11:59</strong><br>算法学习, 较快的看完数据结构与算法. 奈何大一下没有好好学.  欠的总归要还<br><a href=\"https://next.xuetangx.com/learn/THU08091000384/THU08091000384/1516243/article/1387079\" target=\"_blank\" rel=\"noopener\">https://next.xuetangx.com/learn/THU08091000384/THU08091000384/1516243/article/1387079</a></p>\n<p><a href=\"https://next.xuetangx.com/learn/THU08091002048/THU08091002048/1515966/article/1373713\" target=\"_blank\" rel=\"noopener\">https://next.xuetangx.com/learn/THU08091002048/THU08091002048/1515966/article/1373713</a></p>\n<p><strong>2020年7月4日22:26:56</strong><br>晚上看操作系统<br><a href=\"https://www.bilibili.com/video/BV1iW411d7hd\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1iW411d7hd</a></p>\n<p>大概时间规划大概如下.  上午C++基础或与之相关 下午算法 晚上操作系统或与之相关. 具体要等暑假开始实行调整.  最后一个暑假,<del>彼岸鱼你可长点心吧</del></p>\n<p><strong>2020年7月14日23:52:20</strong><br>留校有点麻烦, 哎.  尽全力想法留校吧.</p>\n<p>学习具体的时间安排.</p>\n<p><strong>2020年7月17日15:31:42</strong><br>激动人心的一刻!!! 留校申请过了, 感谢老师的帮助. 我还有什么理由不更好好利用暑假呢??</p>\n<p>算法最终选择了算法四教材</p>\n<h1 id=\"2020年7月27日-2020年8月2日\"><a href=\"#2020年7月27日-2020年8月2日\" class=\"headerlink\" title=\"2020年7月27日 - 2020年8月2日\"></a>2020年7月27日 - 2020年8月2日</h1><p><strong>2020年7月30日00:31:57</strong><br>没想到第一次记录都是这个时间点了…..<br>原因是使用了更高级的方式… 记录了自己每个时间段干了什么emm</p>\n<p>这里用来写总结吧, 最终每个星期插一张图片=, =</p>\n<p><strong>2020年7月30日10:11:52</strong></p>\n<p>详细了解并使用exec系列函数</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"规划\"><a href=\"#规划\" class=\"headerlink\" title=\"规划\"></a>规划</h1><p><strong>2020年7月4日22:09:19</strong><br>C++Primer从头到尾看一遍 做习题.  16章+3章.<br>两天一章, 力求看透, 看足.  整理笔记.</p>\n<p><strong>2020年7月4日22:11:54</strong><br>微信公众号运营, 整理自己发过的博客.</p>\n<p><strong>2020年7月4日22:11:59</strong><br>算法学习, 较快的看完数据结构与算法. 奈何大一下没有好好学.  欠的总归要还<br><a href=\"https://next.xuetangx.com/learn/THU08091000384/THU08091000384/1516243/article/1387079\" target=\"_blank\" rel=\"noopener\">https://next.xuetangx.com/learn/THU08091000384/THU08091000384/1516243/article/1387079</a></p>\n<p><a href=\"https://next.xuetangx.com/learn/THU08091002048/THU08091002048/1515966/article/1373713\" target=\"_blank\" rel=\"noopener\">https://next.xuetangx.com/learn/THU08091002048/THU08091002048/1515966/article/1373713</a></p>\n<p><strong>2020年7月4日22:26:56</strong><br>晚上看操作系统<br><a href=\"https://www.bilibili.com/video/BV1iW411d7hd\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1iW411d7hd</a></p>\n<p>大概时间规划大概如下.  上午C++基础或与之相关 下午算法 晚上操作系统或与之相关. 具体要等暑假开始实行调整.  最后一个暑假,<del>彼岸鱼你可长点心吧</del></p>\n<p><strong>2020年7月14日23:52:20</strong><br>留校有点麻烦, 哎.  尽全力想法留校吧.</p>\n<p>学习具体的时间安排.</p>\n<p><strong>2020年7月17日15:31:42</strong><br>激动人心的一刻!!! 留校申请过了, 感谢老师的帮助. 我还有什么理由不更好好利用暑假呢??</p>\n<p>算法最终选择了算法四教材</p>\n<h1 id=\"2020年7月27日-2020年8月2日\"><a href=\"#2020年7月27日-2020年8月2日\" class=\"headerlink\" title=\"2020年7月27日 - 2020年8月2日\"></a>2020年7月27日 - 2020年8月2日</h1><p><strong>2020年7月30日00:31:57</strong><br>没想到第一次记录都是这个时间点了…..<br>原因是使用了更高级的方式… 记录了自己每个时间段干了什么emm</p>\n<p>这里用来写总结吧, 最终每个星期插一张图片=, =</p>\n<p><strong>2020年7月30日10:11:52</strong></p>\n<p>详细了解并使用exec系列函数</p>\n"},{"title":"小方说知识星球","date":"2020-06-16T11:29:20.000Z","_content":"\n这里并不做过多的记录, 记录一些tips吧\n\nlsof 能用做文件删除恢复. 仅限于文件虽然被删除但依然被某个进程打开.\n\n\nbind函数\n地址可以指定 INADDR_ANY\n那么端口呢?  测试了下如果端口为0确实是 bind到了随机端口\n\nbind到一个已经bind的端口会出错. 然而如果端口为0 随机的端口则没有被bind过\n\n客户端connect前调用bind能够以指定端口号连接, 这个在高性能服务器见过 不过一直没有用过\n\n异步connect? 非阻塞connect\n\nconnect尝试次数? 尝试间隔? \n\n| 函数名称 | 返回值 | 阻塞     | 非阻塞                                                                         |\n| -------- | ------ | -------- | ------------------------------------------------------------------------------ |\n| recv     | -1     | 出错     | 判断是否为EWOULDBLOCK(数据已经收完, ET模式收完数据的标志) 或者 EINTR(信号中断) |\n| recv     | 0      | 对端关闭 | 对端关闭                                                                       |\n| send     | -1     | 出错     | EWOULDBLOCK(数据无法继续发出) EAGAIN                                           |\n\nLT 想收多少收多少 收不完就提醒\nET 爱收不收 过了这村没这店\n\n\n老大让你开发一个邮件服务器, 大多数人像Springboot使用者. 第一时间就会去找库\n然而大多数HTTP协议实现都比较简单, 在自己公司所用框架的网络基础上, 很简单就能写出.8\n\n2020年7月17日20:30:06\n理论->常用Api->知晓如何组织底层Api\n网络编程重难点解析直播录像及课件, 终于看完了.","source":"_posts/假期学习记录-小方说知识星球.md","raw":"---\ntitle: 小方说知识星球\ndate: 2020-06-16 19:29:20\ncategories: \n- 假期学习记录\ntags:\n- 肉疼\n- 小方说\n---\n\n这里并不做过多的记录, 记录一些tips吧\n\nlsof 能用做文件删除恢复. 仅限于文件虽然被删除但依然被某个进程打开.\n\n\nbind函数\n地址可以指定 INADDR_ANY\n那么端口呢?  测试了下如果端口为0确实是 bind到了随机端口\n\nbind到一个已经bind的端口会出错. 然而如果端口为0 随机的端口则没有被bind过\n\n客户端connect前调用bind能够以指定端口号连接, 这个在高性能服务器见过 不过一直没有用过\n\n异步connect? 非阻塞connect\n\nconnect尝试次数? 尝试间隔? \n\n| 函数名称 | 返回值 | 阻塞     | 非阻塞                                                                         |\n| -------- | ------ | -------- | ------------------------------------------------------------------------------ |\n| recv     | -1     | 出错     | 判断是否为EWOULDBLOCK(数据已经收完, ET模式收完数据的标志) 或者 EINTR(信号中断) |\n| recv     | 0      | 对端关闭 | 对端关闭                                                                       |\n| send     | -1     | 出错     | EWOULDBLOCK(数据无法继续发出) EAGAIN                                           |\n\nLT 想收多少收多少 收不完就提醒\nET 爱收不收 过了这村没这店\n\n\n老大让你开发一个邮件服务器, 大多数人像Springboot使用者. 第一时间就会去找库\n然而大多数HTTP协议实现都比较简单, 在自己公司所用框架的网络基础上, 很简单就能写出.8\n\n2020年7月17日20:30:06\n理论->常用Api->知晓如何组织底层Api\n网络编程重难点解析直播录像及课件, 终于看完了.","slug":"假期学习记录-小方说知识星球","published":1,"updated":"2020-12-05T02:38:57.534Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6l001qf8und9tzgsk4","content":"<p>这里并不做过多的记录, 记录一些tips吧</p>\n<p>lsof 能用做文件删除恢复. 仅限于文件虽然被删除但依然被某个进程打开.</p>\n<p>bind函数<br>地址可以指定 INADDR_ANY<br>那么端口呢?  测试了下如果端口为0确实是 bind到了随机端口</p>\n<p>bind到一个已经bind的端口会出错. 然而如果端口为0 随机的端口则没有被bind过</p>\n<p>客户端connect前调用bind能够以指定端口号连接, 这个在高性能服务器见过 不过一直没有用过</p>\n<p>异步connect? 非阻塞connect</p>\n<p>connect尝试次数? 尝试间隔? </p>\n<table>\n<thead>\n<tr>\n<th>函数名称</th>\n<th>返回值</th>\n<th>阻塞</th>\n<th>非阻塞</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>recv</td>\n<td>-1</td>\n<td>出错</td>\n<td>判断是否为EWOULDBLOCK(数据已经收完, ET模式收完数据的标志) 或者 EINTR(信号中断)</td>\n</tr>\n<tr>\n<td>recv</td>\n<td>0</td>\n<td>对端关闭</td>\n<td>对端关闭</td>\n</tr>\n<tr>\n<td>send</td>\n<td>-1</td>\n<td>出错</td>\n<td>EWOULDBLOCK(数据无法继续发出) EAGAIN</td>\n</tr>\n</tbody></table>\n<p>LT 想收多少收多少 收不完就提醒<br>ET 爱收不收 过了这村没这店</p>\n<p>老大让你开发一个邮件服务器, 大多数人像Springboot使用者. 第一时间就会去找库<br>然而大多数HTTP协议实现都比较简单, 在自己公司所用框架的网络基础上, 很简单就能写出.8</p>\n<p>2020年7月17日20:30:06<br>理论-&gt;常用Api-&gt;知晓如何组织底层Api<br>网络编程重难点解析直播录像及课件, 终于看完了.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这里并不做过多的记录, 记录一些tips吧</p>\n<p>lsof 能用做文件删除恢复. 仅限于文件虽然被删除但依然被某个进程打开.</p>\n<p>bind函数<br>地址可以指定 INADDR_ANY<br>那么端口呢?  测试了下如果端口为0确实是 bind到了随机端口</p>\n<p>bind到一个已经bind的端口会出错. 然而如果端口为0 随机的端口则没有被bind过</p>\n<p>客户端connect前调用bind能够以指定端口号连接, 这个在高性能服务器见过 不过一直没有用过</p>\n<p>异步connect? 非阻塞connect</p>\n<p>connect尝试次数? 尝试间隔? </p>\n<table>\n<thead>\n<tr>\n<th>函数名称</th>\n<th>返回值</th>\n<th>阻塞</th>\n<th>非阻塞</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>recv</td>\n<td>-1</td>\n<td>出错</td>\n<td>判断是否为EWOULDBLOCK(数据已经收完, ET模式收完数据的标志) 或者 EINTR(信号中断)</td>\n</tr>\n<tr>\n<td>recv</td>\n<td>0</td>\n<td>对端关闭</td>\n<td>对端关闭</td>\n</tr>\n<tr>\n<td>send</td>\n<td>-1</td>\n<td>出错</td>\n<td>EWOULDBLOCK(数据无法继续发出) EAGAIN</td>\n</tr>\n</tbody></table>\n<p>LT 想收多少收多少 收不完就提醒<br>ET 爱收不收 过了这村没这店</p>\n<p>老大让你开发一个邮件服务器, 大多数人像Springboot使用者. 第一时间就会去找库<br>然而大多数HTTP协议实现都比较简单, 在自己公司所用框架的网络基础上, 很简单就能写出.8</p>\n<p>2020年7月17日20:30:06<br>理论-&gt;常用Api-&gt;知晓如何组织底层Api<br>网络编程重难点解析直播录像及课件, 终于看完了.</p>\n"},{"title":"远程连接宿舍电脑","date":"2020-10-29T08:40:39.000Z","_content":"\n学校机房电脑配置低? 卡慢?\n\n学习机房电脑没有自己电脑环境用着顺手?\n\n你还在担心使用机房电脑后需要拷贝代码到U盘或者QQ吗?\n\n~~机房电脑玩大型游戏?~~\n\n使用远程连接吧!\n\n\n# 向日葵等\n\n优点: 不需要公网IP就能使用, 安装使用非常方便\n缺点: 由于数据交互经过了向日葵的服务器导致延迟较高?\n\n# Win10自带远程连接\n\n优点: 内网使用延迟极低, 就像直接操作远在其他地方的笔记本一样\n缺点: 需要内网使用, 配置较为繁琐.\n\n\n针对内网这一问题, 学校机房, 学校stuwifi, 宿舍网线都是同一内网(得益于三网通一, 没想到这货还有这样的好处), 所以最大的问题解决了.\n\n\n## 安装前提\n\n必须确保电脑为专业版  最好是正版专业版盗版可能会有账户配置等问题 自行查阅.\n\n任务栏左下角Win10图标右击, 打开设置 --> 更新和安全 --> 选择激活  确保显示的为专业版\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E4%B8%93%E4%B8%9A%E7%89%88.png)\n\n\n可惜大部分笔记本都是家庭版, 我这里只推荐一种方法家庭版升级专业版. 其他方法自行百度尝试\n\n去淘宝购买**家庭版升级专业版Win10密钥**注意不是简单的专业版就行了必须写着**升级**, 详细咨询客服吧\n\n大概15软妹币左右即可拥有正版Win10专业版, 而且不需要重装系统C盘不会动.\n\n购买密钥后 在更新和安全的激活那里选择**更改产品密钥** 输入确认即可.\n\n## 自己电脑开启远程连接\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.png)\n\n桌面我的电脑(此电脑) 右击选择属性->远程设置->勾选图示三个对勾.\n\n## 确认电脑IP\n\ncmd输入ipconfig记录好自己的IPV4地址和IPV6地址 IPV6不要记录临时地址\n\nIPV6地址永远不会变,  且**无论电脑是否登录都能使用**, 但是机房电脑没有IPV6\n\nIPV4地址可能会改变, 需要**10.2.5.251电脑登录后**才能使用 推荐设置静态IPV4地址或者每次使用记录下IPV4\n\n\n## 机房电脑设置\n\n机房电脑任务栏左下角的Win10图标右侧的搜索(放大镜标志) --> 输入**远程**二字->选择弹出来的**远程桌面连接**->输入**IPV4**地址\n\n确保宿舍电脑联网的情况下 点击连接就提示让你输入账号密码.  账号和密码是你Win10账户的账号和密码. 输入账号密码就连接成功了.\n\n## 其他建议选项\n\n1. 宿舍建议直插网线, 宿舍电脑使用Wifi可能有延迟感觉","source":"_posts/分享学习会-远程连接宿舍电脑.md","raw":"---\ntitle: 远程连接宿舍电脑\ntags:\n  - null\ncategories:\n  - 分享会\ndate: 2020-10-29 16:40:39\n---\n\n学校机房电脑配置低? 卡慢?\n\n学习机房电脑没有自己电脑环境用着顺手?\n\n你还在担心使用机房电脑后需要拷贝代码到U盘或者QQ吗?\n\n~~机房电脑玩大型游戏?~~\n\n使用远程连接吧!\n\n\n# 向日葵等\n\n优点: 不需要公网IP就能使用, 安装使用非常方便\n缺点: 由于数据交互经过了向日葵的服务器导致延迟较高?\n\n# Win10自带远程连接\n\n优点: 内网使用延迟极低, 就像直接操作远在其他地方的笔记本一样\n缺点: 需要内网使用, 配置较为繁琐.\n\n\n针对内网这一问题, 学校机房, 学校stuwifi, 宿舍网线都是同一内网(得益于三网通一, 没想到这货还有这样的好处), 所以最大的问题解决了.\n\n\n## 安装前提\n\n必须确保电脑为专业版  最好是正版专业版盗版可能会有账户配置等问题 自行查阅.\n\n任务栏左下角Win10图标右击, 打开设置 --> 更新和安全 --> 选择激活  确保显示的为专业版\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E4%B8%93%E4%B8%9A%E7%89%88.png)\n\n\n可惜大部分笔记本都是家庭版, 我这里只推荐一种方法家庭版升级专业版. 其他方法自行百度尝试\n\n去淘宝购买**家庭版升级专业版Win10密钥**注意不是简单的专业版就行了必须写着**升级**, 详细咨询客服吧\n\n大概15软妹币左右即可拥有正版Win10专业版, 而且不需要重装系统C盘不会动.\n\n购买密钥后 在更新和安全的激活那里选择**更改产品密钥** 输入确认即可.\n\n## 自己电脑开启远程连接\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.png)\n\n桌面我的电脑(此电脑) 右击选择属性->远程设置->勾选图示三个对勾.\n\n## 确认电脑IP\n\ncmd输入ipconfig记录好自己的IPV4地址和IPV6地址 IPV6不要记录临时地址\n\nIPV6地址永远不会变,  且**无论电脑是否登录都能使用**, 但是机房电脑没有IPV6\n\nIPV4地址可能会改变, 需要**10.2.5.251电脑登录后**才能使用 推荐设置静态IPV4地址或者每次使用记录下IPV4\n\n\n## 机房电脑设置\n\n机房电脑任务栏左下角的Win10图标右侧的搜索(放大镜标志) --> 输入**远程**二字->选择弹出来的**远程桌面连接**->输入**IPV4**地址\n\n确保宿舍电脑联网的情况下 点击连接就提示让你输入账号密码.  账号和密码是你Win10账户的账号和密码. 输入账号密码就连接成功了.\n\n## 其他建议选项\n\n1. 宿舍建议直插网线, 宿舍电脑使用Wifi可能有延迟感觉","slug":"分享学习会-远程连接宿舍电脑","published":1,"updated":"2020-10-28T09:16:59.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6l001uf8un45tfh599","content":"<p>学校机房电脑配置低? 卡慢?</p>\n<p>学习机房电脑没有自己电脑环境用着顺手?</p>\n<p>你还在担心使用机房电脑后需要拷贝代码到U盘或者QQ吗?</p>\n<p><del>机房电脑玩大型游戏?</del></p>\n<p>使用远程连接吧!</p>\n<h1 id=\"向日葵等\"><a href=\"#向日葵等\" class=\"headerlink\" title=\"向日葵等\"></a>向日葵等</h1><p>优点: 不需要公网IP就能使用, 安装使用非常方便<br>缺点: 由于数据交互经过了向日葵的服务器导致延迟较高?</p>\n<h1 id=\"Win10自带远程连接\"><a href=\"#Win10自带远程连接\" class=\"headerlink\" title=\"Win10自带远程连接\"></a>Win10自带远程连接</h1><p>优点: 内网使用延迟极低, 就像直接操作远在其他地方的笔记本一样<br>缺点: 需要内网使用, 配置较为繁琐.</p>\n<p>针对内网这一问题, 学校机房, 学校stuwifi, 宿舍网线都是同一内网(得益于三网通一, 没想到这货还有这样的好处), 所以最大的问题解决了.</p>\n<h2 id=\"安装前提\"><a href=\"#安装前提\" class=\"headerlink\" title=\"安装前提\"></a>安装前提</h2><p>必须确保电脑为专业版  最好是正版专业版盗版可能会有账户配置等问题 自行查阅.</p>\n<p>任务栏左下角Win10图标右击, 打开设置 –&gt; 更新和安全 –&gt; 选择激活  确保显示的为专业版<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E4%B8%93%E4%B8%9A%E7%89%88.png\" alt=\"\"></p>\n<p>可惜大部分笔记本都是家庭版, 我这里只推荐一种方法家庭版升级专业版. 其他方法自行百度尝试</p>\n<p>去淘宝购买<strong>家庭版升级专业版Win10密钥</strong>注意不是简单的专业版就行了必须写着<strong>升级</strong>, 详细咨询客服吧</p>\n<p>大概15软妹币左右即可拥有正版Win10专业版, 而且不需要重装系统C盘不会动.</p>\n<p>购买密钥后 在更新和安全的激活那里选择<strong>更改产品密钥</strong> 输入确认即可.</p>\n<h2 id=\"自己电脑开启远程连接\"><a href=\"#自己电脑开启远程连接\" class=\"headerlink\" title=\"自己电脑开启远程连接\"></a>自己电脑开启远程连接</h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.png\" alt=\"\"></p>\n<p>桌面我的电脑(此电脑) 右击选择属性-&gt;远程设置-&gt;勾选图示三个对勾.</p>\n<h2 id=\"确认电脑IP\"><a href=\"#确认电脑IP\" class=\"headerlink\" title=\"确认电脑IP\"></a>确认电脑IP</h2><p>cmd输入ipconfig记录好自己的IPV4地址和IPV6地址 IPV6不要记录临时地址</p>\n<p>IPV6地址永远不会变,  且<strong>无论电脑是否登录都能使用</strong>, 但是机房电脑没有IPV6</p>\n<p>IPV4地址可能会改变, 需要<strong>10.2.5.251电脑登录后</strong>才能使用 推荐设置静态IPV4地址或者每次使用记录下IPV4</p>\n<h2 id=\"机房电脑设置\"><a href=\"#机房电脑设置\" class=\"headerlink\" title=\"机房电脑设置\"></a>机房电脑设置</h2><p>机房电脑任务栏左下角的Win10图标右侧的搜索(放大镜标志) –&gt; 输入<strong>远程</strong>二字-&gt;选择弹出来的<strong>远程桌面连接</strong>-&gt;输入<strong>IPV4</strong>地址</p>\n<p>确保宿舍电脑联网的情况下 点击连接就提示让你输入账号密码.  账号和密码是你Win10账户的账号和密码. 输入账号密码就连接成功了.</p>\n<h2 id=\"其他建议选项\"><a href=\"#其他建议选项\" class=\"headerlink\" title=\"其他建议选项\"></a>其他建议选项</h2><ol>\n<li>宿舍建议直插网线, 宿舍电脑使用Wifi可能有延迟感觉</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>学校机房电脑配置低? 卡慢?</p>\n<p>学习机房电脑没有自己电脑环境用着顺手?</p>\n<p>你还在担心使用机房电脑后需要拷贝代码到U盘或者QQ吗?</p>\n<p><del>机房电脑玩大型游戏?</del></p>\n<p>使用远程连接吧!</p>\n<h1 id=\"向日葵等\"><a href=\"#向日葵等\" class=\"headerlink\" title=\"向日葵等\"></a>向日葵等</h1><p>优点: 不需要公网IP就能使用, 安装使用非常方便<br>缺点: 由于数据交互经过了向日葵的服务器导致延迟较高?</p>\n<h1 id=\"Win10自带远程连接\"><a href=\"#Win10自带远程连接\" class=\"headerlink\" title=\"Win10自带远程连接\"></a>Win10自带远程连接</h1><p>优点: 内网使用延迟极低, 就像直接操作远在其他地方的笔记本一样<br>缺点: 需要内网使用, 配置较为繁琐.</p>\n<p>针对内网这一问题, 学校机房, 学校stuwifi, 宿舍网线都是同一内网(得益于三网通一, 没想到这货还有这样的好处), 所以最大的问题解决了.</p>\n<h2 id=\"安装前提\"><a href=\"#安装前提\" class=\"headerlink\" title=\"安装前提\"></a>安装前提</h2><p>必须确保电脑为专业版  最好是正版专业版盗版可能会有账户配置等问题 自行查阅.</p>\n<p>任务栏左下角Win10图标右击, 打开设置 –&gt; 更新和安全 –&gt; 选择激活  确保显示的为专业版<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E4%B8%93%E4%B8%9A%E7%89%88.png\" alt=\"\"></p>\n<p>可惜大部分笔记本都是家庭版, 我这里只推荐一种方法家庭版升级专业版. 其他方法自行百度尝试</p>\n<p>去淘宝购买<strong>家庭版升级专业版Win10密钥</strong>注意不是简单的专业版就行了必须写着<strong>升级</strong>, 详细咨询客服吧</p>\n<p>大概15软妹币左右即可拥有正版Win10专业版, 而且不需要重装系统C盘不会动.</p>\n<p>购买密钥后 在更新和安全的激活那里选择<strong>更改产品密钥</strong> 输入确认即可.</p>\n<h2 id=\"自己电脑开启远程连接\"><a href=\"#自己电脑开启远程连接\" class=\"headerlink\" title=\"自己电脑开启远程连接\"></a>自己电脑开启远程连接</h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5.png\" alt=\"\"></p>\n<p>桌面我的电脑(此电脑) 右击选择属性-&gt;远程设置-&gt;勾选图示三个对勾.</p>\n<h2 id=\"确认电脑IP\"><a href=\"#确认电脑IP\" class=\"headerlink\" title=\"确认电脑IP\"></a>确认电脑IP</h2><p>cmd输入ipconfig记录好自己的IPV4地址和IPV6地址 IPV6不要记录临时地址</p>\n<p>IPV6地址永远不会变,  且<strong>无论电脑是否登录都能使用</strong>, 但是机房电脑没有IPV6</p>\n<p>IPV4地址可能会改变, 需要<strong>10.2.5.251电脑登录后</strong>才能使用 推荐设置静态IPV4地址或者每次使用记录下IPV4</p>\n<h2 id=\"机房电脑设置\"><a href=\"#机房电脑设置\" class=\"headerlink\" title=\"机房电脑设置\"></a>机房电脑设置</h2><p>机房电脑任务栏左下角的Win10图标右侧的搜索(放大镜标志) –&gt; 输入<strong>远程</strong>二字-&gt;选择弹出来的<strong>远程桌面连接</strong>-&gt;输入<strong>IPV4</strong>地址</p>\n<p>确保宿舍电脑联网的情况下 点击连接就提示让你输入账号密码.  账号和密码是你Win10账户的账号和密码. 输入账号密码就连接成功了.</p>\n<h2 id=\"其他建议选项\"><a href=\"#其他建议选项\" class=\"headerlink\" title=\"其他建议选项\"></a>其他建议选项</h2><ol>\n<li>宿舍建议直插网线, 宿舍电脑使用Wifi可能有延迟感觉</li>\n</ol>\n"},{"title":"HTTP框架底层原理实现","date":"2020-11-01T14:45:39.000Z","_content":"\n# 框架\n\n后端组使用各种框架\n- Java的Springboot\n- Python的Django\n\n框架的底层原理是什么? 当然涉及原理性的东西太多了, 我这里指的是为什么客户端的几次简单点击 最终会转化成了后端的函数调用?\n\nSpringboot针对某一个URL能Get Post等等设置对应的方法. 还能得到指定的参数?\n\n客户端的几下简单的点击就能够将数据传送到后端 从后端拿回数据然后进行显示\n\n后端也只要在相关的函数后处理接收到的数据\n\n# 基础\n\n要解释上面的问题需要用到计算机学院几门专业课的只是 <操作系统> <计算机组成原理 跳过> <计算机网络>\n\n基础知识我要不要学? HTTP协议? DNS怎么发挥的作用?\n\nGET POST 有什么区别? 为什么GET有参数长度限制(自己本以为是RFC规定 然而是浏览器规定的而且是URL长度限制而不是参数限制) 而POST没有参数长度限制\n新了解到了\n\n无法访问网页怎么办? 可以根据浏览器访问流程进行排查\n\n校园网断网跳转怎么实现的? DNS污染又是什么? *返回错误的IP*\n\nfavicon? 如何实现的自动加载 *GET /favicon.ico HTTP/1.1*\n\n抓包的原理\n\n# 浏览器访问流程\n\n当你输入一个网址, 按下回车后 首先会向DNS服务器发送DNS请求将域名转换成IP. *DNS污染*\n\n然后向 IP+端口号 **建立连接 强调!** 发送HTTP请求 (HTTP默认是80端口) 接收HTTP回应 进行解析HTML 然后请求相关的JS文件等\n\n然而收发HTTP并不是 操作系统提供的基础API的功能 那是怎么来的?\n\n# HTTP协议\n\n协议是什么?\n\n文本协议\n\n```\nGET  HTTP/1.1\nHost: 10.2.5.251\nConnection: keep-alive\nDNT: 1\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8\n\n\nGET / HTTP/1.1\nHost: www.baidu.com\nConnection: keep-alive\nDNT: 1\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nSec-Fetch-Site: none\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8\nCookie: BIDUPSID=275AD930CBDC20F9C9E074230710B72E; PSTM=1602485007; BAIDUID=93E8E77E51A5F22CA01131559BA8666A:FG=1; BD_UPN=12314753; BDUSS=BjRVJYdFQ5TEJKWWNPck1ZcWdOVklMT0JHMHhQMUx3UGxDZjhNMVVhRmdqcXRmSVFBQUFBJCQAAAAAAAAAAAEAAADZQdlRcmpkNjc0NDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGABhF9gAYRfM3; BDUSS_BFESS=BjRVJYdFQ5TEJKWWNPck1ZcWdOVklMT0JHMHhQMUx3UGxDZjhNMVVhRmdqcXRmSVFBQUFBJCQAAAAAAAAAAAEAAADZQdlRcmpkNjc0NDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGABhF9gAYRfM3; BAIDUID_BFESS=F500721F63FBCA4EDC7DA170AE314FEE:FG=1; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; COOKIE_SESSION=332523_0_8_0_3_6_1_0_7_4_42_0_332523_0_6_0_1604291277_0_1604291271%7C8%230_0_1604291271%7C1; sug=3; sugstore=0; ORIGIN=0; bdime=0; ZD_ENTRY=google\n\n\nPOST http://202.119.196.6:8080/Self/login/verify HTTP/1.1\nConnection: keep-alive\nCache-Control: max-age=0\nOrigin: http://202.119.196.6:8080\nUpgrade-Insecure-Requests: 1\nDNT: 1\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://202.119.196.6:8080/Self/login/?302=LI\nAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8\nHost: 202.119.196.6:8080\nAccept-Encoding: gzip, deflate, br\nContent-Length: 60\nCookie: JSESSIONID=E56420ED06E0ABE922C5A904DBB9C944\n\nfoo=&bar=&checkcode=1234&account=08180000&password=md5&code=\n\n\nHTTP/1.1 200 OK\nDate: Sat, 31 Dec 2005 23:59:59 GMT\nContent-Type: text/html;charset=ISO-8859-1\nContent-Length: 122\n\n<html>\n<head>\n<title>Wrox Homepage</title>\n</head>\n<body>\n<!-- body goes here -->\nHTTP/1.1 200 OK Date: Sat\n</body>\n</html>\n```\n\n根据这个格式*描述一下格式* 请求方法 请求路径 HTTP版本\n\nHEADER部分 需要什么HEADER加入什么\n\nBODY部分 放入数据\n\n所根据的这个格式 这个规定就叫做协议 HTTP的规定就是HTTP协议\n\n所以说你在手机上查询电费也好 电脑上浏览网页也罢 前端调用后端也是如此 只要是HTTP的API 都会将数据按照这个格式进行打包\n\n1. **建立连接后**   Fiddler监听拦截的数据, 你知道了这个包的数据都有什么 然后自己建立连接发送同样的包 效果是一样的\n2. 发送打包的数据 \n3. 接收服务器返回的结果\n4. 所以可以抓包后模拟请求这就这么来的\n\n# 从TCP看HTTP\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E4%B8%83%E5%B1%82%E5%92%8C%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE.png)\n\n*将根据这张图说一说, 经常让了解的 七层和四层协议.  (网络访问(链接)层)*\n\n上边面说的建立连接建立的实际是TCP连接\n\nTCP连接是通过 IP和端口号建立的 正好使用的上面的IP和端口号\n\nTCP连接干什么?  连接就是传输数据 这就涉及到了读写操作  全双工\n\n两个套接字之间的通信 客户端持有一个套接字 服务器持有一个套接字 然后客户端的数据发送和服务器端的数据接收就是转化为了针对套接字的读写\n\n套接字你可以理解为 两个电话互相通话\n\n套接字的建立和管理都比较复杂, 但是流程极为固定 干脆将这些代码包装起来 对外界提供一个简单的函数即可 内部帮你管理建立TCP连接\n\n客户端指的就是你的浏览器也好, 你的应用也好 套接字这个核心的东西被包装了起来\n\n所以输入网址也好, 使用form标签也罢. 最终都是根据HTTP协议包装你想要发送或者接受的数据. 建立TCP连接 然后将包装好的数据发送到套接字 对方从套接字接受 (流, 流水 按顺序流入)\n\n*nc 命令 演示演示?*\n\n所以你可以没有域名 照样可以使用HTTP协议 照样访问网页.\n\n因为HTTP交互的核心就是 根据HTTP协议包装数据 经由TCP连接收发数据 TCP连接使用的是 IP和端口号 而非域名\n\n域名就没有用了吗? 除了便于记忆? *域名 区分作用*\n\n# HTTP框架\n\n上面说了HTTP交互细节. 本质就是的收发\n```\nGET /api?a=1&b=2 HTTP/1.1\nHost: 10.2.5.251\nConnection: keep-alive\nDNT: 1\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8\n\nHTTP/1.1 200 OK\nDate: Sat, 31 Dec 2005 23:59:59 GMT\nContent-Type: text/html;charset=ISO-8859-1\nContent-Length: 122\n\n＜html＞\n＜head＞\n＜title＞Wrox Homepage＜/title＞\n＜/head＞\n＜body＞\n＜!-- body goes here --＞\n＜/body＞\n＜/html＞\n```\n服务器端从套接字 接收到数据后 大家没有见过上面的东西吧\n\n那就是框架接受之后 把它们作为字符串存了起来 然后按照HTTP的固定协议格式 将内容解析\n\n必须解析的一般有 Get /api?a=1&b=2  然后得知了这是一个GET请求 请求的URL是 /api 有两个参数 叫什么 值是多少\n\n然后根据你服务器代码设定的找到一个对应的函数, 框架调用这个函数 传入参数 你就可以处理相应的逻辑了.\n\n# 库和框架?\n\n库是帮你提供某些功能的包装, 单个库一般并不能开发完整的应用, 只是作为一部分功能函数. curl库 线程库\n\n框架可以理解为库的升级版, 你使用一个框架提供的函数 就能开发完整的应用, 大多数框架还能方便的引入其他的库来供自己使用.\n\n# nginx?\n\nnginx大家用过没有?\n\n一般逻辑都是设置一个域名 然后指向一个端口 是不是?\n\n域名这个东西就藏在了HTTPRequest的 header里 他同样从TCP连接接收数据 解析 便知道了域名 然后根据配置转发即可\n\n# 要不要学基础知识?\n\n端口 计算机网络 组装nas计网\n\n网线到内核 操作系统和计算机组成原理\n\n# 自学能力\n\n我大一来的工作室 来的时候是远爷带我学的JavaWeb. \n\n随便找了本Java书给划一下看哪里\n\n给我指明了一个框架, 然后呢? 去学呗\n\n百度->谷歌中文->谷歌英文 https://translate.google.cn/\n\n知乎 百度 谷歌 Github StackOverflow 等等\n\n遇到问题先百度\n\n- 视频?\n- 看书?\n- 文档?\n\n大二转LinuxC++ 全部都是从零开始 没有人带我\n\n# 大学生\n\n垃圾xxxA4 我就是不想学.\n\n写博客?\n\n\n\n\n人外有人天外有天\n\n让自己一天比一天更加优秀 提升自己\n\n\n平衡自己时间  爆肝程序\n社交 我用大二上的社交换到了Linux入门 我退出了xxxx\n\n大三上减肥(身高), 参加活动, 锻炼身体, 找对象? 规律作息\n\n穿搭\n\n多多质疑 乳酸菌饮料?\n\n不要被轻易带节奏 12:55秒 https://www.bilibili.com/video/BV1jV411o7VV","source":"_posts/分享学习会-HTTP框架底层原理.md","raw":"---\ntitle: HTTP框架底层原理实现\ntags:\n  - null\ncategories:\n  - 分享会\ndate: 2020-11-1 22:45:39\n---\n\n# 框架\n\n后端组使用各种框架\n- Java的Springboot\n- Python的Django\n\n框架的底层原理是什么? 当然涉及原理性的东西太多了, 我这里指的是为什么客户端的几次简单点击 最终会转化成了后端的函数调用?\n\nSpringboot针对某一个URL能Get Post等等设置对应的方法. 还能得到指定的参数?\n\n客户端的几下简单的点击就能够将数据传送到后端 从后端拿回数据然后进行显示\n\n后端也只要在相关的函数后处理接收到的数据\n\n# 基础\n\n要解释上面的问题需要用到计算机学院几门专业课的只是 <操作系统> <计算机组成原理 跳过> <计算机网络>\n\n基础知识我要不要学? HTTP协议? DNS怎么发挥的作用?\n\nGET POST 有什么区别? 为什么GET有参数长度限制(自己本以为是RFC规定 然而是浏览器规定的而且是URL长度限制而不是参数限制) 而POST没有参数长度限制\n新了解到了\n\n无法访问网页怎么办? 可以根据浏览器访问流程进行排查\n\n校园网断网跳转怎么实现的? DNS污染又是什么? *返回错误的IP*\n\nfavicon? 如何实现的自动加载 *GET /favicon.ico HTTP/1.1*\n\n抓包的原理\n\n# 浏览器访问流程\n\n当你输入一个网址, 按下回车后 首先会向DNS服务器发送DNS请求将域名转换成IP. *DNS污染*\n\n然后向 IP+端口号 **建立连接 强调!** 发送HTTP请求 (HTTP默认是80端口) 接收HTTP回应 进行解析HTML 然后请求相关的JS文件等\n\n然而收发HTTP并不是 操作系统提供的基础API的功能 那是怎么来的?\n\n# HTTP协议\n\n协议是什么?\n\n文本协议\n\n```\nGET  HTTP/1.1\nHost: 10.2.5.251\nConnection: keep-alive\nDNT: 1\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8\n\n\nGET / HTTP/1.1\nHost: www.baidu.com\nConnection: keep-alive\nDNT: 1\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nSec-Fetch-Site: none\nSec-Fetch-Mode: navigate\nSec-Fetch-User: ?1\nSec-Fetch-Dest: document\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8\nCookie: BIDUPSID=275AD930CBDC20F9C9E074230710B72E; PSTM=1602485007; BAIDUID=93E8E77E51A5F22CA01131559BA8666A:FG=1; BD_UPN=12314753; BDUSS=BjRVJYdFQ5TEJKWWNPck1ZcWdOVklMT0JHMHhQMUx3UGxDZjhNMVVhRmdqcXRmSVFBQUFBJCQAAAAAAAAAAAEAAADZQdlRcmpkNjc0NDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGABhF9gAYRfM3; BDUSS_BFESS=BjRVJYdFQ5TEJKWWNPck1ZcWdOVklMT0JHMHhQMUx3UGxDZjhNMVVhRmdqcXRmSVFBQUFBJCQAAAAAAAAAAAEAAADZQdlRcmpkNjc0NDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGABhF9gAYRfM3; BAIDUID_BFESS=F500721F63FBCA4EDC7DA170AE314FEE:FG=1; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; COOKIE_SESSION=332523_0_8_0_3_6_1_0_7_4_42_0_332523_0_6_0_1604291277_0_1604291271%7C8%230_0_1604291271%7C1; sug=3; sugstore=0; ORIGIN=0; bdime=0; ZD_ENTRY=google\n\n\nPOST http://202.119.196.6:8080/Self/login/verify HTTP/1.1\nConnection: keep-alive\nCache-Control: max-age=0\nOrigin: http://202.119.196.6:8080\nUpgrade-Insecure-Requests: 1\nDNT: 1\nContent-Type: application/x-www-form-urlencoded\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://202.119.196.6:8080/Self/login/?302=LI\nAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8\nHost: 202.119.196.6:8080\nAccept-Encoding: gzip, deflate, br\nContent-Length: 60\nCookie: JSESSIONID=E56420ED06E0ABE922C5A904DBB9C944\n\nfoo=&bar=&checkcode=1234&account=08180000&password=md5&code=\n\n\nHTTP/1.1 200 OK\nDate: Sat, 31 Dec 2005 23:59:59 GMT\nContent-Type: text/html;charset=ISO-8859-1\nContent-Length: 122\n\n<html>\n<head>\n<title>Wrox Homepage</title>\n</head>\n<body>\n<!-- body goes here -->\nHTTP/1.1 200 OK Date: Sat\n</body>\n</html>\n```\n\n根据这个格式*描述一下格式* 请求方法 请求路径 HTTP版本\n\nHEADER部分 需要什么HEADER加入什么\n\nBODY部分 放入数据\n\n所根据的这个格式 这个规定就叫做协议 HTTP的规定就是HTTP协议\n\n所以说你在手机上查询电费也好 电脑上浏览网页也罢 前端调用后端也是如此 只要是HTTP的API 都会将数据按照这个格式进行打包\n\n1. **建立连接后**   Fiddler监听拦截的数据, 你知道了这个包的数据都有什么 然后自己建立连接发送同样的包 效果是一样的\n2. 发送打包的数据 \n3. 接收服务器返回的结果\n4. 所以可以抓包后模拟请求这就这么来的\n\n# 从TCP看HTTP\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E4%B8%83%E5%B1%82%E5%92%8C%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE.png)\n\n*将根据这张图说一说, 经常让了解的 七层和四层协议.  (网络访问(链接)层)*\n\n上边面说的建立连接建立的实际是TCP连接\n\nTCP连接是通过 IP和端口号建立的 正好使用的上面的IP和端口号\n\nTCP连接干什么?  连接就是传输数据 这就涉及到了读写操作  全双工\n\n两个套接字之间的通信 客户端持有一个套接字 服务器持有一个套接字 然后客户端的数据发送和服务器端的数据接收就是转化为了针对套接字的读写\n\n套接字你可以理解为 两个电话互相通话\n\n套接字的建立和管理都比较复杂, 但是流程极为固定 干脆将这些代码包装起来 对外界提供一个简单的函数即可 内部帮你管理建立TCP连接\n\n客户端指的就是你的浏览器也好, 你的应用也好 套接字这个核心的东西被包装了起来\n\n所以输入网址也好, 使用form标签也罢. 最终都是根据HTTP协议包装你想要发送或者接受的数据. 建立TCP连接 然后将包装好的数据发送到套接字 对方从套接字接受 (流, 流水 按顺序流入)\n\n*nc 命令 演示演示?*\n\n所以你可以没有域名 照样可以使用HTTP协议 照样访问网页.\n\n因为HTTP交互的核心就是 根据HTTP协议包装数据 经由TCP连接收发数据 TCP连接使用的是 IP和端口号 而非域名\n\n域名就没有用了吗? 除了便于记忆? *域名 区分作用*\n\n# HTTP框架\n\n上面说了HTTP交互细节. 本质就是的收发\n```\nGET /api?a=1&b=2 HTTP/1.1\nHost: 10.2.5.251\nConnection: keep-alive\nDNT: 1\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,ja;q=0.8\n\nHTTP/1.1 200 OK\nDate: Sat, 31 Dec 2005 23:59:59 GMT\nContent-Type: text/html;charset=ISO-8859-1\nContent-Length: 122\n\n＜html＞\n＜head＞\n＜title＞Wrox Homepage＜/title＞\n＜/head＞\n＜body＞\n＜!-- body goes here --＞\n＜/body＞\n＜/html＞\n```\n服务器端从套接字 接收到数据后 大家没有见过上面的东西吧\n\n那就是框架接受之后 把它们作为字符串存了起来 然后按照HTTP的固定协议格式 将内容解析\n\n必须解析的一般有 Get /api?a=1&b=2  然后得知了这是一个GET请求 请求的URL是 /api 有两个参数 叫什么 值是多少\n\n然后根据你服务器代码设定的找到一个对应的函数, 框架调用这个函数 传入参数 你就可以处理相应的逻辑了.\n\n# 库和框架?\n\n库是帮你提供某些功能的包装, 单个库一般并不能开发完整的应用, 只是作为一部分功能函数. curl库 线程库\n\n框架可以理解为库的升级版, 你使用一个框架提供的函数 就能开发完整的应用, 大多数框架还能方便的引入其他的库来供自己使用.\n\n# nginx?\n\nnginx大家用过没有?\n\n一般逻辑都是设置一个域名 然后指向一个端口 是不是?\n\n域名这个东西就藏在了HTTPRequest的 header里 他同样从TCP连接接收数据 解析 便知道了域名 然后根据配置转发即可\n\n# 要不要学基础知识?\n\n端口 计算机网络 组装nas计网\n\n网线到内核 操作系统和计算机组成原理\n\n# 自学能力\n\n我大一来的工作室 来的时候是远爷带我学的JavaWeb. \n\n随便找了本Java书给划一下看哪里\n\n给我指明了一个框架, 然后呢? 去学呗\n\n百度->谷歌中文->谷歌英文 https://translate.google.cn/\n\n知乎 百度 谷歌 Github StackOverflow 等等\n\n遇到问题先百度\n\n- 视频?\n- 看书?\n- 文档?\n\n大二转LinuxC++ 全部都是从零开始 没有人带我\n\n# 大学生\n\n垃圾xxxA4 我就是不想学.\n\n写博客?\n\n\n\n\n人外有人天外有天\n\n让自己一天比一天更加优秀 提升自己\n\n\n平衡自己时间  爆肝程序\n社交 我用大二上的社交换到了Linux入门 我退出了xxxx\n\n大三上减肥(身高), 参加活动, 锻炼身体, 找对象? 规律作息\n\n穿搭\n\n多多质疑 乳酸菌饮料?\n\n不要被轻易带节奏 12:55秒 https://www.bilibili.com/video/BV1jV411o7VV","slug":"分享学习会-HTTP框架底层原理","published":1,"updated":"2020-11-07T07:12:14.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6m001vf8un5n6q8p8x","content":"<h1 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h1><p>后端组使用各种框架</p>\n<ul>\n<li>Java的Springboot</li>\n<li>Python的Django</li>\n</ul>\n<p>框架的底层原理是什么? 当然涉及原理性的东西太多了, 我这里指的是为什么客户端的几次简单点击 最终会转化成了后端的函数调用?</p>\n<p>Springboot针对某一个URL能Get Post等等设置对应的方法. 还能得到指定的参数?</p>\n<p>客户端的几下简单的点击就能够将数据传送到后端 从后端拿回数据然后进行显示</p>\n<p>后端也只要在相关的函数后处理接收到的数据</p>\n<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><p>要解释上面的问题需要用到计算机学院几门专业课的只是 &lt;操作系统&gt; &lt;计算机组成原理 跳过&gt; &lt;计算机网络&gt;</p>\n<p>基础知识我要不要学? HTTP协议? DNS怎么发挥的作用?</p>\n<p>GET POST 有什么区别? 为什么GET有参数长度限制(自己本以为是RFC规定 然而是浏览器规定的而且是URL长度限制而不是参数限制) 而POST没有参数长度限制<br>新了解到了</p>\n<p>无法访问网页怎么办? 可以根据浏览器访问流程进行排查</p>\n<p>校园网断网跳转怎么实现的? DNS污染又是什么? <em>返回错误的IP</em></p>\n<p>favicon? 如何实现的自动加载 <em>GET /favicon.ico HTTP/1.1</em></p>\n<p>抓包的原理</p>\n<h1 id=\"浏览器访问流程\"><a href=\"#浏览器访问流程\" class=\"headerlink\" title=\"浏览器访问流程\"></a>浏览器访问流程</h1><p>当你输入一个网址, 按下回车后 首先会向DNS服务器发送DNS请求将域名转换成IP. <em>DNS污染</em></p>\n<p>然后向 IP+端口号 <strong>建立连接 强调!</strong> 发送HTTP请求 (HTTP默认是80端口) 接收HTTP回应 进行解析HTML 然后请求相关的JS文件等</p>\n<p>然而收发HTTP并不是 操作系统提供的基础API的功能 那是怎么来的?</p>\n<h1 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h1><p>协议是什么?</p>\n<p>文本协议</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET  HTTP&#x2F;1.1</span><br><span class=\"line\">Host: 10.2.5.251</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">DNT: 1</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.183 Safari&#x2F;537.36</span><br><span class=\"line\">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET &#x2F; HTTP&#x2F;1.1</span><br><span class=\"line\">Host: www.baidu.com</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">DNT: 1</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.183 Safari&#x2F;537.36</span><br><span class=\"line\">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class=\"line\">Sec-Fetch-Site: none</span><br><span class=\"line\">Sec-Fetch-Mode: navigate</span><br><span class=\"line\">Sec-Fetch-User: ?1</span><br><span class=\"line\">Sec-Fetch-Dest: document</span><br><span class=\"line\">Accept-Encoding: gzip, deflate, br</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class=\"line\">Cookie: BIDUPSID&#x3D;275AD930CBDC20F9C9E074230710B72E; PSTM&#x3D;1602485007; BAIDUID&#x3D;93E8E77E51A5F22CA01131559BA8666A:FG&#x3D;1; BD_UPN&#x3D;12314753; BDUSS&#x3D;BjRVJYdFQ5TEJKWWNPck1ZcWdOVklMT0JHMHhQMUx3UGxDZjhNMVVhRmdqcXRmSVFBQUFBJCQAAAAAAAAAAAEAAADZQdlRcmpkNjc0NDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGABhF9gAYRfM3; BDUSS_BFESS&#x3D;BjRVJYdFQ5TEJKWWNPck1ZcWdOVklMT0JHMHhQMUx3UGxDZjhNMVVhRmdqcXRmSVFBQUFBJCQAAAAAAAAAAAEAAADZQdlRcmpkNjc0NDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGABhF9gAYRfM3; BAIDUID_BFESS&#x3D;F500721F63FBCA4EDC7DA170AE314FEE:FG&#x3D;1; BDORZ&#x3D;B490B5EBF6F3CD402E515D22BCDA1598; COOKIE_SESSION&#x3D;332523_0_8_0_3_6_1_0_7_4_42_0_332523_0_6_0_1604291277_0_1604291271%7C8%230_0_1604291271%7C1; sug&#x3D;3; sugstore&#x3D;0; ORIGIN&#x3D;0; bdime&#x3D;0; ZD_ENTRY&#x3D;google</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST http:&#x2F;&#x2F;202.119.196.6:8080&#x2F;Self&#x2F;login&#x2F;verify HTTP&#x2F;1.1</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Cache-Control: max-age&#x3D;0</span><br><span class=\"line\">Origin: http:&#x2F;&#x2F;202.119.196.6:8080</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">DNT: 1</span><br><span class=\"line\">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class=\"line\">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.111 Safari&#x2F;537.36</span><br><span class=\"line\">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class=\"line\">Referer: http:&#x2F;&#x2F;202.119.196.6:8080&#x2F;Self&#x2F;login&#x2F;?302&#x3D;LI</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class=\"line\">Host: 202.119.196.6:8080</span><br><span class=\"line\">Accept-Encoding: gzip, deflate, br</span><br><span class=\"line\">Content-Length: 60</span><br><span class=\"line\">Cookie: JSESSIONID&#x3D;E56420ED06E0ABE922C5A904DBB9C944</span><br><span class=\"line\"></span><br><span class=\"line\">foo&#x3D;&amp;bar&#x3D;&amp;checkcode&#x3D;1234&amp;account&#x3D;08180000&amp;password&#x3D;md5&amp;code&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">HTTP&#x2F;1.1 200 OK</span><br><span class=\"line\">Date: Sat, 31 Dec 2005 23:59:59 GMT</span><br><span class=\"line\">Content-Type: text&#x2F;html;charset&#x3D;ISO-8859-1</span><br><span class=\"line\">Content-Length: 122</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;Wrox Homepage&lt;&#x2F;title&gt;</span><br><span class=\"line\">&lt;&#x2F;head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;!-- body goes here --&gt;</span><br><span class=\"line\">HTTP&#x2F;1.1 200 OK Date: Sat</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>根据这个格式<em>描述一下格式</em> 请求方法 请求路径 HTTP版本</p>\n<p>HEADER部分 需要什么HEADER加入什么</p>\n<p>BODY部分 放入数据</p>\n<p>所根据的这个格式 这个规定就叫做协议 HTTP的规定就是HTTP协议</p>\n<p>所以说你在手机上查询电费也好 电脑上浏览网页也罢 前端调用后端也是如此 只要是HTTP的API 都会将数据按照这个格式进行打包</p>\n<ol>\n<li><strong>建立连接后</strong>   Fiddler监听拦截的数据, 你知道了这个包的数据都有什么 然后自己建立连接发送同样的包 效果是一样的</li>\n<li>发送打包的数据 </li>\n<li>接收服务器返回的结果</li>\n<li>所以可以抓包后模拟请求这就这么来的</li>\n</ol>\n<h1 id=\"从TCP看HTTP\"><a href=\"#从TCP看HTTP\" class=\"headerlink\" title=\"从TCP看HTTP\"></a>从TCP看HTTP</h1><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E4%B8%83%E5%B1%82%E5%92%8C%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE.png\" alt=\"\"></p>\n<p><em>将根据这张图说一说, 经常让了解的 七层和四层协议.  (网络访问(链接)层)</em></p>\n<p>上边面说的建立连接建立的实际是TCP连接</p>\n<p>TCP连接是通过 IP和端口号建立的 正好使用的上面的IP和端口号</p>\n<p>TCP连接干什么?  连接就是传输数据 这就涉及到了读写操作  全双工</p>\n<p>两个套接字之间的通信 客户端持有一个套接字 服务器持有一个套接字 然后客户端的数据发送和服务器端的数据接收就是转化为了针对套接字的读写</p>\n<p>套接字你可以理解为 两个电话互相通话</p>\n<p>套接字的建立和管理都比较复杂, 但是流程极为固定 干脆将这些代码包装起来 对外界提供一个简单的函数即可 内部帮你管理建立TCP连接</p>\n<p>客户端指的就是你的浏览器也好, 你的应用也好 套接字这个核心的东西被包装了起来</p>\n<p>所以输入网址也好, 使用form标签也罢. 最终都是根据HTTP协议包装你想要发送或者接受的数据. 建立TCP连接 然后将包装好的数据发送到套接字 对方从套接字接受 (流, 流水 按顺序流入)</p>\n<p><em>nc 命令 演示演示?</em></p>\n<p>所以你可以没有域名 照样可以使用HTTP协议 照样访问网页.</p>\n<p>因为HTTP交互的核心就是 根据HTTP协议包装数据 经由TCP连接收发数据 TCP连接使用的是 IP和端口号 而非域名</p>\n<p>域名就没有用了吗? 除了便于记忆? <em>域名 区分作用</em></p>\n<h1 id=\"HTTP框架\"><a href=\"#HTTP框架\" class=\"headerlink\" title=\"HTTP框架\"></a>HTTP框架</h1><p>上面说了HTTP交互细节. 本质就是的收发</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET &#x2F;api?a&#x3D;1&amp;b&#x3D;2 HTTP&#x2F;1.1</span><br><span class=\"line\">Host: 10.2.5.251</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">DNT: 1</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.183 Safari&#x2F;537.36</span><br><span class=\"line\">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class=\"line\"></span><br><span class=\"line\">HTTP&#x2F;1.1 200 OK</span><br><span class=\"line\">Date: Sat, 31 Dec 2005 23:59:59 GMT</span><br><span class=\"line\">Content-Type: text&#x2F;html;charset&#x3D;ISO-8859-1</span><br><span class=\"line\">Content-Length: 122</span><br><span class=\"line\"></span><br><span class=\"line\">＜html＞</span><br><span class=\"line\">＜head＞</span><br><span class=\"line\">＜title＞Wrox Homepage＜&#x2F;title＞</span><br><span class=\"line\">＜&#x2F;head＞</span><br><span class=\"line\">＜body＞</span><br><span class=\"line\">＜!-- body goes here --＞</span><br><span class=\"line\">＜&#x2F;body＞</span><br><span class=\"line\">＜&#x2F;html＞</span><br></pre></td></tr></table></figure>\n<p>服务器端从套接字 接收到数据后 大家没有见过上面的东西吧</p>\n<p>那就是框架接受之后 把它们作为字符串存了起来 然后按照HTTP的固定协议格式 将内容解析</p>\n<p>必须解析的一般有 Get /api?a=1&amp;b=2  然后得知了这是一个GET请求 请求的URL是 /api 有两个参数 叫什么 值是多少</p>\n<p>然后根据你服务器代码设定的找到一个对应的函数, 框架调用这个函数 传入参数 你就可以处理相应的逻辑了.</p>\n<h1 id=\"库和框架\"><a href=\"#库和框架\" class=\"headerlink\" title=\"库和框架?\"></a>库和框架?</h1><p>库是帮你提供某些功能的包装, 单个库一般并不能开发完整的应用, 只是作为一部分功能函数. curl库 线程库</p>\n<p>框架可以理解为库的升级版, 你使用一个框架提供的函数 就能开发完整的应用, 大多数框架还能方便的引入其他的库来供自己使用.</p>\n<h1 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx?\"></a>nginx?</h1><p>nginx大家用过没有?</p>\n<p>一般逻辑都是设置一个域名 然后指向一个端口 是不是?</p>\n<p>域名这个东西就藏在了HTTPRequest的 header里 他同样从TCP连接接收数据 解析 便知道了域名 然后根据配置转发即可</p>\n<h1 id=\"要不要学基础知识\"><a href=\"#要不要学基础知识\" class=\"headerlink\" title=\"要不要学基础知识?\"></a>要不要学基础知识?</h1><p>端口 计算机网络 组装nas计网</p>\n<p>网线到内核 操作系统和计算机组成原理</p>\n<h1 id=\"自学能力\"><a href=\"#自学能力\" class=\"headerlink\" title=\"自学能力\"></a>自学能力</h1><p>我大一来的工作室 来的时候是远爷带我学的JavaWeb. </p>\n<p>随便找了本Java书给划一下看哪里</p>\n<p>给我指明了一个框架, 然后呢? 去学呗</p>\n<p>百度-&gt;谷歌中文-&gt;谷歌英文 <a href=\"https://translate.google.cn/\" target=\"_blank\" rel=\"noopener\">https://translate.google.cn/</a></p>\n<p>知乎 百度 谷歌 Github StackOverflow 等等</p>\n<p>遇到问题先百度</p>\n<ul>\n<li>视频?</li>\n<li>看书?</li>\n<li>文档?</li>\n</ul>\n<p>大二转LinuxC++ 全部都是从零开始 没有人带我</p>\n<h1 id=\"大学生\"><a href=\"#大学生\" class=\"headerlink\" title=\"大学生\"></a>大学生</h1><p>垃圾xxxA4 我就是不想学.</p>\n<p>写博客?</p>\n<p>人外有人天外有天</p>\n<p>让自己一天比一天更加优秀 提升自己</p>\n<p>平衡自己时间  爆肝程序<br>社交 我用大二上的社交换到了Linux入门 我退出了xxxx</p>\n<p>大三上减肥(身高), 参加活动, 锻炼身体, 找对象? 规律作息</p>\n<p>穿搭</p>\n<p>多多质疑 乳酸菌饮料?</p>\n<p>不要被轻易带节奏 12:55秒 <a href=\"https://www.bilibili.com/video/BV1jV411o7VV\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1jV411o7VV</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h1><p>后端组使用各种框架</p>\n<ul>\n<li>Java的Springboot</li>\n<li>Python的Django</li>\n</ul>\n<p>框架的底层原理是什么? 当然涉及原理性的东西太多了, 我这里指的是为什么客户端的几次简单点击 最终会转化成了后端的函数调用?</p>\n<p>Springboot针对某一个URL能Get Post等等设置对应的方法. 还能得到指定的参数?</p>\n<p>客户端的几下简单的点击就能够将数据传送到后端 从后端拿回数据然后进行显示</p>\n<p>后端也只要在相关的函数后处理接收到的数据</p>\n<h1 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h1><p>要解释上面的问题需要用到计算机学院几门专业课的只是 &lt;操作系统&gt; &lt;计算机组成原理 跳过&gt; &lt;计算机网络&gt;</p>\n<p>基础知识我要不要学? HTTP协议? DNS怎么发挥的作用?</p>\n<p>GET POST 有什么区别? 为什么GET有参数长度限制(自己本以为是RFC规定 然而是浏览器规定的而且是URL长度限制而不是参数限制) 而POST没有参数长度限制<br>新了解到了</p>\n<p>无法访问网页怎么办? 可以根据浏览器访问流程进行排查</p>\n<p>校园网断网跳转怎么实现的? DNS污染又是什么? <em>返回错误的IP</em></p>\n<p>favicon? 如何实现的自动加载 <em>GET /favicon.ico HTTP/1.1</em></p>\n<p>抓包的原理</p>\n<h1 id=\"浏览器访问流程\"><a href=\"#浏览器访问流程\" class=\"headerlink\" title=\"浏览器访问流程\"></a>浏览器访问流程</h1><p>当你输入一个网址, 按下回车后 首先会向DNS服务器发送DNS请求将域名转换成IP. <em>DNS污染</em></p>\n<p>然后向 IP+端口号 <strong>建立连接 强调!</strong> 发送HTTP请求 (HTTP默认是80端口) 接收HTTP回应 进行解析HTML 然后请求相关的JS文件等</p>\n<p>然而收发HTTP并不是 操作系统提供的基础API的功能 那是怎么来的?</p>\n<h1 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h1><p>协议是什么?</p>\n<p>文本协议</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET  HTTP&#x2F;1.1</span><br><span class=\"line\">Host: 10.2.5.251</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">DNT: 1</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.183 Safari&#x2F;537.36</span><br><span class=\"line\">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">GET &#x2F; HTTP&#x2F;1.1</span><br><span class=\"line\">Host: www.baidu.com</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">DNT: 1</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.183 Safari&#x2F;537.36</span><br><span class=\"line\">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class=\"line\">Sec-Fetch-Site: none</span><br><span class=\"line\">Sec-Fetch-Mode: navigate</span><br><span class=\"line\">Sec-Fetch-User: ?1</span><br><span class=\"line\">Sec-Fetch-Dest: document</span><br><span class=\"line\">Accept-Encoding: gzip, deflate, br</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class=\"line\">Cookie: BIDUPSID&#x3D;275AD930CBDC20F9C9E074230710B72E; PSTM&#x3D;1602485007; BAIDUID&#x3D;93E8E77E51A5F22CA01131559BA8666A:FG&#x3D;1; BD_UPN&#x3D;12314753; BDUSS&#x3D;BjRVJYdFQ5TEJKWWNPck1ZcWdOVklMT0JHMHhQMUx3UGxDZjhNMVVhRmdqcXRmSVFBQUFBJCQAAAAAAAAAAAEAAADZQdlRcmpkNjc0NDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGABhF9gAYRfM3; BDUSS_BFESS&#x3D;BjRVJYdFQ5TEJKWWNPck1ZcWdOVklMT0JHMHhQMUx3UGxDZjhNMVVhRmdqcXRmSVFBQUFBJCQAAAAAAAAAAAEAAADZQdlRcmpkNjc0NDEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGABhF9gAYRfM3; BAIDUID_BFESS&#x3D;F500721F63FBCA4EDC7DA170AE314FEE:FG&#x3D;1; BDORZ&#x3D;B490B5EBF6F3CD402E515D22BCDA1598; COOKIE_SESSION&#x3D;332523_0_8_0_3_6_1_0_7_4_42_0_332523_0_6_0_1604291277_0_1604291271%7C8%230_0_1604291271%7C1; sug&#x3D;3; sugstore&#x3D;0; ORIGIN&#x3D;0; bdime&#x3D;0; ZD_ENTRY&#x3D;google</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">POST http:&#x2F;&#x2F;202.119.196.6:8080&#x2F;Self&#x2F;login&#x2F;verify HTTP&#x2F;1.1</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Cache-Control: max-age&#x3D;0</span><br><span class=\"line\">Origin: http:&#x2F;&#x2F;202.119.196.6:8080</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">DNT: 1</span><br><span class=\"line\">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class=\"line\">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.111 Safari&#x2F;537.36</span><br><span class=\"line\">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class=\"line\">Referer: http:&#x2F;&#x2F;202.119.196.6:8080&#x2F;Self&#x2F;login&#x2F;?302&#x3D;LI</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class=\"line\">Host: 202.119.196.6:8080</span><br><span class=\"line\">Accept-Encoding: gzip, deflate, br</span><br><span class=\"line\">Content-Length: 60</span><br><span class=\"line\">Cookie: JSESSIONID&#x3D;E56420ED06E0ABE922C5A904DBB9C944</span><br><span class=\"line\"></span><br><span class=\"line\">foo&#x3D;&amp;bar&#x3D;&amp;checkcode&#x3D;1234&amp;account&#x3D;08180000&amp;password&#x3D;md5&amp;code&#x3D;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">HTTP&#x2F;1.1 200 OK</span><br><span class=\"line\">Date: Sat, 31 Dec 2005 23:59:59 GMT</span><br><span class=\"line\">Content-Type: text&#x2F;html;charset&#x3D;ISO-8859-1</span><br><span class=\"line\">Content-Length: 122</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">&lt;title&gt;Wrox Homepage&lt;&#x2F;title&gt;</span><br><span class=\"line\">&lt;&#x2F;head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;!-- body goes here --&gt;</span><br><span class=\"line\">HTTP&#x2F;1.1 200 OK Date: Sat</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br><span class=\"line\">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>\n\n<p>根据这个格式<em>描述一下格式</em> 请求方法 请求路径 HTTP版本</p>\n<p>HEADER部分 需要什么HEADER加入什么</p>\n<p>BODY部分 放入数据</p>\n<p>所根据的这个格式 这个规定就叫做协议 HTTP的规定就是HTTP协议</p>\n<p>所以说你在手机上查询电费也好 电脑上浏览网页也罢 前端调用后端也是如此 只要是HTTP的API 都会将数据按照这个格式进行打包</p>\n<ol>\n<li><strong>建立连接后</strong>   Fiddler监听拦截的数据, 你知道了这个包的数据都有什么 然后自己建立连接发送同样的包 效果是一样的</li>\n<li>发送打包的数据 </li>\n<li>接收服务器返回的结果</li>\n<li>所以可以抓包后模拟请求这就这么来的</li>\n</ol>\n<h1 id=\"从TCP看HTTP\"><a href=\"#从TCP看HTTP\" class=\"headerlink\" title=\"从TCP看HTTP\"></a>从TCP看HTTP</h1><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E4%B8%83%E5%B1%82%E5%92%8C%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE.png\" alt=\"\"></p>\n<p><em>将根据这张图说一说, 经常让了解的 七层和四层协议.  (网络访问(链接)层)</em></p>\n<p>上边面说的建立连接建立的实际是TCP连接</p>\n<p>TCP连接是通过 IP和端口号建立的 正好使用的上面的IP和端口号</p>\n<p>TCP连接干什么?  连接就是传输数据 这就涉及到了读写操作  全双工</p>\n<p>两个套接字之间的通信 客户端持有一个套接字 服务器持有一个套接字 然后客户端的数据发送和服务器端的数据接收就是转化为了针对套接字的读写</p>\n<p>套接字你可以理解为 两个电话互相通话</p>\n<p>套接字的建立和管理都比较复杂, 但是流程极为固定 干脆将这些代码包装起来 对外界提供一个简单的函数即可 内部帮你管理建立TCP连接</p>\n<p>客户端指的就是你的浏览器也好, 你的应用也好 套接字这个核心的东西被包装了起来</p>\n<p>所以输入网址也好, 使用form标签也罢. 最终都是根据HTTP协议包装你想要发送或者接受的数据. 建立TCP连接 然后将包装好的数据发送到套接字 对方从套接字接受 (流, 流水 按顺序流入)</p>\n<p><em>nc 命令 演示演示?</em></p>\n<p>所以你可以没有域名 照样可以使用HTTP协议 照样访问网页.</p>\n<p>因为HTTP交互的核心就是 根据HTTP协议包装数据 经由TCP连接收发数据 TCP连接使用的是 IP和端口号 而非域名</p>\n<p>域名就没有用了吗? 除了便于记忆? <em>域名 区分作用</em></p>\n<h1 id=\"HTTP框架\"><a href=\"#HTTP框架\" class=\"headerlink\" title=\"HTTP框架\"></a>HTTP框架</h1><p>上面说了HTTP交互细节. 本质就是的收发</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET &#x2F;api?a&#x3D;1&amp;b&#x3D;2 HTTP&#x2F;1.1</span><br><span class=\"line\">Host: 10.2.5.251</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">DNT: 1</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.183 Safari&#x2F;537.36</span><br><span class=\"line\">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q&#x3D;0.9,ja;q&#x3D;0.8</span><br><span class=\"line\"></span><br><span class=\"line\">HTTP&#x2F;1.1 200 OK</span><br><span class=\"line\">Date: Sat, 31 Dec 2005 23:59:59 GMT</span><br><span class=\"line\">Content-Type: text&#x2F;html;charset&#x3D;ISO-8859-1</span><br><span class=\"line\">Content-Length: 122</span><br><span class=\"line\"></span><br><span class=\"line\">＜html＞</span><br><span class=\"line\">＜head＞</span><br><span class=\"line\">＜title＞Wrox Homepage＜&#x2F;title＞</span><br><span class=\"line\">＜&#x2F;head＞</span><br><span class=\"line\">＜body＞</span><br><span class=\"line\">＜!-- body goes here --＞</span><br><span class=\"line\">＜&#x2F;body＞</span><br><span class=\"line\">＜&#x2F;html＞</span><br></pre></td></tr></table></figure>\n<p>服务器端从套接字 接收到数据后 大家没有见过上面的东西吧</p>\n<p>那就是框架接受之后 把它们作为字符串存了起来 然后按照HTTP的固定协议格式 将内容解析</p>\n<p>必须解析的一般有 Get /api?a=1&amp;b=2  然后得知了这是一个GET请求 请求的URL是 /api 有两个参数 叫什么 值是多少</p>\n<p>然后根据你服务器代码设定的找到一个对应的函数, 框架调用这个函数 传入参数 你就可以处理相应的逻辑了.</p>\n<h1 id=\"库和框架\"><a href=\"#库和框架\" class=\"headerlink\" title=\"库和框架?\"></a>库和框架?</h1><p>库是帮你提供某些功能的包装, 单个库一般并不能开发完整的应用, 只是作为一部分功能函数. curl库 线程库</p>\n<p>框架可以理解为库的升级版, 你使用一个框架提供的函数 就能开发完整的应用, 大多数框架还能方便的引入其他的库来供自己使用.</p>\n<h1 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx?\"></a>nginx?</h1><p>nginx大家用过没有?</p>\n<p>一般逻辑都是设置一个域名 然后指向一个端口 是不是?</p>\n<p>域名这个东西就藏在了HTTPRequest的 header里 他同样从TCP连接接收数据 解析 便知道了域名 然后根据配置转发即可</p>\n<h1 id=\"要不要学基础知识\"><a href=\"#要不要学基础知识\" class=\"headerlink\" title=\"要不要学基础知识?\"></a>要不要学基础知识?</h1><p>端口 计算机网络 组装nas计网</p>\n<p>网线到内核 操作系统和计算机组成原理</p>\n<h1 id=\"自学能力\"><a href=\"#自学能力\" class=\"headerlink\" title=\"自学能力\"></a>自学能力</h1><p>我大一来的工作室 来的时候是远爷带我学的JavaWeb. </p>\n<p>随便找了本Java书给划一下看哪里</p>\n<p>给我指明了一个框架, 然后呢? 去学呗</p>\n<p>百度-&gt;谷歌中文-&gt;谷歌英文 <a href=\"https://translate.google.cn/\" target=\"_blank\" rel=\"noopener\">https://translate.google.cn/</a></p>\n<p>知乎 百度 谷歌 Github StackOverflow 等等</p>\n<p>遇到问题先百度</p>\n<ul>\n<li>视频?</li>\n<li>看书?</li>\n<li>文档?</li>\n</ul>\n<p>大二转LinuxC++ 全部都是从零开始 没有人带我</p>\n<h1 id=\"大学生\"><a href=\"#大学生\" class=\"headerlink\" title=\"大学生\"></a>大学生</h1><p>垃圾xxxA4 我就是不想学.</p>\n<p>写博客?</p>\n<p>人外有人天外有天</p>\n<p>让自己一天比一天更加优秀 提升自己</p>\n<p>平衡自己时间  爆肝程序<br>社交 我用大二上的社交换到了Linux入门 我退出了xxxx</p>\n<p>大三上减肥(身高), 参加活动, 锻炼身体, 找对象? 规律作息</p>\n<p>穿搭</p>\n<p>多多质疑 乳酸菌饮料?</p>\n<p>不要被轻易带节奏 12:55秒 <a href=\"https://www.bilibili.com/video/BV1jV411o7VV\" target=\"_blank\" rel=\"noopener\">https://www.bilibili.com/video/BV1jV411o7VV</a></p>\n"},{"title":"CPP入门分享","date":"2020-08-28T02:40:39.000Z","img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/ico.png","_content":"\n# 第一次\n\n## 为什么选择的是CPP\n\n学校开设\n- Python\n- CPP\n- xxx\n\n## 目的\n\n课堂讲的肯定比我讲的要好 不过我打算侧重在更加详细的讲某些基础内容 然后主要的是每周的答疑maybe\n\n## 规划\n\n每周五六日中一天 以计算机专业的CPP课本进度 提前讲一部分下周的内容\n\n下一周你遇到的问题的问题私聊我 下周五六日中一天直播的时候讲解\n\n## 独立解决问题的能力\n\n善用搜索引擎\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%B4%A0%E8%B4%A8%E4%BA%94%E8%BF%9E.jpg)\n\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E7%99%BE%E5%BA%A6Or%E9%97%AE%E4%BA%BA.jpg)\n\n当然也不是 所有都要自己找 不去问别人\n\n当你一个问题考虑很久的时候 xxx\n\n\n## 编程难在哪里?\n\n什么是关键字?\n\nhttps://www.runoob.com/w3cnote/cpp-keyword-intro.html\n\n![C++关键字](https://www.runoob.com/wp-content/uploads/2018/06/20130806104900234.jpg)\n\n|||||||\n|-|-|-|-|-|-|\n|if|else|while|for|switch|case|\n|break|continue|return|\n|int|short|char|double|long|float|void|\n|const|static||||\n|delete|new||\n|enum|struct|||\n\n\n思想\n\n有限的关键字 \"无穷\" 的组合\n\n\n## 分享->私人QQ群","source":"_posts/分享学习会-cpp入门.md","raw":"---\ntitle: CPP入门分享\ntags:\n  - null\ncategories:\n  - 分享会\ndate: 2020-08-28 10:40:39\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/ico.png\n---\n\n# 第一次\n\n## 为什么选择的是CPP\n\n学校开设\n- Python\n- CPP\n- xxx\n\n## 目的\n\n课堂讲的肯定比我讲的要好 不过我打算侧重在更加详细的讲某些基础内容 然后主要的是每周的答疑maybe\n\n## 规划\n\n每周五六日中一天 以计算机专业的CPP课本进度 提前讲一部分下周的内容\n\n下一周你遇到的问题的问题私聊我 下周五六日中一天直播的时候讲解\n\n## 独立解决问题的能力\n\n善用搜索引擎\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%B4%A0%E8%B4%A8%E4%BA%94%E8%BF%9E.jpg)\n\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E7%99%BE%E5%BA%A6Or%E9%97%AE%E4%BA%BA.jpg)\n\n当然也不是 所有都要自己找 不去问别人\n\n当你一个问题考虑很久的时候 xxx\n\n\n## 编程难在哪里?\n\n什么是关键字?\n\nhttps://www.runoob.com/w3cnote/cpp-keyword-intro.html\n\n![C++关键字](https://www.runoob.com/wp-content/uploads/2018/06/20130806104900234.jpg)\n\n|||||||\n|-|-|-|-|-|-|\n|if|else|while|for|switch|case|\n|break|continue|return|\n|int|short|char|double|long|float|void|\n|const|static||||\n|delete|new||\n|enum|struct|||\n\n\n思想\n\n有限的关键字 \"无穷\" 的组合\n\n\n## 分享->私人QQ群","slug":"分享学习会-cpp入门","published":1,"updated":"2020-10-28T08:55:57.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6n0020f8unevaecwbs","content":"<h1 id=\"第一次\"><a href=\"#第一次\" class=\"headerlink\" title=\"第一次\"></a>第一次</h1><h2 id=\"为什么选择的是CPP\"><a href=\"#为什么选择的是CPP\" class=\"headerlink\" title=\"为什么选择的是CPP\"></a>为什么选择的是CPP</h2><p>学校开设</p>\n<ul>\n<li>Python</li>\n<li>CPP</li>\n<li>xxx</li>\n</ul>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>课堂讲的肯定比我讲的要好 不过我打算侧重在更加详细的讲某些基础内容 然后主要的是每周的答疑maybe</p>\n<h2 id=\"规划\"><a href=\"#规划\" class=\"headerlink\" title=\"规划\"></a>规划</h2><p>每周五六日中一天 以计算机专业的CPP课本进度 提前讲一部分下周的内容</p>\n<p>下一周你遇到的问题的问题私聊我 下周五六日中一天直播的时候讲解</p>\n<h2 id=\"独立解决问题的能力\"><a href=\"#独立解决问题的能力\" class=\"headerlink\" title=\"独立解决问题的能力\"></a>独立解决问题的能力</h2><p>善用搜索引擎<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%B4%A0%E8%B4%A8%E4%BA%94%E8%BF%9E.jpg\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E7%99%BE%E5%BA%A6Or%E9%97%AE%E4%BA%BA.jpg\" alt=\"\"></p>\n<p>当然也不是 所有都要自己找 不去问别人</p>\n<p>当你一个问题考虑很久的时候 xxx</p>\n<h2 id=\"编程难在哪里\"><a href=\"#编程难在哪里\" class=\"headerlink\" title=\"编程难在哪里?\"></a>编程难在哪里?</h2><p>什么是关键字?</p>\n<p><a href=\"https://www.runoob.com/w3cnote/cpp-keyword-intro.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/w3cnote/cpp-keyword-intro.html</a></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/06/20130806104900234.jpg\" alt=\"C++关键字\"><span class=\"img-alt\">C++关键字</span></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>if</td>\n<td>else</td>\n<td>while</td>\n<td>for</td>\n<td>switch</td>\n<td>case</td>\n</tr>\n<tr>\n<td>break</td>\n<td>continue</td>\n<td>return</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>int</td>\n<td>short</td>\n<td>char</td>\n<td>double</td>\n<td>long</td>\n<td>float</td>\n</tr>\n<tr>\n<td>const</td>\n<td>static</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>delete</td>\n<td>new</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>enum</td>\n<td>struct</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>思想</p>\n<p>有限的关键字 “无穷” 的组合</p>\n<h2 id=\"分享-gt-私人QQ群\"><a href=\"#分享-gt-私人QQ群\" class=\"headerlink\" title=\"分享-&gt;私人QQ群\"></a>分享-&gt;私人QQ群</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第一次\"><a href=\"#第一次\" class=\"headerlink\" title=\"第一次\"></a>第一次</h1><h2 id=\"为什么选择的是CPP\"><a href=\"#为什么选择的是CPP\" class=\"headerlink\" title=\"为什么选择的是CPP\"></a>为什么选择的是CPP</h2><p>学校开设</p>\n<ul>\n<li>Python</li>\n<li>CPP</li>\n<li>xxx</li>\n</ul>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>课堂讲的肯定比我讲的要好 不过我打算侧重在更加详细的讲某些基础内容 然后主要的是每周的答疑maybe</p>\n<h2 id=\"规划\"><a href=\"#规划\" class=\"headerlink\" title=\"规划\"></a>规划</h2><p>每周五六日中一天 以计算机专业的CPP课本进度 提前讲一部分下周的内容</p>\n<p>下一周你遇到的问题的问题私聊我 下周五六日中一天直播的时候讲解</p>\n<h2 id=\"独立解决问题的能力\"><a href=\"#独立解决问题的能力\" class=\"headerlink\" title=\"独立解决问题的能力\"></a>独立解决问题的能力</h2><p>善用搜索引擎<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%B4%A0%E8%B4%A8%E4%BA%94%E8%BF%9E.jpg\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP%E5%88%86%E4%BA%AB%E5%AD%A6%E4%B9%A0%E4%BC%9A/%E7%99%BE%E5%BA%A6Or%E9%97%AE%E4%BA%BA.jpg\" alt=\"\"></p>\n<p>当然也不是 所有都要自己找 不去问别人</p>\n<p>当你一个问题考虑很久的时候 xxx</p>\n<h2 id=\"编程难在哪里\"><a href=\"#编程难在哪里\" class=\"headerlink\" title=\"编程难在哪里?\"></a>编程难在哪里?</h2><p>什么是关键字?</p>\n<p><a href=\"https://www.runoob.com/w3cnote/cpp-keyword-intro.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/w3cnote/cpp-keyword-intro.html</a></p>\n<p><img src=\"https://www.runoob.com/wp-content/uploads/2018/06/20130806104900234.jpg\" alt=\"C++关键字\"></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>if</td>\n<td>else</td>\n<td>while</td>\n<td>for</td>\n<td>switch</td>\n<td>case</td>\n</tr>\n<tr>\n<td>break</td>\n<td>continue</td>\n<td>return</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>int</td>\n<td>short</td>\n<td>char</td>\n<td>double</td>\n<td>long</td>\n<td>float</td>\n</tr>\n<tr>\n<td>const</td>\n<td>static</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>delete</td>\n<td>new</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>enum</td>\n<td>struct</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>思想</p>\n<p>有限的关键字 “无穷” 的组合</p>\n<h2 id=\"分享-gt-私人QQ群\"><a href=\"#分享-gt-私人QQ群\" class=\"headerlink\" title=\"分享-&gt;私人QQ群\"></a>分享-&gt;私人QQ群</h2>"},{"title":"CPP入门分享","date":"2020-09-09T02:40:39.000Z","_content":"\n# 工具\n\nFiddler 截获HTTP请求包\nPostman 测试接口与生成代码\nChrome+SwitchyOmega插件\n\n安装见视频\n\n\n# 配置Fiddler\n\nTools->Options->HTTPS 勾选Decrypt HTTPS traffic 确认安装证书\n\nTools->Options->Connections 勾选Allow remote computer xxxx\n\n记下 Connections中的端口号 默认为8888\n\n# 配置SwitchyOmega插件\n\n新增情景模式->选择代理服务器\n\n代理协议HTTP 代理服务器 127.0.0.1 端口 8888","source":"_posts/分享学习会-抓取接口.md","raw":"---\ntitle: CPP入门分享\ntags:\n  - null\ncategories:\n  - 分享会\ndate: 2020-09-09 10:40:39\n---\n\n# 工具\n\nFiddler 截获HTTP请求包\nPostman 测试接口与生成代码\nChrome+SwitchyOmega插件\n\n安装见视频\n\n\n# 配置Fiddler\n\nTools->Options->HTTPS 勾选Decrypt HTTPS traffic 确认安装证书\n\nTools->Options->Connections 勾选Allow remote computer xxxx\n\n记下 Connections中的端口号 默认为8888\n\n# 配置SwitchyOmega插件\n\n新增情景模式->选择代理服务器\n\n代理协议HTTP 代理服务器 127.0.0.1 端口 8888","slug":"分享学习会-抓取接口","published":1,"updated":"2020-10-28T08:55:57.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6o0021f8unejqd8dea","content":"<h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><p>Fiddler 截获HTTP请求包<br>Postman 测试接口与生成代码<br>Chrome+SwitchyOmega插件</p>\n<p>安装见视频</p>\n<h1 id=\"配置Fiddler\"><a href=\"#配置Fiddler\" class=\"headerlink\" title=\"配置Fiddler\"></a>配置Fiddler</h1><p>Tools-&gt;Options-&gt;HTTPS 勾选Decrypt HTTPS traffic 确认安装证书</p>\n<p>Tools-&gt;Options-&gt;Connections 勾选Allow remote computer xxxx</p>\n<p>记下 Connections中的端口号 默认为8888</p>\n<h1 id=\"配置SwitchyOmega插件\"><a href=\"#配置SwitchyOmega插件\" class=\"headerlink\" title=\"配置SwitchyOmega插件\"></a>配置SwitchyOmega插件</h1><p>新增情景模式-&gt;选择代理服务器</p>\n<p>代理协议HTTP 代理服务器 127.0.0.1 端口 8888</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h1><p>Fiddler 截获HTTP请求包<br>Postman 测试接口与生成代码<br>Chrome+SwitchyOmega插件</p>\n<p>安装见视频</p>\n<h1 id=\"配置Fiddler\"><a href=\"#配置Fiddler\" class=\"headerlink\" title=\"配置Fiddler\"></a>配置Fiddler</h1><p>Tools-&gt;Options-&gt;HTTPS 勾选Decrypt HTTPS traffic 确认安装证书</p>\n<p>Tools-&gt;Options-&gt;Connections 勾选Allow remote computer xxxx</p>\n<p>记下 Connections中的端口号 默认为8888</p>\n<h1 id=\"配置SwitchyOmega插件\"><a href=\"#配置SwitchyOmega插件\" class=\"headerlink\" title=\"配置SwitchyOmega插件\"></a>配置SwitchyOmega插件</h1><p>新增情景模式-&gt;选择代理服务器</p>\n<p>代理协议HTTP 代理服务器 127.0.0.1 端口 8888</p>\n"},{"title":"力扣11.24-N3.无重复字符的最长子串","date":"2020-11-24T10:50:02.000Z","_content":"\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n示例 1:\n```\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n示例 2:\n```\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n示例 3:\n```\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n# 代码1\n```c++\nclass Solution {\npublic:\nint lengthOfLongestSubstring(string s)\n{\n    bool char_flag[128]; // 记录字符是否出现过\n    int char_sub[128]; // 记录字符下标\n    memset(char_flag, false, sizeof char_flag);\n    int max_result = 0;\n    int begin_sub = 0;\n\n    int sub = 0;\n    while (sub < s.length())\n    {\n        char current_char = s[sub];\n\n        if (char_flag[current_char])\n        {\n            if (sub - begin_sub > max_result)\n            {\n                max_result = sub - begin_sub;\n            }\n\n            for (int i = begin_sub; i < char_sub[current_char]; ++i)\n            {\n                char_flag[s[i]] = false;\n            }\n            begin_sub = char_sub[current_char] + 1;\n            char_sub[current_char] = sub;\n        }\n        else\n        {\n            char_sub[current_char] = sub;\n            char_flag[current_char] = true;\n        }\n\n        sub++;\n        if (sub == s.length())\n        {\n            if (sub - begin_sub > max_result)\n            {\n                max_result = sub - begin_sub;\n            }\n        }\n\n    }\n\n    return max_result;\n}\n};\n```\n\n思路是按顺序读取char, 如果没有出现过则标记出现记录下标.\n\n如果出现了则用当前下标减去开始下标判断是否更长来记录, 同时更新开始下标为重复字符的下标后一个字符下标.\n\n移动开始下标后 需要取消 新开始标记和旧开始标记之前的char标记\n\n\n# 样例代码\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s)\n    {\n        int heap[128] = {0};\n        int res = 0;\n        for(int i = 0, j = 0; j < s.size(); ++j)\n        {\n            heap[s[j]]++; // 标记字符出现\n            while(heap[s[j]] > 1) // 再次出现\n            {\n              /*\n              开始符号标记下标 向前滑动 1 将开始下标的字符滑动出去\n              如果滑出去的字符是本次遇到的重复字符 则继续 否则一直滑动到重复字符位置\n              */\n                heap[s[i]]--;\n                i++;\n            }\n            res = max(res, j - i + 1);\n        }\n        return res;\n    }\n};\n```\n\n首先看上去 代码就非常的短 我的写了40行而这个仅有10行\n\n# 改进\n\n我的虽然不是一次滑动一个字符 而是滑动一步到位. 但是仍需要一个for循环来去掉滑出的字符. 所以同样例代码思想.\n\n所以没有必要一次滑动到位, 反正for循环需要执行就在for之中慢慢滑动. `这样可以省去记录字符出现的下标`\n\n我字符出现记录使用的bool数组然而使用`int数组却能包含更多的信息`.\n\n我原版代码需要额外判定一次是否到了尾部, 当最后一个字符没有重复的时候 循环就结束了.","source":"_posts/力扣11.24-N3.无重复字符的最长子串.md","raw":"---\ntitle: 力扣11.24-N3.无重复字符的最长子串\ntags:\n  - 递归分治\ncategories:\n  - 力扣每日一题\ndate: 2020-11-24 18:50:02\n---\n\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n示例 1:\n```\n输入: \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n```\n示例 2:\n```\n输入: \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n示例 3:\n```\n输入: \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n# 代码1\n```c++\nclass Solution {\npublic:\nint lengthOfLongestSubstring(string s)\n{\n    bool char_flag[128]; // 记录字符是否出现过\n    int char_sub[128]; // 记录字符下标\n    memset(char_flag, false, sizeof char_flag);\n    int max_result = 0;\n    int begin_sub = 0;\n\n    int sub = 0;\n    while (sub < s.length())\n    {\n        char current_char = s[sub];\n\n        if (char_flag[current_char])\n        {\n            if (sub - begin_sub > max_result)\n            {\n                max_result = sub - begin_sub;\n            }\n\n            for (int i = begin_sub; i < char_sub[current_char]; ++i)\n            {\n                char_flag[s[i]] = false;\n            }\n            begin_sub = char_sub[current_char] + 1;\n            char_sub[current_char] = sub;\n        }\n        else\n        {\n            char_sub[current_char] = sub;\n            char_flag[current_char] = true;\n        }\n\n        sub++;\n        if (sub == s.length())\n        {\n            if (sub - begin_sub > max_result)\n            {\n                max_result = sub - begin_sub;\n            }\n        }\n\n    }\n\n    return max_result;\n}\n};\n```\n\n思路是按顺序读取char, 如果没有出现过则标记出现记录下标.\n\n如果出现了则用当前下标减去开始下标判断是否更长来记录, 同时更新开始下标为重复字符的下标后一个字符下标.\n\n移动开始下标后 需要取消 新开始标记和旧开始标记之前的char标记\n\n\n# 样例代码\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s)\n    {\n        int heap[128] = {0};\n        int res = 0;\n        for(int i = 0, j = 0; j < s.size(); ++j)\n        {\n            heap[s[j]]++; // 标记字符出现\n            while(heap[s[j]] > 1) // 再次出现\n            {\n              /*\n              开始符号标记下标 向前滑动 1 将开始下标的字符滑动出去\n              如果滑出去的字符是本次遇到的重复字符 则继续 否则一直滑动到重复字符位置\n              */\n                heap[s[i]]--;\n                i++;\n            }\n            res = max(res, j - i + 1);\n        }\n        return res;\n    }\n};\n```\n\n首先看上去 代码就非常的短 我的写了40行而这个仅有10行\n\n# 改进\n\n我的虽然不是一次滑动一个字符 而是滑动一步到位. 但是仍需要一个for循环来去掉滑出的字符. 所以同样例代码思想.\n\n所以没有必要一次滑动到位, 反正for循环需要执行就在for之中慢慢滑动. `这样可以省去记录字符出现的下标`\n\n我字符出现记录使用的bool数组然而使用`int数组却能包含更多的信息`.\n\n我原版代码需要额外判定一次是否到了尾部, 当最后一个字符没有重复的时候 循环就结束了.","slug":"力扣11.24-N3.无重复字符的最长子串","published":1,"updated":"2020-12-03T04:39:02.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6p0025f8un2yvz2pml","content":"<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;abcabcbb&quot;</span><br><span class=\"line\">输出: 3 </span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;bbbbb&quot;</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;pwwkew&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class=\"line\">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h1 id=\"代码1\"><a href=\"#代码1\" class=\"headerlink\" title=\"代码1\"></a>代码1</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> char_flag[<span class=\"number\">128</span>]; <span class=\"comment\">// 记录字符是否出现过</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> char_sub[<span class=\"number\">128</span>]; <span class=\"comment\">// 记录字符下标</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(char_flag, <span class=\"literal\">false</span>, <span class=\"keyword\">sizeof</span> char_flag);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> begin_sub = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sub = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (sub &lt; s.length())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> current_char = s[sub];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (char_flag[current_char])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sub - begin_sub &gt; max_result)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                max_result = sub - begin_sub;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = begin_sub; i &lt; char_sub[current_char]; ++i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                char_flag[s[i]] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            begin_sub = char_sub[current_char] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            char_sub[current_char] = sub;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            char_sub[current_char] = sub;</span><br><span class=\"line\">            char_flag[current_char] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sub++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sub == s.length())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sub - begin_sub &gt; max_result)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                max_result = sub - begin_sub;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>思路是按顺序读取char, 如果没有出现过则标记出现记录下标.</p>\n<p>如果出现了则用当前下标减去开始下标判断是否更长来记录, 同时更新开始下标为重复字符的下标后一个字符下标.</p>\n<p>移动开始下标后 需要取消 新开始标记和旧开始标记之前的char标记</p>\n<h1 id=\"样例代码\"><a href=\"#样例代码\" class=\"headerlink\" title=\"样例代码\"></a>样例代码</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> heap[<span class=\"number\">128</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; j &lt; s.<span class=\"built_in\">size</span>(); ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            heap[s[j]]++; <span class=\"comment\">// 标记字符出现</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(heap[s[j]] &gt; <span class=\"number\">1</span>) <span class=\"comment\">// 再次出现</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">              开始符号标记下标 向前滑动 1 将开始下标的字符滑动出去</span></span><br><span class=\"line\"><span class=\"comment\">              如果滑出去的字符是本次遇到的重复字符 则继续 否则一直滑动到重复字符位置</span></span><br><span class=\"line\"><span class=\"comment\">              */</span></span><br><span class=\"line\">                heap[s[i]]--;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, j - i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>首先看上去 代码就非常的短 我的写了40行而这个仅有10行</p>\n<h1 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h1><p>我的虽然不是一次滑动一个字符 而是滑动一步到位. 但是仍需要一个for循环来去掉滑出的字符. 所以同样例代码思想.</p>\n<p>所以没有必要一次滑动到位, 反正for循环需要执行就在for之中慢慢滑动. <code>这样可以省去记录字符出现的下标</code></p>\n<p>我字符出现记录使用的bool数组然而使用<code>int数组却能包含更多的信息</code>.</p>\n<p>我原版代码需要额外判定一次是否到了尾部, 当最后一个字符没有重复的时候 循环就结束了.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;abcabcbb&quot;</span><br><span class=\"line\">输出: 3 </span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;bbbbb&quot;</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;pwwkew&quot;</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class=\"line\">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h1 id=\"代码1\"><a href=\"#代码1\" class=\"headerlink\" title=\"代码1\"></a>代码1</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> char_flag[<span class=\"number\">128</span>]; <span class=\"comment\">// 记录字符是否出现过</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> char_sub[<span class=\"number\">128</span>]; <span class=\"comment\">// 记录字符下标</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(char_flag, <span class=\"literal\">false</span>, <span class=\"keyword\">sizeof</span> char_flag);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> begin_sub = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sub = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (sub &lt; s.length())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> current_char = s[sub];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (char_flag[current_char])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sub - begin_sub &gt; max_result)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                max_result = sub - begin_sub;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = begin_sub; i &lt; char_sub[current_char]; ++i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                char_flag[s[i]] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            begin_sub = char_sub[current_char] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            char_sub[current_char] = sub;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            char_sub[current_char] = sub;</span><br><span class=\"line\">            char_flag[current_char] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sub++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sub == s.length())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sub - begin_sub &gt; max_result)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                max_result = sub - begin_sub;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> max_result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>思路是按顺序读取char, 如果没有出现过则标记出现记录下标.</p>\n<p>如果出现了则用当前下标减去开始下标判断是否更长来记录, 同时更新开始下标为重复字符的下标后一个字符下标.</p>\n<p>移动开始下标后 需要取消 新开始标记和旧开始标记之前的char标记</p>\n<h1 id=\"样例代码\"><a href=\"#样例代码\" class=\"headerlink\" title=\"样例代码\"></a>样例代码</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> heap[<span class=\"number\">128</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; j &lt; s.<span class=\"built_in\">size</span>(); ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            heap[s[j]]++; <span class=\"comment\">// 标记字符出现</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(heap[s[j]] &gt; <span class=\"number\">1</span>) <span class=\"comment\">// 再次出现</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">              开始符号标记下标 向前滑动 1 将开始下标的字符滑动出去</span></span><br><span class=\"line\"><span class=\"comment\">              如果滑出去的字符是本次遇到的重复字符 则继续 否则一直滑动到重复字符位置</span></span><br><span class=\"line\"><span class=\"comment\">              */</span></span><br><span class=\"line\">                heap[s[i]]--;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = <span class=\"built_in\">max</span>(res, j - i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>首先看上去 代码就非常的短 我的写了40行而这个仅有10行</p>\n<h1 id=\"改进\"><a href=\"#改进\" class=\"headerlink\" title=\"改进\"></a>改进</h1><p>我的虽然不是一次滑动一个字符 而是滑动一步到位. 但是仍需要一个for循环来去掉滑出的字符. 所以同样例代码思想.</p>\n<p>所以没有必要一次滑动到位, 反正for循环需要执行就在for之中慢慢滑动. <code>这样可以省去记录字符出现的下标</code></p>\n<p>我字符出现记录使用的bool数组然而使用<code>int数组却能包含更多的信息</code>.</p>\n<p>我原版代码需要额外判定一次是否到了尾部, 当最后一个字符没有重复的时候 循环就结束了.</p>\n"},{"title":"力扣11.25-N34.在排序数组中查找元素的第一个和最后一个位置","date":"2020-11-25T10:50:02.000Z","_content":"\n# N34.在排序数组中查找元素的第一个和最后一个位置\n\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n\n你的算法时间复杂度必须是 O(log n) 级别。\n\n如果数组中不存在目标值，返回 [-1, -1]。\n\n示例 1:\n```\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: [3,4]\n```\n示例 2:\n```\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: [-1,-1]\n```\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n## 代码1\n```c++\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target)\n    {\n        int left = 0;\n        int right = nums.size();\n\n        while (left < right)\n        {\n            int sub = (right + left) >> 1;\n            if (target == nums[sub])\n            {\n                int l_sub, r_sub;\n                for (l_sub = sub - 1; l_sub >=0 && nums[l_sub] == target; --l_sub)\n                {\n                   \n                }\n                for (r_sub = sub + 1; r_sub <= nums.size() - 1 && nums[r_sub] == target; ++r_sub)\n                {\n                    \n                }\n                return {l_sub + 1, r_sub - 1};\n            }\n            else if (target < nums[sub])\n            {\n                right = sub;\n            }\n            else\n            {\n                left = sub + 1;\n            }\n        }\n\n        return {-1, -1};\n    }\n};\n```\n\n思路使用二分搜索找到目标元素 然后想左右扩散寻找边界\n\n# 剑指 Offer 53 - I. 在排序数组中查找数字 I\n\n统计一个数字在排序数组中出现的次数。\n\n \n\n示例 1:\n```\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: 2\n```\n示例 2:\n```\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: 0\n```\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n## 代码1\n\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target)\n    {\n        int left = 0;\n        int right = nums.size();\n\n        while (left < right)\n        {\n            int sub = (right + left) >> 1;\n            if (target == nums[sub])\n            {\n                int result = 1;\n                for (int l_sub = sub - 1; l_sub >=0 && nums[l_sub] == target; --l_sub)\n                {\n                    ++result;\n                }\n                for (int r_sub = sub + 1; r_sub <= nums.size() - 1 && nums[r_sub] == target; ++r_sub)\n                {\n                    ++result;\n                }\n                return result;\n            }\n            else if (target < nums[sub])\n            {\n                right = sub;\n            }\n            else\n            {\n                left = sub + 1;\n            }\n        }\n\n        return 0;\n    }\n};\n```\n\n思路同上, 返回值不同","source":"_posts/力扣11.25-N34.在排序数组中查找元素的第一个和最后一个位置.md","raw":"---\ntitle: 力扣11.25-N34.在排序数组中查找元素的第一个和最后一个位置\ntags:\n  - 递归分治\ncategories:\n  - 力扣每日一题\ndate: 2020-11-25 18:50:02\n---\n\n# N34.在排序数组中查找元素的第一个和最后一个位置\n\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n\n你的算法时间复杂度必须是 O(log n) 级别。\n\n如果数组中不存在目标值，返回 [-1, -1]。\n\n示例 1:\n```\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: [3,4]\n```\n示例 2:\n```\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: [-1,-1]\n```\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n## 代码1\n```c++\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target)\n    {\n        int left = 0;\n        int right = nums.size();\n\n        while (left < right)\n        {\n            int sub = (right + left) >> 1;\n            if (target == nums[sub])\n            {\n                int l_sub, r_sub;\n                for (l_sub = sub - 1; l_sub >=0 && nums[l_sub] == target; --l_sub)\n                {\n                   \n                }\n                for (r_sub = sub + 1; r_sub <= nums.size() - 1 && nums[r_sub] == target; ++r_sub)\n                {\n                    \n                }\n                return {l_sub + 1, r_sub - 1};\n            }\n            else if (target < nums[sub])\n            {\n                right = sub;\n            }\n            else\n            {\n                left = sub + 1;\n            }\n        }\n\n        return {-1, -1};\n    }\n};\n```\n\n思路使用二分搜索找到目标元素 然后想左右扩散寻找边界\n\n# 剑指 Offer 53 - I. 在排序数组中查找数字 I\n\n统计一个数字在排序数组中出现的次数。\n\n \n\n示例 1:\n```\n输入: nums = [5,7,7,8,8,10], target = 8\n输出: 2\n```\n示例 2:\n```\n输入: nums = [5,7,7,8,8,10], target = 6\n输出: 0\n```\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n## 代码1\n\n```c++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target)\n    {\n        int left = 0;\n        int right = nums.size();\n\n        while (left < right)\n        {\n            int sub = (right + left) >> 1;\n            if (target == nums[sub])\n            {\n                int result = 1;\n                for (int l_sub = sub - 1; l_sub >=0 && nums[l_sub] == target; --l_sub)\n                {\n                    ++result;\n                }\n                for (int r_sub = sub + 1; r_sub <= nums.size() - 1 && nums[r_sub] == target; ++r_sub)\n                {\n                    ++result;\n                }\n                return result;\n            }\n            else if (target < nums[sub])\n            {\n                right = sub;\n            }\n            else\n            {\n                left = sub + 1;\n            }\n        }\n\n        return 0;\n    }\n};\n```\n\n思路同上, 返回值不同","slug":"力扣11.25-N34.在排序数组中查找元素的第一个和最后一个位置","published":1,"updated":"2020-12-03T04:39:21.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6p0027f8un13e9alc0","content":"<h1 id=\"N34-在排序数组中查找元素的第一个和最后一个位置\"><a href=\"#N34-在排序数组中查找元素的第一个和最后一个位置\" class=\"headerlink\" title=\"N34.在排序数组中查找元素的第一个和最后一个位置\"></a>N34.在排序数组中查找元素的第一个和最后一个位置</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>\n<p>你的算法时间复杂度必须是 O(log n) 级别。</p>\n<p>如果数组中不存在目标值，返回 [-1, -1]。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class=\"line\">输出: [3,4]</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class=\"line\">输出: [-1,-1]</span><br></pre></td></tr></table></figure>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"代码1\"><a href=\"#代码1\" class=\"headerlink\" title=\"代码1\"></a>代码1</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">searchRange</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sub = (right + left) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target == nums[sub])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> l_sub, r_sub;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (l_sub = sub - <span class=\"number\">1</span>; l_sub &gt;=<span class=\"number\">0</span> &amp;&amp; nums[l_sub] == target; --l_sub)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                   </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (r_sub = sub + <span class=\"number\">1</span>; r_sub &lt;= nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span> &amp;&amp; nums[r_sub] == target; ++r_sub)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;l_sub + <span class=\"number\">1</span>, r_sub - <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[sub])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                right = sub;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                left = sub + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>思路使用二分搜索找到目标元素 然后想左右扩散寻找边界</p>\n<h1 id=\"剑指-Offer-53-I-在排序数组中查找数字-I\"><a href=\"#剑指-Offer-53-I-在排序数组中查找数字-I\" class=\"headerlink\" title=\"剑指 Offer 53 - I. 在排序数组中查找数字 I\"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I</h1><p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class=\"line\">输出: 2</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></table></figure>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"代码1-1\"><a href=\"#代码1-1\" class=\"headerlink\" title=\"代码1\"></a>代码1</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sub = (right + left) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target == nums[sub])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> result = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> l_sub = sub - <span class=\"number\">1</span>; l_sub &gt;=<span class=\"number\">0</span> &amp;&amp; nums[l_sub] == target; --l_sub)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ++result;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r_sub = sub + <span class=\"number\">1</span>; r_sub &lt;= nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span> &amp;&amp; nums[r_sub] == target; ++r_sub)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ++result;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[sub])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                right = sub;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                left = sub + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>思路同上, 返回值不同</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"N34-在排序数组中查找元素的第一个和最后一个位置\"><a href=\"#N34-在排序数组中查找元素的第一个和最后一个位置\" class=\"headerlink\" title=\"N34.在排序数组中查找元素的第一个和最后一个位置\"></a>N34.在排序数组中查找元素的第一个和最后一个位置</h1><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>\n<p>你的算法时间复杂度必须是 O(log n) 级别。</p>\n<p>如果数组中不存在目标值，返回 [-1, -1]。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class=\"line\">输出: [3,4]</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class=\"line\">输出: [-1,-1]</span><br></pre></td></tr></table></figure>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"代码1\"><a href=\"#代码1\" class=\"headerlink\" title=\"代码1\"></a>代码1</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">searchRange</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sub = (right + left) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target == nums[sub])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> l_sub, r_sub;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (l_sub = sub - <span class=\"number\">1</span>; l_sub &gt;=<span class=\"number\">0</span> &amp;&amp; nums[l_sub] == target; --l_sub)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                   </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (r_sub = sub + <span class=\"number\">1</span>; r_sub &lt;= nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span> &amp;&amp; nums[r_sub] == target; ++r_sub)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;l_sub + <span class=\"number\">1</span>, r_sub - <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[sub])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                right = sub;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                left = sub + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;<span class=\"number\">-1</span>, <span class=\"number\">-1</span>&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>思路使用二分搜索找到目标元素 然后想左右扩散寻找边界</p>\n<h1 id=\"剑指-Offer-53-I-在排序数组中查找数字-I\"><a href=\"#剑指-Offer-53-I-在排序数组中查找数字-I\" class=\"headerlink\" title=\"剑指 Offer 53 - I. 在排序数组中查找数字 I\"></a>剑指 Offer 53 - I. 在排序数组中查找数字 I</h1><p>统计一个数字在排序数组中出现的次数。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class=\"line\">输出: 2</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></table></figure>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"代码1-1\"><a href=\"#代码1-1\" class=\"headerlink\" title=\"代码1\"></a>代码1</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">search</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sub = (right + left) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (target == nums[sub])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> result = <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> l_sub = sub - <span class=\"number\">1</span>; l_sub &gt;=<span class=\"number\">0</span> &amp;&amp; nums[l_sub] == target; --l_sub)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ++result;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> r_sub = sub + <span class=\"number\">1</span>; r_sub &lt;= nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span> &amp;&amp; nums[r_sub] == target; ++r_sub)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ++result;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; nums[sub])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                right = sub;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                left = sub + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>思路同上, 返回值不同</p>\n"},{"title":"力扣12.3-N1143.最长公共子序列","date":"2020-12-03T08:25:02.000Z","_content":"\n# 最长公共子序列\n\n给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。\n\n一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n例如，\"ace\" 是 \"abcde\" 的子序列，但 \"aec\" 不是 \"abcde\" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。\n\n若这两个字符串没有公共子序列，则返回 0。\n\n \n\n示例 1:\n```\n输入：text1 = \"abcde\", text2 = \"ace\" \n输出：3  \n解释：最长公共子序列是 \"ace\"，它的长度为 3。\n```\n示例 2:\n```\n输入：text1 = \"abc\", text2 = \"abc\"\n输出：3\n解释：最长公共子序列是 \"abc\"，它的长度为 3。\n```\n示例 3:\n```\n输入：text1 = \"abc\", text2 = \"def\"\n输出：0\n解释：两个字符串没有公共子序列，返回 0。\n```\n\n提示:\n```\n1 <= text1.length <= 1000\n1 <= text2.length <= 1000\n输入的字符串只含有小写英文字符。\n```\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-common-subsequence\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n## 代码1\n```c++\n    int longest(const std::string& text1, const std::string& text2, \n        int text1_sub, int text2_sub)\n    {\n        if (text1_sub >= text1.length() || text2_sub >= text2.length())\n        {\n            return 0;\n        }\n        if (text1[text1_sub] == text2[text2_sub])\n        {\n            return 1 + longest(text1, text2, text1_sub + 1, text2_sub + 1);\n        }\n        else\n        {\n            return max(longest(text1, text2, text1_sub + 1, text2_sub), \n                        longest(text1, text2, text1_sub, text2_sub + 1));\n        }\n    }\n\n    int longestCommonSubsequence(string text1, string text2)\n    {\n        return longest(text1, text2, 0, 0);\n    }\n```\n\n最简单的思路 然而会超时\n\n## 代码2 动态规划\n\n```c++\nint longestCommonSubsequence(string text1, string text2)\n    {\n        int result[1005][1005]{};\n\n        for (int i1 = 0; i1 < text1.length(); ++i1)\n        {\n            for (int i2 = 0; i2 < text2.length(); ++i2)\n            {\n                if (text1[i1] == text2[i2])\n                {\n                    result[i1 + 1][i2 + 1] = result[i1][i2] + 1;\n                }\n                else\n                {\n                    result[i1 + 1][i2 + 1] = max(result[i1][i2 + 1], result[i1 + 1][i2]);\n                }\n            }\n        }\n        return result[text1.length()][text2.length()];\n    }\n```\n\n设text1和text2的解是T\n\n- 如果text1和text2的最后两个字符相等, 则T的最后一个字符也是这个字符\n\n这样 text1和text2分别去掉最后一个字符后, T去掉最后一个字符后的T1 是前面两个新字符串的最长公共子序列\n\n- 如果最后两个字符不同, 则T可能是text1去掉最后一个字符后和text2的最长公共子序列 也可能是text2去掉最后一个字符后和text1的最长公共子序列\n\n这个可以循环下去, 直到最后两个字符相等 转入上方过程\n\n\n由于存在多种可能便需要设置result数组存储中间结果`result[i][j]`是text1前i个字符和text2前j个字符的最长公共子序列长度\n\n数组填充方式 为上方描述的逆过程. \n\n- 如果i1 i2所指字符相同 `result[i][j]`结果是`result[i - 1][j - 1] + 1`\n表示的是text1前i-1字符和text2前j-1字符最长公共子序列 加上 这个相同的字符 得到前i和前j的最长公共子序列\n\n- 如果所指字符不同则`result[i][j]`可能是`result[i][j - 1]` 也可能是`result[i][j - 1]`取最大值\n表示的是前ij的最长公共子序列是 text1前i字符和text2前j-1字符最长公共子序列 或者是 前i-1和前j的最长公共子序列\n\n最终得到结果`result[text1.length()][text2.length()]` 表示前length1和前length2的最长公共子序列","source":"_posts/力扣12.3-N1143.最长公共子序列.md","raw":"---\ntitle: 力扣12.3-N1143.最长公共子序列\ntags:\n  - 动态规划\ncategories:\n  - 力扣每日一题\ndate: 2020-12-3 16:25:02\n---\n\n# 最长公共子序列\n\n给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。\n\n一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n例如，\"ace\" 是 \"abcde\" 的子序列，但 \"aec\" 不是 \"abcde\" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。\n\n若这两个字符串没有公共子序列，则返回 0。\n\n \n\n示例 1:\n```\n输入：text1 = \"abcde\", text2 = \"ace\" \n输出：3  \n解释：最长公共子序列是 \"ace\"，它的长度为 3。\n```\n示例 2:\n```\n输入：text1 = \"abc\", text2 = \"abc\"\n输出：3\n解释：最长公共子序列是 \"abc\"，它的长度为 3。\n```\n示例 3:\n```\n输入：text1 = \"abc\", text2 = \"def\"\n输出：0\n解释：两个字符串没有公共子序列，返回 0。\n```\n\n提示:\n```\n1 <= text1.length <= 1000\n1 <= text2.length <= 1000\n输入的字符串只含有小写英文字符。\n```\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-common-subsequence\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n## 代码1\n```c++\n    int longest(const std::string& text1, const std::string& text2, \n        int text1_sub, int text2_sub)\n    {\n        if (text1_sub >= text1.length() || text2_sub >= text2.length())\n        {\n            return 0;\n        }\n        if (text1[text1_sub] == text2[text2_sub])\n        {\n            return 1 + longest(text1, text2, text1_sub + 1, text2_sub + 1);\n        }\n        else\n        {\n            return max(longest(text1, text2, text1_sub + 1, text2_sub), \n                        longest(text1, text2, text1_sub, text2_sub + 1));\n        }\n    }\n\n    int longestCommonSubsequence(string text1, string text2)\n    {\n        return longest(text1, text2, 0, 0);\n    }\n```\n\n最简单的思路 然而会超时\n\n## 代码2 动态规划\n\n```c++\nint longestCommonSubsequence(string text1, string text2)\n    {\n        int result[1005][1005]{};\n\n        for (int i1 = 0; i1 < text1.length(); ++i1)\n        {\n            for (int i2 = 0; i2 < text2.length(); ++i2)\n            {\n                if (text1[i1] == text2[i2])\n                {\n                    result[i1 + 1][i2 + 1] = result[i1][i2] + 1;\n                }\n                else\n                {\n                    result[i1 + 1][i2 + 1] = max(result[i1][i2 + 1], result[i1 + 1][i2]);\n                }\n            }\n        }\n        return result[text1.length()][text2.length()];\n    }\n```\n\n设text1和text2的解是T\n\n- 如果text1和text2的最后两个字符相等, 则T的最后一个字符也是这个字符\n\n这样 text1和text2分别去掉最后一个字符后, T去掉最后一个字符后的T1 是前面两个新字符串的最长公共子序列\n\n- 如果最后两个字符不同, 则T可能是text1去掉最后一个字符后和text2的最长公共子序列 也可能是text2去掉最后一个字符后和text1的最长公共子序列\n\n这个可以循环下去, 直到最后两个字符相等 转入上方过程\n\n\n由于存在多种可能便需要设置result数组存储中间结果`result[i][j]`是text1前i个字符和text2前j个字符的最长公共子序列长度\n\n数组填充方式 为上方描述的逆过程. \n\n- 如果i1 i2所指字符相同 `result[i][j]`结果是`result[i - 1][j - 1] + 1`\n表示的是text1前i-1字符和text2前j-1字符最长公共子序列 加上 这个相同的字符 得到前i和前j的最长公共子序列\n\n- 如果所指字符不同则`result[i][j]`可能是`result[i][j - 1]` 也可能是`result[i][j - 1]`取最大值\n表示的是前ij的最长公共子序列是 text1前i字符和text2前j-1字符最长公共子序列 或者是 前i-1和前j的最长公共子序列\n\n最终得到结果`result[text1.length()][text2.length()]` 表示前length1和前length2的最长公共子序列","slug":"力扣12.3-N1143.最长公共子序列","published":1,"updated":"2020-12-04T00:29:00.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6q002af8unel6s9auc","content":"<h1 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h1><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>\n<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>\n<p>若这两个字符串没有公共子序列，则返回 0。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class=\"line\">输出：3  </span><br><span class=\"line\">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：两个字符串没有公共子序列，返回 0。</span><br></pre></td></tr></table></figure>\n\n<p>提示:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;&#x3D; text1.length &lt;&#x3D; 1000</span><br><span class=\"line\">1 &lt;&#x3D; text2.length &lt;&#x3D; 1000</span><br><span class=\"line\">输入的字符串只含有小写英文字符。</span><br></pre></td></tr></table></figure>\n\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/longest-common-subsequence\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-common-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"代码1\"><a href=\"#代码1\" class=\"headerlink\" title=\"代码1\"></a>代码1</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longest</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; text1, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; text2, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">int</span> text1_sub, <span class=\"keyword\">int</span> text2_sub)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (text1_sub &gt;= text1.length() || text2_sub &gt;= text2.length())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (text1[text1_sub] == text2[text2_sub])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> + longest(text1, text2, text1_sub + <span class=\"number\">1</span>, text2_sub + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(longest(text1, text2, text1_sub + <span class=\"number\">1</span>, text2_sub), </span><br><span class=\"line\">                    longest(text1, text2, text1_sub, text2_sub + <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(<span class=\"built_in\">string</span> text1, <span class=\"built_in\">string</span> text2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> longest(text1, text2, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最简单的思路 然而会超时</p>\n<h2 id=\"代码2-动态规划\"><a href=\"#代码2-动态规划\" class=\"headerlink\" title=\"代码2 动态规划\"></a>代码2 动态规划</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(<span class=\"built_in\">string</span> text1, <span class=\"built_in\">string</span> text2)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>]&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i1 = <span class=\"number\">0</span>; i1 &lt; text1.length(); ++i1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i2 = <span class=\"number\">0</span>; i2 &lt; text2.length(); ++i2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (text1[i1] == text2[i2])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    result[i1 + <span class=\"number\">1</span>][i2 + <span class=\"number\">1</span>] = result[i1][i2] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    result[i1 + <span class=\"number\">1</span>][i2 + <span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(result[i1][i2 + <span class=\"number\">1</span>], result[i1 + <span class=\"number\">1</span>][i2]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result[text1.length()][text2.length()];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>设text1和text2的解是T</p>\n<ul>\n<li>如果text1和text2的最后两个字符相等, 则T的最后一个字符也是这个字符</li>\n</ul>\n<p>这样 text1和text2分别去掉最后一个字符后, T去掉最后一个字符后的T1 是前面两个新字符串的最长公共子序列</p>\n<ul>\n<li>如果最后两个字符不同, 则T可能是text1去掉最后一个字符后和text2的最长公共子序列 也可能是text2去掉最后一个字符后和text1的最长公共子序列</li>\n</ul>\n<p>这个可以循环下去, 直到最后两个字符相等 转入上方过程</p>\n<p>由于存在多种可能便需要设置result数组存储中间结果<code>result[i][j]</code>是text1前i个字符和text2前j个字符的最长公共子序列长度</p>\n<p>数组填充方式 为上方描述的逆过程. </p>\n<ul>\n<li><p>如果i1 i2所指字符相同 <code>result[i][j]</code>结果是<code>result[i - 1][j - 1] + 1</code><br>表示的是text1前i-1字符和text2前j-1字符最长公共子序列 加上 这个相同的字符 得到前i和前j的最长公共子序列</p>\n</li>\n<li><p>如果所指字符不同则<code>result[i][j]</code>可能是<code>result[i][j - 1]</code> 也可能是<code>result[i][j - 1]</code>取最大值<br>表示的是前ij的最长公共子序列是 text1前i字符和text2前j-1字符最长公共子序列 或者是 前i-1和前j的最长公共子序列</p>\n</li>\n</ul>\n<p>最终得到结果<code>result[text1.length()][text2.length()]</code> 表示前length1和前length2的最长公共子序列</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h1><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。</p>\n<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。</p>\n<p>若这两个字符串没有公共子序列，则返回 0。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; </span><br><span class=\"line\">输出：3  </span><br><span class=\"line\">解释：最长公共子序列是 &quot;ace&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>\n<p>示例 2:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;abc&quot;</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：最长公共子序列是 &quot;abc&quot;，它的长度为 3。</span><br></pre></td></tr></table></figure>\n<p>示例 3:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 &#x3D; &quot;abc&quot;, text2 &#x3D; &quot;def&quot;</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：两个字符串没有公共子序列，返回 0。</span><br></pre></td></tr></table></figure>\n\n<p>提示:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;&#x3D; text1.length &lt;&#x3D; 1000</span><br><span class=\"line\">1 &lt;&#x3D; text2.length &lt;&#x3D; 1000</span><br><span class=\"line\">输入的字符串只含有小写英文字符。</span><br></pre></td></tr></table></figure>\n\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/longest-common-subsequence\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-common-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"代码1\"><a href=\"#代码1\" class=\"headerlink\" title=\"代码1\"></a>代码1</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longest</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; text1, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; text2, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"keyword\">int</span> text1_sub, <span class=\"keyword\">int</span> text2_sub)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (text1_sub &gt;= text1.length() || text2_sub &gt;= text2.length())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (text1[text1_sub] == text2[text2_sub])</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> + longest(text1, text2, text1_sub + <span class=\"number\">1</span>, text2_sub + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>(longest(text1, text2, text1_sub + <span class=\"number\">1</span>, text2_sub), </span><br><span class=\"line\">                    longest(text1, text2, text1_sub, text2_sub + <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(<span class=\"built_in\">string</span> text1, <span class=\"built_in\">string</span> text2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> longest(text1, text2, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最简单的思路 然而会超时</p>\n<h2 id=\"代码2-动态规划\"><a href=\"#代码2-动态规划\" class=\"headerlink\" title=\"代码2 动态规划\"></a>代码2 动态规划</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestCommonSubsequence</span><span class=\"params\">(<span class=\"built_in\">string</span> text1, <span class=\"built_in\">string</span> text2)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result[<span class=\"number\">1005</span>][<span class=\"number\">1005</span>]&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i1 = <span class=\"number\">0</span>; i1 &lt; text1.length(); ++i1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i2 = <span class=\"number\">0</span>; i2 &lt; text2.length(); ++i2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (text1[i1] == text2[i2])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    result[i1 + <span class=\"number\">1</span>][i2 + <span class=\"number\">1</span>] = result[i1][i2] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    result[i1 + <span class=\"number\">1</span>][i2 + <span class=\"number\">1</span>] = <span class=\"built_in\">max</span>(result[i1][i2 + <span class=\"number\">1</span>], result[i1 + <span class=\"number\">1</span>][i2]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result[text1.length()][text2.length()];</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>设text1和text2的解是T</p>\n<ul>\n<li>如果text1和text2的最后两个字符相等, 则T的最后一个字符也是这个字符</li>\n</ul>\n<p>这样 text1和text2分别去掉最后一个字符后, T去掉最后一个字符后的T1 是前面两个新字符串的最长公共子序列</p>\n<ul>\n<li>如果最后两个字符不同, 则T可能是text1去掉最后一个字符后和text2的最长公共子序列 也可能是text2去掉最后一个字符后和text1的最长公共子序列</li>\n</ul>\n<p>这个可以循环下去, 直到最后两个字符相等 转入上方过程</p>\n<p>由于存在多种可能便需要设置result数组存储中间结果<code>result[i][j]</code>是text1前i个字符和text2前j个字符的最长公共子序列长度</p>\n<p>数组填充方式 为上方描述的逆过程. </p>\n<ul>\n<li><p>如果i1 i2所指字符相同 <code>result[i][j]</code>结果是<code>result[i - 1][j - 1] + 1</code><br>表示的是text1前i-1字符和text2前j-1字符最长公共子序列 加上 这个相同的字符 得到前i和前j的最长公共子序列</p>\n</li>\n<li><p>如果所指字符不同则<code>result[i][j]</code>可能是<code>result[i][j - 1]</code> 也可能是<code>result[i][j - 1]</code>取最大值<br>表示的是前ij的最长公共子序列是 text1前i字符和text2前j-1字符最长公共子序列 或者是 前i-1和前j的最长公共子序列</p>\n</li>\n</ul>\n<p>最终得到结果<code>result[text1.length()][text2.length()]</code> 表示前length1和前length2的最长公共子序列</p>\n"},{"title":"力扣11.26-H23.合并K个升序链表","date":"2020-11-26T08:25:02.000Z","_content":"# 合并K个升序链表\n\n给你一个链表数组，每个链表都已经按升序排列。\n\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n\n示例 1：\n```\n输入：lists = [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下：\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n将它们合并到一个有序链表中得到。\n1->1->2->3->4->4->5->6\n```\n示例 2：\n```\n输入：lists = []\n输出：[]\n```\n示例 3：\n```\n输入：lists = [[]]\n输出：[]\n```\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/merge-k-sorted-lists\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n## 代码1\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n\n    ListNode* Merge(const vector<ListNode*>& lists, int left, int right)\n    {\n        if (right - left <= 1)\n        {\n            return lists[left];\n        }\n        else if (right - left == 2)\n        {\n            ListNode* node1 = lists[left];\n            ListNode* node2 = lists[left + 1];\n\n            if (!node1)\n            {\n                return node2;\n            }\n            else if (!node2)\n            {\n                return node1;\n            }\n\n            ListNode* head = new ListNode;\n            ListNode* node = head;\n\n            if (node1->val <= node2->val)\n            {\n                head->val = node1->val;\n                node1 = node1->next;\n            }\n            else\n            {\n                head->val = node2->val;\n                node2 = node2->next;\n            }\n\n            while (node1 != nullptr || node2 != nullptr)\n            {\n                if (!node1 || (node2 && node2->val <= node1->val))\n                {\n                    node->next = new ListNode(node2->val);\n                    node = node->next;\n                    node2 = node2->next;\n                }\n                else if (node2 == nullptr || (node1 && node1->val < node2->val))\n                {\n                    node->next = new ListNode(node1->val);\n                    node = node->next;\n                    node1 = node1->next;\n                }\n            }\n\n            return head;\n        }\n        else\n        {\n            int mid = (left + right) >> 1;\n            ListNode* node1 = Merge(lists, left, mid);\n            ListNode* node2 = Merge(lists, mid, right);\n            ListNode* result = Merge({ node1, node2 }, 0, 2);\n            return result;\n        }\n    }\n\n    ListNode* mergeKLists(vector<ListNode*>& lists)\n    {\n        if (lists.empty())\n        {\n            return nullptr;\n        }\n        return Merge(lists, 0, lists.size());\n    }\n};\n```\n\n思路的话比较简单 使用分治和递归. 将若干个`ListNode*`的合并的最终分解为 两两合并. 然后将合并结果再两两合并\n\n第一版代码 我甚至没有delete临时用的指针... 有内存泄漏的问题  最终提交后 `Time-33%`.... 好吧\n\n仔细想了下部分地方不需要这么多的拷贝 直接复用已有的`ListNode*`就行\n\n## 代码2\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n\n    ListNode* Merge(const vector<ListNode*>& lists, int left, int right)\n    {\n        if (right - left <= 1)\n        {\n            return lists[left];\n        }\n        else if (right - left == 2) // 主要改动从这里开始\n        {\n            ListNode* node1 = lists[left];\n            ListNode* node2 = lists[left + 1];\n\n            if (!node1)\n            {\n                return node2;\n            }\n            else if (!node2)\n            {\n                return node1;\n            }\n\n            ListNode* head;\n            if (node1->val <= node2->val)\n            {\n                head = node1;\n                node1 = node1->next;\n            }\n            else\n            {\n                head = node2;\n                node2 = node2->next;\n            }\n\n            ListNode* node = head;\n\n            while (node1 != nullptr || node2 != nullptr)\n            {\n                if (!node1) // 同时在`node1`或`node2`为空的时候 直接append 避免额外的扫描\n                {\n                    node->next = node2;\n                    break;\n                }\n                else if (!node2)\n                {\n                    node->next = node1;\n                    break;\n                }\n                else\n                {\n                    if (node2->val <= node1->val)\n                    {\n                        node->next = node2;\n                        node = node->next;\n\n                        node2 = node2->next;\n                    }\n                    else\n                    {\n                        node->next = node1;\n                        node = node->next;\n\n                        node1 = node1->next;\n                    }\n                }\n            }\n\n            return head;\n        }\n        else\n        {\n            int mid = (left + right) >> 1;\n            ListNode* node1 = Merge(lists, left, mid);\n            ListNode* node2 = Merge(lists, mid, right);\n            ListNode* result = Merge({ node1, node2 }, 0, 2);\n            return result;\n        }\n    }\n\n    ListNode* mergeKLists(vector<ListNode*>& lists)\n    {\n        if (lists.empty())\n        {\n            return nullptr;\n        }\n        return Merge(lists, 0, lists.size());\n    }\n};\n```\n\n这次改动去掉了所有的new 因为直接复用已有的ListNode即可 同时在`node1`或`node2`为空的时候 直接append 避免额外的扫描\n\n从`Time-33%`变化到了`Time-67%`  \n\n## 样例代码\n\n```c++\nclass Solution {\npublic:\n    // 合并两个有序链表\n    ListNode* merge(ListNode* p1, ListNode* p2){ // 合并\n        if(!p1) return p2;\n        if(!p2) return p1;\n        if(p1->val <= p2->val){\n            p1->next = merge(p1->next, p2);\n            return p1;\n        }else{\n            p2->next = merge(p1, p2->next);\n            return p2;\n        }\n    }\n\n    ListNode* merge(vector<ListNode*>& lists, int start, int end){ // 负责拆分和合并\n        if(start == end) return lists[start];\n        int mid = (start + end) / 2;\n        ListNode* l1 = merge(lists, start, mid);\n        ListNode* l2 = merge(lists, mid+1, end);\n        return merge(l1, l2);\n    }\n\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.size() == 0) return nullptr;\n        return merge(lists, 0, lists.size()-1);\n    }\n};\n```\n\n这代码太精简了...","source":"_posts/力扣11.26-H23.合并K个升序链表.md","raw":"---\ntitle: 力扣11.26-H23.合并K个升序链表\ntags:\n  - 递归分治\ncategories:\n  - 力扣每日一题\ndate: 2020-11-26 16:25:02\n---\n# 合并K个升序链表\n\n给你一个链表数组，每个链表都已经按升序排列。\n\n请你将所有链表合并到一个升序链表中，返回合并后的链表。\n\n示例 1：\n```\n输入：lists = [[1,4,5],[1,3,4],[2,6]]\n输出：[1,1,2,3,4,4,5,6]\n解释：链表数组如下：\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\n将它们合并到一个有序链表中得到。\n1->1->2->3->4->4->5->6\n```\n示例 2：\n```\n输入：lists = []\n输出：[]\n```\n示例 3：\n```\n输入：lists = [[]]\n输出：[]\n```\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/merge-k-sorted-lists\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n## 代码1\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n\n    ListNode* Merge(const vector<ListNode*>& lists, int left, int right)\n    {\n        if (right - left <= 1)\n        {\n            return lists[left];\n        }\n        else if (right - left == 2)\n        {\n            ListNode* node1 = lists[left];\n            ListNode* node2 = lists[left + 1];\n\n            if (!node1)\n            {\n                return node2;\n            }\n            else if (!node2)\n            {\n                return node1;\n            }\n\n            ListNode* head = new ListNode;\n            ListNode* node = head;\n\n            if (node1->val <= node2->val)\n            {\n                head->val = node1->val;\n                node1 = node1->next;\n            }\n            else\n            {\n                head->val = node2->val;\n                node2 = node2->next;\n            }\n\n            while (node1 != nullptr || node2 != nullptr)\n            {\n                if (!node1 || (node2 && node2->val <= node1->val))\n                {\n                    node->next = new ListNode(node2->val);\n                    node = node->next;\n                    node2 = node2->next;\n                }\n                else if (node2 == nullptr || (node1 && node1->val < node2->val))\n                {\n                    node->next = new ListNode(node1->val);\n                    node = node->next;\n                    node1 = node1->next;\n                }\n            }\n\n            return head;\n        }\n        else\n        {\n            int mid = (left + right) >> 1;\n            ListNode* node1 = Merge(lists, left, mid);\n            ListNode* node2 = Merge(lists, mid, right);\n            ListNode* result = Merge({ node1, node2 }, 0, 2);\n            return result;\n        }\n    }\n\n    ListNode* mergeKLists(vector<ListNode*>& lists)\n    {\n        if (lists.empty())\n        {\n            return nullptr;\n        }\n        return Merge(lists, 0, lists.size());\n    }\n};\n```\n\n思路的话比较简单 使用分治和递归. 将若干个`ListNode*`的合并的最终分解为 两两合并. 然后将合并结果再两两合并\n\n第一版代码 我甚至没有delete临时用的指针... 有内存泄漏的问题  最终提交后 `Time-33%`.... 好吧\n\n仔细想了下部分地方不需要这么多的拷贝 直接复用已有的`ListNode*`就行\n\n## 代码2\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n\n    ListNode* Merge(const vector<ListNode*>& lists, int left, int right)\n    {\n        if (right - left <= 1)\n        {\n            return lists[left];\n        }\n        else if (right - left == 2) // 主要改动从这里开始\n        {\n            ListNode* node1 = lists[left];\n            ListNode* node2 = lists[left + 1];\n\n            if (!node1)\n            {\n                return node2;\n            }\n            else if (!node2)\n            {\n                return node1;\n            }\n\n            ListNode* head;\n            if (node1->val <= node2->val)\n            {\n                head = node1;\n                node1 = node1->next;\n            }\n            else\n            {\n                head = node2;\n                node2 = node2->next;\n            }\n\n            ListNode* node = head;\n\n            while (node1 != nullptr || node2 != nullptr)\n            {\n                if (!node1) // 同时在`node1`或`node2`为空的时候 直接append 避免额外的扫描\n                {\n                    node->next = node2;\n                    break;\n                }\n                else if (!node2)\n                {\n                    node->next = node1;\n                    break;\n                }\n                else\n                {\n                    if (node2->val <= node1->val)\n                    {\n                        node->next = node2;\n                        node = node->next;\n\n                        node2 = node2->next;\n                    }\n                    else\n                    {\n                        node->next = node1;\n                        node = node->next;\n\n                        node1 = node1->next;\n                    }\n                }\n            }\n\n            return head;\n        }\n        else\n        {\n            int mid = (left + right) >> 1;\n            ListNode* node1 = Merge(lists, left, mid);\n            ListNode* node2 = Merge(lists, mid, right);\n            ListNode* result = Merge({ node1, node2 }, 0, 2);\n            return result;\n        }\n    }\n\n    ListNode* mergeKLists(vector<ListNode*>& lists)\n    {\n        if (lists.empty())\n        {\n            return nullptr;\n        }\n        return Merge(lists, 0, lists.size());\n    }\n};\n```\n\n这次改动去掉了所有的new 因为直接复用已有的ListNode即可 同时在`node1`或`node2`为空的时候 直接append 避免额外的扫描\n\n从`Time-33%`变化到了`Time-67%`  \n\n## 样例代码\n\n```c++\nclass Solution {\npublic:\n    // 合并两个有序链表\n    ListNode* merge(ListNode* p1, ListNode* p2){ // 合并\n        if(!p1) return p2;\n        if(!p2) return p1;\n        if(p1->val <= p2->val){\n            p1->next = merge(p1->next, p2);\n            return p1;\n        }else{\n            p2->next = merge(p1, p2->next);\n            return p2;\n        }\n    }\n\n    ListNode* merge(vector<ListNode*>& lists, int start, int end){ // 负责拆分和合并\n        if(start == end) return lists[start];\n        int mid = (start + end) / 2;\n        ListNode* l1 = merge(lists, start, mid);\n        ListNode* l2 = merge(lists, mid+1, end);\n        return merge(l1, l2);\n    }\n\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        if(lists.size() == 0) return nullptr;\n        return merge(lists, 0, lists.size()-1);\n    }\n};\n```\n\n这代码太精简了...","slug":"力扣11.26-H23.合并K个升序链表","published":1,"updated":"2020-12-03T04:39:21.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6s002cf8unfkd6100u","content":"<h1 id=\"合并K个升序链表\"><a href=\"#合并K个升序链表\" class=\"headerlink\" title=\"合并K个升序链表\"></a>合并K个升序链表</h1><p>给你一个链表数组，每个链表都已经按升序排列。</p>\n<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class=\"line\">输出：[1,1,2,3,4,4,5,6]</span><br><span class=\"line\">解释：链表数组如下：</span><br><span class=\"line\">[</span><br><span class=\"line\">  1-&gt;4-&gt;5,</span><br><span class=\"line\">  1-&gt;3-&gt;4,</span><br><span class=\"line\">  2-&gt;6</span><br><span class=\"line\">]</span><br><span class=\"line\">将它们合并到一个有序链表中得到。</span><br><span class=\"line\">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：lists &#x3D; []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：lists &#x3D; [[]]</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/merge-k-sorted-lists\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/merge-k-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"代码1\"><a href=\"#代码1\" class=\"headerlink\" title=\"代码1\"></a>代码1</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">Merge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right - left &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lists[left];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right - left == <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ListNode* node1 = lists[left];</span><br><span class=\"line\">            ListNode* node2 = lists[left + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!node1)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!node2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ListNode* head = <span class=\"keyword\">new</span> ListNode;</span><br><span class=\"line\">            ListNode* node = head;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node1-&gt;val &lt;= node2-&gt;val)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                head-&gt;val = node1-&gt;val;</span><br><span class=\"line\">                node1 = node1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                head-&gt;val = node2-&gt;val;</span><br><span class=\"line\">                node2 = node2-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (node1 != <span class=\"literal\">nullptr</span> || node2 != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!node1 || (node2 &amp;&amp; node2-&gt;val &lt;= node1-&gt;val))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    node-&gt;next = <span class=\"keyword\">new</span> ListNode(node2-&gt;val);</span><br><span class=\"line\">                    node = node-&gt;next;</span><br><span class=\"line\">                    node2 = node2-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node2 == <span class=\"literal\">nullptr</span> || (node1 &amp;&amp; node1-&gt;val &lt; node2-&gt;val))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    node-&gt;next = <span class=\"keyword\">new</span> ListNode(node1-&gt;val);</span><br><span class=\"line\">                    node = node-&gt;next;</span><br><span class=\"line\">                    node1 = node1-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (left + right) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            ListNode* node1 = Merge(lists, left, mid);</span><br><span class=\"line\">            ListNode* node2 = Merge(lists, mid, right);</span><br><span class=\"line\">            ListNode* result = Merge(&#123; node1, node2 &#125;, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lists.empty())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Merge(lists, <span class=\"number\">0</span>, lists.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>思路的话比较简单 使用分治和递归. 将若干个<code>ListNode*</code>的合并的最终分解为 两两合并. 然后将合并结果再两两合并</p>\n<p>第一版代码 我甚至没有delete临时用的指针… 有内存泄漏的问题  最终提交后 <code>Time-33%</code>…. 好吧</p>\n<p>仔细想了下部分地方不需要这么多的拷贝 直接复用已有的<code>ListNode*</code>就行</p>\n<h2 id=\"代码2\"><a href=\"#代码2\" class=\"headerlink\" title=\"代码2\"></a>代码2</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">Merge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right - left &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lists[left];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right - left == <span class=\"number\">2</span>) <span class=\"comment\">// 主要改动从这里开始</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ListNode* node1 = lists[left];</span><br><span class=\"line\">            ListNode* node2 = lists[left + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!node1)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!node2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ListNode* head;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node1-&gt;val &lt;= node2-&gt;val)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                head = node1;</span><br><span class=\"line\">                node1 = node1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                head = node2;</span><br><span class=\"line\">                node2 = node2-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ListNode* node = head;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (node1 != <span class=\"literal\">nullptr</span> || node2 != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!node1) <span class=\"comment\">// 同时在`node1`或`node2`为空的时候 直接append 避免额外的扫描</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    node-&gt;next = node2;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!node2)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    node-&gt;next = node1;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (node2-&gt;val &lt;= node1-&gt;val)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        node-&gt;next = node2;</span><br><span class=\"line\">                        node = node-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">                        node2 = node2-&gt;next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        node-&gt;next = node1;</span><br><span class=\"line\">                        node = node-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">                        node1 = node1-&gt;next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (left + right) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            ListNode* node1 = Merge(lists, left, mid);</span><br><span class=\"line\">            ListNode* node2 = Merge(lists, mid, right);</span><br><span class=\"line\">            ListNode* result = Merge(&#123; node1, node2 &#125;, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lists.empty())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Merge(lists, <span class=\"number\">0</span>, lists.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这次改动去掉了所有的new 因为直接复用已有的ListNode即可 同时在<code>node1</code>或<code>node2</code>为空的时候 直接append 避免额外的扫描</p>\n<p>从<code>Time-33%</code>变化到了<code>Time-67%</code>  </p>\n<h2 id=\"样例代码\"><a href=\"#样例代码\" class=\"headerlink\" title=\"样例代码\"></a>样例代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 合并两个有序链表</span></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">merge</span><span class=\"params\">(ListNode* p1, ListNode* p2)</span></span>&#123; <span class=\"comment\">// 合并</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!p1) <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!p2) <span class=\"keyword\">return</span> p1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p1-&gt;val &lt;= p2-&gt;val)&#123;</span><br><span class=\"line\">            p1-&gt;next = merge(p1-&gt;next, p2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p1;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            p2-&gt;next = merge(p1, p2-&gt;next);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> <span class=\"built_in\">end</span>)</span></span>&#123; <span class=\"comment\">// 负责拆分和合并</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(start == <span class=\"built_in\">end</span>) <span class=\"keyword\">return</span> lists[start];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (start + <span class=\"built_in\">end</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        ListNode* l1 = merge(lists, start, mid);</span><br><span class=\"line\">        ListNode* l2 = merge(lists, mid+<span class=\"number\">1</span>, <span class=\"built_in\">end</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(l1, l2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lists.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(lists, <span class=\"number\">0</span>, lists.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这代码太精简了…</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"合并K个升序链表\"><a href=\"#合并K个升序链表\" class=\"headerlink\" title=\"合并K个升序链表\"></a>合并K个升序链表</h1><p>给你一个链表数组，每个链表都已经按升序排列。</p>\n<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：lists &#x3D; [[1,4,5],[1,3,4],[2,6]]</span><br><span class=\"line\">输出：[1,1,2,3,4,4,5,6]</span><br><span class=\"line\">解释：链表数组如下：</span><br><span class=\"line\">[</span><br><span class=\"line\">  1-&gt;4-&gt;5,</span><br><span class=\"line\">  1-&gt;3-&gt;4,</span><br><span class=\"line\">  2-&gt;6</span><br><span class=\"line\">]</span><br><span class=\"line\">将它们合并到一个有序链表中得到。</span><br><span class=\"line\">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：lists &#x3D; []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：lists &#x3D; [[]]</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/merge-k-sorted-lists\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/merge-k-sorted-lists</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"代码1\"><a href=\"#代码1\" class=\"headerlink\" title=\"代码1\"></a>代码1</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">Merge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right - left &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lists[left];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right - left == <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ListNode* node1 = lists[left];</span><br><span class=\"line\">            ListNode* node2 = lists[left + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!node1)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!node2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ListNode* head = <span class=\"keyword\">new</span> ListNode;</span><br><span class=\"line\">            ListNode* node = head;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node1-&gt;val &lt;= node2-&gt;val)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                head-&gt;val = node1-&gt;val;</span><br><span class=\"line\">                node1 = node1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                head-&gt;val = node2-&gt;val;</span><br><span class=\"line\">                node2 = node2-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (node1 != <span class=\"literal\">nullptr</span> || node2 != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!node1 || (node2 &amp;&amp; node2-&gt;val &lt;= node1-&gt;val))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    node-&gt;next = <span class=\"keyword\">new</span> ListNode(node2-&gt;val);</span><br><span class=\"line\">                    node = node-&gt;next;</span><br><span class=\"line\">                    node2 = node2-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (node2 == <span class=\"literal\">nullptr</span> || (node1 &amp;&amp; node1-&gt;val &lt; node2-&gt;val))</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    node-&gt;next = <span class=\"keyword\">new</span> ListNode(node1-&gt;val);</span><br><span class=\"line\">                    node = node-&gt;next;</span><br><span class=\"line\">                    node1 = node1-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (left + right) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            ListNode* node1 = Merge(lists, left, mid);</span><br><span class=\"line\">            ListNode* node2 = Merge(lists, mid, right);</span><br><span class=\"line\">            ListNode* result = Merge(&#123; node1, node2 &#125;, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lists.empty())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Merge(lists, <span class=\"number\">0</span>, lists.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>思路的话比较简单 使用分治和递归. 将若干个<code>ListNode*</code>的合并的最终分解为 两两合并. 然后将合并结果再两两合并</p>\n<p>第一版代码 我甚至没有delete临时用的指针… 有内存泄漏的问题  最终提交后 <code>Time-33%</code>…. 好吧</p>\n<p>仔细想了下部分地方不需要这么多的拷贝 直接复用已有的<code>ListNode*</code>就行</p>\n<h2 id=\"代码2\"><a href=\"#代码2\" class=\"headerlink\" title=\"代码2\"></a>代码2</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">Merge</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right - left &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lists[left];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (right - left == <span class=\"number\">2</span>) <span class=\"comment\">// 主要改动从这里开始</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ListNode* node1 = lists[left];</span><br><span class=\"line\">            ListNode* node2 = lists[left + <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!node1)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node2;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!node2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> node1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ListNode* head;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node1-&gt;val &lt;= node2-&gt;val)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                head = node1;</span><br><span class=\"line\">                node1 = node1-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                head = node2;</span><br><span class=\"line\">                node2 = node2-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ListNode* node = head;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (node1 != <span class=\"literal\">nullptr</span> || node2 != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!node1) <span class=\"comment\">// 同时在`node1`或`node2`为空的时候 直接append 避免额外的扫描</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    node-&gt;next = node2;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!node2)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    node-&gt;next = node1;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (node2-&gt;val &lt;= node1-&gt;val)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        node-&gt;next = node2;</span><br><span class=\"line\">                        node = node-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">                        node2 = node2-&gt;next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        node-&gt;next = node1;</span><br><span class=\"line\">                        node = node-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">                        node1 = node1-&gt;next;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = (left + right) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            ListNode* node1 = Merge(lists, left, mid);</span><br><span class=\"line\">            ListNode* node2 = Merge(lists, mid, right);</span><br><span class=\"line\">            ListNode* result = Merge(&#123; node1, node2 &#125;, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lists.empty())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Merge(lists, <span class=\"number\">0</span>, lists.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这次改动去掉了所有的new 因为直接复用已有的ListNode即可 同时在<code>node1</code>或<code>node2</code>为空的时候 直接append 避免额外的扫描</p>\n<p>从<code>Time-33%</code>变化到了<code>Time-67%</code>  </p>\n<h2 id=\"样例代码\"><a href=\"#样例代码\" class=\"headerlink\" title=\"样例代码\"></a>样例代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 合并两个有序链表</span></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">merge</span><span class=\"params\">(ListNode* p1, ListNode* p2)</span></span>&#123; <span class=\"comment\">// 合并</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!p1) <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!p2) <span class=\"keyword\">return</span> p1;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p1-&gt;val &lt;= p2-&gt;val)&#123;</span><br><span class=\"line\">            p1-&gt;next = merge(p1-&gt;next, p2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p1;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            p2-&gt;next = merge(p1, p2-&gt;next);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> <span class=\"built_in\">end</span>)</span></span>&#123; <span class=\"comment\">// 负责拆分和合并</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(start == <span class=\"built_in\">end</span>) <span class=\"keyword\">return</span> lists[start];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (start + <span class=\"built_in\">end</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        ListNode* l1 = merge(lists, start, mid);</span><br><span class=\"line\">        ListNode* l2 = merge(lists, mid+<span class=\"number\">1</span>, <span class=\"built_in\">end</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(l1, l2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">mergeKLists</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(lists.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(lists, <span class=\"number\">0</span>, lists.<span class=\"built_in\">size</span>()<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这代码太精简了…</p>\n"},{"title":"游戏知识-腾讯游戏学院-如何进入游戏开发行业","date":"2019-12-22T12:50:02.000Z","_content":"\n由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面\n[想做游戏吗？如何开始我的游戏开发职业生涯](https://gameinstitute.qq.com/course/detail/10156)\n<!--more-->\n做游戏不会重复做同样的工作, 项目不同\n\n","source":"_posts/游戏知识-腾讯游戏学院-如何进入游戏开发行业.md","raw":"---\ntitle: 游戏知识-腾讯游戏学院-如何进入游戏开发行业\ntags:\n  - 腾讯游戏学院\ncategories:\n  - 游戏知识\n  - 腾讯游戏学院\ndate: 2019-12-22 20:50:02\n---\n\n由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面\n[想做游戏吗？如何开始我的游戏开发职业生涯](https://gameinstitute.qq.com/course/detail/10156)\n<!--more-->\n做游戏不会重复做同样的工作, 项目不同\n\n","slug":"游戏知识-腾讯游戏学院-如何进入游戏开发行业","published":1,"updated":"2020-03-05T14:04:56.802Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6t002ef8un96of9b5j","content":"<p>由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面<br><a href=\"https://gameinstitute.qq.com/course/detail/10156\" target=\"_blank\" rel=\"noopener\">想做游戏吗？如何开始我的游戏开发职业生涯</a></p>\n<a id=\"more\"></a>\n<p>做游戏不会重复做同样的工作, 项目不同</p>\n","site":{"data":{}},"excerpt":"<p>由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面<br><a href=\"https://gameinstitute.qq.com/course/detail/10156\" target=\"_blank\" rel=\"noopener\">想做游戏吗？如何开始我的游戏开发职业生涯</a></p>","more":"<p>做游戏不会重复做同样的工作, 项目不同</p>"},{"title":"球球","date":"2020-03-05T13:50:02.000Z","_content":"\n[休闲: 球球](https://gameinstitute.qq.com/course/detail/10110)\n\nP2P 模式........ 好吧没有采用基本模式\n采用了变种, 从客户端中选取主客户端 局域网游戏会采用\n\n\n**状态同步**\nMMO用的多, 断线重连简单 直接返回状态\n\n收到命令集 计算后 返回结果 防作弊 服务器压力大 包量大\n\n预表现emm\n\n\n**帧同步**\n服务器广播客户端发送的指令集, 断线重连需要补上丢失的帧\n\n预表现emm\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E8%AF%BE%E5%A0%82/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AF%B9%E6%AF%94.png)\n\n航标\n终于知道游戏瞬移是怎么回事了\n\n影子追随\n\n心跳包矫正时间 获取延迟等等\n\n\n王者 帧同步.\n\n守望先锋 16ms一个包\n\nRTT网络延迟\n\n预表现\n\n测试\n","source":"_posts/游戏知识-腾讯游戏学院-球球.md","raw":"---\ntitle: 球球\ntags:\n  - 腾讯游戏学院\ncategories:\n  - 游戏知识\n  - 服务器\ndate: 2020-03-05 21:50:02\n---\n\n[休闲: 球球](https://gameinstitute.qq.com/course/detail/10110)\n\nP2P 模式........ 好吧没有采用基本模式\n采用了变种, 从客户端中选取主客户端 局域网游戏会采用\n\n\n**状态同步**\nMMO用的多, 断线重连简单 直接返回状态\n\n收到命令集 计算后 返回结果 防作弊 服务器压力大 包量大\n\n预表现emm\n\n\n**帧同步**\n服务器广播客户端发送的指令集, 断线重连需要补上丢失的帧\n\n预表现emm\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E8%AF%BE%E5%A0%82/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AF%B9%E6%AF%94.png)\n\n航标\n终于知道游戏瞬移是怎么回事了\n\n影子追随\n\n心跳包矫正时间 获取延迟等等\n\n\n王者 帧同步.\n\n守望先锋 16ms一个包\n\nRTT网络延迟\n\n预表现\n\n测试\n","slug":"游戏知识-腾讯游戏学院-球球","published":1,"updated":"2020-06-03T02:34:52.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6u002if8un9z5s5als","content":"<p><a href=\"https://gameinstitute.qq.com/course/detail/10110\" target=\"_blank\" rel=\"noopener\">休闲: 球球</a></p>\n<p>P2P 模式…….. 好吧没有采用基本模式<br>采用了变种, 从客户端中选取主客户端 局域网游戏会采用</p>\n<p><strong>状态同步</strong><br>MMO用的多, 断线重连简单 直接返回状态</p>\n<p>收到命令集 计算后 返回结果 防作弊 服务器压力大 包量大</p>\n<p>预表现emm</p>\n<p><strong>帧同步</strong><br>服务器广播客户端发送的指令集, 断线重连需要补上丢失的帧</p>\n<p>预表现emm</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E8%AF%BE%E5%A0%82/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AF%B9%E6%AF%94.png\" alt=\"\"></p>\n<p>航标<br>终于知道游戏瞬移是怎么回事了</p>\n<p>影子追随</p>\n<p>心跳包矫正时间 获取延迟等等</p>\n<p>王者 帧同步.</p>\n<p>守望先锋 16ms一个包</p>\n<p>RTT网络延迟</p>\n<p>预表现</p>\n<p>测试</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://gameinstitute.qq.com/course/detail/10110\" target=\"_blank\" rel=\"noopener\">休闲: 球球</a></p>\n<p>P2P 模式…….. 好吧没有采用基本模式<br>采用了变种, 从客户端中选取主客户端 局域网游戏会采用</p>\n<p><strong>状态同步</strong><br>MMO用的多, 断线重连简单 直接返回状态</p>\n<p>收到命令集 计算后 返回结果 防作弊 服务器压力大 包量大</p>\n<p>预表现emm</p>\n<p><strong>帧同步</strong><br>服务器广播客户端发送的指令集, 断线重连需要补上丢失的帧</p>\n<p>预表现emm</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E8%AF%BE%E5%A0%82/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AF%B9%E6%AF%94.png\" alt=\"\"></p>\n<p>航标<br>终于知道游戏瞬移是怎么回事了</p>\n<p>影子追随</p>\n<p>心跳包矫正时间 获取延迟等等</p>\n<p>王者 帧同步.</p>\n<p>守望先锋 16ms一个包</p>\n<p>RTT网络延迟</p>\n<p>预表现</p>\n<p>测试</p>\n"},{"title":"力扣12.1-N5.最长回文子串","date":"2020-12-01T08:25:02.000Z","_content":"# 最长回文子串\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n示例 1：\n```\n输入: \"babad\"\n输出: \"bab\"\n注意: \"aba\" 也是一个有效答案。\n```\n示例 2：\n```\n输入: \"cbbd\"\n输出: \"bb\"\n```\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-palindromic-substring\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n## 代码1 - 中心扩散法\n\n```c++\nclass Solution {\npublic:\n    string longestPalindrome(string s)\n    {\n        /* 开头老套路 先处理了最简单的输入*/\n        if (s.length() <= 1)\n        {\n            return s;\n        }\n\n        /* 记录最大长度*/\n        int max_len = 0;\n\n        /* 记录最大长度子串的开始下标 用于return时的substr 解决拷贝问题*/\n        int result_begin_sub = 0;\n        int i = 0;\n        while (i < s.length())\n        {\n            int l_begin = i, r_begin = i;\n            \n            /* 从当前下标开始 找到最长的相同字符子串*/\n            /* lbegin指向此子串的开始字符 rbegin指向结尾字符*/\n            while (r_begin < s.length() - 1 && s[r_begin + 1] == s[i])\n            {\n                r_begin++;\n            }\n            /* 更新下标 减少循环次数*/\n            i = r_begin + 1;\n\n            /* 向左右两侧遍历 相同字符则 向左移动lbegin 向右移动rbegin*/\n            do\n            {\n                l_begin--;\n                r_begin++;\n            }\n            while (l_begin >=0 && r_begin < s.length() && s[l_begin] == s[r_begin]);\n            \n            /* 更新最大长度*/\n            int len = r_begin - l_begin - 1;\n            if (len > max_len)\n            {\n                max_len = len;\n                result_begin_sub = l_begin + 1;\n            }\n        }\n\n        return s.substr(result_begin_sub, max_len);\n    }\n};\n```\n\n遍历字符串 从当前循环开始下标找到最长的相同字符子串 如a 或 bb 或 ccc\n\n然后向左右两侧遍历 如果左右字符相同 继续遍历 最终得到两个下标\n\n左下标指向当前最大回文子串的左边一个字符 右下标指向右边一个字符\n\n这样就得到了子串的开始下标和长度 更新最大长度 继续遍历","source":"_posts/力扣12.1-N5.最长回文子串.md","raw":"---\ntitle: 力扣12.1-N5.最长回文子串\ntags:\n  - 中心扩散\ncategories:\n  - 力扣每日一题\ndate: 2020-12-1 16:25:02\n---\n# 最长回文子串\n\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。\n\n示例 1：\n```\n输入: \"babad\"\n输出: \"bab\"\n注意: \"aba\" 也是一个有效答案。\n```\n示例 2：\n```\n输入: \"cbbd\"\n输出: \"bb\"\n```\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/longest-palindromic-substring\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n## 代码1 - 中心扩散法\n\n```c++\nclass Solution {\npublic:\n    string longestPalindrome(string s)\n    {\n        /* 开头老套路 先处理了最简单的输入*/\n        if (s.length() <= 1)\n        {\n            return s;\n        }\n\n        /* 记录最大长度*/\n        int max_len = 0;\n\n        /* 记录最大长度子串的开始下标 用于return时的substr 解决拷贝问题*/\n        int result_begin_sub = 0;\n        int i = 0;\n        while (i < s.length())\n        {\n            int l_begin = i, r_begin = i;\n            \n            /* 从当前下标开始 找到最长的相同字符子串*/\n            /* lbegin指向此子串的开始字符 rbegin指向结尾字符*/\n            while (r_begin < s.length() - 1 && s[r_begin + 1] == s[i])\n            {\n                r_begin++;\n            }\n            /* 更新下标 减少循环次数*/\n            i = r_begin + 1;\n\n            /* 向左右两侧遍历 相同字符则 向左移动lbegin 向右移动rbegin*/\n            do\n            {\n                l_begin--;\n                r_begin++;\n            }\n            while (l_begin >=0 && r_begin < s.length() && s[l_begin] == s[r_begin]);\n            \n            /* 更新最大长度*/\n            int len = r_begin - l_begin - 1;\n            if (len > max_len)\n            {\n                max_len = len;\n                result_begin_sub = l_begin + 1;\n            }\n        }\n\n        return s.substr(result_begin_sub, max_len);\n    }\n};\n```\n\n遍历字符串 从当前循环开始下标找到最长的相同字符子串 如a 或 bb 或 ccc\n\n然后向左右两侧遍历 如果左右字符相同 继续遍历 最终得到两个下标\n\n左下标指向当前最大回文子串的左边一个字符 右下标指向右边一个字符\n\n这样就得到了子串的开始下标和长度 更新最大长度 继续遍历","slug":"力扣12.1-N5.最长回文子串","published":1,"updated":"2020-12-03T04:38:41.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6v002kf8unhzwqafcn","content":"<h1 id=\"最长回文子串\"><a href=\"#最长回文子串\" class=\"headerlink\" title=\"最长回文子串\"></a>最长回文子串</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;babad&quot;</span><br><span class=\"line\">输出: &quot;bab&quot;</span><br><span class=\"line\">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;cbbd&quot;</span><br><span class=\"line\">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"代码1-中心扩散法\"><a href=\"#代码1-中心扩散法\" class=\"headerlink\" title=\"代码1 - 中心扩散法\"></a>代码1 - 中心扩散法</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 开头老套路 先处理了最简单的输入*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 记录最大长度*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> max_len = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 记录最大长度子串的开始下标 用于return时的substr 解决拷贝问题*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result_begin_sub = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; s.length())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l_begin = i, r_begin = i;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">/* 从当前下标开始 找到最长的相同字符子串*/</span></span><br><span class=\"line\">            <span class=\"comment\">/* lbegin指向此子串的开始字符 rbegin指向结尾字符*/</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (r_begin &lt; s.length() - <span class=\"number\">1</span> &amp;&amp; s[r_begin + <span class=\"number\">1</span>] == s[i])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                r_begin++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/* 更新下标 减少循环次数*/</span></span><br><span class=\"line\">            i = r_begin + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* 向左右两侧遍历 相同字符则 向左移动lbegin 向右移动rbegin*/</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                l_begin--;</span><br><span class=\"line\">                r_begin++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (l_begin &gt;=<span class=\"number\">0</span> &amp;&amp; r_begin &lt; s.length() &amp;&amp; s[l_begin] == s[r_begin]);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">/* 更新最大长度*/</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = r_begin - l_begin - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (len &gt; max_len)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                max_len = len;</span><br><span class=\"line\">                result_begin_sub = l_begin + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substr(result_begin_sub, max_len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>遍历字符串 从当前循环开始下标找到最长的相同字符子串 如a 或 bb 或 ccc</p>\n<p>然后向左右两侧遍历 如果左右字符相同 继续遍历 最终得到两个下标</p>\n<p>左下标指向当前最大回文子串的左边一个字符 右下标指向右边一个字符</p>\n<p>这样就得到了子串的开始下标和长度 更新最大长度 继续遍历</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"最长回文子串\"><a href=\"#最长回文子串\" class=\"headerlink\" title=\"最长回文子串\"></a>最长回文子串</h1><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;babad&quot;</span><br><span class=\"line\">输出: &quot;bab&quot;</span><br><span class=\"line\">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: &quot;cbbd&quot;</span><br><span class=\"line\">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>\n<p>来源：力扣（LeetCode）<br>链接：<a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/longest-palindromic-substring</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>\n<h2 id=\"代码1-中心扩散法\"><a href=\"#代码1-中心扩散法\" class=\"headerlink\" title=\"代码1 - 中心扩散法\"></a>代码1 - 中心扩散法</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/* 开头老套路 先处理了最简单的输入*/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() &lt;= <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 记录最大长度*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> max_len = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 记录最大长度子串的开始下标 用于return时的substr 解决拷贝问题*/</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> result_begin_sub = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; s.length())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l_begin = i, r_begin = i;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">/* 从当前下标开始 找到最长的相同字符子串*/</span></span><br><span class=\"line\">            <span class=\"comment\">/* lbegin指向此子串的开始字符 rbegin指向结尾字符*/</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (r_begin &lt; s.length() - <span class=\"number\">1</span> &amp;&amp; s[r_begin + <span class=\"number\">1</span>] == s[i])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                r_begin++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">/* 更新下标 减少循环次数*/</span></span><br><span class=\"line\">            i = r_begin + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">/* 向左右两侧遍历 相同字符则 向左移动lbegin 向右移动rbegin*/</span></span><br><span class=\"line\">            <span class=\"keyword\">do</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                l_begin--;</span><br><span class=\"line\">                r_begin++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (l_begin &gt;=<span class=\"number\">0</span> &amp;&amp; r_begin &lt; s.length() &amp;&amp; s[l_begin] == s[r_begin]);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"comment\">/* 更新最大长度*/</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = r_begin - l_begin - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (len &gt; max_len)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                max_len = len;</span><br><span class=\"line\">                result_begin_sub = l_begin + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substr(result_begin_sub, max_len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>遍历字符串 从当前循环开始下标找到最长的相同字符子串 如a 或 bb 或 ccc</p>\n<p>然后向左右两侧遍历 如果左右字符相同 继续遍历 最终得到两个下标</p>\n<p>左下标指向当前最大回文子串的左边一个字符 右下标指向右边一个字符</p>\n<p>这样就得到了子串的开始下标和长度 更新最大长度 继续遍历</p>\n"},{"title":"游戏知识-服务器-服务器通信","date":"2019-12-22T12:50:02.000Z","_content":"\n由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面\n[服务器通信](https://gameinstitute.qq.com/course/detail/10096)\n<!--more-->\n# 概述\n作业型-单纯多个client对一个server .. 比如我开始写过的聊天室程序\n\n# CS通信\nDNS协议-基于UDP协议\n\nTCP\n面向连接的可靠的有时序性的-流式协议\n窗口管理\n流量控制\n数据确认\nUDP\n无连接不保证可靠性的无法保证时序-报文协议\n\nQQ-CS\n网络状况较好-UDP????-好吧还是处理了\n网络状况差-TCP\n大文件-TCP-TCP适合大文件交互, 因为他保持连接流式协议~\n\n微信-CS\n前台运行-TCP长连接\n后台运行-TCP短连接\n查看文章-HTTP(TCP短连接)\n\nQQ-早期产品, 花最少的前~榨干性能\n微信-腾讯后期产品\n\n----------------\n字符串\n自定义\nProtobuf\n\n序列化反序列化.\n\nUDP协议-不要让单个包的数据量超过1K, 否则会由于分片等 导致一个大包一旦一个分片失败就都失败\n\n存在的问题\n1. 客户端和服务端数据一直对不上\n可能是字节序的问题 - 字节序转换(网络字节数传送)\n2. 服务器发送的数据延迟-小包\nNAGLE算法-小包并不是立即发送-等存多了在一起发送-可以禁用掉~~\n3. 数据较大或者网络波动\n发送缓冲区慢了.. 适当加大发送缓冲区\n\n非阻塞IO\nO_NONBLOCK\n多路复用\nselect\npoll\nepoll\n\n# SS通信\nTCP-最常用\nUDP-非关键数据-日志服务-内网通信网络状况好可以超过MTU\n非SOCKET通信-进程间通信?-管道-信号-共享内存-信息队列-文件..","source":"_posts/游戏知识-服务器-服务器通信.md","raw":"---\ntitle: 游戏知识-服务器-服务器通信\ntags:\n  - 腾讯游戏学院\ncategories:\n  - 游戏知识\n  - 服务器\ndate: 2019-12-22 20:50:02\n---\n\n由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面\n[服务器通信](https://gameinstitute.qq.com/course/detail/10096)\n<!--more-->\n# 概述\n作业型-单纯多个client对一个server .. 比如我开始写过的聊天室程序\n\n# CS通信\nDNS协议-基于UDP协议\n\nTCP\n面向连接的可靠的有时序性的-流式协议\n窗口管理\n流量控制\n数据确认\nUDP\n无连接不保证可靠性的无法保证时序-报文协议\n\nQQ-CS\n网络状况较好-UDP????-好吧还是处理了\n网络状况差-TCP\n大文件-TCP-TCP适合大文件交互, 因为他保持连接流式协议~\n\n微信-CS\n前台运行-TCP长连接\n后台运行-TCP短连接\n查看文章-HTTP(TCP短连接)\n\nQQ-早期产品, 花最少的前~榨干性能\n微信-腾讯后期产品\n\n----------------\n字符串\n自定义\nProtobuf\n\n序列化反序列化.\n\nUDP协议-不要让单个包的数据量超过1K, 否则会由于分片等 导致一个大包一旦一个分片失败就都失败\n\n存在的问题\n1. 客户端和服务端数据一直对不上\n可能是字节序的问题 - 字节序转换(网络字节数传送)\n2. 服务器发送的数据延迟-小包\nNAGLE算法-小包并不是立即发送-等存多了在一起发送-可以禁用掉~~\n3. 数据较大或者网络波动\n发送缓冲区慢了.. 适当加大发送缓冲区\n\n非阻塞IO\nO_NONBLOCK\n多路复用\nselect\npoll\nepoll\n\n# SS通信\nTCP-最常用\nUDP-非关键数据-日志服务-内网通信网络状况好可以超过MTU\n非SOCKET通信-进程间通信?-管道-信号-共享内存-信息队列-文件..","slug":"游戏知识-服务器-服务器通信","published":1,"updated":"2020-03-05T14:04:59.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6w002pf8unacvw5qus","content":"<p>由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面<br><a href=\"https://gameinstitute.qq.com/course/detail/10096\" target=\"_blank\" rel=\"noopener\">服务器通信</a></p>\n<a id=\"more\"></a>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>作业型-单纯多个client对一个server .. 比如我开始写过的聊天室程序</p>\n<h1 id=\"CS通信\"><a href=\"#CS通信\" class=\"headerlink\" title=\"CS通信\"></a>CS通信</h1><p>DNS协议-基于UDP协议</p>\n<p>TCP<br>面向连接的可靠的有时序性的-流式协议<br>窗口管理<br>流量控制<br>数据确认<br>UDP<br>无连接不保证可靠性的无法保证时序-报文协议</p>\n<p>QQ-CS<br>网络状况较好-UDP????-好吧还是处理了<br>网络状况差-TCP<br>大文件-TCP-TCP适合大文件交互, 因为他保持连接流式协议~</p>\n<p>微信-CS<br>前台运行-TCP长连接<br>后台运行-TCP短连接<br>查看文章-HTTP(TCP短连接)</p>\n<p>QQ-早期产品, 花最少的前~榨干性能<br>微信-腾讯后期产品</p>\n<hr>\n<p>字符串<br>自定义<br>Protobuf</p>\n<p>序列化反序列化.</p>\n<p>UDP协议-不要让单个包的数据量超过1K, 否则会由于分片等 导致一个大包一旦一个分片失败就都失败</p>\n<p>存在的问题</p>\n<ol>\n<li>客户端和服务端数据一直对不上<br>可能是字节序的问题 - 字节序转换(网络字节数传送)</li>\n<li>服务器发送的数据延迟-小包<br>NAGLE算法-小包并不是立即发送-等存多了在一起发送-可以禁用掉~~</li>\n<li>数据较大或者网络波动<br>发送缓冲区慢了.. 适当加大发送缓冲区</li>\n</ol>\n<p>非阻塞IO<br>O_NONBLOCK<br>多路复用<br>select<br>poll<br>epoll</p>\n<h1 id=\"SS通信\"><a href=\"#SS通信\" class=\"headerlink\" title=\"SS通信\"></a>SS通信</h1><p>TCP-最常用<br>UDP-非关键数据-日志服务-内网通信网络状况好可以超过MTU<br>非SOCKET通信-进程间通信?-管道-信号-共享内存-信息队列-文件..</p>\n","site":{"data":{}},"excerpt":"<p>由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面<br><a href=\"https://gameinstitute.qq.com/course/detail/10096\" target=\"_blank\" rel=\"noopener\">服务器通信</a></p>","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>作业型-单纯多个client对一个server .. 比如我开始写过的聊天室程序</p>\n<h1 id=\"CS通信\"><a href=\"#CS通信\" class=\"headerlink\" title=\"CS通信\"></a>CS通信</h1><p>DNS协议-基于UDP协议</p>\n<p>TCP<br>面向连接的可靠的有时序性的-流式协议<br>窗口管理<br>流量控制<br>数据确认<br>UDP<br>无连接不保证可靠性的无法保证时序-报文协议</p>\n<p>QQ-CS<br>网络状况较好-UDP????-好吧还是处理了<br>网络状况差-TCP<br>大文件-TCP-TCP适合大文件交互, 因为他保持连接流式协议~</p>\n<p>微信-CS<br>前台运行-TCP长连接<br>后台运行-TCP短连接<br>查看文章-HTTP(TCP短连接)</p>\n<p>QQ-早期产品, 花最少的前~榨干性能<br>微信-腾讯后期产品</p>\n<hr>\n<p>字符串<br>自定义<br>Protobuf</p>\n<p>序列化反序列化.</p>\n<p>UDP协议-不要让单个包的数据量超过1K, 否则会由于分片等 导致一个大包一旦一个分片失败就都失败</p>\n<p>存在的问题</p>\n<ol>\n<li>客户端和服务端数据一直对不上<br>可能是字节序的问题 - 字节序转换(网络字节数传送)</li>\n<li>服务器发送的数据延迟-小包<br>NAGLE算法-小包并不是立即发送-等存多了在一起发送-可以禁用掉~~</li>\n<li>数据较大或者网络波动<br>发送缓冲区慢了.. 适当加大发送缓冲区</li>\n</ol>\n<p>非阻塞IO<br>O_NONBLOCK<br>多路复用<br>select<br>poll<br>epoll</p>\n<h1 id=\"SS通信\"><a href=\"#SS通信\" class=\"headerlink\" title=\"SS通信\"></a>SS通信</h1><p>TCP-最常用<br>UDP-非关键数据-日志服务-内网通信网络状况好可以超过MTU<br>非SOCKET通信-进程间通信?-管道-信号-共享内存-信息队列-文件..</p>"},{"title":"数据结构和STL","date":"2020-03-03T02:38:28.000Z","top":90,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL/api.png","_content":"\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL/api.png)\n\n对stl库string等定义的变量 使用sizeof并不会得到真实的大小, sizeof只会返回相关类中成员的大小\n\nstl等库中使用指针指向真实的数据, sizeof的时候只记录了指针的大小 并不记录指针指向空间的大小\n\n| 顺序容器 | 按序访问 |\n| --- | --- |\n| array | 静态的连续数组 |\n| vector | 动态的连续数组 |\n| deque | 双端队列 |\n| forward_list | 单链表 |\n| list | 双链表 |\n\n\n| 关联容器 | 能实现快速查找O(logn) |\n| --- | --- |\n| set | 唯一key的集合, 按照key排序 |\n| map | k v集合, 按照k排序, k是唯一的 |\n| multiset | key的集合 按照key排序 |\n| multimap | k v的集合, 按照key排序 |\n\n| 无序关联容器 | 快速查找均摊O(1)最坏O(n)的无序(哈希)数据结构 |\n| --- | --- |\n| unordered_set | 唯一key的集合, 按照key生成散列 |\n| unordered_map | 唯一key, k v的集合, 按照key生成散列 |\n| unordered_multiset | key的集合, 按照key生成散列 |\n| unordered_multimap | k v的集合, 按照key生成散列 |\n\n| 容器适配器 | 提供顺序容器的不同接口 |\n| --- | --- |\n| stack | 适配一个容器提供栈 vector deque list满足要求 默认是deque|\n| queue | 适配一个容器提供队列 deque list 默认是deque|\n| priority_queue | 适配一个容器提供优先级队列 vector deque 默认是 vector|\n\n# Sequence containers 顺序容器\n## array\n## vector\n\n\n\n## deque\n## forward_list\n## list\n\n\n# Associative containers 关联容器\n## set\n## map\n## multiset\n## multimap\n\n# Unordered associative containers 无序关联容器\n## unordered_set\n## unordered_map\n## unordered_multiset\n## unordered_multimap\n\n# Container adaptors 容器适配器\n## stack\n## queue\n## priority_queue\n","source":"_posts/算法90-数据结构简单应用.md","raw":"---\ntitle: 数据结构和STL\ndate: 2020-03-03 10:38:28\ntags:\ncategories:\n - 算法\ntop: 90\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL/api.png\n---\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL/api.png)\n\n对stl库string等定义的变量 使用sizeof并不会得到真实的大小, sizeof只会返回相关类中成员的大小\n\nstl等库中使用指针指向真实的数据, sizeof的时候只记录了指针的大小 并不记录指针指向空间的大小\n\n| 顺序容器 | 按序访问 |\n| --- | --- |\n| array | 静态的连续数组 |\n| vector | 动态的连续数组 |\n| deque | 双端队列 |\n| forward_list | 单链表 |\n| list | 双链表 |\n\n\n| 关联容器 | 能实现快速查找O(logn) |\n| --- | --- |\n| set | 唯一key的集合, 按照key排序 |\n| map | k v集合, 按照k排序, k是唯一的 |\n| multiset | key的集合 按照key排序 |\n| multimap | k v的集合, 按照key排序 |\n\n| 无序关联容器 | 快速查找均摊O(1)最坏O(n)的无序(哈希)数据结构 |\n| --- | --- |\n| unordered_set | 唯一key的集合, 按照key生成散列 |\n| unordered_map | 唯一key, k v的集合, 按照key生成散列 |\n| unordered_multiset | key的集合, 按照key生成散列 |\n| unordered_multimap | k v的集合, 按照key生成散列 |\n\n| 容器适配器 | 提供顺序容器的不同接口 |\n| --- | --- |\n| stack | 适配一个容器提供栈 vector deque list满足要求 默认是deque|\n| queue | 适配一个容器提供队列 deque list 默认是deque|\n| priority_queue | 适配一个容器提供优先级队列 vector deque 默认是 vector|\n\n# Sequence containers 顺序容器\n## array\n## vector\n\n\n\n## deque\n## forward_list\n## list\n\n\n# Associative containers 关联容器\n## set\n## map\n## multiset\n## multimap\n\n# Unordered associative containers 无序关联容器\n## unordered_set\n## unordered_map\n## unordered_multiset\n## unordered_multimap\n\n# Container adaptors 容器适配器\n## stack\n## queue\n## priority_queue\n","slug":"算法90-数据结构简单应用","published":1,"updated":"2020-08-09T15:28:11.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6w002qf8un5owh9rrl","content":"<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL/api.png\" alt=\"\"></p>\n<p>对stl库string等定义的变量 使用sizeof并不会得到真实的大小, sizeof只会返回相关类中成员的大小</p>\n<p>stl等库中使用指针指向真实的数据, sizeof的时候只记录了指针的大小 并不记录指针指向空间的大小</p>\n<table>\n<thead>\n<tr>\n<th>顺序容器</th>\n<th>按序访问</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>array</td>\n<td>静态的连续数组</td>\n</tr>\n<tr>\n<td>vector</td>\n<td>动态的连续数组</td>\n</tr>\n<tr>\n<td>deque</td>\n<td>双端队列</td>\n</tr>\n<tr>\n<td>forward_list</td>\n<td>单链表</td>\n</tr>\n<tr>\n<td>list</td>\n<td>双链表</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>关联容器</th>\n<th>能实现快速查找O(logn)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>set</td>\n<td>唯一key的集合, 按照key排序</td>\n</tr>\n<tr>\n<td>map</td>\n<td>k v集合, 按照k排序, k是唯一的</td>\n</tr>\n<tr>\n<td>multiset</td>\n<td>key的集合 按照key排序</td>\n</tr>\n<tr>\n<td>multimap</td>\n<td>k v的集合, 按照key排序</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>无序关联容器</th>\n<th>快速查找均摊O(1)最坏O(n)的无序(哈希)数据结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>unordered_set</td>\n<td>唯一key的集合, 按照key生成散列</td>\n</tr>\n<tr>\n<td>unordered_map</td>\n<td>唯一key, k v的集合, 按照key生成散列</td>\n</tr>\n<tr>\n<td>unordered_multiset</td>\n<td>key的集合, 按照key生成散列</td>\n</tr>\n<tr>\n<td>unordered_multimap</td>\n<td>k v的集合, 按照key生成散列</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>容器适配器</th>\n<th>提供顺序容器的不同接口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>stack</td>\n<td>适配一个容器提供栈 vector deque list满足要求 默认是deque</td>\n</tr>\n<tr>\n<td>queue</td>\n<td>适配一个容器提供队列 deque list 默认是deque</td>\n</tr>\n<tr>\n<td>priority_queue</td>\n<td>适配一个容器提供优先级队列 vector deque 默认是 vector</td>\n</tr>\n</tbody></table>\n<h1 id=\"Sequence-containers-顺序容器\"><a href=\"#Sequence-containers-顺序容器\" class=\"headerlink\" title=\"Sequence containers 顺序容器\"></a>Sequence containers 顺序容器</h1><h2 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h2><h2 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h2><h2 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h2><h2 id=\"forward-list\"><a href=\"#forward-list\" class=\"headerlink\" title=\"forward_list\"></a>forward_list</h2><h2 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h2><h1 id=\"Associative-containers-关联容器\"><a href=\"#Associative-containers-关联容器\" class=\"headerlink\" title=\"Associative containers 关联容器\"></a>Associative containers 关联容器</h1><h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h2><h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><h2 id=\"multiset\"><a href=\"#multiset\" class=\"headerlink\" title=\"multiset\"></a>multiset</h2><h2 id=\"multimap\"><a href=\"#multimap\" class=\"headerlink\" title=\"multimap\"></a>multimap</h2><h1 id=\"Unordered-associative-containers-无序关联容器\"><a href=\"#Unordered-associative-containers-无序关联容器\" class=\"headerlink\" title=\"Unordered associative containers 无序关联容器\"></a>Unordered associative containers 无序关联容器</h1><h2 id=\"unordered-set\"><a href=\"#unordered-set\" class=\"headerlink\" title=\"unordered_set\"></a>unordered_set</h2><h2 id=\"unordered-map\"><a href=\"#unordered-map\" class=\"headerlink\" title=\"unordered_map\"></a>unordered_map</h2><h2 id=\"unordered-multiset\"><a href=\"#unordered-multiset\" class=\"headerlink\" title=\"unordered_multiset\"></a>unordered_multiset</h2><h2 id=\"unordered-multimap\"><a href=\"#unordered-multimap\" class=\"headerlink\" title=\"unordered_multimap\"></a>unordered_multimap</h2><h1 id=\"Container-adaptors-容器适配器\"><a href=\"#Container-adaptors-容器适配器\" class=\"headerlink\" title=\"Container adaptors 容器适配器\"></a>Container adaptors 容器适配器</h1><h2 id=\"stack\"><a href=\"#stack\" class=\"headerlink\" title=\"stack\"></a>stack</h2><h2 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h2><h2 id=\"priority-queue\"><a href=\"#priority-queue\" class=\"headerlink\" title=\"priority_queue\"></a>priority_queue</h2>","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL/api.png\" alt=\"\"></p>\n<p>对stl库string等定义的变量 使用sizeof并不会得到真实的大小, sizeof只会返回相关类中成员的大小</p>\n<p>stl等库中使用指针指向真实的数据, sizeof的时候只记录了指针的大小 并不记录指针指向空间的大小</p>\n<table>\n<thead>\n<tr>\n<th>顺序容器</th>\n<th>按序访问</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>array</td>\n<td>静态的连续数组</td>\n</tr>\n<tr>\n<td>vector</td>\n<td>动态的连续数组</td>\n</tr>\n<tr>\n<td>deque</td>\n<td>双端队列</td>\n</tr>\n<tr>\n<td>forward_list</td>\n<td>单链表</td>\n</tr>\n<tr>\n<td>list</td>\n<td>双链表</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>关联容器</th>\n<th>能实现快速查找O(logn)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>set</td>\n<td>唯一key的集合, 按照key排序</td>\n</tr>\n<tr>\n<td>map</td>\n<td>k v集合, 按照k排序, k是唯一的</td>\n</tr>\n<tr>\n<td>multiset</td>\n<td>key的集合 按照key排序</td>\n</tr>\n<tr>\n<td>multimap</td>\n<td>k v的集合, 按照key排序</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>无序关联容器</th>\n<th>快速查找均摊O(1)最坏O(n)的无序(哈希)数据结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>unordered_set</td>\n<td>唯一key的集合, 按照key生成散列</td>\n</tr>\n<tr>\n<td>unordered_map</td>\n<td>唯一key, k v的集合, 按照key生成散列</td>\n</tr>\n<tr>\n<td>unordered_multiset</td>\n<td>key的集合, 按照key生成散列</td>\n</tr>\n<tr>\n<td>unordered_multimap</td>\n<td>k v的集合, 按照key生成散列</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>容器适配器</th>\n<th>提供顺序容器的不同接口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>stack</td>\n<td>适配一个容器提供栈 vector deque list满足要求 默认是deque</td>\n</tr>\n<tr>\n<td>queue</td>\n<td>适配一个容器提供队列 deque list 默认是deque</td>\n</tr>\n<tr>\n<td>priority_queue</td>\n<td>适配一个容器提供优先级队列 vector deque 默认是 vector</td>\n</tr>\n</tbody></table>\n<h1 id=\"Sequence-containers-顺序容器\"><a href=\"#Sequence-containers-顺序容器\" class=\"headerlink\" title=\"Sequence containers 顺序容器\"></a>Sequence containers 顺序容器</h1><h2 id=\"array\"><a href=\"#array\" class=\"headerlink\" title=\"array\"></a>array</h2><h2 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h2><h2 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h2><h2 id=\"forward-list\"><a href=\"#forward-list\" class=\"headerlink\" title=\"forward_list\"></a>forward_list</h2><h2 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h2><h1 id=\"Associative-containers-关联容器\"><a href=\"#Associative-containers-关联容器\" class=\"headerlink\" title=\"Associative containers 关联容器\"></a>Associative containers 关联容器</h1><h2 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h2><h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><h2 id=\"multiset\"><a href=\"#multiset\" class=\"headerlink\" title=\"multiset\"></a>multiset</h2><h2 id=\"multimap\"><a href=\"#multimap\" class=\"headerlink\" title=\"multimap\"></a>multimap</h2><h1 id=\"Unordered-associative-containers-无序关联容器\"><a href=\"#Unordered-associative-containers-无序关联容器\" class=\"headerlink\" title=\"Unordered associative containers 无序关联容器\"></a>Unordered associative containers 无序关联容器</h1><h2 id=\"unordered-set\"><a href=\"#unordered-set\" class=\"headerlink\" title=\"unordered_set\"></a>unordered_set</h2><h2 id=\"unordered-map\"><a href=\"#unordered-map\" class=\"headerlink\" title=\"unordered_map\"></a>unordered_map</h2><h2 id=\"unordered-multiset\"><a href=\"#unordered-multiset\" class=\"headerlink\" title=\"unordered_multiset\"></a>unordered_multiset</h2><h2 id=\"unordered-multimap\"><a href=\"#unordered-multimap\" class=\"headerlink\" title=\"unordered_multimap\"></a>unordered_multimap</h2><h1 id=\"Container-adaptors-容器适配器\"><a href=\"#Container-adaptors-容器适配器\" class=\"headerlink\" title=\"Container adaptors 容器适配器\"></a>Container adaptors 容器适配器</h1><h2 id=\"stack\"><a href=\"#stack\" class=\"headerlink\" title=\"stack\"></a>stack</h2><h2 id=\"queue\"><a href=\"#queue\" class=\"headerlink\" title=\"queue\"></a>queue</h2><h2 id=\"priority-queue\"><a href=\"#priority-queue\" class=\"headerlink\" title=\"priority_queue\"></a>priority_queue</h2>"},{"title":"算法题目记录","date":"2020-03-03T02:38:28.000Z","top":91,"_content":"","source":"_posts/算法91-算法题目记录.md","raw":"---\ntitle: 算法题目记录\ndate: 2020-03-03 10:38:28\ntags:\ncategories:\n - 算法\ntop: 91\n---\n","slug":"算法91-算法题目记录","published":1,"updated":"2020-07-17T08:53:05.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6y002vf8un58k4dzt3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"EPOLL本质","date":"2020-03-25T09:35:20.000Z","_content":"\nEPOLL本质是什么?  ~~本质当然是复读机~~\n\n参考和图片来源\n[如果这篇文章说不清epoll的本质，那就过来掐死我吧！](https://zhuanlan.zhihu.com/p/64138532)\n\n一个socket对应一个端口号, 网络数据包中包含了端口, 内核可以通过端口号找到对应的socket\n\n**select的不足**\nselect需要遍历两次socket列表, 第一次遍历用于将进程加入到所有socket的等待队列\n第二次遍历是每次唤醒都需要将进程从每个socket等待队列移除\n由于遍历开销大, 所以才规定了select最大的监视数量\n\n**功能分离**\n![](https://pic2.zhimg.com/80/v2-5ce040484bbe61df5b484730c4cf56cd_720w.jpg)\nselect将 `维护等待队列` 和 `阻塞进程`两个步骤合二为一, 每次select都需要这两部操作, 然而socket并不需要每次都修改\nepoll将操作分开, 使用epoll_ctl维护等待队列, 使用epoll_wait阻塞进程\n\n**就绪队列**\nselect不知道哪些socket接收到了数据, 只能一个个遍历.\n如果内核维护一个\"就绪队列\" 引用存储事件就绪的socket, 进程唤醒后获取\"就绪队列\"就能够知道\n哪些socket接收到数据\n\n\n**epoll_create创建了什么?**\n创建了一次eventpoll对象, epollfd正是他所代表的对象. 由于epollfd也是文件系统一员也存在等待队列\n\nselect将进程加入到每个socket的等待队列, 而epoll将进程加入到了eventpoll的等待队列 只加入了一次.\n\n**epoll_ctl修改了什么**\nepoll_ctl将 eventpoll添加到sockfd的等待队列中\n\n当socket接收到数据后, 中断程序会操作eventpoll对象, 而不是直接操作进程(socket的等待队列中就是eventpoll)\n\n**接收数据**\nsocket接收到数据后, 中断程序会给epollpoll的`就绪列表`添加socket的引用.\n\n这样socket就不会直接影响进程, 而是通过改变eventpoll的`就绪列表`来改变进程状态\n\n**epoll_wait**\n当程序执行到epoll_wait后如果`就绪队列`已经有socket引用就会返回, 如果为空就阻塞进程\n\n**阻塞和唤醒进程**\n进程被添加到了eventpoll的等待队列中, socket接收到数据后, 中断程序一方面修改`就绪队列`一方面唤醒\neventpoll等待队列的进程, 由于`就绪队列` 进程便知道哪些socket发生变化\n\n\n**实现细节**\neventpoll的数据结构是双向链表, 能够快速的插入和删除的数据结构\n\n就绪队列的数据结构是红黑树, 方便添加删除检索避免重复添加.","source":"_posts/网络编程-Socket理论-EPOLL本质.md","raw":"---\ntitle: EPOLL本质\ndate: 2020-03-25 17:35:20\ntags:\ncategories:\n  - 网络编程\n  - Socket理论\n---\n\nEPOLL本质是什么?  ~~本质当然是复读机~~\n\n参考和图片来源\n[如果这篇文章说不清epoll的本质，那就过来掐死我吧！](https://zhuanlan.zhihu.com/p/64138532)\n\n一个socket对应一个端口号, 网络数据包中包含了端口, 内核可以通过端口号找到对应的socket\n\n**select的不足**\nselect需要遍历两次socket列表, 第一次遍历用于将进程加入到所有socket的等待队列\n第二次遍历是每次唤醒都需要将进程从每个socket等待队列移除\n由于遍历开销大, 所以才规定了select最大的监视数量\n\n**功能分离**\n![](https://pic2.zhimg.com/80/v2-5ce040484bbe61df5b484730c4cf56cd_720w.jpg)\nselect将 `维护等待队列` 和 `阻塞进程`两个步骤合二为一, 每次select都需要这两部操作, 然而socket并不需要每次都修改\nepoll将操作分开, 使用epoll_ctl维护等待队列, 使用epoll_wait阻塞进程\n\n**就绪队列**\nselect不知道哪些socket接收到了数据, 只能一个个遍历.\n如果内核维护一个\"就绪队列\" 引用存储事件就绪的socket, 进程唤醒后获取\"就绪队列\"就能够知道\n哪些socket接收到数据\n\n\n**epoll_create创建了什么?**\n创建了一次eventpoll对象, epollfd正是他所代表的对象. 由于epollfd也是文件系统一员也存在等待队列\n\nselect将进程加入到每个socket的等待队列, 而epoll将进程加入到了eventpoll的等待队列 只加入了一次.\n\n**epoll_ctl修改了什么**\nepoll_ctl将 eventpoll添加到sockfd的等待队列中\n\n当socket接收到数据后, 中断程序会操作eventpoll对象, 而不是直接操作进程(socket的等待队列中就是eventpoll)\n\n**接收数据**\nsocket接收到数据后, 中断程序会给epollpoll的`就绪列表`添加socket的引用.\n\n这样socket就不会直接影响进程, 而是通过改变eventpoll的`就绪列表`来改变进程状态\n\n**epoll_wait**\n当程序执行到epoll_wait后如果`就绪队列`已经有socket引用就会返回, 如果为空就阻塞进程\n\n**阻塞和唤醒进程**\n进程被添加到了eventpoll的等待队列中, socket接收到数据后, 中断程序一方面修改`就绪队列`一方面唤醒\neventpoll等待队列的进程, 由于`就绪队列` 进程便知道哪些socket发生变化\n\n\n**实现细节**\neventpoll的数据结构是双向链表, 能够快速的插入和删除的数据结构\n\n就绪队列的数据结构是红黑树, 方便添加删除检索避免重复添加.","slug":"网络编程-Socket理论-EPOLL本质","published":1,"updated":"2020-12-05T02:27:03.519Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6y002wf8une4tlhnju","content":"<p>EPOLL本质是什么?  <del>本质当然是复读机</del></p>\n<p>参考和图片来源<br><a href=\"https://zhuanlan.zhihu.com/p/64138532\" target=\"_blank\" rel=\"noopener\">如果这篇文章说不清epoll的本质，那就过来掐死我吧！</a></p>\n<p>一个socket对应一个端口号, 网络数据包中包含了端口, 内核可以通过端口号找到对应的socket</p>\n<p><strong>select的不足</strong><br>select需要遍历两次socket列表, 第一次遍历用于将进程加入到所有socket的等待队列<br>第二次遍历是每次唤醒都需要将进程从每个socket等待队列移除<br>由于遍历开销大, 所以才规定了select最大的监视数量</p>\n<p><strong>功能分离</strong><br><img src=\"https://pic2.zhimg.com/80/v2-5ce040484bbe61df5b484730c4cf56cd_720w.jpg\" alt=\"\"><br>select将 <code>维护等待队列</code> 和 <code>阻塞进程</code>两个步骤合二为一, 每次select都需要这两部操作, 然而socket并不需要每次都修改<br>epoll将操作分开, 使用epoll_ctl维护等待队列, 使用epoll_wait阻塞进程</p>\n<p><strong>就绪队列</strong><br>select不知道哪些socket接收到了数据, 只能一个个遍历.<br>如果内核维护一个”就绪队列” 引用存储事件就绪的socket, 进程唤醒后获取”就绪队列”就能够知道<br>哪些socket接收到数据</p>\n<p><strong>epoll_create创建了什么?</strong><br>创建了一次eventpoll对象, epollfd正是他所代表的对象. 由于epollfd也是文件系统一员也存在等待队列</p>\n<p>select将进程加入到每个socket的等待队列, 而epoll将进程加入到了eventpoll的等待队列 只加入了一次.</p>\n<p><strong>epoll_ctl修改了什么</strong><br>epoll_ctl将 eventpoll添加到sockfd的等待队列中</p>\n<p>当socket接收到数据后, 中断程序会操作eventpoll对象, 而不是直接操作进程(socket的等待队列中就是eventpoll)</p>\n<p><strong>接收数据</strong><br>socket接收到数据后, 中断程序会给epollpoll的<code>就绪列表</code>添加socket的引用.</p>\n<p>这样socket就不会直接影响进程, 而是通过改变eventpoll的<code>就绪列表</code>来改变进程状态</p>\n<p><strong>epoll_wait</strong><br>当程序执行到epoll_wait后如果<code>就绪队列</code>已经有socket引用就会返回, 如果为空就阻塞进程</p>\n<p><strong>阻塞和唤醒进程</strong><br>进程被添加到了eventpoll的等待队列中, socket接收到数据后, 中断程序一方面修改<code>就绪队列</code>一方面唤醒<br>eventpoll等待队列的进程, 由于<code>就绪队列</code> 进程便知道哪些socket发生变化</p>\n<p><strong>实现细节</strong><br>eventpoll的数据结构是双向链表, 能够快速的插入和删除的数据结构</p>\n<p>就绪队列的数据结构是红黑树, 方便添加删除检索避免重复添加.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>EPOLL本质是什么?  <del>本质当然是复读机</del></p>\n<p>参考和图片来源<br><a href=\"https://zhuanlan.zhihu.com/p/64138532\" target=\"_blank\" rel=\"noopener\">如果这篇文章说不清epoll的本质，那就过来掐死我吧！</a></p>\n<p>一个socket对应一个端口号, 网络数据包中包含了端口, 内核可以通过端口号找到对应的socket</p>\n<p><strong>select的不足</strong><br>select需要遍历两次socket列表, 第一次遍历用于将进程加入到所有socket的等待队列<br>第二次遍历是每次唤醒都需要将进程从每个socket等待队列移除<br>由于遍历开销大, 所以才规定了select最大的监视数量</p>\n<p><strong>功能分离</strong><br><img src=\"https://pic2.zhimg.com/80/v2-5ce040484bbe61df5b484730c4cf56cd_720w.jpg\" alt=\"\"><br>select将 <code>维护等待队列</code> 和 <code>阻塞进程</code>两个步骤合二为一, 每次select都需要这两部操作, 然而socket并不需要每次都修改<br>epoll将操作分开, 使用epoll_ctl维护等待队列, 使用epoll_wait阻塞进程</p>\n<p><strong>就绪队列</strong><br>select不知道哪些socket接收到了数据, 只能一个个遍历.<br>如果内核维护一个”就绪队列” 引用存储事件就绪的socket, 进程唤醒后获取”就绪队列”就能够知道<br>哪些socket接收到数据</p>\n<p><strong>epoll_create创建了什么?</strong><br>创建了一次eventpoll对象, epollfd正是他所代表的对象. 由于epollfd也是文件系统一员也存在等待队列</p>\n<p>select将进程加入到每个socket的等待队列, 而epoll将进程加入到了eventpoll的等待队列 只加入了一次.</p>\n<p><strong>epoll_ctl修改了什么</strong><br>epoll_ctl将 eventpoll添加到sockfd的等待队列中</p>\n<p>当socket接收到数据后, 中断程序会操作eventpoll对象, 而不是直接操作进程(socket的等待队列中就是eventpoll)</p>\n<p><strong>接收数据</strong><br>socket接收到数据后, 中断程序会给epollpoll的<code>就绪列表</code>添加socket的引用.</p>\n<p>这样socket就不会直接影响进程, 而是通过改变eventpoll的<code>就绪列表</code>来改变进程状态</p>\n<p><strong>epoll_wait</strong><br>当程序执行到epoll_wait后如果<code>就绪队列</code>已经有socket引用就会返回, 如果为空就阻塞进程</p>\n<p><strong>阻塞和唤醒进程</strong><br>进程被添加到了eventpoll的等待队列中, socket接收到数据后, 中断程序一方面修改<code>就绪队列</code>一方面唤醒<br>eventpoll等待队列的进程, 由于<code>就绪队列</code> 进程便知道哪些socket发生变化</p>\n<p><strong>实现细节</strong><br>eventpoll的数据结构是双向链表, 能够快速的插入和删除的数据结构</p>\n<p>就绪队列的数据结构是红黑树, 方便添加删除检索避免重复添加.</p>\n"},{"title":"Send返回值引出的(非)阻塞IO","date":"2020-03-20T03:14:20.000Z","_content":"# 现存疑问\n1. WNOWAIT和O_NONBLOCK 的关系?\n2. 当非阻塞send时, 返回值与什么有关? 本地socket发送缓冲区空余还是对端空余?\n3. 对端接收缓冲区满了会发生什么?\n4. 暂且认为send返回值是拷贝到缓冲区中的字节数, 如果这些数据没有成功发送呢?\n5. send函数发送的字节数 超出了recv端的接受能力 会发生什么?\n\n最近这两天在实战一个http服务器的编写.\n\n遇到了一个问题: send的返回值小于传入的len, 因为我仅调用一次send函数 导致页面一直显示加载\n\n然后找了下为什么? 什么时候? send返回值会小于len;\n\n# send\nhttps://stackoverflow.com/questions/14700906/socket-programming-send-return-value\n\n```\nIn practice, send() in blocking mode sends all the data, regardless of what the documentation says, unless there was an error, in which case nothing is sent.\n实战中, send() 处于阻塞状态会发送所有的数据, 除非发生错误 但这会导致数据没有发送\n\nIn non-blocking mode, it sends whatever will fit into the socket send buffer and returns that length if > 0. If the socket send buffer is full, it returns -1 with errno = EWOULDBLOCK/EAGAIN.\n在非阻塞模式下, 只要能放入socket发送缓冲区 就返回放入的长度 如果缓冲区满了就返回-1 设置EWOULDBLOCK/EAGAIN\n```\n\n[非阻塞模式下 send 和 recv 函数的返回值](https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247486643&idx=1&sn=9db678398f390759ff81b354ef056000&chksm=fc70f75fcb077e49363b087ba45609fdfbcba286338e70c2d4c7092e83e2d3feac56455e02a2&scene=27#wechat_redirect)\n\n这篇博客里也说明了这个问题. 下面是原博客的代码稍作修改\n```c++\n//推荐的方式二：在一个循环里面根据偏移量发送数据\nbool SendData(const char* buf , int buf_length)\n{\n    //已发送的字节数目\n    int sent_bytes = 0;\n    int ret = 0;\n    while (true)\n    {\n        ret = send(fd, buf + sent_bytes, buf_length - sent_bytes, 0);\n        if (ret == -1)\n        {\n            if (errno == EAGIN)\n            {\n                //严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍\n                break;\n            }             \n            else if (errno == EINTR)\n            {\n                continue;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else if (ret == 0)\n        {\n            //认为对端关闭了连接\n            return false;\n        }\n\n        sent_bytes += ret;\n        if (sent_bytes == buf_length)\n        {\n            break;\n        }\n        //稍稍降低 CPU 的使用率\n        usleep(1);\n    }\n    return true;\n}\n```","source":"_posts/网络编程-Socket理论-Send返回值探析.md","raw":"---\ntitle: Send返回值引出的(非)阻塞IO\ndate: 2020-03-20 11:14:20\ntags:\ncategories:\n  - 网络编程\n  - Socket理论\n---\n# 现存疑问\n1. WNOWAIT和O_NONBLOCK 的关系?\n2. 当非阻塞send时, 返回值与什么有关? 本地socket发送缓冲区空余还是对端空余?\n3. 对端接收缓冲区满了会发生什么?\n4. 暂且认为send返回值是拷贝到缓冲区中的字节数, 如果这些数据没有成功发送呢?\n5. send函数发送的字节数 超出了recv端的接受能力 会发生什么?\n\n最近这两天在实战一个http服务器的编写.\n\n遇到了一个问题: send的返回值小于传入的len, 因为我仅调用一次send函数 导致页面一直显示加载\n\n然后找了下为什么? 什么时候? send返回值会小于len;\n\n# send\nhttps://stackoverflow.com/questions/14700906/socket-programming-send-return-value\n\n```\nIn practice, send() in blocking mode sends all the data, regardless of what the documentation says, unless there was an error, in which case nothing is sent.\n实战中, send() 处于阻塞状态会发送所有的数据, 除非发生错误 但这会导致数据没有发送\n\nIn non-blocking mode, it sends whatever will fit into the socket send buffer and returns that length if > 0. If the socket send buffer is full, it returns -1 with errno = EWOULDBLOCK/EAGAIN.\n在非阻塞模式下, 只要能放入socket发送缓冲区 就返回放入的长度 如果缓冲区满了就返回-1 设置EWOULDBLOCK/EAGAIN\n```\n\n[非阻塞模式下 send 和 recv 函数的返回值](https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247486643&idx=1&sn=9db678398f390759ff81b354ef056000&chksm=fc70f75fcb077e49363b087ba45609fdfbcba286338e70c2d4c7092e83e2d3feac56455e02a2&scene=27#wechat_redirect)\n\n这篇博客里也说明了这个问题. 下面是原博客的代码稍作修改\n```c++\n//推荐的方式二：在一个循环里面根据偏移量发送数据\nbool SendData(const char* buf , int buf_length)\n{\n    //已发送的字节数目\n    int sent_bytes = 0;\n    int ret = 0;\n    while (true)\n    {\n        ret = send(fd, buf + sent_bytes, buf_length - sent_bytes, 0);\n        if (ret == -1)\n        {\n            if (errno == EAGIN)\n            {\n                //严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍\n                break;\n            }             \n            else if (errno == EINTR)\n            {\n                continue;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else if (ret == 0)\n        {\n            //认为对端关闭了连接\n            return false;\n        }\n\n        sent_bytes += ret;\n        if (sent_bytes == buf_length)\n        {\n            break;\n        }\n        //稍稍降低 CPU 的使用率\n        usleep(1);\n    }\n    return true;\n}\n```","slug":"网络编程-Socket理论-Send返回值探析","published":1,"updated":"2020-12-05T02:27:03.519Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg6z0030f8unek72c0xh","content":"<h1 id=\"现存疑问\"><a href=\"#现存疑问\" class=\"headerlink\" title=\"现存疑问\"></a>现存疑问</h1><ol>\n<li>WNOWAIT和O_NONBLOCK 的关系?</li>\n<li>当非阻塞send时, 返回值与什么有关? 本地socket发送缓冲区空余还是对端空余?</li>\n<li>对端接收缓冲区满了会发生什么?</li>\n<li>暂且认为send返回值是拷贝到缓冲区中的字节数, 如果这些数据没有成功发送呢?</li>\n<li>send函数发送的字节数 超出了recv端的接受能力 会发生什么?</li>\n</ol>\n<p>最近这两天在实战一个http服务器的编写.</p>\n<p>遇到了一个问题: send的返回值小于传入的len, 因为我仅调用一次send函数 导致页面一直显示加载</p>\n<p>然后找了下为什么? 什么时候? send返回值会小于len;</p>\n<h1 id=\"send\"><a href=\"#send\" class=\"headerlink\" title=\"send\"></a>send</h1><p><a href=\"https://stackoverflow.com/questions/14700906/socket-programming-send-return-value\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/14700906/socket-programming-send-return-value</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In practice, send() in blocking mode sends all the data, regardless of what the documentation says, unless there was an error, in which case nothing is sent.</span><br><span class=\"line\">实战中, send() 处于阻塞状态会发送所有的数据, 除非发生错误 但这会导致数据没有发送</span><br><span class=\"line\"></span><br><span class=\"line\">In non-blocking mode, it sends whatever will fit into the socket send buffer and returns that length if &gt; 0. If the socket send buffer is full, it returns -1 with errno &#x3D; EWOULDBLOCK&#x2F;EAGAIN.</span><br><span class=\"line\">在非阻塞模式下, 只要能放入socket发送缓冲区 就返回放入的长度 如果缓冲区满了就返回-1 设置EWOULDBLOCK&#x2F;EAGAIN</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247486643&idx=1&sn=9db678398f390759ff81b354ef056000&chksm=fc70f75fcb077e49363b087ba45609fdfbcba286338e70c2d4c7092e83e2d3feac56455e02a2&scene=27#wechat_redirect\" target=\"_blank\" rel=\"noopener\">非阻塞模式下 send 和 recv 函数的返回值</a></p>\n<p>这篇博客里也说明了这个问题. 下面是原博客的代码稍作修改</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//推荐的方式二：在一个循环里面根据偏移量发送数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SendData</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* buf , <span class=\"keyword\">int</span> buf_length)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//已发送的字节数目</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sent_bytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ret = send(fd, buf + sent_bytes, buf_length - sent_bytes, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (errno == EAGIN)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;             </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (errno == EINTR)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//认为对端关闭了连接</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sent_bytes += ret;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sent_bytes == buf_length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//稍稍降低 CPU 的使用率</span></span><br><span class=\"line\">        usleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"现存疑问\"><a href=\"#现存疑问\" class=\"headerlink\" title=\"现存疑问\"></a>现存疑问</h1><ol>\n<li>WNOWAIT和O_NONBLOCK 的关系?</li>\n<li>当非阻塞send时, 返回值与什么有关? 本地socket发送缓冲区空余还是对端空余?</li>\n<li>对端接收缓冲区满了会发生什么?</li>\n<li>暂且认为send返回值是拷贝到缓冲区中的字节数, 如果这些数据没有成功发送呢?</li>\n<li>send函数发送的字节数 超出了recv端的接受能力 会发生什么?</li>\n</ol>\n<p>最近这两天在实战一个http服务器的编写.</p>\n<p>遇到了一个问题: send的返回值小于传入的len, 因为我仅调用一次send函数 导致页面一直显示加载</p>\n<p>然后找了下为什么? 什么时候? send返回值会小于len;</p>\n<h1 id=\"send\"><a href=\"#send\" class=\"headerlink\" title=\"send\"></a>send</h1><p><a href=\"https://stackoverflow.com/questions/14700906/socket-programming-send-return-value\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/14700906/socket-programming-send-return-value</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In practice, send() in blocking mode sends all the data, regardless of what the documentation says, unless there was an error, in which case nothing is sent.</span><br><span class=\"line\">实战中, send() 处于阻塞状态会发送所有的数据, 除非发生错误 但这会导致数据没有发送</span><br><span class=\"line\"></span><br><span class=\"line\">In non-blocking mode, it sends whatever will fit into the socket send buffer and returns that length if &gt; 0. If the socket send buffer is full, it returns -1 with errno &#x3D; EWOULDBLOCK&#x2F;EAGAIN.</span><br><span class=\"line\">在非阻塞模式下, 只要能放入socket发送缓冲区 就返回放入的长度 如果缓冲区满了就返回-1 设置EWOULDBLOCK&#x2F;EAGAIN</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247486643&idx=1&sn=9db678398f390759ff81b354ef056000&chksm=fc70f75fcb077e49363b087ba45609fdfbcba286338e70c2d4c7092e83e2d3feac56455e02a2&scene=27#wechat_redirect\" target=\"_blank\" rel=\"noopener\">非阻塞模式下 send 和 recv 函数的返回值</a></p>\n<p>这篇博客里也说明了这个问题. 下面是原博客的代码稍作修改</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//推荐的方式二：在一个循环里面根据偏移量发送数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SendData</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* buf , <span class=\"keyword\">int</span> buf_length)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//已发送的字节数目</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sent_bytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ret = send(fd, buf + sent_bytes, buf_length - sent_bytes, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (errno == EAGIN)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;             </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (errno == EINTR)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//认为对端关闭了连接</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sent_bytes += ret;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sent_bytes == buf_length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//稍稍降低 CPU 的使用率</span></span><br><span class=\"line\">        usleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"算法四","date":"2020-07-17T07:51:28.000Z","top":92,"img":"https://algs4.cs.princeton.edu/cover.png","_content":"\n来之不易的暑期留校, 一半献给算法.\n\n# 第二章 排序\n\n选择排序\n- 运行时间和输入的数据无关, 仅和数量有关.\n不会利用输入的初始状态\n- 数据移动是最少的\n我们将研究的其他任何算法 都不具备这个特性.....\n\n插入排序\n- 适合小规模数组\n- 对于部分有序的数组, 处理起来很有效\n- 倒置的数量很少时, 插入排序很可能比其他算法还要快\n\n希尔排序\n- 插入排序对于大规模乱序数组很慢, 因为它只会交换相邻元素, 因此为了改进插入排序的局部性,提出了希尔排序\n- 希尔排序交换不相邻的元素以对数组的局部性进行排序, 最终用插入排序调整局部有序的数组\n\n归并排序\n- 原地归并排序\n- 自顶向下 递归实现 分治思想\n- 自底向上 从归并微型数组到整体归并\n\n快速排序\n- 分治排序算法\n\n堆排序\n- 只能说妙啊.. 这本书先讲的优先队列如何实现, 然后紧接着就用sink方法完成了堆排序\n\n\n**稳定性**\n\n某地在某时下雨 时间和地点存在对应关系.\n按照时间排序后, 再按照地点排序 单个地点的时间排序就很可能被打乱\n\n稳定, 则时间排序没有被打乱. 不稳定, 很可能时间排序被打乱\n\n\n| 算法     | 是否稳定 | 是否为原地排序 | 时间复杂度 | 空间复杂度 | 备注                                                               |\n| -------- | -------- | -------------- | ---------- | ---------- | ------------------------------------------------------------------ |\n| 选择排序 | 否       | 是             | N^2        | 1          | 最简单粗暴的方式, 交换次数最少                                     |\n| 插入排序 | 是       | 是             | 介于N与N^2 | 1          | 很大程度取决输入元素的排列情况, 如果倒置元素很少则性能可能超过快排 |\n| 希尔排序 | 否       | 是             |            | 1          | 插入排序的改良版, 改善了插入排序过于局限                           |\n| 快速排序 | 否       | 是             | NlogN      | lgN        | 分治, 运行效率由概率保证                                           |\n| 归并排序 | 是       | 否             | NlogN      | N          | 自顶向下(递归 分治)和自底向上(从局部到整体) 两种方法               |\n| 堆排序   | 否       | 是             | NlogN      | 1          | 学完后突然想到了如果在很多的数字中找到最大的多少个数这种问题       |\n\n\n\n**2.4 优先队列**\n\n需要支持两种操作, 删除最大元素和插入元素  - 优先级队列\n\n\n1. 数组实现(无序) - 插入快 删除慢\n\nInsert方法 直接将元素插入尾部, 类似栈的push方法\n\nDelMax方法 使用一个内部循环找出最大的元素和边界元素交换 然后删除边界元素, 删除的时候类似pop方法\n\n2. 数组实现(有序) - 插入慢 删除快\n\nInsert方法 中进行排序, 插入新的元素的时候将较大元素向右移动一格位置, 然后插入新的元素\n\nDelMax方法 直接删除右侧元素, 类似栈的pop方法\n\n3. 链表表示法\n\n无序序列是解决问题的惰性方法, 仅在必要的时候才会采取行动 找出最大元素\n\n有序序列是解决问题的积极方法, 尽可能的未雨绸缪, 使得找出最大元素高效\n\n4. `二叉堆`表示法 - 插入和删除都为线性对数级别\n\nInsert方法 将新元素添加到数组末端, 增加了堆的大小 将新元素`上浮`到合适的位置\n\nDelMax方法 删除顶部元素 将数组的最后一个元素放到顶部 将其`下沉`到合适的位置 减小了堆的大小 将\n\n\n**堆**\n\n二叉堆: 每个元素都要保证小于等于(大于等于)另外两个特定位置的元素. 其根节点是最小(最大)元素\n\n1. 二叉堆的指针表示法\n\n需要使用三个指针, 指向父节点和两个子节点\n\n2. 使用数组\n\n完全二叉树可以使用数组表示 不使用数组的0位置元素 从1开始 k的子节点分别在2k和2k+1\n\n\n**堆的有序化**\n\n以最大堆为例\n\n1. 由下至上的堆有序化 `上浮`\n\n堆的有序状态因为 某个节点比他的父节点更大 被打破.\n\n需要与父节点交换, 不断向上直到遇到一个更大的父节点 或者到了顶部\n\n2. 由上至下的堆有序化 `下浮`\n\n堆的有序状态因为 某个父节点比 他的两个子节点或其中之一子节点 小 被打破.\n\n将父节点与子节点中较大的一个进行交换直到它的子节点都比它小 获得到了底部\n\n\n# 第三章 查找\n\n符号表: 最主要的目的是是将`one key`和`one value`联系起来, 是一种存储键值对的数据结构, 支持插入和查找\n\n| 使用的数据结构 | 实现 | 优点 | 缺点 |\n| --- | --- | --- | -- |\n| 链表(顺序查找) | SequentialSearchST | 适用于小型问题 | 对于大型表很慢 |\n| 有序数组(二分) | BinarySearchST | 最优的查找和空间需求, 能够进行有序性相关的操作 | 插入操作很慢 |\n| 二叉查找树 | BST | 实现简单, 能够进行有序性相关的操作 | 没有性能上界的保证, 链接需要额外的空间 |\n| 平衡二叉树 | RedBlackBST | 最优的查找和插入效率, 能够进行有序性相关的操作 | 链接需要额外的空间 |\n| 散列表 | SeparateChainHashST LinearProbingHashST | 能够快速的查找和插入常见的数据类型 | 需要计算散列, 无法进行有序性相关操作, 链接和空节点需要额外的空间 |\n\n","source":"_posts/算法92-算法四.md","raw":"---\ntitle: 算法四\ndate: 2020-07-17 15:51:28\ntags:\ncategories:\n - 算法\ntop: 92\nimg: https://algs4.cs.princeton.edu/cover.png\n---\n\n来之不易的暑期留校, 一半献给算法.\n\n# 第二章 排序\n\n选择排序\n- 运行时间和输入的数据无关, 仅和数量有关.\n不会利用输入的初始状态\n- 数据移动是最少的\n我们将研究的其他任何算法 都不具备这个特性.....\n\n插入排序\n- 适合小规模数组\n- 对于部分有序的数组, 处理起来很有效\n- 倒置的数量很少时, 插入排序很可能比其他算法还要快\n\n希尔排序\n- 插入排序对于大规模乱序数组很慢, 因为它只会交换相邻元素, 因此为了改进插入排序的局部性,提出了希尔排序\n- 希尔排序交换不相邻的元素以对数组的局部性进行排序, 最终用插入排序调整局部有序的数组\n\n归并排序\n- 原地归并排序\n- 自顶向下 递归实现 分治思想\n- 自底向上 从归并微型数组到整体归并\n\n快速排序\n- 分治排序算法\n\n堆排序\n- 只能说妙啊.. 这本书先讲的优先队列如何实现, 然后紧接着就用sink方法完成了堆排序\n\n\n**稳定性**\n\n某地在某时下雨 时间和地点存在对应关系.\n按照时间排序后, 再按照地点排序 单个地点的时间排序就很可能被打乱\n\n稳定, 则时间排序没有被打乱. 不稳定, 很可能时间排序被打乱\n\n\n| 算法     | 是否稳定 | 是否为原地排序 | 时间复杂度 | 空间复杂度 | 备注                                                               |\n| -------- | -------- | -------------- | ---------- | ---------- | ------------------------------------------------------------------ |\n| 选择排序 | 否       | 是             | N^2        | 1          | 最简单粗暴的方式, 交换次数最少                                     |\n| 插入排序 | 是       | 是             | 介于N与N^2 | 1          | 很大程度取决输入元素的排列情况, 如果倒置元素很少则性能可能超过快排 |\n| 希尔排序 | 否       | 是             |            | 1          | 插入排序的改良版, 改善了插入排序过于局限                           |\n| 快速排序 | 否       | 是             | NlogN      | lgN        | 分治, 运行效率由概率保证                                           |\n| 归并排序 | 是       | 否             | NlogN      | N          | 自顶向下(递归 分治)和自底向上(从局部到整体) 两种方法               |\n| 堆排序   | 否       | 是             | NlogN      | 1          | 学完后突然想到了如果在很多的数字中找到最大的多少个数这种问题       |\n\n\n\n**2.4 优先队列**\n\n需要支持两种操作, 删除最大元素和插入元素  - 优先级队列\n\n\n1. 数组实现(无序) - 插入快 删除慢\n\nInsert方法 直接将元素插入尾部, 类似栈的push方法\n\nDelMax方法 使用一个内部循环找出最大的元素和边界元素交换 然后删除边界元素, 删除的时候类似pop方法\n\n2. 数组实现(有序) - 插入慢 删除快\n\nInsert方法 中进行排序, 插入新的元素的时候将较大元素向右移动一格位置, 然后插入新的元素\n\nDelMax方法 直接删除右侧元素, 类似栈的pop方法\n\n3. 链表表示法\n\n无序序列是解决问题的惰性方法, 仅在必要的时候才会采取行动 找出最大元素\n\n有序序列是解决问题的积极方法, 尽可能的未雨绸缪, 使得找出最大元素高效\n\n4. `二叉堆`表示法 - 插入和删除都为线性对数级别\n\nInsert方法 将新元素添加到数组末端, 增加了堆的大小 将新元素`上浮`到合适的位置\n\nDelMax方法 删除顶部元素 将数组的最后一个元素放到顶部 将其`下沉`到合适的位置 减小了堆的大小 将\n\n\n**堆**\n\n二叉堆: 每个元素都要保证小于等于(大于等于)另外两个特定位置的元素. 其根节点是最小(最大)元素\n\n1. 二叉堆的指针表示法\n\n需要使用三个指针, 指向父节点和两个子节点\n\n2. 使用数组\n\n完全二叉树可以使用数组表示 不使用数组的0位置元素 从1开始 k的子节点分别在2k和2k+1\n\n\n**堆的有序化**\n\n以最大堆为例\n\n1. 由下至上的堆有序化 `上浮`\n\n堆的有序状态因为 某个节点比他的父节点更大 被打破.\n\n需要与父节点交换, 不断向上直到遇到一个更大的父节点 或者到了顶部\n\n2. 由上至下的堆有序化 `下浮`\n\n堆的有序状态因为 某个父节点比 他的两个子节点或其中之一子节点 小 被打破.\n\n将父节点与子节点中较大的一个进行交换直到它的子节点都比它小 获得到了底部\n\n\n# 第三章 查找\n\n符号表: 最主要的目的是是将`one key`和`one value`联系起来, 是一种存储键值对的数据结构, 支持插入和查找\n\n| 使用的数据结构 | 实现 | 优点 | 缺点 |\n| --- | --- | --- | -- |\n| 链表(顺序查找) | SequentialSearchST | 适用于小型问题 | 对于大型表很慢 |\n| 有序数组(二分) | BinarySearchST | 最优的查找和空间需求, 能够进行有序性相关的操作 | 插入操作很慢 |\n| 二叉查找树 | BST | 实现简单, 能够进行有序性相关的操作 | 没有性能上界的保证, 链接需要额外的空间 |\n| 平衡二叉树 | RedBlackBST | 最优的查找和插入效率, 能够进行有序性相关的操作 | 链接需要额外的空间 |\n| 散列表 | SeparateChainHashST LinearProbingHashST | 能够快速的查找和插入常见的数据类型 | 需要计算散列, 无法进行有序性相关操作, 链接和空节点需要额外的空间 |\n\n","slug":"算法92-算法四","published":1,"updated":"2020-11-04T14:30:35.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg700032f8unhr7khtja","content":"<p>来之不易的暑期留校, 一半献给算法.</p>\n<h1 id=\"第二章-排序\"><a href=\"#第二章-排序\" class=\"headerlink\" title=\"第二章 排序\"></a>第二章 排序</h1><p>选择排序</p>\n<ul>\n<li>运行时间和输入的数据无关, 仅和数量有关.<br>不会利用输入的初始状态</li>\n<li>数据移动是最少的<br>我们将研究的其他任何算法 都不具备这个特性…..</li>\n</ul>\n<p>插入排序</p>\n<ul>\n<li>适合小规模数组</li>\n<li>对于部分有序的数组, 处理起来很有效</li>\n<li>倒置的数量很少时, 插入排序很可能比其他算法还要快</li>\n</ul>\n<p>希尔排序</p>\n<ul>\n<li>插入排序对于大规模乱序数组很慢, 因为它只会交换相邻元素, 因此为了改进插入排序的局部性,提出了希尔排序</li>\n<li>希尔排序交换不相邻的元素以对数组的局部性进行排序, 最终用插入排序调整局部有序的数组</li>\n</ul>\n<p>归并排序</p>\n<ul>\n<li>原地归并排序</li>\n<li>自顶向下 递归实现 分治思想</li>\n<li>自底向上 从归并微型数组到整体归并</li>\n</ul>\n<p>快速排序</p>\n<ul>\n<li>分治排序算法</li>\n</ul>\n<p>堆排序</p>\n<ul>\n<li>只能说妙啊.. 这本书先讲的优先队列如何实现, 然后紧接着就用sink方法完成了堆排序</li>\n</ul>\n<p><strong>稳定性</strong></p>\n<p>某地在某时下雨 时间和地点存在对应关系.<br>按照时间排序后, 再按照地点排序 单个地点的时间排序就很可能被打乱</p>\n<p>稳定, 则时间排序没有被打乱. 不稳定, 很可能时间排序被打乱</p>\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th>是否稳定</th>\n<th>是否为原地排序</th>\n<th>时间复杂度</th>\n<th>空间复杂度</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>选择排序</td>\n<td>否</td>\n<td>是</td>\n<td>N^2</td>\n<td>1</td>\n<td>最简单粗暴的方式, 交换次数最少</td>\n</tr>\n<tr>\n<td>插入排序</td>\n<td>是</td>\n<td>是</td>\n<td>介于N与N^2</td>\n<td>1</td>\n<td>很大程度取决输入元素的排列情况, 如果倒置元素很少则性能可能超过快排</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td>否</td>\n<td>是</td>\n<td></td>\n<td>1</td>\n<td>插入排序的改良版, 改善了插入排序过于局限</td>\n</tr>\n<tr>\n<td>快速排序</td>\n<td>否</td>\n<td>是</td>\n<td>NlogN</td>\n<td>lgN</td>\n<td>分治, 运行效率由概率保证</td>\n</tr>\n<tr>\n<td>归并排序</td>\n<td>是</td>\n<td>否</td>\n<td>NlogN</td>\n<td>N</td>\n<td>自顶向下(递归 分治)和自底向上(从局部到整体) 两种方法</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>否</td>\n<td>是</td>\n<td>NlogN</td>\n<td>1</td>\n<td>学完后突然想到了如果在很多的数字中找到最大的多少个数这种问题</td>\n</tr>\n</tbody></table>\n<p><strong>2.4 优先队列</strong></p>\n<p>需要支持两种操作, 删除最大元素和插入元素  - 优先级队列</p>\n<ol>\n<li>数组实现(无序) - 插入快 删除慢</li>\n</ol>\n<p>Insert方法 直接将元素插入尾部, 类似栈的push方法</p>\n<p>DelMax方法 使用一个内部循环找出最大的元素和边界元素交换 然后删除边界元素, 删除的时候类似pop方法</p>\n<ol start=\"2\">\n<li>数组实现(有序) - 插入慢 删除快</li>\n</ol>\n<p>Insert方法 中进行排序, 插入新的元素的时候将较大元素向右移动一格位置, 然后插入新的元素</p>\n<p>DelMax方法 直接删除右侧元素, 类似栈的pop方法</p>\n<ol start=\"3\">\n<li>链表表示法</li>\n</ol>\n<p>无序序列是解决问题的惰性方法, 仅在必要的时候才会采取行动 找出最大元素</p>\n<p>有序序列是解决问题的积极方法, 尽可能的未雨绸缪, 使得找出最大元素高效</p>\n<ol start=\"4\">\n<li><code>二叉堆</code>表示法 - 插入和删除都为线性对数级别</li>\n</ol>\n<p>Insert方法 将新元素添加到数组末端, 增加了堆的大小 将新元素<code>上浮</code>到合适的位置</p>\n<p>DelMax方法 删除顶部元素 将数组的最后一个元素放到顶部 将其<code>下沉</code>到合适的位置 减小了堆的大小 将</p>\n<p><strong>堆</strong></p>\n<p>二叉堆: 每个元素都要保证小于等于(大于等于)另外两个特定位置的元素. 其根节点是最小(最大)元素</p>\n<ol>\n<li>二叉堆的指针表示法</li>\n</ol>\n<p>需要使用三个指针, 指向父节点和两个子节点</p>\n<ol start=\"2\">\n<li>使用数组</li>\n</ol>\n<p>完全二叉树可以使用数组表示 不使用数组的0位置元素 从1开始 k的子节点分别在2k和2k+1</p>\n<p><strong>堆的有序化</strong></p>\n<p>以最大堆为例</p>\n<ol>\n<li>由下至上的堆有序化 <code>上浮</code></li>\n</ol>\n<p>堆的有序状态因为 某个节点比他的父节点更大 被打破.</p>\n<p>需要与父节点交换, 不断向上直到遇到一个更大的父节点 或者到了顶部</p>\n<ol start=\"2\">\n<li>由上至下的堆有序化 <code>下浮</code></li>\n</ol>\n<p>堆的有序状态因为 某个父节点比 他的两个子节点或其中之一子节点 小 被打破.</p>\n<p>将父节点与子节点中较大的一个进行交换直到它的子节点都比它小 获得到了底部</p>\n<h1 id=\"第三章-查找\"><a href=\"#第三章-查找\" class=\"headerlink\" title=\"第三章 查找\"></a>第三章 查找</h1><p>符号表: 最主要的目的是是将<code>one key</code>和<code>one value</code>联系起来, 是一种存储键值对的数据结构, 支持插入和查找</p>\n<table>\n<thead>\n<tr>\n<th>使用的数据结构</th>\n<th>实现</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>链表(顺序查找)</td>\n<td>SequentialSearchST</td>\n<td>适用于小型问题</td>\n<td>对于大型表很慢</td>\n</tr>\n<tr>\n<td>有序数组(二分)</td>\n<td>BinarySearchST</td>\n<td>最优的查找和空间需求, 能够进行有序性相关的操作</td>\n<td>插入操作很慢</td>\n</tr>\n<tr>\n<td>二叉查找树</td>\n<td>BST</td>\n<td>实现简单, 能够进行有序性相关的操作</td>\n<td>没有性能上界的保证, 链接需要额外的空间</td>\n</tr>\n<tr>\n<td>平衡二叉树</td>\n<td>RedBlackBST</td>\n<td>最优的查找和插入效率, 能够进行有序性相关的操作</td>\n<td>链接需要额外的空间</td>\n</tr>\n<tr>\n<td>散列表</td>\n<td>SeparateChainHashST LinearProbingHashST</td>\n<td>能够快速的查找和插入常见的数据类型</td>\n<td>需要计算散列, 无法进行有序性相关操作, 链接和空节点需要额外的空间</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p>来之不易的暑期留校, 一半献给算法.</p>\n<h1 id=\"第二章-排序\"><a href=\"#第二章-排序\" class=\"headerlink\" title=\"第二章 排序\"></a>第二章 排序</h1><p>选择排序</p>\n<ul>\n<li>运行时间和输入的数据无关, 仅和数量有关.<br>不会利用输入的初始状态</li>\n<li>数据移动是最少的<br>我们将研究的其他任何算法 都不具备这个特性…..</li>\n</ul>\n<p>插入排序</p>\n<ul>\n<li>适合小规模数组</li>\n<li>对于部分有序的数组, 处理起来很有效</li>\n<li>倒置的数量很少时, 插入排序很可能比其他算法还要快</li>\n</ul>\n<p>希尔排序</p>\n<ul>\n<li>插入排序对于大规模乱序数组很慢, 因为它只会交换相邻元素, 因此为了改进插入排序的局部性,提出了希尔排序</li>\n<li>希尔排序交换不相邻的元素以对数组的局部性进行排序, 最终用插入排序调整局部有序的数组</li>\n</ul>\n<p>归并排序</p>\n<ul>\n<li>原地归并排序</li>\n<li>自顶向下 递归实现 分治思想</li>\n<li>自底向上 从归并微型数组到整体归并</li>\n</ul>\n<p>快速排序</p>\n<ul>\n<li>分治排序算法</li>\n</ul>\n<p>堆排序</p>\n<ul>\n<li>只能说妙啊.. 这本书先讲的优先队列如何实现, 然后紧接着就用sink方法完成了堆排序</li>\n</ul>\n<p><strong>稳定性</strong></p>\n<p>某地在某时下雨 时间和地点存在对应关系.<br>按照时间排序后, 再按照地点排序 单个地点的时间排序就很可能被打乱</p>\n<p>稳定, 则时间排序没有被打乱. 不稳定, 很可能时间排序被打乱</p>\n<table>\n<thead>\n<tr>\n<th>算法</th>\n<th>是否稳定</th>\n<th>是否为原地排序</th>\n<th>时间复杂度</th>\n<th>空间复杂度</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>选择排序</td>\n<td>否</td>\n<td>是</td>\n<td>N^2</td>\n<td>1</td>\n<td>最简单粗暴的方式, 交换次数最少</td>\n</tr>\n<tr>\n<td>插入排序</td>\n<td>是</td>\n<td>是</td>\n<td>介于N与N^2</td>\n<td>1</td>\n<td>很大程度取决输入元素的排列情况, 如果倒置元素很少则性能可能超过快排</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td>否</td>\n<td>是</td>\n<td></td>\n<td>1</td>\n<td>插入排序的改良版, 改善了插入排序过于局限</td>\n</tr>\n<tr>\n<td>快速排序</td>\n<td>否</td>\n<td>是</td>\n<td>NlogN</td>\n<td>lgN</td>\n<td>分治, 运行效率由概率保证</td>\n</tr>\n<tr>\n<td>归并排序</td>\n<td>是</td>\n<td>否</td>\n<td>NlogN</td>\n<td>N</td>\n<td>自顶向下(递归 分治)和自底向上(从局部到整体) 两种方法</td>\n</tr>\n<tr>\n<td>堆排序</td>\n<td>否</td>\n<td>是</td>\n<td>NlogN</td>\n<td>1</td>\n<td>学完后突然想到了如果在很多的数字中找到最大的多少个数这种问题</td>\n</tr>\n</tbody></table>\n<p><strong>2.4 优先队列</strong></p>\n<p>需要支持两种操作, 删除最大元素和插入元素  - 优先级队列</p>\n<ol>\n<li>数组实现(无序) - 插入快 删除慢</li>\n</ol>\n<p>Insert方法 直接将元素插入尾部, 类似栈的push方法</p>\n<p>DelMax方法 使用一个内部循环找出最大的元素和边界元素交换 然后删除边界元素, 删除的时候类似pop方法</p>\n<ol start=\"2\">\n<li>数组实现(有序) - 插入慢 删除快</li>\n</ol>\n<p>Insert方法 中进行排序, 插入新的元素的时候将较大元素向右移动一格位置, 然后插入新的元素</p>\n<p>DelMax方法 直接删除右侧元素, 类似栈的pop方法</p>\n<ol start=\"3\">\n<li>链表表示法</li>\n</ol>\n<p>无序序列是解决问题的惰性方法, 仅在必要的时候才会采取行动 找出最大元素</p>\n<p>有序序列是解决问题的积极方法, 尽可能的未雨绸缪, 使得找出最大元素高效</p>\n<ol start=\"4\">\n<li><code>二叉堆</code>表示法 - 插入和删除都为线性对数级别</li>\n</ol>\n<p>Insert方法 将新元素添加到数组末端, 增加了堆的大小 将新元素<code>上浮</code>到合适的位置</p>\n<p>DelMax方法 删除顶部元素 将数组的最后一个元素放到顶部 将其<code>下沉</code>到合适的位置 减小了堆的大小 将</p>\n<p><strong>堆</strong></p>\n<p>二叉堆: 每个元素都要保证小于等于(大于等于)另外两个特定位置的元素. 其根节点是最小(最大)元素</p>\n<ol>\n<li>二叉堆的指针表示法</li>\n</ol>\n<p>需要使用三个指针, 指向父节点和两个子节点</p>\n<ol start=\"2\">\n<li>使用数组</li>\n</ol>\n<p>完全二叉树可以使用数组表示 不使用数组的0位置元素 从1开始 k的子节点分别在2k和2k+1</p>\n<p><strong>堆的有序化</strong></p>\n<p>以最大堆为例</p>\n<ol>\n<li>由下至上的堆有序化 <code>上浮</code></li>\n</ol>\n<p>堆的有序状态因为 某个节点比他的父节点更大 被打破.</p>\n<p>需要与父节点交换, 不断向上直到遇到一个更大的父节点 或者到了顶部</p>\n<ol start=\"2\">\n<li>由上至下的堆有序化 <code>下浮</code></li>\n</ol>\n<p>堆的有序状态因为 某个父节点比 他的两个子节点或其中之一子节点 小 被打破.</p>\n<p>将父节点与子节点中较大的一个进行交换直到它的子节点都比它小 获得到了底部</p>\n<h1 id=\"第三章-查找\"><a href=\"#第三章-查找\" class=\"headerlink\" title=\"第三章 查找\"></a>第三章 查找</h1><p>符号表: 最主要的目的是是将<code>one key</code>和<code>one value</code>联系起来, 是一种存储键值对的数据结构, 支持插入和查找</p>\n<table>\n<thead>\n<tr>\n<th>使用的数据结构</th>\n<th>实现</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>链表(顺序查找)</td>\n<td>SequentialSearchST</td>\n<td>适用于小型问题</td>\n<td>对于大型表很慢</td>\n</tr>\n<tr>\n<td>有序数组(二分)</td>\n<td>BinarySearchST</td>\n<td>最优的查找和空间需求, 能够进行有序性相关的操作</td>\n<td>插入操作很慢</td>\n</tr>\n<tr>\n<td>二叉查找树</td>\n<td>BST</td>\n<td>实现简单, 能够进行有序性相关的操作</td>\n<td>没有性能上界的保证, 链接需要额外的空间</td>\n</tr>\n<tr>\n<td>平衡二叉树</td>\n<td>RedBlackBST</td>\n<td>最优的查找和插入效率, 能够进行有序性相关的操作</td>\n<td>链接需要额外的空间</td>\n</tr>\n<tr>\n<td>散列表</td>\n<td>SeparateChainHashST LinearProbingHashST</td>\n<td>能够快速的查找和插入常见的数据类型</td>\n<td>需要计算散列, 无法进行有序性相关操作, 链接和空节点需要额外的空间</td>\n</tr>\n</tbody></table>\n"},{"title":"面试题点带面","date":"2020-04-11T03:00:20.000Z","_content":"\n马上步入四月中旬了, 自己对于socket理论知识知道的还是不多, 于是想了下可以整理下面试题.\n\n单纯整理\"正确答案\"怎么行. 我相信大部分面试题代表的都是某个知识点 某个知识面 或有他的重要实际应用\n\n部分题目是我自己凭空想出来的, 单独开一篇博客又不是内容足够, 索性放在一起\n\n# 基础api相关\n## send发送的时候会自动转换字节序??\n\n作为开篇问题, 我选了这个. 这个问题也算是困扰了一段时间.\n网上的解答自然已经有了\nhttps://stackoverflow.com/questions/23106938/do-recv-and-send-convert-the-messages-in-network-order-format-automatically\n\n最先接触到socket字节序转换相信大多是`htons()`\n这个说明是将主机字节序转换成网络字节序, 我使用的自然是小端 将小端转换成大端 反转链表就好\n而在大端上 头文件自动选择了`htons()`空命令版本\n\n起初我使用send发送全是 类似string的东西 char*保存, 单字节数据自然不会受字节序影响\n\n但是最近学习了moduo后发现了发送数字的实际应用\n对于一个 `int32_t`类型的数字需要调用`htobe32()`转换成`大端序`然后`std::copy`到buffer中\n接收端读取出四个字节 `std::copy`到`int32_t`中, 需要调用下`be32toh()`转换成`小端序` 这就涉及到了字节序转换\n\n总结下就是单字节数据比如发送一个字符串 是不会收到字节序影响\n而如果你直接发送数字比如`int32_t` 就会受到影响\n\n## SIGPIPE信号触发原因和防治\n\nclient与server建立连接后 在server发送信息给client的时候, 由于client已经退出,\nclient方会向server发送RST. 此时server向已经接收到RST的client的socket继续写入数据 会导致SIGPIPE信号\n```c++\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cstring>\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n\nint main()\n{\n    int listen_fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in listen_address{};\n    listen_address.sin_family = AF_INET;\n    listen_address.sin_port = htons(9123);\n\n    int ret = bind(listen_fd, (struct sockaddr*)&listen_address,\n            static_cast<socklen_t>(sizeof listen_address));\n    if (ret == -1)\n    {\n        printf(\"%s\\n\", strerror(errno));\n        exit(ret);\n    }\n\n    ret = listen(listen_fd, 5);\n\n    struct sockaddr_in client_address{};\n    socklen_t client_address_len = static_cast<socklen_t>(sizeof client_address);\n\n    int client_fd = accept(listen_fd, (struct sockaddr*)&client_address,\n            &client_address_len);\n\n    sleep(5);\n    char msg_first[20] = {\"first message\\n\"};\n    send(client_fd, msg_first, strlen(msg_first), 0);\n    // 第一条信息发送后收到RST\n\n    sleep(2);\n    char msg_second[20] = {\"second message\\n\"};\n    send(client_fd, msg_second, strlen(msg_second), 0);\n    // 第二次信息发送后出现SIGPIPE\n\n    return 0;\n}\n```\n\n测试代码如上 运行nc 127.0.0.1 9123后立刻按下Ctrl+C杀死client  截获的所有数据包如下\n\n```\n[root@fish ~]# tcpdump -i lo -Xx tcp port 9123\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes\n00:26:27.780746 IP localhost.40580 > localhost.grcp: Flags [S], seq 2027132643, win 43690, options [mss 65495,sackOK,TS val 1567772563 ecr 0,nop,wscale 7], length 0\n\t0x0000:  4500 003c db97 4000 4006 6122 7f00 0001  E..<..@.@.a\"....\n\t0x0010:  7f00 0001 9e84 23a3 78d3 96e3 0000 0000  ......#.x.......\n\t0x0020:  a002 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........\n\t0x0030:  5d72 4f93 0000 0000 0103 0307            ]rO.........\n00:26:27.780802 IP localhost.grcp > localhost.40580: Flags [S.], seq 2570863062, ack 2027132644, win 43690, options [mss 65495,sackOK,TS val 1567772563 ecr 1567772563,nop,wscale 7], length 0\n\t0x0000:  4500 003c 0000 4000 4006 3cba 7f00 0001  E..<..@.@.<.....\n\t0x0010:  7f00 0001 23a3 9e84 993c 41d6 78d3 96e4  ....#....<A.x...\n\t0x0020:  a012 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........\n\t0x0030:  5d72 4f93 5d72 4f93 0103 0307            ]rO.]rO.....\n00:26:27.780839 IP localhost.40580 > localhost.grcp: Flags [.], ack 1, win 342, options [nop,nop,TS val 1567772563 ecr 1567772563], length 0\n\t0x0000:  4500 0034 db98 4000 4006 6129 7f00 0001  E..4..@.@.a)....\n\t0x0010:  7f00 0001 9e84 23a3 78d3 96e4 993c 41d7  ......#.x....<A.\n\t0x0020:  8010 0156 fe28 0000 0101 080a 5d72 4f93  ...V.(......]rO.\n\t0x0030:  5d72 4f93                                ]rO.\n\n三次握手结束后 由于立刻按下了Ctrl+C 客户端连接异常结束 发送FIN\n\n00:26:27.969734 IP localhost.40580 > localhost.grcp: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 1567772752 ecr 1567772563], length 0\n\t0x0000:  4500 0034 db99 4000 4006 6128 7f00 0001  E..4..@.@.a(....\n\t0x0010:  7f00 0001 9e84 23a3 78d3 96e4 993c 41d7  ......#.x....<A.\n\t0x0020:  8011 0156 fe28 0000 0101 080a 5d72 5050  ...V.(......]rPP\n\t0x0030:  5d72 4f93                                ]rO.\n\n服务端回复收到FIN\n\n00:26:27.970294 IP localhost.grcp > localhost.40580: Flags [.], ack 2, win 342, options [nop,nop,TS val 1567772753 ecr 1567772752], length 0\n\t0x0000:  4500 0034 8f0d 4000 4006 adb4 7f00 0001  E..4..@.@.......\n\t0x0010:  7f00 0001 23a3 9e84 993c 41d7 78d3 96e5  ....#....<A.x...\n\t0x0020:  8010 0156 fe28 0000 0101 080a 5d72 5051  ...V.(......]rPQ\n\t0x0030:  5d72 5050                                ]rPP\n\n第一次写入信息\n\n00:26:32.781104 IP localhost.grcp > localhost.40580: Flags [P.], seq 1:15, ack 2, win 342, options [nop,nop,TS val 1567777564 ecr 1567772752], length 14\n\t0x0000:  4500 0042 8f0e 4000 4006 ada5 7f00 0001  E..B..@.@.......\n\t0x0010:  7f00 0001 23a3 9e84 993c 41d7 78d3 96e5  ....#....<A.x...\n\t0x0020:  8018 0156 fe36 0000 0101 080a 5d72 631c  ...V.6......]rc.\n\t0x0030:  5d72 5050 6669 7273 7420 6d65 7373 6167  ]rPPfirst.messag\n\t0x0040:  650a                                     e.\n\n收到客户端返回的复位RST\n\n00:26:32.781155 IP localhost.40580 > localhost.grcp: Flags [R], seq 2027132645, win 0, length 0\n\t0x0000:  4500 0028 0000 4000 4006 3cce 7f00 0001  E..(..@.@.<.....\n\t0x0010:  7f00 0001 9e84 23a3 78d3 96e5 0000 0000  ......#.x.......\n\t0x0020:  5004 0000 dffd 0000                      P.......\n\n第二次写入信息触发 SIGPIPE\n```\n\n方式SIGPIPE中断进程使用`signal(SIGPIPE, SIG_IGN)`忽略这个信号, 这时send会返回-1并设置errno=EPIPE","source":"_posts/网络编程-Socket理论-面试题点带面.md","raw":"---\ntitle: 面试题点带面\ndate: 2020-04-11 11:00:20\ntags:\ncategories:\n  - 网络编程\n  - Socket理论\n---\n\n马上步入四月中旬了, 自己对于socket理论知识知道的还是不多, 于是想了下可以整理下面试题.\n\n单纯整理\"正确答案\"怎么行. 我相信大部分面试题代表的都是某个知识点 某个知识面 或有他的重要实际应用\n\n部分题目是我自己凭空想出来的, 单独开一篇博客又不是内容足够, 索性放在一起\n\n# 基础api相关\n## send发送的时候会自动转换字节序??\n\n作为开篇问题, 我选了这个. 这个问题也算是困扰了一段时间.\n网上的解答自然已经有了\nhttps://stackoverflow.com/questions/23106938/do-recv-and-send-convert-the-messages-in-network-order-format-automatically\n\n最先接触到socket字节序转换相信大多是`htons()`\n这个说明是将主机字节序转换成网络字节序, 我使用的自然是小端 将小端转换成大端 反转链表就好\n而在大端上 头文件自动选择了`htons()`空命令版本\n\n起初我使用send发送全是 类似string的东西 char*保存, 单字节数据自然不会受字节序影响\n\n但是最近学习了moduo后发现了发送数字的实际应用\n对于一个 `int32_t`类型的数字需要调用`htobe32()`转换成`大端序`然后`std::copy`到buffer中\n接收端读取出四个字节 `std::copy`到`int32_t`中, 需要调用下`be32toh()`转换成`小端序` 这就涉及到了字节序转换\n\n总结下就是单字节数据比如发送一个字符串 是不会收到字节序影响\n而如果你直接发送数字比如`int32_t` 就会受到影响\n\n## SIGPIPE信号触发原因和防治\n\nclient与server建立连接后 在server发送信息给client的时候, 由于client已经退出,\nclient方会向server发送RST. 此时server向已经接收到RST的client的socket继续写入数据 会导致SIGPIPE信号\n```c++\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <cstring>\n#include <unistd.h>\n#include <stdio.h>\n#include <errno.h>\n#include <stdlib.h>\n\nint main()\n{\n    int listen_fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    struct sockaddr_in listen_address{};\n    listen_address.sin_family = AF_INET;\n    listen_address.sin_port = htons(9123);\n\n    int ret = bind(listen_fd, (struct sockaddr*)&listen_address,\n            static_cast<socklen_t>(sizeof listen_address));\n    if (ret == -1)\n    {\n        printf(\"%s\\n\", strerror(errno));\n        exit(ret);\n    }\n\n    ret = listen(listen_fd, 5);\n\n    struct sockaddr_in client_address{};\n    socklen_t client_address_len = static_cast<socklen_t>(sizeof client_address);\n\n    int client_fd = accept(listen_fd, (struct sockaddr*)&client_address,\n            &client_address_len);\n\n    sleep(5);\n    char msg_first[20] = {\"first message\\n\"};\n    send(client_fd, msg_first, strlen(msg_first), 0);\n    // 第一条信息发送后收到RST\n\n    sleep(2);\n    char msg_second[20] = {\"second message\\n\"};\n    send(client_fd, msg_second, strlen(msg_second), 0);\n    // 第二次信息发送后出现SIGPIPE\n\n    return 0;\n}\n```\n\n测试代码如上 运行nc 127.0.0.1 9123后立刻按下Ctrl+C杀死client  截获的所有数据包如下\n\n```\n[root@fish ~]# tcpdump -i lo -Xx tcp port 9123\ntcpdump: verbose output suppressed, use -v or -vv for full protocol decode\nlistening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes\n00:26:27.780746 IP localhost.40580 > localhost.grcp: Flags [S], seq 2027132643, win 43690, options [mss 65495,sackOK,TS val 1567772563 ecr 0,nop,wscale 7], length 0\n\t0x0000:  4500 003c db97 4000 4006 6122 7f00 0001  E..<..@.@.a\"....\n\t0x0010:  7f00 0001 9e84 23a3 78d3 96e3 0000 0000  ......#.x.......\n\t0x0020:  a002 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........\n\t0x0030:  5d72 4f93 0000 0000 0103 0307            ]rO.........\n00:26:27.780802 IP localhost.grcp > localhost.40580: Flags [S.], seq 2570863062, ack 2027132644, win 43690, options [mss 65495,sackOK,TS val 1567772563 ecr 1567772563,nop,wscale 7], length 0\n\t0x0000:  4500 003c 0000 4000 4006 3cba 7f00 0001  E..<..@.@.<.....\n\t0x0010:  7f00 0001 23a3 9e84 993c 41d6 78d3 96e4  ....#....<A.x...\n\t0x0020:  a012 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........\n\t0x0030:  5d72 4f93 5d72 4f93 0103 0307            ]rO.]rO.....\n00:26:27.780839 IP localhost.40580 > localhost.grcp: Flags [.], ack 1, win 342, options [nop,nop,TS val 1567772563 ecr 1567772563], length 0\n\t0x0000:  4500 0034 db98 4000 4006 6129 7f00 0001  E..4..@.@.a)....\n\t0x0010:  7f00 0001 9e84 23a3 78d3 96e4 993c 41d7  ......#.x....<A.\n\t0x0020:  8010 0156 fe28 0000 0101 080a 5d72 4f93  ...V.(......]rO.\n\t0x0030:  5d72 4f93                                ]rO.\n\n三次握手结束后 由于立刻按下了Ctrl+C 客户端连接异常结束 发送FIN\n\n00:26:27.969734 IP localhost.40580 > localhost.grcp: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 1567772752 ecr 1567772563], length 0\n\t0x0000:  4500 0034 db99 4000 4006 6128 7f00 0001  E..4..@.@.a(....\n\t0x0010:  7f00 0001 9e84 23a3 78d3 96e4 993c 41d7  ......#.x....<A.\n\t0x0020:  8011 0156 fe28 0000 0101 080a 5d72 5050  ...V.(......]rPP\n\t0x0030:  5d72 4f93                                ]rO.\n\n服务端回复收到FIN\n\n00:26:27.970294 IP localhost.grcp > localhost.40580: Flags [.], ack 2, win 342, options [nop,nop,TS val 1567772753 ecr 1567772752], length 0\n\t0x0000:  4500 0034 8f0d 4000 4006 adb4 7f00 0001  E..4..@.@.......\n\t0x0010:  7f00 0001 23a3 9e84 993c 41d7 78d3 96e5  ....#....<A.x...\n\t0x0020:  8010 0156 fe28 0000 0101 080a 5d72 5051  ...V.(......]rPQ\n\t0x0030:  5d72 5050                                ]rPP\n\n第一次写入信息\n\n00:26:32.781104 IP localhost.grcp > localhost.40580: Flags [P.], seq 1:15, ack 2, win 342, options [nop,nop,TS val 1567777564 ecr 1567772752], length 14\n\t0x0000:  4500 0042 8f0e 4000 4006 ada5 7f00 0001  E..B..@.@.......\n\t0x0010:  7f00 0001 23a3 9e84 993c 41d7 78d3 96e5  ....#....<A.x...\n\t0x0020:  8018 0156 fe36 0000 0101 080a 5d72 631c  ...V.6......]rc.\n\t0x0030:  5d72 5050 6669 7273 7420 6d65 7373 6167  ]rPPfirst.messag\n\t0x0040:  650a                                     e.\n\n收到客户端返回的复位RST\n\n00:26:32.781155 IP localhost.40580 > localhost.grcp: Flags [R], seq 2027132645, win 0, length 0\n\t0x0000:  4500 0028 0000 4000 4006 3cce 7f00 0001  E..(..@.@.<.....\n\t0x0010:  7f00 0001 9e84 23a3 78d3 96e5 0000 0000  ......#.x.......\n\t0x0020:  5004 0000 dffd 0000                      P.......\n\n第二次写入信息触发 SIGPIPE\n```\n\n方式SIGPIPE中断进程使用`signal(SIGPIPE, SIG_IGN)`忽略这个信号, 这时send会返回-1并设置errno=EPIPE","slug":"网络编程-Socket理论-面试题点带面","published":1,"updated":"2020-12-05T02:26:18.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg710036f8un5n82gst5","content":"<p>马上步入四月中旬了, 自己对于socket理论知识知道的还是不多, 于是想了下可以整理下面试题.</p>\n<p>单纯整理”正确答案”怎么行. 我相信大部分面试题代表的都是某个知识点 某个知识面 或有他的重要实际应用</p>\n<p>部分题目是我自己凭空想出来的, 单独开一篇博客又不是内容足够, 索性放在一起</p>\n<h1 id=\"基础api相关\"><a href=\"#基础api相关\" class=\"headerlink\" title=\"基础api相关\"></a>基础api相关</h1><h2 id=\"send发送的时候会自动转换字节序\"><a href=\"#send发送的时候会自动转换字节序\" class=\"headerlink\" title=\"send发送的时候会自动转换字节序??\"></a>send发送的时候会自动转换字节序??</h2><p>作为开篇问题, 我选了这个. 这个问题也算是困扰了一段时间.<br>网上的解答自然已经有了<br><a href=\"https://stackoverflow.com/questions/23106938/do-recv-and-send-convert-the-messages-in-network-order-format-automatically\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/23106938/do-recv-and-send-convert-the-messages-in-network-order-format-automatically</a></p>\n<p>最先接触到socket字节序转换相信大多是<code>htons()</code><br>这个说明是将主机字节序转换成网络字节序, 我使用的自然是小端 将小端转换成大端 反转链表就好<br>而在大端上 头文件自动选择了<code>htons()</code>空命令版本</p>\n<p>起初我使用send发送全是 类似string的东西 char*保存, 单字节数据自然不会受字节序影响</p>\n<p>但是最近学习了moduo后发现了发送数字的实际应用<br>对于一个 <code>int32_t</code>类型的数字需要调用<code>htobe32()</code>转换成<code>大端序</code>然后<code>std::copy</code>到buffer中<br>接收端读取出四个字节 <code>std::copy</code>到<code>int32_t</code>中, 需要调用下<code>be32toh()</code>转换成<code>小端序</code> 这就涉及到了字节序转换</p>\n<p>总结下就是单字节数据比如发送一个字符串 是不会收到字节序影响<br>而如果你直接发送数字比如<code>int32_t</code> 就会受到影响</p>\n<h2 id=\"SIGPIPE信号触发原因和防治\"><a href=\"#SIGPIPE信号触发原因和防治\" class=\"headerlink\" title=\"SIGPIPE信号触发原因和防治\"></a>SIGPIPE信号触发原因和防治</h2><p>client与server建立连接后 在server发送信息给client的时候, 由于client已经退出,<br>client方会向server发送RST. 此时server向已经接收到RST的client的socket继续写入数据 会导致SIGPIPE信号</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> listen_fd = socket(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">listen_address</span>&#123;</span>&#125;;</span><br><span class=\"line\">    listen_address.sin_family = AF_INET;</span><br><span class=\"line\">    listen_address.sin_port = htons(<span class=\"number\">9123</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = bind(listen_fd, (struct sockaddr*)&amp;listen_address,</span><br><span class=\"line\">            <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">socklen_t</span>&gt;(<span class=\"keyword\">sizeof</span> listen_address));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, strerror(errno));</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">listen</span>(listen_fd, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">client_address</span>&#123;</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">socklen_t</span> client_address_len = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">socklen_t</span>&gt;(<span class=\"keyword\">sizeof</span> client_address);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> client_fd = accept(listen_fd, (struct sockaddr*)&amp;client_address,</span><br><span class=\"line\">            &amp;client_address_len);</span><br><span class=\"line\"></span><br><span class=\"line\">    sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> msg_first[<span class=\"number\">20</span>] = &#123;<span class=\"string\">\"first message\\n\"</span>&#125;;</span><br><span class=\"line\">    send(client_fd, msg_first, <span class=\"built_in\">strlen</span>(msg_first), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 第一条信息发送后收到RST</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> msg_second[<span class=\"number\">20</span>] = &#123;<span class=\"string\">\"second message\\n\"</span>&#125;;</span><br><span class=\"line\">    send(client_fd, msg_second, <span class=\"built_in\">strlen</span>(msg_second), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 第二次信息发送后出现SIGPIPE</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试代码如上 运行nc 127.0.0.1 9123后立刻按下Ctrl+C杀死client  截获的所有数据包如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@fish ~]# tcpdump -i lo -Xx tcp port 9123</span><br><span class=\"line\">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class=\"line\">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class=\"line\">00:26:27.780746 IP localhost.40580 &gt; localhost.grcp: Flags [S], seq 2027132643, win 43690, options [mss 65495,sackOK,TS val 1567772563 ecr 0,nop,wscale 7], length 0</span><br><span class=\"line\">\t0x0000:  4500 003c db97 4000 4006 6122 7f00 0001  E..&lt;..@.@.a&quot;....</span><br><span class=\"line\">\t0x0010:  7f00 0001 9e84 23a3 78d3 96e3 0000 0000  ......#.x.......</span><br><span class=\"line\">\t0x0020:  a002 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........</span><br><span class=\"line\">\t0x0030:  5d72 4f93 0000 0000 0103 0307            ]rO.........</span><br><span class=\"line\">00:26:27.780802 IP localhost.grcp &gt; localhost.40580: Flags [S.], seq 2570863062, ack 2027132644, win 43690, options [mss 65495,sackOK,TS val 1567772563 ecr 1567772563,nop,wscale 7], length 0</span><br><span class=\"line\">\t0x0000:  4500 003c 0000 4000 4006 3cba 7f00 0001  E..&lt;..@.@.&lt;.....</span><br><span class=\"line\">\t0x0010:  7f00 0001 23a3 9e84 993c 41d6 78d3 96e4  ....#....&lt;A.x...</span><br><span class=\"line\">\t0x0020:  a012 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........</span><br><span class=\"line\">\t0x0030:  5d72 4f93 5d72 4f93 0103 0307            ]rO.]rO.....</span><br><span class=\"line\">00:26:27.780839 IP localhost.40580 &gt; localhost.grcp: Flags [.], ack 1, win 342, options [nop,nop,TS val 1567772563 ecr 1567772563], length 0</span><br><span class=\"line\">\t0x0000:  4500 0034 db98 4000 4006 6129 7f00 0001  E..4..@.@.a)....</span><br><span class=\"line\">\t0x0010:  7f00 0001 9e84 23a3 78d3 96e4 993c 41d7  ......#.x....&lt;A.</span><br><span class=\"line\">\t0x0020:  8010 0156 fe28 0000 0101 080a 5d72 4f93  ...V.(......]rO.</span><br><span class=\"line\">\t0x0030:  5d72 4f93                                ]rO.</span><br><span class=\"line\"></span><br><span class=\"line\">三次握手结束后 由于立刻按下了Ctrl+C 客户端连接异常结束 发送FIN</span><br><span class=\"line\"></span><br><span class=\"line\">00:26:27.969734 IP localhost.40580 &gt; localhost.grcp: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 1567772752 ecr 1567772563], length 0</span><br><span class=\"line\">\t0x0000:  4500 0034 db99 4000 4006 6128 7f00 0001  E..4..@.@.a(....</span><br><span class=\"line\">\t0x0010:  7f00 0001 9e84 23a3 78d3 96e4 993c 41d7  ......#.x....&lt;A.</span><br><span class=\"line\">\t0x0020:  8011 0156 fe28 0000 0101 080a 5d72 5050  ...V.(......]rPP</span><br><span class=\"line\">\t0x0030:  5d72 4f93                                ]rO.</span><br><span class=\"line\"></span><br><span class=\"line\">服务端回复收到FIN</span><br><span class=\"line\"></span><br><span class=\"line\">00:26:27.970294 IP localhost.grcp &gt; localhost.40580: Flags [.], ack 2, win 342, options [nop,nop,TS val 1567772753 ecr 1567772752], length 0</span><br><span class=\"line\">\t0x0000:  4500 0034 8f0d 4000 4006 adb4 7f00 0001  E..4..@.@.......</span><br><span class=\"line\">\t0x0010:  7f00 0001 23a3 9e84 993c 41d7 78d3 96e5  ....#....&lt;A.x...</span><br><span class=\"line\">\t0x0020:  8010 0156 fe28 0000 0101 080a 5d72 5051  ...V.(......]rPQ</span><br><span class=\"line\">\t0x0030:  5d72 5050                                ]rPP</span><br><span class=\"line\"></span><br><span class=\"line\">第一次写入信息</span><br><span class=\"line\"></span><br><span class=\"line\">00:26:32.781104 IP localhost.grcp &gt; localhost.40580: Flags [P.], seq 1:15, ack 2, win 342, options [nop,nop,TS val 1567777564 ecr 1567772752], length 14</span><br><span class=\"line\">\t0x0000:  4500 0042 8f0e 4000 4006 ada5 7f00 0001  E..B..@.@.......</span><br><span class=\"line\">\t0x0010:  7f00 0001 23a3 9e84 993c 41d7 78d3 96e5  ....#....&lt;A.x...</span><br><span class=\"line\">\t0x0020:  8018 0156 fe36 0000 0101 080a 5d72 631c  ...V.6......]rc.</span><br><span class=\"line\">\t0x0030:  5d72 5050 6669 7273 7420 6d65 7373 6167  ]rPPfirst.messag</span><br><span class=\"line\">\t0x0040:  650a                                     e.</span><br><span class=\"line\"></span><br><span class=\"line\">收到客户端返回的复位RST</span><br><span class=\"line\"></span><br><span class=\"line\">00:26:32.781155 IP localhost.40580 &gt; localhost.grcp: Flags [R], seq 2027132645, win 0, length 0</span><br><span class=\"line\">\t0x0000:  4500 0028 0000 4000 4006 3cce 7f00 0001  E..(..@.@.&lt;.....</span><br><span class=\"line\">\t0x0010:  7f00 0001 9e84 23a3 78d3 96e5 0000 0000  ......#.x.......</span><br><span class=\"line\">\t0x0020:  5004 0000 dffd 0000                      P.......</span><br><span class=\"line\"></span><br><span class=\"line\">第二次写入信息触发 SIGPIPE</span><br></pre></td></tr></table></figure>\n\n<p>方式SIGPIPE中断进程使用<code>signal(SIGPIPE, SIG_IGN)</code>忽略这个信号, 这时send会返回-1并设置errno=EPIPE</p>\n","site":{"data":{}},"excerpt":"","more":"<p>马上步入四月中旬了, 自己对于socket理论知识知道的还是不多, 于是想了下可以整理下面试题.</p>\n<p>单纯整理”正确答案”怎么行. 我相信大部分面试题代表的都是某个知识点 某个知识面 或有他的重要实际应用</p>\n<p>部分题目是我自己凭空想出来的, 单独开一篇博客又不是内容足够, 索性放在一起</p>\n<h1 id=\"基础api相关\"><a href=\"#基础api相关\" class=\"headerlink\" title=\"基础api相关\"></a>基础api相关</h1><h2 id=\"send发送的时候会自动转换字节序\"><a href=\"#send发送的时候会自动转换字节序\" class=\"headerlink\" title=\"send发送的时候会自动转换字节序??\"></a>send发送的时候会自动转换字节序??</h2><p>作为开篇问题, 我选了这个. 这个问题也算是困扰了一段时间.<br>网上的解答自然已经有了<br><a href=\"https://stackoverflow.com/questions/23106938/do-recv-and-send-convert-the-messages-in-network-order-format-automatically\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/23106938/do-recv-and-send-convert-the-messages-in-network-order-format-automatically</a></p>\n<p>最先接触到socket字节序转换相信大多是<code>htons()</code><br>这个说明是将主机字节序转换成网络字节序, 我使用的自然是小端 将小端转换成大端 反转链表就好<br>而在大端上 头文件自动选择了<code>htons()</code>空命令版本</p>\n<p>起初我使用send发送全是 类似string的东西 char*保存, 单字节数据自然不会受字节序影响</p>\n<p>但是最近学习了moduo后发现了发送数字的实际应用<br>对于一个 <code>int32_t</code>类型的数字需要调用<code>htobe32()</code>转换成<code>大端序</code>然后<code>std::copy</code>到buffer中<br>接收端读取出四个字节 <code>std::copy</code>到<code>int32_t</code>中, 需要调用下<code>be32toh()</code>转换成<code>小端序</code> 这就涉及到了字节序转换</p>\n<p>总结下就是单字节数据比如发送一个字符串 是不会收到字节序影响<br>而如果你直接发送数字比如<code>int32_t</code> 就会受到影响</p>\n<h2 id=\"SIGPIPE信号触发原因和防治\"><a href=\"#SIGPIPE信号触发原因和防治\" class=\"headerlink\" title=\"SIGPIPE信号触发原因和防治\"></a>SIGPIPE信号触发原因和防治</h2><p>client与server建立连接后 在server发送信息给client的时候, 由于client已经退出,<br>client方会向server发送RST. 此时server向已经接收到RST的client的socket继续写入数据 会导致SIGPIPE信号</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> listen_fd = socket(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">listen_address</span>&#123;</span>&#125;;</span><br><span class=\"line\">    listen_address.sin_family = AF_INET;</span><br><span class=\"line\">    listen_address.sin_port = htons(<span class=\"number\">9123</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = bind(listen_fd, (struct sockaddr*)&amp;listen_address,</span><br><span class=\"line\">            <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">socklen_t</span>&gt;(<span class=\"keyword\">sizeof</span> listen_address));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, strerror(errno));</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(ret);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">listen</span>(listen_fd, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">client_address</span>&#123;</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">socklen_t</span> client_address_len = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">socklen_t</span>&gt;(<span class=\"keyword\">sizeof</span> client_address);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> client_fd = accept(listen_fd, (struct sockaddr*)&amp;client_address,</span><br><span class=\"line\">            &amp;client_address_len);</span><br><span class=\"line\"></span><br><span class=\"line\">    sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> msg_first[<span class=\"number\">20</span>] = &#123;<span class=\"string\">\"first message\\n\"</span>&#125;;</span><br><span class=\"line\">    send(client_fd, msg_first, <span class=\"built_in\">strlen</span>(msg_first), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 第一条信息发送后收到RST</span></span><br><span class=\"line\"></span><br><span class=\"line\">    sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">char</span> msg_second[<span class=\"number\">20</span>] = &#123;<span class=\"string\">\"second message\\n\"</span>&#125;;</span><br><span class=\"line\">    send(client_fd, msg_second, <span class=\"built_in\">strlen</span>(msg_second), <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 第二次信息发送后出现SIGPIPE</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试代码如上 运行nc 127.0.0.1 9123后立刻按下Ctrl+C杀死client  截获的所有数据包如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@fish ~]# tcpdump -i lo -Xx tcp port 9123</span><br><span class=\"line\">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class=\"line\">listening on lo, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class=\"line\">00:26:27.780746 IP localhost.40580 &gt; localhost.grcp: Flags [S], seq 2027132643, win 43690, options [mss 65495,sackOK,TS val 1567772563 ecr 0,nop,wscale 7], length 0</span><br><span class=\"line\">\t0x0000:  4500 003c db97 4000 4006 6122 7f00 0001  E..&lt;..@.@.a&quot;....</span><br><span class=\"line\">\t0x0010:  7f00 0001 9e84 23a3 78d3 96e3 0000 0000  ......#.x.......</span><br><span class=\"line\">\t0x0020:  a002 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........</span><br><span class=\"line\">\t0x0030:  5d72 4f93 0000 0000 0103 0307            ]rO.........</span><br><span class=\"line\">00:26:27.780802 IP localhost.grcp &gt; localhost.40580: Flags [S.], seq 2570863062, ack 2027132644, win 43690, options [mss 65495,sackOK,TS val 1567772563 ecr 1567772563,nop,wscale 7], length 0</span><br><span class=\"line\">\t0x0000:  4500 003c 0000 4000 4006 3cba 7f00 0001  E..&lt;..@.@.&lt;.....</span><br><span class=\"line\">\t0x0010:  7f00 0001 23a3 9e84 993c 41d6 78d3 96e4  ....#....&lt;A.x...</span><br><span class=\"line\">\t0x0020:  a012 aaaa fe30 0000 0204 ffd7 0402 080a  .....0..........</span><br><span class=\"line\">\t0x0030:  5d72 4f93 5d72 4f93 0103 0307            ]rO.]rO.....</span><br><span class=\"line\">00:26:27.780839 IP localhost.40580 &gt; localhost.grcp: Flags [.], ack 1, win 342, options [nop,nop,TS val 1567772563 ecr 1567772563], length 0</span><br><span class=\"line\">\t0x0000:  4500 0034 db98 4000 4006 6129 7f00 0001  E..4..@.@.a)....</span><br><span class=\"line\">\t0x0010:  7f00 0001 9e84 23a3 78d3 96e4 993c 41d7  ......#.x....&lt;A.</span><br><span class=\"line\">\t0x0020:  8010 0156 fe28 0000 0101 080a 5d72 4f93  ...V.(......]rO.</span><br><span class=\"line\">\t0x0030:  5d72 4f93                                ]rO.</span><br><span class=\"line\"></span><br><span class=\"line\">三次握手结束后 由于立刻按下了Ctrl+C 客户端连接异常结束 发送FIN</span><br><span class=\"line\"></span><br><span class=\"line\">00:26:27.969734 IP localhost.40580 &gt; localhost.grcp: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 1567772752 ecr 1567772563], length 0</span><br><span class=\"line\">\t0x0000:  4500 0034 db99 4000 4006 6128 7f00 0001  E..4..@.@.a(....</span><br><span class=\"line\">\t0x0010:  7f00 0001 9e84 23a3 78d3 96e4 993c 41d7  ......#.x....&lt;A.</span><br><span class=\"line\">\t0x0020:  8011 0156 fe28 0000 0101 080a 5d72 5050  ...V.(......]rPP</span><br><span class=\"line\">\t0x0030:  5d72 4f93                                ]rO.</span><br><span class=\"line\"></span><br><span class=\"line\">服务端回复收到FIN</span><br><span class=\"line\"></span><br><span class=\"line\">00:26:27.970294 IP localhost.grcp &gt; localhost.40580: Flags [.], ack 2, win 342, options [nop,nop,TS val 1567772753 ecr 1567772752], length 0</span><br><span class=\"line\">\t0x0000:  4500 0034 8f0d 4000 4006 adb4 7f00 0001  E..4..@.@.......</span><br><span class=\"line\">\t0x0010:  7f00 0001 23a3 9e84 993c 41d7 78d3 96e5  ....#....&lt;A.x...</span><br><span class=\"line\">\t0x0020:  8010 0156 fe28 0000 0101 080a 5d72 5051  ...V.(......]rPQ</span><br><span class=\"line\">\t0x0030:  5d72 5050                                ]rPP</span><br><span class=\"line\"></span><br><span class=\"line\">第一次写入信息</span><br><span class=\"line\"></span><br><span class=\"line\">00:26:32.781104 IP localhost.grcp &gt; localhost.40580: Flags [P.], seq 1:15, ack 2, win 342, options [nop,nop,TS val 1567777564 ecr 1567772752], length 14</span><br><span class=\"line\">\t0x0000:  4500 0042 8f0e 4000 4006 ada5 7f00 0001  E..B..@.@.......</span><br><span class=\"line\">\t0x0010:  7f00 0001 23a3 9e84 993c 41d7 78d3 96e5  ....#....&lt;A.x...</span><br><span class=\"line\">\t0x0020:  8018 0156 fe36 0000 0101 080a 5d72 631c  ...V.6......]rc.</span><br><span class=\"line\">\t0x0030:  5d72 5050 6669 7273 7420 6d65 7373 6167  ]rPPfirst.messag</span><br><span class=\"line\">\t0x0040:  650a                                     e.</span><br><span class=\"line\"></span><br><span class=\"line\">收到客户端返回的复位RST</span><br><span class=\"line\"></span><br><span class=\"line\">00:26:32.781155 IP localhost.40580 &gt; localhost.grcp: Flags [R], seq 2027132645, win 0, length 0</span><br><span class=\"line\">\t0x0000:  4500 0028 0000 4000 4006 3cce 7f00 0001  E..(..@.@.&lt;.....</span><br><span class=\"line\">\t0x0010:  7f00 0001 9e84 23a3 78d3 96e5 0000 0000  ......#.x.......</span><br><span class=\"line\">\t0x0020:  5004 0000 dffd 0000                      P.......</span><br><span class=\"line\"></span><br><span class=\"line\">第二次写入信息触发 SIGPIPE</span><br></pre></td></tr></table></figure>\n\n<p>方式SIGPIPE中断进程使用<code>signal(SIGPIPE, SIG_IGN)</code>忽略这个信号, 这时send会返回-1并设置errno=EPIPE</p>\n"},{"title":"TCP状态机","date":"2020-03-25T04:55:20.000Z","_content":"\n- 待补充 双向管道的建立和断开细节\n- 异常三次握手\n- 异常四次挥手\n\n\n[资料参考TCP 协议状态机](https://blog.csdn.net/q1007729991/article/details/69675752)\n\n[TCP有限状态机分析](https://blog.csdn.net/randyjiawenjie/article/details/6397477)\n\nTcp状态图, 虚线代表客户端 实线代表服务器\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP/Socket%E7%90%86%E8%AE%BA/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.png)\n\n正常的连接建立还是比较容易理解的\n\n\n说一下从`CLOSE_WAIT`到`LAST_ACK`\n当被动关闭方`B`接收到`FIN`后知道对方`A`要关闭连接, `B`回复一个`ACK`给`A`\n1. 如果此时`B`没有额外要发送的数据就给`A`, 就发送`FIN`告知`A`自己也要关闭了, 然后`B`进入`LAST_ACK`\n2. 如果此时`B`有额外信息要发送等发送完毕后. 这时`B`发送一个`FIN`告知`A`然后B进入`LAST_ACK`\n\n\n再说一下从`FIN_WAIT_1`到`TIME_WAIT`\n1. 直接从`FIN_WAIT_1`到`TIME_WAIT`, 这个对应上面的第一种情况, 由于`B`没有额外信息发送直接发送了`FIN和ACK`, 这时`A`再发送一个`ACK`, 进入`TIME_WAIT`\n2. 经过中转状态`FIN_WAIT2`对应上面第二种情况, 由于`B`有额外信息发送, 只发送了`ACK`, 这时`A`还可以接受数据, 直到`B`发来`FIN`然后`A`发送`ACK`进入`TIME_WAIT`\n\n\n再说一下`TIME_WAIT`状态\n主动关闭方`A`最后发送了`ACK`确认被动关闭方`B`的`FIN`.\n但是如果这个`ACK`由于各种原因`B`没有收到, 所以`B`会再次发送`FIN`. 然后`A`会在`2MSL`时间内接受到这个`FYN`, 之后`A`再次回复一个`ACk`.计时器重置`2MSL`时间, 重复上面过程. 直到`2MSL`时间内`A`没有收到`FIN`,说明`B`已经收到了.则结束连接\n\n`2MSL`指的是两个`MSL`时间 单个指的是一个片段在网络中的最大存活时间,\nA发送的`ACK`可能消耗一个, B重新发送的`FIN`可能也要消耗一个.最大两个\n\n\n复位报文段\n- 客户端访问不存在的端口， 服务器会发送带RST标志的复位报文段\n- 异常终止连接， 发送复位报文段\n- 客户端或服务端向半打开状态(对方异常终止连接, 但是本方没有收到结束报文)的连接写入数据, 对方回复会一个复位报文段","source":"_posts/网络编程-TCP状态机.md","raw":"---\ntitle: TCP状态机\ndate: 2020-03-25 12:55:20\ntags:\ncategories:\n  - 网络编程\n  - Socket理论\n---\n\n- 待补充 双向管道的建立和断开细节\n- 异常三次握手\n- 异常四次挥手\n\n\n[资料参考TCP 协议状态机](https://blog.csdn.net/q1007729991/article/details/69675752)\n\n[TCP有限状态机分析](https://blog.csdn.net/randyjiawenjie/article/details/6397477)\n\nTcp状态图, 虚线代表客户端 实线代表服务器\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP/Socket%E7%90%86%E8%AE%BA/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.png)\n\n正常的连接建立还是比较容易理解的\n\n\n说一下从`CLOSE_WAIT`到`LAST_ACK`\n当被动关闭方`B`接收到`FIN`后知道对方`A`要关闭连接, `B`回复一个`ACK`给`A`\n1. 如果此时`B`没有额外要发送的数据就给`A`, 就发送`FIN`告知`A`自己也要关闭了, 然后`B`进入`LAST_ACK`\n2. 如果此时`B`有额外信息要发送等发送完毕后. 这时`B`发送一个`FIN`告知`A`然后B进入`LAST_ACK`\n\n\n再说一下从`FIN_WAIT_1`到`TIME_WAIT`\n1. 直接从`FIN_WAIT_1`到`TIME_WAIT`, 这个对应上面的第一种情况, 由于`B`没有额外信息发送直接发送了`FIN和ACK`, 这时`A`再发送一个`ACK`, 进入`TIME_WAIT`\n2. 经过中转状态`FIN_WAIT2`对应上面第二种情况, 由于`B`有额外信息发送, 只发送了`ACK`, 这时`A`还可以接受数据, 直到`B`发来`FIN`然后`A`发送`ACK`进入`TIME_WAIT`\n\n\n再说一下`TIME_WAIT`状态\n主动关闭方`A`最后发送了`ACK`确认被动关闭方`B`的`FIN`.\n但是如果这个`ACK`由于各种原因`B`没有收到, 所以`B`会再次发送`FIN`. 然后`A`会在`2MSL`时间内接受到这个`FYN`, 之后`A`再次回复一个`ACk`.计时器重置`2MSL`时间, 重复上面过程. 直到`2MSL`时间内`A`没有收到`FIN`,说明`B`已经收到了.则结束连接\n\n`2MSL`指的是两个`MSL`时间 单个指的是一个片段在网络中的最大存活时间,\nA发送的`ACK`可能消耗一个, B重新发送的`FIN`可能也要消耗一个.最大两个\n\n\n复位报文段\n- 客户端访问不存在的端口， 服务器会发送带RST标志的复位报文段\n- 异常终止连接， 发送复位报文段\n- 客户端或服务端向半打开状态(对方异常终止连接, 但是本方没有收到结束报文)的连接写入数据, 对方回复会一个复位报文段","slug":"网络编程-TCP状态机","published":1,"updated":"2020-12-05T02:27:03.519Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg710038f8un7uaccuck","content":"<ul>\n<li>待补充 双向管道的建立和断开细节</li>\n<li>异常三次握手</li>\n<li>异常四次挥手</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/q1007729991/article/details/69675752\" target=\"_blank\" rel=\"noopener\">资料参考TCP 协议状态机</a></p>\n<p><a href=\"https://blog.csdn.net/randyjiawenjie/article/details/6397477\" target=\"_blank\" rel=\"noopener\">TCP有限状态机分析</a></p>\n<p>Tcp状态图, 虚线代表客户端 实线代表服务器<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP/Socket%E7%90%86%E8%AE%BA/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.png\" alt=\"\"></p>\n<p>正常的连接建立还是比较容易理解的</p>\n<p>说一下从<code>CLOSE_WAIT</code>到<code>LAST_ACK</code><br>当被动关闭方<code>B</code>接收到<code>FIN</code>后知道对方<code>A</code>要关闭连接, <code>B</code>回复一个<code>ACK</code>给<code>A</code></p>\n<ol>\n<li>如果此时<code>B</code>没有额外要发送的数据就给<code>A</code>, 就发送<code>FIN</code>告知<code>A</code>自己也要关闭了, 然后<code>B</code>进入<code>LAST_ACK</code></li>\n<li>如果此时<code>B</code>有额外信息要发送等发送完毕后. 这时<code>B</code>发送一个<code>FIN</code>告知<code>A</code>然后B进入<code>LAST_ACK</code></li>\n</ol>\n<p>再说一下从<code>FIN_WAIT_1</code>到<code>TIME_WAIT</code></p>\n<ol>\n<li>直接从<code>FIN_WAIT_1</code>到<code>TIME_WAIT</code>, 这个对应上面的第一种情况, 由于<code>B</code>没有额外信息发送直接发送了<code>FIN和ACK</code>, 这时<code>A</code>再发送一个<code>ACK</code>, 进入<code>TIME_WAIT</code></li>\n<li>经过中转状态<code>FIN_WAIT2</code>对应上面第二种情况, 由于<code>B</code>有额外信息发送, 只发送了<code>ACK</code>, 这时<code>A</code>还可以接受数据, 直到<code>B</code>发来<code>FIN</code>然后<code>A</code>发送<code>ACK</code>进入<code>TIME_WAIT</code></li>\n</ol>\n<p>再说一下<code>TIME_WAIT</code>状态<br>主动关闭方<code>A</code>最后发送了<code>ACK</code>确认被动关闭方<code>B</code>的<code>FIN</code>.<br>但是如果这个<code>ACK</code>由于各种原因<code>B</code>没有收到, 所以<code>B</code>会再次发送<code>FIN</code>. 然后<code>A</code>会在<code>2MSL</code>时间内接受到这个<code>FYN</code>, 之后<code>A</code>再次回复一个<code>ACk</code>.计时器重置<code>2MSL</code>时间, 重复上面过程. 直到<code>2MSL</code>时间内<code>A</code>没有收到<code>FIN</code>,说明<code>B</code>已经收到了.则结束连接</p>\n<p><code>2MSL</code>指的是两个<code>MSL</code>时间 单个指的是一个片段在网络中的最大存活时间,<br>A发送的<code>ACK</code>可能消耗一个, B重新发送的<code>FIN</code>可能也要消耗一个.最大两个</p>\n<p>复位报文段</p>\n<ul>\n<li>客户端访问不存在的端口， 服务器会发送带RST标志的复位报文段</li>\n<li>异常终止连接， 发送复位报文段</li>\n<li>客户端或服务端向半打开状态(对方异常终止连接, 但是本方没有收到结束报文)的连接写入数据, 对方回复会一个复位报文段</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>待补充 双向管道的建立和断开细节</li>\n<li>异常三次握手</li>\n<li>异常四次挥手</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/q1007729991/article/details/69675752\" target=\"_blank\" rel=\"noopener\">资料参考TCP 协议状态机</a></p>\n<p><a href=\"https://blog.csdn.net/randyjiawenjie/article/details/6397477\" target=\"_blank\" rel=\"noopener\">TCP有限状态机分析</a></p>\n<p>Tcp状态图, 虚线代表客户端 实线代表服务器<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPP/Socket%E7%90%86%E8%AE%BA/TCP%E7%8A%B6%E6%80%81%E6%9C%BA.png\" alt=\"\"></p>\n<p>正常的连接建立还是比较容易理解的</p>\n<p>说一下从<code>CLOSE_WAIT</code>到<code>LAST_ACK</code><br>当被动关闭方<code>B</code>接收到<code>FIN</code>后知道对方<code>A</code>要关闭连接, <code>B</code>回复一个<code>ACK</code>给<code>A</code></p>\n<ol>\n<li>如果此时<code>B</code>没有额外要发送的数据就给<code>A</code>, 就发送<code>FIN</code>告知<code>A</code>自己也要关闭了, 然后<code>B</code>进入<code>LAST_ACK</code></li>\n<li>如果此时<code>B</code>有额外信息要发送等发送完毕后. 这时<code>B</code>发送一个<code>FIN</code>告知<code>A</code>然后B进入<code>LAST_ACK</code></li>\n</ol>\n<p>再说一下从<code>FIN_WAIT_1</code>到<code>TIME_WAIT</code></p>\n<ol>\n<li>直接从<code>FIN_WAIT_1</code>到<code>TIME_WAIT</code>, 这个对应上面的第一种情况, 由于<code>B</code>没有额外信息发送直接发送了<code>FIN和ACK</code>, 这时<code>A</code>再发送一个<code>ACK</code>, 进入<code>TIME_WAIT</code></li>\n<li>经过中转状态<code>FIN_WAIT2</code>对应上面第二种情况, 由于<code>B</code>有额外信息发送, 只发送了<code>ACK</code>, 这时<code>A</code>还可以接受数据, 直到<code>B</code>发来<code>FIN</code>然后<code>A</code>发送<code>ACK</code>进入<code>TIME_WAIT</code></li>\n</ol>\n<p>再说一下<code>TIME_WAIT</code>状态<br>主动关闭方<code>A</code>最后发送了<code>ACK</code>确认被动关闭方<code>B</code>的<code>FIN</code>.<br>但是如果这个<code>ACK</code>由于各种原因<code>B</code>没有收到, 所以<code>B</code>会再次发送<code>FIN</code>. 然后<code>A</code>会在<code>2MSL</code>时间内接受到这个<code>FYN</code>, 之后<code>A</code>再次回复一个<code>ACk</code>.计时器重置<code>2MSL</code>时间, 重复上面过程. 直到<code>2MSL</code>时间内<code>A</code>没有收到<code>FIN</code>,说明<code>B</code>已经收到了.则结束连接</p>\n<p><code>2MSL</code>指的是两个<code>MSL</code>时间 单个指的是一个片段在网络中的最大存活时间,<br>A发送的<code>ACK</code>可能消耗一个, B重新发送的<code>FIN</code>可能也要消耗一个.最大两个</p>\n<p>复位报文段</p>\n<ul>\n<li>客户端访问不存在的端口， 服务器会发送带RST标志的复位报文段</li>\n<li>异常终止连接， 发送复位报文段</li>\n<li>客户端或服务端向半打开状态(对方异常终止连接, 但是本方没有收到结束报文)的连接写入数据, 对方回复会一个复位报文段</li>\n</ul>\n"},{"title":"计算机网络笔记","date":"2020-06-16T00:50:22.000Z","_content":"# ?\n\n物理层-以太网帧\n数据链路层-MAC帧-添加了首部和尾部-FCS校验\n网络层-IP数据报-首部校验和\n传输层-报文,流 \n\n# 数据链路层\n**封装成帧**\n帧首部SOH, 01H\n帧尾部EOT, 04H\n\n**透明传输**\n数据部分出现 01H和04H以及1BH  在前面增加转义字符ESC 1BH\n\n\n**差错检测**\nCRC校验\nFCS冗余码\n\n**PPP协议**\n7EH 帧首帧尾\n\n\n# 网络层\n\n网络层-数据报\n数据链路层-MAC帧\n\n网络层向上只提供 简单灵活的 无连接的 尽最大努力交付 的 `数据报`服务\n\n地址解析协议ARP\n网际控制报文协议 ICMP\n网际组管理协议 IGMP\n\n转发器-物理层使用的中间设备\n网桥或桥接器-数据链路层使用的中间设备\n路由器-网络层中间设备\n网关-网络层以上使用的中间设备\n\n一个路由器互联的多个局域网网络中-`网络层及以上高层协议必须相同` 而物理层和数据链路层则可不同(p116)\nIP地址`用于网络层及以上高层` MAC地址用于`数据链路层和物理层`\n\n\n路由器转发的时候 源和目的MAC都`会`变化, 然而源和目的IP`不`变化 p118 p123\n\n互联网名字和数字分配机构ICANN进行分配\n\n**IP地址编址的三个阶段**\n- 分类的IP地址\nIP地址由`网络号-主机号`构成\n\n| 类别 | 范围    | 网络号固定部分 | 总网络号位数 | 主机号位数 |\n| ---- | ------- | -------------- | ------------ | ---------- |\n| A类  | 1-126   | 0              | 7+1位          | 主机号24位 |\n| B类  | 128-191 | 10             | 2+14位         | 主机号16位 |\n| C类  | 192-223 | 110            | 3+21位         | 主机号8位  |\n| D类  | 224-239 | 1110           | 多播地址     |            |\n| E类  | 240-255 | 1111           | 保留         |            |\n\nA类\n\n2^7-2\n\n网络号全0 表示本网络\n网络号 0111 1111 127 代表本地换环回(你压根没被当做网络地址, 上表中跳过了127)\n\n2^24-2\n\n主机号全0 表示本主机连接的网络地址\n主机号全1 代表该网络上的所有主机\n\nB类\n\n2^14-1\n\n扣除了128.0.0.0 从128.1.0.0开始\n\n2^16-2\n\n抛去主机号全0和全1 原因同上\n\nC类\n\n2^21-1\n\n扣除了192.0.0.0 从192.0.1.0开始\n\n2^8-2\n\n扣除全0和全1原因同上\n\n其他特殊IP\n`10.*.*.*` `172.16.*.*-172.31.*.*` `192.168.*.*` - 三个私有地址网段 用于私网\n\n\n- 子网的划分\n将B类地址主机号前面几个字作为子网号 划分子网 将二级地址转化为三级地址\n现有B类地址`145.13.0.0`取八位作为子网`145.13.1.0`为一个子网 主机号剩下8位\n\n子网掩码\n当`145.13.1.3`到达路由器`145.13.0.0`(描述不恰当)后 如何将其转发到子网`145.13.1.0`\n使用子网掩码AND运算得到网络地址\n子网掩码子网数子网主机数p138\n\n*@划分子网情况下分组转发算法p140@*\n\n\n\n- 构成超网\n变长子网掩码VLSM(Variable Length Subnet Mask)\n在其基础上研究出无分类编址方法-无分类域间路由选择CIDR(Classless Inter-domain Routing)\n128.14.35.7/20 表明前20位是网络前缀\n成为/20地址块\n*@变长子网掩码划分子网@*\n\n用CIDR地址块来查找目的网络 这种地址的聚合常称为`聚合路由`也称为`构成超网`\n\n从匹配结果总选择具有最长网络前缀的路由-`最长前缀匹配`\n\n------\n\nARP略\n\n----------\nIP数据报格式\n```\n0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL  |Type of Service|          Total Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Identification        |Flags|      Fragment Offset    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Time to Live |    Protocol   |         Header Checksum       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Source Address                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Destination Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\nIHL: 首部长度 最大 2^4-1 = 15 `单位四字节`\n最小是5 即最小首部为20字节\n最大15  即最大为60字节\n\nTotal Length: 总长度 最大 2^16-1 = 65535 `单位一字节`\n以太网最大数据帧 1518 抛去14头部 4字节校验 剩余1500即为`MTU`  数据`帧`(链路层)的`数据字段`最大长度\n\nflags: 标识\n第一位MF MF=1标识`还有分片` DF=1标识`不能分片`\n\nFragment Offset: 片偏移 `单位八字节`\n13位  \n\n*@分片计算 p129@*\n\nTime to Live: 生存时间\n`先减1`再判断是否为0, 为0则丢弃\n\nProtocol: 协议\n常用 TCP-6 UDP-17\n\nHeader Checksum: `首部校验和` 不包括数据部分\n每次经过路由器都可能变化 生存时间标志片偏移可能变化\n\n------------------\n\n首部分为很多16位字的序列 先将原校验和清零 在将所有序列求反码相加 再求反码写入校验和\n接收方将所有序列 求反码相加(这里不将校验和清零) 得到的和取反码 必须为零 \n\nIP数据报的可选部分无分隔符 最后需要用全0的字段补齐为 `四的整数倍`\n\n\n\n`分组转发算法`\n*@路由器路径 与路由表下一跳地址 p132@*\n\n同页特定主机路由和默认路由 下一页分组转发算法\n\n\nICMP略\n\n互联网路由选择协议\n\n\n# 运输层\n\n网络层为`主机`之间提供逻辑通信, 而传输层为应用程序之间提供`端到端`的逻辑通信\n\n\n熟知端口号 - 0~1023 - 服务器端\n登记端口号 - 1024~49151 - 提供给没有熟知端口号使用\n短暂端口号 - 客户端\n\n复用分用的关键 对下使用了IP数据报头部的字段Protocol 以及 对上端口号的使用\n\nUDP数据报 TCP报文段\nUDP是无连接的, 不可靠的, 基于数据报\nTCP是面向连接的, 可靠的, 基于流的服务\n(可靠 无差错, 不丢失, 不重复, 按序到达)\n\n## 用户数据报协议 UDP User Datagram Protocol\n\n```\n0      7 8     15 16    23 24    31\n+--------+--------+--------+--------+\n|          source address           |\n+--------+--------+--------+--------+\n|        destination address        |\n+--------+--------+--------+--------+\n|  zero  |protocol|   UDP length    |\n+--------+--------+--------+--------+\n\n\n0      7 8     15 16    23 24    31\n+--------+--------+--------+--------+\n|     Source      |   Destination   |\n|      Port       |      Port       |\n+--------+--------+--------+--------+\n|                 |                 |\n|     Length      |    Checksum     |\n+--------+--------+--------+--------+\n|\n|          data octets ...\n+---------------- ...\n\n    User Datagram Header Format\n```\n\nUDP length 同 Length: 最小值为8（仅包含首部 无数据）\nChecksum: 校验和 使用 `伪首部` `首部` `数据` 计算出\n校验了源和目的端口和地址\n\nprotocol： udp为17 tcp为6\n\n伪首部12字节, 既不向下传递, 也不向上递交 仅仅为了计算校验和\n\n*@校验和计算 p210@*\n*@TCP和UDP交付IP层的分片@*\n同样16B一组 \n\n\n## 传输控制协议 TCP Transmission Control Protocol\n\n\n\n为了传输的可靠性使用了下面的协议\n**自动重传请求ARQ**\n超时重传：每次发送完设置超时计时器， 超时之前收到确认就取消定时器， 否则到期后重发，并重置定时器。\n\n`收到重复报文`：A发送后B的回复丢失，A重发报文。丢弃重复的报文， 并向对方发送确认，而不能认为之前发送过就不发送了。\n`收到迟到的确认报文`：丢弃， 什么也不做。\n\n**~~停止等待协议~~ 流水线传输协议**\n使用流水线传输协议 就要使用 连续ARQ协议 和 滑动窗口协议\n\n**连续ARQ协议**\n可以连续发送五个连续分组 而不需要对方的确认\n\n每收到一个确认，发送窗口就向前滑动。如果原来发送了五个分组就可以发送第六个分组了。\n累计确认： 对按序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都收到了。\nGO-back-N：如果中间第三个分组丢失，接收方只能发送前两个分组的确认，发送方需要发送后面三个分组。\n\n**滑动窗口协议**\n\n **拥塞控制**\n*@p232 拥塞控制方法 画图和慢开始 拥塞避免 快恢复@*\n\n\n**超时重传时间确认**\n\n报文往返时间RTTS\n新的RTTS = (1-a) x 旧RTTS + a x 新RTTS\na = 0.125\n\n\n超时重传时间\nRTO = RTTS + 4 x RTTD\n\nRTTD = (1 - b) x 旧RTTD + b x | RTTS - 新的RTT |\nb = 0,25\n\nkarn算法 只要报文段重传就不采用其往返时间\n修正 每重传一次新的时间为旧的2倍\n\n```\n0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Source Port          |       Destination Port        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sequence Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Acknowledgment Number                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Data |           |U|A|P|R|S|F|                               |\n| Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n|       |           |G|K|H|T|N|N|                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Checksum            |         Urgent Pointer        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             data                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n\nseq: 序号\n*报文的序号和ack的对应关系*\n\nack: 确认号\n确认号为N 表明, 到序号N-1的所有数据都收到\n\n数据偏移: 单位是四字节\n头部长度 最少是20字节 最大是60字节 所以该项最少为5\n\nURG: 紧急标识\n如果TCP发送缓冲区有很多数据, 但需要紧急发送某个命令. 正常情况下会加在缓冲区位\n如果设置了标识, 则插入到最前边\n\nACK: 确认号\nTCP规定, 建立连接后所有的报文段ACK都设置为1\n**可以携带数据 不携带数据则不会消耗 报文号**\n\nPSH: 推送\n接收方收到该标识后 将数据尽快提交到应用程序, 而不是等缓冲满了提交\n\nRST: 复位\n说明TCP连接出现严重差错  必须重新建立连接\n\nSYN: 同步\n连接建立时用来同步序号\n含有此标记 不能携带数据 但**仍要消耗一个序列号**\n\nFIN: 终止连接\n\n窗口:\n发送本报文段一方的接收窗口\n\n检验和:\n需要加上12字节的伪首部\n*检验和计算*\n\n紧急指针:\n指明报文段中紧急数据的字节数\n\nMSS: 最大报文段长度, 指的是数据字段的最大长度\n\n*@tcp连接的建立和断开 p238@*\n\n\n","source":"_posts/计算机网络-计算机网络笔记整理.md","raw":"---\ntitle: 计算机网络笔记\ndate: 2020-06-16 08:50:22\ncategories: \n- 计算机网络\ntags:\n- 自底向上?\n---\n# ?\n\n物理层-以太网帧\n数据链路层-MAC帧-添加了首部和尾部-FCS校验\n网络层-IP数据报-首部校验和\n传输层-报文,流 \n\n# 数据链路层\n**封装成帧**\n帧首部SOH, 01H\n帧尾部EOT, 04H\n\n**透明传输**\n数据部分出现 01H和04H以及1BH  在前面增加转义字符ESC 1BH\n\n\n**差错检测**\nCRC校验\nFCS冗余码\n\n**PPP协议**\n7EH 帧首帧尾\n\n\n# 网络层\n\n网络层-数据报\n数据链路层-MAC帧\n\n网络层向上只提供 简单灵活的 无连接的 尽最大努力交付 的 `数据报`服务\n\n地址解析协议ARP\n网际控制报文协议 ICMP\n网际组管理协议 IGMP\n\n转发器-物理层使用的中间设备\n网桥或桥接器-数据链路层使用的中间设备\n路由器-网络层中间设备\n网关-网络层以上使用的中间设备\n\n一个路由器互联的多个局域网网络中-`网络层及以上高层协议必须相同` 而物理层和数据链路层则可不同(p116)\nIP地址`用于网络层及以上高层` MAC地址用于`数据链路层和物理层`\n\n\n路由器转发的时候 源和目的MAC都`会`变化, 然而源和目的IP`不`变化 p118 p123\n\n互联网名字和数字分配机构ICANN进行分配\n\n**IP地址编址的三个阶段**\n- 分类的IP地址\nIP地址由`网络号-主机号`构成\n\n| 类别 | 范围    | 网络号固定部分 | 总网络号位数 | 主机号位数 |\n| ---- | ------- | -------------- | ------------ | ---------- |\n| A类  | 1-126   | 0              | 7+1位          | 主机号24位 |\n| B类  | 128-191 | 10             | 2+14位         | 主机号16位 |\n| C类  | 192-223 | 110            | 3+21位         | 主机号8位  |\n| D类  | 224-239 | 1110           | 多播地址     |            |\n| E类  | 240-255 | 1111           | 保留         |            |\n\nA类\n\n2^7-2\n\n网络号全0 表示本网络\n网络号 0111 1111 127 代表本地换环回(你压根没被当做网络地址, 上表中跳过了127)\n\n2^24-2\n\n主机号全0 表示本主机连接的网络地址\n主机号全1 代表该网络上的所有主机\n\nB类\n\n2^14-1\n\n扣除了128.0.0.0 从128.1.0.0开始\n\n2^16-2\n\n抛去主机号全0和全1 原因同上\n\nC类\n\n2^21-1\n\n扣除了192.0.0.0 从192.0.1.0开始\n\n2^8-2\n\n扣除全0和全1原因同上\n\n其他特殊IP\n`10.*.*.*` `172.16.*.*-172.31.*.*` `192.168.*.*` - 三个私有地址网段 用于私网\n\n\n- 子网的划分\n将B类地址主机号前面几个字作为子网号 划分子网 将二级地址转化为三级地址\n现有B类地址`145.13.0.0`取八位作为子网`145.13.1.0`为一个子网 主机号剩下8位\n\n子网掩码\n当`145.13.1.3`到达路由器`145.13.0.0`(描述不恰当)后 如何将其转发到子网`145.13.1.0`\n使用子网掩码AND运算得到网络地址\n子网掩码子网数子网主机数p138\n\n*@划分子网情况下分组转发算法p140@*\n\n\n\n- 构成超网\n变长子网掩码VLSM(Variable Length Subnet Mask)\n在其基础上研究出无分类编址方法-无分类域间路由选择CIDR(Classless Inter-domain Routing)\n128.14.35.7/20 表明前20位是网络前缀\n成为/20地址块\n*@变长子网掩码划分子网@*\n\n用CIDR地址块来查找目的网络 这种地址的聚合常称为`聚合路由`也称为`构成超网`\n\n从匹配结果总选择具有最长网络前缀的路由-`最长前缀匹配`\n\n------\n\nARP略\n\n----------\nIP数据报格式\n```\n0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Version|  IHL  |Type of Service|          Total Length         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Identification        |Flags|      Fragment Offset    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Time to Live |    Protocol   |         Header Checksum       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Source Address                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Destination Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\nIHL: 首部长度 最大 2^4-1 = 15 `单位四字节`\n最小是5 即最小首部为20字节\n最大15  即最大为60字节\n\nTotal Length: 总长度 最大 2^16-1 = 65535 `单位一字节`\n以太网最大数据帧 1518 抛去14头部 4字节校验 剩余1500即为`MTU`  数据`帧`(链路层)的`数据字段`最大长度\n\nflags: 标识\n第一位MF MF=1标识`还有分片` DF=1标识`不能分片`\n\nFragment Offset: 片偏移 `单位八字节`\n13位  \n\n*@分片计算 p129@*\n\nTime to Live: 生存时间\n`先减1`再判断是否为0, 为0则丢弃\n\nProtocol: 协议\n常用 TCP-6 UDP-17\n\nHeader Checksum: `首部校验和` 不包括数据部分\n每次经过路由器都可能变化 生存时间标志片偏移可能变化\n\n------------------\n\n首部分为很多16位字的序列 先将原校验和清零 在将所有序列求反码相加 再求反码写入校验和\n接收方将所有序列 求反码相加(这里不将校验和清零) 得到的和取反码 必须为零 \n\nIP数据报的可选部分无分隔符 最后需要用全0的字段补齐为 `四的整数倍`\n\n\n\n`分组转发算法`\n*@路由器路径 与路由表下一跳地址 p132@*\n\n同页特定主机路由和默认路由 下一页分组转发算法\n\n\nICMP略\n\n互联网路由选择协议\n\n\n# 运输层\n\n网络层为`主机`之间提供逻辑通信, 而传输层为应用程序之间提供`端到端`的逻辑通信\n\n\n熟知端口号 - 0~1023 - 服务器端\n登记端口号 - 1024~49151 - 提供给没有熟知端口号使用\n短暂端口号 - 客户端\n\n复用分用的关键 对下使用了IP数据报头部的字段Protocol 以及 对上端口号的使用\n\nUDP数据报 TCP报文段\nUDP是无连接的, 不可靠的, 基于数据报\nTCP是面向连接的, 可靠的, 基于流的服务\n(可靠 无差错, 不丢失, 不重复, 按序到达)\n\n## 用户数据报协议 UDP User Datagram Protocol\n\n```\n0      7 8     15 16    23 24    31\n+--------+--------+--------+--------+\n|          source address           |\n+--------+--------+--------+--------+\n|        destination address        |\n+--------+--------+--------+--------+\n|  zero  |protocol|   UDP length    |\n+--------+--------+--------+--------+\n\n\n0      7 8     15 16    23 24    31\n+--------+--------+--------+--------+\n|     Source      |   Destination   |\n|      Port       |      Port       |\n+--------+--------+--------+--------+\n|                 |                 |\n|     Length      |    Checksum     |\n+--------+--------+--------+--------+\n|\n|          data octets ...\n+---------------- ...\n\n    User Datagram Header Format\n```\n\nUDP length 同 Length: 最小值为8（仅包含首部 无数据）\nChecksum: 校验和 使用 `伪首部` `首部` `数据` 计算出\n校验了源和目的端口和地址\n\nprotocol： udp为17 tcp为6\n\n伪首部12字节, 既不向下传递, 也不向上递交 仅仅为了计算校验和\n\n*@校验和计算 p210@*\n*@TCP和UDP交付IP层的分片@*\n同样16B一组 \n\n\n## 传输控制协议 TCP Transmission Control Protocol\n\n\n\n为了传输的可靠性使用了下面的协议\n**自动重传请求ARQ**\n超时重传：每次发送完设置超时计时器， 超时之前收到确认就取消定时器， 否则到期后重发，并重置定时器。\n\n`收到重复报文`：A发送后B的回复丢失，A重发报文。丢弃重复的报文， 并向对方发送确认，而不能认为之前发送过就不发送了。\n`收到迟到的确认报文`：丢弃， 什么也不做。\n\n**~~停止等待协议~~ 流水线传输协议**\n使用流水线传输协议 就要使用 连续ARQ协议 和 滑动窗口协议\n\n**连续ARQ协议**\n可以连续发送五个连续分组 而不需要对方的确认\n\n每收到一个确认，发送窗口就向前滑动。如果原来发送了五个分组就可以发送第六个分组了。\n累计确认： 对按序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都收到了。\nGO-back-N：如果中间第三个分组丢失，接收方只能发送前两个分组的确认，发送方需要发送后面三个分组。\n\n**滑动窗口协议**\n\n **拥塞控制**\n*@p232 拥塞控制方法 画图和慢开始 拥塞避免 快恢复@*\n\n\n**超时重传时间确认**\n\n报文往返时间RTTS\n新的RTTS = (1-a) x 旧RTTS + a x 新RTTS\na = 0.125\n\n\n超时重传时间\nRTO = RTTS + 4 x RTTD\n\nRTTD = (1 - b) x 旧RTTD + b x | RTTS - 新的RTT |\nb = 0,25\n\nkarn算法 只要报文段重传就不采用其往返时间\n修正 每重传一次新的时间为旧的2倍\n\n```\n0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Source Port          |       Destination Port        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sequence Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Acknowledgment Number                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Data |           |U|A|P|R|S|F|                               |\n| Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n|       |           |G|K|H|T|N|N|                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Checksum            |         Urgent Pointer        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             data                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n\nseq: 序号\n*报文的序号和ack的对应关系*\n\nack: 确认号\n确认号为N 表明, 到序号N-1的所有数据都收到\n\n数据偏移: 单位是四字节\n头部长度 最少是20字节 最大是60字节 所以该项最少为5\n\nURG: 紧急标识\n如果TCP发送缓冲区有很多数据, 但需要紧急发送某个命令. 正常情况下会加在缓冲区位\n如果设置了标识, 则插入到最前边\n\nACK: 确认号\nTCP规定, 建立连接后所有的报文段ACK都设置为1\n**可以携带数据 不携带数据则不会消耗 报文号**\n\nPSH: 推送\n接收方收到该标识后 将数据尽快提交到应用程序, 而不是等缓冲满了提交\n\nRST: 复位\n说明TCP连接出现严重差错  必须重新建立连接\n\nSYN: 同步\n连接建立时用来同步序号\n含有此标记 不能携带数据 但**仍要消耗一个序列号**\n\nFIN: 终止连接\n\n窗口:\n发送本报文段一方的接收窗口\n\n检验和:\n需要加上12字节的伪首部\n*检验和计算*\n\n紧急指针:\n指明报文段中紧急数据的字节数\n\nMSS: 最大报文段长度, 指的是数据字段的最大长度\n\n*@tcp连接的建立和断开 p238@*\n\n\n","slug":"计算机网络-计算机网络笔记整理","published":1,"updated":"2020-07-14T08:01:25.981Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg72003cf8uneqvm829i","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"?\"></a>?</h1><p>物理层-以太网帧<br>数据链路层-MAC帧-添加了首部和尾部-FCS校验<br>网络层-IP数据报-首部校验和<br>传输层-报文,流 </p>\n<h1 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h1><p><strong>封装成帧</strong><br>帧首部SOH, 01H<br>帧尾部EOT, 04H</p>\n<p><strong>透明传输</strong><br>数据部分出现 01H和04H以及1BH  在前面增加转义字符ESC 1BH</p>\n<p><strong>差错检测</strong><br>CRC校验<br>FCS冗余码</p>\n<p><strong>PPP协议</strong><br>7EH 帧首帧尾</p>\n<h1 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h1><p>网络层-数据报<br>数据链路层-MAC帧</p>\n<p>网络层向上只提供 简单灵活的 无连接的 尽最大努力交付 的 <code>数据报</code>服务</p>\n<p>地址解析协议ARP<br>网际控制报文协议 ICMP<br>网际组管理协议 IGMP</p>\n<p>转发器-物理层使用的中间设备<br>网桥或桥接器-数据链路层使用的中间设备<br>路由器-网络层中间设备<br>网关-网络层以上使用的中间设备</p>\n<p>一个路由器互联的多个局域网网络中-<code>网络层及以上高层协议必须相同</code> 而物理层和数据链路层则可不同(p116)<br>IP地址<code>用于网络层及以上高层</code> MAC地址用于<code>数据链路层和物理层</code></p>\n<p>路由器转发的时候 源和目的MAC都<code>会</code>变化, 然而源和目的IP<code>不</code>变化 p118 p123</p>\n<p>互联网名字和数字分配机构ICANN进行分配</p>\n<p><strong>IP地址编址的三个阶段</strong></p>\n<ul>\n<li>分类的IP地址<br>IP地址由<code>网络号-主机号</code>构成</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>范围</th>\n<th>网络号固定部分</th>\n<th>总网络号位数</th>\n<th>主机号位数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>A类</td>\n<td>1-126</td>\n<td>0</td>\n<td>7+1位</td>\n<td>主机号24位</td>\n</tr>\n<tr>\n<td>B类</td>\n<td>128-191</td>\n<td>10</td>\n<td>2+14位</td>\n<td>主机号16位</td>\n</tr>\n<tr>\n<td>C类</td>\n<td>192-223</td>\n<td>110</td>\n<td>3+21位</td>\n<td>主机号8位</td>\n</tr>\n<tr>\n<td>D类</td>\n<td>224-239</td>\n<td>1110</td>\n<td>多播地址</td>\n<td></td>\n</tr>\n<tr>\n<td>E类</td>\n<td>240-255</td>\n<td>1111</td>\n<td>保留</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>A类</p>\n<p>2^7-2</p>\n<p>网络号全0 表示本网络<br>网络号 0111 1111 127 代表本地换环回(你压根没被当做网络地址, 上表中跳过了127)</p>\n<p>2^24-2</p>\n<p>主机号全0 表示本主机连接的网络地址<br>主机号全1 代表该网络上的所有主机</p>\n<p>B类</p>\n<p>2^14-1</p>\n<p>扣除了128.0.0.0 从128.1.0.0开始</p>\n<p>2^16-2</p>\n<p>抛去主机号全0和全1 原因同上</p>\n<p>C类</p>\n<p>2^21-1</p>\n<p>扣除了192.0.0.0 从192.0.1.0开始</p>\n<p>2^8-2</p>\n<p>扣除全0和全1原因同上</p>\n<p>其他特殊IP<br><code>10.*.*.*</code> <code>172.16.*.*-172.31.*.*</code> <code>192.168.*.*</code> - 三个私有地址网段 用于私网</p>\n<ul>\n<li>子网的划分<br>将B类地址主机号前面几个字作为子网号 划分子网 将二级地址转化为三级地址<br>现有B类地址<code>145.13.0.0</code>取八位作为子网<code>145.13.1.0</code>为一个子网 主机号剩下8位</li>\n</ul>\n<p>子网掩码<br>当<code>145.13.1.3</code>到达路由器<code>145.13.0.0</code>(描述不恰当)后 如何将其转发到子网<code>145.13.1.0</code><br>使用子网掩码AND运算得到网络地址<br>子网掩码子网数子网主机数p138</p>\n<p><em>@划分子网情况下分组转发算法p140@</em></p>\n<ul>\n<li>构成超网<br>变长子网掩码VLSM(Variable Length Subnet Mask)<br>在其基础上研究出无分类编址方法-无分类域间路由选择CIDR(Classless Inter-domain Routing)</li>\n</ul>\n<p>128.14.35.7/20 表明前20位是网络前缀<br>成为/20地址块<br><em>@变长子网掩码划分子网@</em></p>\n<p>用CIDR地址块来查找目的网络 这种地址的聚合常称为<code>聚合路由</code>也称为<code>构成超网</code></p>\n<p>从匹配结果总选择具有最长网络前缀的路由-<code>最长前缀匹配</code></p>\n<hr>\n<p>ARP略</p>\n<hr>\n<p>IP数据报格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0                   1                   2                   3</span><br><span class=\"line\">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|         Identification        |Flags|      Fragment Offset    |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                       Source Address                          |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                    Destination Address                        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                    Options                    |    Padding    |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>\n<p>IHL: 首部长度 最大 2^4-1 = 15 <code>单位四字节</code><br>最小是5 即最小首部为20字节<br>最大15  即最大为60字节</p>\n<p>Total Length: 总长度 最大 2^16-1 = 65535 <code>单位一字节</code><br>以太网最大数据帧 1518 抛去14头部 4字节校验 剩余1500即为<code>MTU</code>  数据<code>帧</code>(链路层)的<code>数据字段</code>最大长度</p>\n<p>flags: 标识<br>第一位MF MF=1标识<code>还有分片</code> DF=1标识<code>不能分片</code></p>\n<p>Fragment Offset: 片偏移 <code>单位八字节</code><br>13位  </p>\n<p><em>@分片计算 p129@</em></p>\n<p>Time to Live: 生存时间<br><code>先减1</code>再判断是否为0, 为0则丢弃</p>\n<p>Protocol: 协议<br>常用 TCP-6 UDP-17</p>\n<p>Header Checksum: <code>首部校验和</code> 不包括数据部分<br>每次经过路由器都可能变化 生存时间标志片偏移可能变化</p>\n<hr>\n<p>首部分为很多16位字的序列 先将原校验和清零 在将所有序列求反码相加 再求反码写入校验和<br>接收方将所有序列 求反码相加(这里不将校验和清零) 得到的和取反码 必须为零 </p>\n<p>IP数据报的可选部分无分隔符 最后需要用全0的字段补齐为 <code>四的整数倍</code></p>\n<p><code>分组转发算法</code><br><em>@路由器路径 与路由表下一跳地址 p132@</em></p>\n<p>同页特定主机路由和默认路由 下一页分组转发算法</p>\n<p>ICMP略</p>\n<p>互联网路由选择协议</p>\n<h1 id=\"运输层\"><a href=\"#运输层\" class=\"headerlink\" title=\"运输层\"></a>运输层</h1><p>网络层为<code>主机</code>之间提供逻辑通信, 而传输层为应用程序之间提供<code>端到端</code>的逻辑通信</p>\n<p>熟知端口号 - 0<del>1023 - 服务器端<br>登记端口号 - 1024</del>49151 - 提供给没有熟知端口号使用<br>短暂端口号 - 客户端</p>\n<p>复用分用的关键 对下使用了IP数据报头部的字段Protocol 以及 对上端口号的使用</p>\n<p>UDP数据报 TCP报文段<br>UDP是无连接的, 不可靠的, 基于数据报<br>TCP是面向连接的, 可靠的, 基于流的服务<br>(可靠 无差错, 不丢失, 不重复, 按序到达)</p>\n<h2 id=\"用户数据报协议-UDP-User-Datagram-Protocol\"><a href=\"#用户数据报协议-UDP-User-Datagram-Protocol\" class=\"headerlink\" title=\"用户数据报协议 UDP User Datagram Protocol\"></a>用户数据报协议 UDP User Datagram Protocol</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0      7 8     15 16    23 24    31</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|          source address           |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|        destination address        |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|  zero  |protocol|   UDP length    |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">0      7 8     15 16    23 24    31</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|     Source      |   Destination   |</span><br><span class=\"line\">|      Port       |      Port       |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|                 |                 |</span><br><span class=\"line\">|     Length      |    Checksum     |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|</span><br><span class=\"line\">|          data octets ...</span><br><span class=\"line\">+---------------- ...</span><br><span class=\"line\"></span><br><span class=\"line\">    User Datagram Header Format</span><br></pre></td></tr></table></figure>\n\n<p>UDP length 同 Length: 最小值为8（仅包含首部 无数据）<br>Checksum: 校验和 使用 <code>伪首部</code> <code>首部</code> <code>数据</code> 计算出<br>校验了源和目的端口和地址</p>\n<p>protocol： udp为17 tcp为6</p>\n<p>伪首部12字节, 既不向下传递, 也不向上递交 仅仅为了计算校验和</p>\n<p><em>@校验和计算 p210@</em><br><em>@TCP和UDP交付IP层的分片@</em><br>同样16B一组 </p>\n<h2 id=\"传输控制协议-TCP-Transmission-Control-Protocol\"><a href=\"#传输控制协议-TCP-Transmission-Control-Protocol\" class=\"headerlink\" title=\"传输控制协议 TCP Transmission Control Protocol\"></a>传输控制协议 TCP Transmission Control Protocol</h2><p>为了传输的可靠性使用了下面的协议<br><strong>自动重传请求ARQ</strong><br>超时重传：每次发送完设置超时计时器， 超时之前收到确认就取消定时器， 否则到期后重发，并重置定时器。</p>\n<p><code>收到重复报文</code>：A发送后B的回复丢失，A重发报文。丢弃重复的报文， 并向对方发送确认，而不能认为之前发送过就不发送了。<br><code>收到迟到的确认报文</code>：丢弃， 什么也不做。</p>\n<p><strong><del>停止等待协议</del> 流水线传输协议</strong><br>使用流水线传输协议 就要使用 连续ARQ协议 和 滑动窗口协议</p>\n<p><strong>连续ARQ协议</strong><br>可以连续发送五个连续分组 而不需要对方的确认</p>\n<p>每收到一个确认，发送窗口就向前滑动。如果原来发送了五个分组就可以发送第六个分组了。<br>累计确认： 对按序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都收到了。<br>GO-back-N：如果中间第三个分组丢失，接收方只能发送前两个分组的确认，发送方需要发送后面三个分组。</p>\n<p><strong>滑动窗口协议</strong></p>\n<p> <strong>拥塞控制</strong><br><em>@p232 拥塞控制方法 画图和慢开始 拥塞避免 快恢复@</em></p>\n<p><strong>超时重传时间确认</strong></p>\n<p>报文往返时间RTTS<br>新的RTTS = (1-a) x 旧RTTS + a x 新RTTS<br>a = 0.125</p>\n<p>超时重传时间<br>RTO = RTTS + 4 x RTTD</p>\n<p>RTTD = (1 - b) x 旧RTTD + b x | RTTS - 新的RTT |<br>b = 0,25</p>\n<p>karn算法 只要报文段重传就不采用其往返时间<br>修正 每重传一次新的时间为旧的2倍</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0                   1                   2                   3</span><br><span class=\"line\">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|          Source Port          |       Destination Port        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                        Sequence Number                        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                    Acknowledgment Number                      |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class=\"line\">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class=\"line\">|       |           |G|K|H|T|N|N|                               |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|           Checksum            |         Urgent Pointer        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                    Options                    |    Padding    |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                             data                              |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>\n\n<p>seq: 序号<br><em>报文的序号和ack的对应关系</em></p>\n<p>ack: 确认号<br>确认号为N 表明, 到序号N-1的所有数据都收到</p>\n<p>数据偏移: 单位是四字节<br>头部长度 最少是20字节 最大是60字节 所以该项最少为5</p>\n<p>URG: 紧急标识<br>如果TCP发送缓冲区有很多数据, 但需要紧急发送某个命令. 正常情况下会加在缓冲区位<br>如果设置了标识, 则插入到最前边</p>\n<p>ACK: 确认号<br>TCP规定, 建立连接后所有的报文段ACK都设置为1<br><strong>可以携带数据 不携带数据则不会消耗 报文号</strong></p>\n<p>PSH: 推送<br>接收方收到该标识后 将数据尽快提交到应用程序, 而不是等缓冲满了提交</p>\n<p>RST: 复位<br>说明TCP连接出现严重差错  必须重新建立连接</p>\n<p>SYN: 同步<br>连接建立时用来同步序号<br>含有此标记 不能携带数据 但<strong>仍要消耗一个序列号</strong></p>\n<p>FIN: 终止连接</p>\n<p>窗口:<br>发送本报文段一方的接收窗口</p>\n<p>检验和:<br>需要加上12字节的伪首部<br><em>检验和计算</em></p>\n<p>紧急指针:<br>指明报文段中紧急数据的字节数</p>\n<p>MSS: 最大报文段长度, 指的是数据字段的最大长度</p>\n<p><em>@tcp连接的建立和断开 p238@</em></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"?\"></a>?</h1><p>物理层-以太网帧<br>数据链路层-MAC帧-添加了首部和尾部-FCS校验<br>网络层-IP数据报-首部校验和<br>传输层-报文,流 </p>\n<h1 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h1><p><strong>封装成帧</strong><br>帧首部SOH, 01H<br>帧尾部EOT, 04H</p>\n<p><strong>透明传输</strong><br>数据部分出现 01H和04H以及1BH  在前面增加转义字符ESC 1BH</p>\n<p><strong>差错检测</strong><br>CRC校验<br>FCS冗余码</p>\n<p><strong>PPP协议</strong><br>7EH 帧首帧尾</p>\n<h1 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h1><p>网络层-数据报<br>数据链路层-MAC帧</p>\n<p>网络层向上只提供 简单灵活的 无连接的 尽最大努力交付 的 <code>数据报</code>服务</p>\n<p>地址解析协议ARP<br>网际控制报文协议 ICMP<br>网际组管理协议 IGMP</p>\n<p>转发器-物理层使用的中间设备<br>网桥或桥接器-数据链路层使用的中间设备<br>路由器-网络层中间设备<br>网关-网络层以上使用的中间设备</p>\n<p>一个路由器互联的多个局域网网络中-<code>网络层及以上高层协议必须相同</code> 而物理层和数据链路层则可不同(p116)<br>IP地址<code>用于网络层及以上高层</code> MAC地址用于<code>数据链路层和物理层</code></p>\n<p>路由器转发的时候 源和目的MAC都<code>会</code>变化, 然而源和目的IP<code>不</code>变化 p118 p123</p>\n<p>互联网名字和数字分配机构ICANN进行分配</p>\n<p><strong>IP地址编址的三个阶段</strong></p>\n<ul>\n<li>分类的IP地址<br>IP地址由<code>网络号-主机号</code>构成</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>范围</th>\n<th>网络号固定部分</th>\n<th>总网络号位数</th>\n<th>主机号位数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>A类</td>\n<td>1-126</td>\n<td>0</td>\n<td>7+1位</td>\n<td>主机号24位</td>\n</tr>\n<tr>\n<td>B类</td>\n<td>128-191</td>\n<td>10</td>\n<td>2+14位</td>\n<td>主机号16位</td>\n</tr>\n<tr>\n<td>C类</td>\n<td>192-223</td>\n<td>110</td>\n<td>3+21位</td>\n<td>主机号8位</td>\n</tr>\n<tr>\n<td>D类</td>\n<td>224-239</td>\n<td>1110</td>\n<td>多播地址</td>\n<td></td>\n</tr>\n<tr>\n<td>E类</td>\n<td>240-255</td>\n<td>1111</td>\n<td>保留</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>A类</p>\n<p>2^7-2</p>\n<p>网络号全0 表示本网络<br>网络号 0111 1111 127 代表本地换环回(你压根没被当做网络地址, 上表中跳过了127)</p>\n<p>2^24-2</p>\n<p>主机号全0 表示本主机连接的网络地址<br>主机号全1 代表该网络上的所有主机</p>\n<p>B类</p>\n<p>2^14-1</p>\n<p>扣除了128.0.0.0 从128.1.0.0开始</p>\n<p>2^16-2</p>\n<p>抛去主机号全0和全1 原因同上</p>\n<p>C类</p>\n<p>2^21-1</p>\n<p>扣除了192.0.0.0 从192.0.1.0开始</p>\n<p>2^8-2</p>\n<p>扣除全0和全1原因同上</p>\n<p>其他特殊IP<br><code>10.*.*.*</code> <code>172.16.*.*-172.31.*.*</code> <code>192.168.*.*</code> - 三个私有地址网段 用于私网</p>\n<ul>\n<li>子网的划分<br>将B类地址主机号前面几个字作为子网号 划分子网 将二级地址转化为三级地址<br>现有B类地址<code>145.13.0.0</code>取八位作为子网<code>145.13.1.0</code>为一个子网 主机号剩下8位</li>\n</ul>\n<p>子网掩码<br>当<code>145.13.1.3</code>到达路由器<code>145.13.0.0</code>(描述不恰当)后 如何将其转发到子网<code>145.13.1.0</code><br>使用子网掩码AND运算得到网络地址<br>子网掩码子网数子网主机数p138</p>\n<p><em>@划分子网情况下分组转发算法p140@</em></p>\n<ul>\n<li>构成超网<br>变长子网掩码VLSM(Variable Length Subnet Mask)<br>在其基础上研究出无分类编址方法-无分类域间路由选择CIDR(Classless Inter-domain Routing)</li>\n</ul>\n<p>128.14.35.7/20 表明前20位是网络前缀<br>成为/20地址块<br><em>@变长子网掩码划分子网@</em></p>\n<p>用CIDR地址块来查找目的网络 这种地址的聚合常称为<code>聚合路由</code>也称为<code>构成超网</code></p>\n<p>从匹配结果总选择具有最长网络前缀的路由-<code>最长前缀匹配</code></p>\n<hr>\n<p>ARP略</p>\n<hr>\n<p>IP数据报格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0                   1                   2                   3</span><br><span class=\"line\">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|         Identification        |Flags|      Fragment Offset    |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                       Source Address                          |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                    Destination Address                        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                    Options                    |    Padding    |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>\n<p>IHL: 首部长度 最大 2^4-1 = 15 <code>单位四字节</code><br>最小是5 即最小首部为20字节<br>最大15  即最大为60字节</p>\n<p>Total Length: 总长度 最大 2^16-1 = 65535 <code>单位一字节</code><br>以太网最大数据帧 1518 抛去14头部 4字节校验 剩余1500即为<code>MTU</code>  数据<code>帧</code>(链路层)的<code>数据字段</code>最大长度</p>\n<p>flags: 标识<br>第一位MF MF=1标识<code>还有分片</code> DF=1标识<code>不能分片</code></p>\n<p>Fragment Offset: 片偏移 <code>单位八字节</code><br>13位  </p>\n<p><em>@分片计算 p129@</em></p>\n<p>Time to Live: 生存时间<br><code>先减1</code>再判断是否为0, 为0则丢弃</p>\n<p>Protocol: 协议<br>常用 TCP-6 UDP-17</p>\n<p>Header Checksum: <code>首部校验和</code> 不包括数据部分<br>每次经过路由器都可能变化 生存时间标志片偏移可能变化</p>\n<hr>\n<p>首部分为很多16位字的序列 先将原校验和清零 在将所有序列求反码相加 再求反码写入校验和<br>接收方将所有序列 求反码相加(这里不将校验和清零) 得到的和取反码 必须为零 </p>\n<p>IP数据报的可选部分无分隔符 最后需要用全0的字段补齐为 <code>四的整数倍</code></p>\n<p><code>分组转发算法</code><br><em>@路由器路径 与路由表下一跳地址 p132@</em></p>\n<p>同页特定主机路由和默认路由 下一页分组转发算法</p>\n<p>ICMP略</p>\n<p>互联网路由选择协议</p>\n<h1 id=\"运输层\"><a href=\"#运输层\" class=\"headerlink\" title=\"运输层\"></a>运输层</h1><p>网络层为<code>主机</code>之间提供逻辑通信, 而传输层为应用程序之间提供<code>端到端</code>的逻辑通信</p>\n<p>熟知端口号 - 0<del>1023 - 服务器端<br>登记端口号 - 1024</del>49151 - 提供给没有熟知端口号使用<br>短暂端口号 - 客户端</p>\n<p>复用分用的关键 对下使用了IP数据报头部的字段Protocol 以及 对上端口号的使用</p>\n<p>UDP数据报 TCP报文段<br>UDP是无连接的, 不可靠的, 基于数据报<br>TCP是面向连接的, 可靠的, 基于流的服务<br>(可靠 无差错, 不丢失, 不重复, 按序到达)</p>\n<h2 id=\"用户数据报协议-UDP-User-Datagram-Protocol\"><a href=\"#用户数据报协议-UDP-User-Datagram-Protocol\" class=\"headerlink\" title=\"用户数据报协议 UDP User Datagram Protocol\"></a>用户数据报协议 UDP User Datagram Protocol</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0      7 8     15 16    23 24    31</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|          source address           |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|        destination address        |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|  zero  |protocol|   UDP length    |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">0      7 8     15 16    23 24    31</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|     Source      |   Destination   |</span><br><span class=\"line\">|      Port       |      Port       |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|                 |                 |</span><br><span class=\"line\">|     Length      |    Checksum     |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|</span><br><span class=\"line\">|          data octets ...</span><br><span class=\"line\">+---------------- ...</span><br><span class=\"line\"></span><br><span class=\"line\">    User Datagram Header Format</span><br></pre></td></tr></table></figure>\n\n<p>UDP length 同 Length: 最小值为8（仅包含首部 无数据）<br>Checksum: 校验和 使用 <code>伪首部</code> <code>首部</code> <code>数据</code> 计算出<br>校验了源和目的端口和地址</p>\n<p>protocol： udp为17 tcp为6</p>\n<p>伪首部12字节, 既不向下传递, 也不向上递交 仅仅为了计算校验和</p>\n<p><em>@校验和计算 p210@</em><br><em>@TCP和UDP交付IP层的分片@</em><br>同样16B一组 </p>\n<h2 id=\"传输控制协议-TCP-Transmission-Control-Protocol\"><a href=\"#传输控制协议-TCP-Transmission-Control-Protocol\" class=\"headerlink\" title=\"传输控制协议 TCP Transmission Control Protocol\"></a>传输控制协议 TCP Transmission Control Protocol</h2><p>为了传输的可靠性使用了下面的协议<br><strong>自动重传请求ARQ</strong><br>超时重传：每次发送完设置超时计时器， 超时之前收到确认就取消定时器， 否则到期后重发，并重置定时器。</p>\n<p><code>收到重复报文</code>：A发送后B的回复丢失，A重发报文。丢弃重复的报文， 并向对方发送确认，而不能认为之前发送过就不发送了。<br><code>收到迟到的确认报文</code>：丢弃， 什么也不做。</p>\n<p><strong><del>停止等待协议</del> 流水线传输协议</strong><br>使用流水线传输协议 就要使用 连续ARQ协议 和 滑动窗口协议</p>\n<p><strong>连续ARQ协议</strong><br>可以连续发送五个连续分组 而不需要对方的确认</p>\n<p>每收到一个确认，发送窗口就向前滑动。如果原来发送了五个分组就可以发送第六个分组了。<br>累计确认： 对按序到达的最后一个分组发送确认，表示到这个分组为止的所有分组都收到了。<br>GO-back-N：如果中间第三个分组丢失，接收方只能发送前两个分组的确认，发送方需要发送后面三个分组。</p>\n<p><strong>滑动窗口协议</strong></p>\n<p> <strong>拥塞控制</strong><br><em>@p232 拥塞控制方法 画图和慢开始 拥塞避免 快恢复@</em></p>\n<p><strong>超时重传时间确认</strong></p>\n<p>报文往返时间RTTS<br>新的RTTS = (1-a) x 旧RTTS + a x 新RTTS<br>a = 0.125</p>\n<p>超时重传时间<br>RTO = RTTS + 4 x RTTD</p>\n<p>RTTD = (1 - b) x 旧RTTD + b x | RTTS - 新的RTT |<br>b = 0,25</p>\n<p>karn算法 只要报文段重传就不采用其往返时间<br>修正 每重传一次新的时间为旧的2倍</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0                   1                   2                   3</span><br><span class=\"line\">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|          Source Port          |       Destination Port        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                        Sequence Number                        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                    Acknowledgment Number                      |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class=\"line\">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class=\"line\">|       |           |G|K|H|T|N|N|                               |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|           Checksum            |         Urgent Pointer        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                    Options                    |    Padding    |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                             data                              |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>\n\n<p>seq: 序号<br><em>报文的序号和ack的对应关系</em></p>\n<p>ack: 确认号<br>确认号为N 表明, 到序号N-1的所有数据都收到</p>\n<p>数据偏移: 单位是四字节<br>头部长度 最少是20字节 最大是60字节 所以该项最少为5</p>\n<p>URG: 紧急标识<br>如果TCP发送缓冲区有很多数据, 但需要紧急发送某个命令. 正常情况下会加在缓冲区位<br>如果设置了标识, 则插入到最前边</p>\n<p>ACK: 确认号<br>TCP规定, 建立连接后所有的报文段ACK都设置为1<br><strong>可以携带数据 不携带数据则不会消耗 报文号</strong></p>\n<p>PSH: 推送<br>接收方收到该标识后 将数据尽快提交到应用程序, 而不是等缓冲满了提交</p>\n<p>RST: 复位<br>说明TCP连接出现严重差错  必须重新建立连接</p>\n<p>SYN: 同步<br>连接建立时用来同步序号<br>含有此标记 不能携带数据 但<strong>仍要消耗一个序列号</strong></p>\n<p>FIN: 终止连接</p>\n<p>窗口:<br>发送本报文段一方的接收窗口</p>\n<p>检验和:<br>需要加上12字节的伪首部<br><em>检验和计算</em></p>\n<p>紧急指针:<br>指明报文段中紧急数据的字节数</p>\n<p>MSS: 最大报文段长度, 指的是数据字段的最大长度</p>\n<p><em>@tcp连接的建立和断开 p238@</em></p>\n"},{"title":"Linux高性能服务器-初级部分","date":"2019-08-17T12:34:39.000Z","top":100,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg","_content":"开头选了这本书, 看到这本书是他人总结三大本后自己写的, 先求个理解大概.\n话说别人推荐的c++服务器咋都是c语言.....\n2019年8月17日20:37:53\n\n每学习一部分就写一个demo\n<!--more-->\n\n2020年7月16日12:43:41\n\n上面那个more标签让我想起了我第一个hexo博客的主题.\n大二暑假了, 距离这篇博客写下已经将近一年了. 时间过得真快, 唯一不变的就是自己依然的菜..\n也理解为什么C++服务器推荐的C语言\n\n这里将第五章后面的内容整理下.\n这算是我第一次写的博客吧, 之前写的时候写的过于详细和冗余了. 目前有了一点基础, 所以这次重新读是为了\n把博客和书读薄\n\n目前第五章后的博客有13000个汉字和44000个字母. 看看整理完毕后有多少吧\n\n## 第五章Linux网络编程基础API\n\n### 主机字节序和网络字节序\n\n字节序分为 `大端字节序`和`小端字节序`\n由于大多数PC采用小端字节序(高位存在高地址处), 所以小端字节序又称为主机字节序\n\n为了防止不同机器字节序不同导致的错乱问题. 规定传输的时候统一为 大端字节序(网络字节序).\n这样主机会根据自己的情况决定 - 是否转换接收到的数据的字节序\n\n\n**基础连接**\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93.jpg)\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88%E5%9C%B0%E5%9D%80%E6%97%8F.jpg)\n\n\n字节序转换\n```c++\n#include <netinet/in.h>\nunsigned long int htonl (unsigned long int hostlong); // host to network long\nunsigned short int htons (unsigned short int hostlong); // host to network short\n\nunsigned long int ntohl (unsigned long int netlong);\nunsigned short int ntohs (unsigned short int netlong);\n```\n\n点分十进制地址和网络地址转换\n程序需要使用网络地址 给人察看需要使用点分十进制 灵活转换\n```c++\n#include <arpa/inet.h>\n// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONE\nin_addr_t  inet_addr(const char* strptr);\n\n// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0\nint inet_aton(const char* cp, struct in_addr* inp);\n\n// 函数返回一个静态变量地址值, 所以多次调用会导致覆盖\nchar* inet_ntoa(struct in_addr in); \n\n// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族\n// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1\nint inet_pton(int af, const char * src, void* dst);\n// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)\nconst char* inet_ntop(int af, const void*  src, char* dst, socklen_t cnt);\n```\n\nsocket 三部曲\n```c++\n// 创建 命名 监听 socket\n# include <sys/socket.h>\n// domain指定使用那个协议族 PF_INET PF_INET6\n// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)\n// 有两个使用较多的选项SOCK_NONBLOCK 设置非阻塞\n// SOCK_CLOEXEC 使用fork创建子进程的时候在子进程中关闭该socket\n// protocol设置为默认的0\n// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1\nint socket(int domain, int type, int protocol);\n\n// socket为socket文件描述符\n// my_addr 为地址信息\n// addrlen为socket地址长度\n// 成功返回0 失败返回 -1\n// 这里细说还有个EADDRINUSE(被绑定的地址正在使用如TIME_WAIT状态)\n// 与之搭配的解决方式 是使用setsockopt设置SO_REUSEADDR为true\nint bind(int socket, const struct sockaddr* my_addr, socklen_t addrlen);\n\n// backlog表示队列最大的长度\nint listen(int socket, int backlog);\n```\n\n\n服务器\n```c++\n// 接受连接 失败返回-1 成功时返回socket\nint accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen)\n```\n\n\n客户端\n```c\n// 发起连接\n#include <sys/types.h>\n#include <sys/socket.h>\n// 第三个参数为 地址指定的长度\n// 成功返回0 失败返回-1\nint connect(int sockfd, const struct sockaddr * serv_addr, socklen_t addrlen);\n```\n\n连接关闭\n```c++\n// 关闭连接\n#include <unistd.h>\n// 参数为保存的socket\n// 并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才能关闭(需要查阅)\nint close(int fd);\n\n// 立即关闭\n#include <sys/socket.h>\n// 第二个参数为可选值 \n//\tSHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃\n//\tSHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去\n//\tSHUT_RDWR 同时关闭读和写\n// 成功返回0 失败为-1 设置errno\nint shutdown(int sockfd, int howto)\n// 1. close会将引用计数-1 等到为0时才关闭套接字. shutdown则可以无视此, 激发TCP的正常连接终止序列\n// 2. close会终止读和写两个方向的数据传送, 但由于TCP全双工有时需要告知对方我方发送已经完毕\n```\n\n\n基础TCP\n```c\n#include<sys/socket.h>\n#include<sys/types.h>\n\n// 读取sockfd的数据\n// buf 指定读缓冲区的位置\n// len 指定读缓冲区的大小\n// flags 参数较多\n// 成功的时候返回读取到的长度, 可能小于预期长度, 需要多次读取.   读取到0 通信对方已经关闭连接, 错误返回-1\nssize_t recv(int sockfd, void *buf, size_t len, int flags);\n// 发送\nssize_t send(int sockfd, const void *buf, size_t len, int flags);\n```\n\n| 选项名        | 含义                                                                                     | 可用于发送 | 可用于接收 |\n| ------------- | ---------------------------------------------------------------------------------------- | ---------- | ---------- |\n| MSG_CONFIRM   | 指示链路层协议持续监听, 直到得到答复.(仅能用于SOCK_DGRAM和SOCK_RAW类型的socket)          | Y          | N          |\n| MSG_DONTROUTE | 不查看路由表, 直接将数据发送给本地的局域网络的主机(代表发送者知道目标主机就在本地网络中) | Y          | N          |\n| MSG_DONTWAIT  | 非阻塞                                                                                   | Y          | Y          |\n| MSG_MORE      | 告知内核有更多的数据要发送, 等到数据写入缓冲区完毕后,一并发送.减少短小的报文提高传输效率 | Y          | N          |\n| MSG_WAITALL   | 读操作一直等待到读取到指定字节后才会返回                                                 | N          | Y          |\n| MSG_PEEK      | 看一下内缓存数据, 并不会影响数据                                                         | N          | Y          |\n| MSG_OOB       | 发送或接收紧急数据                                                                       | Y          | Y          |\n| MSG_NOSIGNAL  | 向读关闭的管道或者socket连接中写入数据不会触发SIGPIPE信号                                | Y          | N          |\n\n基础UDP\n```c\n#include <sys/types.h>\n#include <sys/socket.h>\n// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.\n// 不过recvfrom和sendto 也可以用于 面向STREAM的连接, 这样可以省略发送和接收端的socket地址\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen);\nssize_t sendto(int sockfd, const void* buf, size_t len, ing flags, const struct sockaddr* dest_addr, socklen_t addrlen);\n```\n\n通用读写函数\n```c\n#inclued <sys/socket.h>\nssize_t recvmsg(int sockfd, struct msghdr* msg, int flags);\nssize_t sendmsg(int sockfd, struct msghdr* msg, int flags);\n\nstruct msghdr\n{\n/* socket address --- 指向socket地址结构变量, 对于TCP连接需要设置为NULL*/\n\tvoid* msg_name; \n\n\n\tsocklen_t msg_namelen;\n\t\n\t/* 分散的内存块 --- 对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由\n     * msg_iov指向的数组指定, 称为分散读(scatter read)  ---对于sendmsg而言, msg_iovlen块的分散内存中\n     * 的数据将一并发送称为集中写(gather write);\n\t*/\n\tstruct iovec* msg_iov;\n\tint msg_iovlen; /* 分散内存块的数量*/\n\tvoid* msg_control; /* 指向辅助数据的起始位置*/\n\tsocklen_t msg_controllen; /* 辅助数据的大小*/\n\tint msg_flags; /* 复制函数的flags参数, 并在调用过程中更新*/\n};\n\nstruct iovec\n{\n\tvoid* iov_base /* 内存起始地址*/\n\tsize_t iov_len /* 这块内存长度*/\n}\n```\n\n其他Api\n```c\n#include <sys/socket.h>\n// 用于判断 sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据, \n// 是的话返回1, 不是返回0\n// 这样就可以选择带MSG_OOB标志的recv调用来接收带外数据. \nint sockatmark(int sockfd);\n\n// getsockname 获取sockfd对应的本端socket地址, 存入address指定的内存中, 长度存入address_len中 成功返回0失败返回-1\n// getpeername 获取远端的信息, 同上\nint getsockname(int sockfd, struct sockaddr* address, socklen_t* address_len);\nint getpeername(int sockfd, struct sockaddr* address, socklen_t* address_len);\n```\n\n重要 socket属性设置\n```c++\n/* 以下函数头文件均相同*/\n\n// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度\n// 成功时返回0 失败返回-1\nint getsockopt(int sockfd, int level, int option_name, void* option_value, \n\t\t\t\t\t\tsocklen_t restrict option_len);\nint setsockopt(int sockfd, int level, int option_name, void* option_value, \n\t\t\t\t\t\tsocklen_t restrict option_len);\n```\n\n```c\nstruct linger\n{\n\tint l_onoff /* 开启非0, 关闭为0*/\n\tint l_linger; /* 滞留时间*/\n\t/*\n\t* 当onoff为0的时候此项不起作用, close调用默认行为关闭socket\n\t* 当onoff不为0 且linger为0, close将立即返回, TCP将丢弃发送缓冲区的残留数据, 同时发送一个复位报文段\n\t* 当onoff不为0 且linger大于0 . 当socket阻塞的时候close将会等待TCP模块发送完残留数据并得到确认后关 \n\t* 闭, 如果是处于非阻塞则立即关闭\n\t*/\n};\n```\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/socket%E9%80%89%E9%A1%B9.jpg)\n\n\n**网络信息API**\n```c\n#include <netdb.h>\n// 通过主机名查找ip\nstruct hostent* gethostbyname(const char* name);\n\n// 通过ip获取主机完整信息 \n// type为IP地址类型 AF_INET和AF_INET6\nstruct hostent* gethostbyaddr(const void* addr, size_t len, int type);\n\nstruct hostent\n{\n  char *h_name;\t\t\t/* Official name of host.  */\n  char **h_aliases;\t\t/* Alias list.  */\n  int h_addrtype;\t\t/* Host address type.  */\n  int h_length;\t\t\t/* Length of address.  */\n  char **h_addr_list;\t\t/* List of addresses from name server.  */\n}\n\nint main(int argc, char* argv[])\n{\n    if (argc != 2)\n    {\n        printf(\"非法输入\\n\");\n        exit(0);\n    }\n    char* name = argv[1];\n\n    struct hostent *hostptr{};\n\n    hostptr = gethostbyname(name);\n    if (hostptr == nullptr)\n    {\n        printf(\"输入存在错误 或无法获取\\n\");\n        exit(0);\n    }\n\n    printf(\"Official name of hostptr: %s\\n\", hostptr->h_name);\n\n    char **pptr;\n    char inet_addr[INET_ADDRSTRLEN];\n\n    printf(\"Alias list:\\n\");\n    for (pptr = hostptr->h_aliases; *pptr != nullptr; ++pptr)\n    {\n        printf(\"\\t%s\\n\", *pptr);\n    }\n\n    switch (hostptr->h_addrtype)\n    {\n        case AF_INET:\n        {\n            printf(\"List of addresses from name server:\\n\");\n            for (pptr = hostptr->h_addr_list; *pptr != nullptr; ++pptr)\n            {\n                printf(\"\\t%s\\n\",\n                        inet_ntop(hostptr->h_addrtype, *pptr, inet_addr, sizeof(inet_addr)));\n            }\n            break;\n        }\n        default:\n        {\n            printf(\"unknow address type\\n\");\n            exit(0);\n        }\n    }\n    return 0;\n}\n\n/*\n./run baidu.com\nOfficial name of hostptr: baidu.com\nAlias list:\nList of addresses from name server:\n\t39.156.69.79\n\t220.181.38.148\n*/\n```\n以下两个函数通过读取/etc/services文件 来获取服务信息 以下内容来自维基百科\n\nService文件是现代操作系统在etc目录下的一个配置文件，记录网络服务名对应的端口号与协议 其用途如下\n- 通过TCP/IP的API函数（声明在netdb.h中）直接查到网络服务名与端口号、使用协议的对应关系。如getservbyname(\"serve\",\"tcp\")获取端口号;getservbyport（htons（port），“tcp”）获取端口和协议上的服务名\n- 如果用户在这个文件中维护所有使用的网络服务名字、端口、协议，那么可以一目了然的获悉哪些端口号用于哪个服务，哪些端口号是空闲的\n```c\n#include <netdb.h>\n// 根据名称获取某个服务的完整信息\nstruct servent getservbyname(const char* name, const char* proto);\n\n// 根据端口号获取服务信息\nstruct servent getservbyport(int port, const char* proto);\n\nstruct servent\n{\n\tchar* s_name; /* 服务名称*/\n\tchar ** s_aliases; /* 服务的别名列表*/\n\tint s_port; /* 端口号*/\n\tchar* s_proto; /* 服务类型, 通常为TCP或UDP*/\n}\n```\n```c\n#include <netdb.h>\n// 内部使用的gethostbyname 和 getserverbyname\n// hostname 用于接收主机名, 也可以用来接收字符串表示的IP地址(点分十进制, 十六进制字符串)\n// service 用于接收服务名, 字符串表示的十进制端口号\n// hints参数 对getaddrinfo的输出进行更准确的控制, 可以设置为NULL, 允许反馈各种有用的结果\n// result 指向一个链表, 用于存储getaddrinfo的反馈结果\nint getaddrinfo(const char* hostname, const char* service, const struct addrinfo* hints, struct addrinfo** result)\n\nstruct addrinfo\n{\n\tint ai_flags;\n\tint ai_family;\n\tint ai_socktype; /* 服务类型, SOCK_STREAM或者SOCK_DGRAM*/\n\tint ai_protocol;\n\tsocklen_t ai_addrlen;\n\tchar* ai_canonname; /* 主机的别名*/\n\tstruct sockaddr* ai_addr; /* 指向socket地址*/\n\tstruct addrinfo* ai_next; /* 指向下一个结构体*/\n}\n\n// 需要手动的释放堆内存\nvoid freeaddrinfo(struct addrinfo* res);\n```\n![](https://ftp.bmp.ovh/imgs/2019/08/7ebedb14d8eedeac.png)\n\n```c\n#include <netdb.h>\n// host 存储返回的主机名\n// serv存储返回的服务名\n\nint getnameinfo(const struct sockaddr* sockaddr, socklen_t addrlen, char* host, socklen_t hostlen, char* serv\n\tsocklen_t servlen, int flags);\n\n```\n![](https://ftp.bmp.ovh/imgs/2019/08/bc7196e9a30d5152.png)\n\n测试\n使用\n```shell\ntelnet ip port #来连接服务器的此端口\nnetstat -nt | grep port #来查看此端口的监听\n```\n\n## 第六章高级IO函数\n\nLinux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件自然限制了他的使用频率\n*文件描述符*\n文件描述符在是一个非负整数。是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表。\nSTDOUT_FILENO(值为1)- 值为1的文件描述符为标准输出, 关闭STDOUT_FILENO后用dup即可返回最小可用值(目前为, 1) 这样输出就重定向到了调用dup的参数指向的文件\n\n### 创建文件描述符 - pipe dup dup2 splice\n**pipe函数**\n这个函数可用于创建一个管道, 实现进程间的通信. \n\n```c\n// 函数定义\n// 参数文件描述符数组 fd[0] 读出 fd[1]写入 单向管道\n// 成功返回0, 并将一对打开的文件描述符填入其参数指向的数组\n// 失败返回-1 errno\n#include <unistd.h>\nint pipe(int fd[2]);\n```\n```c\n// 双向管道\n// 第一个参数为 协议PF_UNIX(书上是AF_UNIX)感觉这里指明协议使用PF更好一些\n#include <sys/types.h>\n#include <sys/socket.h>\nint socketpair(int domain, int type, int protocol, int fd[2]);\n```\n学习了后面的内容了解到了进程间通信, 回来补上一个例子\n```c\nint main()\n{\n    int fds[2];\n    socketpair(PF_UNIX, SOCK_STREAM, 0, fds);\n    int pid = fork();\n    if (pid == 0)\n    {\n        close(fds[0]);\n        char a[] = \"123\";\n        send(fds[1], a, strlen(a), 0);\n    }\n    else if (pid > 0)\n    {\n        close(fds[1]);\n        char b[20] {};\n        recv(fds[0], b, 20, 0);\n        printf(\"%s\", b);\n    }\n}\n```\n**dup和dup2函数**\n复制一个现有的文件描述符\n```c\n#include <unistd.h>\n// 返回的文件描述符总是取系统当前可用的最小整数值\nint dup(int oldfd);\n// 可以用newfd来制定新的文件描述符, 如果newfd已经被打开则先关闭\n// 如果newfd==oldfd 则不关闭newfd直接返回\nint dup2(int oldfd, int newfd);\n```\ndup函数创建一个新的文件描述符, 新的文件描述符和原有的file_descriptor共同指向相同的目标.\n回来补上例子, 这个例子由于关掉了`STDOUT_FILENO`dup最小的即为`STDOUT_FILENO`所以\n标准输出都到了这个文件之中\n```c\nint main()\n{\n    int filefd = open(\"/home/lsmg/1.txt\", O_WRONLY);\n    close(STDOUT_FILENO);\n    dup(filefd);\n    printf(\"123\\n\");\n    exit(0);\n}\n```\n\n### 读写数据 - readv writev mmap munmap\n**readv/writev**\n```c\n#include <sys/uio.h>\n// count 为 vector的长度, 即为有多少块内存\n// 成功时返回写入\\读取的长度 失败返回-1\nssize_t readv(int fd, const struct iovec* vector, int count);\nssize_t writev(int fd, const struct iovec* vector, int count);\n\nstruct iovec {\n\tvoid* iov_base /* 内存起始地址*/\n\tsize_t iov_len /* 这块内存长度*/\n}\n```\n回来补上一个使用例子, 这个例子将一个int的内存表示写入到了文件之中\n使用hexdump查看这个文件`0000000 86a0 0001`可以看到`186a0`即为100000\n```c\n// 2020年1月7日16:52:11\nint main()\n{\n    int file = open(\"/home/lsmg/1.txt\", O_WRONLY);\n    int temp = 100000;\n    iovec temp_iovec{};\n    temp_iovec.iov_base = &temp;\n    temp_iovec.iov_len = sizeof(temp);\n    writev(file, &temp_iovec, 1);\n}\n```\nsendfile函数\n```c\n#include <sys/sendfile.h>\n// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取\nssize_t sendfile(int out_fd, int in_fd, off_t* offset, size_t count);\n\nO_RDONLY只读模式\nO_WRONLY只写模式\nO_RDWR读写模式\nint open(file_name, flag);\n```\nstat结构体, 可用fstat生成, **简直就是文件的身份证**\n```c\n#include <sys/stat.h>\nstruct stat\n{\n    dev_t       st_dev;     /* ID of device containing file -文件所在设备的ID*/\n    ino_t       st_ino;     /* inode number -inode节点号*/\n    mode_t      st_mode;    /* protection -保护模式?*/\n    nlink_t     st_nlink;   /* number of hard links -链向此文件的连接数(硬连接)*/\n    uid_t       st_uid;     /* user ID of owner -user id*/\n    gid_t       st_gid;     /* group ID of owner - group id*/\n    dev_t       st_rdev;    /* device ID (if special file) -设备号，针对设备文件*/\n    off_t       st_size;    /* total size, in bytes -文件大小，字节为单位*/\n    blksize_t   st_blksize; /* blocksize for filesystem I/O -系统块的大小*/\n    blkcnt_t    st_blocks;  /* number of blocks allocated -文件所占块数*/\n    time_t      st_atime;   /* time of last access -最近存取时间*/\n    time_t      st_mtime;   /* time of last modification -最近修改时间*/\n    time_t      st_ctime;   /* time of last status change - */\n};\n```\n**身份证**生成函数\n```c\n// 第一个参数需要调用open生成文件描述符\n// 下面其他两个为文件全路径\nint fstat(int filedes, struct stat *buf);\n\n// 当路径指向为符号链接的时候, lstat为符号链接的信息. stat为符号链接指向文件信息\nint stat(const char *path, struct stat *buf);\nint lstat(const char *path, struct stat *buf);\n\n/*\n* ln -s source dist  建立软连接, 类似快捷方式, 也叫符号链接\n* ln source dist  建立硬链接, 同一个文件使用多个不同的别名, 指向同一个文件数据块, 只要硬链接不被完全\n* 删除就可以正常访问\n* 文件数据块 - 文件的真正数据是一个文件数据块, 打开的`文件`指向这个数据块, 就是说\n* `文件`本身就类似快捷方式, 指向文件存在的区域.\n*/\n```\n **mmap和munmap函数**\n\n`mmap`创建一块进程通讯共享的内存(可以将文件映射入其中), `munmap`释放这块内存\n```c\n#include <sys/mman.h>\n\n// start 内存起始位置, 如果为NULL则系统分配一个地址 length为长度\n// port参数 PROT_READ(可读) PROT_WRITE(可写) PROT_EXEC(可执行), PROT_NONE(不可访问)\n// flag参数 内存被修改后的行为\n// - MAP_SHARED 进程间共享内存, 对内存的修改反映到映射文件中\n// - MAP_PRIVATE 为调用进程私有, 对该内存段的修改不会反映到文件中\n// - MAP_ANONUMOUS 不是从文件映射而来, 内容被初始化为0, 最后两个参数被忽略\n// 成功返回区域指针, 失败返回 -1\nvoid* mmap(void* start, size_t length, int port, int flags, int fd, off_t offset);\n// 成功返回0 失败返回-1\nint munmap(void* start, size_t length);\n```\n**splice函数**\n用于在两个文件名描述符之间移动数据, 0拷贝操作\n```c\n#include <fcntl.h>\n// fd_in 为文件描述符, 如果为管道文件描述符则 off_in必须为NULL, 否则为读取开始偏移位置\n// len为指定移动的数据长度, flags参数控制数据如何移动.\n// - SPLICE_F_NONBLOCK 非阻塞splice操作, 但会受文件描述符自身的阻塞\n// - SPLICE_F_MORE 给内核一个提示, 后续的splice调用将读取更多的数据???????\nssize_t splice(int fd_in, loff_t* off_in, int fd_out, loff_t* off_out, size_t len, unsigned int flags);\n\n// 使用splice函数  实现echo服务器\nint main(int argc, char* argv[])\n{\n    if (argc <= 2)\n    {\n        printf(\"the parmerters is wrong\\n\");\n        exit(errno);\n    }\n    char *ip = argv[1];\n\n    int port = atoi(argv[2]);\n    printf(\"the port is %d the ip is %s\\n\", port, ip);\n\n    int sockfd = socket(PF_INET, SOCK_STREAM, 0);\n    assert(sockfd >= 0);\n\n    struct sockaddr_in address{};\n    address.sin_family = AF_INET;\n    address.sin_port = htons(port);\n    inet_pton(AF_INET, ip, &address.sin_addr);\n\n    int ret = bind(sockfd, (sockaddr*)&address, sizeof(address));\n    assert(ret != -1);\n\n    ret = listen(sockfd, 5);\n\n    int clientfd{};\n    sockaddr_in client_address{};\n    socklen_t client_addrlen = sizeof(client_address);\n\n    clientfd = accept(sockfd, (sockaddr*)&client_address, &client_addrlen);\n    if (clientfd < 0)\n    {\n        printf(\"accept error\\n\");\n    }\n    else\n    {\n        printf(\"a new connection from %s:%d success\\n\", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));\n        int fds[2];\n        pipe(fds);\n        ret = splice(clientfd, nullptr, fds[1], nullptr, 32768, SPLICE_F_MORE);\n        assert(ret != -1);\n\n        ret = splice(fds[0], nullptr, clientfd, nullptr, 32768, SPLICE_F_MORE);\n        assert(ret != -1);\n\n        close(clientfd);\n    }\n    close(sockfd);\n    exit(0);\n}\n```\n\n## 第七章Linux服务器程序规范\n\n- Linux程序服务器 一般以后台进程形式运行.  后台进程又称为守护进程(daemon). 他没有控制终端, 因而不会意外的接收到用户输入. 守护进程的父进程通常都是init进程(PID为1的进程)\n- Linux服务器程序有一套日志系统, 他至少能输出日志到文件. 日志这东西太重要了,排错对比全靠它.\n- Linux服务器程序一般以某个专门的非root身份运行. 比如mysqld有自己的账户mysql.\n- Linux服务器程序一般都有自己的配置文件, 而不是把所有配置都写死在代码里面, 方便后续的更改.\n- Linux服务器程序通常在启动的时候生成一个PID文件并存入/var/run 目录中, 以记录改后台进程的PID.\n- Linux服务器程序通常需要考虑系统资源和限制, 预测自己的承受能力\n\n### 日志\n\n```shell\nsudo service rsyslog restart // 启动守护进程\n```\n```c\n#include <syslog.h>\n// priority参数是所谓的设施值(记录日志信息来源, 默认为LOG_USER)与日志级别的按位或\n// - 0 LOG_EMERG  /* 系统不可用*/\n// - 1 LOG_ALERT   /* 报警需要立即采取行动*/\n// - 2 LOG_CRIT /* 非常严重的情况*/\n// - 3 LOG_ERR  /* 错误*/\n// - 4 LOG_WARNING /* 警告*/\n// - 5 LOG_NOTICE /* 通知*/\n// - 6 LOG_INFO /* 信息*/\n//  -7 LOG_DEBUG /* 调试*/\nvoid syslog(int priority, const char* message, .....);\n\n// ident 位于日志的时间后 通常为名字\n// logopt 对后续 syslog调用的行为进行配置\n// -  0x01 LOG_PID  /* 在日志信息中包含程序PID*/\n// -  0x02 LOG_CONS /* 如果信息不能记录到日志文件, 则打印到终端*/\n// -  0x04 LOG_ODELAY /* 延迟打开日志功能直到第一次调用syslog*/\n// -  0x08 LOG_NDELAY /* 不延迟打开日志功能*/\n// facility参数可以修改syslog函数中的默认设施值\nvoid openlog(const char* ident, int logopt, int facility);\n\n// maskpri 一共八位 0000-0000\n// 如果将最后一个0置为1 表示 记录0级别的日志\n// 如果将最后两个0都置为1 表示记录0和1级别的日志\n// 可以通过LOG_MASK() 宏设定 比如LOG_MASK(LOG_CRIT) 表示将倒数第三个0置为1, 表示只记录LOG_CRIT\n// 如果直接设置setlogmask(3); 3的二进制最后两个数均为1 则记录 0和1级别的日志\nint setlogmask(int maskpri);\n\n// 关闭日志功能\nvoid closelog();\n```\n\n### 用户信息, 切换用户\nUID - 真实用户ID\nEUID - 有效用户ID - 方便资源访问\nGID - 真实组ID\nEGID - 有效组ID\n```c\n#include <sys/types.h>\n#include <unistd.h>\n\nuid_t getuid();\nuid_t geteuid();\ngid_t getgid();\ngid_t getegid();\nint setuid(uid_t uid);\nint seteuid(uid_t euid);\nint setgid(gid_t gid);\nint setegid(gid_t gid);\n```\n\n可以通过 `setuid`和`setgid`切换用户 **root用户uid和gid均为0**\n\n### 进程间关系\nPGID - 进程组ID(Linux下每个进程隶属于一个进程组)\n\n#include <unistd.h>\npid_t getpgid(pid_t pid); 成功时返回pid所属的pgid 失败返回-1\nint setpgid(pid_t pid, pid_t pgid);\n\n**会话**\n一些有关联的进程组将形成一个会话\n略过\n\n**查看进程关系**\nps和less\n\n**资源限制**\n略\n**改变目录**\n略\n\n## 第八章高性能服务器程序框架\n\n**服务器模型-CS模型**\n\n**优点**\n- 实现起来简单\n**缺点**\n- 服务器是通信的中心, 访问过大的时候会导致响应过慢\n\n模式图\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%BE8-2%20TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)\n\n编写的demo 没有用到fork函数. 后续待完善\n\n**服务器框架 IO模型**\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png)\n\n这个模型大概能够理解, 自己也算是学了半年的Javaweb.\n\nsocket在创建的时候默认是阻塞的, 不过可以通过传`SOCK_NONBLOCK`参解决\n非阻塞调用都会立即返回 但可能事件没有发生(recv没有接收到信息), 没有发生和出错都会`返回-1` 所以需要通过`errno`来区分这些错误.\n**事件未发生**\naccept, send,recv errno被设置为 `EAGAIN(再来一次)`或`EWOULDBLOCK(期望阻塞)`\nconnect 被设置为 `EINPROGRESS(正在处理中)`\n\n需要在事件已经发生的情况下 去调用非阻塞IO, 才能提高性能\n\n常用IO复用函数 `select` `poll` `epoll_wait` 将在第九章后面说明\n信号将在第十章说明\n\n**两种高效的事件处理模式和并发模式**\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Reactor%E6%A8%A1%E5%BC%8F.png)\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Proactor%E6%A8%A1%E5%BC%8F.png)\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E7%94%A8%E5%90%8C%E6%AD%A5IO%E6%A8%A1%E6%8B%9F%E5%87%BA%E7%9A%84Proactor%E6%A8%A1%E5%BC%8F.png)\n\n程序分为计算密集型(CPU使用很多, IO资源使用很少)和IO密集型(反过来).\n前者使用并发编程反而会降低效率, 后者则会提升效率\n并发编程有多进程和多线程两种方式\n\n并发模式 - IO单元和多个逻辑单元之间协调完成任务的方法.\n服务器主要有两种并发模式\n- 半同步/半异步模式\n- 领导者/追随者模式\n\n**半同步/半异步模式**\n在IO模型中, 异步和同步的区分是内核向应用程序通知的是何种IO事件(就绪事件还是完成事件), 以及由谁来完成IO读写(应用程序还是内核)\n\n而在这里(并发模式) \n同步指的是完全按照代码序列的顺序执行 - 按照同步方式运行的线程称为同步线程\n异步需要系统事件(中断, 信号)来驱动 - 按照异步方式运行的线程称为异步线程\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5.png)\n\n服务器(需要较好的实时性且能同时处理多个客户请求) - 一般使用同步线程和异步线程来实现,即为半同步/半异步模式\n同步线程 - 处理客户逻辑, 处理请求队列中的对象\n异步线程 - 处理IO事件, 接收到客户请求后将其封装成请求对象并插入请求队列\n\n半同步/半异步模式 存在变体 `半同步/半反应堆模式`\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F.png)\n\n异步线程 - 主线程 - 负责监听所有socket上的事件\n\n**领导者/追随者模式**\n略\n\n**高效编程方法 - 有限状态机**\n```c\n// 状态独立的有限状态机\nSTATE_MACHINE(Package _pack) {\n\t\n\tPackageType _type = _pack.GetType();\n\tswitch(_type) {\n\t\tcase type_A:\n\t\t\txxxx;\n\t\t\tbreak;\n\t\tcase type_B:\n\t\t\txxxx;\n\t\t\tbreak;\n\t}\n}\n\n// 带状态转移的有限状态机\nSTATE_MACHINE() {\n\tState cur_State = type_A;\n\twhile(cur_State != type_C) {\n\t\n\t\tPackage _pack = getNewPackage();\n\t\tswitch(cur_State) {\n\t\t\t\n\t\t\tcase type_A:\n\t\t\t\tprocess_package_state_A(_pack);\n\t\t\t\tcur_State = type_B;\n\t\t\t\tbreak;\n\t\t\tcase type_B:\n\t\t\t\txxxx;\n\t\t\t\tcur_State = type_C;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n花了小一个小时 终于一个字母一个字母的抄完了那个5000多字的代码\n@2019年9月8日22:08:46@\n\n### 提高服务器性能的其他建议 池 数据复制 上下文切换和锁\n\n**池** - 用空间换取时间\n进程池和线程池\n\n**数据复制** - 高性能的服务器应该尽量避免不必要的复制\n\n**上下文切换和锁**\n减少`锁`的作用区域. 不应该创建太多的工作进程, 而是使用专门的业务逻辑线程.\n\n","source":"_posts/读书记录100-高性能服务器编程读书记录初级部分.md","raw":"---\ntitle: Linux高性能服务器-初级部分\ntags:\n  - null\ncategories:\n  - 读书记录\ndate: 2019-08-17 20:34:39\n\ntop: 100\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg\n---\n开头选了这本书, 看到这本书是他人总结三大本后自己写的, 先求个理解大概.\n话说别人推荐的c++服务器咋都是c语言.....\n2019年8月17日20:37:53\n\n每学习一部分就写一个demo\n<!--more-->\n\n2020年7月16日12:43:41\n\n上面那个more标签让我想起了我第一个hexo博客的主题.\n大二暑假了, 距离这篇博客写下已经将近一年了. 时间过得真快, 唯一不变的就是自己依然的菜..\n也理解为什么C++服务器推荐的C语言\n\n这里将第五章后面的内容整理下.\n这算是我第一次写的博客吧, 之前写的时候写的过于详细和冗余了. 目前有了一点基础, 所以这次重新读是为了\n把博客和书读薄\n\n目前第五章后的博客有13000个汉字和44000个字母. 看看整理完毕后有多少吧\n\n## 第五章Linux网络编程基础API\n\n### 主机字节序和网络字节序\n\n字节序分为 `大端字节序`和`小端字节序`\n由于大多数PC采用小端字节序(高位存在高地址处), 所以小端字节序又称为主机字节序\n\n为了防止不同机器字节序不同导致的错乱问题. 规定传输的时候统一为 大端字节序(网络字节序).\n这样主机会根据自己的情况决定 - 是否转换接收到的数据的字节序\n\n\n**基础连接**\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93.jpg)\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88%E5%9C%B0%E5%9D%80%E6%97%8F.jpg)\n\n\n字节序转换\n```c++\n#include <netinet/in.h>\nunsigned long int htonl (unsigned long int hostlong); // host to network long\nunsigned short int htons (unsigned short int hostlong); // host to network short\n\nunsigned long int ntohl (unsigned long int netlong);\nunsigned short int ntohs (unsigned short int netlong);\n```\n\n点分十进制地址和网络地址转换\n程序需要使用网络地址 给人察看需要使用点分十进制 灵活转换\n```c++\n#include <arpa/inet.h>\n// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONE\nin_addr_t  inet_addr(const char* strptr);\n\n// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0\nint inet_aton(const char* cp, struct in_addr* inp);\n\n// 函数返回一个静态变量地址值, 所以多次调用会导致覆盖\nchar* inet_ntoa(struct in_addr in); \n\n// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族\n// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1\nint inet_pton(int af, const char * src, void* dst);\n// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)\nconst char* inet_ntop(int af, const void*  src, char* dst, socklen_t cnt);\n```\n\nsocket 三部曲\n```c++\n// 创建 命名 监听 socket\n# include <sys/socket.h>\n// domain指定使用那个协议族 PF_INET PF_INET6\n// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)\n// 有两个使用较多的选项SOCK_NONBLOCK 设置非阻塞\n// SOCK_CLOEXEC 使用fork创建子进程的时候在子进程中关闭该socket\n// protocol设置为默认的0\n// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1\nint socket(int domain, int type, int protocol);\n\n// socket为socket文件描述符\n// my_addr 为地址信息\n// addrlen为socket地址长度\n// 成功返回0 失败返回 -1\n// 这里细说还有个EADDRINUSE(被绑定的地址正在使用如TIME_WAIT状态)\n// 与之搭配的解决方式 是使用setsockopt设置SO_REUSEADDR为true\nint bind(int socket, const struct sockaddr* my_addr, socklen_t addrlen);\n\n// backlog表示队列最大的长度\nint listen(int socket, int backlog);\n```\n\n\n服务器\n```c++\n// 接受连接 失败返回-1 成功时返回socket\nint accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen)\n```\n\n\n客户端\n```c\n// 发起连接\n#include <sys/types.h>\n#include <sys/socket.h>\n// 第三个参数为 地址指定的长度\n// 成功返回0 失败返回-1\nint connect(int sockfd, const struct sockaddr * serv_addr, socklen_t addrlen);\n```\n\n连接关闭\n```c++\n// 关闭连接\n#include <unistd.h>\n// 参数为保存的socket\n// 并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才能关闭(需要查阅)\nint close(int fd);\n\n// 立即关闭\n#include <sys/socket.h>\n// 第二个参数为可选值 \n//\tSHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃\n//\tSHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去\n//\tSHUT_RDWR 同时关闭读和写\n// 成功返回0 失败为-1 设置errno\nint shutdown(int sockfd, int howto)\n// 1. close会将引用计数-1 等到为0时才关闭套接字. shutdown则可以无视此, 激发TCP的正常连接终止序列\n// 2. close会终止读和写两个方向的数据传送, 但由于TCP全双工有时需要告知对方我方发送已经完毕\n```\n\n\n基础TCP\n```c\n#include<sys/socket.h>\n#include<sys/types.h>\n\n// 读取sockfd的数据\n// buf 指定读缓冲区的位置\n// len 指定读缓冲区的大小\n// flags 参数较多\n// 成功的时候返回读取到的长度, 可能小于预期长度, 需要多次读取.   读取到0 通信对方已经关闭连接, 错误返回-1\nssize_t recv(int sockfd, void *buf, size_t len, int flags);\n// 发送\nssize_t send(int sockfd, const void *buf, size_t len, int flags);\n```\n\n| 选项名        | 含义                                                                                     | 可用于发送 | 可用于接收 |\n| ------------- | ---------------------------------------------------------------------------------------- | ---------- | ---------- |\n| MSG_CONFIRM   | 指示链路层协议持续监听, 直到得到答复.(仅能用于SOCK_DGRAM和SOCK_RAW类型的socket)          | Y          | N          |\n| MSG_DONTROUTE | 不查看路由表, 直接将数据发送给本地的局域网络的主机(代表发送者知道目标主机就在本地网络中) | Y          | N          |\n| MSG_DONTWAIT  | 非阻塞                                                                                   | Y          | Y          |\n| MSG_MORE      | 告知内核有更多的数据要发送, 等到数据写入缓冲区完毕后,一并发送.减少短小的报文提高传输效率 | Y          | N          |\n| MSG_WAITALL   | 读操作一直等待到读取到指定字节后才会返回                                                 | N          | Y          |\n| MSG_PEEK      | 看一下内缓存数据, 并不会影响数据                                                         | N          | Y          |\n| MSG_OOB       | 发送或接收紧急数据                                                                       | Y          | Y          |\n| MSG_NOSIGNAL  | 向读关闭的管道或者socket连接中写入数据不会触发SIGPIPE信号                                | Y          | N          |\n\n基础UDP\n```c\n#include <sys/types.h>\n#include <sys/socket.h>\n// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.\n// 不过recvfrom和sendto 也可以用于 面向STREAM的连接, 这样可以省略发送和接收端的socket地址\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen);\nssize_t sendto(int sockfd, const void* buf, size_t len, ing flags, const struct sockaddr* dest_addr, socklen_t addrlen);\n```\n\n通用读写函数\n```c\n#inclued <sys/socket.h>\nssize_t recvmsg(int sockfd, struct msghdr* msg, int flags);\nssize_t sendmsg(int sockfd, struct msghdr* msg, int flags);\n\nstruct msghdr\n{\n/* socket address --- 指向socket地址结构变量, 对于TCP连接需要设置为NULL*/\n\tvoid* msg_name; \n\n\n\tsocklen_t msg_namelen;\n\t\n\t/* 分散的内存块 --- 对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由\n     * msg_iov指向的数组指定, 称为分散读(scatter read)  ---对于sendmsg而言, msg_iovlen块的分散内存中\n     * 的数据将一并发送称为集中写(gather write);\n\t*/\n\tstruct iovec* msg_iov;\n\tint msg_iovlen; /* 分散内存块的数量*/\n\tvoid* msg_control; /* 指向辅助数据的起始位置*/\n\tsocklen_t msg_controllen; /* 辅助数据的大小*/\n\tint msg_flags; /* 复制函数的flags参数, 并在调用过程中更新*/\n};\n\nstruct iovec\n{\n\tvoid* iov_base /* 内存起始地址*/\n\tsize_t iov_len /* 这块内存长度*/\n}\n```\n\n其他Api\n```c\n#include <sys/socket.h>\n// 用于判断 sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据, \n// 是的话返回1, 不是返回0\n// 这样就可以选择带MSG_OOB标志的recv调用来接收带外数据. \nint sockatmark(int sockfd);\n\n// getsockname 获取sockfd对应的本端socket地址, 存入address指定的内存中, 长度存入address_len中 成功返回0失败返回-1\n// getpeername 获取远端的信息, 同上\nint getsockname(int sockfd, struct sockaddr* address, socklen_t* address_len);\nint getpeername(int sockfd, struct sockaddr* address, socklen_t* address_len);\n```\n\n重要 socket属性设置\n```c++\n/* 以下函数头文件均相同*/\n\n// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度\n// 成功时返回0 失败返回-1\nint getsockopt(int sockfd, int level, int option_name, void* option_value, \n\t\t\t\t\t\tsocklen_t restrict option_len);\nint setsockopt(int sockfd, int level, int option_name, void* option_value, \n\t\t\t\t\t\tsocklen_t restrict option_len);\n```\n\n```c\nstruct linger\n{\n\tint l_onoff /* 开启非0, 关闭为0*/\n\tint l_linger; /* 滞留时间*/\n\t/*\n\t* 当onoff为0的时候此项不起作用, close调用默认行为关闭socket\n\t* 当onoff不为0 且linger为0, close将立即返回, TCP将丢弃发送缓冲区的残留数据, 同时发送一个复位报文段\n\t* 当onoff不为0 且linger大于0 . 当socket阻塞的时候close将会等待TCP模块发送完残留数据并得到确认后关 \n\t* 闭, 如果是处于非阻塞则立即关闭\n\t*/\n};\n```\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/socket%E9%80%89%E9%A1%B9.jpg)\n\n\n**网络信息API**\n```c\n#include <netdb.h>\n// 通过主机名查找ip\nstruct hostent* gethostbyname(const char* name);\n\n// 通过ip获取主机完整信息 \n// type为IP地址类型 AF_INET和AF_INET6\nstruct hostent* gethostbyaddr(const void* addr, size_t len, int type);\n\nstruct hostent\n{\n  char *h_name;\t\t\t/* Official name of host.  */\n  char **h_aliases;\t\t/* Alias list.  */\n  int h_addrtype;\t\t/* Host address type.  */\n  int h_length;\t\t\t/* Length of address.  */\n  char **h_addr_list;\t\t/* List of addresses from name server.  */\n}\n\nint main(int argc, char* argv[])\n{\n    if (argc != 2)\n    {\n        printf(\"非法输入\\n\");\n        exit(0);\n    }\n    char* name = argv[1];\n\n    struct hostent *hostptr{};\n\n    hostptr = gethostbyname(name);\n    if (hostptr == nullptr)\n    {\n        printf(\"输入存在错误 或无法获取\\n\");\n        exit(0);\n    }\n\n    printf(\"Official name of hostptr: %s\\n\", hostptr->h_name);\n\n    char **pptr;\n    char inet_addr[INET_ADDRSTRLEN];\n\n    printf(\"Alias list:\\n\");\n    for (pptr = hostptr->h_aliases; *pptr != nullptr; ++pptr)\n    {\n        printf(\"\\t%s\\n\", *pptr);\n    }\n\n    switch (hostptr->h_addrtype)\n    {\n        case AF_INET:\n        {\n            printf(\"List of addresses from name server:\\n\");\n            for (pptr = hostptr->h_addr_list; *pptr != nullptr; ++pptr)\n            {\n                printf(\"\\t%s\\n\",\n                        inet_ntop(hostptr->h_addrtype, *pptr, inet_addr, sizeof(inet_addr)));\n            }\n            break;\n        }\n        default:\n        {\n            printf(\"unknow address type\\n\");\n            exit(0);\n        }\n    }\n    return 0;\n}\n\n/*\n./run baidu.com\nOfficial name of hostptr: baidu.com\nAlias list:\nList of addresses from name server:\n\t39.156.69.79\n\t220.181.38.148\n*/\n```\n以下两个函数通过读取/etc/services文件 来获取服务信息 以下内容来自维基百科\n\nService文件是现代操作系统在etc目录下的一个配置文件，记录网络服务名对应的端口号与协议 其用途如下\n- 通过TCP/IP的API函数（声明在netdb.h中）直接查到网络服务名与端口号、使用协议的对应关系。如getservbyname(\"serve\",\"tcp\")获取端口号;getservbyport（htons（port），“tcp”）获取端口和协议上的服务名\n- 如果用户在这个文件中维护所有使用的网络服务名字、端口、协议，那么可以一目了然的获悉哪些端口号用于哪个服务，哪些端口号是空闲的\n```c\n#include <netdb.h>\n// 根据名称获取某个服务的完整信息\nstruct servent getservbyname(const char* name, const char* proto);\n\n// 根据端口号获取服务信息\nstruct servent getservbyport(int port, const char* proto);\n\nstruct servent\n{\n\tchar* s_name; /* 服务名称*/\n\tchar ** s_aliases; /* 服务的别名列表*/\n\tint s_port; /* 端口号*/\n\tchar* s_proto; /* 服务类型, 通常为TCP或UDP*/\n}\n```\n```c\n#include <netdb.h>\n// 内部使用的gethostbyname 和 getserverbyname\n// hostname 用于接收主机名, 也可以用来接收字符串表示的IP地址(点分十进制, 十六进制字符串)\n// service 用于接收服务名, 字符串表示的十进制端口号\n// hints参数 对getaddrinfo的输出进行更准确的控制, 可以设置为NULL, 允许反馈各种有用的结果\n// result 指向一个链表, 用于存储getaddrinfo的反馈结果\nint getaddrinfo(const char* hostname, const char* service, const struct addrinfo* hints, struct addrinfo** result)\n\nstruct addrinfo\n{\n\tint ai_flags;\n\tint ai_family;\n\tint ai_socktype; /* 服务类型, SOCK_STREAM或者SOCK_DGRAM*/\n\tint ai_protocol;\n\tsocklen_t ai_addrlen;\n\tchar* ai_canonname; /* 主机的别名*/\n\tstruct sockaddr* ai_addr; /* 指向socket地址*/\n\tstruct addrinfo* ai_next; /* 指向下一个结构体*/\n}\n\n// 需要手动的释放堆内存\nvoid freeaddrinfo(struct addrinfo* res);\n```\n![](https://ftp.bmp.ovh/imgs/2019/08/7ebedb14d8eedeac.png)\n\n```c\n#include <netdb.h>\n// host 存储返回的主机名\n// serv存储返回的服务名\n\nint getnameinfo(const struct sockaddr* sockaddr, socklen_t addrlen, char* host, socklen_t hostlen, char* serv\n\tsocklen_t servlen, int flags);\n\n```\n![](https://ftp.bmp.ovh/imgs/2019/08/bc7196e9a30d5152.png)\n\n测试\n使用\n```shell\ntelnet ip port #来连接服务器的此端口\nnetstat -nt | grep port #来查看此端口的监听\n```\n\n## 第六章高级IO函数\n\nLinux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件自然限制了他的使用频率\n*文件描述符*\n文件描述符在是一个非负整数。是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表。\nSTDOUT_FILENO(值为1)- 值为1的文件描述符为标准输出, 关闭STDOUT_FILENO后用dup即可返回最小可用值(目前为, 1) 这样输出就重定向到了调用dup的参数指向的文件\n\n### 创建文件描述符 - pipe dup dup2 splice\n**pipe函数**\n这个函数可用于创建一个管道, 实现进程间的通信. \n\n```c\n// 函数定义\n// 参数文件描述符数组 fd[0] 读出 fd[1]写入 单向管道\n// 成功返回0, 并将一对打开的文件描述符填入其参数指向的数组\n// 失败返回-1 errno\n#include <unistd.h>\nint pipe(int fd[2]);\n```\n```c\n// 双向管道\n// 第一个参数为 协议PF_UNIX(书上是AF_UNIX)感觉这里指明协议使用PF更好一些\n#include <sys/types.h>\n#include <sys/socket.h>\nint socketpair(int domain, int type, int protocol, int fd[2]);\n```\n学习了后面的内容了解到了进程间通信, 回来补上一个例子\n```c\nint main()\n{\n    int fds[2];\n    socketpair(PF_UNIX, SOCK_STREAM, 0, fds);\n    int pid = fork();\n    if (pid == 0)\n    {\n        close(fds[0]);\n        char a[] = \"123\";\n        send(fds[1], a, strlen(a), 0);\n    }\n    else if (pid > 0)\n    {\n        close(fds[1]);\n        char b[20] {};\n        recv(fds[0], b, 20, 0);\n        printf(\"%s\", b);\n    }\n}\n```\n**dup和dup2函数**\n复制一个现有的文件描述符\n```c\n#include <unistd.h>\n// 返回的文件描述符总是取系统当前可用的最小整数值\nint dup(int oldfd);\n// 可以用newfd来制定新的文件描述符, 如果newfd已经被打开则先关闭\n// 如果newfd==oldfd 则不关闭newfd直接返回\nint dup2(int oldfd, int newfd);\n```\ndup函数创建一个新的文件描述符, 新的文件描述符和原有的file_descriptor共同指向相同的目标.\n回来补上例子, 这个例子由于关掉了`STDOUT_FILENO`dup最小的即为`STDOUT_FILENO`所以\n标准输出都到了这个文件之中\n```c\nint main()\n{\n    int filefd = open(\"/home/lsmg/1.txt\", O_WRONLY);\n    close(STDOUT_FILENO);\n    dup(filefd);\n    printf(\"123\\n\");\n    exit(0);\n}\n```\n\n### 读写数据 - readv writev mmap munmap\n**readv/writev**\n```c\n#include <sys/uio.h>\n// count 为 vector的长度, 即为有多少块内存\n// 成功时返回写入\\读取的长度 失败返回-1\nssize_t readv(int fd, const struct iovec* vector, int count);\nssize_t writev(int fd, const struct iovec* vector, int count);\n\nstruct iovec {\n\tvoid* iov_base /* 内存起始地址*/\n\tsize_t iov_len /* 这块内存长度*/\n}\n```\n回来补上一个使用例子, 这个例子将一个int的内存表示写入到了文件之中\n使用hexdump查看这个文件`0000000 86a0 0001`可以看到`186a0`即为100000\n```c\n// 2020年1月7日16:52:11\nint main()\n{\n    int file = open(\"/home/lsmg/1.txt\", O_WRONLY);\n    int temp = 100000;\n    iovec temp_iovec{};\n    temp_iovec.iov_base = &temp;\n    temp_iovec.iov_len = sizeof(temp);\n    writev(file, &temp_iovec, 1);\n}\n```\nsendfile函数\n```c\n#include <sys/sendfile.h>\n// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取\nssize_t sendfile(int out_fd, int in_fd, off_t* offset, size_t count);\n\nO_RDONLY只读模式\nO_WRONLY只写模式\nO_RDWR读写模式\nint open(file_name, flag);\n```\nstat结构体, 可用fstat生成, **简直就是文件的身份证**\n```c\n#include <sys/stat.h>\nstruct stat\n{\n    dev_t       st_dev;     /* ID of device containing file -文件所在设备的ID*/\n    ino_t       st_ino;     /* inode number -inode节点号*/\n    mode_t      st_mode;    /* protection -保护模式?*/\n    nlink_t     st_nlink;   /* number of hard links -链向此文件的连接数(硬连接)*/\n    uid_t       st_uid;     /* user ID of owner -user id*/\n    gid_t       st_gid;     /* group ID of owner - group id*/\n    dev_t       st_rdev;    /* device ID (if special file) -设备号，针对设备文件*/\n    off_t       st_size;    /* total size, in bytes -文件大小，字节为单位*/\n    blksize_t   st_blksize; /* blocksize for filesystem I/O -系统块的大小*/\n    blkcnt_t    st_blocks;  /* number of blocks allocated -文件所占块数*/\n    time_t      st_atime;   /* time of last access -最近存取时间*/\n    time_t      st_mtime;   /* time of last modification -最近修改时间*/\n    time_t      st_ctime;   /* time of last status change - */\n};\n```\n**身份证**生成函数\n```c\n// 第一个参数需要调用open生成文件描述符\n// 下面其他两个为文件全路径\nint fstat(int filedes, struct stat *buf);\n\n// 当路径指向为符号链接的时候, lstat为符号链接的信息. stat为符号链接指向文件信息\nint stat(const char *path, struct stat *buf);\nint lstat(const char *path, struct stat *buf);\n\n/*\n* ln -s source dist  建立软连接, 类似快捷方式, 也叫符号链接\n* ln source dist  建立硬链接, 同一个文件使用多个不同的别名, 指向同一个文件数据块, 只要硬链接不被完全\n* 删除就可以正常访问\n* 文件数据块 - 文件的真正数据是一个文件数据块, 打开的`文件`指向这个数据块, 就是说\n* `文件`本身就类似快捷方式, 指向文件存在的区域.\n*/\n```\n **mmap和munmap函数**\n\n`mmap`创建一块进程通讯共享的内存(可以将文件映射入其中), `munmap`释放这块内存\n```c\n#include <sys/mman.h>\n\n// start 内存起始位置, 如果为NULL则系统分配一个地址 length为长度\n// port参数 PROT_READ(可读) PROT_WRITE(可写) PROT_EXEC(可执行), PROT_NONE(不可访问)\n// flag参数 内存被修改后的行为\n// - MAP_SHARED 进程间共享内存, 对内存的修改反映到映射文件中\n// - MAP_PRIVATE 为调用进程私有, 对该内存段的修改不会反映到文件中\n// - MAP_ANONUMOUS 不是从文件映射而来, 内容被初始化为0, 最后两个参数被忽略\n// 成功返回区域指针, 失败返回 -1\nvoid* mmap(void* start, size_t length, int port, int flags, int fd, off_t offset);\n// 成功返回0 失败返回-1\nint munmap(void* start, size_t length);\n```\n**splice函数**\n用于在两个文件名描述符之间移动数据, 0拷贝操作\n```c\n#include <fcntl.h>\n// fd_in 为文件描述符, 如果为管道文件描述符则 off_in必须为NULL, 否则为读取开始偏移位置\n// len为指定移动的数据长度, flags参数控制数据如何移动.\n// - SPLICE_F_NONBLOCK 非阻塞splice操作, 但会受文件描述符自身的阻塞\n// - SPLICE_F_MORE 给内核一个提示, 后续的splice调用将读取更多的数据???????\nssize_t splice(int fd_in, loff_t* off_in, int fd_out, loff_t* off_out, size_t len, unsigned int flags);\n\n// 使用splice函数  实现echo服务器\nint main(int argc, char* argv[])\n{\n    if (argc <= 2)\n    {\n        printf(\"the parmerters is wrong\\n\");\n        exit(errno);\n    }\n    char *ip = argv[1];\n\n    int port = atoi(argv[2]);\n    printf(\"the port is %d the ip is %s\\n\", port, ip);\n\n    int sockfd = socket(PF_INET, SOCK_STREAM, 0);\n    assert(sockfd >= 0);\n\n    struct sockaddr_in address{};\n    address.sin_family = AF_INET;\n    address.sin_port = htons(port);\n    inet_pton(AF_INET, ip, &address.sin_addr);\n\n    int ret = bind(sockfd, (sockaddr*)&address, sizeof(address));\n    assert(ret != -1);\n\n    ret = listen(sockfd, 5);\n\n    int clientfd{};\n    sockaddr_in client_address{};\n    socklen_t client_addrlen = sizeof(client_address);\n\n    clientfd = accept(sockfd, (sockaddr*)&client_address, &client_addrlen);\n    if (clientfd < 0)\n    {\n        printf(\"accept error\\n\");\n    }\n    else\n    {\n        printf(\"a new connection from %s:%d success\\n\", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));\n        int fds[2];\n        pipe(fds);\n        ret = splice(clientfd, nullptr, fds[1], nullptr, 32768, SPLICE_F_MORE);\n        assert(ret != -1);\n\n        ret = splice(fds[0], nullptr, clientfd, nullptr, 32768, SPLICE_F_MORE);\n        assert(ret != -1);\n\n        close(clientfd);\n    }\n    close(sockfd);\n    exit(0);\n}\n```\n\n## 第七章Linux服务器程序规范\n\n- Linux程序服务器 一般以后台进程形式运行.  后台进程又称为守护进程(daemon). 他没有控制终端, 因而不会意外的接收到用户输入. 守护进程的父进程通常都是init进程(PID为1的进程)\n- Linux服务器程序有一套日志系统, 他至少能输出日志到文件. 日志这东西太重要了,排错对比全靠它.\n- Linux服务器程序一般以某个专门的非root身份运行. 比如mysqld有自己的账户mysql.\n- Linux服务器程序一般都有自己的配置文件, 而不是把所有配置都写死在代码里面, 方便后续的更改.\n- Linux服务器程序通常在启动的时候生成一个PID文件并存入/var/run 目录中, 以记录改后台进程的PID.\n- Linux服务器程序通常需要考虑系统资源和限制, 预测自己的承受能力\n\n### 日志\n\n```shell\nsudo service rsyslog restart // 启动守护进程\n```\n```c\n#include <syslog.h>\n// priority参数是所谓的设施值(记录日志信息来源, 默认为LOG_USER)与日志级别的按位或\n// - 0 LOG_EMERG  /* 系统不可用*/\n// - 1 LOG_ALERT   /* 报警需要立即采取行动*/\n// - 2 LOG_CRIT /* 非常严重的情况*/\n// - 3 LOG_ERR  /* 错误*/\n// - 4 LOG_WARNING /* 警告*/\n// - 5 LOG_NOTICE /* 通知*/\n// - 6 LOG_INFO /* 信息*/\n//  -7 LOG_DEBUG /* 调试*/\nvoid syslog(int priority, const char* message, .....);\n\n// ident 位于日志的时间后 通常为名字\n// logopt 对后续 syslog调用的行为进行配置\n// -  0x01 LOG_PID  /* 在日志信息中包含程序PID*/\n// -  0x02 LOG_CONS /* 如果信息不能记录到日志文件, 则打印到终端*/\n// -  0x04 LOG_ODELAY /* 延迟打开日志功能直到第一次调用syslog*/\n// -  0x08 LOG_NDELAY /* 不延迟打开日志功能*/\n// facility参数可以修改syslog函数中的默认设施值\nvoid openlog(const char* ident, int logopt, int facility);\n\n// maskpri 一共八位 0000-0000\n// 如果将最后一个0置为1 表示 记录0级别的日志\n// 如果将最后两个0都置为1 表示记录0和1级别的日志\n// 可以通过LOG_MASK() 宏设定 比如LOG_MASK(LOG_CRIT) 表示将倒数第三个0置为1, 表示只记录LOG_CRIT\n// 如果直接设置setlogmask(3); 3的二进制最后两个数均为1 则记录 0和1级别的日志\nint setlogmask(int maskpri);\n\n// 关闭日志功能\nvoid closelog();\n```\n\n### 用户信息, 切换用户\nUID - 真实用户ID\nEUID - 有效用户ID - 方便资源访问\nGID - 真实组ID\nEGID - 有效组ID\n```c\n#include <sys/types.h>\n#include <unistd.h>\n\nuid_t getuid();\nuid_t geteuid();\ngid_t getgid();\ngid_t getegid();\nint setuid(uid_t uid);\nint seteuid(uid_t euid);\nint setgid(gid_t gid);\nint setegid(gid_t gid);\n```\n\n可以通过 `setuid`和`setgid`切换用户 **root用户uid和gid均为0**\n\n### 进程间关系\nPGID - 进程组ID(Linux下每个进程隶属于一个进程组)\n\n#include <unistd.h>\npid_t getpgid(pid_t pid); 成功时返回pid所属的pgid 失败返回-1\nint setpgid(pid_t pid, pid_t pgid);\n\n**会话**\n一些有关联的进程组将形成一个会话\n略过\n\n**查看进程关系**\nps和less\n\n**资源限制**\n略\n**改变目录**\n略\n\n## 第八章高性能服务器程序框架\n\n**服务器模型-CS模型**\n\n**优点**\n- 实现起来简单\n**缺点**\n- 服务器是通信的中心, 访问过大的时候会导致响应过慢\n\n模式图\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%BE8-2%20TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)\n\n编写的demo 没有用到fork函数. 后续待完善\n\n**服务器框架 IO模型**\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png)\n\n这个模型大概能够理解, 自己也算是学了半年的Javaweb.\n\nsocket在创建的时候默认是阻塞的, 不过可以通过传`SOCK_NONBLOCK`参解决\n非阻塞调用都会立即返回 但可能事件没有发生(recv没有接收到信息), 没有发生和出错都会`返回-1` 所以需要通过`errno`来区分这些错误.\n**事件未发生**\naccept, send,recv errno被设置为 `EAGAIN(再来一次)`或`EWOULDBLOCK(期望阻塞)`\nconnect 被设置为 `EINPROGRESS(正在处理中)`\n\n需要在事件已经发生的情况下 去调用非阻塞IO, 才能提高性能\n\n常用IO复用函数 `select` `poll` `epoll_wait` 将在第九章后面说明\n信号将在第十章说明\n\n**两种高效的事件处理模式和并发模式**\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Reactor%E6%A8%A1%E5%BC%8F.png)\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Proactor%E6%A8%A1%E5%BC%8F.png)\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E7%94%A8%E5%90%8C%E6%AD%A5IO%E6%A8%A1%E6%8B%9F%E5%87%BA%E7%9A%84Proactor%E6%A8%A1%E5%BC%8F.png)\n\n程序分为计算密集型(CPU使用很多, IO资源使用很少)和IO密集型(反过来).\n前者使用并发编程反而会降低效率, 后者则会提升效率\n并发编程有多进程和多线程两种方式\n\n并发模式 - IO单元和多个逻辑单元之间协调完成任务的方法.\n服务器主要有两种并发模式\n- 半同步/半异步模式\n- 领导者/追随者模式\n\n**半同步/半异步模式**\n在IO模型中, 异步和同步的区分是内核向应用程序通知的是何种IO事件(就绪事件还是完成事件), 以及由谁来完成IO读写(应用程序还是内核)\n\n而在这里(并发模式) \n同步指的是完全按照代码序列的顺序执行 - 按照同步方式运行的线程称为同步线程\n异步需要系统事件(中断, 信号)来驱动 - 按照异步方式运行的线程称为异步线程\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5.png)\n\n服务器(需要较好的实时性且能同时处理多个客户请求) - 一般使用同步线程和异步线程来实现,即为半同步/半异步模式\n同步线程 - 处理客户逻辑, 处理请求队列中的对象\n异步线程 - 处理IO事件, 接收到客户请求后将其封装成请求对象并插入请求队列\n\n半同步/半异步模式 存在变体 `半同步/半反应堆模式`\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F.png)\n\n异步线程 - 主线程 - 负责监听所有socket上的事件\n\n**领导者/追随者模式**\n略\n\n**高效编程方法 - 有限状态机**\n```c\n// 状态独立的有限状态机\nSTATE_MACHINE(Package _pack) {\n\t\n\tPackageType _type = _pack.GetType();\n\tswitch(_type) {\n\t\tcase type_A:\n\t\t\txxxx;\n\t\t\tbreak;\n\t\tcase type_B:\n\t\t\txxxx;\n\t\t\tbreak;\n\t}\n}\n\n// 带状态转移的有限状态机\nSTATE_MACHINE() {\n\tState cur_State = type_A;\n\twhile(cur_State != type_C) {\n\t\n\t\tPackage _pack = getNewPackage();\n\t\tswitch(cur_State) {\n\t\t\t\n\t\t\tcase type_A:\n\t\t\t\tprocess_package_state_A(_pack);\n\t\t\t\tcur_State = type_B;\n\t\t\t\tbreak;\n\t\t\tcase type_B:\n\t\t\t\txxxx;\n\t\t\t\tcur_State = type_C;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n花了小一个小时 终于一个字母一个字母的抄完了那个5000多字的代码\n@2019年9月8日22:08:46@\n\n### 提高服务器性能的其他建议 池 数据复制 上下文切换和锁\n\n**池** - 用空间换取时间\n进程池和线程池\n\n**数据复制** - 高性能的服务器应该尽量避免不必要的复制\n\n**上下文切换和锁**\n减少`锁`的作用区域. 不应该创建太多的工作进程, 而是使用专门的业务逻辑线程.\n\n","slug":"读书记录100-高性能服务器编程读书记录初级部分","published":1,"updated":"2020-12-05T02:31:35.592Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg73003ef8unc9wvfxsv","content":"<p>开头选了这本书, 看到这本书是他人总结三大本后自己写的, 先求个理解大概.<br>话说别人推荐的c++服务器咋都是c语言…..<br>2019年8月17日20:37:53</p>\n<p>每学习一部分就写一个demo</p>\n<a id=\"more\"></a>\n\n<p>2020年7月16日12:43:41</p>\n<p>上面那个more标签让我想起了我第一个hexo博客的主题.<br>大二暑假了, 距离这篇博客写下已经将近一年了. 时间过得真快, 唯一不变的就是自己依然的菜..<br>也理解为什么C++服务器推荐的C语言</p>\n<p>这里将第五章后面的内容整理下.<br>这算是我第一次写的博客吧, 之前写的时候写的过于详细和冗余了. 目前有了一点基础, 所以这次重新读是为了<br>把博客和书读薄</p>\n<p>目前第五章后的博客有13000个汉字和44000个字母. 看看整理完毕后有多少吧</p>\n<h2 id=\"第五章Linux网络编程基础API\"><a href=\"#第五章Linux网络编程基础API\" class=\"headerlink\" title=\"第五章Linux网络编程基础API\"></a>第五章Linux网络编程基础API</h2><h3 id=\"主机字节序和网络字节序\"><a href=\"#主机字节序和网络字节序\" class=\"headerlink\" title=\"主机字节序和网络字节序\"></a>主机字节序和网络字节序</h3><p>字节序分为 <code>大端字节序</code>和<code>小端字节序</code><br>由于大多数PC采用小端字节序(高位存在高地址处), 所以小端字节序又称为主机字节序</p>\n<p>为了防止不同机器字节序不同导致的错乱问题. 规定传输的时候统一为 大端字节序(网络字节序).<br>这样主机会根据自己的情况决定 - 是否转换接收到的数据的字节序</p>\n<p><strong>基础连接</strong><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93.jpg\" alt=\"\"><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88%E5%9C%B0%E5%9D%80%E6%97%8F.jpg\" alt=\"\"></p>\n<p>字节序转换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> <span class=\"title\">htonl</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> hostlong)</span></span>; <span class=\"comment\">// host to network long</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> <span class=\"title\">htons</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> hostlong)</span></span>; <span class=\"comment\">// host to network short</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> <span class=\"title\">ntohl</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> netlong)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> <span class=\"title\">ntohs</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> netlong)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>点分十进制地址和网络地址转换<br>程序需要使用网络地址 给人察看需要使用点分十进制 灵活转换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONE</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">in_addr_t</span>  <span class=\"title\">inet_addr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* strptr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inet_aton</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* cp, struct in_addr* inp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数返回一个静态变量地址值, 所以多次调用会导致覆盖</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">inet_ntoa</span><span class=\"params\">(struct in_addr in)</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族</span></span><br><span class=\"line\"><span class=\"comment\">// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inet_pton</span><span class=\"params\">(<span class=\"keyword\">int</span> af, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * src, <span class=\"keyword\">void</span>* dst)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">inet_ntop</span><span class=\"params\">(<span class=\"keyword\">int</span> af, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>*  src, <span class=\"keyword\">char</span>* dst, <span class=\"keyword\">socklen_t</span> cnt)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>socket 三部曲</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 命名 监听 socket</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// domain指定使用那个协议族 PF_INET PF_INET6</span></span><br><span class=\"line\"><span class=\"comment\">// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)</span></span><br><span class=\"line\"><span class=\"comment\">// 有两个使用较多的选项SOCK_NONBLOCK 设置非阻塞</span></span><br><span class=\"line\"><span class=\"comment\">// SOCK_CLOEXEC 使用fork创建子进程的时候在子进程中关闭该socket</span></span><br><span class=\"line\"><span class=\"comment\">// protocol设置为默认的0</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// socket为socket文件描述符</span></span><br><span class=\"line\"><span class=\"comment\">// my_addr 为地址信息</span></span><br><span class=\"line\"><span class=\"comment\">// addrlen为socket地址长度</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回 -1</span></span><br><span class=\"line\"><span class=\"comment\">// 这里细说还有个EADDRINUSE(被绑定的地址正在使用如TIME_WAIT状态)</span></span><br><span class=\"line\"><span class=\"comment\">// 与之搭配的解决方式 是使用setsockopt设置SO_REUSEADDR为true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">int</span> socket, <span class=\"keyword\">const</span> struct sockaddr* my_addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// backlog表示队列最大的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"keyword\">int</span> socket, <span class=\"keyword\">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>服务器</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接受连接 失败返回-1 成功时返回socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">accept</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr* addr, <span class=\"keyword\">socklen_t</span>* addrlen)</span></span></span><br></pre></td></tr></table></figure>\n\n\n<p>客户端</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发起连接</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 第三个参数为 地址指定的长度</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> struct sockaddr * serv_addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>连接关闭</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 参数为保存的socket</span></span><br><span class=\"line\"><span class=\"comment\">// 并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才能关闭(需要查阅)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">close</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 立即关闭</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数为可选值 </span></span><br><span class=\"line\"><span class=\"comment\">//\tSHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃</span></span><br><span class=\"line\"><span class=\"comment\">//\tSHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去</span></span><br><span class=\"line\"><span class=\"comment\">//\tSHUT_RDWR 同时关闭读和写</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败为-1 设置errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shutdown</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> howto)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 1. close会将引用计数-1 等到为0时才关闭套接字. shutdown则可以无视此, 激发TCP的正常连接终止序列</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 2. close会终止读和写两个方向的数据传送, 但由于TCP全双工有时需要告知对方我方发送已经完毕</span></span></span><br></pre></td></tr></table></figure>\n\n\n<p>基础TCP</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取sockfd的数据</span></span><br><span class=\"line\"><span class=\"comment\">// buf 指定读缓冲区的位置</span></span><br><span class=\"line\"><span class=\"comment\">// len 指定读缓冲区的大小</span></span><br><span class=\"line\"><span class=\"comment\">// flags 参数较多</span></span><br><span class=\"line\"><span class=\"comment\">// 成功的时候返回读取到的长度, 可能小于预期长度, 需要多次读取.   读取到0 通信对方已经关闭连接, 错误返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">recv</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 发送</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>选项名</th>\n<th>含义</th>\n<th>可用于发送</th>\n<th>可用于接收</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MSG_CONFIRM</td>\n<td>指示链路层协议持续监听, 直到得到答复.(仅能用于SOCK_DGRAM和SOCK_RAW类型的socket)</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>MSG_DONTROUTE</td>\n<td>不查看路由表, 直接将数据发送给本地的局域网络的主机(代表发送者知道目标主机就在本地网络中)</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>MSG_DONTWAIT</td>\n<td>非阻塞</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_MORE</td>\n<td>告知内核有更多的数据要发送, 等到数据写入缓冲区完毕后,一并发送.减少短小的报文提高传输效率</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>MSG_WAITALL</td>\n<td>读操作一直等待到读取到指定字节后才会返回</td>\n<td>N</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_PEEK</td>\n<td>看一下内缓存数据, 并不会影响数据</td>\n<td>N</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_OOB</td>\n<td>发送或接收紧急数据</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_NOSIGNAL</td>\n<td>向读关闭的管道或者socket连接中写入数据不会触发SIGPIPE信号</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n</tbody></table>\n<p>基础UDP</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.</span></span><br><span class=\"line\"><span class=\"comment\">// 不过recvfrom和sendto 也可以用于 面向STREAM的连接, 这样可以省略发送和接收端的socket地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">recvfrom</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> flags, struct sockaddr* src_addr, <span class=\"keyword\">socklen_t</span>* addrlen)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">sendto</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* buf, <span class=\"keyword\">size_t</span> len, ing flags, <span class=\"keyword\">const</span> struct sockaddr* dest_addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>通用读写函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#inclued <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">recvmsg</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct msghdr* msg, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">sendmsg</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct msghdr* msg, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msghdr</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">/* socket address --- 指向socket地址结构变量, 对于TCP连接需要设置为NULL*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* msg_name; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">socklen_t</span> msg_namelen;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/* 分散的内存块 --- 对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由</span></span><br><span class=\"line\"><span class=\"comment\">     * msg_iov指向的数组指定, 称为分散读(scatter read)  ---对于sendmsg而言, msg_iovlen块的分散内存中</span></span><br><span class=\"line\"><span class=\"comment\">     * 的数据将一并发送称为集中写(gather write);</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span>* <span class=\"title\">msg_iov</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> msg_iovlen; <span class=\"comment\">/* 分散内存块的数量*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* msg_control; <span class=\"comment\">/* 指向辅助数据的起始位置*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">socklen_t</span> msg_controllen; <span class=\"comment\">/* 辅助数据的大小*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> msg_flags; <span class=\"comment\">/* 复制函数的flags参数, 并在调用过程中更新*/</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* iov_base <span class=\"comment\">/* 内存起始地址*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> iov_len <span class=\"comment\">/* 这块内存长度*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他Api</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 用于判断 sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据, </span></span><br><span class=\"line\"><span class=\"comment\">// 是的话返回1, 不是返回0</span></span><br><span class=\"line\"><span class=\"comment\">// 这样就可以选择带MSG_OOB标志的recv调用来接收带外数据. </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sockatmark</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// getsockname 获取sockfd对应的本端socket地址, 存入address指定的内存中, 长度存入address_len中 成功返回0失败返回-1</span></span><br><span class=\"line\"><span class=\"comment\">// getpeername 获取远端的信息, 同上</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getsockname</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr* address, <span class=\"keyword\">socklen_t</span>* address_len)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getpeername</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr* address, <span class=\"keyword\">socklen_t</span>* address_len)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>重要 socket属性设置</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 以下函数头文件均相同*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度</span></span><br><span class=\"line\"><span class=\"comment\">// 成功时返回0 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> option_name, <span class=\"keyword\">void</span>* option_value, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t<span class=\"keyword\">socklen_t</span> <span class=\"keyword\">restrict</span> option_len)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> option_name, <span class=\"keyword\">void</span>* option_value, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t<span class=\"keyword\">socklen_t</span> <span class=\"keyword\">restrict</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">linger</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l_onoff <span class=\"comment\">/* 开启非0, 关闭为0*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l_linger; <span class=\"comment\">/* 滞留时间*/</span></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t* 当onoff为0的时候此项不起作用, close调用默认行为关闭socket</span></span><br><span class=\"line\"><span class=\"comment\">\t* 当onoff不为0 且linger为0, close将立即返回, TCP将丢弃发送缓冲区的残留数据, 同时发送一个复位报文段</span></span><br><span class=\"line\"><span class=\"comment\">\t* 当onoff不为0 且linger大于0 . 当socket阻塞的时候close将会等待TCP模块发送完残留数据并得到确认后关 </span></span><br><span class=\"line\"><span class=\"comment\">\t* 闭, 如果是处于非阻塞则立即关闭</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/socket%E9%80%89%E9%A1%B9.jpg\" alt=\"\"></p>\n<p><strong>网络信息API</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 通过主机名查找ip</span></span><br><span class=\"line\"><span class=\"function\">struct hostent* <span class=\"title\">gethostbyname</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过ip获取主机完整信息 </span></span><br><span class=\"line\"><span class=\"comment\">// type为IP地址类型 AF_INET和AF_INET6</span></span><br><span class=\"line\"><span class=\"function\">struct hostent* <span class=\"title\">gethostbyaddr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* addr, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *h_name;\t\t\t<span class=\"comment\">/* Official name of host.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> **h_aliases;\t\t<span class=\"comment\">/* Alias list.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> h_addrtype;\t\t<span class=\"comment\">/* Host address type.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> h_length;\t\t\t<span class=\"comment\">/* Length of address.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> **h_addr_list;\t\t<span class=\"comment\">/* List of addresses from name server.  */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"非法输入\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* name = argv[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span> *<span class=\"title\">hostptr</span>&#123;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    hostptr = gethostbyname(name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hostptr == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"输入存在错误 或无法获取\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Official name of hostptr: %s\\n\"</span>, hostptr-&gt;h_name);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span> **pptr;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> inet_addr[INET_ADDRSTRLEN];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Alias list:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (pptr = hostptr-&gt;h_aliases; *pptr != <span class=\"literal\">nullptr</span>; ++pptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\t%s\\n\"</span>, *pptr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (hostptr-&gt;h_addrtype)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AF_INET:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"List of addresses from name server:\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (pptr = hostptr-&gt;h_addr_list; *pptr != <span class=\"literal\">nullptr</span>; ++pptr)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\t%s\\n\"</span>,</span><br><span class=\"line\">                        inet_ntop(hostptr-&gt;h_addrtype, *pptr, inet_addr, <span class=\"keyword\">sizeof</span>(inet_addr)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"unknow address type\\n\"</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">./run baidu.com</span></span><br><span class=\"line\"><span class=\"comment\">Official name of hostptr: baidu.com</span></span><br><span class=\"line\"><span class=\"comment\">Alias list:</span></span><br><span class=\"line\"><span class=\"comment\">List of addresses from name server:</span></span><br><span class=\"line\"><span class=\"comment\">\t39.156.69.79</span></span><br><span class=\"line\"><span class=\"comment\">\t220.181.38.148</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>以下两个函数通过读取/etc/services文件 来获取服务信息 以下内容来自维基百科</p>\n<p>Service文件是现代操作系统在etc目录下的一个配置文件，记录网络服务名对应的端口号与协议 其用途如下</p>\n<ul>\n<li>通过TCP/IP的API函数（声明在netdb.h中）直接查到网络服务名与端口号、使用协议的对应关系。如getservbyname(“serve”,”tcp”)获取端口号;getservbyport（htons（port），“tcp”）获取端口和协议上的服务名</li>\n<li>如果用户在这个文件中维护所有使用的网络服务名字、端口、协议，那么可以一目了然的获悉哪些端口号用于哪个服务，哪些端口号是空闲的<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 根据名称获取某个服务的完整信息</span></span><br><span class=\"line\"><span class=\"function\">struct servent <span class=\"title\">getservbyname</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* proto)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据端口号获取服务信息</span></span><br><span class=\"line\"><span class=\"function\">struct servent <span class=\"title\">getservbyport</span><span class=\"params\">(<span class=\"keyword\">int</span> port, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* proto)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">servent</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* s_name; <span class=\"comment\">/* 服务名称*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ** s_aliases; <span class=\"comment\">/* 服务的别名列表*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> s_port; <span class=\"comment\">/* 端口号*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* s_proto; <span class=\"comment\">/* 服务类型, 通常为TCP或UDP*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 内部使用的gethostbyname 和 getserverbyname</span></span><br><span class=\"line\"><span class=\"comment\">// hostname 用于接收主机名, 也可以用来接收字符串表示的IP地址(点分十进制, 十六进制字符串)</span></span><br><span class=\"line\"><span class=\"comment\">// service 用于接收服务名, 字符串表示的十进制端口号</span></span><br><span class=\"line\"><span class=\"comment\">// hints参数 对getaddrinfo的输出进行更准确的控制, 可以设置为NULL, 允许反馈各种有用的结果</span></span><br><span class=\"line\"><span class=\"comment\">// result 指向一个链表, 用于存储getaddrinfo的反馈结果</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getaddrinfo</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* hostname, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* service, <span class=\"keyword\">const</span> struct addrinfo* hints, struct addrinfo** result)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">struct addrinfo</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_flags;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_family;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_socktype; <span class=\"comment\">/* 服务类型, SOCK_STREAM或者SOCK_DGRAM*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_protocol;</span><br><span class=\"line\">\t<span class=\"keyword\">socklen_t</span> ai_addrlen;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* ai_canonname; <span class=\"comment\">/* 主机的别名*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span>* <span class=\"title\">ai_addr</span>;</span> <span class=\"comment\">/* 指向socket地址*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">addrinfo</span>* <span class=\"title\">ai_next</span>;</span> <span class=\"comment\">/* 指向下一个结构体*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要手动的释放堆内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">freeaddrinfo</span><span class=\"params\">(struct addrinfo* res)</span></span>;</span><br></pre></td></tr></table></figure>\n<img src=\"https://ftp.bmp.ovh/imgs/2019/08/7ebedb14d8eedeac.png\" alt=\"\"></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// host 存储返回的主机名</span></span><br><span class=\"line\"><span class=\"comment\">// serv存储返回的服务名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getnameinfo</span><span class=\"params\">(<span class=\"keyword\">const</span> struct sockaddr* sockaddr, <span class=\"keyword\">socklen_t</span> addrlen, <span class=\"keyword\">char</span>* host, <span class=\"keyword\">socklen_t</span> hostlen, <span class=\"keyword\">char</span>* serv</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t<span class=\"keyword\">socklen_t</span> servlen, <span class=\"keyword\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ftp.bmp.ovh/imgs/2019/08/bc7196e9a30d5152.png\" alt=\"\"></p>\n<p>测试<br>使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet ip port #来连接服务器的此端口</span><br><span class=\"line\">netstat -nt | grep port #来查看此端口的监听</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第六章高级IO函数\"><a href=\"#第六章高级IO函数\" class=\"headerlink\" title=\"第六章高级IO函数\"></a>第六章高级IO函数</h2><p>Linux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件自然限制了他的使用频率<br><em>文件描述符</em><br>文件描述符在是一个非负整数。是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表。<br>STDOUT_FILENO(值为1)- 值为1的文件描述符为标准输出, 关闭STDOUT_FILENO后用dup即可返回最小可用值(目前为, 1) 这样输出就重定向到了调用dup的参数指向的文件</p>\n<h3 id=\"创建文件描述符-pipe-dup-dup2-splice\"><a href=\"#创建文件描述符-pipe-dup-dup2-splice\" class=\"headerlink\" title=\"创建文件描述符 - pipe dup dup2 splice\"></a>创建文件描述符 - pipe dup dup2 splice</h3><p><strong>pipe函数</strong><br>这个函数可用于创建一个管道, 实现进程间的通信. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数定义</span></span><br><span class=\"line\"><span class=\"comment\">// 参数文件描述符数组 fd[0] 读出 fd[1]写入 单向管道</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0, 并将一对打开的文件描述符填入其参数指向的数组</span></span><br><span class=\"line\"><span class=\"comment\">// 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe</span><span class=\"params\">(<span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 双向管道</span></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数为 协议PF_UNIX(书上是AF_UNIX)感觉这里指明协议使用PF更好一些</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socketpair</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol, <span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>\n<p>学习了后面的内容了解到了进程间通信, 回来补上一个例子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fds[<span class=\"number\">2</span>];</span><br><span class=\"line\">    socketpair(PF_UNIX, SOCK_STREAM, <span class=\"number\">0</span>, fds);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pid = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(fds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">char</span> a[] = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">        send(fds[<span class=\"number\">1</span>], a, <span class=\"built_in\">strlen</span>(a), <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(fds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">char</span> b[<span class=\"number\">20</span>] &#123;&#125;;</span><br><span class=\"line\">        recv(fds[<span class=\"number\">0</span>], b, <span class=\"number\">20</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>, b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>dup和dup2函数</strong><br>复制一个现有的文件描述符</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 返回的文件描述符总是取系统当前可用的最小整数值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup</span><span class=\"params\">(<span class=\"keyword\">int</span> oldfd)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 可以用newfd来制定新的文件描述符, 如果newfd已经被打开则先关闭</span></span><br><span class=\"line\"><span class=\"comment\">// 如果newfd==oldfd 则不关闭newfd直接返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup2</span><span class=\"params\">(<span class=\"keyword\">int</span> oldfd, <span class=\"keyword\">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>dup函数创建一个新的文件描述符, 新的文件描述符和原有的file_descriptor共同指向相同的目标.<br>回来补上例子, 这个例子由于关掉了<code>STDOUT_FILENO</code>dup最小的即为<code>STDOUT_FILENO</code>所以<br>标准输出都到了这个文件之中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> filefd = <span class=\"built_in\">open</span>(<span class=\"string\">\"/home/lsmg/1.txt\"</span>, O_WRONLY);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(STDOUT_FILENO);</span><br><span class=\"line\">    dup(filefd);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"123\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"读写数据-readv-writev-mmap-munmap\"><a href=\"#读写数据-readv-writev-mmap-munmap\" class=\"headerlink\" title=\"读写数据 - readv writev mmap munmap\"></a>读写数据 - readv writev mmap munmap</h3><p><strong>readv/writev</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/uio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// count 为 vector的长度, 即为有多少块内存</span></span><br><span class=\"line\"><span class=\"comment\">// 成功时返回写入\\读取的长度 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">readv</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> struct iovec* <span class=\"built_in\">vector</span>, <span class=\"keyword\">int</span> count)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">writev</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> struct iovec* <span class=\"built_in\">vector</span>, <span class=\"keyword\">int</span> count)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* iov_base <span class=\"comment\">/* 内存起始地址*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> iov_len <span class=\"comment\">/* 这块内存长度*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>回来补上一个使用例子, 这个例子将一个int的内存表示写入到了文件之中<br>使用hexdump查看这个文件<code>0000000 86a0 0001</code>可以看到<code>186a0</code>即为100000</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2020年1月7日16:52:11</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> file = <span class=\"built_in\">open</span>(<span class=\"string\">\"/home/lsmg/1.txt\"</span>, O_WRONLY);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = <span class=\"number\">100000</span>;</span><br><span class=\"line\">    iovec temp_iovec&#123;&#125;;</span><br><span class=\"line\">    temp_iovec.iov_base = &amp;temp;</span><br><span class=\"line\">    temp_iovec.iov_len = <span class=\"keyword\">sizeof</span>(temp);</span><br><span class=\"line\">    writev(file, &amp;temp_iovec, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>sendfile函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/sendfile.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">sendfile</span><span class=\"params\">(<span class=\"keyword\">int</span> out_fd, <span class=\"keyword\">int</span> in_fd, <span class=\"keyword\">off_t</span>* offset, <span class=\"keyword\">size_t</span> count)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">O_RDONLY只读模式</span><br><span class=\"line\">O_WRONLY只写模式</span><br><span class=\"line\">O_RDWR读写模式</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open</span><span class=\"params\">(file_name, flag)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>stat结构体, 可用fstat生成, <strong>简直就是文件的身份证</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stat</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">dev_t</span>       st_dev;     <span class=\"comment\">/* ID of device containing file -文件所在设备的ID*/</span></span><br><span class=\"line\">    <span class=\"keyword\">ino_t</span>       st_ino;     <span class=\"comment\">/* inode number -inode节点号*/</span></span><br><span class=\"line\">    <span class=\"keyword\">mode_t</span>      st_mode;    <span class=\"comment\">/* protection -保护模式?*/</span></span><br><span class=\"line\">    <span class=\"keyword\">nlink_t</span>     st_nlink;   <span class=\"comment\">/* number of hard links -链向此文件的连接数(硬连接)*/</span></span><br><span class=\"line\">    <span class=\"keyword\">uid_t</span>       st_uid;     <span class=\"comment\">/* user ID of owner -user id*/</span></span><br><span class=\"line\">    <span class=\"keyword\">gid_t</span>       st_gid;     <span class=\"comment\">/* group ID of owner - group id*/</span></span><br><span class=\"line\">    <span class=\"keyword\">dev_t</span>       st_rdev;    <span class=\"comment\">/* device ID (if special file) -设备号，针对设备文件*/</span></span><br><span class=\"line\">    <span class=\"keyword\">off_t</span>       st_size;    <span class=\"comment\">/* total size, in bytes -文件大小，字节为单位*/</span></span><br><span class=\"line\">    <span class=\"keyword\">blksize_t</span>   st_blksize; <span class=\"comment\">/* blocksize for filesystem I/O -系统块的大小*/</span></span><br><span class=\"line\">    <span class=\"keyword\">blkcnt_t</span>    st_blocks;  <span class=\"comment\">/* number of blocks allocated -文件所占块数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span>      st_atime;   <span class=\"comment\">/* time of last access -最近存取时间*/</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span>      st_mtime;   <span class=\"comment\">/* time of last modification -最近修改时间*/</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span>      st_ctime;   <span class=\"comment\">/* time of last status change - */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>身份证</strong>生成函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一个参数需要调用open生成文件描述符</span></span><br><span class=\"line\"><span class=\"comment\">// 下面其他两个为文件全路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fstat</span><span class=\"params\">(<span class=\"keyword\">int</span> filedes, struct stat *buf)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当路径指向为符号链接的时候, lstat为符号链接的信息. stat为符号链接指向文件信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stat</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, struct stat *buf)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lstat</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, struct stat *buf)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* ln -s source dist  建立软连接, 类似快捷方式, 也叫符号链接</span></span><br><span class=\"line\"><span class=\"comment\">* ln source dist  建立硬链接, 同一个文件使用多个不同的别名, 指向同一个文件数据块, 只要硬链接不被完全</span></span><br><span class=\"line\"><span class=\"comment\">* 删除就可以正常访问</span></span><br><span class=\"line\"><span class=\"comment\">* 文件数据块 - 文件的真正数据是一个文件数据块, 打开的`文件`指向这个数据块, 就是说</span></span><br><span class=\"line\"><span class=\"comment\">* `文件`本身就类似快捷方式, 指向文件存在的区域.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p> <strong>mmap和munmap函数</strong></p>\n<p><code>mmap</code>创建一块进程通讯共享的内存(可以将文件映射入其中), <code>munmap</code>释放这块内存</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/mman.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// start 内存起始位置, 如果为NULL则系统分配一个地址 length为长度</span></span><br><span class=\"line\"><span class=\"comment\">// port参数 PROT_READ(可读) PROT_WRITE(可写) PROT_EXEC(可执行), PROT_NONE(不可访问)</span></span><br><span class=\"line\"><span class=\"comment\">// flag参数 内存被修改后的行为</span></span><br><span class=\"line\"><span class=\"comment\">// - MAP_SHARED 进程间共享内存, 对内存的修改反映到映射文件中</span></span><br><span class=\"line\"><span class=\"comment\">// - MAP_PRIVATE 为调用进程私有, 对该内存段的修改不会反映到文件中</span></span><br><span class=\"line\"><span class=\"comment\">// - MAP_ANONUMOUS 不是从文件映射而来, 内容被初始化为0, 最后两个参数被忽略</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回区域指针, 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">mmap</span><span class=\"params\">(<span class=\"keyword\">void</span>* start, <span class=\"keyword\">size_t</span> length, <span class=\"keyword\">int</span> port, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">munmap</span><span class=\"params\">(<span class=\"keyword\">void</span>* start, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><strong>splice函数</strong><br>用于在两个文件名描述符之间移动数据, 0拷贝操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// fd_in 为文件描述符, 如果为管道文件描述符则 off_in必须为NULL, 否则为读取开始偏移位置</span></span><br><span class=\"line\"><span class=\"comment\">// len为指定移动的数据长度, flags参数控制数据如何移动.</span></span><br><span class=\"line\"><span class=\"comment\">// - SPLICE_F_NONBLOCK 非阻塞splice操作, 但会受文件描述符自身的阻塞</span></span><br><span class=\"line\"><span class=\"comment\">// - SPLICE_F_MORE 给内核一个提示, 后续的splice调用将读取更多的数据???????</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">splice</span><span class=\"params\">(<span class=\"keyword\">int</span> fd_in, <span class=\"keyword\">loff_t</span>* off_in, <span class=\"keyword\">int</span> fd_out, <span class=\"keyword\">loff_t</span>* off_out, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用splice函数  实现echo服务器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &lt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"the parmerters is wrong\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(errno);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ip = argv[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> port = atoi(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"the port is %d the ip is %s\\n\"</span>, port, ip);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(sockfd &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">address</span>&#123;</span>&#125;;</span><br><span class=\"line\">    address.sin_family = AF_INET;</span><br><span class=\"line\">    address.sin_port = htons(port);</span><br><span class=\"line\">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = bind(sockfd, (sockaddr*)&amp;address, <span class=\"keyword\">sizeof</span>(address));</span><br><span class=\"line\">    assert(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">listen</span>(sockfd, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> clientfd&#123;&#125;;</span><br><span class=\"line\">    sockaddr_in client_address&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">socklen_t</span> client_addrlen = <span class=\"keyword\">sizeof</span>(client_address);</span><br><span class=\"line\"></span><br><span class=\"line\">    clientfd = accept(sockfd, (sockaddr*)&amp;client_address, &amp;client_addrlen);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clientfd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"accept error\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"a new connection from %s:%d success\\n\"</span>, inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fds[<span class=\"number\">2</span>];</span><br><span class=\"line\">        pipe(fds);</span><br><span class=\"line\">        ret = splice(clientfd, <span class=\"literal\">nullptr</span>, fds[<span class=\"number\">1</span>], <span class=\"literal\">nullptr</span>, <span class=\"number\">32768</span>, SPLICE_F_MORE);</span><br><span class=\"line\">        assert(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = splice(fds[<span class=\"number\">0</span>], <span class=\"literal\">nullptr</span>, clientfd, <span class=\"literal\">nullptr</span>, <span class=\"number\">32768</span>, SPLICE_F_MORE);</span><br><span class=\"line\">        assert(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">close</span>(clientfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第七章Linux服务器程序规范\"><a href=\"#第七章Linux服务器程序规范\" class=\"headerlink\" title=\"第七章Linux服务器程序规范\"></a>第七章Linux服务器程序规范</h2><ul>\n<li>Linux程序服务器 一般以后台进程形式运行.  后台进程又称为守护进程(daemon). 他没有控制终端, 因而不会意外的接收到用户输入. 守护进程的父进程通常都是init进程(PID为1的进程)</li>\n<li>Linux服务器程序有一套日志系统, 他至少能输出日志到文件. 日志这东西太重要了,排错对比全靠它.</li>\n<li>Linux服务器程序一般以某个专门的非root身份运行. 比如mysqld有自己的账户mysql.</li>\n<li>Linux服务器程序一般都有自己的配置文件, 而不是把所有配置都写死在代码里面, 方便后续的更改.</li>\n<li>Linux服务器程序通常在启动的时候生成一个PID文件并存入/var/run 目录中, 以记录改后台进程的PID.</li>\n<li>Linux服务器程序通常需要考虑系统资源和限制, 预测自己的承受能力</li>\n</ul>\n<h3 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service rsyslog restart // 启动守护进程</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;syslog.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// priority参数是所谓的设施值(记录日志信息来源, 默认为LOG_USER)与日志级别的按位或</span></span><br><span class=\"line\"><span class=\"comment\">// - 0 LOG_EMERG  /* 系统不可用*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 1 LOG_ALERT   /* 报警需要立即采取行动*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 2 LOG_CRIT /* 非常严重的情况*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 3 LOG_ERR  /* 错误*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 4 LOG_WARNING /* 警告*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 5 LOG_NOTICE /* 通知*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 6 LOG_INFO /* 信息*/</span></span><br><span class=\"line\"><span class=\"comment\">//  -7 LOG_DEBUG /* 调试*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">syslog</span><span class=\"params\">(<span class=\"keyword\">int</span> priority, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* message, .....)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ident 位于日志的时间后 通常为名字</span></span><br><span class=\"line\"><span class=\"comment\">// logopt 对后续 syslog调用的行为进行配置</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x01 LOG_PID  /* 在日志信息中包含程序PID*/</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x02 LOG_CONS /* 如果信息不能记录到日志文件, 则打印到终端*/</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x04 LOG_ODELAY /* 延迟打开日志功能直到第一次调用syslog*/</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x08 LOG_NDELAY /* 不延迟打开日志功能*/</span></span><br><span class=\"line\"><span class=\"comment\">// facility参数可以修改syslog函数中的默认设施值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">openlog</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* ident, <span class=\"keyword\">int</span> logopt, <span class=\"keyword\">int</span> facility)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// maskpri 一共八位 0000-0000</span></span><br><span class=\"line\"><span class=\"comment\">// 如果将最后一个0置为1 表示 记录0级别的日志</span></span><br><span class=\"line\"><span class=\"comment\">// 如果将最后两个0都置为1 表示记录0和1级别的日志</span></span><br><span class=\"line\"><span class=\"comment\">// 可以通过LOG_MASK() 宏设定 比如LOG_MASK(LOG_CRIT) 表示将倒数第三个0置为1, 表示只记录LOG_CRIT</span></span><br><span class=\"line\"><span class=\"comment\">// 如果直接设置setlogmask(3); 3的二进制最后两个数均为1 则记录 0和1级别的日志</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setlogmask</span><span class=\"params\">(<span class=\"keyword\">int</span> maskpri)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭日志功能</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">closelog</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用户信息-切换用户\"><a href=\"#用户信息-切换用户\" class=\"headerlink\" title=\"用户信息, 切换用户\"></a>用户信息, 切换用户</h3><p>UID - 真实用户ID<br>EUID - 有效用户ID - 方便资源访问<br>GID - 真实组ID<br>EGID - 有效组ID</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uid_t</span> <span class=\"title\">getuid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uid_t</span> <span class=\"title\">geteuid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">gid_t</span> <span class=\"title\">getgid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">gid_t</span> <span class=\"title\">getegid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setuid</span><span class=\"params\">(<span class=\"keyword\">uid_t</span> uid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">seteuid</span><span class=\"params\">(<span class=\"keyword\">uid_t</span> euid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setgid</span><span class=\"params\">(<span class=\"keyword\">gid_t</span> gid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setegid</span><span class=\"params\">(<span class=\"keyword\">gid_t</span> gid)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>可以通过 <code>setuid</code>和<code>setgid</code>切换用户 <strong>root用户uid和gid均为0</strong></p>\n<h3 id=\"进程间关系\"><a href=\"#进程间关系\" class=\"headerlink\" title=\"进程间关系\"></a>进程间关系</h3><p>PGID - 进程组ID(Linux下每个进程隶属于一个进程组)</p>\n<p>#include &lt;unistd.h&gt;<br>pid_t getpgid(pid_t pid); 成功时返回pid所属的pgid 失败返回-1<br>int setpgid(pid_t pid, pid_t pgid);</p>\n<p><strong>会话</strong><br>一些有关联的进程组将形成一个会话<br>略过</p>\n<p><strong>查看进程关系</strong><br>ps和less</p>\n<p><strong>资源限制</strong><br>略<br><strong>改变目录</strong><br>略</p>\n<h2 id=\"第八章高性能服务器程序框架\"><a href=\"#第八章高性能服务器程序框架\" class=\"headerlink\" title=\"第八章高性能服务器程序框架\"></a>第八章高性能服务器程序框架</h2><p><strong>服务器模型-CS模型</strong></p>\n<p><strong>优点</strong></p>\n<ul>\n<li>实现起来简单</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>服务器是通信的中心, 访问过大的时候会导致响应过慢</li>\n</ul>\n<p>模式图<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%BE8-2%20TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png\" alt=\"\"></p>\n<p>编写的demo 没有用到fork函数. 后续待完善</p>\n<p><strong>服务器框架 IO模型</strong></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png\" alt=\"\"></p>\n<p>这个模型大概能够理解, 自己也算是学了半年的Javaweb.</p>\n<p>socket在创建的时候默认是阻塞的, 不过可以通过传<code>SOCK_NONBLOCK</code>参解决<br>非阻塞调用都会立即返回 但可能事件没有发生(recv没有接收到信息), 没有发生和出错都会<code>返回-1</code> 所以需要通过<code>errno</code>来区分这些错误.<br><strong>事件未发生</strong><br>accept, send,recv errno被设置为 <code>EAGAIN(再来一次)</code>或<code>EWOULDBLOCK(期望阻塞)</code><br>connect 被设置为 <code>EINPROGRESS(正在处理中)</code></p>\n<p>需要在事件已经发生的情况下 去调用非阻塞IO, 才能提高性能</p>\n<p>常用IO复用函数 <code>select</code> <code>poll</code> <code>epoll_wait</code> 将在第九章后面说明<br>信号将在第十章说明</p>\n<p><strong>两种高效的事件处理模式和并发模式</strong><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Reactor%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Proactor%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E7%94%A8%E5%90%8C%E6%AD%A5IO%E6%A8%A1%E6%8B%9F%E5%87%BA%E7%9A%84Proactor%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p>程序分为计算密集型(CPU使用很多, IO资源使用很少)和IO密集型(反过来).<br>前者使用并发编程反而会降低效率, 后者则会提升效率<br>并发编程有多进程和多线程两种方式</p>\n<p>并发模式 - IO单元和多个逻辑单元之间协调完成任务的方法.<br>服务器主要有两种并发模式</p>\n<ul>\n<li>半同步/半异步模式</li>\n<li>领导者/追随者模式</li>\n</ul>\n<p><strong>半同步/半异步模式</strong><br>在IO模型中, 异步和同步的区分是内核向应用程序通知的是何种IO事件(就绪事件还是完成事件), 以及由谁来完成IO读写(应用程序还是内核)</p>\n<p>而在这里(并发模式)<br>同步指的是完全按照代码序列的顺序执行 - 按照同步方式运行的线程称为同步线程<br>异步需要系统事件(中断, 信号)来驱动 - 按照异步方式运行的线程称为异步线程<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5.png\" alt=\"\"></p>\n<p>服务器(需要较好的实时性且能同时处理多个客户请求) - 一般使用同步线程和异步线程来实现,即为半同步/半异步模式<br>同步线程 - 处理客户逻辑, 处理请求队列中的对象<br>异步线程 - 处理IO事件, 接收到客户请求后将其封装成请求对象并插入请求队列</p>\n<p>半同步/半异步模式 存在变体 <code>半同步/半反应堆模式</code><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p>异步线程 - 主线程 - 负责监听所有socket上的事件</p>\n<p><strong>领导者/追随者模式</strong><br>略</p>\n<p><strong>高效编程方法 - 有限状态机</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 状态独立的有限状态机</span></span><br><span class=\"line\">STATE_MACHINE(Package _pack) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPackageType _type = _pack.GetType();</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span>(_type) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> type_A:</span><br><span class=\"line\">\t\t\txxxx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> type_B:</span><br><span class=\"line\">\t\t\txxxx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 带状态转移的有限状态机</span></span><br><span class=\"line\">STATE_MACHINE() &#123;</span><br><span class=\"line\">\tState cur_State = type_A;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(cur_State != type_C) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tPackage _pack = getNewPackage();</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span>(cur_State) &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> type_A:</span><br><span class=\"line\">\t\t\t\tprocess_package_state_A(_pack);</span><br><span class=\"line\">\t\t\t\tcur_State = type_B;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> type_B:</span><br><span class=\"line\">\t\t\t\txxxx;</span><br><span class=\"line\">\t\t\t\tcur_State = type_C;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>花了小一个小时 终于一个字母一个字母的抄完了那个5000多字的代码<br>@2019年9月8日22:08:46@</p>\n<h3 id=\"提高服务器性能的其他建议-池-数据复制-上下文切换和锁\"><a href=\"#提高服务器性能的其他建议-池-数据复制-上下文切换和锁\" class=\"headerlink\" title=\"提高服务器性能的其他建议 池 数据复制 上下文切换和锁\"></a>提高服务器性能的其他建议 池 数据复制 上下文切换和锁</h3><p><strong>池</strong> - 用空间换取时间<br>进程池和线程池</p>\n<p><strong>数据复制</strong> - 高性能的服务器应该尽量避免不必要的复制</p>\n<p><strong>上下文切换和锁</strong><br>减少<code>锁</code>的作用区域. 不应该创建太多的工作进程, 而是使用专门的业务逻辑线程.</p>\n","site":{"data":{}},"excerpt":"<p>开头选了这本书, 看到这本书是他人总结三大本后自己写的, 先求个理解大概.<br>话说别人推荐的c++服务器咋都是c语言…..<br>2019年8月17日20:37:53</p>\n<p>每学习一部分就写一个demo</p>","more":"<p>2020年7月16日12:43:41</p>\n<p>上面那个more标签让我想起了我第一个hexo博客的主题.<br>大二暑假了, 距离这篇博客写下已经将近一年了. 时间过得真快, 唯一不变的就是自己依然的菜..<br>也理解为什么C++服务器推荐的C语言</p>\n<p>这里将第五章后面的内容整理下.<br>这算是我第一次写的博客吧, 之前写的时候写的过于详细和冗余了. 目前有了一点基础, 所以这次重新读是为了<br>把博客和书读薄</p>\n<p>目前第五章后的博客有13000个汉字和44000个字母. 看看整理完毕后有多少吧</p>\n<h2 id=\"第五章Linux网络编程基础API\"><a href=\"#第五章Linux网络编程基础API\" class=\"headerlink\" title=\"第五章Linux网络编程基础API\"></a>第五章Linux网络编程基础API</h2><h3 id=\"主机字节序和网络字节序\"><a href=\"#主机字节序和网络字节序\" class=\"headerlink\" title=\"主机字节序和网络字节序\"></a>主机字节序和网络字节序</h3><p>字节序分为 <code>大端字节序</code>和<code>小端字节序</code><br>由于大多数PC采用小端字节序(高位存在高地址处), 所以小端字节序又称为主机字节序</p>\n<p>为了防止不同机器字节序不同导致的错乱问题. 规定传输的时候统一为 大端字节序(网络字节序).<br>这样主机会根据自己的情况决定 - 是否转换接收到的数据的字节序</p>\n<p><strong>基础连接</strong><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93.jpg\" alt=\"\"><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88%E5%9C%B0%E5%9D%80%E6%97%8F.jpg\" alt=\"\"></p>\n<p>字节序转换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> <span class=\"title\">htonl</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> hostlong)</span></span>; <span class=\"comment\">// host to network long</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> <span class=\"title\">htons</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> hostlong)</span></span>; <span class=\"comment\">// host to network short</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> <span class=\"title\">ntohl</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> netlong)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> <span class=\"title\">ntohs</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> netlong)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>点分十进制地址和网络地址转换<br>程序需要使用网络地址 给人察看需要使用点分十进制 灵活转换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONE</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">in_addr_t</span>  <span class=\"title\">inet_addr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* strptr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inet_aton</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* cp, struct in_addr* inp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数返回一个静态变量地址值, 所以多次调用会导致覆盖</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">inet_ntoa</span><span class=\"params\">(struct in_addr in)</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族</span></span><br><span class=\"line\"><span class=\"comment\">// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inet_pton</span><span class=\"params\">(<span class=\"keyword\">int</span> af, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * src, <span class=\"keyword\">void</span>* dst)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">inet_ntop</span><span class=\"params\">(<span class=\"keyword\">int</span> af, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>*  src, <span class=\"keyword\">char</span>* dst, <span class=\"keyword\">socklen_t</span> cnt)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>socket 三部曲</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建 命名 监听 socket</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// domain指定使用那个协议族 PF_INET PF_INET6</span></span><br><span class=\"line\"><span class=\"comment\">// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)</span></span><br><span class=\"line\"><span class=\"comment\">// 有两个使用较多的选项SOCK_NONBLOCK 设置非阻塞</span></span><br><span class=\"line\"><span class=\"comment\">// SOCK_CLOEXEC 使用fork创建子进程的时候在子进程中关闭该socket</span></span><br><span class=\"line\"><span class=\"comment\">// protocol设置为默认的0</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// socket为socket文件描述符</span></span><br><span class=\"line\"><span class=\"comment\">// my_addr 为地址信息</span></span><br><span class=\"line\"><span class=\"comment\">// addrlen为socket地址长度</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回 -1</span></span><br><span class=\"line\"><span class=\"comment\">// 这里细说还有个EADDRINUSE(被绑定的地址正在使用如TIME_WAIT状态)</span></span><br><span class=\"line\"><span class=\"comment\">// 与之搭配的解决方式 是使用setsockopt设置SO_REUSEADDR为true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">int</span> socket, <span class=\"keyword\">const</span> struct sockaddr* my_addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// backlog表示队列最大的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"keyword\">int</span> socket, <span class=\"keyword\">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>服务器</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接受连接 失败返回-1 成功时返回socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">accept</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr* addr, <span class=\"keyword\">socklen_t</span>* addrlen)</span></span></span><br></pre></td></tr></table></figure>\n\n\n<p>客户端</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发起连接</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 第三个参数为 地址指定的长度</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> struct sockaddr * serv_addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>连接关闭</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 参数为保存的socket</span></span><br><span class=\"line\"><span class=\"comment\">// 并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才能关闭(需要查阅)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">close</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 立即关闭</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数为可选值 </span></span><br><span class=\"line\"><span class=\"comment\">//\tSHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃</span></span><br><span class=\"line\"><span class=\"comment\">//\tSHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去</span></span><br><span class=\"line\"><span class=\"comment\">//\tSHUT_RDWR 同时关闭读和写</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败为-1 设置errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shutdown</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> howto)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 1. close会将引用计数-1 等到为0时才关闭套接字. shutdown则可以无视此, 激发TCP的正常连接终止序列</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 2. close会终止读和写两个方向的数据传送, 但由于TCP全双工有时需要告知对方我方发送已经完毕</span></span></span><br></pre></td></tr></table></figure>\n\n\n<p>基础TCP</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取sockfd的数据</span></span><br><span class=\"line\"><span class=\"comment\">// buf 指定读缓冲区的位置</span></span><br><span class=\"line\"><span class=\"comment\">// len 指定读缓冲区的大小</span></span><br><span class=\"line\"><span class=\"comment\">// flags 参数较多</span></span><br><span class=\"line\"><span class=\"comment\">// 成功的时候返回读取到的长度, 可能小于预期长度, 需要多次读取.   读取到0 通信对方已经关闭连接, 错误返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">recv</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 发送</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>选项名</th>\n<th>含义</th>\n<th>可用于发送</th>\n<th>可用于接收</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MSG_CONFIRM</td>\n<td>指示链路层协议持续监听, 直到得到答复.(仅能用于SOCK_DGRAM和SOCK_RAW类型的socket)</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>MSG_DONTROUTE</td>\n<td>不查看路由表, 直接将数据发送给本地的局域网络的主机(代表发送者知道目标主机就在本地网络中)</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>MSG_DONTWAIT</td>\n<td>非阻塞</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_MORE</td>\n<td>告知内核有更多的数据要发送, 等到数据写入缓冲区完毕后,一并发送.减少短小的报文提高传输效率</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>MSG_WAITALL</td>\n<td>读操作一直等待到读取到指定字节后才会返回</td>\n<td>N</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_PEEK</td>\n<td>看一下内缓存数据, 并不会影响数据</td>\n<td>N</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_OOB</td>\n<td>发送或接收紧急数据</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_NOSIGNAL</td>\n<td>向读关闭的管道或者socket连接中写入数据不会触发SIGPIPE信号</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n</tbody></table>\n<p>基础UDP</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.</span></span><br><span class=\"line\"><span class=\"comment\">// 不过recvfrom和sendto 也可以用于 面向STREAM的连接, 这样可以省略发送和接收端的socket地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">recvfrom</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> flags, struct sockaddr* src_addr, <span class=\"keyword\">socklen_t</span>* addrlen)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">sendto</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* buf, <span class=\"keyword\">size_t</span> len, ing flags, <span class=\"keyword\">const</span> struct sockaddr* dest_addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>通用读写函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#inclued <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">recvmsg</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct msghdr* msg, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">sendmsg</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct msghdr* msg, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msghdr</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">/* socket address --- 指向socket地址结构变量, 对于TCP连接需要设置为NULL*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* msg_name; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">socklen_t</span> msg_namelen;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/* 分散的内存块 --- 对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由</span></span><br><span class=\"line\"><span class=\"comment\">     * msg_iov指向的数组指定, 称为分散读(scatter read)  ---对于sendmsg而言, msg_iovlen块的分散内存中</span></span><br><span class=\"line\"><span class=\"comment\">     * 的数据将一并发送称为集中写(gather write);</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span>* <span class=\"title\">msg_iov</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> msg_iovlen; <span class=\"comment\">/* 分散内存块的数量*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* msg_control; <span class=\"comment\">/* 指向辅助数据的起始位置*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">socklen_t</span> msg_controllen; <span class=\"comment\">/* 辅助数据的大小*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> msg_flags; <span class=\"comment\">/* 复制函数的flags参数, 并在调用过程中更新*/</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* iov_base <span class=\"comment\">/* 内存起始地址*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> iov_len <span class=\"comment\">/* 这块内存长度*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他Api</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 用于判断 sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据, </span></span><br><span class=\"line\"><span class=\"comment\">// 是的话返回1, 不是返回0</span></span><br><span class=\"line\"><span class=\"comment\">// 这样就可以选择带MSG_OOB标志的recv调用来接收带外数据. </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sockatmark</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// getsockname 获取sockfd对应的本端socket地址, 存入address指定的内存中, 长度存入address_len中 成功返回0失败返回-1</span></span><br><span class=\"line\"><span class=\"comment\">// getpeername 获取远端的信息, 同上</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getsockname</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr* address, <span class=\"keyword\">socklen_t</span>* address_len)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getpeername</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr* address, <span class=\"keyword\">socklen_t</span>* address_len)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>重要 socket属性设置</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 以下函数头文件均相同*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度</span></span><br><span class=\"line\"><span class=\"comment\">// 成功时返回0 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> option_name, <span class=\"keyword\">void</span>* option_value, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t<span class=\"keyword\">socklen_t</span> <span class=\"keyword\">restrict</span> option_len)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> option_name, <span class=\"keyword\">void</span>* option_value, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t<span class=\"keyword\">socklen_t</span> <span class=\"keyword\">restrict</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">linger</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l_onoff <span class=\"comment\">/* 开启非0, 关闭为0*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l_linger; <span class=\"comment\">/* 滞留时间*/</span></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t* 当onoff为0的时候此项不起作用, close调用默认行为关闭socket</span></span><br><span class=\"line\"><span class=\"comment\">\t* 当onoff不为0 且linger为0, close将立即返回, TCP将丢弃发送缓冲区的残留数据, 同时发送一个复位报文段</span></span><br><span class=\"line\"><span class=\"comment\">\t* 当onoff不为0 且linger大于0 . 当socket阻塞的时候close将会等待TCP模块发送完残留数据并得到确认后关 </span></span><br><span class=\"line\"><span class=\"comment\">\t* 闭, 如果是处于非阻塞则立即关闭</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/socket%E9%80%89%E9%A1%B9.jpg\" alt=\"\"></p>\n<p><strong>网络信息API</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 通过主机名查找ip</span></span><br><span class=\"line\"><span class=\"function\">struct hostent* <span class=\"title\">gethostbyname</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过ip获取主机完整信息 </span></span><br><span class=\"line\"><span class=\"comment\">// type为IP地址类型 AF_INET和AF_INET6</span></span><br><span class=\"line\"><span class=\"function\">struct hostent* <span class=\"title\">gethostbyaddr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* addr, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *h_name;\t\t\t<span class=\"comment\">/* Official name of host.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> **h_aliases;\t\t<span class=\"comment\">/* Alias list.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> h_addrtype;\t\t<span class=\"comment\">/* Host address type.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> h_length;\t\t\t<span class=\"comment\">/* Length of address.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> **h_addr_list;\t\t<span class=\"comment\">/* List of addresses from name server.  */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"非法输入\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* name = argv[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span> *<span class=\"title\">hostptr</span>&#123;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    hostptr = gethostbyname(name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hostptr == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"输入存在错误 或无法获取\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Official name of hostptr: %s\\n\"</span>, hostptr-&gt;h_name);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span> **pptr;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> inet_addr[INET_ADDRSTRLEN];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Alias list:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (pptr = hostptr-&gt;h_aliases; *pptr != <span class=\"literal\">nullptr</span>; ++pptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\t%s\\n\"</span>, *pptr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (hostptr-&gt;h_addrtype)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AF_INET:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"List of addresses from name server:\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (pptr = hostptr-&gt;h_addr_list; *pptr != <span class=\"literal\">nullptr</span>; ++pptr)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\t%s\\n\"</span>,</span><br><span class=\"line\">                        inet_ntop(hostptr-&gt;h_addrtype, *pptr, inet_addr, <span class=\"keyword\">sizeof</span>(inet_addr)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"unknow address type\\n\"</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">./run baidu.com</span></span><br><span class=\"line\"><span class=\"comment\">Official name of hostptr: baidu.com</span></span><br><span class=\"line\"><span class=\"comment\">Alias list:</span></span><br><span class=\"line\"><span class=\"comment\">List of addresses from name server:</span></span><br><span class=\"line\"><span class=\"comment\">\t39.156.69.79</span></span><br><span class=\"line\"><span class=\"comment\">\t220.181.38.148</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>以下两个函数通过读取/etc/services文件 来获取服务信息 以下内容来自维基百科</p>\n<p>Service文件是现代操作系统在etc目录下的一个配置文件，记录网络服务名对应的端口号与协议 其用途如下</p>\n<ul>\n<li>通过TCP/IP的API函数（声明在netdb.h中）直接查到网络服务名与端口号、使用协议的对应关系。如getservbyname(“serve”,”tcp”)获取端口号;getservbyport（htons（port），“tcp”）获取端口和协议上的服务名</li>\n<li>如果用户在这个文件中维护所有使用的网络服务名字、端口、协议，那么可以一目了然的获悉哪些端口号用于哪个服务，哪些端口号是空闲的<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 根据名称获取某个服务的完整信息</span></span><br><span class=\"line\"><span class=\"function\">struct servent <span class=\"title\">getservbyname</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* proto)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据端口号获取服务信息</span></span><br><span class=\"line\"><span class=\"function\">struct servent <span class=\"title\">getservbyport</span><span class=\"params\">(<span class=\"keyword\">int</span> port, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* proto)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">servent</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* s_name; <span class=\"comment\">/* 服务名称*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ** s_aliases; <span class=\"comment\">/* 服务的别名列表*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> s_port; <span class=\"comment\">/* 端口号*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* s_proto; <span class=\"comment\">/* 服务类型, 通常为TCP或UDP*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 内部使用的gethostbyname 和 getserverbyname</span></span><br><span class=\"line\"><span class=\"comment\">// hostname 用于接收主机名, 也可以用来接收字符串表示的IP地址(点分十进制, 十六进制字符串)</span></span><br><span class=\"line\"><span class=\"comment\">// service 用于接收服务名, 字符串表示的十进制端口号</span></span><br><span class=\"line\"><span class=\"comment\">// hints参数 对getaddrinfo的输出进行更准确的控制, 可以设置为NULL, 允许反馈各种有用的结果</span></span><br><span class=\"line\"><span class=\"comment\">// result 指向一个链表, 用于存储getaddrinfo的反馈结果</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getaddrinfo</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* hostname, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* service, <span class=\"keyword\">const</span> struct addrinfo* hints, struct addrinfo** result)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">struct addrinfo</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_flags;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_family;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_socktype; <span class=\"comment\">/* 服务类型, SOCK_STREAM或者SOCK_DGRAM*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_protocol;</span><br><span class=\"line\">\t<span class=\"keyword\">socklen_t</span> ai_addrlen;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* ai_canonname; <span class=\"comment\">/* 主机的别名*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span>* <span class=\"title\">ai_addr</span>;</span> <span class=\"comment\">/* 指向socket地址*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">addrinfo</span>* <span class=\"title\">ai_next</span>;</span> <span class=\"comment\">/* 指向下一个结构体*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要手动的释放堆内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">freeaddrinfo</span><span class=\"params\">(struct addrinfo* res)</span></span>;</span><br></pre></td></tr></table></figure>\n<img src=\"https://ftp.bmp.ovh/imgs/2019/08/7ebedb14d8eedeac.png\" alt=\"\"></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// host 存储返回的主机名</span></span><br><span class=\"line\"><span class=\"comment\">// serv存储返回的服务名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getnameinfo</span><span class=\"params\">(<span class=\"keyword\">const</span> struct sockaddr* sockaddr, <span class=\"keyword\">socklen_t</span> addrlen, <span class=\"keyword\">char</span>* host, <span class=\"keyword\">socklen_t</span> hostlen, <span class=\"keyword\">char</span>* serv</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t<span class=\"keyword\">socklen_t</span> servlen, <span class=\"keyword\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ftp.bmp.ovh/imgs/2019/08/bc7196e9a30d5152.png\" alt=\"\"></p>\n<p>测试<br>使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet ip port #来连接服务器的此端口</span><br><span class=\"line\">netstat -nt | grep port #来查看此端口的监听</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第六章高级IO函数\"><a href=\"#第六章高级IO函数\" class=\"headerlink\" title=\"第六章高级IO函数\"></a>第六章高级IO函数</h2><p>Linux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件自然限制了他的使用频率<br><em>文件描述符</em><br>文件描述符在是一个非负整数。是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表。<br>STDOUT_FILENO(值为1)- 值为1的文件描述符为标准输出, 关闭STDOUT_FILENO后用dup即可返回最小可用值(目前为, 1) 这样输出就重定向到了调用dup的参数指向的文件</p>\n<h3 id=\"创建文件描述符-pipe-dup-dup2-splice\"><a href=\"#创建文件描述符-pipe-dup-dup2-splice\" class=\"headerlink\" title=\"创建文件描述符 - pipe dup dup2 splice\"></a>创建文件描述符 - pipe dup dup2 splice</h3><p><strong>pipe函数</strong><br>这个函数可用于创建一个管道, 实现进程间的通信. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数定义</span></span><br><span class=\"line\"><span class=\"comment\">// 参数文件描述符数组 fd[0] 读出 fd[1]写入 单向管道</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0, 并将一对打开的文件描述符填入其参数指向的数组</span></span><br><span class=\"line\"><span class=\"comment\">// 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe</span><span class=\"params\">(<span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 双向管道</span></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数为 协议PF_UNIX(书上是AF_UNIX)感觉这里指明协议使用PF更好一些</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socketpair</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol, <span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>\n<p>学习了后面的内容了解到了进程间通信, 回来补上一个例子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fds[<span class=\"number\">2</span>];</span><br><span class=\"line\">    socketpair(PF_UNIX, SOCK_STREAM, <span class=\"number\">0</span>, fds);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pid = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(fds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">char</span> a[] = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">        send(fds[<span class=\"number\">1</span>], a, <span class=\"built_in\">strlen</span>(a), <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(fds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">char</span> b[<span class=\"number\">20</span>] &#123;&#125;;</span><br><span class=\"line\">        recv(fds[<span class=\"number\">0</span>], b, <span class=\"number\">20</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>, b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>dup和dup2函数</strong><br>复制一个现有的文件描述符</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 返回的文件描述符总是取系统当前可用的最小整数值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup</span><span class=\"params\">(<span class=\"keyword\">int</span> oldfd)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 可以用newfd来制定新的文件描述符, 如果newfd已经被打开则先关闭</span></span><br><span class=\"line\"><span class=\"comment\">// 如果newfd==oldfd 则不关闭newfd直接返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup2</span><span class=\"params\">(<span class=\"keyword\">int</span> oldfd, <span class=\"keyword\">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>dup函数创建一个新的文件描述符, 新的文件描述符和原有的file_descriptor共同指向相同的目标.<br>回来补上例子, 这个例子由于关掉了<code>STDOUT_FILENO</code>dup最小的即为<code>STDOUT_FILENO</code>所以<br>标准输出都到了这个文件之中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> filefd = <span class=\"built_in\">open</span>(<span class=\"string\">\"/home/lsmg/1.txt\"</span>, O_WRONLY);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(STDOUT_FILENO);</span><br><span class=\"line\">    dup(filefd);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"123\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"读写数据-readv-writev-mmap-munmap\"><a href=\"#读写数据-readv-writev-mmap-munmap\" class=\"headerlink\" title=\"读写数据 - readv writev mmap munmap\"></a>读写数据 - readv writev mmap munmap</h3><p><strong>readv/writev</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/uio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// count 为 vector的长度, 即为有多少块内存</span></span><br><span class=\"line\"><span class=\"comment\">// 成功时返回写入\\读取的长度 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">readv</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> struct iovec* <span class=\"built_in\">vector</span>, <span class=\"keyword\">int</span> count)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">writev</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> struct iovec* <span class=\"built_in\">vector</span>, <span class=\"keyword\">int</span> count)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* iov_base <span class=\"comment\">/* 内存起始地址*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> iov_len <span class=\"comment\">/* 这块内存长度*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>回来补上一个使用例子, 这个例子将一个int的内存表示写入到了文件之中<br>使用hexdump查看这个文件<code>0000000 86a0 0001</code>可以看到<code>186a0</code>即为100000</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2020年1月7日16:52:11</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> file = <span class=\"built_in\">open</span>(<span class=\"string\">\"/home/lsmg/1.txt\"</span>, O_WRONLY);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = <span class=\"number\">100000</span>;</span><br><span class=\"line\">    iovec temp_iovec&#123;&#125;;</span><br><span class=\"line\">    temp_iovec.iov_base = &amp;temp;</span><br><span class=\"line\">    temp_iovec.iov_len = <span class=\"keyword\">sizeof</span>(temp);</span><br><span class=\"line\">    writev(file, &amp;temp_iovec, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>sendfile函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/sendfile.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">sendfile</span><span class=\"params\">(<span class=\"keyword\">int</span> out_fd, <span class=\"keyword\">int</span> in_fd, <span class=\"keyword\">off_t</span>* offset, <span class=\"keyword\">size_t</span> count)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">O_RDONLY只读模式</span><br><span class=\"line\">O_WRONLY只写模式</span><br><span class=\"line\">O_RDWR读写模式</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open</span><span class=\"params\">(file_name, flag)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>stat结构体, 可用fstat生成, <strong>简直就是文件的身份证</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stat</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">dev_t</span>       st_dev;     <span class=\"comment\">/* ID of device containing file -文件所在设备的ID*/</span></span><br><span class=\"line\">    <span class=\"keyword\">ino_t</span>       st_ino;     <span class=\"comment\">/* inode number -inode节点号*/</span></span><br><span class=\"line\">    <span class=\"keyword\">mode_t</span>      st_mode;    <span class=\"comment\">/* protection -保护模式?*/</span></span><br><span class=\"line\">    <span class=\"keyword\">nlink_t</span>     st_nlink;   <span class=\"comment\">/* number of hard links -链向此文件的连接数(硬连接)*/</span></span><br><span class=\"line\">    <span class=\"keyword\">uid_t</span>       st_uid;     <span class=\"comment\">/* user ID of owner -user id*/</span></span><br><span class=\"line\">    <span class=\"keyword\">gid_t</span>       st_gid;     <span class=\"comment\">/* group ID of owner - group id*/</span></span><br><span class=\"line\">    <span class=\"keyword\">dev_t</span>       st_rdev;    <span class=\"comment\">/* device ID (if special file) -设备号，针对设备文件*/</span></span><br><span class=\"line\">    <span class=\"keyword\">off_t</span>       st_size;    <span class=\"comment\">/* total size, in bytes -文件大小，字节为单位*/</span></span><br><span class=\"line\">    <span class=\"keyword\">blksize_t</span>   st_blksize; <span class=\"comment\">/* blocksize for filesystem I/O -系统块的大小*/</span></span><br><span class=\"line\">    <span class=\"keyword\">blkcnt_t</span>    st_blocks;  <span class=\"comment\">/* number of blocks allocated -文件所占块数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span>      st_atime;   <span class=\"comment\">/* time of last access -最近存取时间*/</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span>      st_mtime;   <span class=\"comment\">/* time of last modification -最近修改时间*/</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span>      st_ctime;   <span class=\"comment\">/* time of last status change - */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>身份证</strong>生成函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一个参数需要调用open生成文件描述符</span></span><br><span class=\"line\"><span class=\"comment\">// 下面其他两个为文件全路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fstat</span><span class=\"params\">(<span class=\"keyword\">int</span> filedes, struct stat *buf)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当路径指向为符号链接的时候, lstat为符号链接的信息. stat为符号链接指向文件信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stat</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, struct stat *buf)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lstat</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, struct stat *buf)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* ln -s source dist  建立软连接, 类似快捷方式, 也叫符号链接</span></span><br><span class=\"line\"><span class=\"comment\">* ln source dist  建立硬链接, 同一个文件使用多个不同的别名, 指向同一个文件数据块, 只要硬链接不被完全</span></span><br><span class=\"line\"><span class=\"comment\">* 删除就可以正常访问</span></span><br><span class=\"line\"><span class=\"comment\">* 文件数据块 - 文件的真正数据是一个文件数据块, 打开的`文件`指向这个数据块, 就是说</span></span><br><span class=\"line\"><span class=\"comment\">* `文件`本身就类似快捷方式, 指向文件存在的区域.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p> <strong>mmap和munmap函数</strong></p>\n<p><code>mmap</code>创建一块进程通讯共享的内存(可以将文件映射入其中), <code>munmap</code>释放这块内存</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/mman.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// start 内存起始位置, 如果为NULL则系统分配一个地址 length为长度</span></span><br><span class=\"line\"><span class=\"comment\">// port参数 PROT_READ(可读) PROT_WRITE(可写) PROT_EXEC(可执行), PROT_NONE(不可访问)</span></span><br><span class=\"line\"><span class=\"comment\">// flag参数 内存被修改后的行为</span></span><br><span class=\"line\"><span class=\"comment\">// - MAP_SHARED 进程间共享内存, 对内存的修改反映到映射文件中</span></span><br><span class=\"line\"><span class=\"comment\">// - MAP_PRIVATE 为调用进程私有, 对该内存段的修改不会反映到文件中</span></span><br><span class=\"line\"><span class=\"comment\">// - MAP_ANONUMOUS 不是从文件映射而来, 内容被初始化为0, 最后两个参数被忽略</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回区域指针, 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">mmap</span><span class=\"params\">(<span class=\"keyword\">void</span>* start, <span class=\"keyword\">size_t</span> length, <span class=\"keyword\">int</span> port, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">munmap</span><span class=\"params\">(<span class=\"keyword\">void</span>* start, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><strong>splice函数</strong><br>用于在两个文件名描述符之间移动数据, 0拷贝操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// fd_in 为文件描述符, 如果为管道文件描述符则 off_in必须为NULL, 否则为读取开始偏移位置</span></span><br><span class=\"line\"><span class=\"comment\">// len为指定移动的数据长度, flags参数控制数据如何移动.</span></span><br><span class=\"line\"><span class=\"comment\">// - SPLICE_F_NONBLOCK 非阻塞splice操作, 但会受文件描述符自身的阻塞</span></span><br><span class=\"line\"><span class=\"comment\">// - SPLICE_F_MORE 给内核一个提示, 后续的splice调用将读取更多的数据???????</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">splice</span><span class=\"params\">(<span class=\"keyword\">int</span> fd_in, <span class=\"keyword\">loff_t</span>* off_in, <span class=\"keyword\">int</span> fd_out, <span class=\"keyword\">loff_t</span>* off_out, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用splice函数  实现echo服务器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &lt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"the parmerters is wrong\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(errno);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ip = argv[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> port = atoi(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"the port is %d the ip is %s\\n\"</span>, port, ip);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(sockfd &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">address</span>&#123;</span>&#125;;</span><br><span class=\"line\">    address.sin_family = AF_INET;</span><br><span class=\"line\">    address.sin_port = htons(port);</span><br><span class=\"line\">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = bind(sockfd, (sockaddr*)&amp;address, <span class=\"keyword\">sizeof</span>(address));</span><br><span class=\"line\">    assert(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">listen</span>(sockfd, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> clientfd&#123;&#125;;</span><br><span class=\"line\">    sockaddr_in client_address&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">socklen_t</span> client_addrlen = <span class=\"keyword\">sizeof</span>(client_address);</span><br><span class=\"line\"></span><br><span class=\"line\">    clientfd = accept(sockfd, (sockaddr*)&amp;client_address, &amp;client_addrlen);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clientfd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"accept error\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"a new connection from %s:%d success\\n\"</span>, inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fds[<span class=\"number\">2</span>];</span><br><span class=\"line\">        pipe(fds);</span><br><span class=\"line\">        ret = splice(clientfd, <span class=\"literal\">nullptr</span>, fds[<span class=\"number\">1</span>], <span class=\"literal\">nullptr</span>, <span class=\"number\">32768</span>, SPLICE_F_MORE);</span><br><span class=\"line\">        assert(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = splice(fds[<span class=\"number\">0</span>], <span class=\"literal\">nullptr</span>, clientfd, <span class=\"literal\">nullptr</span>, <span class=\"number\">32768</span>, SPLICE_F_MORE);</span><br><span class=\"line\">        assert(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">close</span>(clientfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第七章Linux服务器程序规范\"><a href=\"#第七章Linux服务器程序规范\" class=\"headerlink\" title=\"第七章Linux服务器程序规范\"></a>第七章Linux服务器程序规范</h2><ul>\n<li>Linux程序服务器 一般以后台进程形式运行.  后台进程又称为守护进程(daemon). 他没有控制终端, 因而不会意外的接收到用户输入. 守护进程的父进程通常都是init进程(PID为1的进程)</li>\n<li>Linux服务器程序有一套日志系统, 他至少能输出日志到文件. 日志这东西太重要了,排错对比全靠它.</li>\n<li>Linux服务器程序一般以某个专门的非root身份运行. 比如mysqld有自己的账户mysql.</li>\n<li>Linux服务器程序一般都有自己的配置文件, 而不是把所有配置都写死在代码里面, 方便后续的更改.</li>\n<li>Linux服务器程序通常在启动的时候生成一个PID文件并存入/var/run 目录中, 以记录改后台进程的PID.</li>\n<li>Linux服务器程序通常需要考虑系统资源和限制, 预测自己的承受能力</li>\n</ul>\n<h3 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service rsyslog restart // 启动守护进程</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;syslog.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// priority参数是所谓的设施值(记录日志信息来源, 默认为LOG_USER)与日志级别的按位或</span></span><br><span class=\"line\"><span class=\"comment\">// - 0 LOG_EMERG  /* 系统不可用*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 1 LOG_ALERT   /* 报警需要立即采取行动*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 2 LOG_CRIT /* 非常严重的情况*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 3 LOG_ERR  /* 错误*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 4 LOG_WARNING /* 警告*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 5 LOG_NOTICE /* 通知*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 6 LOG_INFO /* 信息*/</span></span><br><span class=\"line\"><span class=\"comment\">//  -7 LOG_DEBUG /* 调试*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">syslog</span><span class=\"params\">(<span class=\"keyword\">int</span> priority, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* message, .....)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ident 位于日志的时间后 通常为名字</span></span><br><span class=\"line\"><span class=\"comment\">// logopt 对后续 syslog调用的行为进行配置</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x01 LOG_PID  /* 在日志信息中包含程序PID*/</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x02 LOG_CONS /* 如果信息不能记录到日志文件, 则打印到终端*/</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x04 LOG_ODELAY /* 延迟打开日志功能直到第一次调用syslog*/</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x08 LOG_NDELAY /* 不延迟打开日志功能*/</span></span><br><span class=\"line\"><span class=\"comment\">// facility参数可以修改syslog函数中的默认设施值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">openlog</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* ident, <span class=\"keyword\">int</span> logopt, <span class=\"keyword\">int</span> facility)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// maskpri 一共八位 0000-0000</span></span><br><span class=\"line\"><span class=\"comment\">// 如果将最后一个0置为1 表示 记录0级别的日志</span></span><br><span class=\"line\"><span class=\"comment\">// 如果将最后两个0都置为1 表示记录0和1级别的日志</span></span><br><span class=\"line\"><span class=\"comment\">// 可以通过LOG_MASK() 宏设定 比如LOG_MASK(LOG_CRIT) 表示将倒数第三个0置为1, 表示只记录LOG_CRIT</span></span><br><span class=\"line\"><span class=\"comment\">// 如果直接设置setlogmask(3); 3的二进制最后两个数均为1 则记录 0和1级别的日志</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setlogmask</span><span class=\"params\">(<span class=\"keyword\">int</span> maskpri)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭日志功能</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">closelog</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用户信息-切换用户\"><a href=\"#用户信息-切换用户\" class=\"headerlink\" title=\"用户信息, 切换用户\"></a>用户信息, 切换用户</h3><p>UID - 真实用户ID<br>EUID - 有效用户ID - 方便资源访问<br>GID - 真实组ID<br>EGID - 有效组ID</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uid_t</span> <span class=\"title\">getuid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uid_t</span> <span class=\"title\">geteuid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">gid_t</span> <span class=\"title\">getgid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">gid_t</span> <span class=\"title\">getegid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setuid</span><span class=\"params\">(<span class=\"keyword\">uid_t</span> uid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">seteuid</span><span class=\"params\">(<span class=\"keyword\">uid_t</span> euid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setgid</span><span class=\"params\">(<span class=\"keyword\">gid_t</span> gid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setegid</span><span class=\"params\">(<span class=\"keyword\">gid_t</span> gid)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>可以通过 <code>setuid</code>和<code>setgid</code>切换用户 <strong>root用户uid和gid均为0</strong></p>\n<h3 id=\"进程间关系\"><a href=\"#进程间关系\" class=\"headerlink\" title=\"进程间关系\"></a>进程间关系</h3><p>PGID - 进程组ID(Linux下每个进程隶属于一个进程组)</p>\n<p>#include &lt;unistd.h&gt;<br>pid_t getpgid(pid_t pid); 成功时返回pid所属的pgid 失败返回-1<br>int setpgid(pid_t pid, pid_t pgid);</p>\n<p><strong>会话</strong><br>一些有关联的进程组将形成一个会话<br>略过</p>\n<p><strong>查看进程关系</strong><br>ps和less</p>\n<p><strong>资源限制</strong><br>略<br><strong>改变目录</strong><br>略</p>\n<h2 id=\"第八章高性能服务器程序框架\"><a href=\"#第八章高性能服务器程序框架\" class=\"headerlink\" title=\"第八章高性能服务器程序框架\"></a>第八章高性能服务器程序框架</h2><p><strong>服务器模型-CS模型</strong></p>\n<p><strong>优点</strong></p>\n<ul>\n<li>实现起来简单</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>服务器是通信的中心, 访问过大的时候会导致响应过慢</li>\n</ul>\n<p>模式图<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%BE8-2%20TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png\" alt=\"\"></p>\n<p>编写的demo 没有用到fork函数. 后续待完善</p>\n<p><strong>服务器框架 IO模型</strong></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png\" alt=\"\"></p>\n<p>这个模型大概能够理解, 自己也算是学了半年的Javaweb.</p>\n<p>socket在创建的时候默认是阻塞的, 不过可以通过传<code>SOCK_NONBLOCK</code>参解决<br>非阻塞调用都会立即返回 但可能事件没有发生(recv没有接收到信息), 没有发生和出错都会<code>返回-1</code> 所以需要通过<code>errno</code>来区分这些错误.<br><strong>事件未发生</strong><br>accept, send,recv errno被设置为 <code>EAGAIN(再来一次)</code>或<code>EWOULDBLOCK(期望阻塞)</code><br>connect 被设置为 <code>EINPROGRESS(正在处理中)</code></p>\n<p>需要在事件已经发生的情况下 去调用非阻塞IO, 才能提高性能</p>\n<p>常用IO复用函数 <code>select</code> <code>poll</code> <code>epoll_wait</code> 将在第九章后面说明<br>信号将在第十章说明</p>\n<p><strong>两种高效的事件处理模式和并发模式</strong><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Reactor%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Proactor%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E7%94%A8%E5%90%8C%E6%AD%A5IO%E6%A8%A1%E6%8B%9F%E5%87%BA%E7%9A%84Proactor%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p>程序分为计算密集型(CPU使用很多, IO资源使用很少)和IO密集型(反过来).<br>前者使用并发编程反而会降低效率, 后者则会提升效率<br>并发编程有多进程和多线程两种方式</p>\n<p>并发模式 - IO单元和多个逻辑单元之间协调完成任务的方法.<br>服务器主要有两种并发模式</p>\n<ul>\n<li>半同步/半异步模式</li>\n<li>领导者/追随者模式</li>\n</ul>\n<p><strong>半同步/半异步模式</strong><br>在IO模型中, 异步和同步的区分是内核向应用程序通知的是何种IO事件(就绪事件还是完成事件), 以及由谁来完成IO读写(应用程序还是内核)</p>\n<p>而在这里(并发模式)<br>同步指的是完全按照代码序列的顺序执行 - 按照同步方式运行的线程称为同步线程<br>异步需要系统事件(中断, 信号)来驱动 - 按照异步方式运行的线程称为异步线程<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5.png\" alt=\"\"></p>\n<p>服务器(需要较好的实时性且能同时处理多个客户请求) - 一般使用同步线程和异步线程来实现,即为半同步/半异步模式<br>同步线程 - 处理客户逻辑, 处理请求队列中的对象<br>异步线程 - 处理IO事件, 接收到客户请求后将其封装成请求对象并插入请求队列</p>\n<p>半同步/半异步模式 存在变体 <code>半同步/半反应堆模式</code><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p>异步线程 - 主线程 - 负责监听所有socket上的事件</p>\n<p><strong>领导者/追随者模式</strong><br>略</p>\n<p><strong>高效编程方法 - 有限状态机</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 状态独立的有限状态机</span></span><br><span class=\"line\">STATE_MACHINE(Package _pack) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPackageType _type = _pack.GetType();</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span>(_type) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> type_A:</span><br><span class=\"line\">\t\t\txxxx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> type_B:</span><br><span class=\"line\">\t\t\txxxx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 带状态转移的有限状态机</span></span><br><span class=\"line\">STATE_MACHINE() &#123;</span><br><span class=\"line\">\tState cur_State = type_A;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(cur_State != type_C) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tPackage _pack = getNewPackage();</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span>(cur_State) &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> type_A:</span><br><span class=\"line\">\t\t\t\tprocess_package_state_A(_pack);</span><br><span class=\"line\">\t\t\t\tcur_State = type_B;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> type_B:</span><br><span class=\"line\">\t\t\t\txxxx;</span><br><span class=\"line\">\t\t\t\tcur_State = type_C;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>花了小一个小时 终于一个字母一个字母的抄完了那个5000多字的代码<br>@2019年9月8日22:08:46@</p>\n<h3 id=\"提高服务器性能的其他建议-池-数据复制-上下文切换和锁\"><a href=\"#提高服务器性能的其他建议-池-数据复制-上下文切换和锁\" class=\"headerlink\" title=\"提高服务器性能的其他建议 池 数据复制 上下文切换和锁\"></a>提高服务器性能的其他建议 池 数据复制 上下文切换和锁</h3><p><strong>池</strong> - 用空间换取时间<br>进程池和线程池</p>\n<p><strong>数据复制</strong> - 高性能的服务器应该尽量避免不必要的复制</p>\n<p><strong>上下文切换和锁</strong><br>减少<code>锁</code>的作用区域. 不应该创建太多的工作进程, 而是使用专门的业务逻辑线程.</p>"},{"title":"Linux高性能服务器-高级部分","date":"2019-08-18T12:34:39.000Z","top":101,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg","_content":"# 第九章 I/O复用\n\nI/O复用使得程序能同时监听多个文件描述符.\n- 客户端程序需要同时处理多个socket 非阻塞connect技术\n- 客户端程序同时处理用户输入和网络连接 聊天室程序\n- TCP服务器要同时处理监听socket和连接socket\n- 同时处理TCP和UDP请求 - 回射服务器\n- 同时监听多个端口, 或者处理多种服务 - xinetd服务器\n\n常用手段`select`, `poll`, `epoll`\n\n## select\n\n```c++\n// maxfdp 一般设置为最大描述符+1, 因为这里表示的是数量 而描述符从0开始\n// readfds  需要监视的文件描述符读变化, 其中的文件描述符可读的时候返回\n// writefds 需要监视的文件描述符写变化, 其中的文件描述符可写的时候返回\n// errorfds 错误\n// timeout 传入NULL为阻塞, 设置为0秒0微秒则变为非阻塞函数\n// 返回值 负值为错误 等待超时说明文件无变化返回0 有变化返回正值\nint select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout); \n\n//操作fd_set的宏\nFD_ZERO(fd_set* fdset);\nFD_SET(int fd, fd_set* fdset);\nFD_CLR(int fd, fd_set* fdset);\nFD_ISSET(int fd, fd_set* fdset);\n// 设置 timeval 超时时间\nstruct timeval\n{\n\tlong tv_sec; // 秒\n\tlong tv_usec; // 微秒\n}\n```\n\nstruct fd_set 一个集合,可以存储多个文件描述符\n内部是一个32位整数的数组, 数组第一个元素对应0~31描述符 一个二进制位代表一个描述符\n数组第二个元素对应32~63 以此类推\n\n\n可读条件\n- socket内核接收缓存区中的字节数大于或等于 其低水位标记\n- socket通信的对方关闭连接 读半连接关闭, 对socket的读操作返回0\n- 监听socket上有新的连接请求\n- socket上有未处理的错误, 可以使用getsockopt的SO_ERROR来读取和清除错误 套接字的读操作不阻塞 并返回-1\n\n可写条件\n- socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记, **且套接字已经连接, 或套接字不需要连接UDP**\n- socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号\n- socket使用非阻塞connect 连接成功或失败后\n- socket上有未处理的错误 套接字的写操作不阻塞 并返回-1\n\n异常条件\n- 发送带外数据\n\nselect函数在第二个参数列表 可读的时候返回\n或者是等到了规定的时间返回\n\n返回之后 第二个参数指向fdset的集合 被修改为可读的fd列表\n这就需要每次返回后都更新 fdset集合\n\n返回后 此函数的返回值为可读的fd数量, 遍历fdset集合 同时使用FD_ISSET判断fdset\n 是否在其中\n然后判断此fd是否为listenfd 如果是则接受新的连接 如果不是说明是已经接受的其他fd 判断是有数据可读\n还是此连接断开\n\n## poll\n**poll**\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B1.png)\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B2.png)\n\n```c++\n#include <poll.h>\n// fds 结构体类型数组 指定我们感兴趣的文件描述符上发生的可读可写和异常事件\\\n// nfds 遍历结合大小 左闭右开\n// timeout 单位为毫秒 -1 为阻塞 0 为立即返回\nint poll(struct pollfd* fds, nfds_t nfds, int timeout);\n\nstruct pollfd\n{\n\tint fd;\n\tshort events;  //注册的事件, 告知poll监听fd上的哪些事件\n\tshort revents; // 实际发生的事件\n}\n```\n```c++\n#define exit_if(r, ...) \\\n{   \\\n    if (r)  \\\n    {   \\\n        printf(__VA_ARGS__);    \\\n        printf(\"errno no: %d, error msg is %s\", errno, strerror(errno));    \\\n        exit(1);    \\\n    }   \\\n}   \\\n\nstruct client_info\n{\n    char *ip_;\n    int port_;\n};\n\nint main(int argc, char* argv[])\n{\n    int port = 8001;\n    char ip[] = \"127.0.0.1\";\n\n    struct sockaddr_in address;\n    address.sin_port = htons(port);\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = htons(INADDR_ANY);\n\n    int listenfd = socket(PF_INET, SOCK_STREAM, 0);\n    exit_if(listenfd < 0, \"socket error\\n\");\n\n    int ret = bind(listenfd, (struct sockaddr*)&address, sizeof(address));\n    exit_if(ret == -1, \"bind error\\n\");\n\n    ret = listen(listenfd, 5);\n    exit_if(ret == -1, \"listen error\\n\");\n\n    constexpr int MAX_CLIENTS = 1024;\n    struct pollfd polls[MAX_CLIENTS] = {};\n    struct client_info clientsinfo[MAX_CLIENTS] = {};\n\n    polls[3].fd = listenfd;\n    polls[3].events = POLLIN | POLLRDHUP;\n\n\n    while (true)\n    {\n        ret = poll(polls, MAX_CLIENTS + 1, -1);\n        exit_if(ret == -1, \"poll error\\n\");\n\n        for (int i = 3; i <= MAX_CLIENTS; ++i)\n        {\n            int fd = polls[i].fd;\n\n            if (polls[i].revents & POLLRDHUP)\n            {\n                polls[i].events = 0;\n                printf(\"close fd-%d from %s:%d\\n\", fd, clientsinfo[fd].ip_, clientsinfo[fd].port_);\n            }\n\n            if (polls[i].revents & POLLIN)\n            {\n                if (fd == listenfd)\n                {\n                    struct sockaddr_in client_address;\n                    socklen_t client_addresslen = sizeof(client_address);\n\n                    int clientfd = accept(listenfd, (struct sockaddr*)&client_address,\n                            &client_addresslen);\n\n                    struct client_info *clientinfo = &clientsinfo[clientfd];\n\n                    clientinfo->ip_ = inet_ntoa(client_address.sin_addr);\n                    clientinfo->port_ = ntohs(client_address.sin_port);\n\n                    exit_if(clientfd < 0, \"accpet error, from %s:%d\\n\", clientinfo->ip_,\n                            clientinfo->port_);\n                    printf(\"accept from %s:%d\\n\", clientinfo->ip_, clientinfo->port_);\n\n                    polls[clientfd].fd = clientfd;\n                    polls[clientfd].events = POLLIN | POLLRDHUP;\n                }\n                else\n                {\n                    char buffer[1024];\n                    memset(buffer, '\\0', sizeof(buffer));\n\n                    ret = read(fd, buffer, 1024);\n                    if(ret == 0)\n                    {\n                        close(fd);\n                    }\n                    else\n                    {\n                        printf(\"recv from %s:%d:\\n%s\\n\", clientsinfo[fd].ip_,\n                               clientsinfo[fd].port_, buffer);\n                    }\n                }\n            }\n        }\n    }\n}\n```\n## epoll\n**epoll**\n\nepoll是Linux特有的I/O复用函数, 实现上与select,poll有很大的差异\n- epoll使用一组函数完成任务\n- epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中\n- epoll无需每次调用都传入文件描述符集或事件集.\n\n有特定的文件描述符创建函数, 来标识这个事件表`epoll_create()`\n`epoll_ctl()` 用来操作这个内核事件表\n`epoll_wait()` 为主要函数 成功返回就绪的文件描述符个数 失败返回-1\n如果`epoll_wait()`函数检测到事件,就将所有就绪的事件从内核事件表(由第一个参数, epoll_create返回的结果) 中复制到第二个参数event指向的数组中, 这个数组只用于输出`epoll_wait`检测到的就绪事件.\n\n*event不同于select和poll的数组参数 既用于传入用户注册的事件, 又用于输出内核检测到的就绪事件, 提高了效率*\n\n```c++\n// 索引poll返回的就绪文件描述符\nint ret = poll(fds, MAX_EVENT_NUMBER - 1);\n// 遍历\nfor(int i = 0; i < MAX_EVENT_NUMBER; ++i) {\n\tif(fds[i].revents & POLLIN) {\n\t\tint sockfd = fds[i].fd;\n\t}\n}\n\n// 索引epoll返回的就绪文件描述符\nint ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER,  -1);\nfor(int i = 0; i < ret; i++) {\n\tint sockfd = events[i].data.fd;\n\t// sockfd 一定就绪 ?????\n}\n```\n\n**LT和ET模式**\nLT(电平触发, 默认的工作模式)\nLT模式下的epoll相当于一个效率较高的poll\nepoll_wait将会一只通知一个事件知道这个事件被处理\n\nET(边沿触发, epoll的高效工作模式)模式\n当向epoll内核事件表中注册一个文件描述符上的EPOLLET事件的时候, epoll将用ET模式来操作这个\n文件描述符\nepoll_wait只会通知一次, 不论这个事件有没有完成\n\nET模式\n```\n-> 123456789-123456789-123456789\nevent trigger once\nget 9bytes of content: 123456789\nget 9bytes of content: -12345678\nget 9bytes of content: 9-1234567\nget 4bytes of content: 89\nread later\n```\nLT模式\n```\n-> 123456789-123456789-123456789\nevent trigger once\nget 9bytes of contents: 123456789\nevent trigger once\nget 9bytes of contents: -12345678\nevent trigger once\nget 9bytes of contents: 9-1234567\nevent trigger once\nget 4bytes of contents: 89\n```\nET模式有任务到来就必须做完, 因为后续将不会继续通知这个事件, 所以ET是epoll的高效工作模式\nLT模式只要事件没被处理就会一直通知\n\n```c++\n#include <epoll.h>\n// size 参数只是给内核一个提示, 事件表需要多大\n// 函数返回其他所有epoll系统调用的第一个参数, 来指定要访问的内核事件表\nint epoll_create(int size);\n\n// epfd 为 epoll_create的返回值\n// op为操作类型\n// - EPOLL_CTL_ADD 向事件表中注册fd上的事件\n// - EPOLL_CTL_MOD 修改fd上的注册事件\n// - EPOLL_CTL_DEL 删除fd上的注册事件\n// fd 为要操作的文件描述符\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);\n\nstruct epoll_event\n{\n\t_uint32_t events; // epoll事件\n\tepoll_data_t data; // 用户数据 是一个联合体\n}\n\ntypedef union epoll_data\n{\n\tvoid* ptr; // ptr fd 不能同时使用\n\tint fd;\n\tuint32_t u32;\n\tuint64_t u64;\n}epoll_data_t\n\n// maxevents监听事件数 必须大于0\n// timeout 为-1 表示阻塞\n// 成功返回就绪的文件描述符个数 失败返回-1\nint epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);\n```\n\n## 三种IO复用的比较\n`select`以及`poll`和`epoll`\n相同\n- 都能同时监听多个文件描述符, 都将等待timeout参数指定的超时时间, 直到一个或多个文件描述符上有事件发生.\n- 返回值为就绪的文件描述符数量, 返回0则表示没有事件发生\n- ![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%B8%89%E7%A7%8DIO%E5%A4%8D%E7%94%A8%E6%AF%94%E8%BE%83.png)\n\n## I/O 复用的高级应用, 非阻塞connect\n\nconnect出错的时候会返回一个errno值 EINPROGRESS - 表示对非阻塞socket调用connect, 连接又没有立即建立的时候, 这时可以调用select和poll函数来监听这个连接失败的socket上的可写事件.\n\n当函数返回的时候, 可以用getsockopt来读取错误码, 并清楚该socket上的错误. 错误码为0表示成功\n\n\n# 第十章信号\n\n## Api\n发送信号Api\n```c++\n#include <sys/types.h>\n#include <signal.h>\n\n// pid > 0 发送给PID为pid标识的进程\n//  0 发送给本进程组的其他进程\n// -1 发送给进程以外的所有进程, 但发送者需要有对目标进程发送信号的权限\n// < -1 发送给组ID为 -pid 的进程组中的所有成员\n\n// 出错信息 EINVAL 无效信号, EPERM 该进程没有权限给任何一个目标进程 ESRCH 目标进程(组) 不存在\nint kill(pid_t pid, int sig);\n```\n接收信号Api\n```c++\n#include <signal.h>\ntypedef void(*_sighandler_t) (int);\n\n#include <bits/signum.h> // 此头文件中有所有的linux可用信号\n// 忽略目标信号\n#define SIG_DFL ((_sighandler_t) 0)\n// 使用信号的默认处理方式\n#define SIG_IGN ((_sighandler_t) 1)\n```\n常用信号\n```\nSIGHUP 控制终端挂起\nSIGPIPE 往读端被关闭的管道或者socket连接中写数据\nSIGURG socket连接上收到紧急数据\nSIGALRM 由alarm或setitimer设置的实时闹钟超时引起\nSIGCHLD 子进程状态变化\n```\n信号函数\n```c++\n// 为一个信号设置处理函数\n#include <signal.h>\n// _handler 指定sig的处理函数\n_sighandler_t signal(int sig, __sighandler_t _handler)\n\n\nint sigaction(int sig, struct sigaction* act, struct sigaction* oact)\n```\n## 概述\n\n信号是用户, 系统, 或者进程发送给目标进程的信息, 以通知目标进程某个状态的改变或者系统异常.\n产生条件\n- 对于前台进程\n用户可以通过输入特殊的终端字符来给它发送信号, CTRL+C 通常为一个中断信号 `SIGINT`\n- 系统异常\n浮点异常和非法内存段的访问\n- 系统状态变化\n由alarm定时器到期将引起`SIGALRM`信号\n- 运行kill命令或调用kill函数\n\n*服务器必须处理(至少忽略) 一些常见的信号, 以免异常终止*\n\n中断系统调用?\n\n# 第十一章定时器\n## socket选项`SO_RCVTIMEO` 和 `SO_SNDTIMEO`\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/SO_RCVTIMEO%E5%92%8CSO_SNDTIMEO%E9%80%89%E9%A1%B9%E7%9A%84%E4%BD%9C%E7%94%A8.png)\n\n使用示例, 通过设置对应的SO_SNDTIMEO 得到超时后的路线\n```c++\nint timeout_connect(const char* ip, const int port, const int sec)\n{\n    struct sockaddr_in address{};\n    address.sin_family = AF_INET;\n    address.sin_port = htons(port);\n    address.sin_addr.s_addr = inet_addr(ip);\n\n    int sockfd = socket(PF_INET, SOCK_STREAM, 0);\n    exit_if(sockfd < 0, \"socket error\\n\");\n\n    struct timeval timeout{};\n    timeout.tv_sec = sec;\n    timeout.tv_usec = 0;\n    socklen_t timeout_len = sizeof(timeout);\n\n    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, timeout_len);\n\n    int ret = connect(sockfd, (struct sockaddr*)&address, sizeof(address));\n    if (ret == -1)\n    {\n\t\t// 当 errno为EINPROGRESS 说明 等待了 10S后依然无法连接成功 实现了定时器\n        if (errno == EINPROGRESS)\n        {\n            printf(\"connecting timeout, process timeout logic\\n\");\n            return -1;\n        }\n        printf(\"error occur when connecting to server\\n\");\n        return -1;\n    }\n    return sockfd;\n}\n\nint main(int argc, char* argv[])\n{\n    exit_if(argc <= 2, \"wrong number of parameters\\n\")\n    const char* ip = argv[1];\n    const int port = atoi(argv[2]);\n\n    int sockfd = timeout_connect(ip, port, 10);\n    if (sockfd < 0)\n    {\n        return 1;\n    }\n    return 0;\n}\n```\n\n## SIGALRM信号-基于升序链表的定时器\n由alarm和setitimer函数设定的实时闹钟一旦超时, 将会触发SIGALRM信号, 用信号处理函数处理定时任务\n 相关的代码放在了github上 代码还是很多的就不放上来了[连接](https://github.com/rjd67441/Notes-HighPerformanceLinuxServerProgramming/tree/master/12.%20%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%9511-2%E5%92%8C11-3%E5%8F%8A11-4%20%E9%93%BE%E8%A1%A8%E5%AE%9A%E6%97%B6%E5%99%A8%2C%20%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5)\n\n总结放在了 日记的博客上 链接后面再甩出来\n## IO复用系统调用的超时参数\n\n## 高性能定时器\n## # 时间轮\n## # 时间堆\n\n# 第十二章高性能IO框架库\n另出一篇博客","source":"_posts/读书记录101-高性能服务器编程读书记录高级部分.md","raw":"---\ntitle: Linux高性能服务器-高级部分\ntags:\n  - null\ncategories:\n  - 读书记录\ndate: 2019-08-18 20:34:39\n\ntop: 101\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg\n---\n# 第九章 I/O复用\n\nI/O复用使得程序能同时监听多个文件描述符.\n- 客户端程序需要同时处理多个socket 非阻塞connect技术\n- 客户端程序同时处理用户输入和网络连接 聊天室程序\n- TCP服务器要同时处理监听socket和连接socket\n- 同时处理TCP和UDP请求 - 回射服务器\n- 同时监听多个端口, 或者处理多种服务 - xinetd服务器\n\n常用手段`select`, `poll`, `epoll`\n\n## select\n\n```c++\n// maxfdp 一般设置为最大描述符+1, 因为这里表示的是数量 而描述符从0开始\n// readfds  需要监视的文件描述符读变化, 其中的文件描述符可读的时候返回\n// writefds 需要监视的文件描述符写变化, 其中的文件描述符可写的时候返回\n// errorfds 错误\n// timeout 传入NULL为阻塞, 设置为0秒0微秒则变为非阻塞函数\n// 返回值 负值为错误 等待超时说明文件无变化返回0 有变化返回正值\nint select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout); \n\n//操作fd_set的宏\nFD_ZERO(fd_set* fdset);\nFD_SET(int fd, fd_set* fdset);\nFD_CLR(int fd, fd_set* fdset);\nFD_ISSET(int fd, fd_set* fdset);\n// 设置 timeval 超时时间\nstruct timeval\n{\n\tlong tv_sec; // 秒\n\tlong tv_usec; // 微秒\n}\n```\n\nstruct fd_set 一个集合,可以存储多个文件描述符\n内部是一个32位整数的数组, 数组第一个元素对应0~31描述符 一个二进制位代表一个描述符\n数组第二个元素对应32~63 以此类推\n\n\n可读条件\n- socket内核接收缓存区中的字节数大于或等于 其低水位标记\n- socket通信的对方关闭连接 读半连接关闭, 对socket的读操作返回0\n- 监听socket上有新的连接请求\n- socket上有未处理的错误, 可以使用getsockopt的SO_ERROR来读取和清除错误 套接字的读操作不阻塞 并返回-1\n\n可写条件\n- socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记, **且套接字已经连接, 或套接字不需要连接UDP**\n- socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号\n- socket使用非阻塞connect 连接成功或失败后\n- socket上有未处理的错误 套接字的写操作不阻塞 并返回-1\n\n异常条件\n- 发送带外数据\n\nselect函数在第二个参数列表 可读的时候返回\n或者是等到了规定的时间返回\n\n返回之后 第二个参数指向fdset的集合 被修改为可读的fd列表\n这就需要每次返回后都更新 fdset集合\n\n返回后 此函数的返回值为可读的fd数量, 遍历fdset集合 同时使用FD_ISSET判断fdset\n 是否在其中\n然后判断此fd是否为listenfd 如果是则接受新的连接 如果不是说明是已经接受的其他fd 判断是有数据可读\n还是此连接断开\n\n## poll\n**poll**\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B1.png)\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B2.png)\n\n```c++\n#include <poll.h>\n// fds 结构体类型数组 指定我们感兴趣的文件描述符上发生的可读可写和异常事件\\\n// nfds 遍历结合大小 左闭右开\n// timeout 单位为毫秒 -1 为阻塞 0 为立即返回\nint poll(struct pollfd* fds, nfds_t nfds, int timeout);\n\nstruct pollfd\n{\n\tint fd;\n\tshort events;  //注册的事件, 告知poll监听fd上的哪些事件\n\tshort revents; // 实际发生的事件\n}\n```\n```c++\n#define exit_if(r, ...) \\\n{   \\\n    if (r)  \\\n    {   \\\n        printf(__VA_ARGS__);    \\\n        printf(\"errno no: %d, error msg is %s\", errno, strerror(errno));    \\\n        exit(1);    \\\n    }   \\\n}   \\\n\nstruct client_info\n{\n    char *ip_;\n    int port_;\n};\n\nint main(int argc, char* argv[])\n{\n    int port = 8001;\n    char ip[] = \"127.0.0.1\";\n\n    struct sockaddr_in address;\n    address.sin_port = htons(port);\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = htons(INADDR_ANY);\n\n    int listenfd = socket(PF_INET, SOCK_STREAM, 0);\n    exit_if(listenfd < 0, \"socket error\\n\");\n\n    int ret = bind(listenfd, (struct sockaddr*)&address, sizeof(address));\n    exit_if(ret == -1, \"bind error\\n\");\n\n    ret = listen(listenfd, 5);\n    exit_if(ret == -1, \"listen error\\n\");\n\n    constexpr int MAX_CLIENTS = 1024;\n    struct pollfd polls[MAX_CLIENTS] = {};\n    struct client_info clientsinfo[MAX_CLIENTS] = {};\n\n    polls[3].fd = listenfd;\n    polls[3].events = POLLIN | POLLRDHUP;\n\n\n    while (true)\n    {\n        ret = poll(polls, MAX_CLIENTS + 1, -1);\n        exit_if(ret == -1, \"poll error\\n\");\n\n        for (int i = 3; i <= MAX_CLIENTS; ++i)\n        {\n            int fd = polls[i].fd;\n\n            if (polls[i].revents & POLLRDHUP)\n            {\n                polls[i].events = 0;\n                printf(\"close fd-%d from %s:%d\\n\", fd, clientsinfo[fd].ip_, clientsinfo[fd].port_);\n            }\n\n            if (polls[i].revents & POLLIN)\n            {\n                if (fd == listenfd)\n                {\n                    struct sockaddr_in client_address;\n                    socklen_t client_addresslen = sizeof(client_address);\n\n                    int clientfd = accept(listenfd, (struct sockaddr*)&client_address,\n                            &client_addresslen);\n\n                    struct client_info *clientinfo = &clientsinfo[clientfd];\n\n                    clientinfo->ip_ = inet_ntoa(client_address.sin_addr);\n                    clientinfo->port_ = ntohs(client_address.sin_port);\n\n                    exit_if(clientfd < 0, \"accpet error, from %s:%d\\n\", clientinfo->ip_,\n                            clientinfo->port_);\n                    printf(\"accept from %s:%d\\n\", clientinfo->ip_, clientinfo->port_);\n\n                    polls[clientfd].fd = clientfd;\n                    polls[clientfd].events = POLLIN | POLLRDHUP;\n                }\n                else\n                {\n                    char buffer[1024];\n                    memset(buffer, '\\0', sizeof(buffer));\n\n                    ret = read(fd, buffer, 1024);\n                    if(ret == 0)\n                    {\n                        close(fd);\n                    }\n                    else\n                    {\n                        printf(\"recv from %s:%d:\\n%s\\n\", clientsinfo[fd].ip_,\n                               clientsinfo[fd].port_, buffer);\n                    }\n                }\n            }\n        }\n    }\n}\n```\n## epoll\n**epoll**\n\nepoll是Linux特有的I/O复用函数, 实现上与select,poll有很大的差异\n- epoll使用一组函数完成任务\n- epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中\n- epoll无需每次调用都传入文件描述符集或事件集.\n\n有特定的文件描述符创建函数, 来标识这个事件表`epoll_create()`\n`epoll_ctl()` 用来操作这个内核事件表\n`epoll_wait()` 为主要函数 成功返回就绪的文件描述符个数 失败返回-1\n如果`epoll_wait()`函数检测到事件,就将所有就绪的事件从内核事件表(由第一个参数, epoll_create返回的结果) 中复制到第二个参数event指向的数组中, 这个数组只用于输出`epoll_wait`检测到的就绪事件.\n\n*event不同于select和poll的数组参数 既用于传入用户注册的事件, 又用于输出内核检测到的就绪事件, 提高了效率*\n\n```c++\n// 索引poll返回的就绪文件描述符\nint ret = poll(fds, MAX_EVENT_NUMBER - 1);\n// 遍历\nfor(int i = 0; i < MAX_EVENT_NUMBER; ++i) {\n\tif(fds[i].revents & POLLIN) {\n\t\tint sockfd = fds[i].fd;\n\t}\n}\n\n// 索引epoll返回的就绪文件描述符\nint ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER,  -1);\nfor(int i = 0; i < ret; i++) {\n\tint sockfd = events[i].data.fd;\n\t// sockfd 一定就绪 ?????\n}\n```\n\n**LT和ET模式**\nLT(电平触发, 默认的工作模式)\nLT模式下的epoll相当于一个效率较高的poll\nepoll_wait将会一只通知一个事件知道这个事件被处理\n\nET(边沿触发, epoll的高效工作模式)模式\n当向epoll内核事件表中注册一个文件描述符上的EPOLLET事件的时候, epoll将用ET模式来操作这个\n文件描述符\nepoll_wait只会通知一次, 不论这个事件有没有完成\n\nET模式\n```\n-> 123456789-123456789-123456789\nevent trigger once\nget 9bytes of content: 123456789\nget 9bytes of content: -12345678\nget 9bytes of content: 9-1234567\nget 4bytes of content: 89\nread later\n```\nLT模式\n```\n-> 123456789-123456789-123456789\nevent trigger once\nget 9bytes of contents: 123456789\nevent trigger once\nget 9bytes of contents: -12345678\nevent trigger once\nget 9bytes of contents: 9-1234567\nevent trigger once\nget 4bytes of contents: 89\n```\nET模式有任务到来就必须做完, 因为后续将不会继续通知这个事件, 所以ET是epoll的高效工作模式\nLT模式只要事件没被处理就会一直通知\n\n```c++\n#include <epoll.h>\n// size 参数只是给内核一个提示, 事件表需要多大\n// 函数返回其他所有epoll系统调用的第一个参数, 来指定要访问的内核事件表\nint epoll_create(int size);\n\n// epfd 为 epoll_create的返回值\n// op为操作类型\n// - EPOLL_CTL_ADD 向事件表中注册fd上的事件\n// - EPOLL_CTL_MOD 修改fd上的注册事件\n// - EPOLL_CTL_DEL 删除fd上的注册事件\n// fd 为要操作的文件描述符\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);\n\nstruct epoll_event\n{\n\t_uint32_t events; // epoll事件\n\tepoll_data_t data; // 用户数据 是一个联合体\n}\n\ntypedef union epoll_data\n{\n\tvoid* ptr; // ptr fd 不能同时使用\n\tint fd;\n\tuint32_t u32;\n\tuint64_t u64;\n}epoll_data_t\n\n// maxevents监听事件数 必须大于0\n// timeout 为-1 表示阻塞\n// 成功返回就绪的文件描述符个数 失败返回-1\nint epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);\n```\n\n## 三种IO复用的比较\n`select`以及`poll`和`epoll`\n相同\n- 都能同时监听多个文件描述符, 都将等待timeout参数指定的超时时间, 直到一个或多个文件描述符上有事件发生.\n- 返回值为就绪的文件描述符数量, 返回0则表示没有事件发生\n- ![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%B8%89%E7%A7%8DIO%E5%A4%8D%E7%94%A8%E6%AF%94%E8%BE%83.png)\n\n## I/O 复用的高级应用, 非阻塞connect\n\nconnect出错的时候会返回一个errno值 EINPROGRESS - 表示对非阻塞socket调用connect, 连接又没有立即建立的时候, 这时可以调用select和poll函数来监听这个连接失败的socket上的可写事件.\n\n当函数返回的时候, 可以用getsockopt来读取错误码, 并清楚该socket上的错误. 错误码为0表示成功\n\n\n# 第十章信号\n\n## Api\n发送信号Api\n```c++\n#include <sys/types.h>\n#include <signal.h>\n\n// pid > 0 发送给PID为pid标识的进程\n//  0 发送给本进程组的其他进程\n// -1 发送给进程以外的所有进程, 但发送者需要有对目标进程发送信号的权限\n// < -1 发送给组ID为 -pid 的进程组中的所有成员\n\n// 出错信息 EINVAL 无效信号, EPERM 该进程没有权限给任何一个目标进程 ESRCH 目标进程(组) 不存在\nint kill(pid_t pid, int sig);\n```\n接收信号Api\n```c++\n#include <signal.h>\ntypedef void(*_sighandler_t) (int);\n\n#include <bits/signum.h> // 此头文件中有所有的linux可用信号\n// 忽略目标信号\n#define SIG_DFL ((_sighandler_t) 0)\n// 使用信号的默认处理方式\n#define SIG_IGN ((_sighandler_t) 1)\n```\n常用信号\n```\nSIGHUP 控制终端挂起\nSIGPIPE 往读端被关闭的管道或者socket连接中写数据\nSIGURG socket连接上收到紧急数据\nSIGALRM 由alarm或setitimer设置的实时闹钟超时引起\nSIGCHLD 子进程状态变化\n```\n信号函数\n```c++\n// 为一个信号设置处理函数\n#include <signal.h>\n// _handler 指定sig的处理函数\n_sighandler_t signal(int sig, __sighandler_t _handler)\n\n\nint sigaction(int sig, struct sigaction* act, struct sigaction* oact)\n```\n## 概述\n\n信号是用户, 系统, 或者进程发送给目标进程的信息, 以通知目标进程某个状态的改变或者系统异常.\n产生条件\n- 对于前台进程\n用户可以通过输入特殊的终端字符来给它发送信号, CTRL+C 通常为一个中断信号 `SIGINT`\n- 系统异常\n浮点异常和非法内存段的访问\n- 系统状态变化\n由alarm定时器到期将引起`SIGALRM`信号\n- 运行kill命令或调用kill函数\n\n*服务器必须处理(至少忽略) 一些常见的信号, 以免异常终止*\n\n中断系统调用?\n\n# 第十一章定时器\n## socket选项`SO_RCVTIMEO` 和 `SO_SNDTIMEO`\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/SO_RCVTIMEO%E5%92%8CSO_SNDTIMEO%E9%80%89%E9%A1%B9%E7%9A%84%E4%BD%9C%E7%94%A8.png)\n\n使用示例, 通过设置对应的SO_SNDTIMEO 得到超时后的路线\n```c++\nint timeout_connect(const char* ip, const int port, const int sec)\n{\n    struct sockaddr_in address{};\n    address.sin_family = AF_INET;\n    address.sin_port = htons(port);\n    address.sin_addr.s_addr = inet_addr(ip);\n\n    int sockfd = socket(PF_INET, SOCK_STREAM, 0);\n    exit_if(sockfd < 0, \"socket error\\n\");\n\n    struct timeval timeout{};\n    timeout.tv_sec = sec;\n    timeout.tv_usec = 0;\n    socklen_t timeout_len = sizeof(timeout);\n\n    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, timeout_len);\n\n    int ret = connect(sockfd, (struct sockaddr*)&address, sizeof(address));\n    if (ret == -1)\n    {\n\t\t// 当 errno为EINPROGRESS 说明 等待了 10S后依然无法连接成功 实现了定时器\n        if (errno == EINPROGRESS)\n        {\n            printf(\"connecting timeout, process timeout logic\\n\");\n            return -1;\n        }\n        printf(\"error occur when connecting to server\\n\");\n        return -1;\n    }\n    return sockfd;\n}\n\nint main(int argc, char* argv[])\n{\n    exit_if(argc <= 2, \"wrong number of parameters\\n\")\n    const char* ip = argv[1];\n    const int port = atoi(argv[2]);\n\n    int sockfd = timeout_connect(ip, port, 10);\n    if (sockfd < 0)\n    {\n        return 1;\n    }\n    return 0;\n}\n```\n\n## SIGALRM信号-基于升序链表的定时器\n由alarm和setitimer函数设定的实时闹钟一旦超时, 将会触发SIGALRM信号, 用信号处理函数处理定时任务\n 相关的代码放在了github上 代码还是很多的就不放上来了[连接](https://github.com/rjd67441/Notes-HighPerformanceLinuxServerProgramming/tree/master/12.%20%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%9511-2%E5%92%8C11-3%E5%8F%8A11-4%20%E9%93%BE%E8%A1%A8%E5%AE%9A%E6%97%B6%E5%99%A8%2C%20%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5)\n\n总结放在了 日记的博客上 链接后面再甩出来\n## IO复用系统调用的超时参数\n\n## 高性能定时器\n## # 时间轮\n## # 时间堆\n\n# 第十二章高性能IO框架库\n另出一篇博客","slug":"读书记录101-高性能服务器编程读书记录高级部分","published":1,"updated":"2020-12-05T02:31:35.595Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg74003if8unhq4l2wb5","content":"<h1 id=\"第九章-I-O复用\"><a href=\"#第九章-I-O复用\" class=\"headerlink\" title=\"第九章 I/O复用\"></a>第九章 I/O复用</h1><p>I/O复用使得程序能同时监听多个文件描述符.</p>\n<ul>\n<li>客户端程序需要同时处理多个socket 非阻塞connect技术</li>\n<li>客户端程序同时处理用户输入和网络连接 聊天室程序</li>\n<li>TCP服务器要同时处理监听socket和连接socket</li>\n<li>同时处理TCP和UDP请求 - 回射服务器</li>\n<li>同时监听多个端口, 或者处理多种服务 - xinetd服务器</li>\n</ul>\n<p>常用手段<code>select</code>, <code>poll</code>, <code>epoll</code></p>\n<h2 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// maxfdp 一般设置为最大描述符+1, 因为这里表示的是数量 而描述符从0开始</span></span><br><span class=\"line\"><span class=\"comment\">// readfds  需要监视的文件描述符读变化, 其中的文件描述符可读的时候返回</span></span><br><span class=\"line\"><span class=\"comment\">// writefds 需要监视的文件描述符写变化, 其中的文件描述符可写的时候返回</span></span><br><span class=\"line\"><span class=\"comment\">// errorfds 错误</span></span><br><span class=\"line\"><span class=\"comment\">// timeout 传入NULL为阻塞, 设置为0秒0微秒则变为非阻塞函数</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值 负值为错误 等待超时说明文件无变化返回0 有变化返回正值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">select</span><span class=\"params\">(<span class=\"keyword\">int</span> maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout)</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作fd_set的宏</span></span><br><span class=\"line\">FD_ZERO(fd_set* fdset);</span><br><span class=\"line\">FD_SET(<span class=\"keyword\">int</span> fd, fd_set* fdset);</span><br><span class=\"line\">FD_CLR(<span class=\"keyword\">int</span> fd, fd_set* fdset);</span><br><span class=\"line\">FD_ISSET(<span class=\"keyword\">int</span> fd, fd_set* fdset);</span><br><span class=\"line\"><span class=\"comment\">// 设置 timeval 超时时间</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> tv_sec; <span class=\"comment\">// 秒</span></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> tv_usec; <span class=\"comment\">// 微秒</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>struct fd_set 一个集合,可以存储多个文件描述符<br>内部是一个32位整数的数组, 数组第一个元素对应0<del>31描述符 一个二进制位代表一个描述符<br>数组第二个元素对应32</del>63 以此类推</p>\n<p>可读条件</p>\n<ul>\n<li>socket内核接收缓存区中的字节数大于或等于 其低水位标记</li>\n<li>socket通信的对方关闭连接 读半连接关闭, 对socket的读操作返回0</li>\n<li>监听socket上有新的连接请求</li>\n<li>socket上有未处理的错误, 可以使用getsockopt的SO_ERROR来读取和清除错误 套接字的读操作不阻塞 并返回-1</li>\n</ul>\n<p>可写条件</p>\n<ul>\n<li>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记, <strong>且套接字已经连接, 或套接字不需要连接UDP</strong></li>\n<li>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</li>\n<li>socket使用非阻塞connect 连接成功或失败后</li>\n<li>socket上有未处理的错误 套接字的写操作不阻塞 并返回-1</li>\n</ul>\n<p>异常条件</p>\n<ul>\n<li>发送带外数据</li>\n</ul>\n<p>select函数在第二个参数列表 可读的时候返回<br>或者是等到了规定的时间返回</p>\n<p>返回之后 第二个参数指向fdset的集合 被修改为可读的fd列表<br>这就需要每次返回后都更新 fdset集合</p>\n<p>返回后 此函数的返回值为可读的fd数量, 遍历fdset集合 同时使用FD_ISSET判断fdset<br> 是否在其中<br>然后判断此fd是否为listenfd 如果是则接受新的连接 如果不是说明是已经接受的其他fd 判断是有数据可读<br>还是此连接断开</p>\n<h2 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h2><p><strong>poll</strong><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B1.png\" alt=\"\"><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B2.png\" alt=\"\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;poll.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// fds 结构体类型数组 指定我们感兴趣的文件描述符上发生的可读可写和异常事件\\</span></span><br><span class=\"line\"><span class=\"comment\">// nfds 遍历结合大小 左闭右开</span></span><br><span class=\"line\"><span class=\"comment\">// timeout 单位为毫秒 -1 为阻塞 0 为立即返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">poll</span><span class=\"params\">(struct pollfd* fds, <span class=\"keyword\">nfds_t</span> nfds, <span class=\"keyword\">int</span> timeout)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pollfd</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">\tshort events;  <span class=\"comment\">//注册的事件, 告知poll监听fd上的哪些事件</span></span><br><span class=\"line\">\tshort revents; <span class=\"comment\">// 实际发生的事件</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> exit_if(r, ...) \\</span></span><br><span class=\"line\">&#123;   \\</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r)  \\</span><br><span class=\"line\">    &#123;   \\</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(__VA_ARGS__);    \\</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"errno no: %d, error msg is %s\"</span>, errno, strerror(errno));    \\</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);    \\</span><br><span class=\"line\">    &#125;   \\</span><br><span class=\"line\">&#125;   \\</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">client_info</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ip_;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> port_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> port = <span class=\"number\">8001</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ip[] = <span class=\"string\">\"127.0.0.1\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">address</span>;</span></span><br><span class=\"line\">    address.sin_port = htons(port);</span><br><span class=\"line\">    address.sin_family = AF_INET;</span><br><span class=\"line\">    address.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    exit_if(listenfd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"socket error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = bind(listenfd, (struct sockaddr*)&amp;address, <span class=\"keyword\">sizeof</span>(address));</span><br><span class=\"line\">    exit_if(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"bind error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">listen</span>(listenfd, <span class=\"number\">5</span>);</span><br><span class=\"line\">    exit_if(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"listen error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> MAX_CLIENTS = <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pollfd</span> <span class=\"title\">polls</span>[<span class=\"title\">MAX_CLIENTS</span>] = &#123;</span>&#125;;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">client_info</span> <span class=\"title\">clientsinfo</span>[<span class=\"title\">MAX_CLIENTS</span>] = &#123;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    polls[<span class=\"number\">3</span>].fd = listenfd;</span><br><span class=\"line\">    polls[<span class=\"number\">3</span>].events = POLLIN | POLLRDHUP;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ret = poll(polls, MAX_CLIENTS + <span class=\"number\">1</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">        exit_if(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"poll error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt;= MAX_CLIENTS; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> fd = polls[i].fd;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (polls[i].revents &amp; POLLRDHUP)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                polls[i].events = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"close fd-%d from %s:%d\\n\"</span>, fd, clientsinfo[fd].ip_, clientsinfo[fd].port_);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (polls[i].revents &amp; POLLIN)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (fd == listenfd)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">client_address</span>;</span></span><br><span class=\"line\">                    <span class=\"keyword\">socklen_t</span> client_addresslen = <span class=\"keyword\">sizeof</span>(client_address);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> clientfd = accept(listenfd, (struct sockaddr*)&amp;client_address,</span><br><span class=\"line\">                            &amp;client_addresslen);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">client_info</span> *<span class=\"title\">clientinfo</span> = &amp;<span class=\"title\">clientsinfo</span>[<span class=\"title\">clientfd</span>];</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    clientinfo-&gt;ip_ = inet_ntoa(client_address.sin_addr);</span><br><span class=\"line\">                    clientinfo-&gt;port_ = ntohs(client_address.sin_port);</span><br><span class=\"line\"></span><br><span class=\"line\">                    exit_if(clientfd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"accpet error, from %s:%d\\n\"</span>, clientinfo-&gt;ip_,</span><br><span class=\"line\">                            clientinfo-&gt;port_);</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"accept from %s:%d\\n\"</span>, clientinfo-&gt;ip_, clientinfo-&gt;port_);</span><br><span class=\"line\"></span><br><span class=\"line\">                    polls[clientfd].fd = clientfd;</span><br><span class=\"line\">                    polls[clientfd].events = POLLIN | POLLRDHUP;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">char</span> <span class=\"built_in\">buffer</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">                    <span class=\"built_in\">memset</span>(<span class=\"built_in\">buffer</span>, <span class=\"string\">'\\0'</span>, <span class=\"keyword\">sizeof</span>(<span class=\"built_in\">buffer</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">                    ret = <span class=\"built_in\">read</span>(fd, <span class=\"built_in\">buffer</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(ret == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">\"recv from %s:%d:\\n%s\\n\"</span>, clientsinfo[fd].ip_,</span><br><span class=\"line\">                               clientsinfo[fd].port_, <span class=\"built_in\">buffer</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h2><p><strong>epoll</strong></p>\n<p>epoll是Linux特有的I/O复用函数, 实现上与select,poll有很大的差异</p>\n<ul>\n<li>epoll使用一组函数完成任务</li>\n<li>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中</li>\n<li>epoll无需每次调用都传入文件描述符集或事件集.</li>\n</ul>\n<p>有特定的文件描述符创建函数, 来标识这个事件表<code>epoll_create()</code><br><code>epoll_ctl()</code> 用来操作这个内核事件表<br><code>epoll_wait()</code> 为主要函数 成功返回就绪的文件描述符个数 失败返回-1<br>如果<code>epoll_wait()</code>函数检测到事件,就将所有就绪的事件从内核事件表(由第一个参数, epoll_create返回的结果) 中复制到第二个参数event指向的数组中, 这个数组只用于输出<code>epoll_wait</code>检测到的就绪事件.</p>\n<p><em>event不同于select和poll的数组参数 既用于传入用户注册的事件, 又用于输出内核检测到的就绪事件, 提高了效率</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 索引poll返回的就绪文件描述符</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = poll(fds, MAX_EVENT_NUMBER - <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sockfd = fds[i].fd;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 索引epoll返回的就绪文件描述符</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER,  <span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ret; i++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sockfd = events[i].data.fd;</span><br><span class=\"line\">\t<span class=\"comment\">// sockfd 一定就绪 ?????</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>LT和ET模式</strong><br>LT(电平触发, 默认的工作模式)<br>LT模式下的epoll相当于一个效率较高的poll<br>epoll_wait将会一只通知一个事件知道这个事件被处理</p>\n<p>ET(边沿触发, epoll的高效工作模式)模式<br>当向epoll内核事件表中注册一个文件描述符上的EPOLLET事件的时候, epoll将用ET模式来操作这个<br>文件描述符<br>epoll_wait只会通知一次, 不论这个事件有没有完成</p>\n<p>ET模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; 123456789-123456789-123456789</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of content: 123456789</span><br><span class=\"line\">get 9bytes of content: -12345678</span><br><span class=\"line\">get 9bytes of content: 9-1234567</span><br><span class=\"line\">get 4bytes of content: 89</span><br><span class=\"line\">read later</span><br></pre></td></tr></table></figure>\n<p>LT模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; 123456789-123456789-123456789</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of contents: 123456789</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of contents: -12345678</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of contents: 9-1234567</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 4bytes of contents: 89</span><br></pre></td></tr></table></figure>\n<p>ET模式有任务到来就必须做完, 因为后续将不会继续通知这个事件, 所以ET是epoll的高效工作模式<br>LT模式只要事件没被处理就会一直通知</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;epoll.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// size 参数只是给内核一个提示, 事件表需要多大</span></span><br><span class=\"line\"><span class=\"comment\">// 函数返回其他所有epoll系统调用的第一个参数, 来指定要访问的内核事件表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_create</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">size</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// epfd 为 epoll_create的返回值</span></span><br><span class=\"line\"><span class=\"comment\">// op为操作类型</span></span><br><span class=\"line\"><span class=\"comment\">// - EPOLL_CTL_ADD 向事件表中注册fd上的事件</span></span><br><span class=\"line\"><span class=\"comment\">// - EPOLL_CTL_MOD 修改fd上的注册事件</span></span><br><span class=\"line\"><span class=\"comment\">// - EPOLL_CTL_DEL 删除fd上的注册事件</span></span><br><span class=\"line\"><span class=\"comment\">// fd 为要操作的文件描述符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_ctl</span><span class=\"params\">(<span class=\"keyword\">int</span> epfd, <span class=\"keyword\">int</span> op, <span class=\"keyword\">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">_uint32_t</span> events; <span class=\"comment\">// epoll事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">epoll_data_t</span> data; <span class=\"comment\">// 用户数据 是一个联合体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> epoll_data</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* ptr; <span class=\"comment\">// ptr fd 不能同时使用</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> u32;</span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">&#125;<span class=\"keyword\">epoll_data_t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// maxevents监听事件数 必须大于0</span></span><br><span class=\"line\"><span class=\"comment\">// timeout 为-1 表示阻塞</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回就绪的文件描述符个数 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_wait</span><span class=\"params\">(<span class=\"keyword\">int</span> epfd, struct epoll_event* events, <span class=\"keyword\">int</span> maxevents, <span class=\"keyword\">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三种IO复用的比较\"><a href=\"#三种IO复用的比较\" class=\"headerlink\" title=\"三种IO复用的比较\"></a>三种IO复用的比较</h2><p><code>select</code>以及<code>poll</code>和<code>epoll</code><br>相同</p>\n<ul>\n<li>都能同时监听多个文件描述符, 都将等待timeout参数指定的超时时间, 直到一个或多个文件描述符上有事件发生.</li>\n<li>返回值为就绪的文件描述符数量, 返回0则表示没有事件发生</li>\n<li><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%B8%89%E7%A7%8DIO%E5%A4%8D%E7%94%A8%E6%AF%94%E8%BE%83.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"I-O-复用的高级应用-非阻塞connect\"><a href=\"#I-O-复用的高级应用-非阻塞connect\" class=\"headerlink\" title=\"I/O 复用的高级应用, 非阻塞connect\"></a>I/O 复用的高级应用, 非阻塞connect</h2><p>connect出错的时候会返回一个errno值 EINPROGRESS - 表示对非阻塞socket调用connect, 连接又没有立即建立的时候, 这时可以调用select和poll函数来监听这个连接失败的socket上的可写事件.</p>\n<p>当函数返回的时候, 可以用getsockopt来读取错误码, 并清楚该socket上的错误. 错误码为0表示成功</p>\n<h1 id=\"第十章信号\"><a href=\"#第十章信号\" class=\"headerlink\" title=\"第十章信号\"></a>第十章信号</h1><h2 id=\"Api\"><a href=\"#Api\" class=\"headerlink\" title=\"Api\"></a>Api</h2><p>发送信号Api</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pid &gt; 0 发送给PID为pid标识的进程</span></span><br><span class=\"line\"><span class=\"comment\">//  0 发送给本进程组的其他进程</span></span><br><span class=\"line\"><span class=\"comment\">// -1 发送给进程以外的所有进程, 但发送者需要有对目标进程发送信号的权限</span></span><br><span class=\"line\"><span class=\"comment\">// &lt; -1 发送给组ID为 -pid 的进程组中的所有成员</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出错信息 EINVAL 无效信号, EPERM 该进程没有权限给任何一个目标进程 ESRCH 目标进程(组) 不存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kill</span><span class=\"params\">(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>接收信号Api</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(*<span class=\"keyword\">_sighandler_t</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/signum.h&gt; // 此头文件中有所有的linux可用信号</span></span></span><br><span class=\"line\"><span class=\"comment\">// 忽略目标信号</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIG_DFL ((_sighandler_t) 0)</span></span><br><span class=\"line\"><span class=\"comment\">// 使用信号的默认处理方式</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIG_IGN ((_sighandler_t) 1)</span></span><br></pre></td></tr></table></figure>\n<p>常用信号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SIGHUP 控制终端挂起</span><br><span class=\"line\">SIGPIPE 往读端被关闭的管道或者socket连接中写数据</span><br><span class=\"line\">SIGURG socket连接上收到紧急数据</span><br><span class=\"line\">SIGALRM 由alarm或setitimer设置的实时闹钟超时引起</span><br><span class=\"line\">SIGCHLD 子进程状态变化</span><br></pre></td></tr></table></figure>\n<p>信号函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为一个信号设置处理函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// _handler 指定sig的处理函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">_sighandler_t</span> <span class=\"title\">signal</span><span class=\"params\">(<span class=\"keyword\">int</span> sig, <span class=\"keyword\">__sighandler_t</span> _handler)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sigaction</span><span class=\"params\">(<span class=\"keyword\">int</span> sig, struct sigaction* act, struct sigaction* oact)</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>信号是用户, 系统, 或者进程发送给目标进程的信息, 以通知目标进程某个状态的改变或者系统异常.<br>产生条件</p>\n<ul>\n<li>对于前台进程<br>用户可以通过输入特殊的终端字符来给它发送信号, CTRL+C 通常为一个中断信号 <code>SIGINT</code></li>\n<li>系统异常<br>浮点异常和非法内存段的访问</li>\n<li>系统状态变化<br>由alarm定时器到期将引起<code>SIGALRM</code>信号</li>\n<li>运行kill命令或调用kill函数</li>\n</ul>\n<p><em>服务器必须处理(至少忽略) 一些常见的信号, 以免异常终止</em></p>\n<p>中断系统调用?</p>\n<h1 id=\"第十一章定时器\"><a href=\"#第十一章定时器\" class=\"headerlink\" title=\"第十一章定时器\"></a>第十一章定时器</h1><h2 id=\"socket选项SO-RCVTIMEO-和-SO-SNDTIMEO\"><a href=\"#socket选项SO-RCVTIMEO-和-SO-SNDTIMEO\" class=\"headerlink\" title=\"socket选项SO_RCVTIMEO 和 SO_SNDTIMEO\"></a>socket选项<code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code></h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/SO_RCVTIMEO%E5%92%8CSO_SNDTIMEO%E9%80%89%E9%A1%B9%E7%9A%84%E4%BD%9C%E7%94%A8.png\" alt=\"\"></p>\n<p>使用示例, 通过设置对应的SO_SNDTIMEO 得到超时后的路线</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">timeout_connect</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* ip, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> port, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> sec)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">address</span>&#123;</span>&#125;;</span><br><span class=\"line\">    address.sin_family = AF_INET;</span><br><span class=\"line\">    address.sin_port = htons(port);</span><br><span class=\"line\">    address.sin_addr.s_addr = inet_addr(ip);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    exit_if(sockfd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"socket error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">timeout</span>&#123;</span>&#125;;</span><br><span class=\"line\">    timeout.tv_sec = sec;</span><br><span class=\"line\">    timeout.tv_usec = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">socklen_t</span> timeout_len = <span class=\"keyword\">sizeof</span>(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, timeout_len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"built_in\">connect</span>(sockfd, (struct sockaddr*)&amp;address, <span class=\"keyword\">sizeof</span>(address));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当 errno为EINPROGRESS 说明 等待了 10S后依然无法连接成功 实现了定时器</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINPROGRESS)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"connecting timeout, process timeout logic\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"error occur when connecting to server\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sockfd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    exit_if(argc &lt;= <span class=\"number\">2</span>, <span class=\"string\">\"wrong number of parameters\\n\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* ip = argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> port = atoi(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd = timeout_connect(ip, port, <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sockfd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SIGALRM信号-基于升序链表的定时器\"><a href=\"#SIGALRM信号-基于升序链表的定时器\" class=\"headerlink\" title=\"SIGALRM信号-基于升序链表的定时器\"></a>SIGALRM信号-基于升序链表的定时器</h2><p>由alarm和setitimer函数设定的实时闹钟一旦超时, 将会触发SIGALRM信号, 用信号处理函数处理定时任务<br> 相关的代码放在了github上 代码还是很多的就不放上来了<a href=\"https://github.com/rjd67441/Notes-HighPerformanceLinuxServerProgramming/tree/master/12.%20%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%9511-2%E5%92%8C11-3%E5%8F%8A11-4%20%E9%93%BE%E8%A1%A8%E5%AE%9A%E6%97%B6%E5%99%A8%2C%20%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5\" target=\"_blank\" rel=\"noopener\">连接</a></p>\n<p>总结放在了 日记的博客上 链接后面再甩出来</p>\n<h2 id=\"IO复用系统调用的超时参数\"><a href=\"#IO复用系统调用的超时参数\" class=\"headerlink\" title=\"IO复用系统调用的超时参数\"></a>IO复用系统调用的超时参数</h2><h2 id=\"高性能定时器\"><a href=\"#高性能定时器\" class=\"headerlink\" title=\"高性能定时器\"></a>高性能定时器</h2><h2 id=\"时间轮\"><a href=\"#时间轮\" class=\"headerlink\" title=\"# 时间轮\"></a># 时间轮</h2><h2 id=\"时间堆\"><a href=\"#时间堆\" class=\"headerlink\" title=\"# 时间堆\"></a># 时间堆</h2><h1 id=\"第十二章高性能IO框架库\"><a href=\"#第十二章高性能IO框架库\" class=\"headerlink\" title=\"第十二章高性能IO框架库\"></a>第十二章高性能IO框架库</h1><p>另出一篇博客</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第九章-I-O复用\"><a href=\"#第九章-I-O复用\" class=\"headerlink\" title=\"第九章 I/O复用\"></a>第九章 I/O复用</h1><p>I/O复用使得程序能同时监听多个文件描述符.</p>\n<ul>\n<li>客户端程序需要同时处理多个socket 非阻塞connect技术</li>\n<li>客户端程序同时处理用户输入和网络连接 聊天室程序</li>\n<li>TCP服务器要同时处理监听socket和连接socket</li>\n<li>同时处理TCP和UDP请求 - 回射服务器</li>\n<li>同时监听多个端口, 或者处理多种服务 - xinetd服务器</li>\n</ul>\n<p>常用手段<code>select</code>, <code>poll</code>, <code>epoll</code></p>\n<h2 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// maxfdp 一般设置为最大描述符+1, 因为这里表示的是数量 而描述符从0开始</span></span><br><span class=\"line\"><span class=\"comment\">// readfds  需要监视的文件描述符读变化, 其中的文件描述符可读的时候返回</span></span><br><span class=\"line\"><span class=\"comment\">// writefds 需要监视的文件描述符写变化, 其中的文件描述符可写的时候返回</span></span><br><span class=\"line\"><span class=\"comment\">// errorfds 错误</span></span><br><span class=\"line\"><span class=\"comment\">// timeout 传入NULL为阻塞, 设置为0秒0微秒则变为非阻塞函数</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值 负值为错误 等待超时说明文件无变化返回0 有变化返回正值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">select</span><span class=\"params\">(<span class=\"keyword\">int</span> maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout)</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作fd_set的宏</span></span><br><span class=\"line\">FD_ZERO(fd_set* fdset);</span><br><span class=\"line\">FD_SET(<span class=\"keyword\">int</span> fd, fd_set* fdset);</span><br><span class=\"line\">FD_CLR(<span class=\"keyword\">int</span> fd, fd_set* fdset);</span><br><span class=\"line\">FD_ISSET(<span class=\"keyword\">int</span> fd, fd_set* fdset);</span><br><span class=\"line\"><span class=\"comment\">// 设置 timeval 超时时间</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> tv_sec; <span class=\"comment\">// 秒</span></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> tv_usec; <span class=\"comment\">// 微秒</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>struct fd_set 一个集合,可以存储多个文件描述符<br>内部是一个32位整数的数组, 数组第一个元素对应0<del>31描述符 一个二进制位代表一个描述符<br>数组第二个元素对应32</del>63 以此类推</p>\n<p>可读条件</p>\n<ul>\n<li>socket内核接收缓存区中的字节数大于或等于 其低水位标记</li>\n<li>socket通信的对方关闭连接 读半连接关闭, 对socket的读操作返回0</li>\n<li>监听socket上有新的连接请求</li>\n<li>socket上有未处理的错误, 可以使用getsockopt的SO_ERROR来读取和清除错误 套接字的读操作不阻塞 并返回-1</li>\n</ul>\n<p>可写条件</p>\n<ul>\n<li>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记, <strong>且套接字已经连接, 或套接字不需要连接UDP</strong></li>\n<li>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</li>\n<li>socket使用非阻塞connect 连接成功或失败后</li>\n<li>socket上有未处理的错误 套接字的写操作不阻塞 并返回-1</li>\n</ul>\n<p>异常条件</p>\n<ul>\n<li>发送带外数据</li>\n</ul>\n<p>select函数在第二个参数列表 可读的时候返回<br>或者是等到了规定的时间返回</p>\n<p>返回之后 第二个参数指向fdset的集合 被修改为可读的fd列表<br>这就需要每次返回后都更新 fdset集合</p>\n<p>返回后 此函数的返回值为可读的fd数量, 遍历fdset集合 同时使用FD_ISSET判断fdset<br> 是否在其中<br>然后判断此fd是否为listenfd 如果是则接受新的连接 如果不是说明是已经接受的其他fd 判断是有数据可读<br>还是此连接断开</p>\n<h2 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h2><p><strong>poll</strong><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B1.png\" alt=\"\"><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B2.png\" alt=\"\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;poll.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// fds 结构体类型数组 指定我们感兴趣的文件描述符上发生的可读可写和异常事件\\</span></span><br><span class=\"line\"><span class=\"comment\">// nfds 遍历结合大小 左闭右开</span></span><br><span class=\"line\"><span class=\"comment\">// timeout 单位为毫秒 -1 为阻塞 0 为立即返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">poll</span><span class=\"params\">(struct pollfd* fds, <span class=\"keyword\">nfds_t</span> nfds, <span class=\"keyword\">int</span> timeout)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pollfd</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">\tshort events;  <span class=\"comment\">//注册的事件, 告知poll监听fd上的哪些事件</span></span><br><span class=\"line\">\tshort revents; <span class=\"comment\">// 实际发生的事件</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> exit_if(r, ...) \\</span></span><br><span class=\"line\">&#123;   \\</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r)  \\</span><br><span class=\"line\">    &#123;   \\</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(__VA_ARGS__);    \\</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"errno no: %d, error msg is %s\"</span>, errno, strerror(errno));    \\</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);    \\</span><br><span class=\"line\">    &#125;   \\</span><br><span class=\"line\">&#125;   \\</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">client_info</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ip_;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> port_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> port = <span class=\"number\">8001</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ip[] = <span class=\"string\">\"127.0.0.1\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">address</span>;</span></span><br><span class=\"line\">    address.sin_port = htons(port);</span><br><span class=\"line\">    address.sin_family = AF_INET;</span><br><span class=\"line\">    address.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    exit_if(listenfd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"socket error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = bind(listenfd, (struct sockaddr*)&amp;address, <span class=\"keyword\">sizeof</span>(address));</span><br><span class=\"line\">    exit_if(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"bind error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">listen</span>(listenfd, <span class=\"number\">5</span>);</span><br><span class=\"line\">    exit_if(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"listen error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> MAX_CLIENTS = <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pollfd</span> <span class=\"title\">polls</span>[<span class=\"title\">MAX_CLIENTS</span>] = &#123;</span>&#125;;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">client_info</span> <span class=\"title\">clientsinfo</span>[<span class=\"title\">MAX_CLIENTS</span>] = &#123;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    polls[<span class=\"number\">3</span>].fd = listenfd;</span><br><span class=\"line\">    polls[<span class=\"number\">3</span>].events = POLLIN | POLLRDHUP;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ret = poll(polls, MAX_CLIENTS + <span class=\"number\">1</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">        exit_if(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"poll error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt;= MAX_CLIENTS; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> fd = polls[i].fd;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (polls[i].revents &amp; POLLRDHUP)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                polls[i].events = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"close fd-%d from %s:%d\\n\"</span>, fd, clientsinfo[fd].ip_, clientsinfo[fd].port_);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (polls[i].revents &amp; POLLIN)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (fd == listenfd)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">client_address</span>;</span></span><br><span class=\"line\">                    <span class=\"keyword\">socklen_t</span> client_addresslen = <span class=\"keyword\">sizeof</span>(client_address);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> clientfd = accept(listenfd, (struct sockaddr*)&amp;client_address,</span><br><span class=\"line\">                            &amp;client_addresslen);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">client_info</span> *<span class=\"title\">clientinfo</span> = &amp;<span class=\"title\">clientsinfo</span>[<span class=\"title\">clientfd</span>];</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    clientinfo-&gt;ip_ = inet_ntoa(client_address.sin_addr);</span><br><span class=\"line\">                    clientinfo-&gt;port_ = ntohs(client_address.sin_port);</span><br><span class=\"line\"></span><br><span class=\"line\">                    exit_if(clientfd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"accpet error, from %s:%d\\n\"</span>, clientinfo-&gt;ip_,</span><br><span class=\"line\">                            clientinfo-&gt;port_);</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"accept from %s:%d\\n\"</span>, clientinfo-&gt;ip_, clientinfo-&gt;port_);</span><br><span class=\"line\"></span><br><span class=\"line\">                    polls[clientfd].fd = clientfd;</span><br><span class=\"line\">                    polls[clientfd].events = POLLIN | POLLRDHUP;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">char</span> <span class=\"built_in\">buffer</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">                    <span class=\"built_in\">memset</span>(<span class=\"built_in\">buffer</span>, <span class=\"string\">'\\0'</span>, <span class=\"keyword\">sizeof</span>(<span class=\"built_in\">buffer</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">                    ret = <span class=\"built_in\">read</span>(fd, <span class=\"built_in\">buffer</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(ret == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">\"recv from %s:%d:\\n%s\\n\"</span>, clientsinfo[fd].ip_,</span><br><span class=\"line\">                               clientsinfo[fd].port_, <span class=\"built_in\">buffer</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h2><p><strong>epoll</strong></p>\n<p>epoll是Linux特有的I/O复用函数, 实现上与select,poll有很大的差异</p>\n<ul>\n<li>epoll使用一组函数完成任务</li>\n<li>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中</li>\n<li>epoll无需每次调用都传入文件描述符集或事件集.</li>\n</ul>\n<p>有特定的文件描述符创建函数, 来标识这个事件表<code>epoll_create()</code><br><code>epoll_ctl()</code> 用来操作这个内核事件表<br><code>epoll_wait()</code> 为主要函数 成功返回就绪的文件描述符个数 失败返回-1<br>如果<code>epoll_wait()</code>函数检测到事件,就将所有就绪的事件从内核事件表(由第一个参数, epoll_create返回的结果) 中复制到第二个参数event指向的数组中, 这个数组只用于输出<code>epoll_wait</code>检测到的就绪事件.</p>\n<p><em>event不同于select和poll的数组参数 既用于传入用户注册的事件, 又用于输出内核检测到的就绪事件, 提高了效率</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 索引poll返回的就绪文件描述符</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = poll(fds, MAX_EVENT_NUMBER - <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sockfd = fds[i].fd;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 索引epoll返回的就绪文件描述符</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER,  <span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ret; i++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sockfd = events[i].data.fd;</span><br><span class=\"line\">\t<span class=\"comment\">// sockfd 一定就绪 ?????</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>LT和ET模式</strong><br>LT(电平触发, 默认的工作模式)<br>LT模式下的epoll相当于一个效率较高的poll<br>epoll_wait将会一只通知一个事件知道这个事件被处理</p>\n<p>ET(边沿触发, epoll的高效工作模式)模式<br>当向epoll内核事件表中注册一个文件描述符上的EPOLLET事件的时候, epoll将用ET模式来操作这个<br>文件描述符<br>epoll_wait只会通知一次, 不论这个事件有没有完成</p>\n<p>ET模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; 123456789-123456789-123456789</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of content: 123456789</span><br><span class=\"line\">get 9bytes of content: -12345678</span><br><span class=\"line\">get 9bytes of content: 9-1234567</span><br><span class=\"line\">get 4bytes of content: 89</span><br><span class=\"line\">read later</span><br></pre></td></tr></table></figure>\n<p>LT模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; 123456789-123456789-123456789</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of contents: 123456789</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of contents: -12345678</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of contents: 9-1234567</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 4bytes of contents: 89</span><br></pre></td></tr></table></figure>\n<p>ET模式有任务到来就必须做完, 因为后续将不会继续通知这个事件, 所以ET是epoll的高效工作模式<br>LT模式只要事件没被处理就会一直通知</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;epoll.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// size 参数只是给内核一个提示, 事件表需要多大</span></span><br><span class=\"line\"><span class=\"comment\">// 函数返回其他所有epoll系统调用的第一个参数, 来指定要访问的内核事件表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_create</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">size</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// epfd 为 epoll_create的返回值</span></span><br><span class=\"line\"><span class=\"comment\">// op为操作类型</span></span><br><span class=\"line\"><span class=\"comment\">// - EPOLL_CTL_ADD 向事件表中注册fd上的事件</span></span><br><span class=\"line\"><span class=\"comment\">// - EPOLL_CTL_MOD 修改fd上的注册事件</span></span><br><span class=\"line\"><span class=\"comment\">// - EPOLL_CTL_DEL 删除fd上的注册事件</span></span><br><span class=\"line\"><span class=\"comment\">// fd 为要操作的文件描述符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_ctl</span><span class=\"params\">(<span class=\"keyword\">int</span> epfd, <span class=\"keyword\">int</span> op, <span class=\"keyword\">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">_uint32_t</span> events; <span class=\"comment\">// epoll事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">epoll_data_t</span> data; <span class=\"comment\">// 用户数据 是一个联合体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> epoll_data</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* ptr; <span class=\"comment\">// ptr fd 不能同时使用</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> u32;</span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">&#125;<span class=\"keyword\">epoll_data_t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// maxevents监听事件数 必须大于0</span></span><br><span class=\"line\"><span class=\"comment\">// timeout 为-1 表示阻塞</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回就绪的文件描述符个数 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_wait</span><span class=\"params\">(<span class=\"keyword\">int</span> epfd, struct epoll_event* events, <span class=\"keyword\">int</span> maxevents, <span class=\"keyword\">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三种IO复用的比较\"><a href=\"#三种IO复用的比较\" class=\"headerlink\" title=\"三种IO复用的比较\"></a>三种IO复用的比较</h2><p><code>select</code>以及<code>poll</code>和<code>epoll</code><br>相同</p>\n<ul>\n<li>都能同时监听多个文件描述符, 都将等待timeout参数指定的超时时间, 直到一个或多个文件描述符上有事件发生.</li>\n<li>返回值为就绪的文件描述符数量, 返回0则表示没有事件发生</li>\n<li><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%B8%89%E7%A7%8DIO%E5%A4%8D%E7%94%A8%E6%AF%94%E8%BE%83.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"I-O-复用的高级应用-非阻塞connect\"><a href=\"#I-O-复用的高级应用-非阻塞connect\" class=\"headerlink\" title=\"I/O 复用的高级应用, 非阻塞connect\"></a>I/O 复用的高级应用, 非阻塞connect</h2><p>connect出错的时候会返回一个errno值 EINPROGRESS - 表示对非阻塞socket调用connect, 连接又没有立即建立的时候, 这时可以调用select和poll函数来监听这个连接失败的socket上的可写事件.</p>\n<p>当函数返回的时候, 可以用getsockopt来读取错误码, 并清楚该socket上的错误. 错误码为0表示成功</p>\n<h1 id=\"第十章信号\"><a href=\"#第十章信号\" class=\"headerlink\" title=\"第十章信号\"></a>第十章信号</h1><h2 id=\"Api\"><a href=\"#Api\" class=\"headerlink\" title=\"Api\"></a>Api</h2><p>发送信号Api</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pid &gt; 0 发送给PID为pid标识的进程</span></span><br><span class=\"line\"><span class=\"comment\">//  0 发送给本进程组的其他进程</span></span><br><span class=\"line\"><span class=\"comment\">// -1 发送给进程以外的所有进程, 但发送者需要有对目标进程发送信号的权限</span></span><br><span class=\"line\"><span class=\"comment\">// &lt; -1 发送给组ID为 -pid 的进程组中的所有成员</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出错信息 EINVAL 无效信号, EPERM 该进程没有权限给任何一个目标进程 ESRCH 目标进程(组) 不存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kill</span><span class=\"params\">(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>接收信号Api</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(*<span class=\"keyword\">_sighandler_t</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/signum.h&gt; // 此头文件中有所有的linux可用信号</span></span></span><br><span class=\"line\"><span class=\"comment\">// 忽略目标信号</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIG_DFL ((_sighandler_t) 0)</span></span><br><span class=\"line\"><span class=\"comment\">// 使用信号的默认处理方式</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIG_IGN ((_sighandler_t) 1)</span></span><br></pre></td></tr></table></figure>\n<p>常用信号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SIGHUP 控制终端挂起</span><br><span class=\"line\">SIGPIPE 往读端被关闭的管道或者socket连接中写数据</span><br><span class=\"line\">SIGURG socket连接上收到紧急数据</span><br><span class=\"line\">SIGALRM 由alarm或setitimer设置的实时闹钟超时引起</span><br><span class=\"line\">SIGCHLD 子进程状态变化</span><br></pre></td></tr></table></figure>\n<p>信号函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为一个信号设置处理函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// _handler 指定sig的处理函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">_sighandler_t</span> <span class=\"title\">signal</span><span class=\"params\">(<span class=\"keyword\">int</span> sig, <span class=\"keyword\">__sighandler_t</span> _handler)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sigaction</span><span class=\"params\">(<span class=\"keyword\">int</span> sig, struct sigaction* act, struct sigaction* oact)</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>信号是用户, 系统, 或者进程发送给目标进程的信息, 以通知目标进程某个状态的改变或者系统异常.<br>产生条件</p>\n<ul>\n<li>对于前台进程<br>用户可以通过输入特殊的终端字符来给它发送信号, CTRL+C 通常为一个中断信号 <code>SIGINT</code></li>\n<li>系统异常<br>浮点异常和非法内存段的访问</li>\n<li>系统状态变化<br>由alarm定时器到期将引起<code>SIGALRM</code>信号</li>\n<li>运行kill命令或调用kill函数</li>\n</ul>\n<p><em>服务器必须处理(至少忽略) 一些常见的信号, 以免异常终止</em></p>\n<p>中断系统调用?</p>\n<h1 id=\"第十一章定时器\"><a href=\"#第十一章定时器\" class=\"headerlink\" title=\"第十一章定时器\"></a>第十一章定时器</h1><h2 id=\"socket选项SO-RCVTIMEO-和-SO-SNDTIMEO\"><a href=\"#socket选项SO-RCVTIMEO-和-SO-SNDTIMEO\" class=\"headerlink\" title=\"socket选项SO_RCVTIMEO 和 SO_SNDTIMEO\"></a>socket选项<code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code></h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/SO_RCVTIMEO%E5%92%8CSO_SNDTIMEO%E9%80%89%E9%A1%B9%E7%9A%84%E4%BD%9C%E7%94%A8.png\" alt=\"\"></p>\n<p>使用示例, 通过设置对应的SO_SNDTIMEO 得到超时后的路线</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">timeout_connect</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* ip, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> port, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> sec)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">address</span>&#123;</span>&#125;;</span><br><span class=\"line\">    address.sin_family = AF_INET;</span><br><span class=\"line\">    address.sin_port = htons(port);</span><br><span class=\"line\">    address.sin_addr.s_addr = inet_addr(ip);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    exit_if(sockfd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"socket error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">timeout</span>&#123;</span>&#125;;</span><br><span class=\"line\">    timeout.tv_sec = sec;</span><br><span class=\"line\">    timeout.tv_usec = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">socklen_t</span> timeout_len = <span class=\"keyword\">sizeof</span>(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, timeout_len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"built_in\">connect</span>(sockfd, (struct sockaddr*)&amp;address, <span class=\"keyword\">sizeof</span>(address));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当 errno为EINPROGRESS 说明 等待了 10S后依然无法连接成功 实现了定时器</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINPROGRESS)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"connecting timeout, process timeout logic\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"error occur when connecting to server\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sockfd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    exit_if(argc &lt;= <span class=\"number\">2</span>, <span class=\"string\">\"wrong number of parameters\\n\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* ip = argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> port = atoi(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd = timeout_connect(ip, port, <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sockfd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SIGALRM信号-基于升序链表的定时器\"><a href=\"#SIGALRM信号-基于升序链表的定时器\" class=\"headerlink\" title=\"SIGALRM信号-基于升序链表的定时器\"></a>SIGALRM信号-基于升序链表的定时器</h2><p>由alarm和setitimer函数设定的实时闹钟一旦超时, 将会触发SIGALRM信号, 用信号处理函数处理定时任务<br> 相关的代码放在了github上 代码还是很多的就不放上来了<a href=\"https://github.com/rjd67441/Notes-HighPerformanceLinuxServerProgramming/tree/master/12.%20%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%9511-2%E5%92%8C11-3%E5%8F%8A11-4%20%E9%93%BE%E8%A1%A8%E5%AE%9A%E6%97%B6%E5%99%A8%2C%20%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5\" target=\"_blank\" rel=\"noopener\">连接</a></p>\n<p>总结放在了 日记的博客上 链接后面再甩出来</p>\n<h2 id=\"IO复用系统调用的超时参数\"><a href=\"#IO复用系统调用的超时参数\" class=\"headerlink\" title=\"IO复用系统调用的超时参数\"></a>IO复用系统调用的超时参数</h2><h2 id=\"高性能定时器\"><a href=\"#高性能定时器\" class=\"headerlink\" title=\"高性能定时器\"></a>高性能定时器</h2><h2 id=\"时间轮\"><a href=\"#时间轮\" class=\"headerlink\" title=\"# 时间轮\"></a># 时间轮</h2><h2 id=\"时间堆\"><a href=\"#时间堆\" class=\"headerlink\" title=\"# 时间堆\"></a># 时间堆</h2><h1 id=\"第十二章高性能IO框架库\"><a href=\"#第十二章高性能IO框架库\" class=\"headerlink\" title=\"第十二章高性能IO框架库\"></a>第十二章高性能IO框架库</h1><p>另出一篇博客</p>\n"},{"title":"Effective读书记录","date":"2020-02-26T13:43:46.000Z","top":110,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Effective%20C%2B%2B/%E5%B0%81%E9%9D%A2.jpg","_content":"\n# 让自己习惯C++\n## 条款02 尽量用const, enum, inline 替换#define\n前言 我目前自己做的框架中大量用了#define.... 因为用enum涉及到转换才能到int. 来学习下这条\n\n**使用 const 常量来替换 #define**\n谨防机号表出错, 特殊情况下 还能减少字量\n\n#define无法限定作用域, 这点我已经感受到了\n\n定义C风格常量字符串\nconst char* const NAME = \"lsmg\"; 防止指向和指向内容改变\n定义C++风格常量字符串\nconst std::string NAME = \"lsmg\";\n\nclass专属常量, 使用如下方式. 可以限定作用域\n```c++\nclass Game\n{\nprivate:\n\tstatic const int MAX_ROOM = 10000; // 常量声明式 - 常量且只有一份\n\tGameroom* rooms[MAX_ROOM];\n}\n```\n如果要获取class专属常量的地址, 或者需要定义式. 则需要在`实现文件`而非`头文件`, 如下声明\n`const int Game::MAX_ROOM` - 未给定初值\n由于class常量已经在声明时获得初值, 所以不用在给定初值\n\n这里我发现一件事情, 这本书 不能只读一遍, 最少两边完整的\n前面就已经开始使用后面的条款了, 先着重本条款, 跨条款的等第二遍\n\n\n## 条款03 尽可能使用const\n**总结**\n- 将某些东西声明为const可帮助编译器探测到错误用法\nconst可以用作在任何作用域内的对象, 函数参数, 函数返回类型, 成员函数本体\n\n\n```c++\nchar greeting[] = \"Hello\";\nchar *p = greeting;\n// const 在 * 左边 被指物是常量 在右边自己是常量 两边都是常量\nconst char *p = greeting; // 指针指向可以变, 指向的值不能变\nchar* const p = greeting; // 指针指向不可以变, 指向的值可以变\nconst char* const p = greeting; // 都不可以变\n```\n**const 参数, 可你帮你检查 == 被写成=的情况**\n这本书看来挺有意思的2333333\n\n**const 函数, 这里看不太懂 没有原来如此的感觉**\n\n## 条款04 确定对象使用前已经被初始化\n**总结**\n- 为内置型对象进行手工初始化.\n- 构造函数最好使用成员初值列, 不要在构造函数中赋值. 初值列次数应该与声明次序相同\n- 为了免除 跨编译单元的初始化次数问题, 用`local static`对象替换`non-local static`对象\n\n永远在使用对象前, 进行初始化.\n在构造函数中, 对所有值进行初始化\n构造函数使用`成员初始列`进行`初始化操作`而非`赋值操作`\n\n\n**减少default构造函数不必要的调用**\n```c++\nClass A\n{\npublic:\n\tA(const std::string &name, const std::list<Gameroom> &room_list);\nprivate:\n\tstd::string name_;\n\tstd::list<Gameroom> room_list_;\n\tint roomnum_;\n}\n\nA::A(const std::string &name, const std::list<Gameroom> &room_list)\n{\n\tname_ = name; // 这些都是赋值 不是初始化\n\troom_list_ = room_list;\n\troomnum_ = 0;\n}\n// C++规定 对象的 成员变量  初始化动作  发生在  进入构造函数本体  之前\n// name_  room_list_  两个在构造函数中被赋值, 而初始化在进入构造函数之前\n// ---发生在这些成员的default构造函数被调用的时候, (发生在进入构造函数前)\n// ---roomnum_例外 int属于内置类型\n\n```\n上面的初始化方式, 浪费了default的构造函数 所以推荐使用下面的形式\n```c++\nA::A(const std::string &name, const std::list<Gameroom> &room_list)\n\t:name_(name), room_list_(room_list), roomnum_(0)\n{\n}\n```\n虽然最终结果相同, 但没有浪费default构造函数. 前两个调用的copy构造函数.\n\n**还可以使用成员初值列 来default构造一个成员变量.**\n```c++\nA::A()\n\t:name_(), room_list_(), roomnum_(0)\n{ // 前两个全部调用的default构造函数\n}\n```\n\n**const reference 内置类型(初始化与赋值等成本) 一定成员初始值列**\n\n**初始值列总是使用 声明次序进行初始化, 而非写的顺序, 所以最好按声明次序列出**\n\n**不同编译单元内定义之 non-local static对象 的初始化 次序**\nstatic对象: 虚构函数会在main() 结束时被自动调用\nlocal static对象: 函数内的static对象\nnon-local对象: 其他static对象\n\n编译单元: 产出单一目标文件的那些源码, 基本是单一源码文件和他包含的头文件\n\n```c++\n// filesystem.h\nclass FileSystem\n{\npublic:\n\tsize_t GetNum() const;\n};\nextern FIieSystem tfs; // 声明\n\n// filesystem.cpp\nFIieSystem tfs; //定义\n\n// directory.h\nclass Directory\n{\npublic:\n\tDirectory(params);\t\n}\nDirectory::Directory(params)\n{\n\tsize_t num = tfs.GetNum(); // 使用tfs对象\n}\n\n// main.cpp\nDirectory temp_dir(params);\n```\n只有当 tfs在temp_dir初始化之前被初始化 才能得到正确的结果. 否则会调用未初始化的对象\n\n但是这个次序无法保证, tfs和tempdir是不同的人在不同的时间于不同的源码文件建立起来的\n因为C++ 对这种情况没有明确定义\n\n如何解决这个问题呢??\n将每个`non-local static`对象搬到自己的专属函数内(该对象在此函数内被声明为static)\n函数返回一个reference对象他所包含的对象\n用户调用这个函数而不是直接调用对象\n\n解决的原因呢?\nC++ 保证函数内的`local static`对象 会在`函数被调用期间`, `首次遇到该对象的定义式`被初始化\n\n```c++\n// filesystem.h\nclass FileSystem\n{\npublic:\n\tstd::size_t GetNum() const;\n}\nFileSystem& tfs()\n{\n\tstatic FileSystem fs;\n\treturn fs;\n}\n\n// directory.h\nclass Directory\n{\npublic:\n\tDirectory(params);\t\n}\nDirectory::Directory(params)\n{\n\tstd::size_t num = tfs().GetNum(); // 使用tfs对象\n}\nDirectory& temp_dir()\n{\n\tstatic Directory td;\n\treturn td;\n}\n```\n# 构造析构赋值运算\n## 条款0506 了解C++默认编写并调用哪些函数 并适当拒绝\n\n**夹带如下私货-public-inline**\n- 一个构造函数(如果你没有任何构造函数)\n- 一个拷贝构造函数\n- 一个析构函数\n- 一个拷贝\n\n拷贝构造函数和拷贝运算符 自动生成的只是单纯的将来源对象的每一个`non-static`成员变量\n拷贝到目标对象\n\n**遇到const 和 引用成员 默认的拷贝无法工作, 编译器会发出警告**\n\n**将不需要的成员函数声明为private, 并且不实现**\n\n## 条款07 为多态基类声明virtual析构函数\n返回指向子类的 父类型指针.\n如果delete这个指针, 在父类析构函数不是virtual的情况下, 很可能会导致\n父类的成分被销毁, 然而子类多出来的部分不被销毁. 造成局部销毁!!\n\n**防止局部销毁很简单, 将父类的析构函数声明为virtual**\n\n**任何class 只要带有virtual函数 几乎确定应该有一个virtual析构函数**\n\n**无端的声明virtual函数是错误的**\n如果class不含virtual函数, 通常表示这个class 不是想做为父类, 这时如果将其析构函数声明为virual\n是一个馊主意.............\n\n*class类的大小 = 成员变量占据大小 + vptr(vitual table pointer)指针大小(4~8 字节)*\n\n每一个带有virtual函数的class都有对应的vtbl\n\n当对象调用某一vitual函数的时候, 实际调用的函数取决于\nvptr(vitual table pointer)指针指向的vtbl(vitual table)\n\n无端的使用virtual函数 会导致占用空间的增大\n\n## 条款08 别让异常逃离析构函数\n\n**总结**\n- 析构函数绝对不要抛出异常, 如果被析构函数调用的函数可能抛出异常, 析构函数应该捕获所有异常\n然后吞下它们, 或者结束程序\n- 如果客户需要对某个操作函数运行期间抛出的异常做出反应, class应该提供一个普通函数(而非在析构函数中)\n执行操作\n\n**析构函数不要抛出异常**\n```c++\nclass Widget\n{\n\t...\n\t~Widget() {...}\n}\n\nvoid Foo()\n{\n\tstd::vector<Widget> v;\n}\n```\n当 `v`被销毁的时候, Widget的析构函数第一次抛出异常C++还能接受?\n第二次就会造成不明确行为\n\n## 条款09: 绝不在构造函数和析构过程中调用virtual函数\n**总结**\n- 在构造和析构期间不要调用virtual函数, 因为这类调用从不下降到`子类`\n\n```c++\nclass Transaction\n{\npublic:\n\tTransaction();\n\tvirtual void LogTransaction() const = 0;\n\t...\n}\nTransaction::Transaction()\n{\n\t...\n\tLogTransaction();\n}\n\nclass BuyTransaction: public Transaction\n{\npublic:\n\tvirtual void LogTransaction() const;\n\t...\n}\n\nclass SellTransaction: public Transaction\n{\npublic:\n\tvirtual void LogTransaction() const;\n\t...\n}\n\nBuyTransaction b;\n```\nBuyTransaction的构造函数会被调用, 但是父类的构造函数会更显被调用.\n然后父类构造函数调用`LogTransaction()`的版本是`父类`的版本!!! 不是子类的版本\n\n析构函数也是同样的道理, 当`子类`的析构函数执行后, `子类`中的属性值就成为未定义状态\n进入`父类`后对象就成为一个`父类`对象\n\n本例子中既然无法实现使用`virtual`函数从`父类`向下调用, 可以再构造期间, 将\n`子类`必要的构造信息向上传给`父类`的构造函数\n\n## 条款10: 另operator= 返回一个reference to *this\n\n注意这只是一个协议, 并无强制性. 如果不遵守代码依然可以通过编译, 然而这份 协议被所有内置类型\n和标准程序库提供的类型共同遵守.\n因此除非你有一个标新立异的好理由, 不然还是随众吧\n\n## 条款11: 在operator= 中处理\"自我赋值\"\n**总结**\n- 确保当对象自我赋值时operator=有良好的的行为. 其中技术包括比较\"来源对象\"\n和\"目标对象\"的地址, 精心周到的语句顺序, 以及copy-and-swap\n- 确认任何函数如果操作一个以上的对象, 而其中多个对象是同一个对象的时候, 进行仍未正确\n\n\n**自我赋值是什么**\n\n```c++\nclass Widget {...};\nWidget w;\n\nw=w; // 什么这个看起来不可能, 那下面呢?\n\na[i] = a[j]; // 这个怎么样?  潜在的自我赋值\n*px = *py // 这个呢? 潜在的自我赋值\n```\n**会出现的问题**\n```c++\nclass Gameroom{....};\nclass Game\n{\n\t...\nprivate:\n\tGameroom* room_;\n}\n\n// operator=的实现代码\nGame& Game::operator=(const Game& ths)\n{\n\tdelete room_;\n\troom_ = new Gameroom(*ths.room_);\n\treturn *this;\n}\n```\n上面的代码 如果 this和ths指向同一个对象就会造成 `room_`构造失败\n因为被`delete`的`room_`就是要传入的\n\n如何解决这个问题呢?\n*比较来源对象 整同测试*\n```c++\nGame& Game::operator=(const Game& ths)\n{\n\tif (this == &ths)\n\t{\n\t\treturn *this;\n\t}\n\tdelete room_;\n\troom_ = new Gameroom(*ths.room_);\n\treturn *this;\n}\n```\n但是如果 `new Gameroom(*ths.room_)`错误, 导致room_指向不安全的内存\n使用下面的代码, 可以导出异常安全, 以及自我赋值\n```c++\nGame& Game::operator=(const Game& ths)\n{\n\tGameroom* p_room = room_;\n\troom_ = new Gameroom(*ths.room_);\n\tdelete p_room;\n\tretutn *this;\n}\n```\n现在如果`new Gameroom`抛出异常, room_还可以保持原状.\n同时也能处理自我赋值\n\n*copy and swap*\n这一段描述我看完之后, 突然想到了上午看的Jsoncpp里面的代码!!!!! 就有这个\n下面的代码更加高效 但是牺牲了清晰性\n```c++\nclass Game\n{\n\tvoid swap(Game& rhs);\n}\nGame& Game::operator=(const Game& ths)\n{\n\tGame temp(this);\n\tswap(temp);\n\treturn *this;\n}\n```\n## 条款12: 复制对象时勿忘其每一个成分\n\n# 资源管理\n## 条款13: 以对象管理资源\n- 防止资源泄露请使用RALL对象, 他们在构造函数获得资源在析构函数释放资源\n- 较常使用的RALL classes是shared_ptr和auto_ptr(在C++17被删掉了) 建议使用前者其复制行为也比较直观\n\n使用工厂方法得到一个指向资源对象的指针, 使用这个指针操作完毕后需要delete 这个指针\n这样这个资源对象的资源就能够被释放\n\n但是, 这是执行了delete的情况, 如果在`指针返回后` 在`delete执行前` 发生了各种情况导致`delete没有被执行`\n发生的情况包括但不限于, 提前return, 如果位于循环中还可能是continue乃至goto, 甚至是异常抛出.\n所以直接使用指针管理资源十分不安全.\n\n同时我们知道 如果使用`资源管理对象`管理资源 使用资源管理对象的`析构函数来释放这个指向资源的指针`\n而且对象的`析构函数`会在资管管理对象`生命周期结束后自动调用`, 这样就能`自动删除资源`, 不用依赖手动在合适的时机delete\n\n使用智能指针是一个非常不错的选择, 当然要注意防止别让多个智能指针指向同一个对象.\n\nauto_ptr在C++17中被废除了, 简单了解下就好了. 书中称这是诡异的复制行为2333,\n复加上其底层条件, 受auto_ptr管理的资源绝对没有一个以上的auto_ptr指向他\n```c++\n// pR1指向CreateResource的返回物\nstd::auto_ptr<Resource> pR1(CreateResource());\n// 现在pR2指向了, pR1被设置为了nullptr\nstd::auto_ptr<Resource> pR2(pR1);\n// 现在pR1指向了, pR2又成了nullptr\npR1 = pR2;\n```\n\n引用计数型智慧指针......\n\n*智能指针析构函数使用的是delete 而不是delete []* 所以不要将动态分配的数组保存进去\n\n## 条款14 在资源管理类中小心copying行为\n\n\n\n\n# 设计与声明\n\n## 条款19: 设计class犹如设计type\n\n如何设计高效的classes呢?\n- 新class的对象该如何被创建和销毁? 这会影响到构造析构函数内存分配释放函数\n- 对象的初始化和对象的赋值有什么样的差别? 决定构造函数和赋值运算符的行为.\n搞清初始化和赋值\n- 注意class对象被值传递 拷贝构造函数会被调用用来生成临时对象\n- 什么是新class的合法值? `setter`函数需要进行的范围检查\n- 你的新class需要配合某个继承图系吗? // TODO\n- 你的新class需要什么样的转换? 如果需要类型转换需要在class中编写`类型转换函数`\n- 什么样的操作运算符和函数对此class而言是合理的? 决定你为class声明哪些函数(条款 23 24 46)\n- 将需要驳回的标准函数设置为private\n- 你的新type有多么一般化? 或许应该定义一整个class家族. 也许模板能帮你\n\n## 条款20: const 引用 替换掉 值传递\n\n值传递会造成大量额外的构造析构被调用\n\n通过引用传递还能避免对象切割问题. 当一个子类通过值传递并被视为一个基类的时候\n子类的特性全部丢失\n\n对于内置类型而言 值传递 比 引用传递 更加高效\n\n## 条款21: 必须返回对象的时候, 别妄想返回其引用\nlocal对象如果被从函数 引用返回 函数结束的时候对象就被销毁 造成未定义行为\n\n如果通过 * 返回一个堆对象 的引用 将会造成诸如内存泄漏等问题\n\n## 条款22: 将成员变量声明为private\n\n成员变量声明为private提供GetSet方法, 看似麻烦... 实则确实麻烦=, =\n不过麻烦的相对面就是他的好处\n\n首先就是提供了封装, 一旦你更改了内如的成员变量的实现等, 你只需要改动GetSet方法, 外部浑然不知.\n如果你声明为了public, 那么你有极大的可能需要修改每一处直接从外部使用成员的代码.\n\n之外你还可以将进行参数校验, 等等保护.\n\n## 条款23: 宁以non-member, non-friend替换member函数\n\n```c++\nclass A\n{\n\tDoA();\n\tDoB();\n\tDoC();\n}\n```\n现在你需要提供一个函数 `DoD()`实现上面三个函数的功能\n你有两个选择\n1. 增加一个新的成员函数`DoD()`内部调用三个函数\n2. 增加一个普通函数, 增加`A& a`参数调用内部的三个函数\n\n\n# 绪论\n\n# 型别推导\n一个对象如果是右值则可以实施移动语义, 左值则不然\n\n如果能取得表达式的地址 - 断定表达式是左值\n如果不可以通常是右值\n\n## 条款1: 理解模板型别推导\n\n","source":"_posts/读书记录110-Effective读书记录.md","raw":"---\ntitle: Effective读书记录\ndate: 2020-02-26 21:43:46\ntags:\ncategories:\n - 读书记录\ntop: 110\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/Effective%20C%2B%2B/%E5%B0%81%E9%9D%A2.jpg\n---\n\n# 让自己习惯C++\n## 条款02 尽量用const, enum, inline 替换#define\n前言 我目前自己做的框架中大量用了#define.... 因为用enum涉及到转换才能到int. 来学习下这条\n\n**使用 const 常量来替换 #define**\n谨防机号表出错, 特殊情况下 还能减少字量\n\n#define无法限定作用域, 这点我已经感受到了\n\n定义C风格常量字符串\nconst char* const NAME = \"lsmg\"; 防止指向和指向内容改变\n定义C++风格常量字符串\nconst std::string NAME = \"lsmg\";\n\nclass专属常量, 使用如下方式. 可以限定作用域\n```c++\nclass Game\n{\nprivate:\n\tstatic const int MAX_ROOM = 10000; // 常量声明式 - 常量且只有一份\n\tGameroom* rooms[MAX_ROOM];\n}\n```\n如果要获取class专属常量的地址, 或者需要定义式. 则需要在`实现文件`而非`头文件`, 如下声明\n`const int Game::MAX_ROOM` - 未给定初值\n由于class常量已经在声明时获得初值, 所以不用在给定初值\n\n这里我发现一件事情, 这本书 不能只读一遍, 最少两边完整的\n前面就已经开始使用后面的条款了, 先着重本条款, 跨条款的等第二遍\n\n\n## 条款03 尽可能使用const\n**总结**\n- 将某些东西声明为const可帮助编译器探测到错误用法\nconst可以用作在任何作用域内的对象, 函数参数, 函数返回类型, 成员函数本体\n\n\n```c++\nchar greeting[] = \"Hello\";\nchar *p = greeting;\n// const 在 * 左边 被指物是常量 在右边自己是常量 两边都是常量\nconst char *p = greeting; // 指针指向可以变, 指向的值不能变\nchar* const p = greeting; // 指针指向不可以变, 指向的值可以变\nconst char* const p = greeting; // 都不可以变\n```\n**const 参数, 可你帮你检查 == 被写成=的情况**\n这本书看来挺有意思的2333333\n\n**const 函数, 这里看不太懂 没有原来如此的感觉**\n\n## 条款04 确定对象使用前已经被初始化\n**总结**\n- 为内置型对象进行手工初始化.\n- 构造函数最好使用成员初值列, 不要在构造函数中赋值. 初值列次数应该与声明次序相同\n- 为了免除 跨编译单元的初始化次数问题, 用`local static`对象替换`non-local static`对象\n\n永远在使用对象前, 进行初始化.\n在构造函数中, 对所有值进行初始化\n构造函数使用`成员初始列`进行`初始化操作`而非`赋值操作`\n\n\n**减少default构造函数不必要的调用**\n```c++\nClass A\n{\npublic:\n\tA(const std::string &name, const std::list<Gameroom> &room_list);\nprivate:\n\tstd::string name_;\n\tstd::list<Gameroom> room_list_;\n\tint roomnum_;\n}\n\nA::A(const std::string &name, const std::list<Gameroom> &room_list)\n{\n\tname_ = name; // 这些都是赋值 不是初始化\n\troom_list_ = room_list;\n\troomnum_ = 0;\n}\n// C++规定 对象的 成员变量  初始化动作  发生在  进入构造函数本体  之前\n// name_  room_list_  两个在构造函数中被赋值, 而初始化在进入构造函数之前\n// ---发生在这些成员的default构造函数被调用的时候, (发生在进入构造函数前)\n// ---roomnum_例外 int属于内置类型\n\n```\n上面的初始化方式, 浪费了default的构造函数 所以推荐使用下面的形式\n```c++\nA::A(const std::string &name, const std::list<Gameroom> &room_list)\n\t:name_(name), room_list_(room_list), roomnum_(0)\n{\n}\n```\n虽然最终结果相同, 但没有浪费default构造函数. 前两个调用的copy构造函数.\n\n**还可以使用成员初值列 来default构造一个成员变量.**\n```c++\nA::A()\n\t:name_(), room_list_(), roomnum_(0)\n{ // 前两个全部调用的default构造函数\n}\n```\n\n**const reference 内置类型(初始化与赋值等成本) 一定成员初始值列**\n\n**初始值列总是使用 声明次序进行初始化, 而非写的顺序, 所以最好按声明次序列出**\n\n**不同编译单元内定义之 non-local static对象 的初始化 次序**\nstatic对象: 虚构函数会在main() 结束时被自动调用\nlocal static对象: 函数内的static对象\nnon-local对象: 其他static对象\n\n编译单元: 产出单一目标文件的那些源码, 基本是单一源码文件和他包含的头文件\n\n```c++\n// filesystem.h\nclass FileSystem\n{\npublic:\n\tsize_t GetNum() const;\n};\nextern FIieSystem tfs; // 声明\n\n// filesystem.cpp\nFIieSystem tfs; //定义\n\n// directory.h\nclass Directory\n{\npublic:\n\tDirectory(params);\t\n}\nDirectory::Directory(params)\n{\n\tsize_t num = tfs.GetNum(); // 使用tfs对象\n}\n\n// main.cpp\nDirectory temp_dir(params);\n```\n只有当 tfs在temp_dir初始化之前被初始化 才能得到正确的结果. 否则会调用未初始化的对象\n\n但是这个次序无法保证, tfs和tempdir是不同的人在不同的时间于不同的源码文件建立起来的\n因为C++ 对这种情况没有明确定义\n\n如何解决这个问题呢??\n将每个`non-local static`对象搬到自己的专属函数内(该对象在此函数内被声明为static)\n函数返回一个reference对象他所包含的对象\n用户调用这个函数而不是直接调用对象\n\n解决的原因呢?\nC++ 保证函数内的`local static`对象 会在`函数被调用期间`, `首次遇到该对象的定义式`被初始化\n\n```c++\n// filesystem.h\nclass FileSystem\n{\npublic:\n\tstd::size_t GetNum() const;\n}\nFileSystem& tfs()\n{\n\tstatic FileSystem fs;\n\treturn fs;\n}\n\n// directory.h\nclass Directory\n{\npublic:\n\tDirectory(params);\t\n}\nDirectory::Directory(params)\n{\n\tstd::size_t num = tfs().GetNum(); // 使用tfs对象\n}\nDirectory& temp_dir()\n{\n\tstatic Directory td;\n\treturn td;\n}\n```\n# 构造析构赋值运算\n## 条款0506 了解C++默认编写并调用哪些函数 并适当拒绝\n\n**夹带如下私货-public-inline**\n- 一个构造函数(如果你没有任何构造函数)\n- 一个拷贝构造函数\n- 一个析构函数\n- 一个拷贝\n\n拷贝构造函数和拷贝运算符 自动生成的只是单纯的将来源对象的每一个`non-static`成员变量\n拷贝到目标对象\n\n**遇到const 和 引用成员 默认的拷贝无法工作, 编译器会发出警告**\n\n**将不需要的成员函数声明为private, 并且不实现**\n\n## 条款07 为多态基类声明virtual析构函数\n返回指向子类的 父类型指针.\n如果delete这个指针, 在父类析构函数不是virtual的情况下, 很可能会导致\n父类的成分被销毁, 然而子类多出来的部分不被销毁. 造成局部销毁!!\n\n**防止局部销毁很简单, 将父类的析构函数声明为virtual**\n\n**任何class 只要带有virtual函数 几乎确定应该有一个virtual析构函数**\n\n**无端的声明virtual函数是错误的**\n如果class不含virtual函数, 通常表示这个class 不是想做为父类, 这时如果将其析构函数声明为virual\n是一个馊主意.............\n\n*class类的大小 = 成员变量占据大小 + vptr(vitual table pointer)指针大小(4~8 字节)*\n\n每一个带有virtual函数的class都有对应的vtbl\n\n当对象调用某一vitual函数的时候, 实际调用的函数取决于\nvptr(vitual table pointer)指针指向的vtbl(vitual table)\n\n无端的使用virtual函数 会导致占用空间的增大\n\n## 条款08 别让异常逃离析构函数\n\n**总结**\n- 析构函数绝对不要抛出异常, 如果被析构函数调用的函数可能抛出异常, 析构函数应该捕获所有异常\n然后吞下它们, 或者结束程序\n- 如果客户需要对某个操作函数运行期间抛出的异常做出反应, class应该提供一个普通函数(而非在析构函数中)\n执行操作\n\n**析构函数不要抛出异常**\n```c++\nclass Widget\n{\n\t...\n\t~Widget() {...}\n}\n\nvoid Foo()\n{\n\tstd::vector<Widget> v;\n}\n```\n当 `v`被销毁的时候, Widget的析构函数第一次抛出异常C++还能接受?\n第二次就会造成不明确行为\n\n## 条款09: 绝不在构造函数和析构过程中调用virtual函数\n**总结**\n- 在构造和析构期间不要调用virtual函数, 因为这类调用从不下降到`子类`\n\n```c++\nclass Transaction\n{\npublic:\n\tTransaction();\n\tvirtual void LogTransaction() const = 0;\n\t...\n}\nTransaction::Transaction()\n{\n\t...\n\tLogTransaction();\n}\n\nclass BuyTransaction: public Transaction\n{\npublic:\n\tvirtual void LogTransaction() const;\n\t...\n}\n\nclass SellTransaction: public Transaction\n{\npublic:\n\tvirtual void LogTransaction() const;\n\t...\n}\n\nBuyTransaction b;\n```\nBuyTransaction的构造函数会被调用, 但是父类的构造函数会更显被调用.\n然后父类构造函数调用`LogTransaction()`的版本是`父类`的版本!!! 不是子类的版本\n\n析构函数也是同样的道理, 当`子类`的析构函数执行后, `子类`中的属性值就成为未定义状态\n进入`父类`后对象就成为一个`父类`对象\n\n本例子中既然无法实现使用`virtual`函数从`父类`向下调用, 可以再构造期间, 将\n`子类`必要的构造信息向上传给`父类`的构造函数\n\n## 条款10: 另operator= 返回一个reference to *this\n\n注意这只是一个协议, 并无强制性. 如果不遵守代码依然可以通过编译, 然而这份 协议被所有内置类型\n和标准程序库提供的类型共同遵守.\n因此除非你有一个标新立异的好理由, 不然还是随众吧\n\n## 条款11: 在operator= 中处理\"自我赋值\"\n**总结**\n- 确保当对象自我赋值时operator=有良好的的行为. 其中技术包括比较\"来源对象\"\n和\"目标对象\"的地址, 精心周到的语句顺序, 以及copy-and-swap\n- 确认任何函数如果操作一个以上的对象, 而其中多个对象是同一个对象的时候, 进行仍未正确\n\n\n**自我赋值是什么**\n\n```c++\nclass Widget {...};\nWidget w;\n\nw=w; // 什么这个看起来不可能, 那下面呢?\n\na[i] = a[j]; // 这个怎么样?  潜在的自我赋值\n*px = *py // 这个呢? 潜在的自我赋值\n```\n**会出现的问题**\n```c++\nclass Gameroom{....};\nclass Game\n{\n\t...\nprivate:\n\tGameroom* room_;\n}\n\n// operator=的实现代码\nGame& Game::operator=(const Game& ths)\n{\n\tdelete room_;\n\troom_ = new Gameroom(*ths.room_);\n\treturn *this;\n}\n```\n上面的代码 如果 this和ths指向同一个对象就会造成 `room_`构造失败\n因为被`delete`的`room_`就是要传入的\n\n如何解决这个问题呢?\n*比较来源对象 整同测试*\n```c++\nGame& Game::operator=(const Game& ths)\n{\n\tif (this == &ths)\n\t{\n\t\treturn *this;\n\t}\n\tdelete room_;\n\troom_ = new Gameroom(*ths.room_);\n\treturn *this;\n}\n```\n但是如果 `new Gameroom(*ths.room_)`错误, 导致room_指向不安全的内存\n使用下面的代码, 可以导出异常安全, 以及自我赋值\n```c++\nGame& Game::operator=(const Game& ths)\n{\n\tGameroom* p_room = room_;\n\troom_ = new Gameroom(*ths.room_);\n\tdelete p_room;\n\tretutn *this;\n}\n```\n现在如果`new Gameroom`抛出异常, room_还可以保持原状.\n同时也能处理自我赋值\n\n*copy and swap*\n这一段描述我看完之后, 突然想到了上午看的Jsoncpp里面的代码!!!!! 就有这个\n下面的代码更加高效 但是牺牲了清晰性\n```c++\nclass Game\n{\n\tvoid swap(Game& rhs);\n}\nGame& Game::operator=(const Game& ths)\n{\n\tGame temp(this);\n\tswap(temp);\n\treturn *this;\n}\n```\n## 条款12: 复制对象时勿忘其每一个成分\n\n# 资源管理\n## 条款13: 以对象管理资源\n- 防止资源泄露请使用RALL对象, 他们在构造函数获得资源在析构函数释放资源\n- 较常使用的RALL classes是shared_ptr和auto_ptr(在C++17被删掉了) 建议使用前者其复制行为也比较直观\n\n使用工厂方法得到一个指向资源对象的指针, 使用这个指针操作完毕后需要delete 这个指针\n这样这个资源对象的资源就能够被释放\n\n但是, 这是执行了delete的情况, 如果在`指针返回后` 在`delete执行前` 发生了各种情况导致`delete没有被执行`\n发生的情况包括但不限于, 提前return, 如果位于循环中还可能是continue乃至goto, 甚至是异常抛出.\n所以直接使用指针管理资源十分不安全.\n\n同时我们知道 如果使用`资源管理对象`管理资源 使用资源管理对象的`析构函数来释放这个指向资源的指针`\n而且对象的`析构函数`会在资管管理对象`生命周期结束后自动调用`, 这样就能`自动删除资源`, 不用依赖手动在合适的时机delete\n\n使用智能指针是一个非常不错的选择, 当然要注意防止别让多个智能指针指向同一个对象.\n\nauto_ptr在C++17中被废除了, 简单了解下就好了. 书中称这是诡异的复制行为2333,\n复加上其底层条件, 受auto_ptr管理的资源绝对没有一个以上的auto_ptr指向他\n```c++\n// pR1指向CreateResource的返回物\nstd::auto_ptr<Resource> pR1(CreateResource());\n// 现在pR2指向了, pR1被设置为了nullptr\nstd::auto_ptr<Resource> pR2(pR1);\n// 现在pR1指向了, pR2又成了nullptr\npR1 = pR2;\n```\n\n引用计数型智慧指针......\n\n*智能指针析构函数使用的是delete 而不是delete []* 所以不要将动态分配的数组保存进去\n\n## 条款14 在资源管理类中小心copying行为\n\n\n\n\n# 设计与声明\n\n## 条款19: 设计class犹如设计type\n\n如何设计高效的classes呢?\n- 新class的对象该如何被创建和销毁? 这会影响到构造析构函数内存分配释放函数\n- 对象的初始化和对象的赋值有什么样的差别? 决定构造函数和赋值运算符的行为.\n搞清初始化和赋值\n- 注意class对象被值传递 拷贝构造函数会被调用用来生成临时对象\n- 什么是新class的合法值? `setter`函数需要进行的范围检查\n- 你的新class需要配合某个继承图系吗? // TODO\n- 你的新class需要什么样的转换? 如果需要类型转换需要在class中编写`类型转换函数`\n- 什么样的操作运算符和函数对此class而言是合理的? 决定你为class声明哪些函数(条款 23 24 46)\n- 将需要驳回的标准函数设置为private\n- 你的新type有多么一般化? 或许应该定义一整个class家族. 也许模板能帮你\n\n## 条款20: const 引用 替换掉 值传递\n\n值传递会造成大量额外的构造析构被调用\n\n通过引用传递还能避免对象切割问题. 当一个子类通过值传递并被视为一个基类的时候\n子类的特性全部丢失\n\n对于内置类型而言 值传递 比 引用传递 更加高效\n\n## 条款21: 必须返回对象的时候, 别妄想返回其引用\nlocal对象如果被从函数 引用返回 函数结束的时候对象就被销毁 造成未定义行为\n\n如果通过 * 返回一个堆对象 的引用 将会造成诸如内存泄漏等问题\n\n## 条款22: 将成员变量声明为private\n\n成员变量声明为private提供GetSet方法, 看似麻烦... 实则确实麻烦=, =\n不过麻烦的相对面就是他的好处\n\n首先就是提供了封装, 一旦你更改了内如的成员变量的实现等, 你只需要改动GetSet方法, 外部浑然不知.\n如果你声明为了public, 那么你有极大的可能需要修改每一处直接从外部使用成员的代码.\n\n之外你还可以将进行参数校验, 等等保护.\n\n## 条款23: 宁以non-member, non-friend替换member函数\n\n```c++\nclass A\n{\n\tDoA();\n\tDoB();\n\tDoC();\n}\n```\n现在你需要提供一个函数 `DoD()`实现上面三个函数的功能\n你有两个选择\n1. 增加一个新的成员函数`DoD()`内部调用三个函数\n2. 增加一个普通函数, 增加`A& a`参数调用内部的三个函数\n\n\n# 绪论\n\n# 型别推导\n一个对象如果是右值则可以实施移动语义, 左值则不然\n\n如果能取得表达式的地址 - 断定表达式是左值\n如果不可以通常是右值\n\n## 条款1: 理解模板型别推导\n\n","slug":"读书记录110-Effective读书记录","published":1,"updated":"2020-12-05T02:31:35.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg75003kf8unaa8708a5","content":"<h1 id=\"让自己习惯C\"><a href=\"#让自己习惯C\" class=\"headerlink\" title=\"让自己习惯C++\"></a>让自己习惯C++</h1><h2 id=\"条款02-尽量用const-enum-inline-替换-define\"><a href=\"#条款02-尽量用const-enum-inline-替换-define\" class=\"headerlink\" title=\"条款02 尽量用const, enum, inline 替换#define\"></a>条款02 尽量用const, enum, inline 替换#define</h2><p>前言 我目前自己做的框架中大量用了#define…. 因为用enum涉及到转换才能到int. 来学习下这条</p>\n<p><strong>使用 const 常量来替换 #define</strong><br>谨防机号表出错, 特殊情况下 还能减少字量</p>\n<p>#define无法限定作用域, 这点我已经感受到了</p>\n<p>定义C风格常量字符串<br>const char* const NAME = “lsmg”; 防止指向和指向内容改变<br>定义C++风格常量字符串<br>const std::string NAME = “lsmg”;</p>\n<p>class专属常量, 使用如下方式. 可以限定作用域</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Game</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_ROOM = <span class=\"number\">10000</span>; <span class=\"comment\">// 常量声明式 - 常量且只有一份</span></span><br><span class=\"line\">\tGameroom* rooms[MAX_ROOM];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要获取class专属常量的地址, 或者需要定义式. 则需要在<code>实现文件</code>而非<code>头文件</code>, 如下声明<br><code>const int Game::MAX_ROOM</code> - 未给定初值<br>由于class常量已经在声明时获得初值, 所以不用在给定初值</p>\n<p>这里我发现一件事情, 这本书 不能只读一遍, 最少两边完整的<br>前面就已经开始使用后面的条款了, 先着重本条款, 跨条款的等第二遍</p>\n<h2 id=\"条款03-尽可能使用const\"><a href=\"#条款03-尽可能使用const\" class=\"headerlink\" title=\"条款03 尽可能使用const\"></a>条款03 尽可能使用const</h2><p><strong>总结</strong></p>\n<ul>\n<li>将某些东西声明为const可帮助编译器探测到错误用法<br>const可以用作在任何作用域内的对象, 函数参数, 函数返回类型, 成员函数本体</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> greeting[] = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *p = greeting;</span><br><span class=\"line\"><span class=\"comment\">// const 在 * 左边 被指物是常量 在右边自己是常量 两边都是常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *p = greeting; <span class=\"comment\">// 指针指向可以变, 指向的值不能变</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> p = greeting; <span class=\"comment\">// 指针指向不可以变, 指向的值可以变</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> p = greeting; <span class=\"comment\">// 都不可以变</span></span><br></pre></td></tr></table></figure>\n<p><strong>const 参数, 可你帮你检查 == 被写成=的情况</strong><br>这本书看来挺有意思的2333333</p>\n<p><strong>const 函数, 这里看不太懂 没有原来如此的感觉</strong></p>\n<h2 id=\"条款04-确定对象使用前已经被初始化\"><a href=\"#条款04-确定对象使用前已经被初始化\" class=\"headerlink\" title=\"条款04 确定对象使用前已经被初始化\"></a>条款04 确定对象使用前已经被初始化</h2><p><strong>总结</strong></p>\n<ul>\n<li>为内置型对象进行手工初始化.</li>\n<li>构造函数最好使用成员初值列, 不要在构造函数中赋值. 初值列次数应该与声明次序相同</li>\n<li>为了免除 跨编译单元的初始化次数问题, 用<code>local static</code>对象替换<code>non-local static</code>对象</li>\n</ul>\n<p>永远在使用对象前, 进行初始化.<br>在构造函数中, 对所有值进行初始化<br>构造函数使用<code>成员初始列</code>进行<code>初始化操作</code>而非<code>赋值操作</code></p>\n<p><strong>减少default构造函数不必要的调用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tA(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; &amp;room_list);</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name_;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; room_list_;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> roomnum_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A::A(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tname_ = name; <span class=\"comment\">// 这些都是赋值 不是初始化</span></span><br><span class=\"line\">\troom_list_ = room_list;</span><br><span class=\"line\">\troomnum_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// C++规定 对象的 成员变量  初始化动作  发生在  进入构造函数本体  之前</span></span><br><span class=\"line\"><span class=\"comment\">// name_  room_list_  两个在构造函数中被赋值, 而初始化在进入构造函数之前</span></span><br><span class=\"line\"><span class=\"comment\">// ---发生在这些成员的default构造函数被调用的时候, (发生在进入构造函数前)</span></span><br><span class=\"line\"><span class=\"comment\">// ---roomnum_例外 int属于内置类型</span></span><br></pre></td></tr></table></figure>\n<p>上面的初始化方式, 浪费了default的构造函数 所以推荐使用下面的形式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A::A(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class=\"line\">\t:name_(name), room_list_(room_list), roomnum_(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然最终结果相同, 但没有浪费default构造函数. 前两个调用的copy构造函数.</p>\n<p><strong>还可以使用成员初值列 来default构造一个成员变量.</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A::A()</span><br><span class=\"line\">\t:name_(), room_list_(), roomnum_(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123; <span class=\"comment\">// 前两个全部调用的default构造函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>const reference 内置类型(初始化与赋值等成本) 一定成员初始值列</strong></p>\n<p><strong>初始值列总是使用 声明次序进行初始化, 而非写的顺序, 所以最好按声明次序列出</strong></p>\n<p><strong>不同编译单元内定义之 non-local static对象 的初始化 次序</strong><br>static对象: 虚构函数会在main() 结束时被自动调用<br>local static对象: 函数内的static对象<br>non-local对象: 其他static对象</p>\n<p>编译单元: 产出单一目标文件的那些源码, 基本是单一源码文件和他包含的头文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// filesystem.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileSystem</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">GetNum</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> FIieSystem tfs; <span class=\"comment\">// 声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// filesystem.cpp</span></span><br><span class=\"line\">FIieSystem tfs; <span class=\"comment\">//定义</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// directory.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Directory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDirectory(params);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Directory::Directory(params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> num = tfs.GetNum(); <span class=\"comment\">// 使用tfs对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"function\">Directory <span class=\"title\">temp_dir</span><span class=\"params\">(params)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>只有当 tfs在temp_dir初始化之前被初始化 才能得到正确的结果. 否则会调用未初始化的对象</p>\n<p>但是这个次序无法保证, tfs和tempdir是不同的人在不同的时间于不同的源码文件建立起来的<br>因为C++ 对这种情况没有明确定义</p>\n<p>如何解决这个问题呢??<br>将每个<code>non-local static</code>对象搬到自己的专属函数内(该对象在此函数内被声明为static)<br>函数返回一个reference对象他所包含的对象<br>用户调用这个函数而不是直接调用对象</p>\n<p>解决的原因呢?<br>C++ 保证函数内的<code>local static</code>对象 会在<code>函数被调用期间</code>, <code>首次遇到该对象的定义式</code>被初始化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// filesystem.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileSystem</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> <span class=\"title\">GetNum</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">FileSystem</span>&amp; <span class=\"title\">tfs</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"built_in\">FileSystem</span> fs;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// directory.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Directory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDirectory(params);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Directory::Directory(params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> num = tfs().GetNum(); <span class=\"comment\">// 使用tfs对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">Directory&amp; <span class=\"title\">temp_dir</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> Directory td;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> td;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"构造析构赋值运算\"><a href=\"#构造析构赋值运算\" class=\"headerlink\" title=\"构造析构赋值运算\"></a>构造析构赋值运算</h1><h2 id=\"条款0506-了解C-默认编写并调用哪些函数-并适当拒绝\"><a href=\"#条款0506-了解C-默认编写并调用哪些函数-并适当拒绝\" class=\"headerlink\" title=\"条款0506 了解C++默认编写并调用哪些函数 并适当拒绝\"></a>条款0506 了解C++默认编写并调用哪些函数 并适当拒绝</h2><p><strong>夹带如下私货-public-inline</strong></p>\n<ul>\n<li>一个构造函数(如果你没有任何构造函数)</li>\n<li>一个拷贝构造函数</li>\n<li>一个析构函数</li>\n<li>一个拷贝</li>\n</ul>\n<p>拷贝构造函数和拷贝运算符 自动生成的只是单纯的将来源对象的每一个<code>non-static</code>成员变量<br>拷贝到目标对象</p>\n<p><strong>遇到const 和 引用成员 默认的拷贝无法工作, 编译器会发出警告</strong></p>\n<p><strong>将不需要的成员函数声明为private, 并且不实现</strong></p>\n<h2 id=\"条款07-为多态基类声明virtual析构函数\"><a href=\"#条款07-为多态基类声明virtual析构函数\" class=\"headerlink\" title=\"条款07 为多态基类声明virtual析构函数\"></a>条款07 为多态基类声明virtual析构函数</h2><p>返回指向子类的 父类型指针.<br>如果delete这个指针, 在父类析构函数不是virtual的情况下, 很可能会导致<br>父类的成分被销毁, 然而子类多出来的部分不被销毁. 造成局部销毁!!</p>\n<p><strong>防止局部销毁很简单, 将父类的析构函数声明为virtual</strong></p>\n<p><strong>任何class 只要带有virtual函数 几乎确定应该有一个virtual析构函数</strong></p>\n<p><strong>无端的声明virtual函数是错误的</strong><br>如果class不含virtual函数, 通常表示这个class 不是想做为父类, 这时如果将其析构函数声明为virual<br>是一个馊主意………….</p>\n<p><em>class类的大小 = 成员变量占据大小 + vptr(vitual table pointer)指针大小(4~8 字节)</em></p>\n<p>每一个带有virtual函数的class都有对应的vtbl</p>\n<p>当对象调用某一vitual函数的时候, 实际调用的函数取决于<br>vptr(vitual table pointer)指针指向的vtbl(vitual table)</p>\n<p>无端的使用virtual函数 会导致占用空间的增大</p>\n<h2 id=\"条款08-别让异常逃离析构函数\"><a href=\"#条款08-别让异常逃离析构函数\" class=\"headerlink\" title=\"条款08 别让异常逃离析构函数\"></a>条款08 别让异常逃离析构函数</h2><p><strong>总结</strong></p>\n<ul>\n<li>析构函数绝对不要抛出异常, 如果被析构函数调用的函数可能抛出异常, 析构函数应该捕获所有异常<br>然后吞下它们, 或者结束程序</li>\n<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应, class应该提供一个普通函数(而非在析构函数中)<br>执行操作</li>\n</ul>\n<p><strong>析构函数不要抛出异常</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t~Widget() &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Widget&gt; v;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 <code>v</code>被销毁的时候, Widget的析构函数第一次抛出异常C++还能接受?<br>第二次就会造成不明确行为</p>\n<h2 id=\"条款09-绝不在构造函数和析构过程中调用virtual函数\"><a href=\"#条款09-绝不在构造函数和析构过程中调用virtual函数\" class=\"headerlink\" title=\"条款09: 绝不在构造函数和析构过程中调用virtual函数\"></a>条款09: 绝不在构造函数和析构过程中调用virtual函数</h2><p><strong>总结</strong></p>\n<ul>\n<li>在构造和析构期间不要调用virtual函数, 因为这类调用从不下降到<code>子类</code></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transaction</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tTransaction();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">LogTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Transaction::Transaction()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tLogTransaction();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuyTransaction</span>:</span> <span class=\"keyword\">public</span> Transaction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">LogTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SellTransaction</span>:</span> <span class=\"keyword\">public</span> Transaction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">LogTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BuyTransaction b;</span><br></pre></td></tr></table></figure>\n<p>BuyTransaction的构造函数会被调用, 但是父类的构造函数会更显被调用.<br>然后父类构造函数调用<code>LogTransaction()</code>的版本是<code>父类</code>的版本!!! 不是子类的版本</p>\n<p>析构函数也是同样的道理, 当<code>子类</code>的析构函数执行后, <code>子类</code>中的属性值就成为未定义状态<br>进入<code>父类</code>后对象就成为一个<code>父类</code>对象</p>\n<p>本例子中既然无法实现使用<code>virtual</code>函数从<code>父类</code>向下调用, 可以再构造期间, 将<br><code>子类</code>必要的构造信息向上传给<code>父类</code>的构造函数</p>\n<h2 id=\"条款10-另operator-返回一个reference-to-this\"><a href=\"#条款10-另operator-返回一个reference-to-this\" class=\"headerlink\" title=\"条款10: 另operator= 返回一个reference to *this\"></a>条款10: 另operator= 返回一个reference to *this</h2><p>注意这只是一个协议, 并无强制性. 如果不遵守代码依然可以通过编译, 然而这份 协议被所有内置类型<br>和标准程序库提供的类型共同遵守.<br>因此除非你有一个标新立异的好理由, 不然还是随众吧</p>\n<h2 id=\"条款11-在operator-中处理”自我赋值”\"><a href=\"#条款11-在operator-中处理”自我赋值”\" class=\"headerlink\" title=\"条款11: 在operator= 中处理”自我赋值”\"></a>条款11: 在operator= 中处理”自我赋值”</h2><p><strong>总结</strong></p>\n<ul>\n<li>确保当对象自我赋值时operator=有良好的的行为. 其中技术包括比较”来源对象”<br>和”目标对象”的地址, 精心周到的语句顺序, 以及copy-and-swap</li>\n<li>确认任何函数如果操作一个以上的对象, 而其中多个对象是同一个对象的时候, 进行仍未正确</li>\n</ul>\n<p><strong>自我赋值是什么</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> &#123;</span>...&#125;;</span><br><span class=\"line\">Widget w;</span><br><span class=\"line\"></span><br><span class=\"line\">w=w; <span class=\"comment\">// 什么这个看起来不可能, 那下面呢?</span></span><br><span class=\"line\"></span><br><span class=\"line\">a[i] = a[j]; <span class=\"comment\">// 这个怎么样?  潜在的自我赋值</span></span><br><span class=\"line\">*px = *py <span class=\"comment\">// 这个呢? 潜在的自我赋值</span></span><br></pre></td></tr></table></figure>\n<p><strong>会出现的问题</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Gameroom</span>&#123;</span>....&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Game</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tGameroom* room_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// operator=的实现代码</span></span><br><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> room_;</span><br><span class=\"line\">\troom_ = <span class=\"keyword\">new</span> Gameroom(*ths.room_);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码 如果 this和ths指向同一个对象就会造成 <code>room_</code>构造失败<br>因为被<code>delete</code>的<code>room_</code>就是要传入的</p>\n<p>如何解决这个问题呢?<br><em>比较来源对象 整同测试</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;ths)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> room_;</span><br><span class=\"line\">\troom_ = <span class=\"keyword\">new</span> Gameroom(*ths.room_);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是如果 <code>new Gameroom(*ths.room_)</code>错误, 导致room_指向不安全的内存<br>使用下面的代码, 可以导出异常安全, 以及自我赋值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tGameroom* p_room = room_;</span><br><span class=\"line\">\troom_ = <span class=\"keyword\">new</span> Gameroom(*ths.room_);</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> p_room;</span><br><span class=\"line\">\tretutn *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在如果<code>new Gameroom</code>抛出异常, room_还可以保持原状.<br>同时也能处理自我赋值</p>\n<p><em>copy and swap</em><br>这一段描述我看完之后, 突然想到了上午看的Jsoncpp里面的代码!!!!! 就有这个<br>下面的代码更加高效 但是牺牲了清晰性</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Game</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(Game&amp; rhs)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tGame temp(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\tswap(temp);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"条款12-复制对象时勿忘其每一个成分\"><a href=\"#条款12-复制对象时勿忘其每一个成分\" class=\"headerlink\" title=\"条款12: 复制对象时勿忘其每一个成分\"></a>条款12: 复制对象时勿忘其每一个成分</h2><h1 id=\"资源管理\"><a href=\"#资源管理\" class=\"headerlink\" title=\"资源管理\"></a>资源管理</h1><h2 id=\"条款13-以对象管理资源\"><a href=\"#条款13-以对象管理资源\" class=\"headerlink\" title=\"条款13: 以对象管理资源\"></a>条款13: 以对象管理资源</h2><ul>\n<li>防止资源泄露请使用RALL对象, 他们在构造函数获得资源在析构函数释放资源</li>\n<li>较常使用的RALL classes是shared_ptr和auto_ptr(在C++17被删掉了) 建议使用前者其复制行为也比较直观</li>\n</ul>\n<p>使用工厂方法得到一个指向资源对象的指针, 使用这个指针操作完毕后需要delete 这个指针<br>这样这个资源对象的资源就能够被释放</p>\n<p>但是, 这是执行了delete的情况, 如果在<code>指针返回后</code> 在<code>delete执行前</code> 发生了各种情况导致<code>delete没有被执行</code><br>发生的情况包括但不限于, 提前return, 如果位于循环中还可能是continue乃至goto, 甚至是异常抛出.<br>所以直接使用指针管理资源十分不安全.</p>\n<p>同时我们知道 如果使用<code>资源管理对象</code>管理资源 使用资源管理对象的<code>析构函数来释放这个指向资源的指针</code><br>而且对象的<code>析构函数</code>会在资管管理对象<code>生命周期结束后自动调用</code>, 这样就能<code>自动删除资源</code>, 不用依赖手动在合适的时机delete</p>\n<p>使用智能指针是一个非常不错的选择, 当然要注意防止别让多个智能指针指向同一个对象.</p>\n<p>auto_ptr在C++17中被废除了, 简单了解下就好了. 书中称这是诡异的复制行为2333,<br>复加上其底层条件, 受auto_ptr管理的资源绝对没有一个以上的auto_ptr指向他</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pR1指向CreateResource的返回物</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">auto_ptr</span>&lt;Resource&gt; <span class=\"title\">pR1</span><span class=\"params\">(CreateResource())</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 现在pR2指向了, pR1被设置为了nullptr</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">auto_ptr</span>&lt;Resource&gt; <span class=\"title\">pR2</span><span class=\"params\">(pR1)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 现在pR1指向了, pR2又成了nullptr</span></span><br><span class=\"line\">pR1 = pR2;</span><br></pre></td></tr></table></figure>\n\n<p>引用计数型智慧指针……</p>\n<p><em>智能指针析构函数使用的是delete 而不是delete []</em> 所以不要将动态分配的数组保存进去</p>\n<h2 id=\"条款14-在资源管理类中小心copying行为\"><a href=\"#条款14-在资源管理类中小心copying行为\" class=\"headerlink\" title=\"条款14 在资源管理类中小心copying行为\"></a>条款14 在资源管理类中小心copying行为</h2><h1 id=\"设计与声明\"><a href=\"#设计与声明\" class=\"headerlink\" title=\"设计与声明\"></a>设计与声明</h1><h2 id=\"条款19-设计class犹如设计type\"><a href=\"#条款19-设计class犹如设计type\" class=\"headerlink\" title=\"条款19: 设计class犹如设计type\"></a>条款19: 设计class犹如设计type</h2><p>如何设计高效的classes呢?</p>\n<ul>\n<li>新class的对象该如何被创建和销毁? 这会影响到构造析构函数内存分配释放函数</li>\n<li>对象的初始化和对象的赋值有什么样的差别? 决定构造函数和赋值运算符的行为.<br>搞清初始化和赋值</li>\n<li>注意class对象被值传递 拷贝构造函数会被调用用来生成临时对象</li>\n<li>什么是新class的合法值? <code>setter</code>函数需要进行的范围检查</li>\n<li>你的新class需要配合某个继承图系吗? // TODO</li>\n<li>你的新class需要什么样的转换? 如果需要类型转换需要在class中编写<code>类型转换函数</code></li>\n<li>什么样的操作运算符和函数对此class而言是合理的? 决定你为class声明哪些函数(条款 23 24 46)</li>\n<li>将需要驳回的标准函数设置为private</li>\n<li>你的新type有多么一般化? 或许应该定义一整个class家族. 也许模板能帮你</li>\n</ul>\n<h2 id=\"条款20-const-引用-替换掉-值传递\"><a href=\"#条款20-const-引用-替换掉-值传递\" class=\"headerlink\" title=\"条款20: const 引用 替换掉 值传递\"></a>条款20: const 引用 替换掉 值传递</h2><p>值传递会造成大量额外的构造析构被调用</p>\n<p>通过引用传递还能避免对象切割问题. 当一个子类通过值传递并被视为一个基类的时候<br>子类的特性全部丢失</p>\n<p>对于内置类型而言 值传递 比 引用传递 更加高效</p>\n<h2 id=\"条款21-必须返回对象的时候-别妄想返回其引用\"><a href=\"#条款21-必须返回对象的时候-别妄想返回其引用\" class=\"headerlink\" title=\"条款21: 必须返回对象的时候, 别妄想返回其引用\"></a>条款21: 必须返回对象的时候, 别妄想返回其引用</h2><p>local对象如果被从函数 引用返回 函数结束的时候对象就被销毁 造成未定义行为</p>\n<p>如果通过 * 返回一个堆对象 的引用 将会造成诸如内存泄漏等问题</p>\n<h2 id=\"条款22-将成员变量声明为private\"><a href=\"#条款22-将成员变量声明为private\" class=\"headerlink\" title=\"条款22: 将成员变量声明为private\"></a>条款22: 将成员变量声明为private</h2><p>成员变量声明为private提供GetSet方法, 看似麻烦… 实则确实麻烦=, =<br>不过麻烦的相对面就是他的好处</p>\n<p>首先就是提供了封装, 一旦你更改了内如的成员变量的实现等, 你只需要改动GetSet方法, 外部浑然不知.<br>如果你声明为了public, 那么你有极大的可能需要修改每一处直接从外部使用成员的代码.</p>\n<p>之外你还可以将进行参数校验, 等等保护.</p>\n<h2 id=\"条款23-宁以non-member-non-friend替换member函数\"><a href=\"#条款23-宁以non-member-non-friend替换member函数\" class=\"headerlink\" title=\"条款23: 宁以non-member, non-friend替换member函数\"></a>条款23: 宁以non-member, non-friend替换member函数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDoA();</span><br><span class=\"line\">\tDoB();</span><br><span class=\"line\">\tDoC();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在你需要提供一个函数 <code>DoD()</code>实现上面三个函数的功能<br>你有两个选择</p>\n<ol>\n<li>增加一个新的成员函数<code>DoD()</code>内部调用三个函数</li>\n<li>增加一个普通函数, 增加<code>A&amp; a</code>参数调用内部的三个函数</li>\n</ol>\n<h1 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h1><h1 id=\"型别推导\"><a href=\"#型别推导\" class=\"headerlink\" title=\"型别推导\"></a>型别推导</h1><p>一个对象如果是右值则可以实施移动语义, 左值则不然</p>\n<p>如果能取得表达式的地址 - 断定表达式是左值<br>如果不可以通常是右值</p>\n<h2 id=\"条款1-理解模板型别推导\"><a href=\"#条款1-理解模板型别推导\" class=\"headerlink\" title=\"条款1: 理解模板型别推导\"></a>条款1: 理解模板型别推导</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"让自己习惯C\"><a href=\"#让自己习惯C\" class=\"headerlink\" title=\"让自己习惯C++\"></a>让自己习惯C++</h1><h2 id=\"条款02-尽量用const-enum-inline-替换-define\"><a href=\"#条款02-尽量用const-enum-inline-替换-define\" class=\"headerlink\" title=\"条款02 尽量用const, enum, inline 替换#define\"></a>条款02 尽量用const, enum, inline 替换#define</h2><p>前言 我目前自己做的框架中大量用了#define…. 因为用enum涉及到转换才能到int. 来学习下这条</p>\n<p><strong>使用 const 常量来替换 #define</strong><br>谨防机号表出错, 特殊情况下 还能减少字量</p>\n<p>#define无法限定作用域, 这点我已经感受到了</p>\n<p>定义C风格常量字符串<br>const char* const NAME = “lsmg”; 防止指向和指向内容改变<br>定义C++风格常量字符串<br>const std::string NAME = “lsmg”;</p>\n<p>class专属常量, 使用如下方式. 可以限定作用域</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Game</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_ROOM = <span class=\"number\">10000</span>; <span class=\"comment\">// 常量声明式 - 常量且只有一份</span></span><br><span class=\"line\">\tGameroom* rooms[MAX_ROOM];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要获取class专属常量的地址, 或者需要定义式. 则需要在<code>实现文件</code>而非<code>头文件</code>, 如下声明<br><code>const int Game::MAX_ROOM</code> - 未给定初值<br>由于class常量已经在声明时获得初值, 所以不用在给定初值</p>\n<p>这里我发现一件事情, 这本书 不能只读一遍, 最少两边完整的<br>前面就已经开始使用后面的条款了, 先着重本条款, 跨条款的等第二遍</p>\n<h2 id=\"条款03-尽可能使用const\"><a href=\"#条款03-尽可能使用const\" class=\"headerlink\" title=\"条款03 尽可能使用const\"></a>条款03 尽可能使用const</h2><p><strong>总结</strong></p>\n<ul>\n<li>将某些东西声明为const可帮助编译器探测到错误用法<br>const可以用作在任何作用域内的对象, 函数参数, 函数返回类型, 成员函数本体</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> greeting[] = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *p = greeting;</span><br><span class=\"line\"><span class=\"comment\">// const 在 * 左边 被指物是常量 在右边自己是常量 两边都是常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *p = greeting; <span class=\"comment\">// 指针指向可以变, 指向的值不能变</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> p = greeting; <span class=\"comment\">// 指针指向不可以变, 指向的值可以变</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> p = greeting; <span class=\"comment\">// 都不可以变</span></span><br></pre></td></tr></table></figure>\n<p><strong>const 参数, 可你帮你检查 == 被写成=的情况</strong><br>这本书看来挺有意思的2333333</p>\n<p><strong>const 函数, 这里看不太懂 没有原来如此的感觉</strong></p>\n<h2 id=\"条款04-确定对象使用前已经被初始化\"><a href=\"#条款04-确定对象使用前已经被初始化\" class=\"headerlink\" title=\"条款04 确定对象使用前已经被初始化\"></a>条款04 确定对象使用前已经被初始化</h2><p><strong>总结</strong></p>\n<ul>\n<li>为内置型对象进行手工初始化.</li>\n<li>构造函数最好使用成员初值列, 不要在构造函数中赋值. 初值列次数应该与声明次序相同</li>\n<li>为了免除 跨编译单元的初始化次数问题, 用<code>local static</code>对象替换<code>non-local static</code>对象</li>\n</ul>\n<p>永远在使用对象前, 进行初始化.<br>在构造函数中, 对所有值进行初始化<br>构造函数使用<code>成员初始列</code>进行<code>初始化操作</code>而非<code>赋值操作</code></p>\n<p><strong>减少default构造函数不必要的调用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tA(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; &amp;room_list);</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name_;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; room_list_;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> roomnum_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A::A(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tname_ = name; <span class=\"comment\">// 这些都是赋值 不是初始化</span></span><br><span class=\"line\">\troom_list_ = room_list;</span><br><span class=\"line\">\troomnum_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// C++规定 对象的 成员变量  初始化动作  发生在  进入构造函数本体  之前</span></span><br><span class=\"line\"><span class=\"comment\">// name_  room_list_  两个在构造函数中被赋值, 而初始化在进入构造函数之前</span></span><br><span class=\"line\"><span class=\"comment\">// ---发生在这些成员的default构造函数被调用的时候, (发生在进入构造函数前)</span></span><br><span class=\"line\"><span class=\"comment\">// ---roomnum_例外 int属于内置类型</span></span><br></pre></td></tr></table></figure>\n<p>上面的初始化方式, 浪费了default的构造函数 所以推荐使用下面的形式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A::A(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class=\"line\">\t:name_(name), room_list_(room_list), roomnum_(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然最终结果相同, 但没有浪费default构造函数. 前两个调用的copy构造函数.</p>\n<p><strong>还可以使用成员初值列 来default构造一个成员变量.</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A::A()</span><br><span class=\"line\">\t:name_(), room_list_(), roomnum_(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123; <span class=\"comment\">// 前两个全部调用的default构造函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>const reference 内置类型(初始化与赋值等成本) 一定成员初始值列</strong></p>\n<p><strong>初始值列总是使用 声明次序进行初始化, 而非写的顺序, 所以最好按声明次序列出</strong></p>\n<p><strong>不同编译单元内定义之 non-local static对象 的初始化 次序</strong><br>static对象: 虚构函数会在main() 结束时被自动调用<br>local static对象: 函数内的static对象<br>non-local对象: 其他static对象</p>\n<p>编译单元: 产出单一目标文件的那些源码, 基本是单一源码文件和他包含的头文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// filesystem.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileSystem</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">GetNum</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> FIieSystem tfs; <span class=\"comment\">// 声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// filesystem.cpp</span></span><br><span class=\"line\">FIieSystem tfs; <span class=\"comment\">//定义</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// directory.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Directory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDirectory(params);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Directory::Directory(params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> num = tfs.GetNum(); <span class=\"comment\">// 使用tfs对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"function\">Directory <span class=\"title\">temp_dir</span><span class=\"params\">(params)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>只有当 tfs在temp_dir初始化之前被初始化 才能得到正确的结果. 否则会调用未初始化的对象</p>\n<p>但是这个次序无法保证, tfs和tempdir是不同的人在不同的时间于不同的源码文件建立起来的<br>因为C++ 对这种情况没有明确定义</p>\n<p>如何解决这个问题呢??<br>将每个<code>non-local static</code>对象搬到自己的专属函数内(该对象在此函数内被声明为static)<br>函数返回一个reference对象他所包含的对象<br>用户调用这个函数而不是直接调用对象</p>\n<p>解决的原因呢?<br>C++ 保证函数内的<code>local static</code>对象 会在<code>函数被调用期间</code>, <code>首次遇到该对象的定义式</code>被初始化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// filesystem.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileSystem</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> <span class=\"title\">GetNum</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">FileSystem</span>&amp; <span class=\"title\">tfs</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"built_in\">FileSystem</span> fs;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// directory.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Directory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDirectory(params);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Directory::Directory(params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> num = tfs().GetNum(); <span class=\"comment\">// 使用tfs对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">Directory&amp; <span class=\"title\">temp_dir</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> Directory td;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> td;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"构造析构赋值运算\"><a href=\"#构造析构赋值运算\" class=\"headerlink\" title=\"构造析构赋值运算\"></a>构造析构赋值运算</h1><h2 id=\"条款0506-了解C-默认编写并调用哪些函数-并适当拒绝\"><a href=\"#条款0506-了解C-默认编写并调用哪些函数-并适当拒绝\" class=\"headerlink\" title=\"条款0506 了解C++默认编写并调用哪些函数 并适当拒绝\"></a>条款0506 了解C++默认编写并调用哪些函数 并适当拒绝</h2><p><strong>夹带如下私货-public-inline</strong></p>\n<ul>\n<li>一个构造函数(如果你没有任何构造函数)</li>\n<li>一个拷贝构造函数</li>\n<li>一个析构函数</li>\n<li>一个拷贝</li>\n</ul>\n<p>拷贝构造函数和拷贝运算符 自动生成的只是单纯的将来源对象的每一个<code>non-static</code>成员变量<br>拷贝到目标对象</p>\n<p><strong>遇到const 和 引用成员 默认的拷贝无法工作, 编译器会发出警告</strong></p>\n<p><strong>将不需要的成员函数声明为private, 并且不实现</strong></p>\n<h2 id=\"条款07-为多态基类声明virtual析构函数\"><a href=\"#条款07-为多态基类声明virtual析构函数\" class=\"headerlink\" title=\"条款07 为多态基类声明virtual析构函数\"></a>条款07 为多态基类声明virtual析构函数</h2><p>返回指向子类的 父类型指针.<br>如果delete这个指针, 在父类析构函数不是virtual的情况下, 很可能会导致<br>父类的成分被销毁, 然而子类多出来的部分不被销毁. 造成局部销毁!!</p>\n<p><strong>防止局部销毁很简单, 将父类的析构函数声明为virtual</strong></p>\n<p><strong>任何class 只要带有virtual函数 几乎确定应该有一个virtual析构函数</strong></p>\n<p><strong>无端的声明virtual函数是错误的</strong><br>如果class不含virtual函数, 通常表示这个class 不是想做为父类, 这时如果将其析构函数声明为virual<br>是一个馊主意………….</p>\n<p><em>class类的大小 = 成员变量占据大小 + vptr(vitual table pointer)指针大小(4~8 字节)</em></p>\n<p>每一个带有virtual函数的class都有对应的vtbl</p>\n<p>当对象调用某一vitual函数的时候, 实际调用的函数取决于<br>vptr(vitual table pointer)指针指向的vtbl(vitual table)</p>\n<p>无端的使用virtual函数 会导致占用空间的增大</p>\n<h2 id=\"条款08-别让异常逃离析构函数\"><a href=\"#条款08-别让异常逃离析构函数\" class=\"headerlink\" title=\"条款08 别让异常逃离析构函数\"></a>条款08 别让异常逃离析构函数</h2><p><strong>总结</strong></p>\n<ul>\n<li>析构函数绝对不要抛出异常, 如果被析构函数调用的函数可能抛出异常, 析构函数应该捕获所有异常<br>然后吞下它们, 或者结束程序</li>\n<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应, class应该提供一个普通函数(而非在析构函数中)<br>执行操作</li>\n</ul>\n<p><strong>析构函数不要抛出异常</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t~Widget() &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Widget&gt; v;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 <code>v</code>被销毁的时候, Widget的析构函数第一次抛出异常C++还能接受?<br>第二次就会造成不明确行为</p>\n<h2 id=\"条款09-绝不在构造函数和析构过程中调用virtual函数\"><a href=\"#条款09-绝不在构造函数和析构过程中调用virtual函数\" class=\"headerlink\" title=\"条款09: 绝不在构造函数和析构过程中调用virtual函数\"></a>条款09: 绝不在构造函数和析构过程中调用virtual函数</h2><p><strong>总结</strong></p>\n<ul>\n<li>在构造和析构期间不要调用virtual函数, 因为这类调用从不下降到<code>子类</code></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transaction</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tTransaction();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">LogTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Transaction::Transaction()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tLogTransaction();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuyTransaction</span>:</span> <span class=\"keyword\">public</span> Transaction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">LogTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SellTransaction</span>:</span> <span class=\"keyword\">public</span> Transaction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">LogTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BuyTransaction b;</span><br></pre></td></tr></table></figure>\n<p>BuyTransaction的构造函数会被调用, 但是父类的构造函数会更显被调用.<br>然后父类构造函数调用<code>LogTransaction()</code>的版本是<code>父类</code>的版本!!! 不是子类的版本</p>\n<p>析构函数也是同样的道理, 当<code>子类</code>的析构函数执行后, <code>子类</code>中的属性值就成为未定义状态<br>进入<code>父类</code>后对象就成为一个<code>父类</code>对象</p>\n<p>本例子中既然无法实现使用<code>virtual</code>函数从<code>父类</code>向下调用, 可以再构造期间, 将<br><code>子类</code>必要的构造信息向上传给<code>父类</code>的构造函数</p>\n<h2 id=\"条款10-另operator-返回一个reference-to-this\"><a href=\"#条款10-另operator-返回一个reference-to-this\" class=\"headerlink\" title=\"条款10: 另operator= 返回一个reference to *this\"></a>条款10: 另operator= 返回一个reference to *this</h2><p>注意这只是一个协议, 并无强制性. 如果不遵守代码依然可以通过编译, 然而这份 协议被所有内置类型<br>和标准程序库提供的类型共同遵守.<br>因此除非你有一个标新立异的好理由, 不然还是随众吧</p>\n<h2 id=\"条款11-在operator-中处理”自我赋值”\"><a href=\"#条款11-在operator-中处理”自我赋值”\" class=\"headerlink\" title=\"条款11: 在operator= 中处理”自我赋值”\"></a>条款11: 在operator= 中处理”自我赋值”</h2><p><strong>总结</strong></p>\n<ul>\n<li>确保当对象自我赋值时operator=有良好的的行为. 其中技术包括比较”来源对象”<br>和”目标对象”的地址, 精心周到的语句顺序, 以及copy-and-swap</li>\n<li>确认任何函数如果操作一个以上的对象, 而其中多个对象是同一个对象的时候, 进行仍未正确</li>\n</ul>\n<p><strong>自我赋值是什么</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> &#123;</span>...&#125;;</span><br><span class=\"line\">Widget w;</span><br><span class=\"line\"></span><br><span class=\"line\">w=w; <span class=\"comment\">// 什么这个看起来不可能, 那下面呢?</span></span><br><span class=\"line\"></span><br><span class=\"line\">a[i] = a[j]; <span class=\"comment\">// 这个怎么样?  潜在的自我赋值</span></span><br><span class=\"line\">*px = *py <span class=\"comment\">// 这个呢? 潜在的自我赋值</span></span><br></pre></td></tr></table></figure>\n<p><strong>会出现的问题</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Gameroom</span>&#123;</span>....&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Game</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tGameroom* room_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// operator=的实现代码</span></span><br><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> room_;</span><br><span class=\"line\">\troom_ = <span class=\"keyword\">new</span> Gameroom(*ths.room_);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码 如果 this和ths指向同一个对象就会造成 <code>room_</code>构造失败<br>因为被<code>delete</code>的<code>room_</code>就是要传入的</p>\n<p>如何解决这个问题呢?<br><em>比较来源对象 整同测试</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;ths)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> room_;</span><br><span class=\"line\">\troom_ = <span class=\"keyword\">new</span> Gameroom(*ths.room_);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是如果 <code>new Gameroom(*ths.room_)</code>错误, 导致room_指向不安全的内存<br>使用下面的代码, 可以导出异常安全, 以及自我赋值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tGameroom* p_room = room_;</span><br><span class=\"line\">\troom_ = <span class=\"keyword\">new</span> Gameroom(*ths.room_);</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> p_room;</span><br><span class=\"line\">\tretutn *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在如果<code>new Gameroom</code>抛出异常, room_还可以保持原状.<br>同时也能处理自我赋值</p>\n<p><em>copy and swap</em><br>这一段描述我看完之后, 突然想到了上午看的Jsoncpp里面的代码!!!!! 就有这个<br>下面的代码更加高效 但是牺牲了清晰性</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Game</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(Game&amp; rhs)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tGame temp(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\tswap(temp);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"条款12-复制对象时勿忘其每一个成分\"><a href=\"#条款12-复制对象时勿忘其每一个成分\" class=\"headerlink\" title=\"条款12: 复制对象时勿忘其每一个成分\"></a>条款12: 复制对象时勿忘其每一个成分</h2><h1 id=\"资源管理\"><a href=\"#资源管理\" class=\"headerlink\" title=\"资源管理\"></a>资源管理</h1><h2 id=\"条款13-以对象管理资源\"><a href=\"#条款13-以对象管理资源\" class=\"headerlink\" title=\"条款13: 以对象管理资源\"></a>条款13: 以对象管理资源</h2><ul>\n<li>防止资源泄露请使用RALL对象, 他们在构造函数获得资源在析构函数释放资源</li>\n<li>较常使用的RALL classes是shared_ptr和auto_ptr(在C++17被删掉了) 建议使用前者其复制行为也比较直观</li>\n</ul>\n<p>使用工厂方法得到一个指向资源对象的指针, 使用这个指针操作完毕后需要delete 这个指针<br>这样这个资源对象的资源就能够被释放</p>\n<p>但是, 这是执行了delete的情况, 如果在<code>指针返回后</code> 在<code>delete执行前</code> 发生了各种情况导致<code>delete没有被执行</code><br>发生的情况包括但不限于, 提前return, 如果位于循环中还可能是continue乃至goto, 甚至是异常抛出.<br>所以直接使用指针管理资源十分不安全.</p>\n<p>同时我们知道 如果使用<code>资源管理对象</code>管理资源 使用资源管理对象的<code>析构函数来释放这个指向资源的指针</code><br>而且对象的<code>析构函数</code>会在资管管理对象<code>生命周期结束后自动调用</code>, 这样就能<code>自动删除资源</code>, 不用依赖手动在合适的时机delete</p>\n<p>使用智能指针是一个非常不错的选择, 当然要注意防止别让多个智能指针指向同一个对象.</p>\n<p>auto_ptr在C++17中被废除了, 简单了解下就好了. 书中称这是诡异的复制行为2333,<br>复加上其底层条件, 受auto_ptr管理的资源绝对没有一个以上的auto_ptr指向他</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pR1指向CreateResource的返回物</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">auto_ptr</span>&lt;Resource&gt; <span class=\"title\">pR1</span><span class=\"params\">(CreateResource())</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 现在pR2指向了, pR1被设置为了nullptr</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">auto_ptr</span>&lt;Resource&gt; <span class=\"title\">pR2</span><span class=\"params\">(pR1)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 现在pR1指向了, pR2又成了nullptr</span></span><br><span class=\"line\">pR1 = pR2;</span><br></pre></td></tr></table></figure>\n\n<p>引用计数型智慧指针……</p>\n<p><em>智能指针析构函数使用的是delete 而不是delete []</em> 所以不要将动态分配的数组保存进去</p>\n<h2 id=\"条款14-在资源管理类中小心copying行为\"><a href=\"#条款14-在资源管理类中小心copying行为\" class=\"headerlink\" title=\"条款14 在资源管理类中小心copying行为\"></a>条款14 在资源管理类中小心copying行为</h2><h1 id=\"设计与声明\"><a href=\"#设计与声明\" class=\"headerlink\" title=\"设计与声明\"></a>设计与声明</h1><h2 id=\"条款19-设计class犹如设计type\"><a href=\"#条款19-设计class犹如设计type\" class=\"headerlink\" title=\"条款19: 设计class犹如设计type\"></a>条款19: 设计class犹如设计type</h2><p>如何设计高效的classes呢?</p>\n<ul>\n<li>新class的对象该如何被创建和销毁? 这会影响到构造析构函数内存分配释放函数</li>\n<li>对象的初始化和对象的赋值有什么样的差别? 决定构造函数和赋值运算符的行为.<br>搞清初始化和赋值</li>\n<li>注意class对象被值传递 拷贝构造函数会被调用用来生成临时对象</li>\n<li>什么是新class的合法值? <code>setter</code>函数需要进行的范围检查</li>\n<li>你的新class需要配合某个继承图系吗? // TODO</li>\n<li>你的新class需要什么样的转换? 如果需要类型转换需要在class中编写<code>类型转换函数</code></li>\n<li>什么样的操作运算符和函数对此class而言是合理的? 决定你为class声明哪些函数(条款 23 24 46)</li>\n<li>将需要驳回的标准函数设置为private</li>\n<li>你的新type有多么一般化? 或许应该定义一整个class家族. 也许模板能帮你</li>\n</ul>\n<h2 id=\"条款20-const-引用-替换掉-值传递\"><a href=\"#条款20-const-引用-替换掉-值传递\" class=\"headerlink\" title=\"条款20: const 引用 替换掉 值传递\"></a>条款20: const 引用 替换掉 值传递</h2><p>值传递会造成大量额外的构造析构被调用</p>\n<p>通过引用传递还能避免对象切割问题. 当一个子类通过值传递并被视为一个基类的时候<br>子类的特性全部丢失</p>\n<p>对于内置类型而言 值传递 比 引用传递 更加高效</p>\n<h2 id=\"条款21-必须返回对象的时候-别妄想返回其引用\"><a href=\"#条款21-必须返回对象的时候-别妄想返回其引用\" class=\"headerlink\" title=\"条款21: 必须返回对象的时候, 别妄想返回其引用\"></a>条款21: 必须返回对象的时候, 别妄想返回其引用</h2><p>local对象如果被从函数 引用返回 函数结束的时候对象就被销毁 造成未定义行为</p>\n<p>如果通过 * 返回一个堆对象 的引用 将会造成诸如内存泄漏等问题</p>\n<h2 id=\"条款22-将成员变量声明为private\"><a href=\"#条款22-将成员变量声明为private\" class=\"headerlink\" title=\"条款22: 将成员变量声明为private\"></a>条款22: 将成员变量声明为private</h2><p>成员变量声明为private提供GetSet方法, 看似麻烦… 实则确实麻烦=, =<br>不过麻烦的相对面就是他的好处</p>\n<p>首先就是提供了封装, 一旦你更改了内如的成员变量的实现等, 你只需要改动GetSet方法, 外部浑然不知.<br>如果你声明为了public, 那么你有极大的可能需要修改每一处直接从外部使用成员的代码.</p>\n<p>之外你还可以将进行参数校验, 等等保护.</p>\n<h2 id=\"条款23-宁以non-member-non-friend替换member函数\"><a href=\"#条款23-宁以non-member-non-friend替换member函数\" class=\"headerlink\" title=\"条款23: 宁以non-member, non-friend替换member函数\"></a>条款23: 宁以non-member, non-friend替换member函数</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tDoA();</span><br><span class=\"line\">\tDoB();</span><br><span class=\"line\">\tDoC();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在你需要提供一个函数 <code>DoD()</code>实现上面三个函数的功能<br>你有两个选择</p>\n<ol>\n<li>增加一个新的成员函数<code>DoD()</code>内部调用三个函数</li>\n<li>增加一个普通函数, 增加<code>A&amp; a</code>参数调用内部的三个函数</li>\n</ol>\n<h1 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h1><h1 id=\"型别推导\"><a href=\"#型别推导\" class=\"headerlink\" title=\"型别推导\"></a>型别推导</h1><p>一个对象如果是右值则可以实施移动语义, 左值则不然</p>\n<p>如果能取得表达式的地址 - 断定表达式是左值<br>如果不可以通常是右值</p>\n<h2 id=\"条款1-理解模板型别推导\"><a href=\"#条款1-理解模板型别推导\" class=\"headerlink\" title=\"条款1: 理解模板型别推导\"></a>条款1: 理解模板型别推导</h2>"},{"title":"Linux高性能服务器-进程线程","date":"2020-02-25T14:34:39.000Z","top":102,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg","_content":"# 第十三章多进程编程\n\n## exec系列系统调用\n```c++\n#include <unistd.h>\n// 声明这个是外部函数或外部变量\nextern char** environ;\n\n// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻\n// arg-接受可变参数 和 argv用于向新的程序传递参数数组\n// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量\n// exec函数是不返回的, 除非出错\n// 如果未报错则源程序被新的程序完全替换\n\nint execl(const char* path, const char* arg, ...);\nint execlp(const char* file, const char* arg, ...);\nint execle(const char* path, const char* arg, ..., char* const envp[])\nint execv(const char* path, char* const argv[]);\nint execvp(const char* file, char* const argv[]);\nint execve(const char* path, char* const argv[], char* const envp[]);\n```\n## fork系统调用-进程的创建\n```c++\n#include <sys/types.h>\n#include <unistd.h>\n// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0\n// 次返回值用于区分是父进程还是子进程\n// 失败返回-1\npid_t fork(viod);\n```\nfork系统调用\nfork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项\n新的进程表项有很多的属性和原进程相同\n- 堆指针\n- 栈指针\n- 标志寄存器的值\n- 子进程代码与父进程完全相同\n- 同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)父进程的数据(堆数据, 栈数据, 静态数据)\n- 创建子进程后, *父进程打开的文件描述符默认在子进程中也是打开的* `文件描述符的引用计数`, `父进程的用户根目录, 当前工作目录等变量的引用计数` 均加1\n\n也存在不同的项目\n- 该进程的PPID(标识父进程)被设置成原进程的PID,  \n- `信号位图被清除`(原进程设置的信号处理函数对新进程无效)\n\n\n(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)\n\n\nThe child process is an exact duplicate of the parent process except\nfor the following points:\n*  The child has its own unique process ID, and this PID does not\n\tmatch the ID of any existing process group (setpgid(2)) or\n\tsession. 子进程拥有自己唯一的进程ID, 不与其他相同\n\n*  The child's parent process ID is the same as the parent's process\n\tID. 子进程的父进程ID PPID 与父进程ID PID相同\n\n*  The child does not inherit its parent's memory locks (mlock(2),\n\tmlockall(2)). 子进程不继承父进程的内存锁(保证一部分内存处于内存中, 而不是sawp分区)\n\n*  Process resource utilizations (getrusage(2)) and CPU time counters\n\t(times(2)) are reset to zero in the child.\n\t进程资源使用和CPU时间计数器在子进程中重置为0\n\n*  The child's set of pending signals is initially empty\n\t(sigpending(2)). 信号位图被初始化为空 原信号处理函数对子进程无效 需重新设置\n\n*  The child does not inherit semaphore adjustments from its parent\n\t(semop(2)). 不会继承semadj\n\n*  The child does not inherit process-associated record locks from\n\tits parent (fcntl(2)).  (On the other hand, it does inherit\n\tfcntl(2) open file description locks and flock(2) locks from its\n\tparent.)\n\n*  The child does not inherit timers from its parent (setitimer(2),\n\talarm(2), timer_create(2)). 不会继承定时器\n\n*  The child does not inherit outstanding asynchronous I/O operations\n\tfrom its parent (aio_read(3), aio_write(3)), nor does it inherit\n\tany asynchronous I/O contexts from its parent (see io_setup(2)).\n\n\n\n\n## 处理僵尸进程-进程的管理\n```c++\n#include <sys/types.h>\n#include <sys/wait.h>\n// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.\npid_t wait(int* stat_loc);\n\n// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)\n// options函数取值WNOHANG-waitpid立即返回\n// 如果目标子进程正常退出, 则返回子进程的pid\n// 如果还没有结束或意外终止, 则立即返回0\n// 调用失败返回-1\npid_t waitpid(pid_t pid, int* stat_loc, int options);\n\nWIFEXITED(stat_val); // 子进程正常结束, 返回一个非0\nWEXITSTATUS(stat_val); // 如果WIFEXITED 非0, 它返回子进程的退出码\nWIFSIGNALED(stat_val);// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值\nWTERMSIG(stat_val);// 如果WIFSIGNALED非0 返回一个信号值\nWIFSTOPPED(stat_val);// 如果子进程意外终止, 它返回一个非0值\nWSTOPSIG(stat_val);// 如果WIFSTOPED非0, 它返回一个信号值\n```\n\n对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询\n- 在`子进程结束运行之后, 父进程读取其退出状态前`, 我们称该子进程处于`僵尸态`\n- 另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) `父进程结束运行之后, 子进程退出之前`, 处于`僵尸态`\n\n以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.\n\nwaitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.\nSIGCHLD信号- 子进程结束后将会给父进程发送此信号\n```c++\nstatic void handle_child(int sig)\n{\n\tpid_t pid;\n\tint stat;\n\twhile ((pid = waitpid(-1, &stat, WNOHANG)) > 0)\n\t{\n\t\t// 善后处理emmmm\n\t}\n}\n```\n\n## 信号量-进程的锁\n*信号量原语*\n只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.\n假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为\n- P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行\n- V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png)\n\n**总结PV使用方法**\n\n使用`semget`获取到唯一的标识.\n使用`semctl`的`SETVAL`传入初始化val的`sem_un`联合体.来初始化val\n调用`semop` 传入唯一标识, `sem_op=-1`执行P(锁)操作`sem_op=1`执行V(开锁)操作\n开关锁通过当`sem_op=-1,semval=0 `\n且未指定`IPC_NOWAIT`\n等待`semval`被`sem_op=1`改为`semval=1`\n\n**创建信号量**\n```c++\n// semeget 系统调用\n// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集\n// key 参数是一个键值, 用来标识一个全局唯一的信号量级,可以在不同进程中获取\n// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0. 一般都是为1\n// sem_flags指定一组标志, 来控制权限\n// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错\n// - IPC_CREAT | IPC_EXCL来创建一组唯一信号量集 如果已经存在则会返回错误 errno = EEXIST\n// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1\nint semget(key_t key, int num_sems, int sem_flags);\n\nint sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT);\n```\n\n**初始化**\n```c++\n// semctl 系统调用\n// sem_id 参数是由semget返回的信号量集标识符\n// sen_num指定被操作的信号量在信号集中的编号\n// command指定命令, 可以追加命令所需的参数, 不过有推荐格式\n// 成功返回对应command的参数, 失败返回-1 errno\nint semctl(int sem_id, int sem_num, int command, ...);\n\n// 第四个参数 竟然需要手动声明...\nunion semun\n{\n\tint              val;    /* Value for SETVAL */\n\tstruct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */\n\tunsigned short  *array;  /* Array for GETALL, SETALL */\n\tstruct seminfo  *__buf;  /* Buffer for IPC_INFO\n\t\t\t\t\t\t\t\t(Linux-specific) */\n};\n// 初始化信号量\nunion semun sem_union;\nsem_union.val = 1;\n// 这里可以直接第三个参数传入1(val)\nif (semctl(sem_id, 0, SETVAL, sem_union) == -1)\n{\n\texit(0);\n}\n\n// 删除信号量\nunion semun sem_union{};\nif (semctl(sem_id, 0, IPC_RMID, sem_union) == -1)\n{\n\texit(EXIT_FAILURE);\n}\n```\n---\n与semop信号量关联的一些重要的内核变量\n```c++\nunsigned short semval; // 信号量的值\nunsigned short semzcnt; // 等待信号量值变为0的进程数量\nunsigned short semncnt// 等待信号量值增加的进程数量\npid_t sempid; // 最后一次执行semop操作的进程ID\n```\n操作信号量, 实际上就是对上面的内核变量操作\n\n```c++\n// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.\n// sem_ops 参数指向一个sembuf结构体类型的数组\n// num_sem_ops 说明操作数组中哪个信号量\n// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行\nint semop(int sem_id, struct sembuf* sem_ops, size_t num_sem_ops);\n\n// sem_op < 0 期望获得信号量\n// semval-=abs(sem_op),要求调用进程对被操作信号量集有写权限\n// 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量\n\n// 如果semval < abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN\n// 如果没有指定 则 阻塞进程等待信号量可用, 且 semzcnt +=1, 等到下面三种情况唤醒\n// 1 发生semval >= abs(sem_op), semzcnt-=1, semval-=abs(sem_op). 在SEM_UNDO设置时更新semadj\n// 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)\n// 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)\nbool P(int sem_id)\n{\n    struct sembuf sem_b;\n    sem_b.sem_num = 0; // 信号量编号 第几个信号量 一般都是第0个\n    sem_b.sem_op = -1; // P\n\t// IPC_NOWAIT 无论信号量操作是否成功, 都立即返回\n\t// SEM_UNDO当进程退出的时候, 取消正在进行的semop操作 PV操作系统更新进程的semadj变量\n    sem_b.sem_flg = SEM_UNDO;\n    return semop(sem_id, &sem_b, 1) != -1;\n}\n\n\n// sem_op > 0 \n// semval+=sem_op , 要求调用进程对被操作的信号量集有写权限\n// 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)\nbool V(int sem_id)\n{\n    struct sembuf sem_b;\n    sem_b.sem_num = 0;\n    sem_b.sem_op = 1; // V\n    sem_b.sem_flg = SEM_UNDO;\n    return semop(sem_id, &sem_b, 1) != -1;\n}\n\n\n// -- sem_op = 0\n// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限\n// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0\n// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN\n// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生\n// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1\n// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM\n// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1\n\n```\n\nsemget成功时返回一个与之关联的内核结构体semid_ds\n```c++\nstruct semid_ds\n{\n\tstruct ipc_perm sem_perm;\n\tunsigned long int sem_nsems; // 被设置为num_sems\n\ttime_t sem_otime; // 被设置为0\n\ttime_t sem_ctime; // 被设置为当前的系统时间\n}\n// 用来描述权限\nstruct ipc_perm\n{\n\tuid_t uid; // 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID\n\tgid_t gid; // 所有者的有效组ID, 被semget设置为调用进程的有效用户ID\n\tuid_t cuid; // 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID\n\tgid_t cgid; // 创建者的有效组ID, 被semget设置为调用进程的有效用户ID\n\tmode_t mode;// 访问权限, 背着只为sem_flags参数的最低9位.\n}\n```\n\n## 共享内存-进程间通信\n**最高效的IPC(进程间通信)机制**\n需要自己同步进程对其的访问, 否则会产生竞态条件\n\n```c++\n// key\n// 与semget相同 标识一段全局唯一的共享内存\n// size 内存区域大小 单位字节\n// shmflg\n// IPC_CREAT 存不存在都创建新的共享内存\n// IPC_CREAT | IPC_EXCL 不存在则创建 存在则报错\n// SHM_HUGETLB 系统将使用\"大页面\"来为共享内存分配空间\n// SHM_NORESERVE 不为共享内存保留swap空间, 如果物理内存不足\n// -在执行写操作的时候将会触发`SIGSEGV`信号\n// -成功返回唯一标识, 失败返回-1 errno\nint shmget(key_t key, size_t size, int shmflg)\n```\n\n```c++\n// shm_id \n// shmget返回的唯一标识\n// shm_addr \n// 关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响\n// 如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强\n// 如果 shm_addr 非空,且没有`SHM_RND`标志 则关联到指定的地址处\n// 如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写*\n// shmflg\n// SHM_RDONLY 设置后内存内容变成只读, 不设置则为读写模式\n// SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联\n// SHM_EXEC 有执行权限\n// 成功返回关联到的地址, 失败返回 (void*)-1 errno\nvoid* shmat(int shm_id, const void* shm_addr, int shmflg)\n\n// 将共享内存关联到进程的地址空间 调用成功之后, 修改shmid_ds的部分内容\n// -shm_nattach +1\n// -更新 shm_lpid\n// -shm_atime设置为当前时间\n```\n\n\n```c++\n// 将共享内存从进程地址空间中分离\n// 成功后\n// -shm_nattach -1\n// -更新 shm_lpid和shm_dtime设置为当前时间\n// 成功返回0 失败返回-1 errno\nint shmdt(const void* shm_addr)\n```\n\n```c++\nint shm_ctl(int shm_id, int command, struct shmid_ds* buf)\n```\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/shmctl.png)\n\n----\n\nshmget 同时会创建对应的`shmid_ds`结构体\n```c++\nstruct shmid_ds\n{\n\tstruct ipc_perm shm_per; // 权限相关\n\tsize_t shm_segsz; // 共享内存大小 单位字节\tsize\n\t__time_t shm_atime; // 对这段内存最后一次调用semat的时间 0\n\t__time_t shm_dtime; // 对这段内存最后一次调用semdt的时间 0\n\t__time_t shm_ctime; // 对这段内存最后一次调用semctl的时间 当前时间\n\t__pid_t shm_cpid; // 创建者PID\n\t__pid_t lpid; // 最后一次执行shmat或shmdt的进程PID\n\tshmatt_t shm_nattach // 关联到此共享内存空间的进程数量\n}\n```\n\n**共享内存的POSIX方法**\n```c++\nint shmfd = shm_open(\"/shm_name\", O_CREAT | O_RDWR, 0666);\nERROR_IF(shmfd == -1, \"shm open\");\n\nint ret = ftruncate(shmfd, BUFFER_SIZE);\nERROR_IF(ret == -1, \"ftruncate\");\n\nshare_mem = (char*)mmap(nullptr, BUFFER_SIZE,\n\t\tPROT_READ | PROT_WRITE, MAP_SHARED, shmfd, 0);\nERROR_IF(share_mem == MAP_FAILED, \"share_mem\");\nclose(shmfd);\n\n// 取消关联\nmunmap((void*)share_mem, BUFFER_SIZE);\n```\n\n## 进程通信-管道\n\n管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证\n父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].\n\n可以用两个管道来实现双向传输数据, 也可以用`socketpair`来创建管道\n\n## 消息队列\n消息队列是两个进程之间传递二进制块数据的一种简单有效的方式.\n每个数据块都有自己的类型, 接收方可以根据类型有选择的接收数据\n\n```c++\n#include <sys/msg.h>\n// 与semget 相同, 成功返回标识符\n// msgflg的设置和作用域setget相同\nint msgget(key_t key, int msgflg);\n```\n\n```c++\n// msg_ptr参数指向一个准备发送的消息, 消息必须按如下定义\n// msg_sz 指的是mtext的长度!!!\n// msgflg通常仅支持IPC_NOWAIT 以非阻塞形式发送数据\nint msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);\n默认如果消息队列已满, 则会阻塞. 如果设置了 IPC_NOTWAIT\n就立即返回 设置errno=EAGIN\n\n系统自带这个结构体 不过mtext长度是1...\nstruct msgbuf\n{\n\tlong mtype; /* 消息类型 正整数*/\n\tchar mtext[512]; /* 消息数据*/\n}\n```\n\n```c++\n// msgtype = 0 读取消息队列第一个消息\n// msgtype > 0 读取消息队列第一个类型是msgtype的消息 除非标志了MSG_EXCEPT\n// msgtype < 0 读取第一个 类型值 < abs(msgtype)的消息\n\n// IPC_NOWAIT 如果消息队列没有消息, 则msgrcv立即返回并设置errno=ENOMSG\n// MSG_EXCEPT 如果msgtype大于0, 则接收第一个非 msgtype 的数据\n// MSG_NOERROR 消息部分长度超过msg_sz 则将它截断\nint msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);\n处于阻塞状态 当消息队列被移除(errno=EIDRM)或者程序接受到信号(errno=EINTR) 都会中断阻塞状态\n```\n\n```c++\nint msgctl(int msqid, int command, struct msqid_ds *buf);\n\nIPC_STAT 复制消息队列关联的数据结构\nIPC_SET 将buf中的部分成员更新到目标的内核数据\nIPC_RMID 立即移除消息队列, 唤醒所有等待读消息和写消息的进程\nIPC_INFO 获取系统消息队列资源配置信息\n\nMSG_INFO 返回已经分配的消息队列所占用资源信息\nMSG_STAT msgqid不再是标识符, 而是内核消息队列的数组索引\n```\n\n\n## 在进程间传递文件描述符\n\n## IPC命令-查看进程间通信的全局唯一key\n\n# 第十四章 多线程编程\n根据运行环境和调度者身份, 线程可以分为两种\n内核线程\n运行在内核空间, 由内核来调度.\n用户线程\n运行在用空间, 由线程库来调用\n\n当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.\n\n线程有三种实现方式\n- 完全在用户空间实现-无需内核支持\n\t创建和调度线程无需内核干预, 速度很快.\n\t不占用额外的内核资源, 对系统影响较小\n\t但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的\n- 完全由内核调度\n\t创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理\n\t优缺点正好与上一个相反\n- 双层调度\n\t结合了前两个的优点\n\t不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势\n\n## 进程的创建和终止\n```c++\n#include <pthread.h>\nint pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine)(void*), void* arg);\n// 成功返回0 失败返回错误码\n// thread 用来唯一的标识一个新线程\n// attr用来设置新县城的属性 传递NULL表示默认线程属性\n// start_routine 指定新线程运行的函数\n// arg指定函数的参数\n```\n```c++\nvoid pthread_exit(void* retval);\n用来保证线程安全干净的退出, 线程函数最好结束时调用.\n通过`retval`参数向线程的回收者传递其退出信息\n执行后不会返回到调用者, 而且永远不会失败\n\nint pthread_join(pthread_t thread, void** retval)\n可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.\n成功时返回0, 失败返回错误码\n等待其他线程结束\nthread 线程标识符\nretval 目标线程的退出返回信息\n\n错误码如下\n`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用\n`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程\n`ESRCH`目标线程不存在\n\nint pthread_cancel(pthread_t thread)\n异常终止一个线程, 即为取消线程\n成功返回0, 失败返回错误码\n```\n\n**线程属性设置**\n```c++\n接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.\n// 启动线程取消\nint pthread_setcancelstart(int state, int* oldstate)\n第一个参数\nPTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态\nPTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求直到\n这个线程允许被取消\n第二个参数 返回之前设定的状态\n\n// 设置线程取消类型\nint pthread_setcanceltype(int type, int* oldtype)\n第一个参数\nPTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消\nPTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 直到调用了下面几个所谓的取消点函数\n最好使用pthread_testcancel函数设置取消点\n设置取消类型(如何取消)\n第二个参数\n原来的取消类型\n```\n\n**设置脱离线程**\n```c++\n// 初始化线程属性对象\nint pthread_attr_init(pthread_attr_t *attr);\n// 销毁线程属性对象, 直到再次初始化前都不能用\nint pthread_attr_destory(pthread_attr_t *attr)\n\n// 参数取值\n// -PTHREAD_CREATE_JOINABLE 线程可回收\n// -PTHREAD_CREATE_DETACH 脱离与进程中其他线程的同步 成为脱离线程\nint pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);\nint pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);\n// 可以直接设置为脱离线程\nint pthread_detach(pthread_t thread)\n```\n\n## 线程同步机制的使用场景\nPOSIX信号量-需要自己维护计数值, 用户空间有计数值 信号量自己又计数值\n两份计数值容易出错\n\n互斥锁-对临界资源的独占式访问\n\n条件变量-等待某个条件满足\n当某个共享数据达到某个值的时候, 唤醒等待这个共享数据的线程\n\n读写锁-可以多个进程读, 读的时候不能写, 同时只能一个写\n\n自旋锁-通过while循环频繁尝试获取锁, 适用于锁事件短, 需要快速切换的场景\n\n## POSIX信号量\n多线程也必须考虑线程同步的问题.\n虽然`pthread_join()`可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求\n比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.\n\n```c++\n#include<semaphore>\n// 用于初始化一个未命名的信号量.\n// pshared==0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享\n// value指定参数的初始值\nint sem_init(sem_t* sem, int pshared, unsigned int value)\n\n// 销毁信号量, 释放其占用的系统资源\nint sem_destory(sem_t* sem)\n\n// 以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞直到sem_wait具有非0值\nint sem_wait(sem_t* sem)\n\n// 跟上面的函数相同不过不会阻塞. 信号量不为0则减一操作, 为0则返回-1 errno\nint sem_trywait(sem_t* sem)\n\n// 原子操作将信号量的值 +1\nint sem_post(sem_t* sem)\n```\n初始化已经存在的信号量会导致无法预期的结果\n\n销毁正被其他线程等待的信号量, 将会导致无法预期的结果\n\n例子如下\n```c++\nconstexpr int kNumberMax = 10;\nstd::vector<int> number(kNumberMax);\n\nconstexpr int kThreadNum = 10;\nsem_t sems[kThreadNum];\npthread_t threads[kThreadNum];\n\nconstexpr int kPrintTime = 1;\n\nvoid* t(void *no)\n{\n    int start_sub = *static_cast<int*>(no);\n    int sub =start_sub;\n    int time = 0;\n    while(++time <= kPrintTime)\n    {\n\t\t// 锁住本线程 释放下一个线程\n        sem_wait(&sems[start_sub]);\n        printf(\"%d\\n\", number[sub]);\n        sem_post(&sems[(start_sub + 1) % kThreadNum]);\n\t\t// 计算下一次要打印的下标\n        sub = (sub + kThreadNum) % kNumberMax;\n    }\n    pthread_exit(nullptr);\n}\n\nint main()\n{\n    std::iota(number.begin(), number.end(), 0);\n    sem_init(&sems[0], 0, 1);\n    for (int i = 1; i < kThreadNum; ++i)\n    {\n        sem_init(&sems[i], 0, 0);\n    }\n    for (int i = 0; i < kThreadNum; ++i)\n    {\n        pthread_create(&threads[i], nullptr, t, &number[i]);\n    }\n\t// 等待最后一个线程结束\n    pthread_join(threads[kThreadNum - 1], nullptr);\n}\n```\nkThreadNum个进程依次打印`[0, kNumberMax)`\n每个进程打印kPrintTime次\n最后一个进程打印完后主线程才能结束\n\n## 互斥锁\n```c++\n// 初始化互斥锁\n// 第一个参数指向目标互斥锁, 第二个参数指定属性 nullptr则为默认\nint pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);\n\n// 销毁目标互斥锁\nint pthread_mutex_destory(pthread_mutex_t *mutex);\n\n// 针对普通锁加锁\nint pthread_mutex_lock(pthread_mutex_t *mutex);\n\n// 针对普通锁立即返回 目标未加锁则加锁 如果已经加锁则返回错误码EBUSY\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\n\n// 解锁 如果有其他线程在等待这个互斥锁, 则其中之一获得\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\n```\n\n销毁一个已经加锁的互斥锁 会发生不可预期的后果\n也可使使用宏`PTHREAD_MUTEX_INITIALIZER`来初始化一个互斥锁\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\n\n**互斥锁属性设置**\n\n```c++\nint pthread_mutexattr_init(pthread_mutexattr_t *attr);\n\nint pthread_mutexattr_destory(pthread_mutexattr_t *attr);\n\n// PTHREAD_PROCESS_SHARED 跨进程共享\n// PTHREAD_PROCESS_PRIVATE 隶属同一进程的线程\nint pthread_mutexattr_getpshared(const pthread_mutexattr_t *attr, int *pshared);\nint pthread_mutexattr_setpshared(const pthread_mutexattr_t *attr, int pshared);\n\n// PTHREAD_MUTEX_NORMAL 普通锁 默认类型\n// PTHREAD_MUTEX_ERRORCHECK 检错锁\n// PTHREAD_MUTEX_RECURSVE 嵌套锁\n// PTHREAD_MUTEX_DEFAULT 默认锁\nint pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *type);\nint pthread_mutexattr_settype(const pthread_mutexattr_t *attr, int type);\n```\nPTHREAD_MUTEX_NORMAL\n一个线程对其加锁后, 其他请求该锁的进程会形成一个等待队列, 解锁后然后按照优先级获得. 保证资源分配公平\nA线程对一个`已经加锁`的普通锁`再次加锁(也是A线程)`-同一线程在解锁前再次加锁引发死锁\n对一个已经`被其他线程加锁`的普通锁`解锁`, 或者`再次解锁已经解锁`的普通锁--解锁-不可预期后果\n\nPTHREAD_MUTEX_ERRORCHECK\n线程对`已经加锁`的检错锁`再次加锁`--加锁-加锁操作返回EDEADLK\n对一个已经`被其他线程加锁`的检错锁`解锁`, 或者`再次解锁已经解锁`的检错锁--解锁-返回EPERM\n\nPTHREAD_MUTEX_RECURSVE\n允许一个线程在释放锁前多次加锁 而不发生死锁.\n如果`其他线程`要获得这个锁, 则`当前锁拥有者`必须执行相应次数的解锁操作--加锁\n对于`已经被其他进程`加锁的嵌套锁解锁, 或者对`已经解锁`的再次解锁--解锁-返回EPERM\n\nPTHREAD_MUTEX_DEFAULT\n这种锁的实现可能为上面三种之一\n对已经加锁的默认锁再次加锁\n对被其他线程加锁的默认锁解锁\n再次解锁已经解锁的默认锁\n都将会发生不可预料后果\n\n例子\n```c++\npthread_mutex_t mutex;\nint count = 0;\nvoid* t(void *a)\n{\n    pthread_mutex_lock(&mutex);\n    printf(\"%d\\n\", count);\n    count++;\n    pthread_mutex_unlock(&mutex);\n}\nint main()\n{\n    pthread_mutex_init(&mutex, nullptr);\n    pthread_t thread[10];\n    for (int i = 0; i < 10; ++i)\n    {\n        pthread_create(&thread[i], nullptr, t, nullptr);\n    }\n    sleep(3);\n    pthread_mutex_destroy(&mutex);\n}\n```\n\n## 条件变量\n\n```c++\nint pthread_cond_init(pthread_cond_t *cond, const pthread_condattr *cond_attr);\n\n// 销毁一个正在被等待的条件变量 将会失败并返回EBUSY\nint pthread_cont_destory(pthread_cond_t *cond);\n\n// 广播式的唤醒所有等待目标条件变量的线程\nint pthread_cont_broadcast(pthread_cond_t *cond);\n\n// 唤醒一个等待目标条件变量的线程\nint pthread_cond_signal(pthread_cond_t *cond);\n\n// 等待目标条件变量\nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);\n```\n\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n将各个字段初始化为0\n\npthread_cond_wait的第二个参数, 用于保护条件变量的互斥锁\n掉用函数前必须将 mutex加锁, 否则会发生不可预料的后果.\n函数执行前将调用线程放入条件变量等待队列, 然后将mutex解锁\n\n从函数调用, 到被放入等待队列的时间内, pthread_cond_signal(broadcast)不会修改条件变量的值\n也就是 pthread_cond_wait函数不会错过目标条件变量的任何变化,\n将pthread_cond_wait函数返回的时候, 互斥锁mutex将会再次锁上\n\n例子\n```c++\npthread_mutex_t mutex;\npthread_cond_t cond;\nint good = 3;\nint produce_count = 0;\nint consume_count = 0;\n\nvoid* Producer(void *arg)\n{\n    while(produce_count < 10)\n    {\n        pthread_mutex_lock(&mutex);\n        good++;\n        pthread_mutex_unlock(&mutex);\n\n        produce_count++;\n        printf(\"produce a good\\n\");\n\t\t// 通知一个线程\n        pthread_cond_signal(&cond);\n        sleep(2);\n    }\n    pthread_exit(nullptr);\n}\n\nvoid* Consumer(void *arg)\n{\n    while (consume_count < 13)\n    {\n\t\t// 传入前需要加锁\n        pthread_mutex_lock(&mutex);\n        if (good > 0)\n        {\n            good--;\n            consume_count++;\n            printf(\"consume a good, reset %d\\n\", good);\n        }\n        else\n        {\n            printf(\"good is 0\\n\");\n            // wait pthread_cond_signal\n            pthread_cond_wait(&cond, &mutex);\n        }\n        pthread_mutex_unlock(&mutex);\n\n        usleep(500 * 1000);\n    }\n    pthread_exit(nullptr);\n}\n\nint main()\n{\n    mutex = PTHREAD_MUTEX_INITIALIZER;\n    cond = PTHREAD_COND_INITIALIZER;\n    pthread_t producer, consumer;\n\n    pthread_create(&consumer, nullptr, Consumer, nullptr);\n    pthread_create(&producer, nullptr, Producer, nullptr);\n\n    pthread_join(consumer, nullptr);\n    pthread_mutex_destroy(&mutex);\n    pthread_cond_destroy(&cond);\n}\n```\n\n## 读写锁\n\n## 自旋锁\n\n\n## 线程同步包装类-多线程环境\n```c++\nclass Sem\n{\npublic:\n    Sem()\n    {\n        if (sem_init(&sem_, 0, 0) != 0)\n        {\n            throw std::exception();\n        }\n    }\n    ~Sem()\n    {\n        sem_destroy(&sem_);\n    }\n    bool Wait()\n    {\n        return sem_wait(&sem_) == 0;\n    }\n    bool Post()\n    {\n        return sem_post(&sem_) == 0;\n    }\nprivate:\n    sem_t sem_;\n};\n\nclass Mutex\n{\npublic:\n    Mutex()\n    {\n        if (pthread_mutex_init(&mutex_, nullptr) != 0)\n        {\n            throw std::exception();\n        }\n\n    }\n    ~Mutex()\n    {\n        pthread_mutex_destroy(&mutex_);\n    }\n    bool Lock()\n    {\n        return pthread_mutex_lock(&mutex_) == 0;\n    }\n    bool Unlock()\n    {\n        return pthread_mutex_unlock(&mutex_) == 0;\n    }\n\nprivate:\n    pthread_mutex_t mutex_;\n};\n\nclass Cond\n{\npublic:\n    Cond()\n    {\n        if (pthread_mutex_init(&mutex_, nullptr) != 0)\n        {\n            throw std::exception();\n        }\n        if (pthread_cond_init(&cond_, nullptr) != 0)\n        {\n            // 这里我一开始没有想到..\n            pthread_mutex_destroy(&mutex_);\n            throw std::exception();\n        }\n    }\n    ~Cond()\n    {\n        pthread_mutex_destroy(&mutex_);\n        pthread_cond_destroy(&cond_);\n    };\n    bool Wait()\n    {\n        int ret = 0;\n        pthread_mutex_lock(&mutex_);\n        ret = pthread_cond_wait(&cond_, &mutex_);\n        pthread_mutex_unlock(&mutex_);\n        return ret == 0;\n    }\n    bool Signal()\n    {\n        return pthread_cond_signal(&cond_) == 0;\n    }\nprivate:\n    pthread_cond_t cond_;\n    pthread_mutex_t mutex_;\n};\n```\n\n线程安全或可重入函数--函数能被多个线程同时调用而不发生竞态条件\n\n多线程程序某个线程调用fork函数, 新进程不会与父进程有相同数量的线程\n子进程只有一个线程-调用fork线程的完美复制\n\n但是子进程会继承父进程的互斥锁(条件变量)的状态, 如果互斥锁被加锁了, 但`不是由`调用fork线程\n锁住的, 此时`子进程`再次对这个互斥锁`执行加锁`操作将会`死锁`.\n\n```c++\npthread_mutex_t mutex;\nvoid* another(void *arg)\n{\n    printf(\"in child thread, lock the mutex\\n\");\n    pthread_mutex_lock(&mutex);\n    sleep(5);\n    // 解锁后 Prepare才能加锁\n    pthread_mutex_unlock(&mutex);\n    pthread_exit(nullptr);\n}\n// 这个函数在fork创建子进程前被调用\nvoid Prepare()\n{\n    // 但是会阻塞 直到执行another函数的线程解锁 才能够继续执行\n    // 这个函数执行完毕前fork不会创建子进程\n    pthread_mutex_lock(&mutex);\n}\n// fork创建线程后 返回前 会在子进程和父进程中执行这个函数\nvoid Infork()\n{\n    pthread_mutex_unlock(&mutex);\n}\nint main()\n{\n    pthread_mutex_init(&mutex, nullptr);\n    pthread_t id;\n    pthread_create(&id, nullptr, another, nullptr);\n\n    sleep(1);\n    // pthread_atfork(Prepare, Infork, Infork);\n    int pid = fork();\n    if (pid < 0)\n    {\n        printf(\"emmm????\\n\");\n        pthread_join(id, nullptr);\n        pthread_mutex_destroy(&mutex);\n        return 1;\n    }\n    else if (pid == 0)\n    {\n        printf(\"child process, want to get the lock\\n\");\n        pthread_mutex_lock(&mutex);\n        printf(\"i cann't run to here, opps....\\n\");\n        pthread_mutex_unlock(&mutex);\n        exit(0);\n    }\n    else\n    {\n        printf(\"wait start\\n\");\n        wait(nullptr);\n        printf(\"wait over\\n\"); // 没有打印 因为子进程不会终止\n    }\n    pthread_join(id, nullptr);\n    pthread_mutex_destroy(&mutex);\n    return 0;\n}\n// $ in child thread, lock the mutex\n// $ wait start\n// $ child process, want to get the lock\n\n// $ in child thread, lock the mutex\n// $ wait start\n// $ child process, want to get the lock\n// $ i cann't run to here, opps....\n// $ wait over\n```\n\n原版就会发生死锁, 新版(去掉注释的代码) 能够正常运行\n\n```c++\nint pthread_atfork (void (*__prepare) (void),\n\t\t\t   void (*__parent) (void),\n\t\t\t   void (*__child) (void));\n```\n第一个句柄 在fork创建子进程前执行\n第二个句柄 在fork创建出子进程后, fork返回前在父进程中执行\n第二个句柄 在fork创建出子进程后, fork返回前在子进程中执行\n\n\n# 第十五章 进程池和线程池\n\n# 线程池 和 简单HTTP服务器\n对我而言神秘已久的线程池终于揭开了面纱.\n没想到这就是线程池23333\n\n线程池写完后 直接写了书上的HTTP服务器.\n\n那个服务器至少我发现两个问题\n- 无法发送大文件\n- 部分请求无法回复\n\n无法发送大文件, 是因为书中使用了writev发送数据\n期初我以为下面的判断 writev返回值 等于 -1就是为了发送大文件, 后来发现这个判断只是给期初就发送失败准备的.\n\n正好前一阵子看了一个服务器的代码\nhttps://github.com/Jigokubana/Notes-flamingo\n\n\n我就索性直接将发送部分修改了\n```c++\n// write_sum_ 需发送总大小\n// write_idx_ 已发送大小\n\nint temp = 0;\nif (write_sum_ - write_idx_ == 0)\n{\n    Modfd(epollfd_, sockfd_, EPOLLIN);\n    Init();\n    return true;\n}\nwhile (true)\n{\n    temp = send(sockfd_, &*write_buff_.begin() + write_idx_, write_sum_ - write_idx_, 0);\n    if (temp <= -1)\n    {\n        if (errno == EAGAIN)\n        {\n            Modfd(epollfd_, sockfd_, EPOLLOUT);\n            return true;\n        }\n    }\n    write_idx_ += temp;\n\n    if (write_idx_ == write_sum_)\n    {\n        // 解除绑定移到了其他地方\n        if (linger_)\n        {\n            Init();\n            Modfd(epollfd_, sockfd_, EPOLLIN);\n            return true;\n        }\n        else\n        {\n            Modfd(epollfd_, sockfd_, EPOLLIN);\n            return false;\n        }\n    }\n}\n```\n\n第二个奇葩的问题就是使用ab压测时候 有些请求无法收到回复.\n这个问题等后面在解决把, 等我知识更加丰富了再说","source":"_posts/读书记录102-高性能服务器编程读书记录进程线程部分.md","raw":"---\ntitle: Linux高性能服务器-进程线程\ntags:\n  - null\ncategories:\n  - 读书记录\ndate: 2020-02-25 22:34:39\n\ntop: 102\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg\n---\n# 第十三章多进程编程\n\n## exec系列系统调用\n```c++\n#include <unistd.h>\n// 声明这个是外部函数或外部变量\nextern char** environ;\n\n// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻\n// arg-接受可变参数 和 argv用于向新的程序传递参数数组\n// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量\n// exec函数是不返回的, 除非出错\n// 如果未报错则源程序被新的程序完全替换\n\nint execl(const char* path, const char* arg, ...);\nint execlp(const char* file, const char* arg, ...);\nint execle(const char* path, const char* arg, ..., char* const envp[])\nint execv(const char* path, char* const argv[]);\nint execvp(const char* file, char* const argv[]);\nint execve(const char* path, char* const argv[], char* const envp[]);\n```\n## fork系统调用-进程的创建\n```c++\n#include <sys/types.h>\n#include <unistd.h>\n// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0\n// 次返回值用于区分是父进程还是子进程\n// 失败返回-1\npid_t fork(viod);\n```\nfork系统调用\nfork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项\n新的进程表项有很多的属性和原进程相同\n- 堆指针\n- 栈指针\n- 标志寄存器的值\n- 子进程代码与父进程完全相同\n- 同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)父进程的数据(堆数据, 栈数据, 静态数据)\n- 创建子进程后, *父进程打开的文件描述符默认在子进程中也是打开的* `文件描述符的引用计数`, `父进程的用户根目录, 当前工作目录等变量的引用计数` 均加1\n\n也存在不同的项目\n- 该进程的PPID(标识父进程)被设置成原进程的PID,  \n- `信号位图被清除`(原进程设置的信号处理函数对新进程无效)\n\n\n(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)\n\n\nThe child process is an exact duplicate of the parent process except\nfor the following points:\n*  The child has its own unique process ID, and this PID does not\n\tmatch the ID of any existing process group (setpgid(2)) or\n\tsession. 子进程拥有自己唯一的进程ID, 不与其他相同\n\n*  The child's parent process ID is the same as the parent's process\n\tID. 子进程的父进程ID PPID 与父进程ID PID相同\n\n*  The child does not inherit its parent's memory locks (mlock(2),\n\tmlockall(2)). 子进程不继承父进程的内存锁(保证一部分内存处于内存中, 而不是sawp分区)\n\n*  Process resource utilizations (getrusage(2)) and CPU time counters\n\t(times(2)) are reset to zero in the child.\n\t进程资源使用和CPU时间计数器在子进程中重置为0\n\n*  The child's set of pending signals is initially empty\n\t(sigpending(2)). 信号位图被初始化为空 原信号处理函数对子进程无效 需重新设置\n\n*  The child does not inherit semaphore adjustments from its parent\n\t(semop(2)). 不会继承semadj\n\n*  The child does not inherit process-associated record locks from\n\tits parent (fcntl(2)).  (On the other hand, it does inherit\n\tfcntl(2) open file description locks and flock(2) locks from its\n\tparent.)\n\n*  The child does not inherit timers from its parent (setitimer(2),\n\talarm(2), timer_create(2)). 不会继承定时器\n\n*  The child does not inherit outstanding asynchronous I/O operations\n\tfrom its parent (aio_read(3), aio_write(3)), nor does it inherit\n\tany asynchronous I/O contexts from its parent (see io_setup(2)).\n\n\n\n\n## 处理僵尸进程-进程的管理\n```c++\n#include <sys/types.h>\n#include <sys/wait.h>\n// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.\npid_t wait(int* stat_loc);\n\n// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)\n// options函数取值WNOHANG-waitpid立即返回\n// 如果目标子进程正常退出, 则返回子进程的pid\n// 如果还没有结束或意外终止, 则立即返回0\n// 调用失败返回-1\npid_t waitpid(pid_t pid, int* stat_loc, int options);\n\nWIFEXITED(stat_val); // 子进程正常结束, 返回一个非0\nWEXITSTATUS(stat_val); // 如果WIFEXITED 非0, 它返回子进程的退出码\nWIFSIGNALED(stat_val);// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值\nWTERMSIG(stat_val);// 如果WIFSIGNALED非0 返回一个信号值\nWIFSTOPPED(stat_val);// 如果子进程意外终止, 它返回一个非0值\nWSTOPSIG(stat_val);// 如果WIFSTOPED非0, 它返回一个信号值\n```\n\n对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询\n- 在`子进程结束运行之后, 父进程读取其退出状态前`, 我们称该子进程处于`僵尸态`\n- 另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) `父进程结束运行之后, 子进程退出之前`, 处于`僵尸态`\n\n以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.\n\nwaitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.\nSIGCHLD信号- 子进程结束后将会给父进程发送此信号\n```c++\nstatic void handle_child(int sig)\n{\n\tpid_t pid;\n\tint stat;\n\twhile ((pid = waitpid(-1, &stat, WNOHANG)) > 0)\n\t{\n\t\t// 善后处理emmmm\n\t}\n}\n```\n\n## 信号量-进程的锁\n*信号量原语*\n只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.\n假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为\n- P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行\n- V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png)\n\n**总结PV使用方法**\n\n使用`semget`获取到唯一的标识.\n使用`semctl`的`SETVAL`传入初始化val的`sem_un`联合体.来初始化val\n调用`semop` 传入唯一标识, `sem_op=-1`执行P(锁)操作`sem_op=1`执行V(开锁)操作\n开关锁通过当`sem_op=-1,semval=0 `\n且未指定`IPC_NOWAIT`\n等待`semval`被`sem_op=1`改为`semval=1`\n\n**创建信号量**\n```c++\n// semeget 系统调用\n// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集\n// key 参数是一个键值, 用来标识一个全局唯一的信号量级,可以在不同进程中获取\n// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0. 一般都是为1\n// sem_flags指定一组标志, 来控制权限\n// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错\n// - IPC_CREAT | IPC_EXCL来创建一组唯一信号量集 如果已经存在则会返回错误 errno = EEXIST\n// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1\nint semget(key_t key, int num_sems, int sem_flags);\n\nint sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT);\n```\n\n**初始化**\n```c++\n// semctl 系统调用\n// sem_id 参数是由semget返回的信号量集标识符\n// sen_num指定被操作的信号量在信号集中的编号\n// command指定命令, 可以追加命令所需的参数, 不过有推荐格式\n// 成功返回对应command的参数, 失败返回-1 errno\nint semctl(int sem_id, int sem_num, int command, ...);\n\n// 第四个参数 竟然需要手动声明...\nunion semun\n{\n\tint              val;    /* Value for SETVAL */\n\tstruct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */\n\tunsigned short  *array;  /* Array for GETALL, SETALL */\n\tstruct seminfo  *__buf;  /* Buffer for IPC_INFO\n\t\t\t\t\t\t\t\t(Linux-specific) */\n};\n// 初始化信号量\nunion semun sem_union;\nsem_union.val = 1;\n// 这里可以直接第三个参数传入1(val)\nif (semctl(sem_id, 0, SETVAL, sem_union) == -1)\n{\n\texit(0);\n}\n\n// 删除信号量\nunion semun sem_union{};\nif (semctl(sem_id, 0, IPC_RMID, sem_union) == -1)\n{\n\texit(EXIT_FAILURE);\n}\n```\n---\n与semop信号量关联的一些重要的内核变量\n```c++\nunsigned short semval; // 信号量的值\nunsigned short semzcnt; // 等待信号量值变为0的进程数量\nunsigned short semncnt// 等待信号量值增加的进程数量\npid_t sempid; // 最后一次执行semop操作的进程ID\n```\n操作信号量, 实际上就是对上面的内核变量操作\n\n```c++\n// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.\n// sem_ops 参数指向一个sembuf结构体类型的数组\n// num_sem_ops 说明操作数组中哪个信号量\n// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行\nint semop(int sem_id, struct sembuf* sem_ops, size_t num_sem_ops);\n\n// sem_op < 0 期望获得信号量\n// semval-=abs(sem_op),要求调用进程对被操作信号量集有写权限\n// 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量\n\n// 如果semval < abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN\n// 如果没有指定 则 阻塞进程等待信号量可用, 且 semzcnt +=1, 等到下面三种情况唤醒\n// 1 发生semval >= abs(sem_op), semzcnt-=1, semval-=abs(sem_op). 在SEM_UNDO设置时更新semadj\n// 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)\n// 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)\nbool P(int sem_id)\n{\n    struct sembuf sem_b;\n    sem_b.sem_num = 0; // 信号量编号 第几个信号量 一般都是第0个\n    sem_b.sem_op = -1; // P\n\t// IPC_NOWAIT 无论信号量操作是否成功, 都立即返回\n\t// SEM_UNDO当进程退出的时候, 取消正在进行的semop操作 PV操作系统更新进程的semadj变量\n    sem_b.sem_flg = SEM_UNDO;\n    return semop(sem_id, &sem_b, 1) != -1;\n}\n\n\n// sem_op > 0 \n// semval+=sem_op , 要求调用进程对被操作的信号量集有写权限\n// 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)\nbool V(int sem_id)\n{\n    struct sembuf sem_b;\n    sem_b.sem_num = 0;\n    sem_b.sem_op = 1; // V\n    sem_b.sem_flg = SEM_UNDO;\n    return semop(sem_id, &sem_b, 1) != -1;\n}\n\n\n// -- sem_op = 0\n// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限\n// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0\n// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN\n// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生\n// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1\n// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM\n// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1\n\n```\n\nsemget成功时返回一个与之关联的内核结构体semid_ds\n```c++\nstruct semid_ds\n{\n\tstruct ipc_perm sem_perm;\n\tunsigned long int sem_nsems; // 被设置为num_sems\n\ttime_t sem_otime; // 被设置为0\n\ttime_t sem_ctime; // 被设置为当前的系统时间\n}\n// 用来描述权限\nstruct ipc_perm\n{\n\tuid_t uid; // 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID\n\tgid_t gid; // 所有者的有效组ID, 被semget设置为调用进程的有效用户ID\n\tuid_t cuid; // 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID\n\tgid_t cgid; // 创建者的有效组ID, 被semget设置为调用进程的有效用户ID\n\tmode_t mode;// 访问权限, 背着只为sem_flags参数的最低9位.\n}\n```\n\n## 共享内存-进程间通信\n**最高效的IPC(进程间通信)机制**\n需要自己同步进程对其的访问, 否则会产生竞态条件\n\n```c++\n// key\n// 与semget相同 标识一段全局唯一的共享内存\n// size 内存区域大小 单位字节\n// shmflg\n// IPC_CREAT 存不存在都创建新的共享内存\n// IPC_CREAT | IPC_EXCL 不存在则创建 存在则报错\n// SHM_HUGETLB 系统将使用\"大页面\"来为共享内存分配空间\n// SHM_NORESERVE 不为共享内存保留swap空间, 如果物理内存不足\n// -在执行写操作的时候将会触发`SIGSEGV`信号\n// -成功返回唯一标识, 失败返回-1 errno\nint shmget(key_t key, size_t size, int shmflg)\n```\n\n```c++\n// shm_id \n// shmget返回的唯一标识\n// shm_addr \n// 关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响\n// 如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强\n// 如果 shm_addr 非空,且没有`SHM_RND`标志 则关联到指定的地址处\n// 如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写*\n// shmflg\n// SHM_RDONLY 设置后内存内容变成只读, 不设置则为读写模式\n// SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联\n// SHM_EXEC 有执行权限\n// 成功返回关联到的地址, 失败返回 (void*)-1 errno\nvoid* shmat(int shm_id, const void* shm_addr, int shmflg)\n\n// 将共享内存关联到进程的地址空间 调用成功之后, 修改shmid_ds的部分内容\n// -shm_nattach +1\n// -更新 shm_lpid\n// -shm_atime设置为当前时间\n```\n\n\n```c++\n// 将共享内存从进程地址空间中分离\n// 成功后\n// -shm_nattach -1\n// -更新 shm_lpid和shm_dtime设置为当前时间\n// 成功返回0 失败返回-1 errno\nint shmdt(const void* shm_addr)\n```\n\n```c++\nint shm_ctl(int shm_id, int command, struct shmid_ds* buf)\n```\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/shmctl.png)\n\n----\n\nshmget 同时会创建对应的`shmid_ds`结构体\n```c++\nstruct shmid_ds\n{\n\tstruct ipc_perm shm_per; // 权限相关\n\tsize_t shm_segsz; // 共享内存大小 单位字节\tsize\n\t__time_t shm_atime; // 对这段内存最后一次调用semat的时间 0\n\t__time_t shm_dtime; // 对这段内存最后一次调用semdt的时间 0\n\t__time_t shm_ctime; // 对这段内存最后一次调用semctl的时间 当前时间\n\t__pid_t shm_cpid; // 创建者PID\n\t__pid_t lpid; // 最后一次执行shmat或shmdt的进程PID\n\tshmatt_t shm_nattach // 关联到此共享内存空间的进程数量\n}\n```\n\n**共享内存的POSIX方法**\n```c++\nint shmfd = shm_open(\"/shm_name\", O_CREAT | O_RDWR, 0666);\nERROR_IF(shmfd == -1, \"shm open\");\n\nint ret = ftruncate(shmfd, BUFFER_SIZE);\nERROR_IF(ret == -1, \"ftruncate\");\n\nshare_mem = (char*)mmap(nullptr, BUFFER_SIZE,\n\t\tPROT_READ | PROT_WRITE, MAP_SHARED, shmfd, 0);\nERROR_IF(share_mem == MAP_FAILED, \"share_mem\");\nclose(shmfd);\n\n// 取消关联\nmunmap((void*)share_mem, BUFFER_SIZE);\n```\n\n## 进程通信-管道\n\n管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证\n父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].\n\n可以用两个管道来实现双向传输数据, 也可以用`socketpair`来创建管道\n\n## 消息队列\n消息队列是两个进程之间传递二进制块数据的一种简单有效的方式.\n每个数据块都有自己的类型, 接收方可以根据类型有选择的接收数据\n\n```c++\n#include <sys/msg.h>\n// 与semget 相同, 成功返回标识符\n// msgflg的设置和作用域setget相同\nint msgget(key_t key, int msgflg);\n```\n\n```c++\n// msg_ptr参数指向一个准备发送的消息, 消息必须按如下定义\n// msg_sz 指的是mtext的长度!!!\n// msgflg通常仅支持IPC_NOWAIT 以非阻塞形式发送数据\nint msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);\n默认如果消息队列已满, 则会阻塞. 如果设置了 IPC_NOTWAIT\n就立即返回 设置errno=EAGIN\n\n系统自带这个结构体 不过mtext长度是1...\nstruct msgbuf\n{\n\tlong mtype; /* 消息类型 正整数*/\n\tchar mtext[512]; /* 消息数据*/\n}\n```\n\n```c++\n// msgtype = 0 读取消息队列第一个消息\n// msgtype > 0 读取消息队列第一个类型是msgtype的消息 除非标志了MSG_EXCEPT\n// msgtype < 0 读取第一个 类型值 < abs(msgtype)的消息\n\n// IPC_NOWAIT 如果消息队列没有消息, 则msgrcv立即返回并设置errno=ENOMSG\n// MSG_EXCEPT 如果msgtype大于0, 则接收第一个非 msgtype 的数据\n// MSG_NOERROR 消息部分长度超过msg_sz 则将它截断\nint msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);\n处于阻塞状态 当消息队列被移除(errno=EIDRM)或者程序接受到信号(errno=EINTR) 都会中断阻塞状态\n```\n\n```c++\nint msgctl(int msqid, int command, struct msqid_ds *buf);\n\nIPC_STAT 复制消息队列关联的数据结构\nIPC_SET 将buf中的部分成员更新到目标的内核数据\nIPC_RMID 立即移除消息队列, 唤醒所有等待读消息和写消息的进程\nIPC_INFO 获取系统消息队列资源配置信息\n\nMSG_INFO 返回已经分配的消息队列所占用资源信息\nMSG_STAT msgqid不再是标识符, 而是内核消息队列的数组索引\n```\n\n\n## 在进程间传递文件描述符\n\n## IPC命令-查看进程间通信的全局唯一key\n\n# 第十四章 多线程编程\n根据运行环境和调度者身份, 线程可以分为两种\n内核线程\n运行在内核空间, 由内核来调度.\n用户线程\n运行在用空间, 由线程库来调用\n\n当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.\n\n线程有三种实现方式\n- 完全在用户空间实现-无需内核支持\n\t创建和调度线程无需内核干预, 速度很快.\n\t不占用额外的内核资源, 对系统影响较小\n\t但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的\n- 完全由内核调度\n\t创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理\n\t优缺点正好与上一个相反\n- 双层调度\n\t结合了前两个的优点\n\t不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势\n\n## 进程的创建和终止\n```c++\n#include <pthread.h>\nint pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine)(void*), void* arg);\n// 成功返回0 失败返回错误码\n// thread 用来唯一的标识一个新线程\n// attr用来设置新县城的属性 传递NULL表示默认线程属性\n// start_routine 指定新线程运行的函数\n// arg指定函数的参数\n```\n```c++\nvoid pthread_exit(void* retval);\n用来保证线程安全干净的退出, 线程函数最好结束时调用.\n通过`retval`参数向线程的回收者传递其退出信息\n执行后不会返回到调用者, 而且永远不会失败\n\nint pthread_join(pthread_t thread, void** retval)\n可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.\n成功时返回0, 失败返回错误码\n等待其他线程结束\nthread 线程标识符\nretval 目标线程的退出返回信息\n\n错误码如下\n`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用\n`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程\n`ESRCH`目标线程不存在\n\nint pthread_cancel(pthread_t thread)\n异常终止一个线程, 即为取消线程\n成功返回0, 失败返回错误码\n```\n\n**线程属性设置**\n```c++\n接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.\n// 启动线程取消\nint pthread_setcancelstart(int state, int* oldstate)\n第一个参数\nPTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态\nPTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求直到\n这个线程允许被取消\n第二个参数 返回之前设定的状态\n\n// 设置线程取消类型\nint pthread_setcanceltype(int type, int* oldtype)\n第一个参数\nPTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消\nPTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 直到调用了下面几个所谓的取消点函数\n最好使用pthread_testcancel函数设置取消点\n设置取消类型(如何取消)\n第二个参数\n原来的取消类型\n```\n\n**设置脱离线程**\n```c++\n// 初始化线程属性对象\nint pthread_attr_init(pthread_attr_t *attr);\n// 销毁线程属性对象, 直到再次初始化前都不能用\nint pthread_attr_destory(pthread_attr_t *attr)\n\n// 参数取值\n// -PTHREAD_CREATE_JOINABLE 线程可回收\n// -PTHREAD_CREATE_DETACH 脱离与进程中其他线程的同步 成为脱离线程\nint pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);\nint pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);\n// 可以直接设置为脱离线程\nint pthread_detach(pthread_t thread)\n```\n\n## 线程同步机制的使用场景\nPOSIX信号量-需要自己维护计数值, 用户空间有计数值 信号量自己又计数值\n两份计数值容易出错\n\n互斥锁-对临界资源的独占式访问\n\n条件变量-等待某个条件满足\n当某个共享数据达到某个值的时候, 唤醒等待这个共享数据的线程\n\n读写锁-可以多个进程读, 读的时候不能写, 同时只能一个写\n\n自旋锁-通过while循环频繁尝试获取锁, 适用于锁事件短, 需要快速切换的场景\n\n## POSIX信号量\n多线程也必须考虑线程同步的问题.\n虽然`pthread_join()`可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求\n比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.\n\n```c++\n#include<semaphore>\n// 用于初始化一个未命名的信号量.\n// pshared==0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享\n// value指定参数的初始值\nint sem_init(sem_t* sem, int pshared, unsigned int value)\n\n// 销毁信号量, 释放其占用的系统资源\nint sem_destory(sem_t* sem)\n\n// 以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞直到sem_wait具有非0值\nint sem_wait(sem_t* sem)\n\n// 跟上面的函数相同不过不会阻塞. 信号量不为0则减一操作, 为0则返回-1 errno\nint sem_trywait(sem_t* sem)\n\n// 原子操作将信号量的值 +1\nint sem_post(sem_t* sem)\n```\n初始化已经存在的信号量会导致无法预期的结果\n\n销毁正被其他线程等待的信号量, 将会导致无法预期的结果\n\n例子如下\n```c++\nconstexpr int kNumberMax = 10;\nstd::vector<int> number(kNumberMax);\n\nconstexpr int kThreadNum = 10;\nsem_t sems[kThreadNum];\npthread_t threads[kThreadNum];\n\nconstexpr int kPrintTime = 1;\n\nvoid* t(void *no)\n{\n    int start_sub = *static_cast<int*>(no);\n    int sub =start_sub;\n    int time = 0;\n    while(++time <= kPrintTime)\n    {\n\t\t// 锁住本线程 释放下一个线程\n        sem_wait(&sems[start_sub]);\n        printf(\"%d\\n\", number[sub]);\n        sem_post(&sems[(start_sub + 1) % kThreadNum]);\n\t\t// 计算下一次要打印的下标\n        sub = (sub + kThreadNum) % kNumberMax;\n    }\n    pthread_exit(nullptr);\n}\n\nint main()\n{\n    std::iota(number.begin(), number.end(), 0);\n    sem_init(&sems[0], 0, 1);\n    for (int i = 1; i < kThreadNum; ++i)\n    {\n        sem_init(&sems[i], 0, 0);\n    }\n    for (int i = 0; i < kThreadNum; ++i)\n    {\n        pthread_create(&threads[i], nullptr, t, &number[i]);\n    }\n\t// 等待最后一个线程结束\n    pthread_join(threads[kThreadNum - 1], nullptr);\n}\n```\nkThreadNum个进程依次打印`[0, kNumberMax)`\n每个进程打印kPrintTime次\n最后一个进程打印完后主线程才能结束\n\n## 互斥锁\n```c++\n// 初始化互斥锁\n// 第一个参数指向目标互斥锁, 第二个参数指定属性 nullptr则为默认\nint pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);\n\n// 销毁目标互斥锁\nint pthread_mutex_destory(pthread_mutex_t *mutex);\n\n// 针对普通锁加锁\nint pthread_mutex_lock(pthread_mutex_t *mutex);\n\n// 针对普通锁立即返回 目标未加锁则加锁 如果已经加锁则返回错误码EBUSY\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\n\n// 解锁 如果有其他线程在等待这个互斥锁, 则其中之一获得\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\n```\n\n销毁一个已经加锁的互斥锁 会发生不可预期的后果\n也可使使用宏`PTHREAD_MUTEX_INITIALIZER`来初始化一个互斥锁\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n\n\n**互斥锁属性设置**\n\n```c++\nint pthread_mutexattr_init(pthread_mutexattr_t *attr);\n\nint pthread_mutexattr_destory(pthread_mutexattr_t *attr);\n\n// PTHREAD_PROCESS_SHARED 跨进程共享\n// PTHREAD_PROCESS_PRIVATE 隶属同一进程的线程\nint pthread_mutexattr_getpshared(const pthread_mutexattr_t *attr, int *pshared);\nint pthread_mutexattr_setpshared(const pthread_mutexattr_t *attr, int pshared);\n\n// PTHREAD_MUTEX_NORMAL 普通锁 默认类型\n// PTHREAD_MUTEX_ERRORCHECK 检错锁\n// PTHREAD_MUTEX_RECURSVE 嵌套锁\n// PTHREAD_MUTEX_DEFAULT 默认锁\nint pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *type);\nint pthread_mutexattr_settype(const pthread_mutexattr_t *attr, int type);\n```\nPTHREAD_MUTEX_NORMAL\n一个线程对其加锁后, 其他请求该锁的进程会形成一个等待队列, 解锁后然后按照优先级获得. 保证资源分配公平\nA线程对一个`已经加锁`的普通锁`再次加锁(也是A线程)`-同一线程在解锁前再次加锁引发死锁\n对一个已经`被其他线程加锁`的普通锁`解锁`, 或者`再次解锁已经解锁`的普通锁--解锁-不可预期后果\n\nPTHREAD_MUTEX_ERRORCHECK\n线程对`已经加锁`的检错锁`再次加锁`--加锁-加锁操作返回EDEADLK\n对一个已经`被其他线程加锁`的检错锁`解锁`, 或者`再次解锁已经解锁`的检错锁--解锁-返回EPERM\n\nPTHREAD_MUTEX_RECURSVE\n允许一个线程在释放锁前多次加锁 而不发生死锁.\n如果`其他线程`要获得这个锁, 则`当前锁拥有者`必须执行相应次数的解锁操作--加锁\n对于`已经被其他进程`加锁的嵌套锁解锁, 或者对`已经解锁`的再次解锁--解锁-返回EPERM\n\nPTHREAD_MUTEX_DEFAULT\n这种锁的实现可能为上面三种之一\n对已经加锁的默认锁再次加锁\n对被其他线程加锁的默认锁解锁\n再次解锁已经解锁的默认锁\n都将会发生不可预料后果\n\n例子\n```c++\npthread_mutex_t mutex;\nint count = 0;\nvoid* t(void *a)\n{\n    pthread_mutex_lock(&mutex);\n    printf(\"%d\\n\", count);\n    count++;\n    pthread_mutex_unlock(&mutex);\n}\nint main()\n{\n    pthread_mutex_init(&mutex, nullptr);\n    pthread_t thread[10];\n    for (int i = 0; i < 10; ++i)\n    {\n        pthread_create(&thread[i], nullptr, t, nullptr);\n    }\n    sleep(3);\n    pthread_mutex_destroy(&mutex);\n}\n```\n\n## 条件变量\n\n```c++\nint pthread_cond_init(pthread_cond_t *cond, const pthread_condattr *cond_attr);\n\n// 销毁一个正在被等待的条件变量 将会失败并返回EBUSY\nint pthread_cont_destory(pthread_cond_t *cond);\n\n// 广播式的唤醒所有等待目标条件变量的线程\nint pthread_cont_broadcast(pthread_cond_t *cond);\n\n// 唤醒一个等待目标条件变量的线程\nint pthread_cond_signal(pthread_cond_t *cond);\n\n// 等待目标条件变量\nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);\n```\n\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n将各个字段初始化为0\n\npthread_cond_wait的第二个参数, 用于保护条件变量的互斥锁\n掉用函数前必须将 mutex加锁, 否则会发生不可预料的后果.\n函数执行前将调用线程放入条件变量等待队列, 然后将mutex解锁\n\n从函数调用, 到被放入等待队列的时间内, pthread_cond_signal(broadcast)不会修改条件变量的值\n也就是 pthread_cond_wait函数不会错过目标条件变量的任何变化,\n将pthread_cond_wait函数返回的时候, 互斥锁mutex将会再次锁上\n\n例子\n```c++\npthread_mutex_t mutex;\npthread_cond_t cond;\nint good = 3;\nint produce_count = 0;\nint consume_count = 0;\n\nvoid* Producer(void *arg)\n{\n    while(produce_count < 10)\n    {\n        pthread_mutex_lock(&mutex);\n        good++;\n        pthread_mutex_unlock(&mutex);\n\n        produce_count++;\n        printf(\"produce a good\\n\");\n\t\t// 通知一个线程\n        pthread_cond_signal(&cond);\n        sleep(2);\n    }\n    pthread_exit(nullptr);\n}\n\nvoid* Consumer(void *arg)\n{\n    while (consume_count < 13)\n    {\n\t\t// 传入前需要加锁\n        pthread_mutex_lock(&mutex);\n        if (good > 0)\n        {\n            good--;\n            consume_count++;\n            printf(\"consume a good, reset %d\\n\", good);\n        }\n        else\n        {\n            printf(\"good is 0\\n\");\n            // wait pthread_cond_signal\n            pthread_cond_wait(&cond, &mutex);\n        }\n        pthread_mutex_unlock(&mutex);\n\n        usleep(500 * 1000);\n    }\n    pthread_exit(nullptr);\n}\n\nint main()\n{\n    mutex = PTHREAD_MUTEX_INITIALIZER;\n    cond = PTHREAD_COND_INITIALIZER;\n    pthread_t producer, consumer;\n\n    pthread_create(&consumer, nullptr, Consumer, nullptr);\n    pthread_create(&producer, nullptr, Producer, nullptr);\n\n    pthread_join(consumer, nullptr);\n    pthread_mutex_destroy(&mutex);\n    pthread_cond_destroy(&cond);\n}\n```\n\n## 读写锁\n\n## 自旋锁\n\n\n## 线程同步包装类-多线程环境\n```c++\nclass Sem\n{\npublic:\n    Sem()\n    {\n        if (sem_init(&sem_, 0, 0) != 0)\n        {\n            throw std::exception();\n        }\n    }\n    ~Sem()\n    {\n        sem_destroy(&sem_);\n    }\n    bool Wait()\n    {\n        return sem_wait(&sem_) == 0;\n    }\n    bool Post()\n    {\n        return sem_post(&sem_) == 0;\n    }\nprivate:\n    sem_t sem_;\n};\n\nclass Mutex\n{\npublic:\n    Mutex()\n    {\n        if (pthread_mutex_init(&mutex_, nullptr) != 0)\n        {\n            throw std::exception();\n        }\n\n    }\n    ~Mutex()\n    {\n        pthread_mutex_destroy(&mutex_);\n    }\n    bool Lock()\n    {\n        return pthread_mutex_lock(&mutex_) == 0;\n    }\n    bool Unlock()\n    {\n        return pthread_mutex_unlock(&mutex_) == 0;\n    }\n\nprivate:\n    pthread_mutex_t mutex_;\n};\n\nclass Cond\n{\npublic:\n    Cond()\n    {\n        if (pthread_mutex_init(&mutex_, nullptr) != 0)\n        {\n            throw std::exception();\n        }\n        if (pthread_cond_init(&cond_, nullptr) != 0)\n        {\n            // 这里我一开始没有想到..\n            pthread_mutex_destroy(&mutex_);\n            throw std::exception();\n        }\n    }\n    ~Cond()\n    {\n        pthread_mutex_destroy(&mutex_);\n        pthread_cond_destroy(&cond_);\n    };\n    bool Wait()\n    {\n        int ret = 0;\n        pthread_mutex_lock(&mutex_);\n        ret = pthread_cond_wait(&cond_, &mutex_);\n        pthread_mutex_unlock(&mutex_);\n        return ret == 0;\n    }\n    bool Signal()\n    {\n        return pthread_cond_signal(&cond_) == 0;\n    }\nprivate:\n    pthread_cond_t cond_;\n    pthread_mutex_t mutex_;\n};\n```\n\n线程安全或可重入函数--函数能被多个线程同时调用而不发生竞态条件\n\n多线程程序某个线程调用fork函数, 新进程不会与父进程有相同数量的线程\n子进程只有一个线程-调用fork线程的完美复制\n\n但是子进程会继承父进程的互斥锁(条件变量)的状态, 如果互斥锁被加锁了, 但`不是由`调用fork线程\n锁住的, 此时`子进程`再次对这个互斥锁`执行加锁`操作将会`死锁`.\n\n```c++\npthread_mutex_t mutex;\nvoid* another(void *arg)\n{\n    printf(\"in child thread, lock the mutex\\n\");\n    pthread_mutex_lock(&mutex);\n    sleep(5);\n    // 解锁后 Prepare才能加锁\n    pthread_mutex_unlock(&mutex);\n    pthread_exit(nullptr);\n}\n// 这个函数在fork创建子进程前被调用\nvoid Prepare()\n{\n    // 但是会阻塞 直到执行another函数的线程解锁 才能够继续执行\n    // 这个函数执行完毕前fork不会创建子进程\n    pthread_mutex_lock(&mutex);\n}\n// fork创建线程后 返回前 会在子进程和父进程中执行这个函数\nvoid Infork()\n{\n    pthread_mutex_unlock(&mutex);\n}\nint main()\n{\n    pthread_mutex_init(&mutex, nullptr);\n    pthread_t id;\n    pthread_create(&id, nullptr, another, nullptr);\n\n    sleep(1);\n    // pthread_atfork(Prepare, Infork, Infork);\n    int pid = fork();\n    if (pid < 0)\n    {\n        printf(\"emmm????\\n\");\n        pthread_join(id, nullptr);\n        pthread_mutex_destroy(&mutex);\n        return 1;\n    }\n    else if (pid == 0)\n    {\n        printf(\"child process, want to get the lock\\n\");\n        pthread_mutex_lock(&mutex);\n        printf(\"i cann't run to here, opps....\\n\");\n        pthread_mutex_unlock(&mutex);\n        exit(0);\n    }\n    else\n    {\n        printf(\"wait start\\n\");\n        wait(nullptr);\n        printf(\"wait over\\n\"); // 没有打印 因为子进程不会终止\n    }\n    pthread_join(id, nullptr);\n    pthread_mutex_destroy(&mutex);\n    return 0;\n}\n// $ in child thread, lock the mutex\n// $ wait start\n// $ child process, want to get the lock\n\n// $ in child thread, lock the mutex\n// $ wait start\n// $ child process, want to get the lock\n// $ i cann't run to here, opps....\n// $ wait over\n```\n\n原版就会发生死锁, 新版(去掉注释的代码) 能够正常运行\n\n```c++\nint pthread_atfork (void (*__prepare) (void),\n\t\t\t   void (*__parent) (void),\n\t\t\t   void (*__child) (void));\n```\n第一个句柄 在fork创建子进程前执行\n第二个句柄 在fork创建出子进程后, fork返回前在父进程中执行\n第二个句柄 在fork创建出子进程后, fork返回前在子进程中执行\n\n\n# 第十五章 进程池和线程池\n\n# 线程池 和 简单HTTP服务器\n对我而言神秘已久的线程池终于揭开了面纱.\n没想到这就是线程池23333\n\n线程池写完后 直接写了书上的HTTP服务器.\n\n那个服务器至少我发现两个问题\n- 无法发送大文件\n- 部分请求无法回复\n\n无法发送大文件, 是因为书中使用了writev发送数据\n期初我以为下面的判断 writev返回值 等于 -1就是为了发送大文件, 后来发现这个判断只是给期初就发送失败准备的.\n\n正好前一阵子看了一个服务器的代码\nhttps://github.com/Jigokubana/Notes-flamingo\n\n\n我就索性直接将发送部分修改了\n```c++\n// write_sum_ 需发送总大小\n// write_idx_ 已发送大小\n\nint temp = 0;\nif (write_sum_ - write_idx_ == 0)\n{\n    Modfd(epollfd_, sockfd_, EPOLLIN);\n    Init();\n    return true;\n}\nwhile (true)\n{\n    temp = send(sockfd_, &*write_buff_.begin() + write_idx_, write_sum_ - write_idx_, 0);\n    if (temp <= -1)\n    {\n        if (errno == EAGAIN)\n        {\n            Modfd(epollfd_, sockfd_, EPOLLOUT);\n            return true;\n        }\n    }\n    write_idx_ += temp;\n\n    if (write_idx_ == write_sum_)\n    {\n        // 解除绑定移到了其他地方\n        if (linger_)\n        {\n            Init();\n            Modfd(epollfd_, sockfd_, EPOLLIN);\n            return true;\n        }\n        else\n        {\n            Modfd(epollfd_, sockfd_, EPOLLIN);\n            return false;\n        }\n    }\n}\n```\n\n第二个奇葩的问题就是使用ab压测时候 有些请求无法收到回复.\n这个问题等后面在解决把, 等我知识更加丰富了再说","slug":"读书记录102-高性能服务器编程读书记录进程线程部分","published":1,"updated":"2020-12-05T02:31:35.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg76003of8un9v6kgemh","content":"<h1 id=\"第十三章多进程编程\"><a href=\"#第十三章多进程编程\" class=\"headerlink\" title=\"第十三章多进程编程\"></a>第十三章多进程编程</h1><h2 id=\"exec系列系统调用\"><a href=\"#exec系列系统调用\" class=\"headerlink\" title=\"exec系列系统调用\"></a>exec系列系统调用</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 声明这个是外部函数或外部变量</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">char</span>** environ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻</span></span><br><span class=\"line\"><span class=\"comment\">// arg-接受可变参数 和 argv用于向新的程序传递参数数组</span></span><br><span class=\"line\"><span class=\"comment\">// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量</span></span><br><span class=\"line\"><span class=\"comment\">// exec函数是不返回的, 除非出错</span></span><br><span class=\"line\"><span class=\"comment\">// 如果未报错则源程序被新的程序完全替换</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execl</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* arg, ...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execlp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* file, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* arg, ...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execle</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* arg, ..., <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> envp[])</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execv</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execvp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* file, <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execve</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> argv[], <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"fork系统调用-进程的创建\"><a href=\"#fork系统调用-进程的创建\" class=\"headerlink\" title=\"fork系统调用-进程的创建\"></a>fork系统调用-进程的创建</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0</span></span><br><span class=\"line\"><span class=\"comment\">// 次返回值用于区分是父进程还是子进程</span></span><br><span class=\"line\"><span class=\"comment\">// 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">fork</span><span class=\"params\">(viod)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>fork系统调用<br>fork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项<br>新的进程表项有很多的属性和原进程相同</p>\n<ul>\n<li>堆指针</li>\n<li>栈指针</li>\n<li>标志寄存器的值</li>\n<li>子进程代码与父进程完全相同</li>\n<li>同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)父进程的数据(堆数据, 栈数据, 静态数据)</li>\n<li>创建子进程后, <em>父进程打开的文件描述符默认在子进程中也是打开的</em> <code>文件描述符的引用计数</code>, <code>父进程的用户根目录, 当前工作目录等变量的引用计数</code> 均加1</li>\n</ul>\n<p>也存在不同的项目</p>\n<ul>\n<li>该进程的PPID(标识父进程)被设置成原进程的PID,  </li>\n<li><code>信号位图被清除</code>(原进程设置的信号处理函数对新进程无效)</li>\n</ul>\n<p>(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)</p>\n<p>The child process is an exact duplicate of the parent process except<br>for the following points:</p>\n<ul>\n<li><p>The child has its own unique process ID, and this PID does not<br> match the ID of any existing process group (setpgid(2)) or<br> session. 子进程拥有自己唯一的进程ID, 不与其他相同</p>\n</li>\n<li><p>The child’s parent process ID is the same as the parent’s process<br> ID. 子进程的父进程ID PPID 与父进程ID PID相同</p>\n</li>\n<li><p>The child does not inherit its parent’s memory locks (mlock(2),<br> mlockall(2)). 子进程不继承父进程的内存锁(保证一部分内存处于内存中, 而不是sawp分区)</p>\n</li>\n<li><p>Process resource utilizations (getrusage(2)) and CPU time counters<br> (times(2)) are reset to zero in the child.<br> 进程资源使用和CPU时间计数器在子进程中重置为0</p>\n</li>\n<li><p>The child’s set of pending signals is initially empty<br> (sigpending(2)). 信号位图被初始化为空 原信号处理函数对子进程无效 需重新设置</p>\n</li>\n<li><p>The child does not inherit semaphore adjustments from its parent<br> (semop(2)). 不会继承semadj</p>\n</li>\n<li><p>The child does not inherit process-associated record locks from<br> its parent (fcntl(2)).  (On the other hand, it does inherit<br> fcntl(2) open file description locks and flock(2) locks from its<br> parent.)</p>\n</li>\n<li><p>The child does not inherit timers from its parent (setitimer(2),<br> alarm(2), timer_create(2)). 不会继承定时器</p>\n</li>\n<li><p>The child does not inherit outstanding asynchronous I/O operations<br> from its parent (aio_read(3), aio_write(3)), nor does it inherit<br> any asynchronous I/O contexts from its parent (see io_setup(2)).</p>\n</li>\n</ul>\n<h2 id=\"处理僵尸进程-进程的管理\"><a href=\"#处理僵尸进程-进程的管理\" class=\"headerlink\" title=\"处理僵尸进程-进程的管理\"></a>处理僵尸进程-进程的管理</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">wait</span><span class=\"params\">(<span class=\"keyword\">int</span>* stat_loc)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)</span></span><br><span class=\"line\"><span class=\"comment\">// options函数取值WNOHANG-waitpid立即返回</span></span><br><span class=\"line\"><span class=\"comment\">// 如果目标子进程正常退出, 则返回子进程的pid</span></span><br><span class=\"line\"><span class=\"comment\">// 如果还没有结束或意外终止, 则立即返回0</span></span><br><span class=\"line\"><span class=\"comment\">// 调用失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">waitpid</span><span class=\"params\">(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span>* stat_loc, <span class=\"keyword\">int</span> options)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">WIFEXITED(stat_val); <span class=\"comment\">// 子进程正常结束, 返回一个非0</span></span><br><span class=\"line\">WEXITSTATUS(stat_val); <span class=\"comment\">// 如果WIFEXITED 非0, 它返回子进程的退出码</span></span><br><span class=\"line\">WIFSIGNALED(stat_val);<span class=\"comment\">// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值</span></span><br><span class=\"line\">WTERMSIG(stat_val);<span class=\"comment\">// 如果WIFSIGNALED非0 返回一个信号值</span></span><br><span class=\"line\">WIFSTOPPED(stat_val);<span class=\"comment\">// 如果子进程意外终止, 它返回一个非0值</span></span><br><span class=\"line\">WSTOPSIG(stat_val);<span class=\"comment\">// 如果WIFSTOPED非0, 它返回一个信号值</span></span><br></pre></td></tr></table></figure>\n\n<p>对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询</p>\n<ul>\n<li>在<code>子进程结束运行之后, 父进程读取其退出状态前</code>, 我们称该子进程处于<code>僵尸态</code></li>\n<li>另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) <code>父进程结束运行之后, 子进程退出之前</code>, 处于<code>僵尸态</code></li>\n</ul>\n<p>以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.</p>\n<p>waitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.<br>SIGCHLD信号- 子进程结束后将会给父进程发送此信号</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handle_child</span><span class=\"params\">(<span class=\"keyword\">int</span> sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pid_t</span> pid;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stat;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((pid = waitpid(<span class=\"number\">-1</span>, &amp;stat, WNOHANG)) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 善后处理emmmm</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"信号量-进程的锁\"><a href=\"#信号量-进程的锁\" class=\"headerlink\" title=\"信号量-进程的锁\"></a>信号量-进程的锁</h2><p><em>信号量原语</em><br>只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.<br>假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为</p>\n<ul>\n<li>P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行</li>\n<li>V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png\" alt=\"\"></li>\n</ul>\n<p><strong>总结PV使用方法</strong></p>\n<p>使用<code>semget</code>获取到唯一的标识.<br>使用<code>semctl</code>的<code>SETVAL</code>传入初始化val的<code>sem_un</code>联合体.来初始化val<br>调用<code>semop</code> 传入唯一标识, <code>sem_op=-1</code>执行P(锁)操作<code>sem_op=1</code>执行V(开锁)操作<br>开关锁通过当<code>sem_op=-1,semval=0</code><br>且未指定<code>IPC_NOWAIT</code><br>等待<code>semval</code>被<code>sem_op=1</code>改为<code>semval=1</code></p>\n<p><strong>创建信号量</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// semeget 系统调用</span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集</span></span><br><span class=\"line\"><span class=\"comment\">// key 参数是一个键值, 用来标识一个全局唯一的信号量级,可以在不同进程中获取</span></span><br><span class=\"line\"><span class=\"comment\">// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0. 一般都是为1</span></span><br><span class=\"line\"><span class=\"comment\">// sem_flags指定一组标志, 来控制权限</span></span><br><span class=\"line\"><span class=\"comment\">// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错</span></span><br><span class=\"line\"><span class=\"comment\">// - IPC_CREAT | IPC_EXCL来创建一组唯一信号量集 如果已经存在则会返回错误 errno = EEXIST</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">int</span> num_sems, <span class=\"keyword\">int</span> sem_flags)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> sem_id = semget((<span class=\"keyword\">key_t</span>)<span class=\"number\">1234</span>, <span class=\"number\">1</span>, <span class=\"number\">0666</span> | IPC_CREAT);</span><br></pre></td></tr></table></figure>\n\n<p><strong>初始化</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// semctl 系统调用</span></span><br><span class=\"line\"><span class=\"comment\">// sem_id 参数是由semget返回的信号量集标识符</span></span><br><span class=\"line\"><span class=\"comment\">// sen_num指定被操作的信号量在信号集中的编号</span></span><br><span class=\"line\"><span class=\"comment\">// command指定命令, 可以追加命令所需的参数, 不过有推荐格式</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回对应command的参数, 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semctl</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id, <span class=\"keyword\">int</span> sem_num, <span class=\"keyword\">int</span> command, ...)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第四个参数 竟然需要手动声明...</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> semun</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>              val;    <span class=\"comment\">/* Value for SETVAL */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">semid_ds</span> *<span class=\"title\">buf</span>;</span>    <span class=\"comment\">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> short  *<span class=\"built_in\">array</span>;  <span class=\"comment\">/* Array for GETALL, SETALL */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">seminfo</span>  *__<span class=\"title\">buf</span>;</span>  <span class=\"comment\">/* Buffer for IPC_INFO</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t(Linux-specific) */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 初始化信号量</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> semun sem_union;</span><br><span class=\"line\">sem_union.val = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这里可以直接第三个参数传入1(val)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (semctl(sem_id, <span class=\"number\">0</span>, SETVAL, sem_union) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除信号量</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> semun sem_union&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (semctl(sem_id, <span class=\"number\">0</span>, IPC_RMID, sem_union) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>与semop信号量关联的一些重要的内核变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> short semval; <span class=\"comment\">// 信号量的值</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> short semzcnt; <span class=\"comment\">// 等待信号量值变为0的进程数量</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> short semncnt<span class=\"comment\">// 等待信号量值增加的进程数量</span></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> sempid; <span class=\"comment\">// 最后一次执行semop操作的进程ID</span></span><br></pre></td></tr></table></figure>\n<p>操作信号量, 实际上就是对上面的内核变量操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.</span></span><br><span class=\"line\"><span class=\"comment\">// sem_ops 参数指向一个sembuf结构体类型的数组</span></span><br><span class=\"line\"><span class=\"comment\">// num_sem_ops 说明操作数组中哪个信号量</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semop</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id, struct sembuf* sem_ops, <span class=\"keyword\">size_t</span> num_sem_ops)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sem_op &lt; 0 期望获得信号量</span></span><br><span class=\"line\"><span class=\"comment\">// semval-=abs(sem_op),要求调用进程对被操作信号量集有写权限</span></span><br><span class=\"line\"><span class=\"comment\">// 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果semval &lt; abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN</span></span><br><span class=\"line\"><span class=\"comment\">// 如果没有指定 则 阻塞进程等待信号量可用, 且 semzcnt +=1, 等到下面三种情况唤醒</span></span><br><span class=\"line\"><span class=\"comment\">// 1 发生semval &gt;= abs(sem_op), semzcnt-=1, semval-=abs(sem_op). 在SEM_UNDO设置时更新semadj</span></span><br><span class=\"line\"><span class=\"comment\">// 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)</span></span><br><span class=\"line\"><span class=\"comment\">// 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">P</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sembuf</span> <span class=\"title\">sem_b</span>;</span></span><br><span class=\"line\">    sem_b.sem_num = <span class=\"number\">0</span>; <span class=\"comment\">// 信号量编号 第几个信号量 一般都是第0个</span></span><br><span class=\"line\">    sem_b.sem_op = <span class=\"number\">-1</span>; <span class=\"comment\">// P</span></span><br><span class=\"line\">\t<span class=\"comment\">// IPC_NOWAIT 无论信号量操作是否成功, 都立即返回</span></span><br><span class=\"line\">\t<span class=\"comment\">// SEM_UNDO当进程退出的时候, 取消正在进行的semop操作 PV操作系统更新进程的semadj变量</span></span><br><span class=\"line\">    sem_b.sem_flg = SEM_UNDO;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> semop(sem_id, &amp;sem_b, <span class=\"number\">1</span>) != <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sem_op &gt; 0 </span></span><br><span class=\"line\"><span class=\"comment\">// semval+=sem_op , 要求调用进程对被操作的信号量集有写权限</span></span><br><span class=\"line\"><span class=\"comment\">// 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">V</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sembuf</span> <span class=\"title\">sem_b</span>;</span></span><br><span class=\"line\">    sem_b.sem_num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    sem_b.sem_op = <span class=\"number\">1</span>; <span class=\"comment\">// V</span></span><br><span class=\"line\">    sem_b.sem_flg = SEM_UNDO;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> semop(sem_id, &amp;sem_b, <span class=\"number\">1</span>) != <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- sem_op = 0</span></span><br><span class=\"line\"><span class=\"comment\">// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限</span></span><br><span class=\"line\"><span class=\"comment\">// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0</span></span><br><span class=\"line\"><span class=\"comment\">// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN</span></span><br><span class=\"line\"><span class=\"comment\">// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生</span></span><br><span class=\"line\"><span class=\"comment\">// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1</span></span><br><span class=\"line\"><span class=\"comment\">// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM</span></span><br><span class=\"line\"><span class=\"comment\">// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1</span></span><br></pre></td></tr></table></figure>\n\n<p>semget成功时返回一个与之关联的内核结构体semid_ds</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">semid_ds</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">sem_perm</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> sem_nsems; <span class=\"comment\">// 被设置为num_sems</span></span><br><span class=\"line\">\t<span class=\"keyword\">time_t</span> sem_otime; <span class=\"comment\">// 被设置为0</span></span><br><span class=\"line\">\t<span class=\"keyword\">time_t</span> sem_ctime; <span class=\"comment\">// 被设置为当前的系统时间</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 用来描述权限</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">uid_t</span> uid; <span class=\"comment\">// 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">gid_t</span> gid; <span class=\"comment\">// 所有者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">uid_t</span> cuid; <span class=\"comment\">// 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">gid_t</span> cgid; <span class=\"comment\">// 创建者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">mode_t</span> mode;<span class=\"comment\">// 访问权限, 背着只为sem_flags参数的最低9位.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"共享内存-进程间通信\"><a href=\"#共享内存-进程间通信\" class=\"headerlink\" title=\"共享内存-进程间通信\"></a>共享内存-进程间通信</h2><p><strong>最高效的IPC(进程间通信)机制</strong><br>需要自己同步进程对其的访问, 否则会产生竞态条件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// key</span></span><br><span class=\"line\"><span class=\"comment\">// 与semget相同 标识一段全局唯一的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">// size 内存区域大小 单位字节</span></span><br><span class=\"line\"><span class=\"comment\">// shmflg</span></span><br><span class=\"line\"><span class=\"comment\">// IPC_CREAT 存不存在都创建新的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">// IPC_CREAT | IPC_EXCL 不存在则创建 存在则报错</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_HUGETLB 系统将使用\"大页面\"来为共享内存分配空间</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_NORESERVE 不为共享内存保留swap空间, 如果物理内存不足</span></span><br><span class=\"line\"><span class=\"comment\">// -在执行写操作的时候将会触发`SIGSEGV`信号</span></span><br><span class=\"line\"><span class=\"comment\">// -成功返回唯一标识, 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">size_t</span> <span class=\"built_in\">size</span>, <span class=\"keyword\">int</span> shmflg)</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// shm_id </span></span><br><span class=\"line\"><span class=\"comment\">// shmget返回的唯一标识</span></span><br><span class=\"line\"><span class=\"comment\">// shm_addr </span></span><br><span class=\"line\"><span class=\"comment\">// 关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响</span></span><br><span class=\"line\"><span class=\"comment\">// 如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 shm_addr 非空,且没有`SHM_RND`标志 则关联到指定的地址处</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写*</span></span><br><span class=\"line\"><span class=\"comment\">// shmflg</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_RDONLY 设置后内存内容变成只读, 不设置则为读写模式</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_EXEC 有执行权限</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回关联到的地址, 失败返回 (void*)-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">shmat</span><span class=\"params\">(<span class=\"keyword\">int</span> shm_id, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* shm_addr, <span class=\"keyword\">int</span> shmflg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 将共享内存关联到进程的地址空间 调用成功之后, 修改shmid_ds的部分内容</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -shm_nattach +1</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -更新 shm_lpid</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -shm_atime设置为当前时间</span></span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将共享内存从进程地址空间中分离</span></span><br><span class=\"line\"><span class=\"comment\">// 成功后</span></span><br><span class=\"line\"><span class=\"comment\">// -shm_nattach -1</span></span><br><span class=\"line\"><span class=\"comment\">// -更新 shm_lpid和shm_dtime设置为当前时间</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmdt</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* shm_addr)</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shm_ctl</span><span class=\"params\">(<span class=\"keyword\">int</span> shm_id, <span class=\"keyword\">int</span> command, struct shmid_ds* buf)</span></span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/shmctl.png\" alt=\"\"></p>\n<hr>\n<p>shmget 同时会创建对应的<code>shmid_ds</code>结构体</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">shmid_ds</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">shm_per</span>;</span> <span class=\"comment\">// 权限相关</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> shm_segsz; <span class=\"comment\">// 共享内存大小 单位字节\tsize</span></span><br><span class=\"line\">\t<span class=\"keyword\">__time_t</span> shm_atime; <span class=\"comment\">// 对这段内存最后一次调用semat的时间 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">__time_t</span> shm_dtime; <span class=\"comment\">// 对这段内存最后一次调用semdt的时间 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">__time_t</span> shm_ctime; <span class=\"comment\">// 对这段内存最后一次调用semctl的时间 当前时间</span></span><br><span class=\"line\">\t<span class=\"keyword\">__pid_t</span> shm_cpid; <span class=\"comment\">// 创建者PID</span></span><br><span class=\"line\">\t<span class=\"keyword\">__pid_t</span> lpid; <span class=\"comment\">// 最后一次执行shmat或shmdt的进程PID</span></span><br><span class=\"line\">\t<span class=\"keyword\">shmatt_t</span> shm_nattach <span class=\"comment\">// 关联到此共享内存空间的进程数量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>共享内存的POSIX方法</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> shmfd = shm_open(<span class=\"string\">\"/shm_name\"</span>, O_CREAT | O_RDWR, <span class=\"number\">0666</span>);</span><br><span class=\"line\">ERROR_IF(shmfd == <span class=\"number\">-1</span>, <span class=\"string\">\"shm open\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = ftruncate(shmfd, BUFFER_SIZE);</span><br><span class=\"line\">ERROR_IF(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"ftruncate\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">share_mem = (<span class=\"keyword\">char</span>*)mmap(<span class=\"literal\">nullptr</span>, BUFFER_SIZE,</span><br><span class=\"line\">\t\tPROT_READ | PROT_WRITE, MAP_SHARED, shmfd, <span class=\"number\">0</span>);</span><br><span class=\"line\">ERROR_IF(share_mem == MAP_FAILED, <span class=\"string\">\"share_mem\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">close</span>(shmfd);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消关联</span></span><br><span class=\"line\">munmap((<span class=\"keyword\">void</span>*)share_mem, BUFFER_SIZE);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进程通信-管道\"><a href=\"#进程通信-管道\" class=\"headerlink\" title=\"进程通信-管道\"></a>进程通信-管道</h2><p>管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证<br>父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].</p>\n<p>可以用两个管道来实现双向传输数据, 也可以用<code>socketpair</code>来创建管道</p>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><p>消息队列是两个进程之间传递二进制块数据的一种简单有效的方式.<br>每个数据块都有自己的类型, 接收方可以根据类型有选择的接收数据</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/msg.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 与semget 相同, 成功返回标识符</span></span><br><span class=\"line\"><span class=\"comment\">// msgflg的设置和作用域setget相同</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// msg_ptr参数指向一个准备发送的消息, 消息必须按如下定义</span></span><br><span class=\"line\"><span class=\"comment\">// msg_sz 指的是mtext的长度!!!</span></span><br><span class=\"line\"><span class=\"comment\">// msgflg通常仅支持IPC_NOWAIT 以非阻塞形式发送数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgsnd</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *msg_ptr, <span class=\"keyword\">size_t</span> msg_sz, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br><span class=\"line\">默认如果消息队列已满, 则会阻塞. 如果设置了 IPC_NOTWAIT</span><br><span class=\"line\">就立即返回 设置errno=EAGIN</span><br><span class=\"line\"></span><br><span class=\"line\">系统自带这个结构体 不过mtext长度是<span class=\"number\">1.</span>..</span><br><span class=\"line\">struct msgbuf</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> mtype; <span class=\"comment\">/* 消息类型 正整数*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> mtext[<span class=\"number\">512</span>]; <span class=\"comment\">/* 消息数据*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// msgtype = 0 读取消息队列第一个消息</span></span><br><span class=\"line\"><span class=\"comment\">// msgtype &gt; 0 读取消息队列第一个类型是msgtype的消息 除非标志了MSG_EXCEPT</span></span><br><span class=\"line\"><span class=\"comment\">// msgtype &lt; 0 读取第一个 类型值 &lt; abs(msgtype)的消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IPC_NOWAIT 如果消息队列没有消息, 则msgrcv立即返回并设置errno=ENOMSG</span></span><br><span class=\"line\"><span class=\"comment\">// MSG_EXCEPT 如果msgtype大于0, 则接收第一个非 msgtype 的数据</span></span><br><span class=\"line\"><span class=\"comment\">// MSG_NOERROR 消息部分长度超过msg_sz 则将它截断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgrcv</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">void</span> *msg_ptr, <span class=\"keyword\">size_t</span> msg_sz, <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> msgtype, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br><span class=\"line\">处于阻塞状态 当消息队列被移除(errno=EIDRM)或者程序接受到信号(errno=EINTR) 都会中断阻塞状态</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgctl</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">int</span> command, struct msqid_ds *buf)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">IPC_STAT 复制消息队列关联的数据结构</span><br><span class=\"line\">IPC_SET 将buf中的部分成员更新到目标的内核数据</span><br><span class=\"line\">IPC_RMID 立即移除消息队列, 唤醒所有等待读消息和写消息的进程</span><br><span class=\"line\">IPC_INFO 获取系统消息队列资源配置信息</span><br><span class=\"line\"></span><br><span class=\"line\">MSG_INFO 返回已经分配的消息队列所占用资源信息</span><br><span class=\"line\">MSG_STAT msgqid不再是标识符, 而是内核消息队列的数组索引</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"在进程间传递文件描述符\"><a href=\"#在进程间传递文件描述符\" class=\"headerlink\" title=\"在进程间传递文件描述符\"></a>在进程间传递文件描述符</h2><h2 id=\"IPC命令-查看进程间通信的全局唯一key\"><a href=\"#IPC命令-查看进程间通信的全局唯一key\" class=\"headerlink\" title=\"IPC命令-查看进程间通信的全局唯一key\"></a>IPC命令-查看进程间通信的全局唯一key</h2><h1 id=\"第十四章-多线程编程\"><a href=\"#第十四章-多线程编程\" class=\"headerlink\" title=\"第十四章 多线程编程\"></a>第十四章 多线程编程</h1><p>根据运行环境和调度者身份, 线程可以分为两种<br>内核线程<br>运行在内核空间, 由内核来调度.<br>用户线程<br>运行在用空间, 由线程库来调用</p>\n<p>当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.</p>\n<p>线程有三种实现方式</p>\n<ul>\n<li>完全在用户空间实现-无需内核支持<br>  创建和调度线程无需内核干预, 速度很快.<br>  不占用额外的内核资源, 对系统影响较小<br>  但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的</li>\n<li>完全由内核调度<br>  创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理<br>  优缺点正好与上一个相反</li>\n<li>双层调度<br>  结合了前两个的优点<br>  不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势</li>\n</ul>\n<h2 id=\"进程的创建和终止\"><a href=\"#进程的创建和终止\" class=\"headerlink\" title=\"进程的创建和终止\"></a>进程的创建和终止</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_create</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span>* thread, <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_attr_t</span>* attr, <span class=\"keyword\">void</span>* (*start_routine)(<span class=\"keyword\">void</span>*), <span class=\"keyword\">void</span>* arg)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回错误码</span></span><br><span class=\"line\"><span class=\"comment\">// thread 用来唯一的标识一个新线程</span></span><br><span class=\"line\"><span class=\"comment\">// attr用来设置新县城的属性 传递NULL表示默认线程属性</span></span><br><span class=\"line\"><span class=\"comment\">// start_routine 指定新线程运行的函数</span></span><br><span class=\"line\"><span class=\"comment\">// arg指定函数的参数</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>* retval)</span></span>;</span><br><span class=\"line\">用来保证线程安全干净的退出, 线程函数最好结束时调用.</span><br><span class=\"line\">通过`retval`参数向线程的回收者传递其退出信息</span><br><span class=\"line\">执行后不会返回到调用者, 而且永远不会失败</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_join</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread, <span class=\"keyword\">void</span>** retval)</span></span></span><br><span class=\"line\">可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.</span><br><span class=\"line\">成功时返回<span class=\"number\">0</span>, 失败返回错误码</span><br><span class=\"line\">等待其他线程结束</span><br><span class=\"line\">thread 线程标识符</span><br><span class=\"line\">retval 目标线程的退出返回信息</span><br><span class=\"line\"></span><br><span class=\"line\">错误码如下</span><br><span class=\"line\">`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用</span><br><span class=\"line\">`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程</span><br><span class=\"line\">`ESRCH`目标线程不存在</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cancel</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread)</span></span></span><br><span class=\"line\">异常终止一个线程, 即为取消线程</span><br><span class=\"line\">成功返回<span class=\"number\">0</span>, 失败返回错误码</span><br></pre></td></tr></table></figure>\n\n<p><strong>线程属性设置</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.</span><br><span class=\"line\"><span class=\"comment\">// 启动线程取消</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_setcancelstart</span><span class=\"params\">(<span class=\"keyword\">int</span> state, <span class=\"keyword\">int</span>* oldstate)</span></span></span><br><span class=\"line\">第一个参数</span><br><span class=\"line\">PTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态</span><br><span class=\"line\">PTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求直到</span><br><span class=\"line\">这个线程允许被取消</span><br><span class=\"line\">第二个参数 返回之前设定的状态</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置线程取消类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_setcanceltype</span><span class=\"params\">(<span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span>* oldtype)</span></span></span><br><span class=\"line\">第一个参数</span><br><span class=\"line\">PTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消</span><br><span class=\"line\">PTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 直到调用了下面几个所谓的取消点函数</span><br><span class=\"line\">最好使用pthread_testcancel函数设置取消点</span><br><span class=\"line\">设置取消类型(如何取消)</span><br><span class=\"line\">第二个参数</span><br><span class=\"line\">原来的取消类型</span><br></pre></td></tr></table></figure>\n\n<p><strong>设置脱离线程</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化线程属性对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_init</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 销毁线程属性对象, 直到再次初始化前都不能用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_destory</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 参数取值</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -PTHREAD_CREATE_JOINABLE 线程可回收</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -PTHREAD_CREATE_DETACH 脱离与进程中其他线程的同步 成为脱离线程</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_getdetachstate</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">int</span> *detachstate)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_setdetachstate</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">int</span> detachstate)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 可以直接设置为脱离线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_detach</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread)</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程同步机制的使用场景\"><a href=\"#线程同步机制的使用场景\" class=\"headerlink\" title=\"线程同步机制的使用场景\"></a>线程同步机制的使用场景</h2><p>POSIX信号量-需要自己维护计数值, 用户空间有计数值 信号量自己又计数值<br>两份计数值容易出错</p>\n<p>互斥锁-对临界资源的独占式访问</p>\n<p>条件变量-等待某个条件满足<br>当某个共享数据达到某个值的时候, 唤醒等待这个共享数据的线程</p>\n<p>读写锁-可以多个进程读, 读的时候不能写, 同时只能一个写</p>\n<p>自旋锁-通过while循环频繁尝试获取锁, 适用于锁事件短, 需要快速切换的场景</p>\n<h2 id=\"POSIX信号量\"><a href=\"#POSIX信号量\" class=\"headerlink\" title=\"POSIX信号量\"></a>POSIX信号量</h2><p>多线程也必须考虑线程同步的问题.<br>虽然<code>pthread_join()</code>可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求<br>比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;semaphore&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 用于初始化一个未命名的信号量.</span></span><br><span class=\"line\"><span class=\"comment\">// pshared==0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享</span></span><br><span class=\"line\"><span class=\"comment\">// value指定参数的初始值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_init</span><span class=\"params\">(<span class=\"keyword\">sem_t</span>* sem, <span class=\"keyword\">int</span> pshared, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 销毁信号量, 释放其占用的系统资源</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_destory</span><span class=\"params\">(<span class=\"keyword\">sem_t</span>* sem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞直到sem_wait具有非0值</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_wait</span><span class=\"params\">(<span class=\"keyword\">sem_t</span>* sem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 跟上面的函数相同不过不会阻塞. 信号量不为0则减一操作, 为0则返回-1 errno</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_trywait</span><span class=\"params\">(<span class=\"keyword\">sem_t</span>* sem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 原子操作将信号量的值 +1</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_post</span><span class=\"params\">(<span class=\"keyword\">sem_t</span>* sem)</span></span></span><br></pre></td></tr></table></figure>\n<p>初始化已经存在的信号量会导致无法预期的结果</p>\n<p>销毁正被其他线程等待的信号量, 将会导致无法预期的结果</p>\n<p>例子如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> kNumberMax = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">number</span><span class=\"params\">(kNumberMax)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> kThreadNum = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">sem_t</span> sems[kThreadNum];</span><br><span class=\"line\"><span class=\"keyword\">pthread_t</span> threads[kThreadNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> kPrintTime = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">t</span><span class=\"params\">(<span class=\"keyword\">void</span> *no)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start_sub = *<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>*&gt;(no);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sub =start_sub;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> time = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(++time &lt;= kPrintTime)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 锁住本线程 释放下一个线程</span></span><br><span class=\"line\">        sem_wait(&amp;sems[start_sub]);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, number[sub]);</span><br><span class=\"line\">        sem_post(&amp;sems[(start_sub + <span class=\"number\">1</span>) % kThreadNum]);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 计算下一次要打印的下标</span></span><br><span class=\"line\">        sub = (sub + kThreadNum) % kNumberMax;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_exit(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::iota(number.<span class=\"built_in\">begin</span>(), number.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">    sem_init(&amp;sems[<span class=\"number\">0</span>], <span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; kThreadNum; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sem_init(&amp;sems[i], <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; kThreadNum; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_create(&amp;threads[i], <span class=\"literal\">nullptr</span>, t, &amp;number[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 等待最后一个线程结束</span></span><br><span class=\"line\">    pthread_join(threads[kThreadNum - <span class=\"number\">1</span>], <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>kThreadNum个进程依次打印<code>[0, kNumberMax)</code><br>每个进程打印kPrintTime次<br>最后一个进程打印完后主线程才能结束</p>\n<h2 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化互斥锁</span></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数指向目标互斥锁, 第二个参数指定属性 nullptr则为默认</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_init</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex, <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 销毁目标互斥锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_destory</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 针对普通锁加锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_lock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 针对普通锁立即返回 目标未加锁则加锁 如果已经加锁则返回错误码EBUSY</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_trylock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解锁 如果有其他线程在等待这个互斥锁, 则其中之一获得</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_unlock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>销毁一个已经加锁的互斥锁 会发生不可预期的后果<br>也可使使用宏<code>PTHREAD_MUTEX_INITIALIZER</code>来初始化一个互斥锁<br>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</p>\n<p><strong>互斥锁属性设置</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_init</span><span class=\"params\">(<span class=\"keyword\">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_destory</span><span class=\"params\">(<span class=\"keyword\">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PTHREAD_PROCESS_SHARED 跨进程共享</span></span><br><span class=\"line\"><span class=\"comment\">// PTHREAD_PROCESS_PRIVATE 隶属同一进程的线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_getpshared</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *attr, <span class=\"keyword\">int</span> *pshared)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_setpshared</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *attr, <span class=\"keyword\">int</span> pshared)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PTHREAD_MUTEX_NORMAL 普通锁 默认类型</span></span><br><span class=\"line\"><span class=\"comment\">// PTHREAD_MUTEX_ERRORCHECK 检错锁</span></span><br><span class=\"line\"><span class=\"comment\">// PTHREAD_MUTEX_RECURSVE 嵌套锁</span></span><br><span class=\"line\"><span class=\"comment\">// PTHREAD_MUTEX_DEFAULT 默认锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_gettype</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *attr, <span class=\"keyword\">int</span> *type)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_settype</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *attr, <span class=\"keyword\">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>PTHREAD_MUTEX_NORMAL<br>一个线程对其加锁后, 其他请求该锁的进程会形成一个等待队列, 解锁后然后按照优先级获得. 保证资源分配公平<br>A线程对一个<code>已经加锁</code>的普通锁<code>再次加锁(也是A线程)</code>-同一线程在解锁前再次加锁引发死锁<br>对一个已经<code>被其他线程加锁</code>的普通锁<code>解锁</code>, 或者<code>再次解锁已经解锁</code>的普通锁–解锁-不可预期后果</p>\n<p>PTHREAD_MUTEX_ERRORCHECK<br>线程对<code>已经加锁</code>的检错锁<code>再次加锁</code>–加锁-加锁操作返回EDEADLK<br>对一个已经<code>被其他线程加锁</code>的检错锁<code>解锁</code>, 或者<code>再次解锁已经解锁</code>的检错锁–解锁-返回EPERM</p>\n<p>PTHREAD_MUTEX_RECURSVE<br>允许一个线程在释放锁前多次加锁 而不发生死锁.<br>如果<code>其他线程</code>要获得这个锁, 则<code>当前锁拥有者</code>必须执行相应次数的解锁操作–加锁<br>对于<code>已经被其他进程</code>加锁的嵌套锁解锁, 或者对<code>已经解锁</code>的再次解锁–解锁-返回EPERM</p>\n<p>PTHREAD_MUTEX_DEFAULT<br>这种锁的实现可能为上面三种之一<br>对已经加锁的默认锁再次加锁<br>对被其他线程加锁的默认锁解锁<br>再次解锁已经解锁的默认锁<br>都将会发生不可预料后果</p>\n<p>例子</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> mutex;</span><br><span class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">t</span><span class=\"params\">(<span class=\"keyword\">void</span> *a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, count);</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pthread_mutex_init(&amp;mutex, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> thread[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_create(&amp;thread[i], <span class=\"literal\">nullptr</span>, t, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">    pthread_mutex_destroy(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"条件变量\"><a href=\"#条件变量\" class=\"headerlink\" title=\"条件变量\"></a>条件变量</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_init</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond, <span class=\"keyword\">const</span> pthread_condattr *cond_attr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 销毁一个正在被等待的条件变量 将会失败并返回EBUSY</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cont_destory</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 广播式的唤醒所有等待目标条件变量的线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cont_broadcast</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 唤醒一个等待目标条件变量的线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_signal</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等待目标条件变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_wait</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond, <span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;<br>将各个字段初始化为0</p>\n<p>pthread_cond_wait的第二个参数, 用于保护条件变量的互斥锁<br>掉用函数前必须将 mutex加锁, 否则会发生不可预料的后果.<br>函数执行前将调用线程放入条件变量等待队列, 然后将mutex解锁</p>\n<p>从函数调用, 到被放入等待队列的时间内, pthread_cond_signal(broadcast)不会修改条件变量的值<br>也就是 pthread_cond_wait函数不会错过目标条件变量的任何变化,<br>将pthread_cond_wait函数返回的时候, 互斥锁mutex将会再次锁上</p>\n<p>例子</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> mutex;</span><br><span class=\"line\"><span class=\"keyword\">pthread_cond_t</span> cond;</span><br><span class=\"line\"><span class=\"keyword\">int</span> good = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> produce_count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> consume_count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">Producer</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(produce_count &lt; <span class=\"number\">10</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">        good++;</span><br><span class=\"line\">        pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">        produce_count++;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"produce a good\\n\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 通知一个线程</span></span><br><span class=\"line\">        pthread_cond_signal(&amp;cond);</span><br><span class=\"line\">        sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_exit(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">Consumer</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (consume_count &lt; <span class=\"number\">13</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 传入前需要加锁</span></span><br><span class=\"line\">        pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (good &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            good--;</span><br><span class=\"line\">            consume_count++;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"consume a good, reset %d\\n\"</span>, good);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"good is 0\\n\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// wait pthread_cond_signal</span></span><br><span class=\"line\">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">        usleep(<span class=\"number\">500</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_exit(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\">    cond = PTHREAD_COND_INITIALIZER;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> producer, consumer;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_create(&amp;consumer, <span class=\"literal\">nullptr</span>, Consumer, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    pthread_create(&amp;producer, <span class=\"literal\">nullptr</span>, Producer, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_join(consumer, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    pthread_mutex_destroy(&amp;mutex);</span><br><span class=\"line\">    pthread_cond_destroy(&amp;cond);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a>读写锁</h2><h2 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h2><h2 id=\"线程同步包装类-多线程环境\"><a href=\"#线程同步包装类-多线程环境\" class=\"headerlink\" title=\"线程同步包装类-多线程环境\"></a>线程同步包装类-多线程环境</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sem</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Sem()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sem_init(&amp;sem_, <span class=\"number\">0</span>, <span class=\"number\">0</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::exception();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Sem()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sem_destroy(&amp;sem_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Wait</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sem_wait(&amp;sem_) == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Post</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sem_post(&amp;sem_) == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">sem_t</span> sem_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mutex</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Mutex()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pthread_mutex_init(&amp;mutex_, <span class=\"literal\">nullptr</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::exception();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Mutex()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_mutex_destroy(&amp;mutex_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Lock</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pthread_mutex_lock(&amp;mutex_) == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Unlock</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pthread_mutex_unlock(&amp;mutex_) == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">pthread_mutex_t</span> mutex_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cond</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Cond()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pthread_mutex_init(&amp;mutex_, <span class=\"literal\">nullptr</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::exception();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pthread_cond_init(&amp;cond_, <span class=\"literal\">nullptr</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里我一开始没有想到..</span></span><br><span class=\"line\">            pthread_mutex_destroy(&amp;mutex_);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::exception();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Cond()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_mutex_destroy(&amp;mutex_);</span><br><span class=\"line\">        pthread_cond_destroy(&amp;cond_);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Wait</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        pthread_mutex_lock(&amp;mutex_);</span><br><span class=\"line\">        ret = pthread_cond_wait(&amp;cond_, &amp;mutex_);</span><br><span class=\"line\">        pthread_mutex_unlock(&amp;mutex_);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Signal</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pthread_cond_signal(&amp;cond_) == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">pthread_cond_t</span> cond_;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_mutex_t</span> mutex_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>线程安全或可重入函数–函数能被多个线程同时调用而不发生竞态条件</p>\n<p>多线程程序某个线程调用fork函数, 新进程不会与父进程有相同数量的线程<br>子进程只有一个线程-调用fork线程的完美复制</p>\n<p>但是子进程会继承父进程的互斥锁(条件变量)的状态, 如果互斥锁被加锁了, 但<code>不是由</code>调用fork线程<br>锁住的, 此时<code>子进程</code>再次对这个互斥锁<code>执行加锁</code>操作将会<code>死锁</code>.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> mutex;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">another</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"in child thread, lock the mutex\\n\"</span>);</span><br><span class=\"line\">    pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">    sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 解锁后 Prepare才能加锁</span></span><br><span class=\"line\">    pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">    pthread_exit(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这个函数在fork创建子进程前被调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Prepare</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 但是会阻塞 直到执行another函数的线程解锁 才能够继续执行</span></span><br><span class=\"line\">    <span class=\"comment\">// 这个函数执行完毕前fork不会创建子进程</span></span><br><span class=\"line\">    pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// fork创建线程后 返回前 会在子进程和父进程中执行这个函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Infork</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pthread_mutex_init(&amp;mutex, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> id;</span><br><span class=\"line\">    pthread_create(&amp;id, <span class=\"literal\">nullptr</span>, another, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// pthread_atfork(Prepare, Infork, Infork);</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pid = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pid &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"emmm????\\n\"</span>);</span><br><span class=\"line\">        pthread_join(id, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        pthread_mutex_destroy(&amp;mutex);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"child process, want to get the lock\\n\"</span>);</span><br><span class=\"line\">        pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"i cann't run to here, opps....\\n\"</span>);</span><br><span class=\"line\">        pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"wait start\\n\"</span>);</span><br><span class=\"line\">        wait(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"wait over\\n\"</span>); <span class=\"comment\">// 没有打印 因为子进程不会终止</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_join(id, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    pthread_mutex_destroy(&amp;mutex);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// $ in child thread, lock the mutex</span></span><br><span class=\"line\"><span class=\"comment\">// $ wait start</span></span><br><span class=\"line\"><span class=\"comment\">// $ child process, want to get the lock</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $ in child thread, lock the mutex</span></span><br><span class=\"line\"><span class=\"comment\">// $ wait start</span></span><br><span class=\"line\"><span class=\"comment\">// $ child process, want to get the lock</span></span><br><span class=\"line\"><span class=\"comment\">// $ i cann't run to here, opps....</span></span><br><span class=\"line\"><span class=\"comment\">// $ wait over</span></span><br></pre></td></tr></table></figure>\n\n<p>原版就会发生死锁, 新版(去掉注释的代码) 能够正常运行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_atfork</span> <span class=\"params\">(<span class=\"keyword\">void</span> (*__prepare) (<span class=\"keyword\">void</span>),</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t   <span class=\"keyword\">void</span> (*__parent) (<span class=\"keyword\">void</span>),</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t   <span class=\"keyword\">void</span> (*__child) (<span class=\"keyword\">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>\n<p>第一个句柄 在fork创建子进程前执行<br>第二个句柄 在fork创建出子进程后, fork返回前在父进程中执行<br>第二个句柄 在fork创建出子进程后, fork返回前在子进程中执行</p>\n<h1 id=\"第十五章-进程池和线程池\"><a href=\"#第十五章-进程池和线程池\" class=\"headerlink\" title=\"第十五章 进程池和线程池\"></a>第十五章 进程池和线程池</h1><h1 id=\"线程池-和-简单HTTP服务器\"><a href=\"#线程池-和-简单HTTP服务器\" class=\"headerlink\" title=\"线程池 和 简单HTTP服务器\"></a>线程池 和 简单HTTP服务器</h1><p>对我而言神秘已久的线程池终于揭开了面纱.<br>没想到这就是线程池23333</p>\n<p>线程池写完后 直接写了书上的HTTP服务器.</p>\n<p>那个服务器至少我发现两个问题</p>\n<ul>\n<li>无法发送大文件</li>\n<li>部分请求无法回复</li>\n</ul>\n<p>无法发送大文件, 是因为书中使用了writev发送数据<br>期初我以为下面的判断 writev返回值 等于 -1就是为了发送大文件, 后来发现这个判断只是给期初就发送失败准备的.</p>\n<p>正好前一阵子看了一个服务器的代码<br><a href=\"https://github.com/Jigokubana/Notes-flamingo\" target=\"_blank\" rel=\"noopener\">https://github.com/Jigokubana/Notes-flamingo</a></p>\n<p>我就索性直接将发送部分修改了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// write_sum_ 需发送总大小</span></span><br><span class=\"line\"><span class=\"comment\">// write_idx_ 已发送大小</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (write_sum_ - write_idx_ == <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Modfd(epollfd_, sockfd_, EPOLLIN);</span><br><span class=\"line\">    Init();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    temp = send(sockfd_, &amp;*write_buff_.<span class=\"built_in\">begin</span>() + write_idx_, write_sum_ - write_idx_, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (temp &lt;= <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EAGAIN)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Modfd(epollfd_, sockfd_, EPOLLOUT);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    write_idx_ += temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (write_idx_ == write_sum_)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 解除绑定移到了其他地方</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (linger_)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Init();</span><br><span class=\"line\">            Modfd(epollfd_, sockfd_, EPOLLIN);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Modfd(epollfd_, sockfd_, EPOLLIN);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二个奇葩的问题就是使用ab压测时候 有些请求无法收到回复.<br>这个问题等后面在解决把, 等我知识更加丰富了再说</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第十三章多进程编程\"><a href=\"#第十三章多进程编程\" class=\"headerlink\" title=\"第十三章多进程编程\"></a>第十三章多进程编程</h1><h2 id=\"exec系列系统调用\"><a href=\"#exec系列系统调用\" class=\"headerlink\" title=\"exec系列系统调用\"></a>exec系列系统调用</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 声明这个是外部函数或外部变量</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">char</span>** environ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻</span></span><br><span class=\"line\"><span class=\"comment\">// arg-接受可变参数 和 argv用于向新的程序传递参数数组</span></span><br><span class=\"line\"><span class=\"comment\">// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量</span></span><br><span class=\"line\"><span class=\"comment\">// exec函数是不返回的, 除非出错</span></span><br><span class=\"line\"><span class=\"comment\">// 如果未报错则源程序被新的程序完全替换</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execl</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* arg, ...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execlp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* file, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* arg, ...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execle</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* arg, ..., <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> envp[])</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execv</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execvp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* file, <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execve</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> argv[], <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"fork系统调用-进程的创建\"><a href=\"#fork系统调用-进程的创建\" class=\"headerlink\" title=\"fork系统调用-进程的创建\"></a>fork系统调用-进程的创建</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0</span></span><br><span class=\"line\"><span class=\"comment\">// 次返回值用于区分是父进程还是子进程</span></span><br><span class=\"line\"><span class=\"comment\">// 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">fork</span><span class=\"params\">(viod)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>fork系统调用<br>fork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项<br>新的进程表项有很多的属性和原进程相同</p>\n<ul>\n<li>堆指针</li>\n<li>栈指针</li>\n<li>标志寄存器的值</li>\n<li>子进程代码与父进程完全相同</li>\n<li>同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)父进程的数据(堆数据, 栈数据, 静态数据)</li>\n<li>创建子进程后, <em>父进程打开的文件描述符默认在子进程中也是打开的</em> <code>文件描述符的引用计数</code>, <code>父进程的用户根目录, 当前工作目录等变量的引用计数</code> 均加1</li>\n</ul>\n<p>也存在不同的项目</p>\n<ul>\n<li>该进程的PPID(标识父进程)被设置成原进程的PID,  </li>\n<li><code>信号位图被清除</code>(原进程设置的信号处理函数对新进程无效)</li>\n</ul>\n<p>(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)</p>\n<p>The child process is an exact duplicate of the parent process except<br>for the following points:</p>\n<ul>\n<li><p>The child has its own unique process ID, and this PID does not<br> match the ID of any existing process group (setpgid(2)) or<br> session. 子进程拥有自己唯一的进程ID, 不与其他相同</p>\n</li>\n<li><p>The child’s parent process ID is the same as the parent’s process<br> ID. 子进程的父进程ID PPID 与父进程ID PID相同</p>\n</li>\n<li><p>The child does not inherit its parent’s memory locks (mlock(2),<br> mlockall(2)). 子进程不继承父进程的内存锁(保证一部分内存处于内存中, 而不是sawp分区)</p>\n</li>\n<li><p>Process resource utilizations (getrusage(2)) and CPU time counters<br> (times(2)) are reset to zero in the child.<br> 进程资源使用和CPU时间计数器在子进程中重置为0</p>\n</li>\n<li><p>The child’s set of pending signals is initially empty<br> (sigpending(2)). 信号位图被初始化为空 原信号处理函数对子进程无效 需重新设置</p>\n</li>\n<li><p>The child does not inherit semaphore adjustments from its parent<br> (semop(2)). 不会继承semadj</p>\n</li>\n<li><p>The child does not inherit process-associated record locks from<br> its parent (fcntl(2)).  (On the other hand, it does inherit<br> fcntl(2) open file description locks and flock(2) locks from its<br> parent.)</p>\n</li>\n<li><p>The child does not inherit timers from its parent (setitimer(2),<br> alarm(2), timer_create(2)). 不会继承定时器</p>\n</li>\n<li><p>The child does not inherit outstanding asynchronous I/O operations<br> from its parent (aio_read(3), aio_write(3)), nor does it inherit<br> any asynchronous I/O contexts from its parent (see io_setup(2)).</p>\n</li>\n</ul>\n<h2 id=\"处理僵尸进程-进程的管理\"><a href=\"#处理僵尸进程-进程的管理\" class=\"headerlink\" title=\"处理僵尸进程-进程的管理\"></a>处理僵尸进程-进程的管理</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">wait</span><span class=\"params\">(<span class=\"keyword\">int</span>* stat_loc)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)</span></span><br><span class=\"line\"><span class=\"comment\">// options函数取值WNOHANG-waitpid立即返回</span></span><br><span class=\"line\"><span class=\"comment\">// 如果目标子进程正常退出, 则返回子进程的pid</span></span><br><span class=\"line\"><span class=\"comment\">// 如果还没有结束或意外终止, 则立即返回0</span></span><br><span class=\"line\"><span class=\"comment\">// 调用失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">waitpid</span><span class=\"params\">(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span>* stat_loc, <span class=\"keyword\">int</span> options)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">WIFEXITED(stat_val); <span class=\"comment\">// 子进程正常结束, 返回一个非0</span></span><br><span class=\"line\">WEXITSTATUS(stat_val); <span class=\"comment\">// 如果WIFEXITED 非0, 它返回子进程的退出码</span></span><br><span class=\"line\">WIFSIGNALED(stat_val);<span class=\"comment\">// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值</span></span><br><span class=\"line\">WTERMSIG(stat_val);<span class=\"comment\">// 如果WIFSIGNALED非0 返回一个信号值</span></span><br><span class=\"line\">WIFSTOPPED(stat_val);<span class=\"comment\">// 如果子进程意外终止, 它返回一个非0值</span></span><br><span class=\"line\">WSTOPSIG(stat_val);<span class=\"comment\">// 如果WIFSTOPED非0, 它返回一个信号值</span></span><br></pre></td></tr></table></figure>\n\n<p>对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询</p>\n<ul>\n<li>在<code>子进程结束运行之后, 父进程读取其退出状态前</code>, 我们称该子进程处于<code>僵尸态</code></li>\n<li>另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) <code>父进程结束运行之后, 子进程退出之前</code>, 处于<code>僵尸态</code></li>\n</ul>\n<p>以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.</p>\n<p>waitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.<br>SIGCHLD信号- 子进程结束后将会给父进程发送此信号</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handle_child</span><span class=\"params\">(<span class=\"keyword\">int</span> sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pid_t</span> pid;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stat;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((pid = waitpid(<span class=\"number\">-1</span>, &amp;stat, WNOHANG)) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 善后处理emmmm</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"信号量-进程的锁\"><a href=\"#信号量-进程的锁\" class=\"headerlink\" title=\"信号量-进程的锁\"></a>信号量-进程的锁</h2><p><em>信号量原语</em><br>只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.<br>假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为</p>\n<ul>\n<li>P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行</li>\n<li>V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png\" alt=\"\"></li>\n</ul>\n<p><strong>总结PV使用方法</strong></p>\n<p>使用<code>semget</code>获取到唯一的标识.<br>使用<code>semctl</code>的<code>SETVAL</code>传入初始化val的<code>sem_un</code>联合体.来初始化val<br>调用<code>semop</code> 传入唯一标识, <code>sem_op=-1</code>执行P(锁)操作<code>sem_op=1</code>执行V(开锁)操作<br>开关锁通过当<code>sem_op=-1,semval=0</code><br>且未指定<code>IPC_NOWAIT</code><br>等待<code>semval</code>被<code>sem_op=1</code>改为<code>semval=1</code></p>\n<p><strong>创建信号量</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// semeget 系统调用</span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集</span></span><br><span class=\"line\"><span class=\"comment\">// key 参数是一个键值, 用来标识一个全局唯一的信号量级,可以在不同进程中获取</span></span><br><span class=\"line\"><span class=\"comment\">// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0. 一般都是为1</span></span><br><span class=\"line\"><span class=\"comment\">// sem_flags指定一组标志, 来控制权限</span></span><br><span class=\"line\"><span class=\"comment\">// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错</span></span><br><span class=\"line\"><span class=\"comment\">// - IPC_CREAT | IPC_EXCL来创建一组唯一信号量集 如果已经存在则会返回错误 errno = EEXIST</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">int</span> num_sems, <span class=\"keyword\">int</span> sem_flags)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> sem_id = semget((<span class=\"keyword\">key_t</span>)<span class=\"number\">1234</span>, <span class=\"number\">1</span>, <span class=\"number\">0666</span> | IPC_CREAT);</span><br></pre></td></tr></table></figure>\n\n<p><strong>初始化</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// semctl 系统调用</span></span><br><span class=\"line\"><span class=\"comment\">// sem_id 参数是由semget返回的信号量集标识符</span></span><br><span class=\"line\"><span class=\"comment\">// sen_num指定被操作的信号量在信号集中的编号</span></span><br><span class=\"line\"><span class=\"comment\">// command指定命令, 可以追加命令所需的参数, 不过有推荐格式</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回对应command的参数, 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semctl</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id, <span class=\"keyword\">int</span> sem_num, <span class=\"keyword\">int</span> command, ...)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第四个参数 竟然需要手动声明...</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> semun</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>              val;    <span class=\"comment\">/* Value for SETVAL */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">semid_ds</span> *<span class=\"title\">buf</span>;</span>    <span class=\"comment\">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> short  *<span class=\"built_in\">array</span>;  <span class=\"comment\">/* Array for GETALL, SETALL */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">seminfo</span>  *__<span class=\"title\">buf</span>;</span>  <span class=\"comment\">/* Buffer for IPC_INFO</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t(Linux-specific) */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 初始化信号量</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> semun sem_union;</span><br><span class=\"line\">sem_union.val = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这里可以直接第三个参数传入1(val)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (semctl(sem_id, <span class=\"number\">0</span>, SETVAL, sem_union) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除信号量</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> semun sem_union&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (semctl(sem_id, <span class=\"number\">0</span>, IPC_RMID, sem_union) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>与semop信号量关联的一些重要的内核变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> short semval; <span class=\"comment\">// 信号量的值</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> short semzcnt; <span class=\"comment\">// 等待信号量值变为0的进程数量</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> short semncnt<span class=\"comment\">// 等待信号量值增加的进程数量</span></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> sempid; <span class=\"comment\">// 最后一次执行semop操作的进程ID</span></span><br></pre></td></tr></table></figure>\n<p>操作信号量, 实际上就是对上面的内核变量操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.</span></span><br><span class=\"line\"><span class=\"comment\">// sem_ops 参数指向一个sembuf结构体类型的数组</span></span><br><span class=\"line\"><span class=\"comment\">// num_sem_ops 说明操作数组中哪个信号量</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semop</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id, struct sembuf* sem_ops, <span class=\"keyword\">size_t</span> num_sem_ops)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sem_op &lt; 0 期望获得信号量</span></span><br><span class=\"line\"><span class=\"comment\">// semval-=abs(sem_op),要求调用进程对被操作信号量集有写权限</span></span><br><span class=\"line\"><span class=\"comment\">// 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果semval &lt; abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN</span></span><br><span class=\"line\"><span class=\"comment\">// 如果没有指定 则 阻塞进程等待信号量可用, 且 semzcnt +=1, 等到下面三种情况唤醒</span></span><br><span class=\"line\"><span class=\"comment\">// 1 发生semval &gt;= abs(sem_op), semzcnt-=1, semval-=abs(sem_op). 在SEM_UNDO设置时更新semadj</span></span><br><span class=\"line\"><span class=\"comment\">// 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)</span></span><br><span class=\"line\"><span class=\"comment\">// 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">P</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sembuf</span> <span class=\"title\">sem_b</span>;</span></span><br><span class=\"line\">    sem_b.sem_num = <span class=\"number\">0</span>; <span class=\"comment\">// 信号量编号 第几个信号量 一般都是第0个</span></span><br><span class=\"line\">    sem_b.sem_op = <span class=\"number\">-1</span>; <span class=\"comment\">// P</span></span><br><span class=\"line\">\t<span class=\"comment\">// IPC_NOWAIT 无论信号量操作是否成功, 都立即返回</span></span><br><span class=\"line\">\t<span class=\"comment\">// SEM_UNDO当进程退出的时候, 取消正在进行的semop操作 PV操作系统更新进程的semadj变量</span></span><br><span class=\"line\">    sem_b.sem_flg = SEM_UNDO;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> semop(sem_id, &amp;sem_b, <span class=\"number\">1</span>) != <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sem_op &gt; 0 </span></span><br><span class=\"line\"><span class=\"comment\">// semval+=sem_op , 要求调用进程对被操作的信号量集有写权限</span></span><br><span class=\"line\"><span class=\"comment\">// 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">V</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sembuf</span> <span class=\"title\">sem_b</span>;</span></span><br><span class=\"line\">    sem_b.sem_num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    sem_b.sem_op = <span class=\"number\">1</span>; <span class=\"comment\">// V</span></span><br><span class=\"line\">    sem_b.sem_flg = SEM_UNDO;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> semop(sem_id, &amp;sem_b, <span class=\"number\">1</span>) != <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- sem_op = 0</span></span><br><span class=\"line\"><span class=\"comment\">// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限</span></span><br><span class=\"line\"><span class=\"comment\">// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0</span></span><br><span class=\"line\"><span class=\"comment\">// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN</span></span><br><span class=\"line\"><span class=\"comment\">// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生</span></span><br><span class=\"line\"><span class=\"comment\">// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1</span></span><br><span class=\"line\"><span class=\"comment\">// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM</span></span><br><span class=\"line\"><span class=\"comment\">// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1</span></span><br></pre></td></tr></table></figure>\n\n<p>semget成功时返回一个与之关联的内核结构体semid_ds</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">semid_ds</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">sem_perm</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> sem_nsems; <span class=\"comment\">// 被设置为num_sems</span></span><br><span class=\"line\">\t<span class=\"keyword\">time_t</span> sem_otime; <span class=\"comment\">// 被设置为0</span></span><br><span class=\"line\">\t<span class=\"keyword\">time_t</span> sem_ctime; <span class=\"comment\">// 被设置为当前的系统时间</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 用来描述权限</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">uid_t</span> uid; <span class=\"comment\">// 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">gid_t</span> gid; <span class=\"comment\">// 所有者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">uid_t</span> cuid; <span class=\"comment\">// 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">gid_t</span> cgid; <span class=\"comment\">// 创建者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">mode_t</span> mode;<span class=\"comment\">// 访问权限, 背着只为sem_flags参数的最低9位.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"共享内存-进程间通信\"><a href=\"#共享内存-进程间通信\" class=\"headerlink\" title=\"共享内存-进程间通信\"></a>共享内存-进程间通信</h2><p><strong>最高效的IPC(进程间通信)机制</strong><br>需要自己同步进程对其的访问, 否则会产生竞态条件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// key</span></span><br><span class=\"line\"><span class=\"comment\">// 与semget相同 标识一段全局唯一的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">// size 内存区域大小 单位字节</span></span><br><span class=\"line\"><span class=\"comment\">// shmflg</span></span><br><span class=\"line\"><span class=\"comment\">// IPC_CREAT 存不存在都创建新的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">// IPC_CREAT | IPC_EXCL 不存在则创建 存在则报错</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_HUGETLB 系统将使用\"大页面\"来为共享内存分配空间</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_NORESERVE 不为共享内存保留swap空间, 如果物理内存不足</span></span><br><span class=\"line\"><span class=\"comment\">// -在执行写操作的时候将会触发`SIGSEGV`信号</span></span><br><span class=\"line\"><span class=\"comment\">// -成功返回唯一标识, 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">size_t</span> <span class=\"built_in\">size</span>, <span class=\"keyword\">int</span> shmflg)</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// shm_id </span></span><br><span class=\"line\"><span class=\"comment\">// shmget返回的唯一标识</span></span><br><span class=\"line\"><span class=\"comment\">// shm_addr </span></span><br><span class=\"line\"><span class=\"comment\">// 关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响</span></span><br><span class=\"line\"><span class=\"comment\">// 如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 shm_addr 非空,且没有`SHM_RND`标志 则关联到指定的地址处</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写*</span></span><br><span class=\"line\"><span class=\"comment\">// shmflg</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_RDONLY 设置后内存内容变成只读, 不设置则为读写模式</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_EXEC 有执行权限</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回关联到的地址, 失败返回 (void*)-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">shmat</span><span class=\"params\">(<span class=\"keyword\">int</span> shm_id, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* shm_addr, <span class=\"keyword\">int</span> shmflg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 将共享内存关联到进程的地址空间 调用成功之后, 修改shmid_ds的部分内容</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -shm_nattach +1</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -更新 shm_lpid</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -shm_atime设置为当前时间</span></span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将共享内存从进程地址空间中分离</span></span><br><span class=\"line\"><span class=\"comment\">// 成功后</span></span><br><span class=\"line\"><span class=\"comment\">// -shm_nattach -1</span></span><br><span class=\"line\"><span class=\"comment\">// -更新 shm_lpid和shm_dtime设置为当前时间</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmdt</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* shm_addr)</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shm_ctl</span><span class=\"params\">(<span class=\"keyword\">int</span> shm_id, <span class=\"keyword\">int</span> command, struct shmid_ds* buf)</span></span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/shmctl.png\" alt=\"\"></p>\n<hr>\n<p>shmget 同时会创建对应的<code>shmid_ds</code>结构体</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">shmid_ds</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">shm_per</span>;</span> <span class=\"comment\">// 权限相关</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> shm_segsz; <span class=\"comment\">// 共享内存大小 单位字节\tsize</span></span><br><span class=\"line\">\t<span class=\"keyword\">__time_t</span> shm_atime; <span class=\"comment\">// 对这段内存最后一次调用semat的时间 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">__time_t</span> shm_dtime; <span class=\"comment\">// 对这段内存最后一次调用semdt的时间 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">__time_t</span> shm_ctime; <span class=\"comment\">// 对这段内存最后一次调用semctl的时间 当前时间</span></span><br><span class=\"line\">\t<span class=\"keyword\">__pid_t</span> shm_cpid; <span class=\"comment\">// 创建者PID</span></span><br><span class=\"line\">\t<span class=\"keyword\">__pid_t</span> lpid; <span class=\"comment\">// 最后一次执行shmat或shmdt的进程PID</span></span><br><span class=\"line\">\t<span class=\"keyword\">shmatt_t</span> shm_nattach <span class=\"comment\">// 关联到此共享内存空间的进程数量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>共享内存的POSIX方法</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> shmfd = shm_open(<span class=\"string\">\"/shm_name\"</span>, O_CREAT | O_RDWR, <span class=\"number\">0666</span>);</span><br><span class=\"line\">ERROR_IF(shmfd == <span class=\"number\">-1</span>, <span class=\"string\">\"shm open\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = ftruncate(shmfd, BUFFER_SIZE);</span><br><span class=\"line\">ERROR_IF(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"ftruncate\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">share_mem = (<span class=\"keyword\">char</span>*)mmap(<span class=\"literal\">nullptr</span>, BUFFER_SIZE,</span><br><span class=\"line\">\t\tPROT_READ | PROT_WRITE, MAP_SHARED, shmfd, <span class=\"number\">0</span>);</span><br><span class=\"line\">ERROR_IF(share_mem == MAP_FAILED, <span class=\"string\">\"share_mem\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">close</span>(shmfd);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消关联</span></span><br><span class=\"line\">munmap((<span class=\"keyword\">void</span>*)share_mem, BUFFER_SIZE);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进程通信-管道\"><a href=\"#进程通信-管道\" class=\"headerlink\" title=\"进程通信-管道\"></a>进程通信-管道</h2><p>管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证<br>父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].</p>\n<p>可以用两个管道来实现双向传输数据, 也可以用<code>socketpair</code>来创建管道</p>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><p>消息队列是两个进程之间传递二进制块数据的一种简单有效的方式.<br>每个数据块都有自己的类型, 接收方可以根据类型有选择的接收数据</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/msg.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 与semget 相同, 成功返回标识符</span></span><br><span class=\"line\"><span class=\"comment\">// msgflg的设置和作用域setget相同</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// msg_ptr参数指向一个准备发送的消息, 消息必须按如下定义</span></span><br><span class=\"line\"><span class=\"comment\">// msg_sz 指的是mtext的长度!!!</span></span><br><span class=\"line\"><span class=\"comment\">// msgflg通常仅支持IPC_NOWAIT 以非阻塞形式发送数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgsnd</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *msg_ptr, <span class=\"keyword\">size_t</span> msg_sz, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br><span class=\"line\">默认如果消息队列已满, 则会阻塞. 如果设置了 IPC_NOTWAIT</span><br><span class=\"line\">就立即返回 设置errno=EAGIN</span><br><span class=\"line\"></span><br><span class=\"line\">系统自带这个结构体 不过mtext长度是<span class=\"number\">1.</span>..</span><br><span class=\"line\">struct msgbuf</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> mtype; <span class=\"comment\">/* 消息类型 正整数*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> mtext[<span class=\"number\">512</span>]; <span class=\"comment\">/* 消息数据*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// msgtype = 0 读取消息队列第一个消息</span></span><br><span class=\"line\"><span class=\"comment\">// msgtype &gt; 0 读取消息队列第一个类型是msgtype的消息 除非标志了MSG_EXCEPT</span></span><br><span class=\"line\"><span class=\"comment\">// msgtype &lt; 0 读取第一个 类型值 &lt; abs(msgtype)的消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IPC_NOWAIT 如果消息队列没有消息, 则msgrcv立即返回并设置errno=ENOMSG</span></span><br><span class=\"line\"><span class=\"comment\">// MSG_EXCEPT 如果msgtype大于0, 则接收第一个非 msgtype 的数据</span></span><br><span class=\"line\"><span class=\"comment\">// MSG_NOERROR 消息部分长度超过msg_sz 则将它截断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgrcv</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">void</span> *msg_ptr, <span class=\"keyword\">size_t</span> msg_sz, <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> msgtype, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br><span class=\"line\">处于阻塞状态 当消息队列被移除(errno=EIDRM)或者程序接受到信号(errno=EINTR) 都会中断阻塞状态</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgctl</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">int</span> command, struct msqid_ds *buf)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">IPC_STAT 复制消息队列关联的数据结构</span><br><span class=\"line\">IPC_SET 将buf中的部分成员更新到目标的内核数据</span><br><span class=\"line\">IPC_RMID 立即移除消息队列, 唤醒所有等待读消息和写消息的进程</span><br><span class=\"line\">IPC_INFO 获取系统消息队列资源配置信息</span><br><span class=\"line\"></span><br><span class=\"line\">MSG_INFO 返回已经分配的消息队列所占用资源信息</span><br><span class=\"line\">MSG_STAT msgqid不再是标识符, 而是内核消息队列的数组索引</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"在进程间传递文件描述符\"><a href=\"#在进程间传递文件描述符\" class=\"headerlink\" title=\"在进程间传递文件描述符\"></a>在进程间传递文件描述符</h2><h2 id=\"IPC命令-查看进程间通信的全局唯一key\"><a href=\"#IPC命令-查看进程间通信的全局唯一key\" class=\"headerlink\" title=\"IPC命令-查看进程间通信的全局唯一key\"></a>IPC命令-查看进程间通信的全局唯一key</h2><h1 id=\"第十四章-多线程编程\"><a href=\"#第十四章-多线程编程\" class=\"headerlink\" title=\"第十四章 多线程编程\"></a>第十四章 多线程编程</h1><p>根据运行环境和调度者身份, 线程可以分为两种<br>内核线程<br>运行在内核空间, 由内核来调度.<br>用户线程<br>运行在用空间, 由线程库来调用</p>\n<p>当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.</p>\n<p>线程有三种实现方式</p>\n<ul>\n<li>完全在用户空间实现-无需内核支持<br>  创建和调度线程无需内核干预, 速度很快.<br>  不占用额外的内核资源, 对系统影响较小<br>  但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的</li>\n<li>完全由内核调度<br>  创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理<br>  优缺点正好与上一个相反</li>\n<li>双层调度<br>  结合了前两个的优点<br>  不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势</li>\n</ul>\n<h2 id=\"进程的创建和终止\"><a href=\"#进程的创建和终止\" class=\"headerlink\" title=\"进程的创建和终止\"></a>进程的创建和终止</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_create</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span>* thread, <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_attr_t</span>* attr, <span class=\"keyword\">void</span>* (*start_routine)(<span class=\"keyword\">void</span>*), <span class=\"keyword\">void</span>* arg)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回错误码</span></span><br><span class=\"line\"><span class=\"comment\">// thread 用来唯一的标识一个新线程</span></span><br><span class=\"line\"><span class=\"comment\">// attr用来设置新县城的属性 传递NULL表示默认线程属性</span></span><br><span class=\"line\"><span class=\"comment\">// start_routine 指定新线程运行的函数</span></span><br><span class=\"line\"><span class=\"comment\">// arg指定函数的参数</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>* retval)</span></span>;</span><br><span class=\"line\">用来保证线程安全干净的退出, 线程函数最好结束时调用.</span><br><span class=\"line\">通过`retval`参数向线程的回收者传递其退出信息</span><br><span class=\"line\">执行后不会返回到调用者, 而且永远不会失败</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_join</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread, <span class=\"keyword\">void</span>** retval)</span></span></span><br><span class=\"line\">可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.</span><br><span class=\"line\">成功时返回<span class=\"number\">0</span>, 失败返回错误码</span><br><span class=\"line\">等待其他线程结束</span><br><span class=\"line\">thread 线程标识符</span><br><span class=\"line\">retval 目标线程的退出返回信息</span><br><span class=\"line\"></span><br><span class=\"line\">错误码如下</span><br><span class=\"line\">`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用</span><br><span class=\"line\">`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程</span><br><span class=\"line\">`ESRCH`目标线程不存在</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cancel</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread)</span></span></span><br><span class=\"line\">异常终止一个线程, 即为取消线程</span><br><span class=\"line\">成功返回<span class=\"number\">0</span>, 失败返回错误码</span><br></pre></td></tr></table></figure>\n\n<p><strong>线程属性设置</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.</span><br><span class=\"line\"><span class=\"comment\">// 启动线程取消</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_setcancelstart</span><span class=\"params\">(<span class=\"keyword\">int</span> state, <span class=\"keyword\">int</span>* oldstate)</span></span></span><br><span class=\"line\">第一个参数</span><br><span class=\"line\">PTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态</span><br><span class=\"line\">PTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求直到</span><br><span class=\"line\">这个线程允许被取消</span><br><span class=\"line\">第二个参数 返回之前设定的状态</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置线程取消类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_setcanceltype</span><span class=\"params\">(<span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span>* oldtype)</span></span></span><br><span class=\"line\">第一个参数</span><br><span class=\"line\">PTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消</span><br><span class=\"line\">PTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 直到调用了下面几个所谓的取消点函数</span><br><span class=\"line\">最好使用pthread_testcancel函数设置取消点</span><br><span class=\"line\">设置取消类型(如何取消)</span><br><span class=\"line\">第二个参数</span><br><span class=\"line\">原来的取消类型</span><br></pre></td></tr></table></figure>\n\n<p><strong>设置脱离线程</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化线程属性对象</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_init</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 销毁线程属性对象, 直到再次初始化前都不能用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_destory</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 参数取值</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -PTHREAD_CREATE_JOINABLE 线程可回收</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -PTHREAD_CREATE_DETACH 脱离与进程中其他线程的同步 成为脱离线程</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_getdetachstate</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">int</span> *detachstate)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_attr_setdetachstate</span><span class=\"params\">(<span class=\"keyword\">pthread_attr_t</span> *attr, <span class=\"keyword\">int</span> detachstate)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 可以直接设置为脱离线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_detach</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread)</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"线程同步机制的使用场景\"><a href=\"#线程同步机制的使用场景\" class=\"headerlink\" title=\"线程同步机制的使用场景\"></a>线程同步机制的使用场景</h2><p>POSIX信号量-需要自己维护计数值, 用户空间有计数值 信号量自己又计数值<br>两份计数值容易出错</p>\n<p>互斥锁-对临界资源的独占式访问</p>\n<p>条件变量-等待某个条件满足<br>当某个共享数据达到某个值的时候, 唤醒等待这个共享数据的线程</p>\n<p>读写锁-可以多个进程读, 读的时候不能写, 同时只能一个写</p>\n<p>自旋锁-通过while循环频繁尝试获取锁, 适用于锁事件短, 需要快速切换的场景</p>\n<h2 id=\"POSIX信号量\"><a href=\"#POSIX信号量\" class=\"headerlink\" title=\"POSIX信号量\"></a>POSIX信号量</h2><p>多线程也必须考虑线程同步的问题.<br>虽然<code>pthread_join()</code>可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求<br>比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;semaphore&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 用于初始化一个未命名的信号量.</span></span><br><span class=\"line\"><span class=\"comment\">// pshared==0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享</span></span><br><span class=\"line\"><span class=\"comment\">// value指定参数的初始值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_init</span><span class=\"params\">(<span class=\"keyword\">sem_t</span>* sem, <span class=\"keyword\">int</span> pshared, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 销毁信号量, 释放其占用的系统资源</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_destory</span><span class=\"params\">(<span class=\"keyword\">sem_t</span>* sem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞直到sem_wait具有非0值</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_wait</span><span class=\"params\">(<span class=\"keyword\">sem_t</span>* sem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 跟上面的函数相同不过不会阻塞. 信号量不为0则减一操作, 为0则返回-1 errno</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_trywait</span><span class=\"params\">(<span class=\"keyword\">sem_t</span>* sem)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 原子操作将信号量的值 +1</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sem_post</span><span class=\"params\">(<span class=\"keyword\">sem_t</span>* sem)</span></span></span><br></pre></td></tr></table></figure>\n<p>初始化已经存在的信号量会导致无法预期的结果</p>\n<p>销毁正被其他线程等待的信号量, 将会导致无法预期的结果</p>\n<p>例子如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> kNumberMax = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">number</span><span class=\"params\">(kNumberMax)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> kThreadNum = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">sem_t</span> sems[kThreadNum];</span><br><span class=\"line\"><span class=\"keyword\">pthread_t</span> threads[kThreadNum];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> kPrintTime = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">t</span><span class=\"params\">(<span class=\"keyword\">void</span> *no)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start_sub = *<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>*&gt;(no);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sub =start_sub;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> time = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(++time &lt;= kPrintTime)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 锁住本线程 释放下一个线程</span></span><br><span class=\"line\">        sem_wait(&amp;sems[start_sub]);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, number[sub]);</span><br><span class=\"line\">        sem_post(&amp;sems[(start_sub + <span class=\"number\">1</span>) % kThreadNum]);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 计算下一次要打印的下标</span></span><br><span class=\"line\">        sub = (sub + kThreadNum) % kNumberMax;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_exit(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::iota(number.<span class=\"built_in\">begin</span>(), number.<span class=\"built_in\">end</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">    sem_init(&amp;sems[<span class=\"number\">0</span>], <span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; kThreadNum; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sem_init(&amp;sems[i], <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; kThreadNum; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_create(&amp;threads[i], <span class=\"literal\">nullptr</span>, t, &amp;number[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 等待最后一个线程结束</span></span><br><span class=\"line\">    pthread_join(threads[kThreadNum - <span class=\"number\">1</span>], <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>kThreadNum个进程依次打印<code>[0, kNumberMax)</code><br>每个进程打印kPrintTime次<br>最后一个进程打印完后主线程才能结束</p>\n<h2 id=\"互斥锁\"><a href=\"#互斥锁\" class=\"headerlink\" title=\"互斥锁\"></a>互斥锁</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化互斥锁</span></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数指向目标互斥锁, 第二个参数指定属性 nullptr则为默认</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_init</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex, <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 销毁目标互斥锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_destory</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 针对普通锁加锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_lock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 针对普通锁立即返回 目标未加锁则加锁 如果已经加锁则返回错误码EBUSY</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_trylock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解锁 如果有其他线程在等待这个互斥锁, 则其中之一获得</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_unlock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>销毁一个已经加锁的互斥锁 会发生不可预期的后果<br>也可使使用宏<code>PTHREAD_MUTEX_INITIALIZER</code>来初始化一个互斥锁<br>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</p>\n<p><strong>互斥锁属性设置</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_init</span><span class=\"params\">(<span class=\"keyword\">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_destory</span><span class=\"params\">(<span class=\"keyword\">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PTHREAD_PROCESS_SHARED 跨进程共享</span></span><br><span class=\"line\"><span class=\"comment\">// PTHREAD_PROCESS_PRIVATE 隶属同一进程的线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_getpshared</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *attr, <span class=\"keyword\">int</span> *pshared)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_setpshared</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *attr, <span class=\"keyword\">int</span> pshared)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// PTHREAD_MUTEX_NORMAL 普通锁 默认类型</span></span><br><span class=\"line\"><span class=\"comment\">// PTHREAD_MUTEX_ERRORCHECK 检错锁</span></span><br><span class=\"line\"><span class=\"comment\">// PTHREAD_MUTEX_RECURSVE 嵌套锁</span></span><br><span class=\"line\"><span class=\"comment\">// PTHREAD_MUTEX_DEFAULT 默认锁</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_gettype</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *attr, <span class=\"keyword\">int</span> *type)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutexattr_settype</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">pthread_mutexattr_t</span> *attr, <span class=\"keyword\">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>PTHREAD_MUTEX_NORMAL<br>一个线程对其加锁后, 其他请求该锁的进程会形成一个等待队列, 解锁后然后按照优先级获得. 保证资源分配公平<br>A线程对一个<code>已经加锁</code>的普通锁<code>再次加锁(也是A线程)</code>-同一线程在解锁前再次加锁引发死锁<br>对一个已经<code>被其他线程加锁</code>的普通锁<code>解锁</code>, 或者<code>再次解锁已经解锁</code>的普通锁–解锁-不可预期后果</p>\n<p>PTHREAD_MUTEX_ERRORCHECK<br>线程对<code>已经加锁</code>的检错锁<code>再次加锁</code>–加锁-加锁操作返回EDEADLK<br>对一个已经<code>被其他线程加锁</code>的检错锁<code>解锁</code>, 或者<code>再次解锁已经解锁</code>的检错锁–解锁-返回EPERM</p>\n<p>PTHREAD_MUTEX_RECURSVE<br>允许一个线程在释放锁前多次加锁 而不发生死锁.<br>如果<code>其他线程</code>要获得这个锁, 则<code>当前锁拥有者</code>必须执行相应次数的解锁操作–加锁<br>对于<code>已经被其他进程</code>加锁的嵌套锁解锁, 或者对<code>已经解锁</code>的再次解锁–解锁-返回EPERM</p>\n<p>PTHREAD_MUTEX_DEFAULT<br>这种锁的实现可能为上面三种之一<br>对已经加锁的默认锁再次加锁<br>对被其他线程加锁的默认锁解锁<br>再次解锁已经解锁的默认锁<br>都将会发生不可预料后果</p>\n<p>例子</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> mutex;</span><br><span class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">t</span><span class=\"params\">(<span class=\"keyword\">void</span> *a)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, count);</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">    pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pthread_mutex_init(&amp;mutex, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> thread[<span class=\"number\">10</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_create(&amp;thread[i], <span class=\"literal\">nullptr</span>, t, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">    pthread_mutex_destroy(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"条件变量\"><a href=\"#条件变量\" class=\"headerlink\" title=\"条件变量\"></a>条件变量</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_init</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond, <span class=\"keyword\">const</span> pthread_condattr *cond_attr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 销毁一个正在被等待的条件变量 将会失败并返回EBUSY</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cont_destory</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 广播式的唤醒所有等待目标条件变量的线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cont_broadcast</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 唤醒一个等待目标条件变量的线程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_signal</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等待目标条件变量</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cond_wait</span><span class=\"params\">(<span class=\"keyword\">pthread_cond_t</span> *cond, <span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;<br>将各个字段初始化为0</p>\n<p>pthread_cond_wait的第二个参数, 用于保护条件变量的互斥锁<br>掉用函数前必须将 mutex加锁, 否则会发生不可预料的后果.<br>函数执行前将调用线程放入条件变量等待队列, 然后将mutex解锁</p>\n<p>从函数调用, 到被放入等待队列的时间内, pthread_cond_signal(broadcast)不会修改条件变量的值<br>也就是 pthread_cond_wait函数不会错过目标条件变量的任何变化,<br>将pthread_cond_wait函数返回的时候, 互斥锁mutex将会再次锁上</p>\n<p>例子</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> mutex;</span><br><span class=\"line\"><span class=\"keyword\">pthread_cond_t</span> cond;</span><br><span class=\"line\"><span class=\"keyword\">int</span> good = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> produce_count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> consume_count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">Producer</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(produce_count &lt; <span class=\"number\">10</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">        good++;</span><br><span class=\"line\">        pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">        produce_count++;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"produce a good\\n\"</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">// 通知一个线程</span></span><br><span class=\"line\">        pthread_cond_signal(&amp;cond);</span><br><span class=\"line\">        sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_exit(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">Consumer</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (consume_count &lt; <span class=\"number\">13</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 传入前需要加锁</span></span><br><span class=\"line\">        pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (good &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            good--;</span><br><span class=\"line\">            consume_count++;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"consume a good, reset %d\\n\"</span>, good);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"good is 0\\n\"</span>);</span><br><span class=\"line\">            <span class=\"comment\">// wait pthread_cond_signal</span></span><br><span class=\"line\">            pthread_cond_wait(&amp;cond, &amp;mutex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\"></span><br><span class=\"line\">        usleep(<span class=\"number\">500</span> * <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_exit(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class=\"line\">    cond = PTHREAD_COND_INITIALIZER;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> producer, consumer;</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_create(&amp;consumer, <span class=\"literal\">nullptr</span>, Consumer, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    pthread_create(&amp;producer, <span class=\"literal\">nullptr</span>, Producer, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    pthread_join(consumer, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    pthread_mutex_destroy(&amp;mutex);</span><br><span class=\"line\">    pthread_cond_destroy(&amp;cond);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"读写锁\"><a href=\"#读写锁\" class=\"headerlink\" title=\"读写锁\"></a>读写锁</h2><h2 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h2><h2 id=\"线程同步包装类-多线程环境\"><a href=\"#线程同步包装类-多线程环境\" class=\"headerlink\" title=\"线程同步包装类-多线程环境\"></a>线程同步包装类-多线程环境</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sem</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Sem()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sem_init(&amp;sem_, <span class=\"number\">0</span>, <span class=\"number\">0</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::exception();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Sem()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sem_destroy(&amp;sem_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Wait</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sem_wait(&amp;sem_) == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Post</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sem_post(&amp;sem_) == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">sem_t</span> sem_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mutex</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Mutex()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pthread_mutex_init(&amp;mutex_, <span class=\"literal\">nullptr</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::exception();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Mutex()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_mutex_destroy(&amp;mutex_);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Lock</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pthread_mutex_lock(&amp;mutex_) == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Unlock</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pthread_mutex_unlock(&amp;mutex_) == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">pthread_mutex_t</span> mutex_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cond</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Cond()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pthread_mutex_init(&amp;mutex_, <span class=\"literal\">nullptr</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::exception();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pthread_cond_init(&amp;cond_, <span class=\"literal\">nullptr</span>) != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 这里我一开始没有想到..</span></span><br><span class=\"line\">            pthread_mutex_destroy(&amp;mutex_);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::exception();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Cond()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        pthread_mutex_destroy(&amp;mutex_);</span><br><span class=\"line\">        pthread_cond_destroy(&amp;cond_);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Wait</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">        pthread_mutex_lock(&amp;mutex_);</span><br><span class=\"line\">        ret = pthread_cond_wait(&amp;cond_, &amp;mutex_);</span><br><span class=\"line\">        pthread_mutex_unlock(&amp;mutex_);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Signal</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pthread_cond_signal(&amp;cond_) == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">pthread_cond_t</span> cond_;</span><br><span class=\"line\">    <span class=\"keyword\">pthread_mutex_t</span> mutex_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>线程安全或可重入函数–函数能被多个线程同时调用而不发生竞态条件</p>\n<p>多线程程序某个线程调用fork函数, 新进程不会与父进程有相同数量的线程<br>子进程只有一个线程-调用fork线程的完美复制</p>\n<p>但是子进程会继承父进程的互斥锁(条件变量)的状态, 如果互斥锁被加锁了, 但<code>不是由</code>调用fork线程<br>锁住的, 此时<code>子进程</code>再次对这个互斥锁<code>执行加锁</code>操作将会<code>死锁</code>.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> mutex;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">another</span><span class=\"params\">(<span class=\"keyword\">void</span> *arg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"in child thread, lock the mutex\\n\"</span>);</span><br><span class=\"line\">    pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">    sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 解锁后 Prepare才能加锁</span></span><br><span class=\"line\">    pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">    pthread_exit(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 这个函数在fork创建子进程前被调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Prepare</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 但是会阻塞 直到执行another函数的线程解锁 才能够继续执行</span></span><br><span class=\"line\">    <span class=\"comment\">// 这个函数执行完毕前fork不会创建子进程</span></span><br><span class=\"line\">    pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// fork创建线程后 返回前 会在子进程和父进程中执行这个函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Infork</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    pthread_mutex_init(&amp;mutex, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">pthread_t</span> id;</span><br><span class=\"line\">    pthread_create(&amp;id, <span class=\"literal\">nullptr</span>, another, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// pthread_atfork(Prepare, Infork, Infork);</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> pid = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pid &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"emmm????\\n\"</span>);</span><br><span class=\"line\">        pthread_join(id, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        pthread_mutex_destroy(&amp;mutex);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"child process, want to get the lock\\n\"</span>);</span><br><span class=\"line\">        pthread_mutex_lock(&amp;mutex);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"i cann't run to here, opps....\\n\"</span>);</span><br><span class=\"line\">        pthread_mutex_unlock(&amp;mutex);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"wait start\\n\"</span>);</span><br><span class=\"line\">        wait(<span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"wait over\\n\"</span>); <span class=\"comment\">// 没有打印 因为子进程不会终止</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pthread_join(id, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    pthread_mutex_destroy(&amp;mutex);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// $ in child thread, lock the mutex</span></span><br><span class=\"line\"><span class=\"comment\">// $ wait start</span></span><br><span class=\"line\"><span class=\"comment\">// $ child process, want to get the lock</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $ in child thread, lock the mutex</span></span><br><span class=\"line\"><span class=\"comment\">// $ wait start</span></span><br><span class=\"line\"><span class=\"comment\">// $ child process, want to get the lock</span></span><br><span class=\"line\"><span class=\"comment\">// $ i cann't run to here, opps....</span></span><br><span class=\"line\"><span class=\"comment\">// $ wait over</span></span><br></pre></td></tr></table></figure>\n\n<p>原版就会发生死锁, 新版(去掉注释的代码) 能够正常运行</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_atfork</span> <span class=\"params\">(<span class=\"keyword\">void</span> (*__prepare) (<span class=\"keyword\">void</span>),</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t   <span class=\"keyword\">void</span> (*__parent) (<span class=\"keyword\">void</span>),</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t   <span class=\"keyword\">void</span> (*__child) (<span class=\"keyword\">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>\n<p>第一个句柄 在fork创建子进程前执行<br>第二个句柄 在fork创建出子进程后, fork返回前在父进程中执行<br>第二个句柄 在fork创建出子进程后, fork返回前在子进程中执行</p>\n<h1 id=\"第十五章-进程池和线程池\"><a href=\"#第十五章-进程池和线程池\" class=\"headerlink\" title=\"第十五章 进程池和线程池\"></a>第十五章 进程池和线程池</h1><h1 id=\"线程池-和-简单HTTP服务器\"><a href=\"#线程池-和-简单HTTP服务器\" class=\"headerlink\" title=\"线程池 和 简单HTTP服务器\"></a>线程池 和 简单HTTP服务器</h1><p>对我而言神秘已久的线程池终于揭开了面纱.<br>没想到这就是线程池23333</p>\n<p>线程池写完后 直接写了书上的HTTP服务器.</p>\n<p>那个服务器至少我发现两个问题</p>\n<ul>\n<li>无法发送大文件</li>\n<li>部分请求无法回复</li>\n</ul>\n<p>无法发送大文件, 是因为书中使用了writev发送数据<br>期初我以为下面的判断 writev返回值 等于 -1就是为了发送大文件, 后来发现这个判断只是给期初就发送失败准备的.</p>\n<p>正好前一阵子看了一个服务器的代码<br><a href=\"https://github.com/Jigokubana/Notes-flamingo\" target=\"_blank\" rel=\"noopener\">https://github.com/Jigokubana/Notes-flamingo</a></p>\n<p>我就索性直接将发送部分修改了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// write_sum_ 需发送总大小</span></span><br><span class=\"line\"><span class=\"comment\">// write_idx_ 已发送大小</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (write_sum_ - write_idx_ == <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Modfd(epollfd_, sockfd_, EPOLLIN);</span><br><span class=\"line\">    Init();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    temp = send(sockfd_, &amp;*write_buff_.<span class=\"built_in\">begin</span>() + write_idx_, write_sum_ - write_idx_, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (temp &lt;= <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EAGAIN)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Modfd(epollfd_, sockfd_, EPOLLOUT);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    write_idx_ += temp;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (write_idx_ == write_sum_)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 解除绑定移到了其他地方</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (linger_)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Init();</span><br><span class=\"line\">            Modfd(epollfd_, sockfd_, EPOLLIN);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Modfd(epollfd_, sockfd_, EPOLLIN);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二个奇葩的问题就是使用ab压测时候 有些请求无法收到回复.<br>这个问题等后面在解决把, 等我知识更加丰富了再说</p>\n"},{"title":"代码大全","date":"2020-05-13T13:19:39.000Z","top":130,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E5%B0%81%E9%9D%A2.png","_content":"距离上次什么时候写博客已经记不清了, 看了眼GitHub备份记录 已经25天了. 这25天我咕了吗? 咕是不可能咕的. 这段时间我终于做出了第一个UE4比较完善的联机游戏.\n学习了更多的muduo自己的mongo也更加完善. 只看书写博客不写代码可不行.\n\n技术类书籍慢慢开始看了, mongo写的时间不短了.  代码大全听说是神书? 来粗读看看吧\n\n# 第?部分\n## 第六章 可以工作的类\n使用ADT 可以实现隐藏细节, 改动不会影响到整个程序.\n\n这点感受还是有些的. 前两天自己写VPN(目前项目暂停了)的时候, 有个Buffer类, Buffer类的核心是libevent的evbuff, 我直接使用Get方法Get到这个evbuff的指针, 然后在外部进行操作.\n起初这样只是图简单吧, 也想到了这样会写出烂代码. 后面改动核心evbuff的时候, 发现太麻烦了, 最终改成了几个简单的接口 Append Clear等, 对外隐藏了内部是什么缓冲结构\n\n\nhas a  ---- 组合 包含\nis a ---- 集成 epoll(select) is a mutiplexing\n\n\n只有一个实例的类是值得怀疑的, 同样只有一个派生类的基类也是值得怀疑的\n\n拷贝对象优先使用深拷贝\n\n创建类的原因\n- 为现实世界中的对象建模\n- 为抽象的对象建模 形状类是抽象的 不过圆 正方形等都是真实存在的\n- 降低复杂度 一个类创建结束后, 你就可以忘掉其中的细节 使用接口即可\n- 隔离复杂度\n- 隐藏实现细节 限制变动的影响范围 隐藏全局数据\n- 让参数传递更加舒畅 成员变量 \n- 复用代码\n\n\n## 第七章 高质量的子程序\n\n创建子程序的正当理由\n- 降低复杂度\n一个子程序编写完毕后, 应该可以忘记其中的细节\n- 引入中间,易懂的抽象\n避免代码重复  从大块的代码中抽取子程序\n- 隐藏顺序 如果某两行代码有特定的执行顺序, 可以考虑抽取出来. 感觉这里可以推广到Mutex lock后忘记unlock 或者 Buffer中读取数据后 忘记移动指针?\n- 提高可移植性 这点看项目了\n\n\n似乎过于简单没有必要写成子程序, 当然也要看情况了\n- 这里我感觉最深的还是 两行或者三行经常调用的程序, 如果重复写多次 最终告知你需要修改的时候 那可真是灾难性的消息. 实例的话: 增加参数校验等等\n\n\n准确的使用对仗词\n\n|        |          |\n| ------ | -------- |\n| add    | remove   |\n| begin  | end      |\n| create | destory  |\n| next   | previous |\n| start  | stop     |\n\n\n如何使用子程序参数\n- 按照输入-修改-输出的顺序排列参数\n- 如果几个子程序都是用了类似的一些参数, 应该让这些参数的排列顺序一致\n- 使用所有的参数, 删去未使用到的参数\n- 不要把子程序的参数用做工作变量\n\n设置函数的返回值\n- 检查所有可能的返回路径, 在函数开头设置默认返回 一个不错的选择(muduo中见到了)\n- 老生常谈的不要返回局部对象的引用或者指针\n\n\n少使用宏吧 inline和typedef 不香吗, 不是肉包子也是好吃的素包子了\n\n## 第八章 防御式编程\n~~防御式编程并不是说让你在编程时保持 \"防备批评或攻击\" 的态度~~\n\n子程序不应该因为传入错误数据而被破坏\n- 检查所有源自外部数据的值\n- 检查子程序所有输入参数的值\n- 决定如何处理错误的输入数据\n\n使用错误处理代码来处理与其发生的状况, 使用断言来处理绝不应该发生的状况\n\n\n错误处理技术 其他感觉... 用不到吧 现在不记录了\n- 返回中立值 最简单的方法, 继续执行操作并简单的返回一个没有危害的数值. 数值计算-返回0 字符串返回空串 指针返回空指针\n- 日志打印\n- 关闭程序\n\n\n隔离程序\n两块相对独立的代码块 在交互函数见进行参数校验 过滤掉一个模块传来的非法参数\n\n辅助调试的代码.....\n我现在就遇到一个bug 还不知道怎么修改 与多线程有关的问题 排查真难-2020年5月18日13:11:43\n2020年6月18日23:50:44 排查掉了 今天看到了这段话 补充上吧\n\n决定产品最终发布的时候应该保留多少防御内容\n防御内容越多消耗的性能越多\n\n## 第九章 伪代码的编程过程\n\n原则\n- 用类似英语的句子来准确描述特定的操作\n- 便面使用目标编程语言中的特定语法元素\n- 在本意的层面上编写伪代码. 用伪代码描述解决问题的方法意图, 而不是去写如何用目标语言实现这个方法\n- 在一个足够低的层次上编写伪代码, 以便近乎自动的生成代码, 如果层次过高则会隐藏细节问题\n\n\n1. 定义子程序要解决的问题\n- 子程序将要隐藏的信息\n- 传给子程序的各项输入, 得到的输出\n- 调用子程序前确保相关前条件成立. 输入数据的范围正确 流已经初始化 文件已经打开或关闭\n- 在子程序将控制权交回调用方程序之前, 确保其后条件成立. 多线程问题居多\n\n2. 为子程序命名\n3. 决定如何测试子程序\n4. 在标准库中搜寻可用的功能\n5. 考虑错误处理和效率问题\n\n\n# 第三部分 变量variables\n\n## 第十章 使用变量的一般事项\n\n这本书还教你做人...  分数不可能很高 因为有的概念是杜撰的!!\n(请读第33章 个人性格 诚实一节)\n\n位图\nB-树\n堆\n栈\n文字量\n查找表\n引用完整性\n树\n共用体\n变体\n\n\n- 在声明的时候就进行初始化\n- 在理想的情况下, 在靠近第一次使用变量的位置声明和定义变量\n- 多多使用const 吧\n- 注意计数器和累加器. 这里很久前遇到一个坑 无符号自减可能会下溢\n- 构造函数中进行初始化\n- 检查是否需要重新初始化\n- 检查输入的合法性\n- 初始化指针建议初始化为 0, 一旦你看到为0的指针越界就知道是没有赋值\n\n## 第十一章 变量名的力量\n\n1. 为循环下标 临时变量命名\n2. bool变量\ndone->事情已经完成\nerror->有错误发生\nfound->找到\nsuccess/ok ->某操作已经成功 不是很具体\nIs前缀可以用在模糊不清的词前, 不过这样也会导致最终表达模糊不清\n3. 标识全局变量 使用 `g_` 前缀\n4. 标识类型声明 `T` 前缀\n5. 避免在名字中使用1 2 后缀file_1 file_2\n\n\n## 第十二章 基本数据类型\n\n1. 避免使用神秘数值 突然出现某个数值 这样一方面不便于修改所有值 一方面防止忘记数值含义\n2. 除零 的发生\n3. 防止溢出 这里最常见的就是循环体中了 更尤其是unsigned变量自减的时候\n4. 防范数组越界\n5. C风格字符串的长度声明为 `CONSTANT+1`, CONSTANT是长度. 防止到时候你分不清长度是该+1还是-1还是就是本身\n\n\n`if(chosen_color = 1)`和`if(chose_color = Color_Red)`后者枚举的使用更清楚.\n枚举示例\n```c++\nenum Color\n{\n  COLOR_RED,\n  COLOR_BLUE\n}\n```\n\n单点控制(single-pointcontrol)让程序真正软了起来, 将一个量保存在变量中. 程序中使用变量名替换这个量\n\n## 第十三章 不常见的数据类型\np318\n\n引用必须总是引用一个对象, 而指针则可以指向空值.\n引用所指向的对象在改引用初始化后不能改变\n\n全局变量应该加以说明\n\n全局数据隐藏到类中, 使用static\n\n不应该吧所有数据放在一个大对象中到处传递\n\n不要实用全局变量存放中间结果\n\n# 第四部分语句\n\n\n## 第十四章 组织直线型代码\n\n- 设法组织代码, 使依赖关系变得非常明显\n```c++\ndata = ReadData();\nresult = CalculateResultsFromData(data);\nPrintResult(result);\n```\n这段代码看起来很舒服, 逻辑清理, 命名到位. 明显的表明了函数间的依赖关系\n\n```c++\nrevenue.ComputeMonthly();\nrevenue.ComputeQuarterly();\nrevenue.ComputeAnnual();\n```\n这段代码, 前后依赖关系没有表现出来. 实际上计算季度收入需要先计算月收入 计算年收入需要季度收入\n\n- 使子程序名能凸显依赖关系\n- 使用子程序参数明确显示依赖关系\n\n几个函数连续使用相同的参数, 说明之间极可能存在依赖关系.\n几个函数使用不同的参数, 说明之间极可能不存在依赖关系\n- 对逻辑不清晰的代码 进行注释说明\n- 使用断言或者错误来处理错误的调用顺序\n\n\n## 第十五章 使用条件语句\n\nif 语句\n- 首先写正常的代码路径, 再处理不常见的情况. 使得正确情况的执行路径在代码中是清晰的.\n- 确保对于等量的分支是正确的(最好不要用>替换>= <替换<=) 防止off-by-one偏差一的错误. 这点emm\n- 把正常情况的处理放在if后面 不要放在else后面 (看了眼示例代码, 对于嵌套if非常重要)\n- ~~通用汽车公司做的分析发现 有五到八成的if语句都需要配有else语句~~\n- 确保考虑到所有的情况, 一串if elseif之后应该加上一个else检查其他情况, 防止有未考虑到的情况\n\ncase语句\n- default语句只用来检查真正的默认情况, 而不是用来处理你认为的最后一种情况. 否则\n你将失去case语句的标号(label)所提供的自动说明功能, 也丧失了default子句检错的能力\n- 利用default语句来检错\n- case语句后没有break应该注释说明\n\n## 第十六章 控制循环\n\n- 不要滥用循环下标\n最好不要在循环体外 使用 依赖于循环下标最终取值的代码 可能会因为循环异常退出或者循环结束, 得到的下标并不是你想要的下标. 应该使用合适的变量用来标记在循环中是否遇到了你想要的情况\n- 考虑在while循环中使用break而不是布尔标记\n- 不要使用浮点数作为边界\n- 使用有意义的下标变量名, 防止下标串话.\n- 不要在循环中修改下标值\n\n下面的代码就是下标串话, 本来第二个循环应该使用j. 这种bug可能不是很容易排查出来, i和j乍一看很像.\n```c++\nint  i, j;\nfor (i = 0; i < xxx; ++i)\n{\n  xxxx\n  for (i = 0; j <xxx; ++j)\n  {\n\n  }\n}\n```\n\n\n低效的程序员会随意做一些试验, 直到他们找到了一种看上去能工作的组合. 如果某个循环没有按照想象工作,低效的程序员可能会把`<`改为`<=`. 如果还不行可能把下标`+1`或者`-1`. 这样最终可能碰出正确组合, 也有可能把原来的错误改成了另一个更微妙的错误. 即使这样随意的开发过程能够产生正确的程序, 这些程序员也不明白为什么这个程序是正确的.\n\n## 第十七章 不常见的控制结构\n\n递归前两天正好用过, 如果用的恰当的话 感觉很不错\n\n我也不想去用...... =, =","source":"_posts/读书记录130-代码大全.md","raw":"---\ntitle: 代码大全\ntags:\n  - null\ncategories:\n  - 读书记录\ndate: 2020-05-13 21:19:39\n\ntop: 130\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E5%B0%81%E9%9D%A2.png\n---\n距离上次什么时候写博客已经记不清了, 看了眼GitHub备份记录 已经25天了. 这25天我咕了吗? 咕是不可能咕的. 这段时间我终于做出了第一个UE4比较完善的联机游戏.\n学习了更多的muduo自己的mongo也更加完善. 只看书写博客不写代码可不行.\n\n技术类书籍慢慢开始看了, mongo写的时间不短了.  代码大全听说是神书? 来粗读看看吧\n\n# 第?部分\n## 第六章 可以工作的类\n使用ADT 可以实现隐藏细节, 改动不会影响到整个程序.\n\n这点感受还是有些的. 前两天自己写VPN(目前项目暂停了)的时候, 有个Buffer类, Buffer类的核心是libevent的evbuff, 我直接使用Get方法Get到这个evbuff的指针, 然后在外部进行操作.\n起初这样只是图简单吧, 也想到了这样会写出烂代码. 后面改动核心evbuff的时候, 发现太麻烦了, 最终改成了几个简单的接口 Append Clear等, 对外隐藏了内部是什么缓冲结构\n\n\nhas a  ---- 组合 包含\nis a ---- 集成 epoll(select) is a mutiplexing\n\n\n只有一个实例的类是值得怀疑的, 同样只有一个派生类的基类也是值得怀疑的\n\n拷贝对象优先使用深拷贝\n\n创建类的原因\n- 为现实世界中的对象建模\n- 为抽象的对象建模 形状类是抽象的 不过圆 正方形等都是真实存在的\n- 降低复杂度 一个类创建结束后, 你就可以忘掉其中的细节 使用接口即可\n- 隔离复杂度\n- 隐藏实现细节 限制变动的影响范围 隐藏全局数据\n- 让参数传递更加舒畅 成员变量 \n- 复用代码\n\n\n## 第七章 高质量的子程序\n\n创建子程序的正当理由\n- 降低复杂度\n一个子程序编写完毕后, 应该可以忘记其中的细节\n- 引入中间,易懂的抽象\n避免代码重复  从大块的代码中抽取子程序\n- 隐藏顺序 如果某两行代码有特定的执行顺序, 可以考虑抽取出来. 感觉这里可以推广到Mutex lock后忘记unlock 或者 Buffer中读取数据后 忘记移动指针?\n- 提高可移植性 这点看项目了\n\n\n似乎过于简单没有必要写成子程序, 当然也要看情况了\n- 这里我感觉最深的还是 两行或者三行经常调用的程序, 如果重复写多次 最终告知你需要修改的时候 那可真是灾难性的消息. 实例的话: 增加参数校验等等\n\n\n准确的使用对仗词\n\n|        |          |\n| ------ | -------- |\n| add    | remove   |\n| begin  | end      |\n| create | destory  |\n| next   | previous |\n| start  | stop     |\n\n\n如何使用子程序参数\n- 按照输入-修改-输出的顺序排列参数\n- 如果几个子程序都是用了类似的一些参数, 应该让这些参数的排列顺序一致\n- 使用所有的参数, 删去未使用到的参数\n- 不要把子程序的参数用做工作变量\n\n设置函数的返回值\n- 检查所有可能的返回路径, 在函数开头设置默认返回 一个不错的选择(muduo中见到了)\n- 老生常谈的不要返回局部对象的引用或者指针\n\n\n少使用宏吧 inline和typedef 不香吗, 不是肉包子也是好吃的素包子了\n\n## 第八章 防御式编程\n~~防御式编程并不是说让你在编程时保持 \"防备批评或攻击\" 的态度~~\n\n子程序不应该因为传入错误数据而被破坏\n- 检查所有源自外部数据的值\n- 检查子程序所有输入参数的值\n- 决定如何处理错误的输入数据\n\n使用错误处理代码来处理与其发生的状况, 使用断言来处理绝不应该发生的状况\n\n\n错误处理技术 其他感觉... 用不到吧 现在不记录了\n- 返回中立值 最简单的方法, 继续执行操作并简单的返回一个没有危害的数值. 数值计算-返回0 字符串返回空串 指针返回空指针\n- 日志打印\n- 关闭程序\n\n\n隔离程序\n两块相对独立的代码块 在交互函数见进行参数校验 过滤掉一个模块传来的非法参数\n\n辅助调试的代码.....\n我现在就遇到一个bug 还不知道怎么修改 与多线程有关的问题 排查真难-2020年5月18日13:11:43\n2020年6月18日23:50:44 排查掉了 今天看到了这段话 补充上吧\n\n决定产品最终发布的时候应该保留多少防御内容\n防御内容越多消耗的性能越多\n\n## 第九章 伪代码的编程过程\n\n原则\n- 用类似英语的句子来准确描述特定的操作\n- 便面使用目标编程语言中的特定语法元素\n- 在本意的层面上编写伪代码. 用伪代码描述解决问题的方法意图, 而不是去写如何用目标语言实现这个方法\n- 在一个足够低的层次上编写伪代码, 以便近乎自动的生成代码, 如果层次过高则会隐藏细节问题\n\n\n1. 定义子程序要解决的问题\n- 子程序将要隐藏的信息\n- 传给子程序的各项输入, 得到的输出\n- 调用子程序前确保相关前条件成立. 输入数据的范围正确 流已经初始化 文件已经打开或关闭\n- 在子程序将控制权交回调用方程序之前, 确保其后条件成立. 多线程问题居多\n\n2. 为子程序命名\n3. 决定如何测试子程序\n4. 在标准库中搜寻可用的功能\n5. 考虑错误处理和效率问题\n\n\n# 第三部分 变量variables\n\n## 第十章 使用变量的一般事项\n\n这本书还教你做人...  分数不可能很高 因为有的概念是杜撰的!!\n(请读第33章 个人性格 诚实一节)\n\n位图\nB-树\n堆\n栈\n文字量\n查找表\n引用完整性\n树\n共用体\n变体\n\n\n- 在声明的时候就进行初始化\n- 在理想的情况下, 在靠近第一次使用变量的位置声明和定义变量\n- 多多使用const 吧\n- 注意计数器和累加器. 这里很久前遇到一个坑 无符号自减可能会下溢\n- 构造函数中进行初始化\n- 检查是否需要重新初始化\n- 检查输入的合法性\n- 初始化指针建议初始化为 0, 一旦你看到为0的指针越界就知道是没有赋值\n\n## 第十一章 变量名的力量\n\n1. 为循环下标 临时变量命名\n2. bool变量\ndone->事情已经完成\nerror->有错误发生\nfound->找到\nsuccess/ok ->某操作已经成功 不是很具体\nIs前缀可以用在模糊不清的词前, 不过这样也会导致最终表达模糊不清\n3. 标识全局变量 使用 `g_` 前缀\n4. 标识类型声明 `T` 前缀\n5. 避免在名字中使用1 2 后缀file_1 file_2\n\n\n## 第十二章 基本数据类型\n\n1. 避免使用神秘数值 突然出现某个数值 这样一方面不便于修改所有值 一方面防止忘记数值含义\n2. 除零 的发生\n3. 防止溢出 这里最常见的就是循环体中了 更尤其是unsigned变量自减的时候\n4. 防范数组越界\n5. C风格字符串的长度声明为 `CONSTANT+1`, CONSTANT是长度. 防止到时候你分不清长度是该+1还是-1还是就是本身\n\n\n`if(chosen_color = 1)`和`if(chose_color = Color_Red)`后者枚举的使用更清楚.\n枚举示例\n```c++\nenum Color\n{\n  COLOR_RED,\n  COLOR_BLUE\n}\n```\n\n单点控制(single-pointcontrol)让程序真正软了起来, 将一个量保存在变量中. 程序中使用变量名替换这个量\n\n## 第十三章 不常见的数据类型\np318\n\n引用必须总是引用一个对象, 而指针则可以指向空值.\n引用所指向的对象在改引用初始化后不能改变\n\n全局变量应该加以说明\n\n全局数据隐藏到类中, 使用static\n\n不应该吧所有数据放在一个大对象中到处传递\n\n不要实用全局变量存放中间结果\n\n# 第四部分语句\n\n\n## 第十四章 组织直线型代码\n\n- 设法组织代码, 使依赖关系变得非常明显\n```c++\ndata = ReadData();\nresult = CalculateResultsFromData(data);\nPrintResult(result);\n```\n这段代码看起来很舒服, 逻辑清理, 命名到位. 明显的表明了函数间的依赖关系\n\n```c++\nrevenue.ComputeMonthly();\nrevenue.ComputeQuarterly();\nrevenue.ComputeAnnual();\n```\n这段代码, 前后依赖关系没有表现出来. 实际上计算季度收入需要先计算月收入 计算年收入需要季度收入\n\n- 使子程序名能凸显依赖关系\n- 使用子程序参数明确显示依赖关系\n\n几个函数连续使用相同的参数, 说明之间极可能存在依赖关系.\n几个函数使用不同的参数, 说明之间极可能不存在依赖关系\n- 对逻辑不清晰的代码 进行注释说明\n- 使用断言或者错误来处理错误的调用顺序\n\n\n## 第十五章 使用条件语句\n\nif 语句\n- 首先写正常的代码路径, 再处理不常见的情况. 使得正确情况的执行路径在代码中是清晰的.\n- 确保对于等量的分支是正确的(最好不要用>替换>= <替换<=) 防止off-by-one偏差一的错误. 这点emm\n- 把正常情况的处理放在if后面 不要放在else后面 (看了眼示例代码, 对于嵌套if非常重要)\n- ~~通用汽车公司做的分析发现 有五到八成的if语句都需要配有else语句~~\n- 确保考虑到所有的情况, 一串if elseif之后应该加上一个else检查其他情况, 防止有未考虑到的情况\n\ncase语句\n- default语句只用来检查真正的默认情况, 而不是用来处理你认为的最后一种情况. 否则\n你将失去case语句的标号(label)所提供的自动说明功能, 也丧失了default子句检错的能力\n- 利用default语句来检错\n- case语句后没有break应该注释说明\n\n## 第十六章 控制循环\n\n- 不要滥用循环下标\n最好不要在循环体外 使用 依赖于循环下标最终取值的代码 可能会因为循环异常退出或者循环结束, 得到的下标并不是你想要的下标. 应该使用合适的变量用来标记在循环中是否遇到了你想要的情况\n- 考虑在while循环中使用break而不是布尔标记\n- 不要使用浮点数作为边界\n- 使用有意义的下标变量名, 防止下标串话.\n- 不要在循环中修改下标值\n\n下面的代码就是下标串话, 本来第二个循环应该使用j. 这种bug可能不是很容易排查出来, i和j乍一看很像.\n```c++\nint  i, j;\nfor (i = 0; i < xxx; ++i)\n{\n  xxxx\n  for (i = 0; j <xxx; ++j)\n  {\n\n  }\n}\n```\n\n\n低效的程序员会随意做一些试验, 直到他们找到了一种看上去能工作的组合. 如果某个循环没有按照想象工作,低效的程序员可能会把`<`改为`<=`. 如果还不行可能把下标`+1`或者`-1`. 这样最终可能碰出正确组合, 也有可能把原来的错误改成了另一个更微妙的错误. 即使这样随意的开发过程能够产生正确的程序, 这些程序员也不明白为什么这个程序是正确的.\n\n## 第十七章 不常见的控制结构\n\n递归前两天正好用过, 如果用的恰当的话 感觉很不错\n\n我也不想去用...... =, =","slug":"读书记录130-代码大全","published":1,"updated":"2020-12-05T02:30:39.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg77003qf8un7cfa7p8r","content":"<p>距离上次什么时候写博客已经记不清了, 看了眼GitHub备份记录 已经25天了. 这25天我咕了吗? 咕是不可能咕的. 这段时间我终于做出了第一个UE4比较完善的联机游戏.<br>学习了更多的muduo自己的mongo也更加完善. 只看书写博客不写代码可不行.</p>\n<p>技术类书籍慢慢开始看了, mongo写的时间不短了.  代码大全听说是神书? 来粗读看看吧</p>\n<h1 id=\"第-部分\"><a href=\"#第-部分\" class=\"headerlink\" title=\"第?部分\"></a>第?部分</h1><h2 id=\"第六章-可以工作的类\"><a href=\"#第六章-可以工作的类\" class=\"headerlink\" title=\"第六章 可以工作的类\"></a>第六章 可以工作的类</h2><p>使用ADT 可以实现隐藏细节, 改动不会影响到整个程序.</p>\n<p>这点感受还是有些的. 前两天自己写VPN(目前项目暂停了)的时候, 有个Buffer类, Buffer类的核心是libevent的evbuff, 我直接使用Get方法Get到这个evbuff的指针, 然后在外部进行操作.<br>起初这样只是图简单吧, 也想到了这样会写出烂代码. 后面改动核心evbuff的时候, 发现太麻烦了, 最终改成了几个简单的接口 Append Clear等, 对外隐藏了内部是什么缓冲结构</p>\n<p>has a  —- 组合 包含<br>is a —- 集成 epoll(select) is a mutiplexing</p>\n<p>只有一个实例的类是值得怀疑的, 同样只有一个派生类的基类也是值得怀疑的</p>\n<p>拷贝对象优先使用深拷贝</p>\n<p>创建类的原因</p>\n<ul>\n<li>为现实世界中的对象建模</li>\n<li>为抽象的对象建模 形状类是抽象的 不过圆 正方形等都是真实存在的</li>\n<li>降低复杂度 一个类创建结束后, 你就可以忘掉其中的细节 使用接口即可</li>\n<li>隔离复杂度</li>\n<li>隐藏实现细节 限制变动的影响范围 隐藏全局数据</li>\n<li>让参数传递更加舒畅 成员变量 </li>\n<li>复用代码</li>\n</ul>\n<h2 id=\"第七章-高质量的子程序\"><a href=\"#第七章-高质量的子程序\" class=\"headerlink\" title=\"第七章 高质量的子程序\"></a>第七章 高质量的子程序</h2><p>创建子程序的正当理由</p>\n<ul>\n<li>降低复杂度<br>一个子程序编写完毕后, 应该可以忘记其中的细节</li>\n<li>引入中间,易懂的抽象<br>避免代码重复  从大块的代码中抽取子程序</li>\n<li>隐藏顺序 如果某两行代码有特定的执行顺序, 可以考虑抽取出来. 感觉这里可以推广到Mutex lock后忘记unlock 或者 Buffer中读取数据后 忘记移动指针?</li>\n<li>提高可移植性 这点看项目了</li>\n</ul>\n<p>似乎过于简单没有必要写成子程序, 当然也要看情况了</p>\n<ul>\n<li>这里我感觉最深的还是 两行或者三行经常调用的程序, 如果重复写多次 最终告知你需要修改的时候 那可真是灾难性的消息. 实例的话: 增加参数校验等等</li>\n</ul>\n<p>准确的使用对仗词</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>add</td>\n<td>remove</td>\n</tr>\n<tr>\n<td>begin</td>\n<td>end</td>\n</tr>\n<tr>\n<td>create</td>\n<td>destory</td>\n</tr>\n<tr>\n<td>next</td>\n<td>previous</td>\n</tr>\n<tr>\n<td>start</td>\n<td>stop</td>\n</tr>\n</tbody></table>\n<p>如何使用子程序参数</p>\n<ul>\n<li>按照输入-修改-输出的顺序排列参数</li>\n<li>如果几个子程序都是用了类似的一些参数, 应该让这些参数的排列顺序一致</li>\n<li>使用所有的参数, 删去未使用到的参数</li>\n<li>不要把子程序的参数用做工作变量</li>\n</ul>\n<p>设置函数的返回值</p>\n<ul>\n<li>检查所有可能的返回路径, 在函数开头设置默认返回 一个不错的选择(muduo中见到了)</li>\n<li>老生常谈的不要返回局部对象的引用或者指针</li>\n</ul>\n<p>少使用宏吧 inline和typedef 不香吗, 不是肉包子也是好吃的素包子了</p>\n<h2 id=\"第八章-防御式编程\"><a href=\"#第八章-防御式编程\" class=\"headerlink\" title=\"第八章 防御式编程\"></a>第八章 防御式编程</h2><p><del>防御式编程并不是说让你在编程时保持 “防备批评或攻击” 的态度</del></p>\n<p>子程序不应该因为传入错误数据而被破坏</p>\n<ul>\n<li>检查所有源自外部数据的值</li>\n<li>检查子程序所有输入参数的值</li>\n<li>决定如何处理错误的输入数据</li>\n</ul>\n<p>使用错误处理代码来处理与其发生的状况, 使用断言来处理绝不应该发生的状况</p>\n<p>错误处理技术 其他感觉… 用不到吧 现在不记录了</p>\n<ul>\n<li>返回中立值 最简单的方法, 继续执行操作并简单的返回一个没有危害的数值. 数值计算-返回0 字符串返回空串 指针返回空指针</li>\n<li>日志打印</li>\n<li>关闭程序</li>\n</ul>\n<p>隔离程序<br>两块相对独立的代码块 在交互函数见进行参数校验 过滤掉一个模块传来的非法参数</p>\n<p>辅助调试的代码…..<br>我现在就遇到一个bug 还不知道怎么修改 与多线程有关的问题 排查真难-2020年5月18日13:11:43<br>2020年6月18日23:50:44 排查掉了 今天看到了这段话 补充上吧</p>\n<p>决定产品最终发布的时候应该保留多少防御内容<br>防御内容越多消耗的性能越多</p>\n<h2 id=\"第九章-伪代码的编程过程\"><a href=\"#第九章-伪代码的编程过程\" class=\"headerlink\" title=\"第九章 伪代码的编程过程\"></a>第九章 伪代码的编程过程</h2><p>原则</p>\n<ul>\n<li>用类似英语的句子来准确描述特定的操作</li>\n<li>便面使用目标编程语言中的特定语法元素</li>\n<li>在本意的层面上编写伪代码. 用伪代码描述解决问题的方法意图, 而不是去写如何用目标语言实现这个方法</li>\n<li>在一个足够低的层次上编写伪代码, 以便近乎自动的生成代码, 如果层次过高则会隐藏细节问题</li>\n</ul>\n<ol>\n<li>定义子程序要解决的问题</li>\n</ol>\n<ul>\n<li>子程序将要隐藏的信息</li>\n<li>传给子程序的各项输入, 得到的输出</li>\n<li>调用子程序前确保相关前条件成立. 输入数据的范围正确 流已经初始化 文件已经打开或关闭</li>\n<li>在子程序将控制权交回调用方程序之前, 确保其后条件成立. 多线程问题居多</li>\n</ul>\n<ol start=\"2\">\n<li>为子程序命名</li>\n<li>决定如何测试子程序</li>\n<li>在标准库中搜寻可用的功能</li>\n<li>考虑错误处理和效率问题</li>\n</ol>\n<h1 id=\"第三部分-变量variables\"><a href=\"#第三部分-变量variables\" class=\"headerlink\" title=\"第三部分 变量variables\"></a>第三部分 变量variables</h1><h2 id=\"第十章-使用变量的一般事项\"><a href=\"#第十章-使用变量的一般事项\" class=\"headerlink\" title=\"第十章 使用变量的一般事项\"></a>第十章 使用变量的一般事项</h2><p>这本书还教你做人…  分数不可能很高 因为有的概念是杜撰的!!<br>(请读第33章 个人性格 诚实一节)</p>\n<p>位图<br>B-树<br>堆<br>栈<br>文字量<br>查找表<br>引用完整性<br>树<br>共用体<br>变体</p>\n<ul>\n<li>在声明的时候就进行初始化</li>\n<li>在理想的情况下, 在靠近第一次使用变量的位置声明和定义变量</li>\n<li>多多使用const 吧</li>\n<li>注意计数器和累加器. 这里很久前遇到一个坑 无符号自减可能会下溢</li>\n<li>构造函数中进行初始化</li>\n<li>检查是否需要重新初始化</li>\n<li>检查输入的合法性</li>\n<li>初始化指针建议初始化为 0, 一旦你看到为0的指针越界就知道是没有赋值</li>\n</ul>\n<h2 id=\"第十一章-变量名的力量\"><a href=\"#第十一章-变量名的力量\" class=\"headerlink\" title=\"第十一章 变量名的力量\"></a>第十一章 变量名的力量</h2><ol>\n<li>为循环下标 临时变量命名</li>\n<li>bool变量<br>done-&gt;事情已经完成<br>error-&gt;有错误发生<br>found-&gt;找到<br>success/ok -&gt;某操作已经成功 不是很具体<br>Is前缀可以用在模糊不清的词前, 不过这样也会导致最终表达模糊不清</li>\n<li>标识全局变量 使用 <code>g_</code> 前缀</li>\n<li>标识类型声明 <code>T</code> 前缀</li>\n<li>避免在名字中使用1 2 后缀file_1 file_2</li>\n</ol>\n<h2 id=\"第十二章-基本数据类型\"><a href=\"#第十二章-基本数据类型\" class=\"headerlink\" title=\"第十二章 基本数据类型\"></a>第十二章 基本数据类型</h2><ol>\n<li>避免使用神秘数值 突然出现某个数值 这样一方面不便于修改所有值 一方面防止忘记数值含义</li>\n<li>除零 的发生</li>\n<li>防止溢出 这里最常见的就是循环体中了 更尤其是unsigned变量自减的时候</li>\n<li>防范数组越界</li>\n<li>C风格字符串的长度声明为 <code>CONSTANT+1</code>, CONSTANT是长度. 防止到时候你分不清长度是该+1还是-1还是就是本身</li>\n</ol>\n<p><code>if(chosen_color = 1)</code>和<code>if(chose_color = Color_Red)</code>后者枚举的使用更清楚.<br>枚举示例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  COLOR_RED,</span><br><span class=\"line\">  COLOR_BLUE</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单点控制(single-pointcontrol)让程序真正软了起来, 将一个量保存在变量中. 程序中使用变量名替换这个量</p>\n<h2 id=\"第十三章-不常见的数据类型\"><a href=\"#第十三章-不常见的数据类型\" class=\"headerlink\" title=\"第十三章 不常见的数据类型\"></a>第十三章 不常见的数据类型</h2><p>p318</p>\n<p>引用必须总是引用一个对象, 而指针则可以指向空值.<br>引用所指向的对象在改引用初始化后不能改变</p>\n<p>全局变量应该加以说明</p>\n<p>全局数据隐藏到类中, 使用static</p>\n<p>不应该吧所有数据放在一个大对象中到处传递</p>\n<p>不要实用全局变量存放中间结果</p>\n<h1 id=\"第四部分语句\"><a href=\"#第四部分语句\" class=\"headerlink\" title=\"第四部分语句\"></a>第四部分语句</h1><h2 id=\"第十四章-组织直线型代码\"><a href=\"#第十四章-组织直线型代码\" class=\"headerlink\" title=\"第十四章 组织直线型代码\"></a>第十四章 组织直线型代码</h2><ul>\n<li>设法组织代码, 使依赖关系变得非常明显<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = ReadData();</span><br><span class=\"line\">result = CalculateResultsFromData(data);</span><br><span class=\"line\">PrintResult(result);</span><br></pre></td></tr></table></figure>\n这段代码看起来很舒服, 逻辑清理, 命名到位. 明显的表明了函数间的依赖关系</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">revenue.ComputeMonthly();</span><br><span class=\"line\">revenue.ComputeQuarterly();</span><br><span class=\"line\">revenue.ComputeAnnual();</span><br></pre></td></tr></table></figure>\n<p>这段代码, 前后依赖关系没有表现出来. 实际上计算季度收入需要先计算月收入 计算年收入需要季度收入</p>\n<ul>\n<li>使子程序名能凸显依赖关系</li>\n<li>使用子程序参数明确显示依赖关系</li>\n</ul>\n<p>几个函数连续使用相同的参数, 说明之间极可能存在依赖关系.<br>几个函数使用不同的参数, 说明之间极可能不存在依赖关系</p>\n<ul>\n<li>对逻辑不清晰的代码 进行注释说明</li>\n<li>使用断言或者错误来处理错误的调用顺序</li>\n</ul>\n<h2 id=\"第十五章-使用条件语句\"><a href=\"#第十五章-使用条件语句\" class=\"headerlink\" title=\"第十五章 使用条件语句\"></a>第十五章 使用条件语句</h2><p>if 语句</p>\n<ul>\n<li>首先写正常的代码路径, 再处理不常见的情况. 使得正确情况的执行路径在代码中是清晰的.</li>\n<li>确保对于等量的分支是正确的(最好不要用&gt;替换&gt;= &lt;替换&lt;=) 防止off-by-one偏差一的错误. 这点emm</li>\n<li>把正常情况的处理放在if后面 不要放在else后面 (看了眼示例代码, 对于嵌套if非常重要)</li>\n<li><del>通用汽车公司做的分析发现 有五到八成的if语句都需要配有else语句</del></li>\n<li>确保考虑到所有的情况, 一串if elseif之后应该加上一个else检查其他情况, 防止有未考虑到的情况</li>\n</ul>\n<p>case语句</p>\n<ul>\n<li>default语句只用来检查真正的默认情况, 而不是用来处理你认为的最后一种情况. 否则<br>你将失去case语句的标号(label)所提供的自动说明功能, 也丧失了default子句检错的能力</li>\n<li>利用default语句来检错</li>\n<li>case语句后没有break应该注释说明</li>\n</ul>\n<h2 id=\"第十六章-控制循环\"><a href=\"#第十六章-控制循环\" class=\"headerlink\" title=\"第十六章 控制循环\"></a>第十六章 控制循环</h2><ul>\n<li>不要滥用循环下标<br>最好不要在循环体外 使用 依赖于循环下标最终取值的代码 可能会因为循环异常退出或者循环结束, 得到的下标并不是你想要的下标. 应该使用合适的变量用来标记在循环中是否遇到了你想要的情况</li>\n<li>考虑在while循环中使用break而不是布尔标记</li>\n<li>不要使用浮点数作为边界</li>\n<li>使用有意义的下标变量名, 防止下标串话.</li>\n<li>不要在循环中修改下标值</li>\n</ul>\n<p>下面的代码就是下标串话, 本来第二个循环应该使用j. 这种bug可能不是很容易排查出来, i和j乍一看很像.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>  i, j;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; xxx; ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  xxxx</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; j &lt;xxx; ++j)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>低效的程序员会随意做一些试验, 直到他们找到了一种看上去能工作的组合. 如果某个循环没有按照想象工作,低效的程序员可能会把<code>&lt;</code>改为<code>&lt;=</code>. 如果还不行可能把下标<code>+1</code>或者<code>-1</code>. 这样最终可能碰出正确组合, 也有可能把原来的错误改成了另一个更微妙的错误. 即使这样随意的开发过程能够产生正确的程序, 这些程序员也不明白为什么这个程序是正确的.</p>\n<h2 id=\"第十七章-不常见的控制结构\"><a href=\"#第十七章-不常见的控制结构\" class=\"headerlink\" title=\"第十七章 不常见的控制结构\"></a>第十七章 不常见的控制结构</h2><p>递归前两天正好用过, 如果用的恰当的话 感觉很不错</p>\n<p>我也不想去用…… =, =</p>\n","site":{"data":{}},"excerpt":"","more":"<p>距离上次什么时候写博客已经记不清了, 看了眼GitHub备份记录 已经25天了. 这25天我咕了吗? 咕是不可能咕的. 这段时间我终于做出了第一个UE4比较完善的联机游戏.<br>学习了更多的muduo自己的mongo也更加完善. 只看书写博客不写代码可不行.</p>\n<p>技术类书籍慢慢开始看了, mongo写的时间不短了.  代码大全听说是神书? 来粗读看看吧</p>\n<h1 id=\"第-部分\"><a href=\"#第-部分\" class=\"headerlink\" title=\"第?部分\"></a>第?部分</h1><h2 id=\"第六章-可以工作的类\"><a href=\"#第六章-可以工作的类\" class=\"headerlink\" title=\"第六章 可以工作的类\"></a>第六章 可以工作的类</h2><p>使用ADT 可以实现隐藏细节, 改动不会影响到整个程序.</p>\n<p>这点感受还是有些的. 前两天自己写VPN(目前项目暂停了)的时候, 有个Buffer类, Buffer类的核心是libevent的evbuff, 我直接使用Get方法Get到这个evbuff的指针, 然后在外部进行操作.<br>起初这样只是图简单吧, 也想到了这样会写出烂代码. 后面改动核心evbuff的时候, 发现太麻烦了, 最终改成了几个简单的接口 Append Clear等, 对外隐藏了内部是什么缓冲结构</p>\n<p>has a  —- 组合 包含<br>is a —- 集成 epoll(select) is a mutiplexing</p>\n<p>只有一个实例的类是值得怀疑的, 同样只有一个派生类的基类也是值得怀疑的</p>\n<p>拷贝对象优先使用深拷贝</p>\n<p>创建类的原因</p>\n<ul>\n<li>为现实世界中的对象建模</li>\n<li>为抽象的对象建模 形状类是抽象的 不过圆 正方形等都是真实存在的</li>\n<li>降低复杂度 一个类创建结束后, 你就可以忘掉其中的细节 使用接口即可</li>\n<li>隔离复杂度</li>\n<li>隐藏实现细节 限制变动的影响范围 隐藏全局数据</li>\n<li>让参数传递更加舒畅 成员变量 </li>\n<li>复用代码</li>\n</ul>\n<h2 id=\"第七章-高质量的子程序\"><a href=\"#第七章-高质量的子程序\" class=\"headerlink\" title=\"第七章 高质量的子程序\"></a>第七章 高质量的子程序</h2><p>创建子程序的正当理由</p>\n<ul>\n<li>降低复杂度<br>一个子程序编写完毕后, 应该可以忘记其中的细节</li>\n<li>引入中间,易懂的抽象<br>避免代码重复  从大块的代码中抽取子程序</li>\n<li>隐藏顺序 如果某两行代码有特定的执行顺序, 可以考虑抽取出来. 感觉这里可以推广到Mutex lock后忘记unlock 或者 Buffer中读取数据后 忘记移动指针?</li>\n<li>提高可移植性 这点看项目了</li>\n</ul>\n<p>似乎过于简单没有必要写成子程序, 当然也要看情况了</p>\n<ul>\n<li>这里我感觉最深的还是 两行或者三行经常调用的程序, 如果重复写多次 最终告知你需要修改的时候 那可真是灾难性的消息. 实例的话: 增加参数校验等等</li>\n</ul>\n<p>准确的使用对仗词</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>add</td>\n<td>remove</td>\n</tr>\n<tr>\n<td>begin</td>\n<td>end</td>\n</tr>\n<tr>\n<td>create</td>\n<td>destory</td>\n</tr>\n<tr>\n<td>next</td>\n<td>previous</td>\n</tr>\n<tr>\n<td>start</td>\n<td>stop</td>\n</tr>\n</tbody></table>\n<p>如何使用子程序参数</p>\n<ul>\n<li>按照输入-修改-输出的顺序排列参数</li>\n<li>如果几个子程序都是用了类似的一些参数, 应该让这些参数的排列顺序一致</li>\n<li>使用所有的参数, 删去未使用到的参数</li>\n<li>不要把子程序的参数用做工作变量</li>\n</ul>\n<p>设置函数的返回值</p>\n<ul>\n<li>检查所有可能的返回路径, 在函数开头设置默认返回 一个不错的选择(muduo中见到了)</li>\n<li>老生常谈的不要返回局部对象的引用或者指针</li>\n</ul>\n<p>少使用宏吧 inline和typedef 不香吗, 不是肉包子也是好吃的素包子了</p>\n<h2 id=\"第八章-防御式编程\"><a href=\"#第八章-防御式编程\" class=\"headerlink\" title=\"第八章 防御式编程\"></a>第八章 防御式编程</h2><p><del>防御式编程并不是说让你在编程时保持 “防备批评或攻击” 的态度</del></p>\n<p>子程序不应该因为传入错误数据而被破坏</p>\n<ul>\n<li>检查所有源自外部数据的值</li>\n<li>检查子程序所有输入参数的值</li>\n<li>决定如何处理错误的输入数据</li>\n</ul>\n<p>使用错误处理代码来处理与其发生的状况, 使用断言来处理绝不应该发生的状况</p>\n<p>错误处理技术 其他感觉… 用不到吧 现在不记录了</p>\n<ul>\n<li>返回中立值 最简单的方法, 继续执行操作并简单的返回一个没有危害的数值. 数值计算-返回0 字符串返回空串 指针返回空指针</li>\n<li>日志打印</li>\n<li>关闭程序</li>\n</ul>\n<p>隔离程序<br>两块相对独立的代码块 在交互函数见进行参数校验 过滤掉一个模块传来的非法参数</p>\n<p>辅助调试的代码…..<br>我现在就遇到一个bug 还不知道怎么修改 与多线程有关的问题 排查真难-2020年5月18日13:11:43<br>2020年6月18日23:50:44 排查掉了 今天看到了这段话 补充上吧</p>\n<p>决定产品最终发布的时候应该保留多少防御内容<br>防御内容越多消耗的性能越多</p>\n<h2 id=\"第九章-伪代码的编程过程\"><a href=\"#第九章-伪代码的编程过程\" class=\"headerlink\" title=\"第九章 伪代码的编程过程\"></a>第九章 伪代码的编程过程</h2><p>原则</p>\n<ul>\n<li>用类似英语的句子来准确描述特定的操作</li>\n<li>便面使用目标编程语言中的特定语法元素</li>\n<li>在本意的层面上编写伪代码. 用伪代码描述解决问题的方法意图, 而不是去写如何用目标语言实现这个方法</li>\n<li>在一个足够低的层次上编写伪代码, 以便近乎自动的生成代码, 如果层次过高则会隐藏细节问题</li>\n</ul>\n<ol>\n<li>定义子程序要解决的问题</li>\n</ol>\n<ul>\n<li>子程序将要隐藏的信息</li>\n<li>传给子程序的各项输入, 得到的输出</li>\n<li>调用子程序前确保相关前条件成立. 输入数据的范围正确 流已经初始化 文件已经打开或关闭</li>\n<li>在子程序将控制权交回调用方程序之前, 确保其后条件成立. 多线程问题居多</li>\n</ul>\n<ol start=\"2\">\n<li>为子程序命名</li>\n<li>决定如何测试子程序</li>\n<li>在标准库中搜寻可用的功能</li>\n<li>考虑错误处理和效率问题</li>\n</ol>\n<h1 id=\"第三部分-变量variables\"><a href=\"#第三部分-变量variables\" class=\"headerlink\" title=\"第三部分 变量variables\"></a>第三部分 变量variables</h1><h2 id=\"第十章-使用变量的一般事项\"><a href=\"#第十章-使用变量的一般事项\" class=\"headerlink\" title=\"第十章 使用变量的一般事项\"></a>第十章 使用变量的一般事项</h2><p>这本书还教你做人…  分数不可能很高 因为有的概念是杜撰的!!<br>(请读第33章 个人性格 诚实一节)</p>\n<p>位图<br>B-树<br>堆<br>栈<br>文字量<br>查找表<br>引用完整性<br>树<br>共用体<br>变体</p>\n<ul>\n<li>在声明的时候就进行初始化</li>\n<li>在理想的情况下, 在靠近第一次使用变量的位置声明和定义变量</li>\n<li>多多使用const 吧</li>\n<li>注意计数器和累加器. 这里很久前遇到一个坑 无符号自减可能会下溢</li>\n<li>构造函数中进行初始化</li>\n<li>检查是否需要重新初始化</li>\n<li>检查输入的合法性</li>\n<li>初始化指针建议初始化为 0, 一旦你看到为0的指针越界就知道是没有赋值</li>\n</ul>\n<h2 id=\"第十一章-变量名的力量\"><a href=\"#第十一章-变量名的力量\" class=\"headerlink\" title=\"第十一章 变量名的力量\"></a>第十一章 变量名的力量</h2><ol>\n<li>为循环下标 临时变量命名</li>\n<li>bool变量<br>done-&gt;事情已经完成<br>error-&gt;有错误发生<br>found-&gt;找到<br>success/ok -&gt;某操作已经成功 不是很具体<br>Is前缀可以用在模糊不清的词前, 不过这样也会导致最终表达模糊不清</li>\n<li>标识全局变量 使用 <code>g_</code> 前缀</li>\n<li>标识类型声明 <code>T</code> 前缀</li>\n<li>避免在名字中使用1 2 后缀file_1 file_2</li>\n</ol>\n<h2 id=\"第十二章-基本数据类型\"><a href=\"#第十二章-基本数据类型\" class=\"headerlink\" title=\"第十二章 基本数据类型\"></a>第十二章 基本数据类型</h2><ol>\n<li>避免使用神秘数值 突然出现某个数值 这样一方面不便于修改所有值 一方面防止忘记数值含义</li>\n<li>除零 的发生</li>\n<li>防止溢出 这里最常见的就是循环体中了 更尤其是unsigned变量自减的时候</li>\n<li>防范数组越界</li>\n<li>C风格字符串的长度声明为 <code>CONSTANT+1</code>, CONSTANT是长度. 防止到时候你分不清长度是该+1还是-1还是就是本身</li>\n</ol>\n<p><code>if(chosen_color = 1)</code>和<code>if(chose_color = Color_Red)</code>后者枚举的使用更清楚.<br>枚举示例</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Color</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  COLOR_RED,</span><br><span class=\"line\">  COLOR_BLUE</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单点控制(single-pointcontrol)让程序真正软了起来, 将一个量保存在变量中. 程序中使用变量名替换这个量</p>\n<h2 id=\"第十三章-不常见的数据类型\"><a href=\"#第十三章-不常见的数据类型\" class=\"headerlink\" title=\"第十三章 不常见的数据类型\"></a>第十三章 不常见的数据类型</h2><p>p318</p>\n<p>引用必须总是引用一个对象, 而指针则可以指向空值.<br>引用所指向的对象在改引用初始化后不能改变</p>\n<p>全局变量应该加以说明</p>\n<p>全局数据隐藏到类中, 使用static</p>\n<p>不应该吧所有数据放在一个大对象中到处传递</p>\n<p>不要实用全局变量存放中间结果</p>\n<h1 id=\"第四部分语句\"><a href=\"#第四部分语句\" class=\"headerlink\" title=\"第四部分语句\"></a>第四部分语句</h1><h2 id=\"第十四章-组织直线型代码\"><a href=\"#第十四章-组织直线型代码\" class=\"headerlink\" title=\"第十四章 组织直线型代码\"></a>第十四章 组织直线型代码</h2><ul>\n<li>设法组织代码, 使依赖关系变得非常明显<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = ReadData();</span><br><span class=\"line\">result = CalculateResultsFromData(data);</span><br><span class=\"line\">PrintResult(result);</span><br></pre></td></tr></table></figure>\n这段代码看起来很舒服, 逻辑清理, 命名到位. 明显的表明了函数间的依赖关系</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">revenue.ComputeMonthly();</span><br><span class=\"line\">revenue.ComputeQuarterly();</span><br><span class=\"line\">revenue.ComputeAnnual();</span><br></pre></td></tr></table></figure>\n<p>这段代码, 前后依赖关系没有表现出来. 实际上计算季度收入需要先计算月收入 计算年收入需要季度收入</p>\n<ul>\n<li>使子程序名能凸显依赖关系</li>\n<li>使用子程序参数明确显示依赖关系</li>\n</ul>\n<p>几个函数连续使用相同的参数, 说明之间极可能存在依赖关系.<br>几个函数使用不同的参数, 说明之间极可能不存在依赖关系</p>\n<ul>\n<li>对逻辑不清晰的代码 进行注释说明</li>\n<li>使用断言或者错误来处理错误的调用顺序</li>\n</ul>\n<h2 id=\"第十五章-使用条件语句\"><a href=\"#第十五章-使用条件语句\" class=\"headerlink\" title=\"第十五章 使用条件语句\"></a>第十五章 使用条件语句</h2><p>if 语句</p>\n<ul>\n<li>首先写正常的代码路径, 再处理不常见的情况. 使得正确情况的执行路径在代码中是清晰的.</li>\n<li>确保对于等量的分支是正确的(最好不要用&gt;替换&gt;= &lt;替换&lt;=) 防止off-by-one偏差一的错误. 这点emm</li>\n<li>把正常情况的处理放在if后面 不要放在else后面 (看了眼示例代码, 对于嵌套if非常重要)</li>\n<li><del>通用汽车公司做的分析发现 有五到八成的if语句都需要配有else语句</del></li>\n<li>确保考虑到所有的情况, 一串if elseif之后应该加上一个else检查其他情况, 防止有未考虑到的情况</li>\n</ul>\n<p>case语句</p>\n<ul>\n<li>default语句只用来检查真正的默认情况, 而不是用来处理你认为的最后一种情况. 否则<br>你将失去case语句的标号(label)所提供的自动说明功能, 也丧失了default子句检错的能力</li>\n<li>利用default语句来检错</li>\n<li>case语句后没有break应该注释说明</li>\n</ul>\n<h2 id=\"第十六章-控制循环\"><a href=\"#第十六章-控制循环\" class=\"headerlink\" title=\"第十六章 控制循环\"></a>第十六章 控制循环</h2><ul>\n<li>不要滥用循环下标<br>最好不要在循环体外 使用 依赖于循环下标最终取值的代码 可能会因为循环异常退出或者循环结束, 得到的下标并不是你想要的下标. 应该使用合适的变量用来标记在循环中是否遇到了你想要的情况</li>\n<li>考虑在while循环中使用break而不是布尔标记</li>\n<li>不要使用浮点数作为边界</li>\n<li>使用有意义的下标变量名, 防止下标串话.</li>\n<li>不要在循环中修改下标值</li>\n</ul>\n<p>下面的代码就是下标串话, 本来第二个循环应该使用j. 这种bug可能不是很容易排查出来, i和j乍一看很像.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>  i, j;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; xxx; ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  xxxx</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; j &lt;xxx; ++j)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>低效的程序员会随意做一些试验, 直到他们找到了一种看上去能工作的组合. 如果某个循环没有按照想象工作,低效的程序员可能会把<code>&lt;</code>改为<code>&lt;=</code>. 如果还不行可能把下标<code>+1</code>或者<code>-1</code>. 这样最终可能碰出正确组合, 也有可能把原来的错误改成了另一个更微妙的错误. 即使这样随意的开发过程能够产生正确的程序, 这些程序员也不明白为什么这个程序是正确的.</p>\n<h2 id=\"第十七章-不常见的控制结构\"><a href=\"#第十七章-不常见的控制结构\" class=\"headerlink\" title=\"第十七章 不常见的控制结构\"></a>第十七章 不常见的控制结构</h2><p>递归前两天正好用过, 如果用的恰当的话 感觉很不错</p>\n<p>我也不想去用…… =, =</p>\n"},{"title":"UNP卷二读书记录","date":"2020-03-15T03:16:20.000Z","top":115,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/UNP%E5%8D%B7%E4%BA%8C%E5%B0%81%E9%9D%A2.png","_content":"\n# 消息传递\n## 管道和有名管道FIFO\n\n**popen pclose**\n```c++\n#include <stdio.h>\n// 成功返回文件指针, 出错为NULL\nFILE* popen(const char *command, const char *type);\nFILE* fp = popen(command, \"r\");\n\n// 成功为shell终止状态, 出错则为 -1\nint pclose(FILE *stream);\npclose(fp);\n```\npopen创建一个管道并启动另外一个进程 创建者要么从管道读出标准输入, 要么将标准输出写到管道\n返回的文件指针作用\n通过type参数控制\ntype = \"r\" 创建者 通过文件指针读入command命令产生的标准输出\ntype = \"w\" 创建者 通过文件指针为command命令提供标准输入\n\npclose 关闭这个标准IO流\n\n\n**FIFO 先进先出(first in, first out)**\n\n又称为有名管道(named pipe) 单向(半双工)数据流, 每个FIFO都有一个路径名与之对应. \n从而允许无亲缘关系的进程访问同一个FIFO\n\n```c++\n#include <sys/types.h>\n#include <sys/stat.h>\n\n// 成功返回 0 失败返回 -1\nint mkfifo(const char *pathname, mode_t mode);\n\nconst char FIFO1 = \"/tmp/fifo.1\";\nmkfifo(FIFO1, 0666);\n\n// 创建之后需要打开来进行读或者写 可以使用open也可以使用其他标准IO打开函数\nint writefd = open(FIFO1, O_WRONLY, 0); /* 在父进程中打开 父进程写 */\nint readfd = open(FIFO1, O_RDONLY, 0); /* 在子进程中打开 子进程读 */\n\n// 只有调用unlink才能从文件系统删除文件名字\nunlink(FIFO1);\n```\nmkfifo 隐含已经指定 O_CREAT | O_EXCL\n要么不存在创建一个新的, 要么返回 errno=EEXIST(所指定名字的FIFO已经存在)\n\n如果想要打开已经存在的FIFO可以使用open函数.\n可以判断 如果返回-1 并且errno=EEXIST 就调用open函数打开\n\n\n```c++\n// 子进程\nreadfd = open(FIFO1, O_RDONLY, 0);\nwritefd = open(FIFO2, O_WRONLY, 0);\n\n// 父进程\nwritefd = open(FIFO1, O_WRONLY, 0);\nreadfd = open(FIFO2, O_RDONLY, 0);\n\n// 父进程 这样会阻塞\nreadfd = open(FIFO2, O_RDONLY, 0);\nwritefd = open(FIFO1, O_WRONLY, 0);\n```\n如果调换父进程的两行代码 程序就会进入死锁\n因为如果当前没有任何进程`打开某个FIFO来写`, 打开这个`FIFO来读`的进程将会`阻塞`\n\n\n当对一个管道或者FIFO的最终close发生的时候, 该管道或FIFO中的任何残余数据都将被丢弃\n\n\n即使在A主机上能够访问到B主机的目录, 即使不同主机上的两个进程都能够通过NFS打开同一个FIFO\n他们之间也不能通过FIFO从一个进程到另一个进程发送数据\n\n拒绝服务型攻击Dos\n如果是单进程可能会让服务器处于阻塞状态, 多进程也可能会由于一个恶意客户发送大量独立请求\n导致服务器子进程数达到上限, 使得后续的fork失败\n\n\n**其他**\n从字节流中获取完整的单个信息\n- 带特殊终止序列\n许多UNIX应用使用换行分割 因特尔应用程序使用回车符加上一个换行符\n- 显式长度\n将长度增加在请求中\n- 每次连接一个记录\n应用通过关闭对端连接指示一个记录结束. HTTP1.0使用的这一技术\n\n标准IO函数fdopen可以将标准IO流与pipe返回的文件描述符相关联'\n\n\n**限制**\n系统加在管道和FIFO的唯一限制是\n- OPEN_MAX\n一个进程在任意时刻打开的最大描述符数量 >=16\n- PIPE_BUF\n可以原子性的写入一个管道或FIFO的最大数据量 >= 512\n\n\n**习题练习**\n1. 父进程终止的时候, 如果子进程的fd[1]仍处于打开状态, 则子进程对fd[0]的read 不会返回文件结束符,\n因为fd[1]虽然在父进程中关闭了, 但是在子进程中依然打开. 如果关闭子进程fd[1], 则父进程一旦关闭, \n他的所有文件描述符即关闭, 子进程对fd[0]的read就会返回0.(想到了自己写的服务器, 客户端断开连接就会read出一个0长度的内容)\n2. 从 不存在即创建, 存在->打开 变成 存在->打开, 不存在即创建. 可能会在open打开失败后 创建fifo之前\n被其他进程抢先创建fifo, 导致本进程的mkfifo调用失败\n3. 出错信息写到了标准错误输出\n5. 可以把第一个open调用设置成非阻塞, 但是为了避免readline返回错误, 标志必须在readline之前去除\n6. 死锁\n7. 读进程关闭管道或者FIFO后给写进程一个信号(往关闭的管道写会产生SIGPIPE信号),\n写进程关闭管道或者FIFO后将文件结束符发送给读进程(读进程读到长度为0的文件结束符)\n\n\n## POSIX消息队列\n\n**mqueue创建和删除**\n```c++\n#include <mqueue.h>\n\n// oflag O_RDONLY O_WRONLY O_RDWR 可以加上O_CREAT和O_EXCL或者O_NONBLOCK\n// 创建一个新队列的时候(制定了O_CREAT且消息队列不存在)后两个参数都需要\n// 权限位 和 指定某些属性 nullptr则使用默认属性\n\n// 成功返回消息队列 fd 失败 -1\nmqd_t mq_open(const char *name, int oflag,\n /*mode_t mode, struct mq_attr *attr*/);\n```\n注意\n消息队列文件描述符不必是(而且很可能不是)像文件描述符或者socket文件描述符那样的短整数\n\n```c++\n// 关闭消息队列 引用计数 -1\nint mq_close(mqd_t mqdes);\n```\n类似close函数, 调用进程可以不再使用该文件描述符, 但是其消息队列并不会从系统中删除\n\n当一个进程终止的时候, 所有打开着的消息队列都将关闭, 就像自动调用了mq_close\n\n\n如果要从系统中删除`mq_open`第一个参数`name` 必须调用下面的函数\n```c++\n// 引用计数 -1\nint mq_unlink(const char *name);\n```\n\n每个消息队列有一个保存着当前打开描述符数的引用计数器\n\n当消息队列的引用计数仍大于0时, 其name就能删除\n但是队列的析构会在`引用计数为0`的时候自动析构.\n\n\n第一个demo敲完之后 一直是errno=13.\n在`man mq_overview`\n```\nOn Linux, message queues are created in a virtual filesystem.   (Other  implementa‐\ntions may also provide such a feature, but the details are likely to differ.)  This\nfilesystem can be mounted (by the superuser) using the following commands:\n\n# mkdir /dev/mqueue\n# mount -t mqueue none /dev/mqueue\n\nThe sticky bit is automatically enabled on the mount directory.\n```\n而且 name参数的格式是`/somename` 这个是相对挂载目录的\n\n\n**属性设置**\n```c++\nstruct mq_attr\n{\n    long mq_flags; /* 0, O_NONBLOCK */\n    long mq_maxmsg; /* max number */\n    long mq_msgsize; /* max size of a msg in bytes */\n    long mq_curmsgs; /* number of message currently on queue */\n}\n\nint mq_getattr(mqd_t mqdes, struct mq_attr *attr);\n\n// set 的时候 只有mq_attr中的mq_flags起作用 设置取消O_NONBLOCK\n// 最大消息数和最大字节数 只能在创建队列的时候设置\n// 队列中房钱消息数 只能获取不能设置\n// 第三个参数 不为nullptr则返回之前的属性\nint mq_setattr(mqd_t mqdes, const struct mq_attr *attr, struct mq_attr *oattr);\n```\n\n**发送接收信息**\n```c++\n// prio 优先级 必须 <= MQ_PRIO_MAX\nint mq_send(mqd_t mqdes, const char *ptr, size_t len, unsigned int prio);\n\n// len 必须 >= mq_attr.mq_msgsize 如果小于则 errno = EMSGSIZE\nssize_t mq_receive(mqd_t mqdes, const char *ptr, size_t len, unsigned int *priop);\n```\n如果不使用优先级 发送的时候可以将 mq_send的 prio 设置为0\n接受的时候 mq_receive priop 设置为 nullptr\n\n\n**消息队列的限制**\n- mq_maxmsg 队列中最大消息数\n- mq_msgsize单个消息的最大字节\n- MQ_OPEN_MAX 一个进程同时打开消息队列的最大数目\n- MQ_PRIO_MAX 最大优先级+1\n\n**异步事件通知**\n- 产生信号\n- 创建一个线程执行一个指定的函数\n\n```c++\n// 为指定队列建立或者删除异步事件通知.\n\n// 成功返回 0 失败返回 -1\nint mq_notify(mqd_t mqdes, struct sigevent *nofification);\n\nstruct sigval\n{\n    int sival_int;\n    void *sival_ptr;\n}\n\nstruct sigevent\n{\n    int sigev_notify; // SIGEV_NONE SIGEV_SIGNAL SIGEV_THREAD\n    int sigev_signo; // signal number if SIGEV_SIGNAL\n    union sigval sigev_value; // passed to signal handler pr thread\n    // 下面两个用于 SIGEV_THREAD\n    void (*sigev_notify_function)(union sigval);\n    pthread_attr_t *sigev_notify_attributes;\n}\n```\n1. 如果 notification != nullptr\n当前进程希望 在有一个消息 到达所指定的 先前为空的队列 时得到通知\n我们说 该进程被注册为接收该队列的通知\n\n2. 如果 notification == nullptr\n如果 该进程被注册为 接受所指定队列通知 则取消它\n\n3. 任何时刻只有一个进程可以被注册为 接收某个队列的通知\n4. 当一个消息到达某个空队列, 而且已经注册, 那么只有当\n没有因为调用mq_reveive导致的阻塞 的时候才会发出通知\n5. 通知发出后 注册立即被撤销.. 需要重新注册???\n\nUnix信号产生后会复位成默认行为.\n信号处理程序通常第一个调用signal函数, 用于重新建立处理程序\n这时会产生一个空窗时期(信号产生 与 当前进程重建信号处理程序之间)\n空窗时期再次产生同一信号 可能终止当前进程\n\n初看起来, mq_notify可能也有这个问题.\n不过在消息队列`为空前` `通知不会再次产生`\n所以不要在`读出消息后`重新注册\n而应该在`读出消息前`重新注册\n\n\n`volatile sig_atomic_t mqflag = 0;`\nsig_atomic_t 即使缺少信号所做的异步中断，亦能作为原子实体访问的整数类型。\nvolatile 标记可能会随时改变\n","source":"_posts/读书记录115-UNP卷二.md","raw":"---\ntitle: UNP卷二读书记录\ndate: 2020-03-15 11:16:20\ntags:\ncategories:\n - 读书记录\ntop: 115\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/UNP%E5%8D%B7%E4%BA%8C%E5%B0%81%E9%9D%A2.png\n---\n\n# 消息传递\n## 管道和有名管道FIFO\n\n**popen pclose**\n```c++\n#include <stdio.h>\n// 成功返回文件指针, 出错为NULL\nFILE* popen(const char *command, const char *type);\nFILE* fp = popen(command, \"r\");\n\n// 成功为shell终止状态, 出错则为 -1\nint pclose(FILE *stream);\npclose(fp);\n```\npopen创建一个管道并启动另外一个进程 创建者要么从管道读出标准输入, 要么将标准输出写到管道\n返回的文件指针作用\n通过type参数控制\ntype = \"r\" 创建者 通过文件指针读入command命令产生的标准输出\ntype = \"w\" 创建者 通过文件指针为command命令提供标准输入\n\npclose 关闭这个标准IO流\n\n\n**FIFO 先进先出(first in, first out)**\n\n又称为有名管道(named pipe) 单向(半双工)数据流, 每个FIFO都有一个路径名与之对应. \n从而允许无亲缘关系的进程访问同一个FIFO\n\n```c++\n#include <sys/types.h>\n#include <sys/stat.h>\n\n// 成功返回 0 失败返回 -1\nint mkfifo(const char *pathname, mode_t mode);\n\nconst char FIFO1 = \"/tmp/fifo.1\";\nmkfifo(FIFO1, 0666);\n\n// 创建之后需要打开来进行读或者写 可以使用open也可以使用其他标准IO打开函数\nint writefd = open(FIFO1, O_WRONLY, 0); /* 在父进程中打开 父进程写 */\nint readfd = open(FIFO1, O_RDONLY, 0); /* 在子进程中打开 子进程读 */\n\n// 只有调用unlink才能从文件系统删除文件名字\nunlink(FIFO1);\n```\nmkfifo 隐含已经指定 O_CREAT | O_EXCL\n要么不存在创建一个新的, 要么返回 errno=EEXIST(所指定名字的FIFO已经存在)\n\n如果想要打开已经存在的FIFO可以使用open函数.\n可以判断 如果返回-1 并且errno=EEXIST 就调用open函数打开\n\n\n```c++\n// 子进程\nreadfd = open(FIFO1, O_RDONLY, 0);\nwritefd = open(FIFO2, O_WRONLY, 0);\n\n// 父进程\nwritefd = open(FIFO1, O_WRONLY, 0);\nreadfd = open(FIFO2, O_RDONLY, 0);\n\n// 父进程 这样会阻塞\nreadfd = open(FIFO2, O_RDONLY, 0);\nwritefd = open(FIFO1, O_WRONLY, 0);\n```\n如果调换父进程的两行代码 程序就会进入死锁\n因为如果当前没有任何进程`打开某个FIFO来写`, 打开这个`FIFO来读`的进程将会`阻塞`\n\n\n当对一个管道或者FIFO的最终close发生的时候, 该管道或FIFO中的任何残余数据都将被丢弃\n\n\n即使在A主机上能够访问到B主机的目录, 即使不同主机上的两个进程都能够通过NFS打开同一个FIFO\n他们之间也不能通过FIFO从一个进程到另一个进程发送数据\n\n拒绝服务型攻击Dos\n如果是单进程可能会让服务器处于阻塞状态, 多进程也可能会由于一个恶意客户发送大量独立请求\n导致服务器子进程数达到上限, 使得后续的fork失败\n\n\n**其他**\n从字节流中获取完整的单个信息\n- 带特殊终止序列\n许多UNIX应用使用换行分割 因特尔应用程序使用回车符加上一个换行符\n- 显式长度\n将长度增加在请求中\n- 每次连接一个记录\n应用通过关闭对端连接指示一个记录结束. HTTP1.0使用的这一技术\n\n标准IO函数fdopen可以将标准IO流与pipe返回的文件描述符相关联'\n\n\n**限制**\n系统加在管道和FIFO的唯一限制是\n- OPEN_MAX\n一个进程在任意时刻打开的最大描述符数量 >=16\n- PIPE_BUF\n可以原子性的写入一个管道或FIFO的最大数据量 >= 512\n\n\n**习题练习**\n1. 父进程终止的时候, 如果子进程的fd[1]仍处于打开状态, 则子进程对fd[0]的read 不会返回文件结束符,\n因为fd[1]虽然在父进程中关闭了, 但是在子进程中依然打开. 如果关闭子进程fd[1], 则父进程一旦关闭, \n他的所有文件描述符即关闭, 子进程对fd[0]的read就会返回0.(想到了自己写的服务器, 客户端断开连接就会read出一个0长度的内容)\n2. 从 不存在即创建, 存在->打开 变成 存在->打开, 不存在即创建. 可能会在open打开失败后 创建fifo之前\n被其他进程抢先创建fifo, 导致本进程的mkfifo调用失败\n3. 出错信息写到了标准错误输出\n5. 可以把第一个open调用设置成非阻塞, 但是为了避免readline返回错误, 标志必须在readline之前去除\n6. 死锁\n7. 读进程关闭管道或者FIFO后给写进程一个信号(往关闭的管道写会产生SIGPIPE信号),\n写进程关闭管道或者FIFO后将文件结束符发送给读进程(读进程读到长度为0的文件结束符)\n\n\n## POSIX消息队列\n\n**mqueue创建和删除**\n```c++\n#include <mqueue.h>\n\n// oflag O_RDONLY O_WRONLY O_RDWR 可以加上O_CREAT和O_EXCL或者O_NONBLOCK\n// 创建一个新队列的时候(制定了O_CREAT且消息队列不存在)后两个参数都需要\n// 权限位 和 指定某些属性 nullptr则使用默认属性\n\n// 成功返回消息队列 fd 失败 -1\nmqd_t mq_open(const char *name, int oflag,\n /*mode_t mode, struct mq_attr *attr*/);\n```\n注意\n消息队列文件描述符不必是(而且很可能不是)像文件描述符或者socket文件描述符那样的短整数\n\n```c++\n// 关闭消息队列 引用计数 -1\nint mq_close(mqd_t mqdes);\n```\n类似close函数, 调用进程可以不再使用该文件描述符, 但是其消息队列并不会从系统中删除\n\n当一个进程终止的时候, 所有打开着的消息队列都将关闭, 就像自动调用了mq_close\n\n\n如果要从系统中删除`mq_open`第一个参数`name` 必须调用下面的函数\n```c++\n// 引用计数 -1\nint mq_unlink(const char *name);\n```\n\n每个消息队列有一个保存着当前打开描述符数的引用计数器\n\n当消息队列的引用计数仍大于0时, 其name就能删除\n但是队列的析构会在`引用计数为0`的时候自动析构.\n\n\n第一个demo敲完之后 一直是errno=13.\n在`man mq_overview`\n```\nOn Linux, message queues are created in a virtual filesystem.   (Other  implementa‐\ntions may also provide such a feature, but the details are likely to differ.)  This\nfilesystem can be mounted (by the superuser) using the following commands:\n\n# mkdir /dev/mqueue\n# mount -t mqueue none /dev/mqueue\n\nThe sticky bit is automatically enabled on the mount directory.\n```\n而且 name参数的格式是`/somename` 这个是相对挂载目录的\n\n\n**属性设置**\n```c++\nstruct mq_attr\n{\n    long mq_flags; /* 0, O_NONBLOCK */\n    long mq_maxmsg; /* max number */\n    long mq_msgsize; /* max size of a msg in bytes */\n    long mq_curmsgs; /* number of message currently on queue */\n}\n\nint mq_getattr(mqd_t mqdes, struct mq_attr *attr);\n\n// set 的时候 只有mq_attr中的mq_flags起作用 设置取消O_NONBLOCK\n// 最大消息数和最大字节数 只能在创建队列的时候设置\n// 队列中房钱消息数 只能获取不能设置\n// 第三个参数 不为nullptr则返回之前的属性\nint mq_setattr(mqd_t mqdes, const struct mq_attr *attr, struct mq_attr *oattr);\n```\n\n**发送接收信息**\n```c++\n// prio 优先级 必须 <= MQ_PRIO_MAX\nint mq_send(mqd_t mqdes, const char *ptr, size_t len, unsigned int prio);\n\n// len 必须 >= mq_attr.mq_msgsize 如果小于则 errno = EMSGSIZE\nssize_t mq_receive(mqd_t mqdes, const char *ptr, size_t len, unsigned int *priop);\n```\n如果不使用优先级 发送的时候可以将 mq_send的 prio 设置为0\n接受的时候 mq_receive priop 设置为 nullptr\n\n\n**消息队列的限制**\n- mq_maxmsg 队列中最大消息数\n- mq_msgsize单个消息的最大字节\n- MQ_OPEN_MAX 一个进程同时打开消息队列的最大数目\n- MQ_PRIO_MAX 最大优先级+1\n\n**异步事件通知**\n- 产生信号\n- 创建一个线程执行一个指定的函数\n\n```c++\n// 为指定队列建立或者删除异步事件通知.\n\n// 成功返回 0 失败返回 -1\nint mq_notify(mqd_t mqdes, struct sigevent *nofification);\n\nstruct sigval\n{\n    int sival_int;\n    void *sival_ptr;\n}\n\nstruct sigevent\n{\n    int sigev_notify; // SIGEV_NONE SIGEV_SIGNAL SIGEV_THREAD\n    int sigev_signo; // signal number if SIGEV_SIGNAL\n    union sigval sigev_value; // passed to signal handler pr thread\n    // 下面两个用于 SIGEV_THREAD\n    void (*sigev_notify_function)(union sigval);\n    pthread_attr_t *sigev_notify_attributes;\n}\n```\n1. 如果 notification != nullptr\n当前进程希望 在有一个消息 到达所指定的 先前为空的队列 时得到通知\n我们说 该进程被注册为接收该队列的通知\n\n2. 如果 notification == nullptr\n如果 该进程被注册为 接受所指定队列通知 则取消它\n\n3. 任何时刻只有一个进程可以被注册为 接收某个队列的通知\n4. 当一个消息到达某个空队列, 而且已经注册, 那么只有当\n没有因为调用mq_reveive导致的阻塞 的时候才会发出通知\n5. 通知发出后 注册立即被撤销.. 需要重新注册???\n\nUnix信号产生后会复位成默认行为.\n信号处理程序通常第一个调用signal函数, 用于重新建立处理程序\n这时会产生一个空窗时期(信号产生 与 当前进程重建信号处理程序之间)\n空窗时期再次产生同一信号 可能终止当前进程\n\n初看起来, mq_notify可能也有这个问题.\n不过在消息队列`为空前` `通知不会再次产生`\n所以不要在`读出消息后`重新注册\n而应该在`读出消息前`重新注册\n\n\n`volatile sig_atomic_t mqflag = 0;`\nsig_atomic_t 即使缺少信号所做的异步中断，亦能作为原子实体访问的整数类型。\nvolatile 标记可能会随时改变\n","slug":"读书记录115-UNP卷二","published":1,"updated":"2020-12-05T02:31:35.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg78003uf8unfk8pajid","content":"<h1 id=\"消息传递\"><a href=\"#消息传递\" class=\"headerlink\" title=\"消息传递\"></a>消息传递</h1><h2 id=\"管道和有名管道FIFO\"><a href=\"#管道和有名管道FIFO\" class=\"headerlink\" title=\"管道和有名管道FIFO\"></a>管道和有名管道FIFO</h2><p><strong>popen pclose</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回文件指针, 出错为NULL</span></span><br><span class=\"line\"><span class=\"function\">FILE* <span class=\"title\">popen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *command, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *type)</span></span>;</span><br><span class=\"line\">FILE* fp = popen(command, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功为shell终止状态, 出错则为 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pclose</span><span class=\"params\">(FILE *stream)</span></span>;</span><br><span class=\"line\">pclose(fp);</span><br></pre></td></tr></table></figure>\n<p>popen创建一个管道并启动另外一个进程 创建者要么从管道读出标准输入, 要么将标准输出写到管道<br>返回的文件指针作用<br>通过type参数控制<br>type = “r” 创建者 通过文件指针读入command命令产生的标准输出<br>type = “w” 创建者 通过文件指针为command命令提供标准输入</p>\n<p>pclose 关闭这个标准IO流</p>\n<p><strong>FIFO 先进先出(first in, first out)</strong></p>\n<p>又称为有名管道(named pipe) 单向(半双工)数据流, 每个FIFO都有一个路径名与之对应.<br>从而允许无亲缘关系的进程访问同一个FIFO</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功返回 0 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mkfifo</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">mode_t</span> mode)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> FIFO1 = <span class=\"string\">\"/tmp/fifo.1\"</span>;</span><br><span class=\"line\">mkfifo(FIFO1, <span class=\"number\">0666</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建之后需要打开来进行读或者写 可以使用open也可以使用其他标准IO打开函数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> writefd = <span class=\"built_in\">open</span>(FIFO1, O_WRONLY, <span class=\"number\">0</span>); <span class=\"comment\">/* 在父进程中打开 父进程写 */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> readfd = <span class=\"built_in\">open</span>(FIFO1, O_RDONLY, <span class=\"number\">0</span>); <span class=\"comment\">/* 在子进程中打开 子进程读 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只有调用unlink才能从文件系统删除文件名字</span></span><br><span class=\"line\">unlink(FIFO1);</span><br></pre></td></tr></table></figure>\n<p>mkfifo 隐含已经指定 O_CREAT | O_EXCL<br>要么不存在创建一个新的, 要么返回 errno=EEXIST(所指定名字的FIFO已经存在)</p>\n<p>如果想要打开已经存在的FIFO可以使用open函数.<br>可以判断 如果返回-1 并且errno=EEXIST 就调用open函数打开</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 子进程</span></span><br><span class=\"line\">readfd = <span class=\"built_in\">open</span>(FIFO1, O_RDONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\">writefd = <span class=\"built_in\">open</span>(FIFO2, O_WRONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父进程</span></span><br><span class=\"line\">writefd = <span class=\"built_in\">open</span>(FIFO1, O_WRONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\">readfd = <span class=\"built_in\">open</span>(FIFO2, O_RDONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父进程 这样会阻塞</span></span><br><span class=\"line\">readfd = <span class=\"built_in\">open</span>(FIFO2, O_RDONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\">writefd = <span class=\"built_in\">open</span>(FIFO1, O_WRONLY, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>如果调换父进程的两行代码 程序就会进入死锁<br>因为如果当前没有任何进程<code>打开某个FIFO来写</code>, 打开这个<code>FIFO来读</code>的进程将会<code>阻塞</code></p>\n<p>当对一个管道或者FIFO的最终close发生的时候, 该管道或FIFO中的任何残余数据都将被丢弃</p>\n<p>即使在A主机上能够访问到B主机的目录, 即使不同主机上的两个进程都能够通过NFS打开同一个FIFO<br>他们之间也不能通过FIFO从一个进程到另一个进程发送数据</p>\n<p>拒绝服务型攻击Dos<br>如果是单进程可能会让服务器处于阻塞状态, 多进程也可能会由于一个恶意客户发送大量独立请求<br>导致服务器子进程数达到上限, 使得后续的fork失败</p>\n<p><strong>其他</strong><br>从字节流中获取完整的单个信息</p>\n<ul>\n<li>带特殊终止序列<br>许多UNIX应用使用换行分割 因特尔应用程序使用回车符加上一个换行符</li>\n<li>显式长度<br>将长度增加在请求中</li>\n<li>每次连接一个记录<br>应用通过关闭对端连接指示一个记录结束. HTTP1.0使用的这一技术</li>\n</ul>\n<p>标准IO函数fdopen可以将标准IO流与pipe返回的文件描述符相关联’</p>\n<p><strong>限制</strong><br>系统加在管道和FIFO的唯一限制是</p>\n<ul>\n<li>OPEN_MAX<br>一个进程在任意时刻打开的最大描述符数量 &gt;=16</li>\n<li>PIPE_BUF<br>可以原子性的写入一个管道或FIFO的最大数据量 &gt;= 512</li>\n</ul>\n<p><strong>习题练习</strong></p>\n<ol>\n<li>父进程终止的时候, 如果子进程的fd[1]仍处于打开状态, 则子进程对fd[0]的read 不会返回文件结束符,<br>因为fd[1]虽然在父进程中关闭了, 但是在子进程中依然打开. 如果关闭子进程fd[1], 则父进程一旦关闭,<br>他的所有文件描述符即关闭, 子进程对fd[0]的read就会返回0.(想到了自己写的服务器, 客户端断开连接就会read出一个0长度的内容)</li>\n<li>从 不存在即创建, 存在-&gt;打开 变成 存在-&gt;打开, 不存在即创建. 可能会在open打开失败后 创建fifo之前<br>被其他进程抢先创建fifo, 导致本进程的mkfifo调用失败</li>\n<li>出错信息写到了标准错误输出</li>\n<li>可以把第一个open调用设置成非阻塞, 但是为了避免readline返回错误, 标志必须在readline之前去除</li>\n<li>死锁</li>\n<li>读进程关闭管道或者FIFO后给写进程一个信号(往关闭的管道写会产生SIGPIPE信号),<br>写进程关闭管道或者FIFO后将文件结束符发送给读进程(读进程读到长度为0的文件结束符)</li>\n</ol>\n<h2 id=\"POSIX消息队列\"><a href=\"#POSIX消息队列\" class=\"headerlink\" title=\"POSIX消息队列\"></a>POSIX消息队列</h2><p><strong>mqueue创建和删除</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mqueue.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// oflag O_RDONLY O_WRONLY O_RDWR 可以加上O_CREAT和O_EXCL或者O_NONBLOCK</span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个新队列的时候(制定了O_CREAT且消息队列不存在)后两个参数都需要</span></span><br><span class=\"line\"><span class=\"comment\">// 权限位 和 指定某些属性 nullptr则使用默认属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功返回消息队列 fd 失败 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">mqd_t</span> <span class=\"title\">mq_open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">int</span> oflag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"> <span class=\"comment\">/*mode_t mode, struct mq_attr *attr*/</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>注意<br>消息队列文件描述符不必是(而且很可能不是)像文件描述符或者socket文件描述符那样的短整数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关闭消息队列 引用计数 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_close</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>类似close函数, 调用进程可以不再使用该文件描述符, 但是其消息队列并不会从系统中删除</p>\n<p>当一个进程终止的时候, 所有打开着的消息队列都将关闭, 就像自动调用了mq_close</p>\n<p>如果要从系统中删除<code>mq_open</code>第一个参数<code>name</code> 必须调用下面的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引用计数 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_unlink</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>每个消息队列有一个保存着当前打开描述符数的引用计数器</p>\n<p>当消息队列的引用计数仍大于0时, 其name就能删除<br>但是队列的析构会在<code>引用计数为0</code>的时候自动析构.</p>\n<p>第一个demo敲完之后 一直是errno=13.<br>在<code>man mq_overview</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">On Linux, message queues are created in a virtual filesystem.   (Other  implementa‐</span><br><span class=\"line\">tions may also provide such a feature, but the details are likely to differ.)  This</span><br><span class=\"line\">filesystem can be mounted (by the superuser) using the following commands:</span><br><span class=\"line\"></span><br><span class=\"line\"># mkdir &#x2F;dev&#x2F;mqueue</span><br><span class=\"line\"># mount -t mqueue none &#x2F;dev&#x2F;mqueue</span><br><span class=\"line\"></span><br><span class=\"line\">The sticky bit is automatically enabled on the mount directory.</span><br></pre></td></tr></table></figure>\n<p>而且 name参数的格式是<code>/somename</code> 这个是相对挂载目录的</p>\n<p><strong>属性设置</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mq_attr</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_flags; <span class=\"comment\">/* 0, O_NONBLOCK */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_maxmsg; <span class=\"comment\">/* max number */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_msgsize; <span class=\"comment\">/* max size of a msg in bytes */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_curmsgs; <span class=\"comment\">/* number of message currently on queue */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_getattr</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, struct mq_attr *attr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// set 的时候 只有mq_attr中的mq_flags起作用 设置取消O_NONBLOCK</span></span><br><span class=\"line\"><span class=\"comment\">// 最大消息数和最大字节数 只能在创建队列的时候设置</span></span><br><span class=\"line\"><span class=\"comment\">// 队列中房钱消息数 只能获取不能设置</span></span><br><span class=\"line\"><span class=\"comment\">// 第三个参数 不为nullptr则返回之前的属性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_setattr</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, <span class=\"keyword\">const</span> struct mq_attr *attr, struct mq_attr *oattr)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>发送接收信息</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// prio 优先级 必须 &lt;= MQ_PRIO_MAX</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_send</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *ptr, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> prio)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// len 必须 &gt;= mq_attr.mq_msgsize 如果小于则 errno = EMSGSIZE</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">mq_receive</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *ptr, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *priop)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>如果不使用优先级 发送的时候可以将 mq_send的 prio 设置为0<br>接受的时候 mq_receive priop 设置为 nullptr</p>\n<p><strong>消息队列的限制</strong></p>\n<ul>\n<li>mq_maxmsg 队列中最大消息数</li>\n<li>mq_msgsize单个消息的最大字节</li>\n<li>MQ_OPEN_MAX 一个进程同时打开消息队列的最大数目</li>\n<li>MQ_PRIO_MAX 最大优先级+1</li>\n</ul>\n<p><strong>异步事件通知</strong></p>\n<ul>\n<li>产生信号</li>\n<li>创建一个线程执行一个指定的函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为指定队列建立或者删除异步事件通知.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功返回 0 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_notify</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, struct sigevent *nofification)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigval</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sival_int;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *sival_ptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigevent</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sigev_notify; <span class=\"comment\">// SIGEV_NONE SIGEV_SIGNAL SIGEV_THREAD</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sigev_signo; <span class=\"comment\">// signal number if SIGEV_SIGNAL</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> sigval sigev_value; <span class=\"comment\">// passed to signal handler pr thread</span></span><br><span class=\"line\">    <span class=\"comment\">// 下面两个用于 SIGEV_THREAD</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*sigev_notify_function)(<span class=\"keyword\">union</span> sigval);</span><br><span class=\"line\">    <span class=\"keyword\">pthread_attr_t</span> *sigev_notify_attributes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>如果 notification != nullptr<br>当前进程希望 在有一个消息 到达所指定的 先前为空的队列 时得到通知<br>我们说 该进程被注册为接收该队列的通知</p>\n</li>\n<li><p>如果 notification == nullptr<br>如果 该进程被注册为 接受所指定队列通知 则取消它</p>\n</li>\n<li><p>任何时刻只有一个进程可以被注册为 接收某个队列的通知</p>\n</li>\n<li><p>当一个消息到达某个空队列, 而且已经注册, 那么只有当<br>没有因为调用mq_reveive导致的阻塞 的时候才会发出通知</p>\n</li>\n<li><p>通知发出后 注册立即被撤销.. 需要重新注册???</p>\n</li>\n</ol>\n<p>Unix信号产生后会复位成默认行为.<br>信号处理程序通常第一个调用signal函数, 用于重新建立处理程序<br>这时会产生一个空窗时期(信号产生 与 当前进程重建信号处理程序之间)<br>空窗时期再次产生同一信号 可能终止当前进程</p>\n<p>初看起来, mq_notify可能也有这个问题.<br>不过在消息队列<code>为空前</code> <code>通知不会再次产生</code><br>所以不要在<code>读出消息后</code>重新注册<br>而应该在<code>读出消息前</code>重新注册</p>\n<p><code>volatile sig_atomic_t mqflag = 0;</code><br>sig_atomic_t 即使缺少信号所做的异步中断，亦能作为原子实体访问的整数类型。<br>volatile 标记可能会随时改变</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"消息传递\"><a href=\"#消息传递\" class=\"headerlink\" title=\"消息传递\"></a>消息传递</h1><h2 id=\"管道和有名管道FIFO\"><a href=\"#管道和有名管道FIFO\" class=\"headerlink\" title=\"管道和有名管道FIFO\"></a>管道和有名管道FIFO</h2><p><strong>popen pclose</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回文件指针, 出错为NULL</span></span><br><span class=\"line\"><span class=\"function\">FILE* <span class=\"title\">popen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *command, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *type)</span></span>;</span><br><span class=\"line\">FILE* fp = popen(command, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功为shell终止状态, 出错则为 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pclose</span><span class=\"params\">(FILE *stream)</span></span>;</span><br><span class=\"line\">pclose(fp);</span><br></pre></td></tr></table></figure>\n<p>popen创建一个管道并启动另外一个进程 创建者要么从管道读出标准输入, 要么将标准输出写到管道<br>返回的文件指针作用<br>通过type参数控制<br>type = “r” 创建者 通过文件指针读入command命令产生的标准输出<br>type = “w” 创建者 通过文件指针为command命令提供标准输入</p>\n<p>pclose 关闭这个标准IO流</p>\n<p><strong>FIFO 先进先出(first in, first out)</strong></p>\n<p>又称为有名管道(named pipe) 单向(半双工)数据流, 每个FIFO都有一个路径名与之对应.<br>从而允许无亲缘关系的进程访问同一个FIFO</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功返回 0 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mkfifo</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">mode_t</span> mode)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> FIFO1 = <span class=\"string\">\"/tmp/fifo.1\"</span>;</span><br><span class=\"line\">mkfifo(FIFO1, <span class=\"number\">0666</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建之后需要打开来进行读或者写 可以使用open也可以使用其他标准IO打开函数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> writefd = <span class=\"built_in\">open</span>(FIFO1, O_WRONLY, <span class=\"number\">0</span>); <span class=\"comment\">/* 在父进程中打开 父进程写 */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> readfd = <span class=\"built_in\">open</span>(FIFO1, O_RDONLY, <span class=\"number\">0</span>); <span class=\"comment\">/* 在子进程中打开 子进程读 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只有调用unlink才能从文件系统删除文件名字</span></span><br><span class=\"line\">unlink(FIFO1);</span><br></pre></td></tr></table></figure>\n<p>mkfifo 隐含已经指定 O_CREAT | O_EXCL<br>要么不存在创建一个新的, 要么返回 errno=EEXIST(所指定名字的FIFO已经存在)</p>\n<p>如果想要打开已经存在的FIFO可以使用open函数.<br>可以判断 如果返回-1 并且errno=EEXIST 就调用open函数打开</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 子进程</span></span><br><span class=\"line\">readfd = <span class=\"built_in\">open</span>(FIFO1, O_RDONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\">writefd = <span class=\"built_in\">open</span>(FIFO2, O_WRONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父进程</span></span><br><span class=\"line\">writefd = <span class=\"built_in\">open</span>(FIFO1, O_WRONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\">readfd = <span class=\"built_in\">open</span>(FIFO2, O_RDONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父进程 这样会阻塞</span></span><br><span class=\"line\">readfd = <span class=\"built_in\">open</span>(FIFO2, O_RDONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\">writefd = <span class=\"built_in\">open</span>(FIFO1, O_WRONLY, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>如果调换父进程的两行代码 程序就会进入死锁<br>因为如果当前没有任何进程<code>打开某个FIFO来写</code>, 打开这个<code>FIFO来读</code>的进程将会<code>阻塞</code></p>\n<p>当对一个管道或者FIFO的最终close发生的时候, 该管道或FIFO中的任何残余数据都将被丢弃</p>\n<p>即使在A主机上能够访问到B主机的目录, 即使不同主机上的两个进程都能够通过NFS打开同一个FIFO<br>他们之间也不能通过FIFO从一个进程到另一个进程发送数据</p>\n<p>拒绝服务型攻击Dos<br>如果是单进程可能会让服务器处于阻塞状态, 多进程也可能会由于一个恶意客户发送大量独立请求<br>导致服务器子进程数达到上限, 使得后续的fork失败</p>\n<p><strong>其他</strong><br>从字节流中获取完整的单个信息</p>\n<ul>\n<li>带特殊终止序列<br>许多UNIX应用使用换行分割 因特尔应用程序使用回车符加上一个换行符</li>\n<li>显式长度<br>将长度增加在请求中</li>\n<li>每次连接一个记录<br>应用通过关闭对端连接指示一个记录结束. HTTP1.0使用的这一技术</li>\n</ul>\n<p>标准IO函数fdopen可以将标准IO流与pipe返回的文件描述符相关联’</p>\n<p><strong>限制</strong><br>系统加在管道和FIFO的唯一限制是</p>\n<ul>\n<li>OPEN_MAX<br>一个进程在任意时刻打开的最大描述符数量 &gt;=16</li>\n<li>PIPE_BUF<br>可以原子性的写入一个管道或FIFO的最大数据量 &gt;= 512</li>\n</ul>\n<p><strong>习题练习</strong></p>\n<ol>\n<li>父进程终止的时候, 如果子进程的fd[1]仍处于打开状态, 则子进程对fd[0]的read 不会返回文件结束符,<br>因为fd[1]虽然在父进程中关闭了, 但是在子进程中依然打开. 如果关闭子进程fd[1], 则父进程一旦关闭,<br>他的所有文件描述符即关闭, 子进程对fd[0]的read就会返回0.(想到了自己写的服务器, 客户端断开连接就会read出一个0长度的内容)</li>\n<li>从 不存在即创建, 存在-&gt;打开 变成 存在-&gt;打开, 不存在即创建. 可能会在open打开失败后 创建fifo之前<br>被其他进程抢先创建fifo, 导致本进程的mkfifo调用失败</li>\n<li>出错信息写到了标准错误输出</li>\n<li>可以把第一个open调用设置成非阻塞, 但是为了避免readline返回错误, 标志必须在readline之前去除</li>\n<li>死锁</li>\n<li>读进程关闭管道或者FIFO后给写进程一个信号(往关闭的管道写会产生SIGPIPE信号),<br>写进程关闭管道或者FIFO后将文件结束符发送给读进程(读进程读到长度为0的文件结束符)</li>\n</ol>\n<h2 id=\"POSIX消息队列\"><a href=\"#POSIX消息队列\" class=\"headerlink\" title=\"POSIX消息队列\"></a>POSIX消息队列</h2><p><strong>mqueue创建和删除</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mqueue.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// oflag O_RDONLY O_WRONLY O_RDWR 可以加上O_CREAT和O_EXCL或者O_NONBLOCK</span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个新队列的时候(制定了O_CREAT且消息队列不存在)后两个参数都需要</span></span><br><span class=\"line\"><span class=\"comment\">// 权限位 和 指定某些属性 nullptr则使用默认属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功返回消息队列 fd 失败 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">mqd_t</span> <span class=\"title\">mq_open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">int</span> oflag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"> <span class=\"comment\">/*mode_t mode, struct mq_attr *attr*/</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>注意<br>消息队列文件描述符不必是(而且很可能不是)像文件描述符或者socket文件描述符那样的短整数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关闭消息队列 引用计数 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_close</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>类似close函数, 调用进程可以不再使用该文件描述符, 但是其消息队列并不会从系统中删除</p>\n<p>当一个进程终止的时候, 所有打开着的消息队列都将关闭, 就像自动调用了mq_close</p>\n<p>如果要从系统中删除<code>mq_open</code>第一个参数<code>name</code> 必须调用下面的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引用计数 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_unlink</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>每个消息队列有一个保存着当前打开描述符数的引用计数器</p>\n<p>当消息队列的引用计数仍大于0时, 其name就能删除<br>但是队列的析构会在<code>引用计数为0</code>的时候自动析构.</p>\n<p>第一个demo敲完之后 一直是errno=13.<br>在<code>man mq_overview</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">On Linux, message queues are created in a virtual filesystem.   (Other  implementa‐</span><br><span class=\"line\">tions may also provide such a feature, but the details are likely to differ.)  This</span><br><span class=\"line\">filesystem can be mounted (by the superuser) using the following commands:</span><br><span class=\"line\"></span><br><span class=\"line\"># mkdir &#x2F;dev&#x2F;mqueue</span><br><span class=\"line\"># mount -t mqueue none &#x2F;dev&#x2F;mqueue</span><br><span class=\"line\"></span><br><span class=\"line\">The sticky bit is automatically enabled on the mount directory.</span><br></pre></td></tr></table></figure>\n<p>而且 name参数的格式是<code>/somename</code> 这个是相对挂载目录的</p>\n<p><strong>属性设置</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mq_attr</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_flags; <span class=\"comment\">/* 0, O_NONBLOCK */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_maxmsg; <span class=\"comment\">/* max number */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_msgsize; <span class=\"comment\">/* max size of a msg in bytes */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_curmsgs; <span class=\"comment\">/* number of message currently on queue */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_getattr</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, struct mq_attr *attr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// set 的时候 只有mq_attr中的mq_flags起作用 设置取消O_NONBLOCK</span></span><br><span class=\"line\"><span class=\"comment\">// 最大消息数和最大字节数 只能在创建队列的时候设置</span></span><br><span class=\"line\"><span class=\"comment\">// 队列中房钱消息数 只能获取不能设置</span></span><br><span class=\"line\"><span class=\"comment\">// 第三个参数 不为nullptr则返回之前的属性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_setattr</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, <span class=\"keyword\">const</span> struct mq_attr *attr, struct mq_attr *oattr)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>发送接收信息</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// prio 优先级 必须 &lt;= MQ_PRIO_MAX</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_send</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *ptr, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> prio)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// len 必须 &gt;= mq_attr.mq_msgsize 如果小于则 errno = EMSGSIZE</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">mq_receive</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *ptr, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *priop)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>如果不使用优先级 发送的时候可以将 mq_send的 prio 设置为0<br>接受的时候 mq_receive priop 设置为 nullptr</p>\n<p><strong>消息队列的限制</strong></p>\n<ul>\n<li>mq_maxmsg 队列中最大消息数</li>\n<li>mq_msgsize单个消息的最大字节</li>\n<li>MQ_OPEN_MAX 一个进程同时打开消息队列的最大数目</li>\n<li>MQ_PRIO_MAX 最大优先级+1</li>\n</ul>\n<p><strong>异步事件通知</strong></p>\n<ul>\n<li>产生信号</li>\n<li>创建一个线程执行一个指定的函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为指定队列建立或者删除异步事件通知.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功返回 0 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_notify</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, struct sigevent *nofification)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigval</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sival_int;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *sival_ptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigevent</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sigev_notify; <span class=\"comment\">// SIGEV_NONE SIGEV_SIGNAL SIGEV_THREAD</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sigev_signo; <span class=\"comment\">// signal number if SIGEV_SIGNAL</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> sigval sigev_value; <span class=\"comment\">// passed to signal handler pr thread</span></span><br><span class=\"line\">    <span class=\"comment\">// 下面两个用于 SIGEV_THREAD</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*sigev_notify_function)(<span class=\"keyword\">union</span> sigval);</span><br><span class=\"line\">    <span class=\"keyword\">pthread_attr_t</span> *sigev_notify_attributes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>如果 notification != nullptr<br>当前进程希望 在有一个消息 到达所指定的 先前为空的队列 时得到通知<br>我们说 该进程被注册为接收该队列的通知</p>\n</li>\n<li><p>如果 notification == nullptr<br>如果 该进程被注册为 接受所指定队列通知 则取消它</p>\n</li>\n<li><p>任何时刻只有一个进程可以被注册为 接收某个队列的通知</p>\n</li>\n<li><p>当一个消息到达某个空队列, 而且已经注册, 那么只有当<br>没有因为调用mq_reveive导致的阻塞 的时候才会发出通知</p>\n</li>\n<li><p>通知发出后 注册立即被撤销.. 需要重新注册???</p>\n</li>\n</ol>\n<p>Unix信号产生后会复位成默认行为.<br>信号处理程序通常第一个调用signal函数, 用于重新建立处理程序<br>这时会产生一个空窗时期(信号产生 与 当前进程重建信号处理程序之间)<br>空窗时期再次产生同一信号 可能终止当前进程</p>\n<p>初看起来, mq_notify可能也有这个问题.<br>不过在消息队列<code>为空前</code> <code>通知不会再次产生</code><br>所以不要在<code>读出消息后</code>重新注册<br>而应该在<code>读出消息前</code>重新注册</p>\n<p><code>volatile sig_atomic_t mqflag = 0;</code><br>sig_atomic_t 即使缺少信号所做的异步中断，亦能作为原子实体访问的整数类型。<br>volatile 标记可能会随时改变</p>\n"},{"title":"深度探索C++对象模型","date":"2020-09-15T07:17:39.000Z","_content":"\n# 第一章 关于对象\n\n加上封装之后的成本增加了吗?\n\n并没有增加成本, C++在布局以及存取时间上主要的额外负担是由virtual引起的\n- virtual func机制 用来支持一个有效率的执行期绑定\n- virtual base class 用来实现多次出现在继承体系中的base class, 有一个单一而被共享的实例\n\n\nC++ 有两种成员变量`static`和`nonstatic`\n三种成员函数`static`, `nonstatic`和`virtual`\n\n\n# 第三章Data语义学\n\n```c++\n\nclass Foo\n{\n};\n\nFoo foo;\n```\n\n`sizeof foo = ?`答案是1， 这是为了防止不同的对象却有相同的地址\n\n同时class也存在`字节对齐`现象\n\n\n在针对虚拟继承问题的时候\n\n```\nD对象的内存结构  从低地址开始\n\nD对象数据部分  《- D类对象指针 dptr 指向这里 可以从vptr指向的表中获取A对象数据部分的偏移量 offset\nC对象数据部分\nB对象数据部分\nA对象数据部分  《- dptr + offset 则实现了 子类指针向父类指针的转化\n```\n\nA 派生出 B C。 B C派生出D  如何保证在BC对象中都有A对象， 而在D对象中只有一个A对象？\n\n一种方法是 \n\n先安排派生类的部分 再后接基类的部分， 这样派生类D的对象指针就是指向自己数据部分的指针\n\n如果想要实现子类向父类转换呢？\n\n在vtpr指向的表中的 -1 位置放置偏移量， 由于D类对象的指针是内存开始位置 如果要转换成A类指针\n\n则从D类对象的vptr指向的表中获取A类数据部分的偏移量 这样就实现了子类向父类转换\n\n\n```c++\nclass Foo\n{\npublic:\n    int x;\n    int y;\n    int z;\n};\n\nint main()\n{\n    printf(\"&Foo::x = %p\\n\", &Foo::x);  // 0x0\n    printf(\"&Foo::y = %p\\n\", &Foo::y); // 0x4\n    printf(\"&Foo::z = %p\\n\", &Foo::z); // 0x8\n    return 0;\n}\n```\n如果x， y， z定义为protected或者private则会报错。public得到的是其在类内的偏移地址\n\n# 第四章\n\nname-mangling\n\n不要将mangling之后的结果显示给用户看，这样用户会疑惑哪里来的这个函数（大体来说 我们采纳了他的建议）\n\nstatic member func 并不是比 nonstatic member func效率高 后者也会转换成类似前者的调用。 \n\nstatic member func的主要特征就是他没有`this指针` \n- 所以它不能存取nonstatic member \n- 不能被声明为const 因为const成员函数最终转化成了 const修饰的this指针\n- 不需要通过对象来调用， 因为他不需要this指针\n\nC++中多态表示以一个public base class的指针（或reference）寻址出一个derived class object。这样就实现了多态的函数调用机制\n\n三目运算符搭配逗号运算符\n\n\n# 第五章\nvptr的初始化发生在 base class constructor调用之后，程序员提供的代码之前\n\n不要再vurtual base class中声明数据\n\nvptr会随着构造函数从基类到子类的一层层调用被改变\n同样 析构函数会逆操作 这个指针\n\n# 第六章 \n\n一般情况下 程序的构造函数我们都知道他在那里调用。 然而，析构函数呢？答案是析构函数会在函数结束的时候被调用（针对局部对象）。所以析构函数的调用代码会被穿插入每一个return 前（对象被构造后的return 被构造前的则没有必要） 尽管某些return不会被调用\n\nnew运算符只有一个步骤？ 不不不 会被扩充为 1. 先分配内存 2. 设定初值\n\ndelete运算符 则会进行检测 delete nullptr 则不会有任何效果\n\n针对对象使用new则会在分配内存后通过调用构造函数设定初始值， 而delete则会在检测nullptr后调用析构函数然后将内存归还\n\nNRV优化\n\n# 第七章\n\ntemplate， exception handling（EH）， runtime type identification（RTTI， EH的副作用？）\n\n模板类的错误发现 会直到被实例化的时候才会被发现 延迟了错误的发现时机\n\n目前的编译器，面对一个template声明，在它被一组实际参数实例化之前，只能施行有限的错误检查。template中那些与语法无关的错误，程序员可能认为十分明显，编译器却让他通过了，只有在特定实例被定义之后，运行时。才会产生错误。\n\ndynamic_cast 运算符可以在执行期间决定真正的类型。 如果downcast是安全的这个运算符会传回适当转换过的指针。如果是不安全的则返回0\ndynamic_cast同样可以对引用进行操作，成功后返回转换后的引用，失败后只能抛出异常（因为没有办法像指针那样指定nullptr表示错误）","source":"_posts/读书记录130-深度探索C++对象模型.md","raw":"---\ntitle: 深度探索C++对象模型\ntags:\n  - null\ncategories:\n  - 读书记录\ndate: 2020-09-15 15:17:39\n---\n\n# 第一章 关于对象\n\n加上封装之后的成本增加了吗?\n\n并没有增加成本, C++在布局以及存取时间上主要的额外负担是由virtual引起的\n- virtual func机制 用来支持一个有效率的执行期绑定\n- virtual base class 用来实现多次出现在继承体系中的base class, 有一个单一而被共享的实例\n\n\nC++ 有两种成员变量`static`和`nonstatic`\n三种成员函数`static`, `nonstatic`和`virtual`\n\n\n# 第三章Data语义学\n\n```c++\n\nclass Foo\n{\n};\n\nFoo foo;\n```\n\n`sizeof foo = ?`答案是1， 这是为了防止不同的对象却有相同的地址\n\n同时class也存在`字节对齐`现象\n\n\n在针对虚拟继承问题的时候\n\n```\nD对象的内存结构  从低地址开始\n\nD对象数据部分  《- D类对象指针 dptr 指向这里 可以从vptr指向的表中获取A对象数据部分的偏移量 offset\nC对象数据部分\nB对象数据部分\nA对象数据部分  《- dptr + offset 则实现了 子类指针向父类指针的转化\n```\n\nA 派生出 B C。 B C派生出D  如何保证在BC对象中都有A对象， 而在D对象中只有一个A对象？\n\n一种方法是 \n\n先安排派生类的部分 再后接基类的部分， 这样派生类D的对象指针就是指向自己数据部分的指针\n\n如果想要实现子类向父类转换呢？\n\n在vtpr指向的表中的 -1 位置放置偏移量， 由于D类对象的指针是内存开始位置 如果要转换成A类指针\n\n则从D类对象的vptr指向的表中获取A类数据部分的偏移量 这样就实现了子类向父类转换\n\n\n```c++\nclass Foo\n{\npublic:\n    int x;\n    int y;\n    int z;\n};\n\nint main()\n{\n    printf(\"&Foo::x = %p\\n\", &Foo::x);  // 0x0\n    printf(\"&Foo::y = %p\\n\", &Foo::y); // 0x4\n    printf(\"&Foo::z = %p\\n\", &Foo::z); // 0x8\n    return 0;\n}\n```\n如果x， y， z定义为protected或者private则会报错。public得到的是其在类内的偏移地址\n\n# 第四章\n\nname-mangling\n\n不要将mangling之后的结果显示给用户看，这样用户会疑惑哪里来的这个函数（大体来说 我们采纳了他的建议）\n\nstatic member func 并不是比 nonstatic member func效率高 后者也会转换成类似前者的调用。 \n\nstatic member func的主要特征就是他没有`this指针` \n- 所以它不能存取nonstatic member \n- 不能被声明为const 因为const成员函数最终转化成了 const修饰的this指针\n- 不需要通过对象来调用， 因为他不需要this指针\n\nC++中多态表示以一个public base class的指针（或reference）寻址出一个derived class object。这样就实现了多态的函数调用机制\n\n三目运算符搭配逗号运算符\n\n\n# 第五章\nvptr的初始化发生在 base class constructor调用之后，程序员提供的代码之前\n\n不要再vurtual base class中声明数据\n\nvptr会随着构造函数从基类到子类的一层层调用被改变\n同样 析构函数会逆操作 这个指针\n\n# 第六章 \n\n一般情况下 程序的构造函数我们都知道他在那里调用。 然而，析构函数呢？答案是析构函数会在函数结束的时候被调用（针对局部对象）。所以析构函数的调用代码会被穿插入每一个return 前（对象被构造后的return 被构造前的则没有必要） 尽管某些return不会被调用\n\nnew运算符只有一个步骤？ 不不不 会被扩充为 1. 先分配内存 2. 设定初值\n\ndelete运算符 则会进行检测 delete nullptr 则不会有任何效果\n\n针对对象使用new则会在分配内存后通过调用构造函数设定初始值， 而delete则会在检测nullptr后调用析构函数然后将内存归还\n\nNRV优化\n\n# 第七章\n\ntemplate， exception handling（EH）， runtime type identification（RTTI， EH的副作用？）\n\n模板类的错误发现 会直到被实例化的时候才会被发现 延迟了错误的发现时机\n\n目前的编译器，面对一个template声明，在它被一组实际参数实例化之前，只能施行有限的错误检查。template中那些与语法无关的错误，程序员可能认为十分明显，编译器却让他通过了，只有在特定实例被定义之后，运行时。才会产生错误。\n\ndynamic_cast 运算符可以在执行期间决定真正的类型。 如果downcast是安全的这个运算符会传回适当转换过的指针。如果是不安全的则返回0\ndynamic_cast同样可以对引用进行操作，成功后返回转换后的引用，失败后只能抛出异常（因为没有办法像指针那样指定nullptr表示错误）","slug":"读书记录130-深度探索C++对象模型","published":1,"updated":"2020-12-05T02:31:35.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg79003wf8un7t0j4r2y","content":"<h1 id=\"第一章-关于对象\"><a href=\"#第一章-关于对象\" class=\"headerlink\" title=\"第一章 关于对象\"></a>第一章 关于对象</h1><p>加上封装之后的成本增加了吗?</p>\n<p>并没有增加成本, C++在布局以及存取时间上主要的额外负担是由virtual引起的</p>\n<ul>\n<li>virtual func机制 用来支持一个有效率的执行期绑定</li>\n<li>virtual base class 用来实现多次出现在继承体系中的base class, 有一个单一而被共享的实例</li>\n</ul>\n<p>C++ 有两种成员变量<code>static</code>和<code>nonstatic</code><br>三种成员函数<code>static</code>, <code>nonstatic</code>和<code>virtual</code></p>\n<h1 id=\"第三章Data语义学\"><a href=\"#第三章Data语义学\" class=\"headerlink\" title=\"第三章Data语义学\"></a>第三章Data语义学</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo foo;</span><br></pre></td></tr></table></figure>\n\n<p><code>sizeof foo = ?</code>答案是1， 这是为了防止不同的对象却有相同的地址</p>\n<p>同时class也存在<code>字节对齐</code>现象</p>\n<p>在针对虚拟继承问题的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D对象的内存结构  从低地址开始</span><br><span class=\"line\"></span><br><span class=\"line\">D对象数据部分  《- D类对象指针 dptr 指向这里 可以从vptr指向的表中获取A对象数据部分的偏移量 offset</span><br><span class=\"line\">C对象数据部分</span><br><span class=\"line\">B对象数据部分</span><br><span class=\"line\">A对象数据部分  《- dptr + offset 则实现了 子类指针向父类指针的转化</span><br></pre></td></tr></table></figure>\n\n<p>A 派生出 B C。 B C派生出D  如何保证在BC对象中都有A对象， 而在D对象中只有一个A对象？</p>\n<p>一种方法是 </p>\n<p>先安排派生类的部分 再后接基类的部分， 这样派生类D的对象指针就是指向自己数据部分的指针</p>\n<p>如果想要实现子类向父类转换呢？</p>\n<p>在vtpr指向的表中的 -1 位置放置偏移量， 由于D类对象的指针是内存开始位置 如果要转换成A类指针</p>\n<p>则从D类对象的vptr指向的表中获取A类数据部分的偏移量 这样就实现了子类向父类转换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> z;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Foo::x = %p\\n\"</span>, &amp;Foo::x);  <span class=\"comment\">// 0x0</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Foo::y = %p\\n\"</span>, &amp;Foo::y); <span class=\"comment\">// 0x4</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Foo::z = %p\\n\"</span>, &amp;Foo::z); <span class=\"comment\">// 0x8</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果x， y， z定义为protected或者private则会报错。public得到的是其在类内的偏移地址</p>\n<h1 id=\"第四章\"><a href=\"#第四章\" class=\"headerlink\" title=\"第四章\"></a>第四章</h1><p>name-mangling</p>\n<p>不要将mangling之后的结果显示给用户看，这样用户会疑惑哪里来的这个函数（大体来说 我们采纳了他的建议）</p>\n<p>static member func 并不是比 nonstatic member func效率高 后者也会转换成类似前者的调用。 </p>\n<p>static member func的主要特征就是他没有<code>this指针</code> </p>\n<ul>\n<li>所以它不能存取nonstatic member </li>\n<li>不能被声明为const 因为const成员函数最终转化成了 const修饰的this指针</li>\n<li>不需要通过对象来调用， 因为他不需要this指针</li>\n</ul>\n<p>C++中多态表示以一个public base class的指针（或reference）寻址出一个derived class object。这样就实现了多态的函数调用机制</p>\n<p>三目运算符搭配逗号运算符</p>\n<h1 id=\"第五章\"><a href=\"#第五章\" class=\"headerlink\" title=\"第五章\"></a>第五章</h1><p>vptr的初始化发生在 base class constructor调用之后，程序员提供的代码之前</p>\n<p>不要再vurtual base class中声明数据</p>\n<p>vptr会随着构造函数从基类到子类的一层层调用被改变<br>同样 析构函数会逆操作 这个指针</p>\n<h1 id=\"第六章\"><a href=\"#第六章\" class=\"headerlink\" title=\"第六章\"></a>第六章</h1><p>一般情况下 程序的构造函数我们都知道他在那里调用。 然而，析构函数呢？答案是析构函数会在函数结束的时候被调用（针对局部对象）。所以析构函数的调用代码会被穿插入每一个return 前（对象被构造后的return 被构造前的则没有必要） 尽管某些return不会被调用</p>\n<p>new运算符只有一个步骤？ 不不不 会被扩充为 1. 先分配内存 2. 设定初值</p>\n<p>delete运算符 则会进行检测 delete nullptr 则不会有任何效果</p>\n<p>针对对象使用new则会在分配内存后通过调用构造函数设定初始值， 而delete则会在检测nullptr后调用析构函数然后将内存归还</p>\n<p>NRV优化</p>\n<h1 id=\"第七章\"><a href=\"#第七章\" class=\"headerlink\" title=\"第七章\"></a>第七章</h1><p>template， exception handling（EH）， runtime type identification（RTTI， EH的副作用？）</p>\n<p>模板类的错误发现 会直到被实例化的时候才会被发现 延迟了错误的发现时机</p>\n<p>目前的编译器，面对一个template声明，在它被一组实际参数实例化之前，只能施行有限的错误检查。template中那些与语法无关的错误，程序员可能认为十分明显，编译器却让他通过了，只有在特定实例被定义之后，运行时。才会产生错误。</p>\n<p>dynamic_cast 运算符可以在执行期间决定真正的类型。 如果downcast是安全的这个运算符会传回适当转换过的指针。如果是不安全的则返回0<br>dynamic_cast同样可以对引用进行操作，成功后返回转换后的引用，失败后只能抛出异常（因为没有办法像指针那样指定nullptr表示错误）</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第一章-关于对象\"><a href=\"#第一章-关于对象\" class=\"headerlink\" title=\"第一章 关于对象\"></a>第一章 关于对象</h1><p>加上封装之后的成本增加了吗?</p>\n<p>并没有增加成本, C++在布局以及存取时间上主要的额外负担是由virtual引起的</p>\n<ul>\n<li>virtual func机制 用来支持一个有效率的执行期绑定</li>\n<li>virtual base class 用来实现多次出现在继承体系中的base class, 有一个单一而被共享的实例</li>\n</ul>\n<p>C++ 有两种成员变量<code>static</code>和<code>nonstatic</code><br>三种成员函数<code>static</code>, <code>nonstatic</code>和<code>virtual</code></p>\n<h1 id=\"第三章Data语义学\"><a href=\"#第三章Data语义学\" class=\"headerlink\" title=\"第三章Data语义学\"></a>第三章Data语义学</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo foo;</span><br></pre></td></tr></table></figure>\n\n<p><code>sizeof foo = ?</code>答案是1， 这是为了防止不同的对象却有相同的地址</p>\n<p>同时class也存在<code>字节对齐</code>现象</p>\n<p>在针对虚拟继承问题的时候</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D对象的内存结构  从低地址开始</span><br><span class=\"line\"></span><br><span class=\"line\">D对象数据部分  《- D类对象指针 dptr 指向这里 可以从vptr指向的表中获取A对象数据部分的偏移量 offset</span><br><span class=\"line\">C对象数据部分</span><br><span class=\"line\">B对象数据部分</span><br><span class=\"line\">A对象数据部分  《- dptr + offset 则实现了 子类指针向父类指针的转化</span><br></pre></td></tr></table></figure>\n\n<p>A 派生出 B C。 B C派生出D  如何保证在BC对象中都有A对象， 而在D对象中只有一个A对象？</p>\n<p>一种方法是 </p>\n<p>先安排派生类的部分 再后接基类的部分， 这样派生类D的对象指针就是指向自己数据部分的指针</p>\n<p>如果想要实现子类向父类转换呢？</p>\n<p>在vtpr指向的表中的 -1 位置放置偏移量， 由于D类对象的指针是内存开始位置 如果要转换成A类指针</p>\n<p>则从D类对象的vptr指向的表中获取A类数据部分的偏移量 这样就实现了子类向父类转换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> z;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Foo::x = %p\\n\"</span>, &amp;Foo::x);  <span class=\"comment\">// 0x0</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Foo::y = %p\\n\"</span>, &amp;Foo::y); <span class=\"comment\">// 0x4</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"&amp;Foo::z = %p\\n\"</span>, &amp;Foo::z); <span class=\"comment\">// 0x8</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果x， y， z定义为protected或者private则会报错。public得到的是其在类内的偏移地址</p>\n<h1 id=\"第四章\"><a href=\"#第四章\" class=\"headerlink\" title=\"第四章\"></a>第四章</h1><p>name-mangling</p>\n<p>不要将mangling之后的结果显示给用户看，这样用户会疑惑哪里来的这个函数（大体来说 我们采纳了他的建议）</p>\n<p>static member func 并不是比 nonstatic member func效率高 后者也会转换成类似前者的调用。 </p>\n<p>static member func的主要特征就是他没有<code>this指针</code> </p>\n<ul>\n<li>所以它不能存取nonstatic member </li>\n<li>不能被声明为const 因为const成员函数最终转化成了 const修饰的this指针</li>\n<li>不需要通过对象来调用， 因为他不需要this指针</li>\n</ul>\n<p>C++中多态表示以一个public base class的指针（或reference）寻址出一个derived class object。这样就实现了多态的函数调用机制</p>\n<p>三目运算符搭配逗号运算符</p>\n<h1 id=\"第五章\"><a href=\"#第五章\" class=\"headerlink\" title=\"第五章\"></a>第五章</h1><p>vptr的初始化发生在 base class constructor调用之后，程序员提供的代码之前</p>\n<p>不要再vurtual base class中声明数据</p>\n<p>vptr会随着构造函数从基类到子类的一层层调用被改变<br>同样 析构函数会逆操作 这个指针</p>\n<h1 id=\"第六章\"><a href=\"#第六章\" class=\"headerlink\" title=\"第六章\"></a>第六章</h1><p>一般情况下 程序的构造函数我们都知道他在那里调用。 然而，析构函数呢？答案是析构函数会在函数结束的时候被调用（针对局部对象）。所以析构函数的调用代码会被穿插入每一个return 前（对象被构造后的return 被构造前的则没有必要） 尽管某些return不会被调用</p>\n<p>new运算符只有一个步骤？ 不不不 会被扩充为 1. 先分配内存 2. 设定初值</p>\n<p>delete运算符 则会进行检测 delete nullptr 则不会有任何效果</p>\n<p>针对对象使用new则会在分配内存后通过调用构造函数设定初始值， 而delete则会在检测nullptr后调用析构函数然后将内存归还</p>\n<p>NRV优化</p>\n<h1 id=\"第七章\"><a href=\"#第七章\" class=\"headerlink\" title=\"第七章\"></a>第七章</h1><p>template， exception handling（EH）， runtime type identification（RTTI， EH的副作用？）</p>\n<p>模板类的错误发现 会直到被实例化的时候才会被发现 延迟了错误的发现时机</p>\n<p>目前的编译器，面对一个template声明，在它被一组实际参数实例化之前，只能施行有限的错误检查。template中那些与语法无关的错误，程序员可能认为十分明显，编译器却让他通过了，只有在特定实例被定义之后，运行时。才会产生错误。</p>\n<p>dynamic_cast 运算符可以在执行期间决定真正的类型。 如果downcast是安全的这个运算符会传回适当转换过的指针。如果是不安全的则返回0<br>dynamic_cast同样可以对引用进行操作，成功后返回转换后的引用，失败后只能抛出异常（因为没有办法像指针那样指定nullptr表示错误）</p>\n"},{"title":"Linux多线程服务器端编程","date":"2020-03-31T09:19:39.000Z","top":120,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/cover.jpg","_content":"\nLinux高性能服务器编程基本看玩了, 现在需要进行实战练习, 然而从单纯的只会api到做出项目, 之间的距离\n不是一般的小, 最终我选择了这本书.....\n\n相关自己写的代码 大部分放在github 少部分会写在博客中\n\n# 第一部分 C++多线程系统编程\n## 第一章 线程安全的对象生命期管理\n\n一个线程安全的class需要满足的条件\n- 多个线程同时访问, 其表现出正确的行为\n- 无论操作系统如何调度这些线程, 无论这些线程的执行顺序如何交织\n- 调用端代码无需额外的同步或其他协调操作\n\n对象构造的安全, 在构造期间不要泄露this指针, 如果不按照以下规定可能会早对象构造完成前就被访问\n- 不要在构造函数中注册任何回调\n- 不要在构造函数中把this传给跨线程的对象\n- 即便在构造函数最后一行也不行, 因为对象可能是一个父类, 会先构造父类部分, 再构造子类部分\n\n二段式构造有时候可以解决上面的问题\n\n二段式构造-构造函数+initialize()\n因为构造函数没有办法告知是否构造成功, 如果使用异常处理将会使代码复杂化.\n比如在构造函数中使用new操作, 如果new操作失败就会出现不可预料的后果, 然后外部却无法知道\n再比如将this传给其他跨线程对象, 如果构造结束前传入, 可能就会发生问题\n\n\n**shared_ptr的引出**\n如果在一个对象中通过指针访问资源(另一个对象), 知道这个资源是否活着是很难的.\n如果简单的判断指针是否为空, 可能会在线程B已经判断了指针不为空还没有执行后续操作时, 线程A就把\n这个资源释放掉了\n\n当然可以通过资源管理对象 管理上面的资源, 但是也存在上面的问题.\n\n所以要想安全的销毁对象最好在其他线程都看不到的情况下偷偷进行. (垃圾回收原理, 所有人用不到的东西一定是垃圾)\n\n所以可以再资源管理对象中增加引用计数, 外部对象在释放资源管理对象中资源的时候, 只是将引用计数减一, 当引用计数为0的时候 在进行释放.\n\n\nC++可能出现的内存问题\n- 缓冲区溢出\n使用`std::vector<char>/std::string`或者自己编写`Buffer Class来管理缓冲区`. 记住缓冲区长度, 通过成员函数而不是裸指针修改缓冲区\n- 空悬指针/野指针\n使用shared_ptr/weak_ptr\n- 重复释放\n使用scoped_ptr, 只在对象析构的时候释放一次\n- 内存泄漏\n使用scoped_ptr, 对象析构时自动释放内存\n- 不配对的new[]/delete\n把new[] 统统替换成std::vector, scoped_array\n- 内存碎片\n\n使用智能指针存在的一些问题\n```c++\nclass Book\n{\npublic:\n    Book(const std::string& name) :name_(name) {}\n\n    void DoSomething() {};\nprivate:\n    std::string name_;\n};\n\nclass BookShelf\n{\npublic:\n    void Register(std::weak_ptr<Book> book)\n    {\n        books_.push_back(book);\n    }\n\n    void CheckBook()\n    {\n        // 锁争用\n        // 这里开头上锁 很可能影响其他的函数, 因为这里调用了用户提供的函数, 等待时间可能会非常长\n        // 比如Register函数就没有办法在这段时间中插入新的book\n        \n        // mutex lock 开头上锁 保护vector\n        Iterator iter = books_.begin();\n        while (iter != books_.end())\n        {\n            std::shared_ptr<Book> obj(iter->lock());\n            if (obj)\n            {\n                obj->DoSomething();\n                iter++;\n            }\n            else \n            {\n                iter = books_.erase(iter);\n            }\n        }\n    }\nprivate:\n    // 这样就强制要求了Book必须以shared_ptr管理\n    std::vector<std::weak_ptr<Book>> books_;\n    typedef std::vector<std::weak_ptr<Book>>::iterator Iterator;\n};\n```\n\n\n在对象的成员变量vector中保存shared_ptr 会导致管理的资源无法被释放, 因为引用计数最少为1.\n如果保存weak_ptr可能会导致vector只增不减, 因为weak_ptr只管自己管理的资源, 不管自己.\n通过定制shared_ptr的析构函数可以解决这个问题\n\n\n如果将某个类的this指针 bind到一个function对象, 可能在函数调用时传进入一个已经被释放的对象地址\n建议使用shared_ptr解决上面的问题, 如果想要获得this指针对应的shared_ptr, 可以另类继承\n`enable_shared_from_this<T>`, 通过在bind函数绑定`shared_from_this()返回的shared_ptr`.\n```c++\nclass BookShelf:std::enable_shared_from_this<BookShelf>\n{\npublic:\n\n    // Book对象固然可以销毁, 但是出现了轻微的内存泄漏\n    // book_只增不减!!!!. 虽然Book对象销毁了但是book_中依然保存着weak_ptr\n    // 所以需要定制析构功能\n    std::shared_ptr<Book> GetBook(const std::string &bookname)\n    {\n        std::shared_ptr<Book> pbook;\n        // 上锁\n        std::weak_ptr<Book>& wkbook = books_[bookname];\n        pbook = wkbook.lock();\n        if (!pbook)\n        {\n            // pbook.reset(new Book(bookname));\n\n            // 依然有问题 绑定this指针可能到时候this指向的对象已经不复存在了\n            // pbook.reset(new Book(bookname),\n            //   std::bind(&BookShelf::DeleteBook, this, std::placeholders::_1));\n\n            // 注意shared_from_this不能在构造函数中调用, 因为构造Bookshelf的时候 他还没有\n            // 被交给shared_ptr管理\n            pbook.reset(new Book(bookname),\n                std::bind(&BookShelf::DeleteBook, shared_from_this(), std::placeholders::_1));\n\n            wkbook = pbook;\n        }\n        return pbook;\n    }\nprivate:\n    std::map<std::string, std::weak_ptr<Book>> books_;\n\n    void DeleteBook(Book* book)\n    {\n        if (book)\n        {\n            // 上锁\n            books_.erase(book->GetName());\n        }\n        delete book;\n    }\n};\n```\n然而上面的代码依然有问题\n依然有个问题. BookShelf的生命期似乎被意外延长了, 他不会短于function对象\n所以改用weak_pr不就可以了吗\n\n```c++\nclass BookShelf:std::enable_shared_from_this<BookShelf>\n{\npublic:\n    std::shared_ptr<Book> GetBook(const std::string &bookname)\n    {\n        std::shared_ptr<Book> pbook;\n        std::weak_ptr<Book>& wkbook = books_[bookname];\n        pbook = wkbook.lock();\n        if (!pbook)\n        {\n            pbook.reset(new Book(bookname),\n                std::bind(&BookShelf::WkDeleteCallback,\n                    std::weak_ptr<BookShelf>(shared_from_this()),\n                    std::placeholders::_1));\n\n            wkbook = pbook;\n        }\n        return pbook;\n    }\nprivate:\n    std::map<std::string, std::weak_ptr<Book>> books_;\n\n    void WkDeleteCallback(const std::weak_ptr<BookShelf> wk_shelf, Book* book)\n    {\n        std::shared_ptr<BookShelf> bookshelf(wk_shelf.lock());\n        if (bookshelf)\n        {\n            DeleteBook(book);\n        }\n        delete book;\n    }\n\n    void DeleteBook(Book* book)\n    {\n        if (book)\n        {\n            // 上锁\n            books_.erase(book->GetName());\n        }\n    }\n};\n```\n\n\n\n第一章已经读完了, 笔记只有上面那点. 我在学习Linux高性能服务器编程的大二上半年时间照着书边读边写笔记, 然后后来到了大二下我改成了读完一部分后脑中有什么记什么, 重要的地方如果记不清写不出来就去再看一下. 这样花费在记笔记的时间就少了很多, 写出来的笔记更加方便自己阅读.\n\n第一章部分内容能看懂 真是谢了之前看的那个项目代码, 那个项目中大量使用了智能指针, 我在读哪个项目的代码的时候查了不少的东西, 现在才能看懂第一章的部分东西.\n然而大部分?的东西感觉还是似懂非懂, 想写又写不出什么来. 我对于智能指针的使用还是过于晚了把.\n\n第一章看来后续还要读一遍了\n\n\n## 第二章 线程同步精要\n\n**线程同步的四项原则**\n按重要性排列\n1. 最低限度的共享对象, 减少需要同步的场合, *不用就不需要同步了nice!!!*\n2. 使用高级的并发编程构建, 线程池, 队列, 倒计时\n3. 不得已使用底层同步原语时, 只使用非递归的互斥器和条件变量, 慎用读写锁, 不要用信号量\n4. 除了使用atomic整数外, 不要自己编写lock-free代码, 也不要用内核级的同步原语. 不凭空猜测\n哪种做法性能更好 比如自旋锁和互斥锁\n\n**互斥器 mutex**\n使用mutex的原则\n- 使用RAII手法封装mutex的创建销毁加锁解锁这四个操作, 不会因异常而忘记解锁\n- 只使用非递归的mutex即不可重入的mutex\n容易排查错误 使用递归mutex问题可能出现也可能不出现(可能由于逻辑问题对一个mutex加锁两次), 而使用非递归即可发现错误并改正\n- 不手工调用lock()和unlock() 函数, *一切交给栈上的Guard对象的构造和析构函数负责*\n- Gruad对象的生命期正好等于临界区\n\n次要原则\n- 不使用跨进程的mutex, 进程间通信只用TCP sockets\n- 加锁解锁在同一个线程 不会出现跨线程的操作 (RAII自动保证)\n- 不忘记解锁(包括各种提前返回和异常抛出) 不重复解锁 均由RAII自动保证\n- 必要时考虑用PTHREAD_MUTEX_ERRORCHECK来排错\n\n**封装MutexLock MutexLockGuard Condition**\n在Linux高性能服务器编程中 我也看过了封装mutex, 不过当时并没有使用RAII\n从这里开始算是对RAII(Resource Acquisition Is Initialization)有了了解\n\nhttps://zh.cppreference.com/w/cpp/language/raii\n拥有open()/close()、lock()/unlock()，或 init()/copyFrom()/destroy()成员函数的类是非RAII类的典型例子\n\nRAII将资源封装入一个类 如MutexLock类\n- 构造函数请求资源, 建立所有类不变式, 或在无法完成时抛出异常\n- 析构函数释放资源并绝不抛出异常\n始终经由RALL类的实例使用满足要求的资源如MutexLockGuard类, 资源需满足\n- 自身拥有自动存储期或临时生存期\n- 或具有与自动或临时对象的生存期绑定的生存期\n\n自己的理解就是经由RAII类生存期管理资源, RAII生存期开始即使用资源,\n当RAII类生存期结束, RAII类中保存着的资源也自动销毁\nRAII可以有效防止上面那些成对函数调用前一个后 由于异常抛出提前返回等 后一个函数没有被调用 造成资源状态异常\n\n**线程安全的Singleton实现**\n这个类在 flamingo 中也见到了, 这次是升级版\n借由pthread_once保证线程安全\n```c++\ntemplate <typename T>\nclass Singleton : noncopyable\n{\npublic:\n    static T& GetInstance()\n    {\n        pthread_once(&ponce_, Init);\n        return *value_;\n    }\nprivate:\n    Singleton();\n    ~Singleton();\n    static void Init()\n    {\n        value_ = new T();\n    }\nprivate:\n    static pthread_once_t ponce_;\n    static T *value_;\n};\ntemplate <typename T>\npthread_once_t Singleton<T>::ponce_ = PTHREAD_ONCE_INIT;\ntemplate <typename T>\nT* Singleton<T>::value_ = nullptr;\n```\n\n**copy-on-write?? copy-on-other-write!!**\n\n```c++\ntypedef std::pair<string, int> Entry;\ntypedef std::vector<Entry> EntryList;\ntypedef std::map<string, EntryList> Map;\ntypedef std::shared_ptr<Map> MapPtr;\n\nMapPtr data_;\n```\n好的现在数据存储在data_ 中 系统中存在多个读线程和一个写线程 针对data_\n如果写线程不管不顾 有数据就往data_中写入 出现了读写进程同时访问data_就会出问题.\n就书中描述来意思来说 不用大刀阔斧的使用读写锁, 能用mutex简单解决为什么要用读写锁.\n那么如何保证读写安全呢?\n\n当读进程读的时候 拷贝一次data_ data_的引用计数至少为2.\n就在这时写进程判断 data_引用计数不为1, 于是拷贝原来指向的map, 然后将data_ reset指向新的map\n这时data_引用计数变为1 可以正常写了. 而读进程中保存的map拷贝是稍久的 引用计数降为1, 执行完后就自动析构了旧数据\n\n下面的代码 读部分只在GetData中加锁, 缩小了临界区\n```c++\nMapPtr GetData() const\n{\n    // binding reference of type ‘MutexLock&’ to ‘const MutexLock’ discards qualifiers\n    MutexLockGuard lock(mutex_);\n    return data_;\n}\n\nint CustomerData::Query(const string &custmoner, const string &stock) const\n{\n    MapPtr data = GetData();\n    Map::const_iterator entries = data->find(custmoner);\n    if (entries != data->end())\n    {\n        return FindEntry(entries->second, stock);\n    }\n    else\n    {\n        return -1;\n    }\n}\n\nvoid CustomerData::Update(const string &customer, const CustomerData::EntryList &entries)\n{\n    MutexLockGuard lock(mutex_);\n    if (!data_.unique())\n    {\n        MapPtr new_data(new Map(*data_));\n        data_.swap(new_data);\n        // sawp后 先前某个线程通过GetData拿到MapPtr 他会读到稍旧的数据\n    }\n    assert(data_.unique());\n    (*data_)[customer] = entries;\n}\n```\n\n## 第三章 多线程服务器的适用场合与常用编程模型\n\n单线程服务器常用的编程模型\n`non-blocking IO + IO multiplexing` 即为`Reactor模式`\n程序的基本结构是一个事件循环, 以事件驱动和事件回调的方式实现业务逻辑\n\n本质的缺点\n要求事件回调函数必须是非阻塞的, 单线程还阻塞 这还怎么玩...\n对于涉及网络IO的请求响应式协议, 容易割裂业务逻辑, 使其散布于多个回调函数中\n\n多线程服务器常用编程模型\n1. 每个请求创建一个线程, 使用阻塞式IO操作\n2. 使用线程池, 同样是阻塞式IO操作\n3. 非阻塞IO + IO多路复用 即Java NIO方法\n4. 领导者追随者等高级模式\n\n\n推荐的C++多线程服务器端编程模式为 one (event) loop per thread + thread pool\n一个线程一个事件循环 + 线程池\n事件循环用作IO多路复用, 配合非阻塞IO和定时器\n线程池用作计算, 具体可以是任务队列或生产者消费者队列\n\n必须使用单线程的场合\n- 程序可能会fork\n- 限制程序的CPU占用率 一个线程最多占满一个核心\n\n适用多线程程序的场景\n- 有多个CPU可用, 单核机器上多线程没有性能优势\n- 线程间有共享数据, 否则建议使用 主进程+工作进程 每个进程都是单线程的模型\n- 共享数据是可以修改的. 如果数据不能修改可以进程间使用共享内存\n- 事件响应有优先级差异, 防止优先级反转\n- 程序要有相当的计算量\n- 利用异步操作\n- 能享受到增加CPU数目带来的好处\n- 多线程有有效地划分责任与功能\n\n后面大部分我都是看看就过去了, 自己没有丝毫经验 也不打算现在细看\n\n## 第四章 C++多线程系统编程精要\n\n学习多线程编程面临的最大思维方式转变\n- 当前进程随时可能被切出去\n- 多线程程序中事件的发生顺序不再有全局统一的先后关系\n\n常用的11个pthreads函数\n- pthread_create() pthread_join()\n- pthread_mutex_(create/destory/lock/unlock)\n- pthread_cond_(create/destory/wait/signal/broadcast)\n\n多线程系统编程的难点不在于学习线程原语, 而在于理解多线程与现有的C/C++库函数和系统调用的交互关系\n以进一步学习如何设计并实现线程安全且高效的程序\n\npthread_t并不适合作为程序中对线程的标识符\n- 他可能会同一进程的两个线程相同\n- 或者是不利于打印\n- 无法判断其是否非法\n- 文件系统中没有对应项\n- 脱离进程便没意义\n\n推荐使用gettid()作为线程标识符\n- 任何时刻都是全局唯一的\n- 类型为pid_t通常为一个小整数利于在日志中打印.\n- 0就是非法值1, 因为操作系统第一个进程init的pid是1\n- 在现代Linux中, 他直接表示内核的任务调度id, 容易在/proc文件系统中找到对应项\n- 在其他系统工具中也容易定位到某一个具体线程, 列如使用top按线程列出任务, \n便可以找到线程id, 再根据程序日志判断是哪一个具体线程\n\n```c++\n// .h\nextern __thread int t_cachedTid;\nvoid cacheTid();\ninline int tid()\n{\n    if (__builtin_expect(t_cachedTid == 0, 0))\n    {\n        cacheTid();\n    }\n    return t_cachedTid;\n}\n\n// .cpp\n__thread int t_cachedTid = 0;\nvoid CurrentThread::cacheTid()\n{\n    if (t_cachedTid == 0)\n    {\n        t_cachedTid = gettid();\n    }\n}\n\n// .cpp\npid_t gettid()\n{\n    return static_cast<pid_t>(::syscall(SYS_gettid));\n}\n```\n\n__thread\n只能修饰POD类型, 不能修饰class类型, 因为无法自动调用构造析构函数. 可以用于修饰全局变量函数内的静态变量.是GCC内置的线程局部存储设施，存取效率可以和全局变量相比。__thread变量每一个线程有一份独立实体，各个线程的值互不干扰.\n\n__builtin_expect\n这个指令是gcc引入的，作用是允许程序员将最有可能执行的分支告诉编译器。这个指令的写法为：__builtin_expect(EXP, N)。\n意思是：EXP==N的概率很大. 就图中代码翻译过来就是 `t_cachedTid == 0`为`0(假)`, 即为`t_cachedTid`最可能不是0.\n\n- 使用同一个class创建线程, 全局统一. 一般不会为每个网络连接创建线程, 除非并发数与cpu数目相同\n一个服务程序的线程数目应该与当前负载无关, 而应该有CPU数目有关.\n- 程序运行期间不要再创建和销毁线程, 最好在初始化的时候创建所有的线程\n\n\n线程销毁的方式\n- 正常死亡, 从线程主函数返回, 线程正常退出\n- 非正常死亡, 从线程主函数抛出异常或线程触发segfault信号等非法操作\n- 自杀 调用pthread_exit() 立刻终止线程\n- 他杀 其他线程调用pthread_cancel() 来强制终止某个线程\n\n线程只有一种正常死亡方式, 即第一种 其他方法都是错的Java中甚至把相关函数都废弃了\n\n每个文件描述符只由一个线程操作, 从而解决消息收发的顺序问题, 把一个文件描述符读写分开未必会提高性能. 同时我们不知道epoll_wait阻塞的时候, 其他线程添加新的fd会发生什么. 为了稳妥起见应该把对同一个epollfd的操作放入同一个线程中执行.\n\n\n**包装文件描述符和连接**\n用Socket对象包装文件描述符\n所有对此文件描述符的读写操作都通过此对象进行, 对象的析构函数里关闭文件描述符. 这样只要Socket对象还活着 就不会与其他Socket对象有相同的文件描述符, 也就不会发生串话. 包装文件描述符已经见过了, 同样是在flamingo中看到的.\n\n用Tcpconnection包装连接\n如果仅仅记住 fd = 8 这样的文件描述符, A线程accept后转身去处理业务B线程把 fd = 8 给关闭了!! 同时accept一个新的fd 同样是8!!. 这时A线程回复就会出现问题. 所以应该持有封装了Socket对象的Tcpconnection, 保证请求处理期间 文件描述符不会被关闭. 或者是持有Tcpconnection的弱引用. 这样就能知道 fd = 8 到底是原来的还是被关闭后新创建的. Tcpconnection对象不能提前销毁, 所以使用了shared_ptr来管理其生存期, 保证不会提前销毁造成串话.\n\n## 第五章 高效的多线程日志\n日志库大体分为前端和后端两部分, 两端之间的联系可能简单到只有一个函数\n大多数感觉都是宏命令\n\n日志的滚动也很重要 根据文件大小 和 时间 自动创建新的日志文件, 而不是全写入一个文件中\n\n避免出现正则表达的元字符(列如我最喜欢的`'['和']'`) 便于使用正则表达式查找\n\n这一章的笔记是在我照着代码实现了简单的相似功能后才写的, 记录一下好的地方\n大体分为了 LogStream类和Logger类 前者负责通过`<<`维护LogBuffer缓冲区, 后者做包装提供接口\nLogBuffer使用了简单的数组作为缓冲区, 使用Append添加内容 维护写指针\n\nLogStream重载了多种 参数情况, char和char* 很方便写入到缓冲区中\n数字则需要转化成字符串\n```c++\nLogStream& operator<<(short num);\nLogStream& operator<<(unsigned short num);\nLogStream& operator<<(int num);\nLogStream& operator<<(unsigned num);\nLogStream& operator<<(long num);\nLogStream& operator<<(unsigned long num);\nLogStream& operator<<(long long num);\nLogStream& operator<<(unsigned long long num);\n\nLogStream& operator<<(char str);\nLogStream& operator<<(const char* str);\n```\n\n转化函数, 不得不说设计的真好. 通过模板解决了多种数字类型\n```c++\nconst char digits_character[] = \"0123456789\";\n// LEARN https://www.drdobbs.com/flexible-c-1-efficient-integer-to-string/184401596\ntemplate<typename T>\nsize_t Convert(char buff[], T value)\n{\n    T i = value;\n    char* p = buff;\n    do\n    {\n        unsigned lsd = static_cast<unsigned>(i % 10);\n        i /= 10;\n        // *p++ = '0' + lsd; 不高效\n        *p++ = digits_character[lsd];\n    } while (i != 0);\n\n    if (value < 0)\n    {\n        *p++ = '-';\n    }\n    *p = '\\0';\n\n    // LEARN 原文中是从buff最后一个字节开始写入 但是这里需要从开头写入 所以改为倒置一下\n    std::reverse(buff, p);\n    return p - buff;\n}\n\ntemplate<typename T>\nvoid LogStream::FormatInteger(T t)\n{\n    if (buffer_.WriteableBytes() > MAX_NUMBER_SIZE)\n    {\n        size_t len = Convert(buffer_.WritePeek(), t);\n        buffer_.MoveWritePeek(len);\n    }\n}\n```\n将格式化也单独出了一个类\n```c++\nclass Fmt\n{\npublic:\n    template<typename T>\n    Fmt(const char* fmt, T val);\n\n    const char* GetData() const\n    {\n        return buff_;\n    }\n    int GetLength() const\n    {\n        return length_;\n    }\n\nprivate:\n    char buff_[32];\n    size_t length_;\n};\n\ntemplate<typename T>\nFmt::Fmt(const char* fmt, T val)\n{\n    static_assert(std::is_arithmetic<T>::value == true, \"Must be arithmetic type\");\n    length_ = snprintf(buff_, sizeof buff_, fmt, val);\n    assert(length_ < sizeof buff_);\n}\n```\n\nLogger类的设计\n方便了日志的打印, 实现了高效的转换\n```c++\nenum LogLevel\n{\n    DEBUG,\n    INFO,\n    WARN,\n    ERROR,\n    FATAL,\n    NUM_LOG_LEVELS /* 仅用于表示LogLevel元素个数 不做实际使用 */\n};\n// LEARN 处处保持长度一致 使用NUM_LOG_LEVELS表示大小\nconst char* LogLevelName[Logger::NUM_LOG_LEVELS] =\n{\n    \"DEBUG \",\n    \"INFO  \",\n    \"WARN  \",\n    \"ERROR \",\n    \"FATAL \",\n};\n```\n字符串指针包装类, 减少strlen的调用 或者字符串没有终止\n```c++\n// LEARN 临时包装字符串指针和长度\nclass T\n{\npublic:\n\n    T(const char* str, size_t len):\n    str_(str),\n    len_(len)\n    {\n        assert(strlen(str) == len);\n    }\n\n    const char* str_;\n    const size_t len_;\n};\n```\n使用内部类Impl包装了LogStream LogStream负责的是单纯的维护缓冲区 重载各种运算符.\nImpl的构造函数输出了日志前边的固定部分\nLogger的构造函数负责根据有无函数名等重载输出额外的固定内容\n构造和析构之间完成 纯用户自定义部分输出\nLogger的析构函数负责输出每条日志的结尾部分 文件名和行号\n```c++\nclass Impl\n{\npublic:\n    typedef Logger::LogLevel LogLevel;\n    Impl(LogLevel level, const SourceFile& file, int line);\n    void FormatTime();\n    void Finish();\n\n    Timestamp time_;\n    LogStream stream_;\n    LogLevel level_;\n    SourceFile filename_;\n    int line_;\n};\n```\n内部类SourceFile负责将`__FILE__`宏产生的字符数组转换成单纯的文件名. 使用了数组引用\n```c++\nclass SourceFile\n{\npublic:\n    /**\n        * 数组的引用 使数组在传参时不会降为 指针\n        */\n    template<int N>\n    SourceFile(const char (&arr)[N]):\n    data_(arr),\n    size_(N - 1)\n    {\n        const char* name = strrchr(data_, '/'); /* /name */\n        if (name)\n        {\n            data_ = name + 1;\n            size_ -= static_cast<int>(data_ - arr);\n        }\n    }\n\n    const char* data_;\n    int size_;\n};\n```\n\n其他高效设计\n```c++\n// LEARN 缓存上一次输出的秒 同一秒输出时避免多次格式化\n// 同一秒输出仅仅格式化 微秒部分\n__thread char t_time[64];\n__thread time_t t_last_second;\n```\n\n# 第二部分 muduo网络库\n## 第六章 muduo网络库简介\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/ClassDiagram.png)\n\n看完前面的一小部分, 我真心觉得这个库跟之前那个flamingo特别像, 估计这种管理方式就是某种主流方式?\n估计我以后自己写的时候也是会按照这个模式来写了吧\n\nTCP网络编程最本质的是处理三个半事件\n- 连接的建立\n- 连接断开 主动断开close 被动断开 read返回0\n- 消息到达, 文件描述符可读. 最为重要的一个事件, 对它的处理方式决定了网络编程的风格.(阻塞还是非阻塞, 如何处理分包, 应用层缓冲如何设计)\n- 消息发送完毕 这算半个\n\n现在存在的问题\n- 如果保证发送完应用层缓冲区数据才断开连接\n自己思考的可以设立标志位, 如果设置了标志位发送完成后检测标志位 关闭连接\n- 如果要主动发起连接, 但是对方主动拒绝, 如何定期重试\n按照TCP重试机制 发送SYN 开启定时器 如果定时内没有收到确认ACK则重发SYN\n\n\n这里了解到一个词 前向声明,\n在程序设计中，前向声明（Forward Declaration）是指声明标识符(表示编程的实体，如数据类型、变量、函数)时还没有给出完整的定义。\n通常为了简化头文件的关系 可以在A的头文件中 声明`class B`, 这样在你的代码中就可以使用`B*`而不需要引入B的头文件\n\n## 第七章 muduo编程示例\n\n本章大部分都是实战小例子, 自然要在代码中注释了.\n博客这里就简单写一写\n**关于`input buffer`和`output buffer`已经有所了解过**\n\n`output buffer`在`write`调用一次没有发送完全的时候起到大用途. 一次没有发送完不应该等待在那里, 应该是接管这些未发送的数据, 阻塞代价是很大的. 应该是注册`EPILOUT`事件, 直到数据全部发送完毕. 否则就一直注册事件, 当然这是在连接正常的时候.\n使用`output buffer`还有一个小问题, 一般情况下一次发送未完成才会使用到`output buffer`. 当缓冲区中存在数据的时候. 下一次的数据不能进行发送, 而应该是直接追加到尾部.\n\n`input buffer`某种意义上作用更大, 这涉及到一个重要概念\"粘包\"的处理. \n\n这里我了解到了`capacity()`机制, 可以用来减少内存分配次数. `capacity()`代表预分配的内存大小,\n而`size()`是你写入的数据大小, 当`size == capacity`的时候`再写入内容`内存会分配更长的一个数组将旧数据拷贝过去`size()`依然是你写入的大小, `capacity()`则会变大\n```c++\nstd::vector<char> buff(20); // 填充了20个元素 0\nvoid Foo(size_t size)\n{\n    buff.resize(size);\n    printf(\"%ld %ld\\n\", buff.size(), buff.capacity());\n}\nint main()\n{\n    printf(\"%ld %ld\\n\", buff.size(), buff.capacity()); // 20 20\n    Foo(512); // 512 512\n    Foo(1024); // 1024 1024\n    Foo(1025); // 1025 2048\n    Foo(2048); // 2048 2048\n    Foo(2049); // 2049 4096\n}\n```\n\n花了小半天时间去了解配置了下 protobuf, 是一把很锋利的剑不错!\n\n网络编程中使用protobuf的两个先决条件\n- 长度问题, protobuf打包的数据没有自带长度信息或终结符, 这就需要程序自己在发送和接受的时候做正确的切分\n- 类型问题, protobuf打包的数据没有自带类型信息, 需要由发送方把类型信息传给接收方, 接收方创建对应的具体protobuf message对象, 再做反序列化\n\n我第一印象解决上面的方法, 就如书中所言是山寨的做法.... 增加header部分\n\n![Protobuf类图](https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/protobuf%20class.png)\n\n大概意思就是大部分人通过在头部增加代号标识消息类型(具体对应那个message), 而protobuf提供了\n根据反射 根据typename 选择对应的Message对象的功能, 由于我没有用过protobuf 目前不是很了解 不过大概就这样了, 后续会专门学习 先用即可\n```c++\n// eg typename=muduo.Query\ngoogle::protobuf::Message* ProtobufCodec::createMessage(const std::string& typeName)\n{\n    google::protobuf::Message* message = nullptr;\n    const google::protobuf::Descriptor* descriptor =\n        google::protobuf::DescriptorPool::generated_pool()->FindMessageTypeByName(typeName);\n    if (descriptor)\n    {\n        const google::protobuf::Message* prototype =\n            google::protobuf::MessageFactory::generated_factory()->GetPrototype(descriptor);\n        if (prototype)\n        {\n            message = prototype->New(); // 返回的是动态创建的指针\n        }\n    }\n    return message;\n}\n\ntypedef std::shared_ptr<google::protobuf::Message> MessagePtr;\nMessagePtr message;\nmessage.reset(createMessage(typeName)); // 接管指针\n```\n\n作者设计的格式如下\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/protobuf%E4%BC%A0%E8%BE%93%E6%A0%BC%E5%BC%8F.png)\n\n```c++\nstruct Foo\n{\n    // int32_t version; 根本不需要版本号\n    int32_t len; // 没有使用uin32_t 是为了跨语言, Java没有unsigned\n    int32_t namelen;\n    char type_name[namelen]; // 以 /0 结尾 方便接收方处理 节省strlen() 空间换时间\n    char protobuf_data[len-namelen-8]\n    int32_t checksum; // adler32算法 进行校验\n}\n```\n\n终于知道编码器解码器合起来叫什么了... 编解码器(codec)\n\n后面的一些例子就跳过了, 去准备阅读第八章然后动手写库了 这里才是重点 至于例子当时候自己再写.\n自己的库不香吗?\n\n## 第八章 muduo网路库设计与实现\n~~第八章从第0节开始 一看就是程序员~~\n\n2020年4月27日11:02:12 距离写完上一行博客已经过去不短的时间了.\n这段时间我仿照muduo从中抽了部分功能做了自己的mongo库, 然后我将muduo Protobuf作为附属\n改成了ProtobufServer(包装了TcpServer).\n\n之后我便重新编写UE4部分的Protobuf收发部分的代码.\n昨天晚上总算是将UE4打飞机的单机版 成功改造成了联机版. 使用的帧同步\n服务器稳定性极佳, 而且内存占用很低, 想到了我之前写的Java服务器. 服务器CPU性能占用极少.\n\n初期设计的时候 单机每秒发送12包, 每包平均0.16kb. 单机每秒就是2kb.  如果有6个客户端\n服务器算上广播 出站流量 72kb/s\n\n跑了下iftop看了下基本是这样.\n12*6 = 72kb/s\n\n阿里云送的服务器1Mbps, 理论可以支持8个客户端同屏游戏\n阿里云学生机5Mbps, 理论支持17个客户端同屏游戏\n\n当然了现在只同步了输入, 不过其他同步内容消耗的流量就很少了.\n\n服务器程序运行良好, 倒是UE4 偶尔会崩....\n\n后面慢慢完善打飞机和服务器\n\n使用框架很简单的就实现了 登录和游玩数据分开 很舒服. 当然了登录目前只是个摆设没有在服务端保存\n跳过登录依然可以玩, 后面完善db服务器再说\n\n\n# 第三部分 工程实践经验谈\n## 第九章 分布式 跳过\n\n## 第十章 C++编译链接模型精要","source":"_posts/读书记录120-Linux多线程服务器.md","raw":"---\ntitle: Linux多线程服务器端编程\ntags:\n  - null\ncategories:\n  - 读书记录\ndate: 2020-03-31 17:19:39\n\ntop: 120\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/cover.jpg\n---\n\nLinux高性能服务器编程基本看玩了, 现在需要进行实战练习, 然而从单纯的只会api到做出项目, 之间的距离\n不是一般的小, 最终我选择了这本书.....\n\n相关自己写的代码 大部分放在github 少部分会写在博客中\n\n# 第一部分 C++多线程系统编程\n## 第一章 线程安全的对象生命期管理\n\n一个线程安全的class需要满足的条件\n- 多个线程同时访问, 其表现出正确的行为\n- 无论操作系统如何调度这些线程, 无论这些线程的执行顺序如何交织\n- 调用端代码无需额外的同步或其他协调操作\n\n对象构造的安全, 在构造期间不要泄露this指针, 如果不按照以下规定可能会早对象构造完成前就被访问\n- 不要在构造函数中注册任何回调\n- 不要在构造函数中把this传给跨线程的对象\n- 即便在构造函数最后一行也不行, 因为对象可能是一个父类, 会先构造父类部分, 再构造子类部分\n\n二段式构造有时候可以解决上面的问题\n\n二段式构造-构造函数+initialize()\n因为构造函数没有办法告知是否构造成功, 如果使用异常处理将会使代码复杂化.\n比如在构造函数中使用new操作, 如果new操作失败就会出现不可预料的后果, 然后外部却无法知道\n再比如将this传给其他跨线程对象, 如果构造结束前传入, 可能就会发生问题\n\n\n**shared_ptr的引出**\n如果在一个对象中通过指针访问资源(另一个对象), 知道这个资源是否活着是很难的.\n如果简单的判断指针是否为空, 可能会在线程B已经判断了指针不为空还没有执行后续操作时, 线程A就把\n这个资源释放掉了\n\n当然可以通过资源管理对象 管理上面的资源, 但是也存在上面的问题.\n\n所以要想安全的销毁对象最好在其他线程都看不到的情况下偷偷进行. (垃圾回收原理, 所有人用不到的东西一定是垃圾)\n\n所以可以再资源管理对象中增加引用计数, 外部对象在释放资源管理对象中资源的时候, 只是将引用计数减一, 当引用计数为0的时候 在进行释放.\n\n\nC++可能出现的内存问题\n- 缓冲区溢出\n使用`std::vector<char>/std::string`或者自己编写`Buffer Class来管理缓冲区`. 记住缓冲区长度, 通过成员函数而不是裸指针修改缓冲区\n- 空悬指针/野指针\n使用shared_ptr/weak_ptr\n- 重复释放\n使用scoped_ptr, 只在对象析构的时候释放一次\n- 内存泄漏\n使用scoped_ptr, 对象析构时自动释放内存\n- 不配对的new[]/delete\n把new[] 统统替换成std::vector, scoped_array\n- 内存碎片\n\n使用智能指针存在的一些问题\n```c++\nclass Book\n{\npublic:\n    Book(const std::string& name) :name_(name) {}\n\n    void DoSomething() {};\nprivate:\n    std::string name_;\n};\n\nclass BookShelf\n{\npublic:\n    void Register(std::weak_ptr<Book> book)\n    {\n        books_.push_back(book);\n    }\n\n    void CheckBook()\n    {\n        // 锁争用\n        // 这里开头上锁 很可能影响其他的函数, 因为这里调用了用户提供的函数, 等待时间可能会非常长\n        // 比如Register函数就没有办法在这段时间中插入新的book\n        \n        // mutex lock 开头上锁 保护vector\n        Iterator iter = books_.begin();\n        while (iter != books_.end())\n        {\n            std::shared_ptr<Book> obj(iter->lock());\n            if (obj)\n            {\n                obj->DoSomething();\n                iter++;\n            }\n            else \n            {\n                iter = books_.erase(iter);\n            }\n        }\n    }\nprivate:\n    // 这样就强制要求了Book必须以shared_ptr管理\n    std::vector<std::weak_ptr<Book>> books_;\n    typedef std::vector<std::weak_ptr<Book>>::iterator Iterator;\n};\n```\n\n\n在对象的成员变量vector中保存shared_ptr 会导致管理的资源无法被释放, 因为引用计数最少为1.\n如果保存weak_ptr可能会导致vector只增不减, 因为weak_ptr只管自己管理的资源, 不管自己.\n通过定制shared_ptr的析构函数可以解决这个问题\n\n\n如果将某个类的this指针 bind到一个function对象, 可能在函数调用时传进入一个已经被释放的对象地址\n建议使用shared_ptr解决上面的问题, 如果想要获得this指针对应的shared_ptr, 可以另类继承\n`enable_shared_from_this<T>`, 通过在bind函数绑定`shared_from_this()返回的shared_ptr`.\n```c++\nclass BookShelf:std::enable_shared_from_this<BookShelf>\n{\npublic:\n\n    // Book对象固然可以销毁, 但是出现了轻微的内存泄漏\n    // book_只增不减!!!!. 虽然Book对象销毁了但是book_中依然保存着weak_ptr\n    // 所以需要定制析构功能\n    std::shared_ptr<Book> GetBook(const std::string &bookname)\n    {\n        std::shared_ptr<Book> pbook;\n        // 上锁\n        std::weak_ptr<Book>& wkbook = books_[bookname];\n        pbook = wkbook.lock();\n        if (!pbook)\n        {\n            // pbook.reset(new Book(bookname));\n\n            // 依然有问题 绑定this指针可能到时候this指向的对象已经不复存在了\n            // pbook.reset(new Book(bookname),\n            //   std::bind(&BookShelf::DeleteBook, this, std::placeholders::_1));\n\n            // 注意shared_from_this不能在构造函数中调用, 因为构造Bookshelf的时候 他还没有\n            // 被交给shared_ptr管理\n            pbook.reset(new Book(bookname),\n                std::bind(&BookShelf::DeleteBook, shared_from_this(), std::placeholders::_1));\n\n            wkbook = pbook;\n        }\n        return pbook;\n    }\nprivate:\n    std::map<std::string, std::weak_ptr<Book>> books_;\n\n    void DeleteBook(Book* book)\n    {\n        if (book)\n        {\n            // 上锁\n            books_.erase(book->GetName());\n        }\n        delete book;\n    }\n};\n```\n然而上面的代码依然有问题\n依然有个问题. BookShelf的生命期似乎被意外延长了, 他不会短于function对象\n所以改用weak_pr不就可以了吗\n\n```c++\nclass BookShelf:std::enable_shared_from_this<BookShelf>\n{\npublic:\n    std::shared_ptr<Book> GetBook(const std::string &bookname)\n    {\n        std::shared_ptr<Book> pbook;\n        std::weak_ptr<Book>& wkbook = books_[bookname];\n        pbook = wkbook.lock();\n        if (!pbook)\n        {\n            pbook.reset(new Book(bookname),\n                std::bind(&BookShelf::WkDeleteCallback,\n                    std::weak_ptr<BookShelf>(shared_from_this()),\n                    std::placeholders::_1));\n\n            wkbook = pbook;\n        }\n        return pbook;\n    }\nprivate:\n    std::map<std::string, std::weak_ptr<Book>> books_;\n\n    void WkDeleteCallback(const std::weak_ptr<BookShelf> wk_shelf, Book* book)\n    {\n        std::shared_ptr<BookShelf> bookshelf(wk_shelf.lock());\n        if (bookshelf)\n        {\n            DeleteBook(book);\n        }\n        delete book;\n    }\n\n    void DeleteBook(Book* book)\n    {\n        if (book)\n        {\n            // 上锁\n            books_.erase(book->GetName());\n        }\n    }\n};\n```\n\n\n\n第一章已经读完了, 笔记只有上面那点. 我在学习Linux高性能服务器编程的大二上半年时间照着书边读边写笔记, 然后后来到了大二下我改成了读完一部分后脑中有什么记什么, 重要的地方如果记不清写不出来就去再看一下. 这样花费在记笔记的时间就少了很多, 写出来的笔记更加方便自己阅读.\n\n第一章部分内容能看懂 真是谢了之前看的那个项目代码, 那个项目中大量使用了智能指针, 我在读哪个项目的代码的时候查了不少的东西, 现在才能看懂第一章的部分东西.\n然而大部分?的东西感觉还是似懂非懂, 想写又写不出什么来. 我对于智能指针的使用还是过于晚了把.\n\n第一章看来后续还要读一遍了\n\n\n## 第二章 线程同步精要\n\n**线程同步的四项原则**\n按重要性排列\n1. 最低限度的共享对象, 减少需要同步的场合, *不用就不需要同步了nice!!!*\n2. 使用高级的并发编程构建, 线程池, 队列, 倒计时\n3. 不得已使用底层同步原语时, 只使用非递归的互斥器和条件变量, 慎用读写锁, 不要用信号量\n4. 除了使用atomic整数外, 不要自己编写lock-free代码, 也不要用内核级的同步原语. 不凭空猜测\n哪种做法性能更好 比如自旋锁和互斥锁\n\n**互斥器 mutex**\n使用mutex的原则\n- 使用RAII手法封装mutex的创建销毁加锁解锁这四个操作, 不会因异常而忘记解锁\n- 只使用非递归的mutex即不可重入的mutex\n容易排查错误 使用递归mutex问题可能出现也可能不出现(可能由于逻辑问题对一个mutex加锁两次), 而使用非递归即可发现错误并改正\n- 不手工调用lock()和unlock() 函数, *一切交给栈上的Guard对象的构造和析构函数负责*\n- Gruad对象的生命期正好等于临界区\n\n次要原则\n- 不使用跨进程的mutex, 进程间通信只用TCP sockets\n- 加锁解锁在同一个线程 不会出现跨线程的操作 (RAII自动保证)\n- 不忘记解锁(包括各种提前返回和异常抛出) 不重复解锁 均由RAII自动保证\n- 必要时考虑用PTHREAD_MUTEX_ERRORCHECK来排错\n\n**封装MutexLock MutexLockGuard Condition**\n在Linux高性能服务器编程中 我也看过了封装mutex, 不过当时并没有使用RAII\n从这里开始算是对RAII(Resource Acquisition Is Initialization)有了了解\n\nhttps://zh.cppreference.com/w/cpp/language/raii\n拥有open()/close()、lock()/unlock()，或 init()/copyFrom()/destroy()成员函数的类是非RAII类的典型例子\n\nRAII将资源封装入一个类 如MutexLock类\n- 构造函数请求资源, 建立所有类不变式, 或在无法完成时抛出异常\n- 析构函数释放资源并绝不抛出异常\n始终经由RALL类的实例使用满足要求的资源如MutexLockGuard类, 资源需满足\n- 自身拥有自动存储期或临时生存期\n- 或具有与自动或临时对象的生存期绑定的生存期\n\n自己的理解就是经由RAII类生存期管理资源, RAII生存期开始即使用资源,\n当RAII类生存期结束, RAII类中保存着的资源也自动销毁\nRAII可以有效防止上面那些成对函数调用前一个后 由于异常抛出提前返回等 后一个函数没有被调用 造成资源状态异常\n\n**线程安全的Singleton实现**\n这个类在 flamingo 中也见到了, 这次是升级版\n借由pthread_once保证线程安全\n```c++\ntemplate <typename T>\nclass Singleton : noncopyable\n{\npublic:\n    static T& GetInstance()\n    {\n        pthread_once(&ponce_, Init);\n        return *value_;\n    }\nprivate:\n    Singleton();\n    ~Singleton();\n    static void Init()\n    {\n        value_ = new T();\n    }\nprivate:\n    static pthread_once_t ponce_;\n    static T *value_;\n};\ntemplate <typename T>\npthread_once_t Singleton<T>::ponce_ = PTHREAD_ONCE_INIT;\ntemplate <typename T>\nT* Singleton<T>::value_ = nullptr;\n```\n\n**copy-on-write?? copy-on-other-write!!**\n\n```c++\ntypedef std::pair<string, int> Entry;\ntypedef std::vector<Entry> EntryList;\ntypedef std::map<string, EntryList> Map;\ntypedef std::shared_ptr<Map> MapPtr;\n\nMapPtr data_;\n```\n好的现在数据存储在data_ 中 系统中存在多个读线程和一个写线程 针对data_\n如果写线程不管不顾 有数据就往data_中写入 出现了读写进程同时访问data_就会出问题.\n就书中描述来意思来说 不用大刀阔斧的使用读写锁, 能用mutex简单解决为什么要用读写锁.\n那么如何保证读写安全呢?\n\n当读进程读的时候 拷贝一次data_ data_的引用计数至少为2.\n就在这时写进程判断 data_引用计数不为1, 于是拷贝原来指向的map, 然后将data_ reset指向新的map\n这时data_引用计数变为1 可以正常写了. 而读进程中保存的map拷贝是稍久的 引用计数降为1, 执行完后就自动析构了旧数据\n\n下面的代码 读部分只在GetData中加锁, 缩小了临界区\n```c++\nMapPtr GetData() const\n{\n    // binding reference of type ‘MutexLock&’ to ‘const MutexLock’ discards qualifiers\n    MutexLockGuard lock(mutex_);\n    return data_;\n}\n\nint CustomerData::Query(const string &custmoner, const string &stock) const\n{\n    MapPtr data = GetData();\n    Map::const_iterator entries = data->find(custmoner);\n    if (entries != data->end())\n    {\n        return FindEntry(entries->second, stock);\n    }\n    else\n    {\n        return -1;\n    }\n}\n\nvoid CustomerData::Update(const string &customer, const CustomerData::EntryList &entries)\n{\n    MutexLockGuard lock(mutex_);\n    if (!data_.unique())\n    {\n        MapPtr new_data(new Map(*data_));\n        data_.swap(new_data);\n        // sawp后 先前某个线程通过GetData拿到MapPtr 他会读到稍旧的数据\n    }\n    assert(data_.unique());\n    (*data_)[customer] = entries;\n}\n```\n\n## 第三章 多线程服务器的适用场合与常用编程模型\n\n单线程服务器常用的编程模型\n`non-blocking IO + IO multiplexing` 即为`Reactor模式`\n程序的基本结构是一个事件循环, 以事件驱动和事件回调的方式实现业务逻辑\n\n本质的缺点\n要求事件回调函数必须是非阻塞的, 单线程还阻塞 这还怎么玩...\n对于涉及网络IO的请求响应式协议, 容易割裂业务逻辑, 使其散布于多个回调函数中\n\n多线程服务器常用编程模型\n1. 每个请求创建一个线程, 使用阻塞式IO操作\n2. 使用线程池, 同样是阻塞式IO操作\n3. 非阻塞IO + IO多路复用 即Java NIO方法\n4. 领导者追随者等高级模式\n\n\n推荐的C++多线程服务器端编程模式为 one (event) loop per thread + thread pool\n一个线程一个事件循环 + 线程池\n事件循环用作IO多路复用, 配合非阻塞IO和定时器\n线程池用作计算, 具体可以是任务队列或生产者消费者队列\n\n必须使用单线程的场合\n- 程序可能会fork\n- 限制程序的CPU占用率 一个线程最多占满一个核心\n\n适用多线程程序的场景\n- 有多个CPU可用, 单核机器上多线程没有性能优势\n- 线程间有共享数据, 否则建议使用 主进程+工作进程 每个进程都是单线程的模型\n- 共享数据是可以修改的. 如果数据不能修改可以进程间使用共享内存\n- 事件响应有优先级差异, 防止优先级反转\n- 程序要有相当的计算量\n- 利用异步操作\n- 能享受到增加CPU数目带来的好处\n- 多线程有有效地划分责任与功能\n\n后面大部分我都是看看就过去了, 自己没有丝毫经验 也不打算现在细看\n\n## 第四章 C++多线程系统编程精要\n\n学习多线程编程面临的最大思维方式转变\n- 当前进程随时可能被切出去\n- 多线程程序中事件的发生顺序不再有全局统一的先后关系\n\n常用的11个pthreads函数\n- pthread_create() pthread_join()\n- pthread_mutex_(create/destory/lock/unlock)\n- pthread_cond_(create/destory/wait/signal/broadcast)\n\n多线程系统编程的难点不在于学习线程原语, 而在于理解多线程与现有的C/C++库函数和系统调用的交互关系\n以进一步学习如何设计并实现线程安全且高效的程序\n\npthread_t并不适合作为程序中对线程的标识符\n- 他可能会同一进程的两个线程相同\n- 或者是不利于打印\n- 无法判断其是否非法\n- 文件系统中没有对应项\n- 脱离进程便没意义\n\n推荐使用gettid()作为线程标识符\n- 任何时刻都是全局唯一的\n- 类型为pid_t通常为一个小整数利于在日志中打印.\n- 0就是非法值1, 因为操作系统第一个进程init的pid是1\n- 在现代Linux中, 他直接表示内核的任务调度id, 容易在/proc文件系统中找到对应项\n- 在其他系统工具中也容易定位到某一个具体线程, 列如使用top按线程列出任务, \n便可以找到线程id, 再根据程序日志判断是哪一个具体线程\n\n```c++\n// .h\nextern __thread int t_cachedTid;\nvoid cacheTid();\ninline int tid()\n{\n    if (__builtin_expect(t_cachedTid == 0, 0))\n    {\n        cacheTid();\n    }\n    return t_cachedTid;\n}\n\n// .cpp\n__thread int t_cachedTid = 0;\nvoid CurrentThread::cacheTid()\n{\n    if (t_cachedTid == 0)\n    {\n        t_cachedTid = gettid();\n    }\n}\n\n// .cpp\npid_t gettid()\n{\n    return static_cast<pid_t>(::syscall(SYS_gettid));\n}\n```\n\n__thread\n只能修饰POD类型, 不能修饰class类型, 因为无法自动调用构造析构函数. 可以用于修饰全局变量函数内的静态变量.是GCC内置的线程局部存储设施，存取效率可以和全局变量相比。__thread变量每一个线程有一份独立实体，各个线程的值互不干扰.\n\n__builtin_expect\n这个指令是gcc引入的，作用是允许程序员将最有可能执行的分支告诉编译器。这个指令的写法为：__builtin_expect(EXP, N)。\n意思是：EXP==N的概率很大. 就图中代码翻译过来就是 `t_cachedTid == 0`为`0(假)`, 即为`t_cachedTid`最可能不是0.\n\n- 使用同一个class创建线程, 全局统一. 一般不会为每个网络连接创建线程, 除非并发数与cpu数目相同\n一个服务程序的线程数目应该与当前负载无关, 而应该有CPU数目有关.\n- 程序运行期间不要再创建和销毁线程, 最好在初始化的时候创建所有的线程\n\n\n线程销毁的方式\n- 正常死亡, 从线程主函数返回, 线程正常退出\n- 非正常死亡, 从线程主函数抛出异常或线程触发segfault信号等非法操作\n- 自杀 调用pthread_exit() 立刻终止线程\n- 他杀 其他线程调用pthread_cancel() 来强制终止某个线程\n\n线程只有一种正常死亡方式, 即第一种 其他方法都是错的Java中甚至把相关函数都废弃了\n\n每个文件描述符只由一个线程操作, 从而解决消息收发的顺序问题, 把一个文件描述符读写分开未必会提高性能. 同时我们不知道epoll_wait阻塞的时候, 其他线程添加新的fd会发生什么. 为了稳妥起见应该把对同一个epollfd的操作放入同一个线程中执行.\n\n\n**包装文件描述符和连接**\n用Socket对象包装文件描述符\n所有对此文件描述符的读写操作都通过此对象进行, 对象的析构函数里关闭文件描述符. 这样只要Socket对象还活着 就不会与其他Socket对象有相同的文件描述符, 也就不会发生串话. 包装文件描述符已经见过了, 同样是在flamingo中看到的.\n\n用Tcpconnection包装连接\n如果仅仅记住 fd = 8 这样的文件描述符, A线程accept后转身去处理业务B线程把 fd = 8 给关闭了!! 同时accept一个新的fd 同样是8!!. 这时A线程回复就会出现问题. 所以应该持有封装了Socket对象的Tcpconnection, 保证请求处理期间 文件描述符不会被关闭. 或者是持有Tcpconnection的弱引用. 这样就能知道 fd = 8 到底是原来的还是被关闭后新创建的. Tcpconnection对象不能提前销毁, 所以使用了shared_ptr来管理其生存期, 保证不会提前销毁造成串话.\n\n## 第五章 高效的多线程日志\n日志库大体分为前端和后端两部分, 两端之间的联系可能简单到只有一个函数\n大多数感觉都是宏命令\n\n日志的滚动也很重要 根据文件大小 和 时间 自动创建新的日志文件, 而不是全写入一个文件中\n\n避免出现正则表达的元字符(列如我最喜欢的`'['和']'`) 便于使用正则表达式查找\n\n这一章的笔记是在我照着代码实现了简单的相似功能后才写的, 记录一下好的地方\n大体分为了 LogStream类和Logger类 前者负责通过`<<`维护LogBuffer缓冲区, 后者做包装提供接口\nLogBuffer使用了简单的数组作为缓冲区, 使用Append添加内容 维护写指针\n\nLogStream重载了多种 参数情况, char和char* 很方便写入到缓冲区中\n数字则需要转化成字符串\n```c++\nLogStream& operator<<(short num);\nLogStream& operator<<(unsigned short num);\nLogStream& operator<<(int num);\nLogStream& operator<<(unsigned num);\nLogStream& operator<<(long num);\nLogStream& operator<<(unsigned long num);\nLogStream& operator<<(long long num);\nLogStream& operator<<(unsigned long long num);\n\nLogStream& operator<<(char str);\nLogStream& operator<<(const char* str);\n```\n\n转化函数, 不得不说设计的真好. 通过模板解决了多种数字类型\n```c++\nconst char digits_character[] = \"0123456789\";\n// LEARN https://www.drdobbs.com/flexible-c-1-efficient-integer-to-string/184401596\ntemplate<typename T>\nsize_t Convert(char buff[], T value)\n{\n    T i = value;\n    char* p = buff;\n    do\n    {\n        unsigned lsd = static_cast<unsigned>(i % 10);\n        i /= 10;\n        // *p++ = '0' + lsd; 不高效\n        *p++ = digits_character[lsd];\n    } while (i != 0);\n\n    if (value < 0)\n    {\n        *p++ = '-';\n    }\n    *p = '\\0';\n\n    // LEARN 原文中是从buff最后一个字节开始写入 但是这里需要从开头写入 所以改为倒置一下\n    std::reverse(buff, p);\n    return p - buff;\n}\n\ntemplate<typename T>\nvoid LogStream::FormatInteger(T t)\n{\n    if (buffer_.WriteableBytes() > MAX_NUMBER_SIZE)\n    {\n        size_t len = Convert(buffer_.WritePeek(), t);\n        buffer_.MoveWritePeek(len);\n    }\n}\n```\n将格式化也单独出了一个类\n```c++\nclass Fmt\n{\npublic:\n    template<typename T>\n    Fmt(const char* fmt, T val);\n\n    const char* GetData() const\n    {\n        return buff_;\n    }\n    int GetLength() const\n    {\n        return length_;\n    }\n\nprivate:\n    char buff_[32];\n    size_t length_;\n};\n\ntemplate<typename T>\nFmt::Fmt(const char* fmt, T val)\n{\n    static_assert(std::is_arithmetic<T>::value == true, \"Must be arithmetic type\");\n    length_ = snprintf(buff_, sizeof buff_, fmt, val);\n    assert(length_ < sizeof buff_);\n}\n```\n\nLogger类的设计\n方便了日志的打印, 实现了高效的转换\n```c++\nenum LogLevel\n{\n    DEBUG,\n    INFO,\n    WARN,\n    ERROR,\n    FATAL,\n    NUM_LOG_LEVELS /* 仅用于表示LogLevel元素个数 不做实际使用 */\n};\n// LEARN 处处保持长度一致 使用NUM_LOG_LEVELS表示大小\nconst char* LogLevelName[Logger::NUM_LOG_LEVELS] =\n{\n    \"DEBUG \",\n    \"INFO  \",\n    \"WARN  \",\n    \"ERROR \",\n    \"FATAL \",\n};\n```\n字符串指针包装类, 减少strlen的调用 或者字符串没有终止\n```c++\n// LEARN 临时包装字符串指针和长度\nclass T\n{\npublic:\n\n    T(const char* str, size_t len):\n    str_(str),\n    len_(len)\n    {\n        assert(strlen(str) == len);\n    }\n\n    const char* str_;\n    const size_t len_;\n};\n```\n使用内部类Impl包装了LogStream LogStream负责的是单纯的维护缓冲区 重载各种运算符.\nImpl的构造函数输出了日志前边的固定部分\nLogger的构造函数负责根据有无函数名等重载输出额外的固定内容\n构造和析构之间完成 纯用户自定义部分输出\nLogger的析构函数负责输出每条日志的结尾部分 文件名和行号\n```c++\nclass Impl\n{\npublic:\n    typedef Logger::LogLevel LogLevel;\n    Impl(LogLevel level, const SourceFile& file, int line);\n    void FormatTime();\n    void Finish();\n\n    Timestamp time_;\n    LogStream stream_;\n    LogLevel level_;\n    SourceFile filename_;\n    int line_;\n};\n```\n内部类SourceFile负责将`__FILE__`宏产生的字符数组转换成单纯的文件名. 使用了数组引用\n```c++\nclass SourceFile\n{\npublic:\n    /**\n        * 数组的引用 使数组在传参时不会降为 指针\n        */\n    template<int N>\n    SourceFile(const char (&arr)[N]):\n    data_(arr),\n    size_(N - 1)\n    {\n        const char* name = strrchr(data_, '/'); /* /name */\n        if (name)\n        {\n            data_ = name + 1;\n            size_ -= static_cast<int>(data_ - arr);\n        }\n    }\n\n    const char* data_;\n    int size_;\n};\n```\n\n其他高效设计\n```c++\n// LEARN 缓存上一次输出的秒 同一秒输出时避免多次格式化\n// 同一秒输出仅仅格式化 微秒部分\n__thread char t_time[64];\n__thread time_t t_last_second;\n```\n\n# 第二部分 muduo网络库\n## 第六章 muduo网络库简介\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/ClassDiagram.png)\n\n看完前面的一小部分, 我真心觉得这个库跟之前那个flamingo特别像, 估计这种管理方式就是某种主流方式?\n估计我以后自己写的时候也是会按照这个模式来写了吧\n\nTCP网络编程最本质的是处理三个半事件\n- 连接的建立\n- 连接断开 主动断开close 被动断开 read返回0\n- 消息到达, 文件描述符可读. 最为重要的一个事件, 对它的处理方式决定了网络编程的风格.(阻塞还是非阻塞, 如何处理分包, 应用层缓冲如何设计)\n- 消息发送完毕 这算半个\n\n现在存在的问题\n- 如果保证发送完应用层缓冲区数据才断开连接\n自己思考的可以设立标志位, 如果设置了标志位发送完成后检测标志位 关闭连接\n- 如果要主动发起连接, 但是对方主动拒绝, 如何定期重试\n按照TCP重试机制 发送SYN 开启定时器 如果定时内没有收到确认ACK则重发SYN\n\n\n这里了解到一个词 前向声明,\n在程序设计中，前向声明（Forward Declaration）是指声明标识符(表示编程的实体，如数据类型、变量、函数)时还没有给出完整的定义。\n通常为了简化头文件的关系 可以在A的头文件中 声明`class B`, 这样在你的代码中就可以使用`B*`而不需要引入B的头文件\n\n## 第七章 muduo编程示例\n\n本章大部分都是实战小例子, 自然要在代码中注释了.\n博客这里就简单写一写\n**关于`input buffer`和`output buffer`已经有所了解过**\n\n`output buffer`在`write`调用一次没有发送完全的时候起到大用途. 一次没有发送完不应该等待在那里, 应该是接管这些未发送的数据, 阻塞代价是很大的. 应该是注册`EPILOUT`事件, 直到数据全部发送完毕. 否则就一直注册事件, 当然这是在连接正常的时候.\n使用`output buffer`还有一个小问题, 一般情况下一次发送未完成才会使用到`output buffer`. 当缓冲区中存在数据的时候. 下一次的数据不能进行发送, 而应该是直接追加到尾部.\n\n`input buffer`某种意义上作用更大, 这涉及到一个重要概念\"粘包\"的处理. \n\n这里我了解到了`capacity()`机制, 可以用来减少内存分配次数. `capacity()`代表预分配的内存大小,\n而`size()`是你写入的数据大小, 当`size == capacity`的时候`再写入内容`内存会分配更长的一个数组将旧数据拷贝过去`size()`依然是你写入的大小, `capacity()`则会变大\n```c++\nstd::vector<char> buff(20); // 填充了20个元素 0\nvoid Foo(size_t size)\n{\n    buff.resize(size);\n    printf(\"%ld %ld\\n\", buff.size(), buff.capacity());\n}\nint main()\n{\n    printf(\"%ld %ld\\n\", buff.size(), buff.capacity()); // 20 20\n    Foo(512); // 512 512\n    Foo(1024); // 1024 1024\n    Foo(1025); // 1025 2048\n    Foo(2048); // 2048 2048\n    Foo(2049); // 2049 4096\n}\n```\n\n花了小半天时间去了解配置了下 protobuf, 是一把很锋利的剑不错!\n\n网络编程中使用protobuf的两个先决条件\n- 长度问题, protobuf打包的数据没有自带长度信息或终结符, 这就需要程序自己在发送和接受的时候做正确的切分\n- 类型问题, protobuf打包的数据没有自带类型信息, 需要由发送方把类型信息传给接收方, 接收方创建对应的具体protobuf message对象, 再做反序列化\n\n我第一印象解决上面的方法, 就如书中所言是山寨的做法.... 增加header部分\n\n![Protobuf类图](https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/protobuf%20class.png)\n\n大概意思就是大部分人通过在头部增加代号标识消息类型(具体对应那个message), 而protobuf提供了\n根据反射 根据typename 选择对应的Message对象的功能, 由于我没有用过protobuf 目前不是很了解 不过大概就这样了, 后续会专门学习 先用即可\n```c++\n// eg typename=muduo.Query\ngoogle::protobuf::Message* ProtobufCodec::createMessage(const std::string& typeName)\n{\n    google::protobuf::Message* message = nullptr;\n    const google::protobuf::Descriptor* descriptor =\n        google::protobuf::DescriptorPool::generated_pool()->FindMessageTypeByName(typeName);\n    if (descriptor)\n    {\n        const google::protobuf::Message* prototype =\n            google::protobuf::MessageFactory::generated_factory()->GetPrototype(descriptor);\n        if (prototype)\n        {\n            message = prototype->New(); // 返回的是动态创建的指针\n        }\n    }\n    return message;\n}\n\ntypedef std::shared_ptr<google::protobuf::Message> MessagePtr;\nMessagePtr message;\nmessage.reset(createMessage(typeName)); // 接管指针\n```\n\n作者设计的格式如下\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/protobuf%E4%BC%A0%E8%BE%93%E6%A0%BC%E5%BC%8F.png)\n\n```c++\nstruct Foo\n{\n    // int32_t version; 根本不需要版本号\n    int32_t len; // 没有使用uin32_t 是为了跨语言, Java没有unsigned\n    int32_t namelen;\n    char type_name[namelen]; // 以 /0 结尾 方便接收方处理 节省strlen() 空间换时间\n    char protobuf_data[len-namelen-8]\n    int32_t checksum; // adler32算法 进行校验\n}\n```\n\n终于知道编码器解码器合起来叫什么了... 编解码器(codec)\n\n后面的一些例子就跳过了, 去准备阅读第八章然后动手写库了 这里才是重点 至于例子当时候自己再写.\n自己的库不香吗?\n\n## 第八章 muduo网路库设计与实现\n~~第八章从第0节开始 一看就是程序员~~\n\n2020年4月27日11:02:12 距离写完上一行博客已经过去不短的时间了.\n这段时间我仿照muduo从中抽了部分功能做了自己的mongo库, 然后我将muduo Protobuf作为附属\n改成了ProtobufServer(包装了TcpServer).\n\n之后我便重新编写UE4部分的Protobuf收发部分的代码.\n昨天晚上总算是将UE4打飞机的单机版 成功改造成了联机版. 使用的帧同步\n服务器稳定性极佳, 而且内存占用很低, 想到了我之前写的Java服务器. 服务器CPU性能占用极少.\n\n初期设计的时候 单机每秒发送12包, 每包平均0.16kb. 单机每秒就是2kb.  如果有6个客户端\n服务器算上广播 出站流量 72kb/s\n\n跑了下iftop看了下基本是这样.\n12*6 = 72kb/s\n\n阿里云送的服务器1Mbps, 理论可以支持8个客户端同屏游戏\n阿里云学生机5Mbps, 理论支持17个客户端同屏游戏\n\n当然了现在只同步了输入, 不过其他同步内容消耗的流量就很少了.\n\n服务器程序运行良好, 倒是UE4 偶尔会崩....\n\n后面慢慢完善打飞机和服务器\n\n使用框架很简单的就实现了 登录和游玩数据分开 很舒服. 当然了登录目前只是个摆设没有在服务端保存\n跳过登录依然可以玩, 后面完善db服务器再说\n\n\n# 第三部分 工程实践经验谈\n## 第九章 分布式 跳过\n\n## 第十章 C++编译链接模型精要","slug":"读书记录120-Linux多线程服务器","published":1,"updated":"2020-12-05T02:31:35.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg79003zf8unbq55ed1w","content":"<p>Linux高性能服务器编程基本看玩了, 现在需要进行实战练习, 然而从单纯的只会api到做出项目, 之间的距离<br>不是一般的小, 最终我选择了这本书…..</p>\n<p>相关自己写的代码 大部分放在github 少部分会写在博客中</p>\n<h1 id=\"第一部分-C-多线程系统编程\"><a href=\"#第一部分-C-多线程系统编程\" class=\"headerlink\" title=\"第一部分 C++多线程系统编程\"></a>第一部分 C++多线程系统编程</h1><h2 id=\"第一章-线程安全的对象生命期管理\"><a href=\"#第一章-线程安全的对象生命期管理\" class=\"headerlink\" title=\"第一章 线程安全的对象生命期管理\"></a>第一章 线程安全的对象生命期管理</h2><p>一个线程安全的class需要满足的条件</p>\n<ul>\n<li>多个线程同时访问, 其表现出正确的行为</li>\n<li>无论操作系统如何调度这些线程, 无论这些线程的执行顺序如何交织</li>\n<li>调用端代码无需额外的同步或其他协调操作</li>\n</ul>\n<p>对象构造的安全, 在构造期间不要泄露this指针, 如果不按照以下规定可能会早对象构造完成前就被访问</p>\n<ul>\n<li>不要在构造函数中注册任何回调</li>\n<li>不要在构造函数中把this传给跨线程的对象</li>\n<li>即便在构造函数最后一行也不行, 因为对象可能是一个父类, 会先构造父类部分, 再构造子类部分</li>\n</ul>\n<p>二段式构造有时候可以解决上面的问题</p>\n<p>二段式构造-构造函数+initialize()<br>因为构造函数没有办法告知是否构造成功, 如果使用异常处理将会使代码复杂化.<br>比如在构造函数中使用new操作, 如果new操作失败就会出现不可预料的后果, 然后外部却无法知道<br>再比如将this传给其他跨线程对象, 如果构造结束前传入, 可能就会发生问题</p>\n<p><strong>shared_ptr的引出</strong><br>如果在一个对象中通过指针访问资源(另一个对象), 知道这个资源是否活着是很难的.<br>如果简单的判断指针是否为空, 可能会在线程B已经判断了指针不为空还没有执行后续操作时, 线程A就把<br>这个资源释放掉了</p>\n<p>当然可以通过资源管理对象 管理上面的资源, 但是也存在上面的问题.</p>\n<p>所以要想安全的销毁对象最好在其他线程都看不到的情况下偷偷进行. (垃圾回收原理, 所有人用不到的东西一定是垃圾)</p>\n<p>所以可以再资源管理对象中增加引用计数, 外部对象在释放资源管理对象中资源的时候, 只是将引用计数减一, 当引用计数为0的时候 在进行释放.</p>\n<p>C++可能出现的内存问题</p>\n<ul>\n<li>缓冲区溢出<br>使用<code>std::vector&lt;char&gt;/std::string</code>或者自己编写<code>Buffer Class来管理缓冲区</code>. 记住缓冲区长度, 通过成员函数而不是裸指针修改缓冲区</li>\n<li>空悬指针/野指针<br>使用shared_ptr/weak_ptr</li>\n<li>重复释放<br>使用scoped_ptr, 只在对象析构的时候释放一次</li>\n<li>内存泄漏<br>使用scoped_ptr, 对象析构时自动释放内存</li>\n<li>不配对的new[]/delete<br>把new[] 统统替换成std::vector, scoped_array</li>\n<li>内存碎片</li>\n</ul>\n<p>使用智能指针存在的一些问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Book(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; name) :name_(name) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DoSomething</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookShelf</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Register</span><span class=\"params\">(<span class=\"built_in\">std</span>::weak_ptr&lt;Book&gt; book)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        books_.push_back(book);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CheckBook</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 锁争用</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里开头上锁 很可能影响其他的函数, 因为这里调用了用户提供的函数, 等待时间可能会非常长</span></span><br><span class=\"line\">        <span class=\"comment\">// 比如Register函数就没有办法在这段时间中插入新的book</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// mutex lock 开头上锁 保护vector</span></span><br><span class=\"line\">        Iterator iter = books_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iter != books_.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;Book&gt; <span class=\"title\">obj</span><span class=\"params\">(iter-&gt;lock())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (obj)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                obj-&gt;DoSomething();</span><br><span class=\"line\">                iter++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                iter = books_.erase(iter);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 这样就强制要求了Book必须以shared_ptr管理</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::weak_ptr&lt;Book&gt;&gt;::iterator Iterator;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>在对象的成员变量vector中保存shared_ptr 会导致管理的资源无法被释放, 因为引用计数最少为1.<br>如果保存weak_ptr可能会导致vector只增不减, 因为weak_ptr只管自己管理的资源, 不管自己.<br>通过定制shared_ptr的析构函数可以解决这个问题</p>\n<p>如果将某个类的this指针 bind到一个function对象, 可能在函数调用时传进入一个已经被释放的对象地址<br>建议使用shared_ptr解决上面的问题, 如果想要获得this指针对应的shared_ptr, 可以另类继承<br><code>enable_shared_from_this&lt;T&gt;</code>, 通过在bind函数绑定<code>shared_from_this()返回的shared_ptr</code>.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookShelf</span>:</span><span class=\"built_in\">std</span>::enable_shared_from_this&lt;BookShelf&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Book对象固然可以销毁, 但是出现了轻微的内存泄漏</span></span><br><span class=\"line\">    <span class=\"comment\">// book_只增不减!!!!. 虽然Book对象销毁了但是book_中依然保存着weak_ptr</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以需要定制析构功能</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;Book&gt; <span class=\"title\">GetBook</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;bookname)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;Book&gt; pbook;</span><br><span class=\"line\">        <span class=\"comment\">// 上锁</span></span><br><span class=\"line\">        <span class=\"built_in\">std</span>::weak_ptr&lt;Book&gt;&amp; wkbook = books_[bookname];</span><br><span class=\"line\">        pbook = wkbook.lock();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!pbook)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// pbook.reset(new Book(bookname));</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 依然有问题 绑定this指针可能到时候this指向的对象已经不复存在了</span></span><br><span class=\"line\">            <span class=\"comment\">// pbook.reset(new Book(bookname),</span></span><br><span class=\"line\">            <span class=\"comment\">//   std::bind(&amp;BookShelf::DeleteBook, this, std::placeholders::_1));</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 注意shared_from_this不能在构造函数中调用, 因为构造Bookshelf的时候 他还没有</span></span><br><span class=\"line\">            <span class=\"comment\">// 被交给shared_ptr管理</span></span><br><span class=\"line\">            pbook.reset(<span class=\"keyword\">new</span> Book(bookname),</span><br><span class=\"line\">                <span class=\"built_in\">std</span>::bind(&amp;BookShelf::DeleteBook, shared_from_this(), <span class=\"built_in\">std</span>::placeholders::_1));</span><br><span class=\"line\"></span><br><span class=\"line\">            wkbook = pbook;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pbook;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, <span class=\"built_in\">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteBook</span><span class=\"params\">(Book* book)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (book)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 上锁</span></span><br><span class=\"line\">            books_.erase(book-&gt;GetName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> book;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>然而上面的代码依然有问题<br>依然有个问题. BookShelf的生命期似乎被意外延长了, 他不会短于function对象<br>所以改用weak_pr不就可以了吗</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookShelf</span>:</span><span class=\"built_in\">std</span>::enable_shared_from_this&lt;BookShelf&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;Book&gt; <span class=\"title\">GetBook</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;bookname)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;Book&gt; pbook;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::weak_ptr&lt;Book&gt;&amp; wkbook = books_[bookname];</span><br><span class=\"line\">        pbook = wkbook.lock();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!pbook)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pbook.reset(<span class=\"keyword\">new</span> Book(bookname),</span><br><span class=\"line\">                <span class=\"built_in\">std</span>::bind(&amp;BookShelf::WkDeleteCallback,</span><br><span class=\"line\">                    <span class=\"built_in\">std</span>::weak_ptr&lt;BookShelf&gt;(shared_from_this()),</span><br><span class=\"line\">                    <span class=\"built_in\">std</span>::placeholders::_1));</span><br><span class=\"line\"></span><br><span class=\"line\">            wkbook = pbook;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pbook;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, <span class=\"built_in\">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">WkDeleteCallback</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::weak_ptr&lt;BookShelf&gt; wk_shelf, Book* book)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;BookShelf&gt; <span class=\"title\">bookshelf</span><span class=\"params\">(wk_shelf.lock())</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bookshelf)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            DeleteBook(book);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> book;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteBook</span><span class=\"params\">(Book* book)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (book)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 上锁</span></span><br><span class=\"line\">            books_.erase(book-&gt;GetName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>第一章已经读完了, 笔记只有上面那点. 我在学习Linux高性能服务器编程的大二上半年时间照着书边读边写笔记, 然后后来到了大二下我改成了读完一部分后脑中有什么记什么, 重要的地方如果记不清写不出来就去再看一下. 这样花费在记笔记的时间就少了很多, 写出来的笔记更加方便自己阅读.</p>\n<p>第一章部分内容能看懂 真是谢了之前看的那个项目代码, 那个项目中大量使用了智能指针, 我在读哪个项目的代码的时候查了不少的东西, 现在才能看懂第一章的部分东西.<br>然而大部分?的东西感觉还是似懂非懂, 想写又写不出什么来. 我对于智能指针的使用还是过于晚了把.</p>\n<p>第一章看来后续还要读一遍了</p>\n<h2 id=\"第二章-线程同步精要\"><a href=\"#第二章-线程同步精要\" class=\"headerlink\" title=\"第二章 线程同步精要\"></a>第二章 线程同步精要</h2><p><strong>线程同步的四项原则</strong><br>按重要性排列</p>\n<ol>\n<li>最低限度的共享对象, 减少需要同步的场合, <em>不用就不需要同步了nice!!!</em></li>\n<li>使用高级的并发编程构建, 线程池, 队列, 倒计时</li>\n<li>不得已使用底层同步原语时, 只使用非递归的互斥器和条件变量, 慎用读写锁, 不要用信号量</li>\n<li>除了使用atomic整数外, 不要自己编写lock-free代码, 也不要用内核级的同步原语. 不凭空猜测<br>哪种做法性能更好 比如自旋锁和互斥锁</li>\n</ol>\n<p><strong>互斥器 mutex</strong><br>使用mutex的原则</p>\n<ul>\n<li>使用RAII手法封装mutex的创建销毁加锁解锁这四个操作, 不会因异常而忘记解锁</li>\n<li>只使用非递归的mutex即不可重入的mutex<br>容易排查错误 使用递归mutex问题可能出现也可能不出现(可能由于逻辑问题对一个mutex加锁两次), 而使用非递归即可发现错误并改正</li>\n<li>不手工调用lock()和unlock() 函数, <em>一切交给栈上的Guard对象的构造和析构函数负责</em></li>\n<li>Gruad对象的生命期正好等于临界区</li>\n</ul>\n<p>次要原则</p>\n<ul>\n<li>不使用跨进程的mutex, 进程间通信只用TCP sockets</li>\n<li>加锁解锁在同一个线程 不会出现跨线程的操作 (RAII自动保证)</li>\n<li>不忘记解锁(包括各种提前返回和异常抛出) 不重复解锁 均由RAII自动保证</li>\n<li>必要时考虑用PTHREAD_MUTEX_ERRORCHECK来排错</li>\n</ul>\n<p><strong>封装MutexLock MutexLockGuard Condition</strong><br>在Linux高性能服务器编程中 我也看过了封装mutex, 不过当时并没有使用RAII<br>从这里开始算是对RAII(Resource Acquisition Is Initialization)有了了解</p>\n<p><a href=\"https://zh.cppreference.com/w/cpp/language/raii\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/language/raii</a><br>拥有open()/close()、lock()/unlock()，或 init()/copyFrom()/destroy()成员函数的类是非RAII类的典型例子</p>\n<p>RAII将资源封装入一个类 如MutexLock类</p>\n<ul>\n<li>构造函数请求资源, 建立所有类不变式, 或在无法完成时抛出异常</li>\n<li>析构函数释放资源并绝不抛出异常<br>始终经由RALL类的实例使用满足要求的资源如MutexLockGuard类, 资源需满足</li>\n<li>自身拥有自动存储期或临时生存期</li>\n<li>或具有与自动或临时对象的生存期绑定的生存期</li>\n</ul>\n<p>自己的理解就是经由RAII类生存期管理资源, RAII生存期开始即使用资源,<br>当RAII类生存期结束, RAII类中保存着的资源也自动销毁<br>RAII可以有效防止上面那些成对函数调用前一个后 由于异常抛出提前返回等 后一个函数没有被调用 造成资源状态异常</p>\n<p><strong>线程安全的Singleton实现</strong><br>这个类在 flamingo 中也见到了, 这次是升级版<br>借由pthread_once保证线程安全</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> :</span> noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> T&amp; <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        pthread_once(&amp;ponce_, Init);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *value_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Singleton();</span><br><span class=\"line\">    ~Singleton();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        value_ = <span class=\"keyword\">new</span> T();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">pthread_once_t</span> ponce_;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> T *value_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">pthread_once_t</span> Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">T* Singleton&lt;T&gt;::value_ = <span class=\"literal\">nullptr</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>copy-on-write?? copy-on-other-write!!</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::pair&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">int</span>&gt; Entry;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Entry&gt; EntryList;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, EntryList&gt; Map;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;Map&gt; MapPtr;</span><br><span class=\"line\"></span><br><span class=\"line\">MapPtr data_;</span><br></pre></td></tr></table></figure>\n<p>好的现在数据存储在data_ 中 系统中存在多个读线程和一个写线程 针对data_<br>如果写线程不管不顾 有数据就往data_中写入 出现了读写进程同时访问data_就会出问题.<br>就书中描述来意思来说 不用大刀阔斧的使用读写锁, 能用mutex简单解决为什么要用读写锁.<br>那么如何保证读写安全呢?</p>\n<p>当读进程读的时候 拷贝一次data_ data_的引用计数至少为2.<br>就在这时写进程判断 data_引用计数不为1, 于是拷贝原来指向的map, 然后将data_ reset指向新的map<br>这时data_引用计数变为1 可以正常写了. 而读进程中保存的map拷贝是稍久的 引用计数降为1, 执行完后就自动析构了旧数据</p>\n<p>下面的代码 读部分只在GetData中加锁, 缩小了临界区</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MapPtr <span class=\"title\">GetData</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// binding reference of type ‘MutexLock&amp;’ to ‘const MutexLock’ discards qualifiers</span></span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CustomerData::Query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;custmoner, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;stock)</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    MapPtr data = GetData();</span><br><span class=\"line\">    Map::const_iterator entries = data-&gt;<span class=\"built_in\">find</span>(custmoner);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entries != data-&gt;<span class=\"built_in\">end</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FindEntry(entries-&gt;second, stock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CustomerData::Update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;customer, <span class=\"keyword\">const</span> CustomerData::EntryList &amp;entries)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data_.unique())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MapPtr <span class=\"title\">new_data</span><span class=\"params\">(<span class=\"keyword\">new</span> Map(*data_))</span></span>;</span><br><span class=\"line\">        data_.swap(new_data);</span><br><span class=\"line\">        <span class=\"comment\">// sawp后 先前某个线程通过GetData拿到MapPtr 他会读到稍旧的数据</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    assert(data_.unique());</span><br><span class=\"line\">    (*data_)[customer] = entries;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第三章-多线程服务器的适用场合与常用编程模型\"><a href=\"#第三章-多线程服务器的适用场合与常用编程模型\" class=\"headerlink\" title=\"第三章 多线程服务器的适用场合与常用编程模型\"></a>第三章 多线程服务器的适用场合与常用编程模型</h2><p>单线程服务器常用的编程模型<br><code>non-blocking IO + IO multiplexing</code> 即为<code>Reactor模式</code><br>程序的基本结构是一个事件循环, 以事件驱动和事件回调的方式实现业务逻辑</p>\n<p>本质的缺点<br>要求事件回调函数必须是非阻塞的, 单线程还阻塞 这还怎么玩…<br>对于涉及网络IO的请求响应式协议, 容易割裂业务逻辑, 使其散布于多个回调函数中</p>\n<p>多线程服务器常用编程模型</p>\n<ol>\n<li>每个请求创建一个线程, 使用阻塞式IO操作</li>\n<li>使用线程池, 同样是阻塞式IO操作</li>\n<li>非阻塞IO + IO多路复用 即Java NIO方法</li>\n<li>领导者追随者等高级模式</li>\n</ol>\n<p>推荐的C++多线程服务器端编程模式为 one (event) loop per thread + thread pool<br>一个线程一个事件循环 + 线程池<br>事件循环用作IO多路复用, 配合非阻塞IO和定时器<br>线程池用作计算, 具体可以是任务队列或生产者消费者队列</p>\n<p>必须使用单线程的场合</p>\n<ul>\n<li>程序可能会fork</li>\n<li>限制程序的CPU占用率 一个线程最多占满一个核心</li>\n</ul>\n<p>适用多线程程序的场景</p>\n<ul>\n<li>有多个CPU可用, 单核机器上多线程没有性能优势</li>\n<li>线程间有共享数据, 否则建议使用 主进程+工作进程 每个进程都是单线程的模型</li>\n<li>共享数据是可以修改的. 如果数据不能修改可以进程间使用共享内存</li>\n<li>事件响应有优先级差异, 防止优先级反转</li>\n<li>程序要有相当的计算量</li>\n<li>利用异步操作</li>\n<li>能享受到增加CPU数目带来的好处</li>\n<li>多线程有有效地划分责任与功能</li>\n</ul>\n<p>后面大部分我都是看看就过去了, 自己没有丝毫经验 也不打算现在细看</p>\n<h2 id=\"第四章-C-多线程系统编程精要\"><a href=\"#第四章-C-多线程系统编程精要\" class=\"headerlink\" title=\"第四章 C++多线程系统编程精要\"></a>第四章 C++多线程系统编程精要</h2><p>学习多线程编程面临的最大思维方式转变</p>\n<ul>\n<li>当前进程随时可能被切出去</li>\n<li>多线程程序中事件的发生顺序不再有全局统一的先后关系</li>\n</ul>\n<p>常用的11个pthreads函数</p>\n<ul>\n<li>pthread_create() pthread_join()</li>\n<li>pthread_mutex_(create/destory/lock/unlock)</li>\n<li>pthread_cond_(create/destory/wait/signal/broadcast)</li>\n</ul>\n<p>多线程系统编程的难点不在于学习线程原语, 而在于理解多线程与现有的C/C++库函数和系统调用的交互关系<br>以进一步学习如何设计并实现线程安全且高效的程序</p>\n<p>pthread_t并不适合作为程序中对线程的标识符</p>\n<ul>\n<li>他可能会同一进程的两个线程相同</li>\n<li>或者是不利于打印</li>\n<li>无法判断其是否非法</li>\n<li>文件系统中没有对应项</li>\n<li>脱离进程便没意义</li>\n</ul>\n<p>推荐使用gettid()作为线程标识符</p>\n<ul>\n<li>任何时刻都是全局唯一的</li>\n<li>类型为pid_t通常为一个小整数利于在日志中打印.</li>\n<li>0就是非法值1, 因为操作系统第一个进程init的pid是1</li>\n<li>在现代Linux中, 他直接表示内核的任务调度id, 容易在/proc文件系统中找到对应项</li>\n<li>在其他系统工具中也容易定位到某一个具体线程, 列如使用top按线程列出任务,<br>便可以找到线程id, 再根据程序日志判断是哪一个具体线程</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .h</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> __thread <span class=\"keyword\">int</span> t_cachedTid;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cacheTid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">tid</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__builtin_expect(t_cachedTid == <span class=\"number\">0</span>, <span class=\"number\">0</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cacheTid();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t_cachedTid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// .cpp</span></span><br><span class=\"line\">__thread <span class=\"keyword\">int</span> t_cachedTid = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CurrentThread::cacheTid</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t_cachedTid == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        t_cachedTid = gettid();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// .cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">gettid</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">pid_t</span>&gt;(::syscall(SYS_gettid));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>thread<br>只能修饰POD类型, 不能修饰class类型, 因为无法自动调用构造析构函数. 可以用于修饰全局变量函数内的静态变量.是GCC内置的线程局部存储设施，存取效率可以和全局变量相比。</strong>thread变量每一个线程有一份独立实体，各个线程的值互不干扰.</p>\n<p><strong>builtin_expect<br>这个指令是gcc引入的，作用是允许程序员将最有可能执行的分支告诉编译器。这个指令的写法为：</strong>builtin_expect(EXP, N)。<br>意思是：EXP==N的概率很大. 就图中代码翻译过来就是 <code>t_cachedTid == 0</code>为<code>0(假)</code>, 即为<code>t_cachedTid</code>最可能不是0.</p>\n<ul>\n<li>使用同一个class创建线程, 全局统一. 一般不会为每个网络连接创建线程, 除非并发数与cpu数目相同<br>一个服务程序的线程数目应该与当前负载无关, 而应该有CPU数目有关.</li>\n<li>程序运行期间不要再创建和销毁线程, 最好在初始化的时候创建所有的线程</li>\n</ul>\n<p>线程销毁的方式</p>\n<ul>\n<li>正常死亡, 从线程主函数返回, 线程正常退出</li>\n<li>非正常死亡, 从线程主函数抛出异常或线程触发segfault信号等非法操作</li>\n<li>自杀 调用pthread_exit() 立刻终止线程</li>\n<li>他杀 其他线程调用pthread_cancel() 来强制终止某个线程</li>\n</ul>\n<p>线程只有一种正常死亡方式, 即第一种 其他方法都是错的Java中甚至把相关函数都废弃了</p>\n<p>每个文件描述符只由一个线程操作, 从而解决消息收发的顺序问题, 把一个文件描述符读写分开未必会提高性能. 同时我们不知道epoll_wait阻塞的时候, 其他线程添加新的fd会发生什么. 为了稳妥起见应该把对同一个epollfd的操作放入同一个线程中执行.</p>\n<p><strong>包装文件描述符和连接</strong><br>用Socket对象包装文件描述符<br>所有对此文件描述符的读写操作都通过此对象进行, 对象的析构函数里关闭文件描述符. 这样只要Socket对象还活着 就不会与其他Socket对象有相同的文件描述符, 也就不会发生串话. 包装文件描述符已经见过了, 同样是在flamingo中看到的.</p>\n<p>用Tcpconnection包装连接<br>如果仅仅记住 fd = 8 这样的文件描述符, A线程accept后转身去处理业务B线程把 fd = 8 给关闭了!! 同时accept一个新的fd 同样是8!!. 这时A线程回复就会出现问题. 所以应该持有封装了Socket对象的Tcpconnection, 保证请求处理期间 文件描述符不会被关闭. 或者是持有Tcpconnection的弱引用. 这样就能知道 fd = 8 到底是原来的还是被关闭后新创建的. Tcpconnection对象不能提前销毁, 所以使用了shared_ptr来管理其生存期, 保证不会提前销毁造成串话.</p>\n<h2 id=\"第五章-高效的多线程日志\"><a href=\"#第五章-高效的多线程日志\" class=\"headerlink\" title=\"第五章 高效的多线程日志\"></a>第五章 高效的多线程日志</h2><p>日志库大体分为前端和后端两部分, 两端之间的联系可能简单到只有一个函数<br>大多数感觉都是宏命令</p>\n<p>日志的滚动也很重要 根据文件大小 和 时间 自动创建新的日志文件, 而不是全写入一个文件中</p>\n<p>避免出现正则表达的元字符(列如我最喜欢的<code>&#39;[&#39;和&#39;]&#39;</code>) 便于使用正则表达式查找</p>\n<p>这一章的笔记是在我照着代码实现了简单的相似功能后才写的, 记录一下好的地方<br>大体分为了 LogStream类和Logger类 前者负责通过<code>&lt;&lt;</code>维护LogBuffer缓冲区, 后者做包装提供接口<br>LogBuffer使用了简单的数组作为缓冲区, 使用Append添加内容 维护写指针</p>\n<p>LogStream重载了多种 参数情况, char和char* 很方便写入到缓冲区中<br>数字则需要转化成字符串</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(short num);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">unsigned</span> short num);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">int</span> num);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">unsigned</span> num);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">long</span> num);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> num);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> num);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> num);</span><br><span class=\"line\"></span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">char</span> str);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str);</span><br></pre></td></tr></table></figure>\n\n<p>转化函数, 不得不说设计的真好. 通过模板解决了多种数字类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> digits_character[] = <span class=\"string\">\"0123456789\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// LEARN https://www.drdobbs.com/flexible-c-1-efficient-integer-to-string/184401596</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">Convert</span><span class=\"params\">(<span class=\"keyword\">char</span> buff[], T value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    T i = value;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* p = buff;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> lsd = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">unsigned</span>&gt;(i % <span class=\"number\">10</span>);</span><br><span class=\"line\">        i /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"comment\">// *p++ = '0' + lsd; 不高效</span></span><br><span class=\"line\">        *p++ = digits_character[lsd];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (i != <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *p++ = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *p = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// LEARN 原文中是从buff最后一个字节开始写入 但是这里需要从开头写入 所以改为倒置一下</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::reverse(buff, p);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p - buff;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LogStream::FormatInteger</span><span class=\"params\">(T t)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buffer_.WriteableBytes() &gt; MAX_NUMBER_SIZE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">size_t</span> len = Convert(buffer_.WritePeek(), t);</span><br><span class=\"line\">        buffer_.MoveWritePeek(len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将格式化也单独出了一个类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fmt</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">    Fmt(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* fmt, T val);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">GetData</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buff_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetLength</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> length_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buff_[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> length_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">Fmt::Fmt(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* fmt, T val)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static_assert</span>(<span class=\"built_in\">std</span>::is_arithmetic&lt;T&gt;::value == <span class=\"literal\">true</span>, <span class=\"string\">\"Must be arithmetic type\"</span>);</span><br><span class=\"line\">    length_ = <span class=\"built_in\">snprintf</span>(buff_, <span class=\"keyword\">sizeof</span> buff_, fmt, val);</span><br><span class=\"line\">    assert(length_ &lt; <span class=\"keyword\">sizeof</span> buff_);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Logger类的设计<br>方便了日志的打印, 实现了高效的转换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> LogLevel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DEBUG,</span><br><span class=\"line\">    INFO,</span><br><span class=\"line\">    WARN,</span><br><span class=\"line\">    ERROR,</span><br><span class=\"line\">    FATAL,</span><br><span class=\"line\">    NUM_LOG_LEVELS <span class=\"comment\">/* 仅用于表示LogLevel元素个数 不做实际使用 */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// LEARN 处处保持长度一致 使用NUM_LOG_LEVELS表示大小</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* LogLevelName[Logger::NUM_LOG_LEVELS] =</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"DEBUG \"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"INFO  \"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"WARN  \"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"ERROR \"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"FATAL \"</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>字符串指针包装类, 减少strlen的调用 或者字符串没有终止</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LEARN 临时包装字符串指针和长度</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    T(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str, <span class=\"keyword\">size_t</span> len):</span><br><span class=\"line\">    str_(str),</span><br><span class=\"line\">    len_(len)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        assert(<span class=\"built_in\">strlen</span>(str) == len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str_;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">size_t</span> len_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>使用内部类Impl包装了LogStream LogStream负责的是单纯的维护缓冲区 重载各种运算符.<br>Impl的构造函数输出了日志前边的固定部分<br>Logger的构造函数负责根据有无函数名等重载输出额外的固定内容<br>构造和析构之间完成 纯用户自定义部分输出<br>Logger的析构函数负责输出每条日志的结尾部分 文件名和行号</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Impl</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> Logger::LogLevel LogLevel;</span><br><span class=\"line\">    Impl(LogLevel level, <span class=\"keyword\">const</span> SourceFile&amp; file, <span class=\"keyword\">int</span> <span class=\"built_in\">line</span>);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">FormatTime</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Finish</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Timestamp time_;</span><br><span class=\"line\">    LogStream stream_;</span><br><span class=\"line\">    LogLevel level_;</span><br><span class=\"line\">    SourceFile filename_;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> line_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>内部类SourceFile负责将<code>__FILE__</code>宏产生的字符数组转换成单纯的文件名. 使用了数组引用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SourceFile</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 数组的引用 使数组在传参时不会降为 指针</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">int</span> N&gt;</span><br><span class=\"line\">    SourceFile(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;arr)[N]):</span><br><span class=\"line\">    data_(arr),</span><br><span class=\"line\">    size_(N - <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name = <span class=\"built_in\">strrchr</span>(data_, <span class=\"string\">'/'</span>); <span class=\"comment\">/* /name */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            data_ = name + <span class=\"number\">1</span>;</span><br><span class=\"line\">            size_ -= <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(data_ - arr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* data_;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其他高效设计</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LEARN 缓存上一次输出的秒 同一秒输出时避免多次格式化</span></span><br><span class=\"line\"><span class=\"comment\">// 同一秒输出仅仅格式化 微秒部分</span></span><br><span class=\"line\">__thread <span class=\"keyword\">char</span> t_time[<span class=\"number\">64</span>];</span><br><span class=\"line\">__thread <span class=\"keyword\">time_t</span> t_last_second;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第二部分-muduo网络库\"><a href=\"#第二部分-muduo网络库\" class=\"headerlink\" title=\"第二部分 muduo网络库\"></a>第二部分 muduo网络库</h1><h2 id=\"第六章-muduo网络库简介\"><a href=\"#第六章-muduo网络库简介\" class=\"headerlink\" title=\"第六章 muduo网络库简介\"></a>第六章 muduo网络库简介</h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/ClassDiagram.png\" alt=\"\"></p>\n<p>看完前面的一小部分, 我真心觉得这个库跟之前那个flamingo特别像, 估计这种管理方式就是某种主流方式?<br>估计我以后自己写的时候也是会按照这个模式来写了吧</p>\n<p>TCP网络编程最本质的是处理三个半事件</p>\n<ul>\n<li>连接的建立</li>\n<li>连接断开 主动断开close 被动断开 read返回0</li>\n<li>消息到达, 文件描述符可读. 最为重要的一个事件, 对它的处理方式决定了网络编程的风格.(阻塞还是非阻塞, 如何处理分包, 应用层缓冲如何设计)</li>\n<li>消息发送完毕 这算半个</li>\n</ul>\n<p>现在存在的问题</p>\n<ul>\n<li>如果保证发送完应用层缓冲区数据才断开连接<br>自己思考的可以设立标志位, 如果设置了标志位发送完成后检测标志位 关闭连接</li>\n<li>如果要主动发起连接, 但是对方主动拒绝, 如何定期重试<br>按照TCP重试机制 发送SYN 开启定时器 如果定时内没有收到确认ACK则重发SYN</li>\n</ul>\n<p>这里了解到一个词 前向声明,<br>在程序设计中，前向声明（Forward Declaration）是指声明标识符(表示编程的实体，如数据类型、变量、函数)时还没有给出完整的定义。<br>通常为了简化头文件的关系 可以在A的头文件中 声明<code>class B</code>, 这样在你的代码中就可以使用<code>B*</code>而不需要引入B的头文件</p>\n<h2 id=\"第七章-muduo编程示例\"><a href=\"#第七章-muduo编程示例\" class=\"headerlink\" title=\"第七章 muduo编程示例\"></a>第七章 muduo编程示例</h2><p>本章大部分都是实战小例子, 自然要在代码中注释了.<br>博客这里就简单写一写<br><strong>关于<code>input buffer</code>和<code>output buffer</code>已经有所了解过</strong></p>\n<p><code>output buffer</code>在<code>write</code>调用一次没有发送完全的时候起到大用途. 一次没有发送完不应该等待在那里, 应该是接管这些未发送的数据, 阻塞代价是很大的. 应该是注册<code>EPILOUT</code>事件, 直到数据全部发送完毕. 否则就一直注册事件, 当然这是在连接正常的时候.<br>使用<code>output buffer</code>还有一个小问题, 一般情况下一次发送未完成才会使用到<code>output buffer</code>. 当缓冲区中存在数据的时候. 下一次的数据不能进行发送, 而应该是直接追加到尾部.</p>\n<p><code>input buffer</code>某种意义上作用更大, 这涉及到一个重要概念”粘包”的处理. </p>\n<p>这里我了解到了<code>capacity()</code>机制, 可以用来减少内存分配次数. <code>capacity()</code>代表预分配的内存大小,<br>而<code>size()</code>是你写入的数据大小, 当<code>size == capacity</code>的时候<code>再写入内容</code>内存会分配更长的一个数组将旧数据拷贝过去<code>size()</code>依然是你写入的大小, <code>capacity()</code>则会变大</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; <span class=\"title\">buff</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>; <span class=\"comment\">// 填充了20个元素 0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foo</span><span class=\"params\">(<span class=\"keyword\">size_t</span> <span class=\"built_in\">size</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    buff.resize(<span class=\"built_in\">size</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%ld %ld\\n\"</span>, buff.<span class=\"built_in\">size</span>(), buff.capacity());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%ld %ld\\n\"</span>, buff.<span class=\"built_in\">size</span>(), buff.capacity()); <span class=\"comment\">// 20 20</span></span><br><span class=\"line\">    Foo(<span class=\"number\">512</span>); <span class=\"comment\">// 512 512</span></span><br><span class=\"line\">    Foo(<span class=\"number\">1024</span>); <span class=\"comment\">// 1024 1024</span></span><br><span class=\"line\">    Foo(<span class=\"number\">1025</span>); <span class=\"comment\">// 1025 2048</span></span><br><span class=\"line\">    Foo(<span class=\"number\">2048</span>); <span class=\"comment\">// 2048 2048</span></span><br><span class=\"line\">    Foo(<span class=\"number\">2049</span>); <span class=\"comment\">// 2049 4096</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>花了小半天时间去了解配置了下 protobuf, 是一把很锋利的剑不错!</p>\n<p>网络编程中使用protobuf的两个先决条件</p>\n<ul>\n<li>长度问题, protobuf打包的数据没有自带长度信息或终结符, 这就需要程序自己在发送和接受的时候做正确的切分</li>\n<li>类型问题, protobuf打包的数据没有自带类型信息, 需要由发送方把类型信息传给接收方, 接收方创建对应的具体protobuf message对象, 再做反序列化</li>\n</ul>\n<p>我第一印象解决上面的方法, 就如书中所言是山寨的做法…. 增加header部分</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/protobuf%20class.png\" alt=\"Protobuf类图\"><span class=\"img-alt\">Protobuf类图</span></p>\n<p>大概意思就是大部分人通过在头部增加代号标识消息类型(具体对应那个message), 而protobuf提供了<br>根据反射 根据typename 选择对应的Message对象的功能, 由于我没有用过protobuf 目前不是很了解 不过大概就这样了, 后续会专门学习 先用即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// eg typename=muduo.Query</span></span><br><span class=\"line\">google::<span class=\"function\">protobuf::Message* <span class=\"title\">ProtobufCodec::createMessage</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; typeName)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    google::protobuf::Message* message = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> google::protobuf::Descriptor* descriptor =</span><br><span class=\"line\">        google::protobuf::DescriptorPool::generated_pool()-&gt;FindMessageTypeByName(typeName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (descriptor)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> google::protobuf::Message* prototype =</span><br><span class=\"line\">            google::protobuf::MessageFactory::generated_factory()-&gt;GetPrototype(descriptor);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prototype)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            message = prototype-&gt;New(); <span class=\"comment\">// 返回的是动态创建的指针</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;google::protobuf::Message&gt; MessagePtr;</span><br><span class=\"line\">MessagePtr message;</span><br><span class=\"line\">message.reset(createMessage(typeName)); <span class=\"comment\">// 接管指针</span></span><br></pre></td></tr></table></figure>\n\n<p>作者设计的格式如下<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/protobuf%E4%BC%A0%E8%BE%93%E6%A0%BC%E5%BC%8F.png\" alt=\"\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// int32_t version; 根本不需要版本号</span></span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> len; <span class=\"comment\">// 没有使用uin32_t 是为了跨语言, Java没有unsigned</span></span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> namelen;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> type_name[namelen]; <span class=\"comment\">// 以 /0 结尾 方便接收方处理 节省strlen() 空间换时间</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> protobuf_data[len-namelen<span class=\"number\">-8</span>]</span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> checksum; <span class=\"comment\">// adler32算法 进行校验</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>终于知道编码器解码器合起来叫什么了… 编解码器(codec)</p>\n<p>后面的一些例子就跳过了, 去准备阅读第八章然后动手写库了 这里才是重点 至于例子当时候自己再写.<br>自己的库不香吗?</p>\n<h2 id=\"第八章-muduo网路库设计与实现\"><a href=\"#第八章-muduo网路库设计与实现\" class=\"headerlink\" title=\"第八章 muduo网路库设计与实现\"></a>第八章 muduo网路库设计与实现</h2><p><del>第八章从第0节开始 一看就是程序员</del></p>\n<p>2020年4月27日11:02:12 距离写完上一行博客已经过去不短的时间了.<br>这段时间我仿照muduo从中抽了部分功能做了自己的mongo库, 然后我将muduo Protobuf作为附属<br>改成了ProtobufServer(包装了TcpServer).</p>\n<p>之后我便重新编写UE4部分的Protobuf收发部分的代码.<br>昨天晚上总算是将UE4打飞机的单机版 成功改造成了联机版. 使用的帧同步<br>服务器稳定性极佳, 而且内存占用很低, 想到了我之前写的Java服务器. 服务器CPU性能占用极少.</p>\n<p>初期设计的时候 单机每秒发送12包, 每包平均0.16kb. 单机每秒就是2kb.  如果有6个客户端<br>服务器算上广播 出站流量 72kb/s</p>\n<p>跑了下iftop看了下基本是这样.<br>12*6 = 72kb/s</p>\n<p>阿里云送的服务器1Mbps, 理论可以支持8个客户端同屏游戏<br>阿里云学生机5Mbps, 理论支持17个客户端同屏游戏</p>\n<p>当然了现在只同步了输入, 不过其他同步内容消耗的流量就很少了.</p>\n<p>服务器程序运行良好, 倒是UE4 偶尔会崩….</p>\n<p>后面慢慢完善打飞机和服务器</p>\n<p>使用框架很简单的就实现了 登录和游玩数据分开 很舒服. 当然了登录目前只是个摆设没有在服务端保存<br>跳过登录依然可以玩, 后面完善db服务器再说</p>\n<h1 id=\"第三部分-工程实践经验谈\"><a href=\"#第三部分-工程实践经验谈\" class=\"headerlink\" title=\"第三部分 工程实践经验谈\"></a>第三部分 工程实践经验谈</h1><h2 id=\"第九章-分布式-跳过\"><a href=\"#第九章-分布式-跳过\" class=\"headerlink\" title=\"第九章 分布式 跳过\"></a>第九章 分布式 跳过</h2><h2 id=\"第十章-C-编译链接模型精要\"><a href=\"#第十章-C-编译链接模型精要\" class=\"headerlink\" title=\"第十章 C++编译链接模型精要\"></a>第十章 C++编译链接模型精要</h2>","site":{"data":{}},"excerpt":"","more":"<p>Linux高性能服务器编程基本看玩了, 现在需要进行实战练习, 然而从单纯的只会api到做出项目, 之间的距离<br>不是一般的小, 最终我选择了这本书…..</p>\n<p>相关自己写的代码 大部分放在github 少部分会写在博客中</p>\n<h1 id=\"第一部分-C-多线程系统编程\"><a href=\"#第一部分-C-多线程系统编程\" class=\"headerlink\" title=\"第一部分 C++多线程系统编程\"></a>第一部分 C++多线程系统编程</h1><h2 id=\"第一章-线程安全的对象生命期管理\"><a href=\"#第一章-线程安全的对象生命期管理\" class=\"headerlink\" title=\"第一章 线程安全的对象生命期管理\"></a>第一章 线程安全的对象生命期管理</h2><p>一个线程安全的class需要满足的条件</p>\n<ul>\n<li>多个线程同时访问, 其表现出正确的行为</li>\n<li>无论操作系统如何调度这些线程, 无论这些线程的执行顺序如何交织</li>\n<li>调用端代码无需额外的同步或其他协调操作</li>\n</ul>\n<p>对象构造的安全, 在构造期间不要泄露this指针, 如果不按照以下规定可能会早对象构造完成前就被访问</p>\n<ul>\n<li>不要在构造函数中注册任何回调</li>\n<li>不要在构造函数中把this传给跨线程的对象</li>\n<li>即便在构造函数最后一行也不行, 因为对象可能是一个父类, 会先构造父类部分, 再构造子类部分</li>\n</ul>\n<p>二段式构造有时候可以解决上面的问题</p>\n<p>二段式构造-构造函数+initialize()<br>因为构造函数没有办法告知是否构造成功, 如果使用异常处理将会使代码复杂化.<br>比如在构造函数中使用new操作, 如果new操作失败就会出现不可预料的后果, 然后外部却无法知道<br>再比如将this传给其他跨线程对象, 如果构造结束前传入, 可能就会发生问题</p>\n<p><strong>shared_ptr的引出</strong><br>如果在一个对象中通过指针访问资源(另一个对象), 知道这个资源是否活着是很难的.<br>如果简单的判断指针是否为空, 可能会在线程B已经判断了指针不为空还没有执行后续操作时, 线程A就把<br>这个资源释放掉了</p>\n<p>当然可以通过资源管理对象 管理上面的资源, 但是也存在上面的问题.</p>\n<p>所以要想安全的销毁对象最好在其他线程都看不到的情况下偷偷进行. (垃圾回收原理, 所有人用不到的东西一定是垃圾)</p>\n<p>所以可以再资源管理对象中增加引用计数, 外部对象在释放资源管理对象中资源的时候, 只是将引用计数减一, 当引用计数为0的时候 在进行释放.</p>\n<p>C++可能出现的内存问题</p>\n<ul>\n<li>缓冲区溢出<br>使用<code>std::vector&lt;char&gt;/std::string</code>或者自己编写<code>Buffer Class来管理缓冲区</code>. 记住缓冲区长度, 通过成员函数而不是裸指针修改缓冲区</li>\n<li>空悬指针/野指针<br>使用shared_ptr/weak_ptr</li>\n<li>重复释放<br>使用scoped_ptr, 只在对象析构的时候释放一次</li>\n<li>内存泄漏<br>使用scoped_ptr, 对象析构时自动释放内存</li>\n<li>不配对的new[]/delete<br>把new[] 统统替换成std::vector, scoped_array</li>\n<li>内存碎片</li>\n</ul>\n<p>使用智能指针存在的一些问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Book(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; name) :name_(name) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DoSomething</span><span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookShelf</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Register</span><span class=\"params\">(<span class=\"built_in\">std</span>::weak_ptr&lt;Book&gt; book)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        books_.push_back(book);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CheckBook</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 锁争用</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里开头上锁 很可能影响其他的函数, 因为这里调用了用户提供的函数, 等待时间可能会非常长</span></span><br><span class=\"line\">        <span class=\"comment\">// 比如Register函数就没有办法在这段时间中插入新的book</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// mutex lock 开头上锁 保护vector</span></span><br><span class=\"line\">        Iterator iter = books_.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (iter != books_.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;Book&gt; <span class=\"title\">obj</span><span class=\"params\">(iter-&gt;lock())</span></span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (obj)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                obj-&gt;DoSomething();</span><br><span class=\"line\">                iter++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                iter = books_.erase(iter);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 这样就强制要求了Book必须以shared_ptr管理</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::weak_ptr&lt;Book&gt;&gt;::iterator Iterator;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<p>在对象的成员变量vector中保存shared_ptr 会导致管理的资源无法被释放, 因为引用计数最少为1.<br>如果保存weak_ptr可能会导致vector只增不减, 因为weak_ptr只管自己管理的资源, 不管自己.<br>通过定制shared_ptr的析构函数可以解决这个问题</p>\n<p>如果将某个类的this指针 bind到一个function对象, 可能在函数调用时传进入一个已经被释放的对象地址<br>建议使用shared_ptr解决上面的问题, 如果想要获得this指针对应的shared_ptr, 可以另类继承<br><code>enable_shared_from_this&lt;T&gt;</code>, 通过在bind函数绑定<code>shared_from_this()返回的shared_ptr</code>.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookShelf</span>:</span><span class=\"built_in\">std</span>::enable_shared_from_this&lt;BookShelf&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Book对象固然可以销毁, 但是出现了轻微的内存泄漏</span></span><br><span class=\"line\">    <span class=\"comment\">// book_只增不减!!!!. 虽然Book对象销毁了但是book_中依然保存着weak_ptr</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以需要定制析构功能</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;Book&gt; <span class=\"title\">GetBook</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;bookname)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;Book&gt; pbook;</span><br><span class=\"line\">        <span class=\"comment\">// 上锁</span></span><br><span class=\"line\">        <span class=\"built_in\">std</span>::weak_ptr&lt;Book&gt;&amp; wkbook = books_[bookname];</span><br><span class=\"line\">        pbook = wkbook.lock();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!pbook)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// pbook.reset(new Book(bookname));</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 依然有问题 绑定this指针可能到时候this指向的对象已经不复存在了</span></span><br><span class=\"line\">            <span class=\"comment\">// pbook.reset(new Book(bookname),</span></span><br><span class=\"line\">            <span class=\"comment\">//   std::bind(&amp;BookShelf::DeleteBook, this, std::placeholders::_1));</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 注意shared_from_this不能在构造函数中调用, 因为构造Bookshelf的时候 他还没有</span></span><br><span class=\"line\">            <span class=\"comment\">// 被交给shared_ptr管理</span></span><br><span class=\"line\">            pbook.reset(<span class=\"keyword\">new</span> Book(bookname),</span><br><span class=\"line\">                <span class=\"built_in\">std</span>::bind(&amp;BookShelf::DeleteBook, shared_from_this(), <span class=\"built_in\">std</span>::placeholders::_1));</span><br><span class=\"line\"></span><br><span class=\"line\">            wkbook = pbook;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pbook;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, <span class=\"built_in\">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteBook</span><span class=\"params\">(Book* book)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (book)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 上锁</span></span><br><span class=\"line\">            books_.erase(book-&gt;GetName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> book;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>然而上面的代码依然有问题<br>依然有个问题. BookShelf的生命期似乎被意外延长了, 他不会短于function对象<br>所以改用weak_pr不就可以了吗</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookShelf</span>:</span><span class=\"built_in\">std</span>::enable_shared_from_this&lt;BookShelf&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;Book&gt; <span class=\"title\">GetBook</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;bookname)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;Book&gt; pbook;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::weak_ptr&lt;Book&gt;&amp; wkbook = books_[bookname];</span><br><span class=\"line\">        pbook = wkbook.lock();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!pbook)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            pbook.reset(<span class=\"keyword\">new</span> Book(bookname),</span><br><span class=\"line\">                <span class=\"built_in\">std</span>::bind(&amp;BookShelf::WkDeleteCallback,</span><br><span class=\"line\">                    <span class=\"built_in\">std</span>::weak_ptr&lt;BookShelf&gt;(shared_from_this()),</span><br><span class=\"line\">                    <span class=\"built_in\">std</span>::placeholders::_1));</span><br><span class=\"line\"></span><br><span class=\"line\">            wkbook = pbook;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pbook;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>, <span class=\"built_in\">std</span>::weak_ptr&lt;Book&gt;&gt; books_;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">WkDeleteCallback</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::weak_ptr&lt;BookShelf&gt; wk_shelf, Book* book)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;BookShelf&gt; <span class=\"title\">bookshelf</span><span class=\"params\">(wk_shelf.lock())</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bookshelf)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            DeleteBook(book);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> book;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeleteBook</span><span class=\"params\">(Book* book)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (book)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 上锁</span></span><br><span class=\"line\">            books_.erase(book-&gt;GetName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>第一章已经读完了, 笔记只有上面那点. 我在学习Linux高性能服务器编程的大二上半年时间照着书边读边写笔记, 然后后来到了大二下我改成了读完一部分后脑中有什么记什么, 重要的地方如果记不清写不出来就去再看一下. 这样花费在记笔记的时间就少了很多, 写出来的笔记更加方便自己阅读.</p>\n<p>第一章部分内容能看懂 真是谢了之前看的那个项目代码, 那个项目中大量使用了智能指针, 我在读哪个项目的代码的时候查了不少的东西, 现在才能看懂第一章的部分东西.<br>然而大部分?的东西感觉还是似懂非懂, 想写又写不出什么来. 我对于智能指针的使用还是过于晚了把.</p>\n<p>第一章看来后续还要读一遍了</p>\n<h2 id=\"第二章-线程同步精要\"><a href=\"#第二章-线程同步精要\" class=\"headerlink\" title=\"第二章 线程同步精要\"></a>第二章 线程同步精要</h2><p><strong>线程同步的四项原则</strong><br>按重要性排列</p>\n<ol>\n<li>最低限度的共享对象, 减少需要同步的场合, <em>不用就不需要同步了nice!!!</em></li>\n<li>使用高级的并发编程构建, 线程池, 队列, 倒计时</li>\n<li>不得已使用底层同步原语时, 只使用非递归的互斥器和条件变量, 慎用读写锁, 不要用信号量</li>\n<li>除了使用atomic整数外, 不要自己编写lock-free代码, 也不要用内核级的同步原语. 不凭空猜测<br>哪种做法性能更好 比如自旋锁和互斥锁</li>\n</ol>\n<p><strong>互斥器 mutex</strong><br>使用mutex的原则</p>\n<ul>\n<li>使用RAII手法封装mutex的创建销毁加锁解锁这四个操作, 不会因异常而忘记解锁</li>\n<li>只使用非递归的mutex即不可重入的mutex<br>容易排查错误 使用递归mutex问题可能出现也可能不出现(可能由于逻辑问题对一个mutex加锁两次), 而使用非递归即可发现错误并改正</li>\n<li>不手工调用lock()和unlock() 函数, <em>一切交给栈上的Guard对象的构造和析构函数负责</em></li>\n<li>Gruad对象的生命期正好等于临界区</li>\n</ul>\n<p>次要原则</p>\n<ul>\n<li>不使用跨进程的mutex, 进程间通信只用TCP sockets</li>\n<li>加锁解锁在同一个线程 不会出现跨线程的操作 (RAII自动保证)</li>\n<li>不忘记解锁(包括各种提前返回和异常抛出) 不重复解锁 均由RAII自动保证</li>\n<li>必要时考虑用PTHREAD_MUTEX_ERRORCHECK来排错</li>\n</ul>\n<p><strong>封装MutexLock MutexLockGuard Condition</strong><br>在Linux高性能服务器编程中 我也看过了封装mutex, 不过当时并没有使用RAII<br>从这里开始算是对RAII(Resource Acquisition Is Initialization)有了了解</p>\n<p><a href=\"https://zh.cppreference.com/w/cpp/language/raii\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/language/raii</a><br>拥有open()/close()、lock()/unlock()，或 init()/copyFrom()/destroy()成员函数的类是非RAII类的典型例子</p>\n<p>RAII将资源封装入一个类 如MutexLock类</p>\n<ul>\n<li>构造函数请求资源, 建立所有类不变式, 或在无法完成时抛出异常</li>\n<li>析构函数释放资源并绝不抛出异常<br>始终经由RALL类的实例使用满足要求的资源如MutexLockGuard类, 资源需满足</li>\n<li>自身拥有自动存储期或临时生存期</li>\n<li>或具有与自动或临时对象的生存期绑定的生存期</li>\n</ul>\n<p>自己的理解就是经由RAII类生存期管理资源, RAII生存期开始即使用资源,<br>当RAII类生存期结束, RAII类中保存着的资源也自动销毁<br>RAII可以有效防止上面那些成对函数调用前一个后 由于异常抛出提前返回等 后一个函数没有被调用 造成资源状态异常</p>\n<p><strong>线程安全的Singleton实现</strong><br>这个类在 flamingo 中也见到了, 这次是升级版<br>借由pthread_once保证线程安全</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> :</span> noncopyable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> T&amp; <span class=\"title\">GetInstance</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        pthread_once(&amp;ponce_, Init);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *value_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Singleton();</span><br><span class=\"line\">    ~Singleton();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        value_ = <span class=\"keyword\">new</span> T();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">pthread_once_t</span> ponce_;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> T *value_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"keyword\">pthread_once_t</span> Singleton&lt;T&gt;::ponce_ = PTHREAD_ONCE_INIT;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">T* Singleton&lt;T&gt;::value_ = <span class=\"literal\">nullptr</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>copy-on-write?? copy-on-other-write!!</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::pair&lt;<span class=\"built_in\">string</span>, <span class=\"keyword\">int</span>&gt; Entry;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Entry&gt; EntryList;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, EntryList&gt; Map;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;Map&gt; MapPtr;</span><br><span class=\"line\"></span><br><span class=\"line\">MapPtr data_;</span><br></pre></td></tr></table></figure>\n<p>好的现在数据存储在data_ 中 系统中存在多个读线程和一个写线程 针对data_<br>如果写线程不管不顾 有数据就往data_中写入 出现了读写进程同时访问data_就会出问题.<br>就书中描述来意思来说 不用大刀阔斧的使用读写锁, 能用mutex简单解决为什么要用读写锁.<br>那么如何保证读写安全呢?</p>\n<p>当读进程读的时候 拷贝一次data_ data_的引用计数至少为2.<br>就在这时写进程判断 data_引用计数不为1, 于是拷贝原来指向的map, 然后将data_ reset指向新的map<br>这时data_引用计数变为1 可以正常写了. 而读进程中保存的map拷贝是稍久的 引用计数降为1, 执行完后就自动析构了旧数据</p>\n<p>下面的代码 读部分只在GetData中加锁, 缩小了临界区</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MapPtr <span class=\"title\">GetData</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// binding reference of type ‘MutexLock&amp;’ to ‘const MutexLock’ discards qualifiers</span></span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CustomerData::Query</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;custmoner, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;stock)</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    MapPtr data = GetData();</span><br><span class=\"line\">    Map::const_iterator entries = data-&gt;<span class=\"built_in\">find</span>(custmoner);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (entries != data-&gt;<span class=\"built_in\">end</span>())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> FindEntry(entries-&gt;second, stock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CustomerData::Update</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;customer, <span class=\"keyword\">const</span> CustomerData::EntryList &amp;entries)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">MutexLockGuard <span class=\"title\">lock</span><span class=\"params\">(mutex_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!data_.unique())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"function\">MapPtr <span class=\"title\">new_data</span><span class=\"params\">(<span class=\"keyword\">new</span> Map(*data_))</span></span>;</span><br><span class=\"line\">        data_.swap(new_data);</span><br><span class=\"line\">        <span class=\"comment\">// sawp后 先前某个线程通过GetData拿到MapPtr 他会读到稍旧的数据</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    assert(data_.unique());</span><br><span class=\"line\">    (*data_)[customer] = entries;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第三章-多线程服务器的适用场合与常用编程模型\"><a href=\"#第三章-多线程服务器的适用场合与常用编程模型\" class=\"headerlink\" title=\"第三章 多线程服务器的适用场合与常用编程模型\"></a>第三章 多线程服务器的适用场合与常用编程模型</h2><p>单线程服务器常用的编程模型<br><code>non-blocking IO + IO multiplexing</code> 即为<code>Reactor模式</code><br>程序的基本结构是一个事件循环, 以事件驱动和事件回调的方式实现业务逻辑</p>\n<p>本质的缺点<br>要求事件回调函数必须是非阻塞的, 单线程还阻塞 这还怎么玩…<br>对于涉及网络IO的请求响应式协议, 容易割裂业务逻辑, 使其散布于多个回调函数中</p>\n<p>多线程服务器常用编程模型</p>\n<ol>\n<li>每个请求创建一个线程, 使用阻塞式IO操作</li>\n<li>使用线程池, 同样是阻塞式IO操作</li>\n<li>非阻塞IO + IO多路复用 即Java NIO方法</li>\n<li>领导者追随者等高级模式</li>\n</ol>\n<p>推荐的C++多线程服务器端编程模式为 one (event) loop per thread + thread pool<br>一个线程一个事件循环 + 线程池<br>事件循环用作IO多路复用, 配合非阻塞IO和定时器<br>线程池用作计算, 具体可以是任务队列或生产者消费者队列</p>\n<p>必须使用单线程的场合</p>\n<ul>\n<li>程序可能会fork</li>\n<li>限制程序的CPU占用率 一个线程最多占满一个核心</li>\n</ul>\n<p>适用多线程程序的场景</p>\n<ul>\n<li>有多个CPU可用, 单核机器上多线程没有性能优势</li>\n<li>线程间有共享数据, 否则建议使用 主进程+工作进程 每个进程都是单线程的模型</li>\n<li>共享数据是可以修改的. 如果数据不能修改可以进程间使用共享内存</li>\n<li>事件响应有优先级差异, 防止优先级反转</li>\n<li>程序要有相当的计算量</li>\n<li>利用异步操作</li>\n<li>能享受到增加CPU数目带来的好处</li>\n<li>多线程有有效地划分责任与功能</li>\n</ul>\n<p>后面大部分我都是看看就过去了, 自己没有丝毫经验 也不打算现在细看</p>\n<h2 id=\"第四章-C-多线程系统编程精要\"><a href=\"#第四章-C-多线程系统编程精要\" class=\"headerlink\" title=\"第四章 C++多线程系统编程精要\"></a>第四章 C++多线程系统编程精要</h2><p>学习多线程编程面临的最大思维方式转变</p>\n<ul>\n<li>当前进程随时可能被切出去</li>\n<li>多线程程序中事件的发生顺序不再有全局统一的先后关系</li>\n</ul>\n<p>常用的11个pthreads函数</p>\n<ul>\n<li>pthread_create() pthread_join()</li>\n<li>pthread_mutex_(create/destory/lock/unlock)</li>\n<li>pthread_cond_(create/destory/wait/signal/broadcast)</li>\n</ul>\n<p>多线程系统编程的难点不在于学习线程原语, 而在于理解多线程与现有的C/C++库函数和系统调用的交互关系<br>以进一步学习如何设计并实现线程安全且高效的程序</p>\n<p>pthread_t并不适合作为程序中对线程的标识符</p>\n<ul>\n<li>他可能会同一进程的两个线程相同</li>\n<li>或者是不利于打印</li>\n<li>无法判断其是否非法</li>\n<li>文件系统中没有对应项</li>\n<li>脱离进程便没意义</li>\n</ul>\n<p>推荐使用gettid()作为线程标识符</p>\n<ul>\n<li>任何时刻都是全局唯一的</li>\n<li>类型为pid_t通常为一个小整数利于在日志中打印.</li>\n<li>0就是非法值1, 因为操作系统第一个进程init的pid是1</li>\n<li>在现代Linux中, 他直接表示内核的任务调度id, 容易在/proc文件系统中找到对应项</li>\n<li>在其他系统工具中也容易定位到某一个具体线程, 列如使用top按线程列出任务,<br>便可以找到线程id, 再根据程序日志判断是哪一个具体线程</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .h</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> __thread <span class=\"keyword\">int</span> t_cachedTid;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cacheTid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">tid</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__builtin_expect(t_cachedTid == <span class=\"number\">0</span>, <span class=\"number\">0</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        cacheTid();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t_cachedTid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// .cpp</span></span><br><span class=\"line\">__thread <span class=\"keyword\">int</span> t_cachedTid = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CurrentThread::cacheTid</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t_cachedTid == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        t_cachedTid = gettid();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// .cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">gettid</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">pid_t</span>&gt;(::syscall(SYS_gettid));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>thread<br>只能修饰POD类型, 不能修饰class类型, 因为无法自动调用构造析构函数. 可以用于修饰全局变量函数内的静态变量.是GCC内置的线程局部存储设施，存取效率可以和全局变量相比。</strong>thread变量每一个线程有一份独立实体，各个线程的值互不干扰.</p>\n<p><strong>builtin_expect<br>这个指令是gcc引入的，作用是允许程序员将最有可能执行的分支告诉编译器。这个指令的写法为：</strong>builtin_expect(EXP, N)。<br>意思是：EXP==N的概率很大. 就图中代码翻译过来就是 <code>t_cachedTid == 0</code>为<code>0(假)</code>, 即为<code>t_cachedTid</code>最可能不是0.</p>\n<ul>\n<li>使用同一个class创建线程, 全局统一. 一般不会为每个网络连接创建线程, 除非并发数与cpu数目相同<br>一个服务程序的线程数目应该与当前负载无关, 而应该有CPU数目有关.</li>\n<li>程序运行期间不要再创建和销毁线程, 最好在初始化的时候创建所有的线程</li>\n</ul>\n<p>线程销毁的方式</p>\n<ul>\n<li>正常死亡, 从线程主函数返回, 线程正常退出</li>\n<li>非正常死亡, 从线程主函数抛出异常或线程触发segfault信号等非法操作</li>\n<li>自杀 调用pthread_exit() 立刻终止线程</li>\n<li>他杀 其他线程调用pthread_cancel() 来强制终止某个线程</li>\n</ul>\n<p>线程只有一种正常死亡方式, 即第一种 其他方法都是错的Java中甚至把相关函数都废弃了</p>\n<p>每个文件描述符只由一个线程操作, 从而解决消息收发的顺序问题, 把一个文件描述符读写分开未必会提高性能. 同时我们不知道epoll_wait阻塞的时候, 其他线程添加新的fd会发生什么. 为了稳妥起见应该把对同一个epollfd的操作放入同一个线程中执行.</p>\n<p><strong>包装文件描述符和连接</strong><br>用Socket对象包装文件描述符<br>所有对此文件描述符的读写操作都通过此对象进行, 对象的析构函数里关闭文件描述符. 这样只要Socket对象还活着 就不会与其他Socket对象有相同的文件描述符, 也就不会发生串话. 包装文件描述符已经见过了, 同样是在flamingo中看到的.</p>\n<p>用Tcpconnection包装连接<br>如果仅仅记住 fd = 8 这样的文件描述符, A线程accept后转身去处理业务B线程把 fd = 8 给关闭了!! 同时accept一个新的fd 同样是8!!. 这时A线程回复就会出现问题. 所以应该持有封装了Socket对象的Tcpconnection, 保证请求处理期间 文件描述符不会被关闭. 或者是持有Tcpconnection的弱引用. 这样就能知道 fd = 8 到底是原来的还是被关闭后新创建的. Tcpconnection对象不能提前销毁, 所以使用了shared_ptr来管理其生存期, 保证不会提前销毁造成串话.</p>\n<h2 id=\"第五章-高效的多线程日志\"><a href=\"#第五章-高效的多线程日志\" class=\"headerlink\" title=\"第五章 高效的多线程日志\"></a>第五章 高效的多线程日志</h2><p>日志库大体分为前端和后端两部分, 两端之间的联系可能简单到只有一个函数<br>大多数感觉都是宏命令</p>\n<p>日志的滚动也很重要 根据文件大小 和 时间 自动创建新的日志文件, 而不是全写入一个文件中</p>\n<p>避免出现正则表达的元字符(列如我最喜欢的<code>&#39;[&#39;和&#39;]&#39;</code>) 便于使用正则表达式查找</p>\n<p>这一章的笔记是在我照着代码实现了简单的相似功能后才写的, 记录一下好的地方<br>大体分为了 LogStream类和Logger类 前者负责通过<code>&lt;&lt;</code>维护LogBuffer缓冲区, 后者做包装提供接口<br>LogBuffer使用了简单的数组作为缓冲区, 使用Append添加内容 维护写指针</p>\n<p>LogStream重载了多种 参数情况, char和char* 很方便写入到缓冲区中<br>数字则需要转化成字符串</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(short num);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">unsigned</span> short num);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">int</span> num);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">unsigned</span> num);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">long</span> num);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> num);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> num);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> num);</span><br><span class=\"line\"></span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">char</span> str);</span><br><span class=\"line\">LogStream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str);</span><br></pre></td></tr></table></figure>\n\n<p>转化函数, 不得不说设计的真好. 通过模板解决了多种数字类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> digits_character[] = <span class=\"string\">\"0123456789\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// LEARN https://www.drdobbs.com/flexible-c-1-efficient-integer-to-string/184401596</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">size_t</span> <span class=\"title\">Convert</span><span class=\"params\">(<span class=\"keyword\">char</span> buff[], T value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    T i = value;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* p = buff;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> lsd = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">unsigned</span>&gt;(i % <span class=\"number\">10</span>);</span><br><span class=\"line\">        i /= <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"comment\">// *p++ = '0' + lsd; 不高效</span></span><br><span class=\"line\">        *p++ = digits_character[lsd];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (i != <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        *p++ = <span class=\"string\">'-'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *p = <span class=\"string\">'\\0'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// LEARN 原文中是从buff最后一个字节开始写入 但是这里需要从开头写入 所以改为倒置一下</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::reverse(buff, p);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p - buff;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">LogStream::FormatInteger</span><span class=\"params\">(T t)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (buffer_.WriteableBytes() &gt; MAX_NUMBER_SIZE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">size_t</span> len = Convert(buffer_.WritePeek(), t);</span><br><span class=\"line\">        buffer_.MoveWritePeek(len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将格式化也单独出了一个类</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fmt</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">    Fmt(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* fmt, T val);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">GetData</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buff_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetLength</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> length_;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buff_[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> length_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\">Fmt::Fmt(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* fmt, T val)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static_assert</span>(<span class=\"built_in\">std</span>::is_arithmetic&lt;T&gt;::value == <span class=\"literal\">true</span>, <span class=\"string\">\"Must be arithmetic type\"</span>);</span><br><span class=\"line\">    length_ = <span class=\"built_in\">snprintf</span>(buff_, <span class=\"keyword\">sizeof</span> buff_, fmt, val);</span><br><span class=\"line\">    assert(length_ &lt; <span class=\"keyword\">sizeof</span> buff_);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Logger类的设计<br>方便了日志的打印, 实现了高效的转换</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> LogLevel</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    DEBUG,</span><br><span class=\"line\">    INFO,</span><br><span class=\"line\">    WARN,</span><br><span class=\"line\">    ERROR,</span><br><span class=\"line\">    FATAL,</span><br><span class=\"line\">    NUM_LOG_LEVELS <span class=\"comment\">/* 仅用于表示LogLevel元素个数 不做实际使用 */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// LEARN 处处保持长度一致 使用NUM_LOG_LEVELS表示大小</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* LogLevelName[Logger::NUM_LOG_LEVELS] =</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"DEBUG \"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"INFO  \"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"WARN  \"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"ERROR \"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"FATAL \"</span>,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>字符串指针包装类, 减少strlen的调用 或者字符串没有终止</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LEARN 临时包装字符串指针和长度</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    T(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str, <span class=\"keyword\">size_t</span> len):</span><br><span class=\"line\">    str_(str),</span><br><span class=\"line\">    len_(len)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        assert(<span class=\"built_in\">strlen</span>(str) == len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str_;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">size_t</span> len_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>使用内部类Impl包装了LogStream LogStream负责的是单纯的维护缓冲区 重载各种运算符.<br>Impl的构造函数输出了日志前边的固定部分<br>Logger的构造函数负责根据有无函数名等重载输出额外的固定内容<br>构造和析构之间完成 纯用户自定义部分输出<br>Logger的析构函数负责输出每条日志的结尾部分 文件名和行号</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Impl</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> Logger::LogLevel LogLevel;</span><br><span class=\"line\">    Impl(LogLevel level, <span class=\"keyword\">const</span> SourceFile&amp; file, <span class=\"keyword\">int</span> <span class=\"built_in\">line</span>);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">FormatTime</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Finish</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Timestamp time_;</span><br><span class=\"line\">    LogStream stream_;</span><br><span class=\"line\">    LogLevel level_;</span><br><span class=\"line\">    SourceFile filename_;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> line_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>内部类SourceFile负责将<code>__FILE__</code>宏产生的字符数组转换成单纯的文件名. 使用了数组引用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SourceFile</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        * 数组的引用 使数组在传参时不会降为 指针</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">    <span class=\"keyword\">template</span>&lt;<span class=\"keyword\">int</span> N&gt;</span><br><span class=\"line\">    SourceFile(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;arr)[N]):</span><br><span class=\"line\">    data_(arr),</span><br><span class=\"line\">    size_(N - <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name = <span class=\"built_in\">strrchr</span>(data_, <span class=\"string\">'/'</span>); <span class=\"comment\">/* /name */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            data_ = name + <span class=\"number\">1</span>;</span><br><span class=\"line\">            size_ -= <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(data_ - arr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* data_;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size_;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其他高效设计</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LEARN 缓存上一次输出的秒 同一秒输出时避免多次格式化</span></span><br><span class=\"line\"><span class=\"comment\">// 同一秒输出仅仅格式化 微秒部分</span></span><br><span class=\"line\">__thread <span class=\"keyword\">char</span> t_time[<span class=\"number\">64</span>];</span><br><span class=\"line\">__thread <span class=\"keyword\">time_t</span> t_last_second;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第二部分-muduo网络库\"><a href=\"#第二部分-muduo网络库\" class=\"headerlink\" title=\"第二部分 muduo网络库\"></a>第二部分 muduo网络库</h1><h2 id=\"第六章-muduo网络库简介\"><a href=\"#第六章-muduo网络库简介\" class=\"headerlink\" title=\"第六章 muduo网络库简介\"></a>第六章 muduo网络库简介</h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/ClassDiagram.png\" alt=\"\"></p>\n<p>看完前面的一小部分, 我真心觉得这个库跟之前那个flamingo特别像, 估计这种管理方式就是某种主流方式?<br>估计我以后自己写的时候也是会按照这个模式来写了吧</p>\n<p>TCP网络编程最本质的是处理三个半事件</p>\n<ul>\n<li>连接的建立</li>\n<li>连接断开 主动断开close 被动断开 read返回0</li>\n<li>消息到达, 文件描述符可读. 最为重要的一个事件, 对它的处理方式决定了网络编程的风格.(阻塞还是非阻塞, 如何处理分包, 应用层缓冲如何设计)</li>\n<li>消息发送完毕 这算半个</li>\n</ul>\n<p>现在存在的问题</p>\n<ul>\n<li>如果保证发送完应用层缓冲区数据才断开连接<br>自己思考的可以设立标志位, 如果设置了标志位发送完成后检测标志位 关闭连接</li>\n<li>如果要主动发起连接, 但是对方主动拒绝, 如何定期重试<br>按照TCP重试机制 发送SYN 开启定时器 如果定时内没有收到确认ACK则重发SYN</li>\n</ul>\n<p>这里了解到一个词 前向声明,<br>在程序设计中，前向声明（Forward Declaration）是指声明标识符(表示编程的实体，如数据类型、变量、函数)时还没有给出完整的定义。<br>通常为了简化头文件的关系 可以在A的头文件中 声明<code>class B</code>, 这样在你的代码中就可以使用<code>B*</code>而不需要引入B的头文件</p>\n<h2 id=\"第七章-muduo编程示例\"><a href=\"#第七章-muduo编程示例\" class=\"headerlink\" title=\"第七章 muduo编程示例\"></a>第七章 muduo编程示例</h2><p>本章大部分都是实战小例子, 自然要在代码中注释了.<br>博客这里就简单写一写<br><strong>关于<code>input buffer</code>和<code>output buffer</code>已经有所了解过</strong></p>\n<p><code>output buffer</code>在<code>write</code>调用一次没有发送完全的时候起到大用途. 一次没有发送完不应该等待在那里, 应该是接管这些未发送的数据, 阻塞代价是很大的. 应该是注册<code>EPILOUT</code>事件, 直到数据全部发送完毕. 否则就一直注册事件, 当然这是在连接正常的时候.<br>使用<code>output buffer</code>还有一个小问题, 一般情况下一次发送未完成才会使用到<code>output buffer</code>. 当缓冲区中存在数据的时候. 下一次的数据不能进行发送, 而应该是直接追加到尾部.</p>\n<p><code>input buffer</code>某种意义上作用更大, 这涉及到一个重要概念”粘包”的处理. </p>\n<p>这里我了解到了<code>capacity()</code>机制, 可以用来减少内存分配次数. <code>capacity()</code>代表预分配的内存大小,<br>而<code>size()</code>是你写入的数据大小, 当<code>size == capacity</code>的时候<code>再写入内容</code>内存会分配更长的一个数组将旧数据拷贝过去<code>size()</code>依然是你写入的大小, <code>capacity()</code>则会变大</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">char</span>&gt; <span class=\"title\">buff</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>; <span class=\"comment\">// 填充了20个元素 0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foo</span><span class=\"params\">(<span class=\"keyword\">size_t</span> <span class=\"built_in\">size</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    buff.resize(<span class=\"built_in\">size</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%ld %ld\\n\"</span>, buff.<span class=\"built_in\">size</span>(), buff.capacity());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%ld %ld\\n\"</span>, buff.<span class=\"built_in\">size</span>(), buff.capacity()); <span class=\"comment\">// 20 20</span></span><br><span class=\"line\">    Foo(<span class=\"number\">512</span>); <span class=\"comment\">// 512 512</span></span><br><span class=\"line\">    Foo(<span class=\"number\">1024</span>); <span class=\"comment\">// 1024 1024</span></span><br><span class=\"line\">    Foo(<span class=\"number\">1025</span>); <span class=\"comment\">// 1025 2048</span></span><br><span class=\"line\">    Foo(<span class=\"number\">2048</span>); <span class=\"comment\">// 2048 2048</span></span><br><span class=\"line\">    Foo(<span class=\"number\">2049</span>); <span class=\"comment\">// 2049 4096</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>花了小半天时间去了解配置了下 protobuf, 是一把很锋利的剑不错!</p>\n<p>网络编程中使用protobuf的两个先决条件</p>\n<ul>\n<li>长度问题, protobuf打包的数据没有自带长度信息或终结符, 这就需要程序自己在发送和接受的时候做正确的切分</li>\n<li>类型问题, protobuf打包的数据没有自带类型信息, 需要由发送方把类型信息传给接收方, 接收方创建对应的具体protobuf message对象, 再做反序列化</li>\n</ul>\n<p>我第一印象解决上面的方法, 就如书中所言是山寨的做法…. 增加header部分</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/protobuf%20class.png\" alt=\"Protobuf类图\"></p>\n<p>大概意思就是大部分人通过在头部增加代号标识消息类型(具体对应那个message), 而protobuf提供了<br>根据反射 根据typename 选择对应的Message对象的功能, 由于我没有用过protobuf 目前不是很了解 不过大概就这样了, 后续会专门学习 先用即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// eg typename=muduo.Query</span></span><br><span class=\"line\">google::<span class=\"function\">protobuf::Message* <span class=\"title\">ProtobufCodec::createMessage</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; typeName)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    google::protobuf::Message* message = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> google::protobuf::Descriptor* descriptor =</span><br><span class=\"line\">        google::protobuf::DescriptorPool::generated_pool()-&gt;FindMessageTypeByName(typeName);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (descriptor)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> google::protobuf::Message* prototype =</span><br><span class=\"line\">            google::protobuf::MessageFactory::generated_factory()-&gt;GetPrototype(descriptor);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prototype)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            message = prototype-&gt;New(); <span class=\"comment\">// 返回的是动态创建的指针</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;google::protobuf::Message&gt; MessagePtr;</span><br><span class=\"line\">MessagePtr message;</span><br><span class=\"line\">message.reset(createMessage(typeName)); <span class=\"comment\">// 接管指针</span></span><br></pre></td></tr></table></figure>\n\n<p>作者设计的格式如下<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/MultithreadingServer/protobuf%E4%BC%A0%E8%BE%93%E6%A0%BC%E5%BC%8F.png\" alt=\"\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// int32_t version; 根本不需要版本号</span></span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> len; <span class=\"comment\">// 没有使用uin32_t 是为了跨语言, Java没有unsigned</span></span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> namelen;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> type_name[namelen]; <span class=\"comment\">// 以 /0 结尾 方便接收方处理 节省strlen() 空间换时间</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> protobuf_data[len-namelen<span class=\"number\">-8</span>]</span><br><span class=\"line\">    <span class=\"keyword\">int32_t</span> checksum; <span class=\"comment\">// adler32算法 进行校验</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>终于知道编码器解码器合起来叫什么了… 编解码器(codec)</p>\n<p>后面的一些例子就跳过了, 去准备阅读第八章然后动手写库了 这里才是重点 至于例子当时候自己再写.<br>自己的库不香吗?</p>\n<h2 id=\"第八章-muduo网路库设计与实现\"><a href=\"#第八章-muduo网路库设计与实现\" class=\"headerlink\" title=\"第八章 muduo网路库设计与实现\"></a>第八章 muduo网路库设计与实现</h2><p><del>第八章从第0节开始 一看就是程序员</del></p>\n<p>2020年4月27日11:02:12 距离写完上一行博客已经过去不短的时间了.<br>这段时间我仿照muduo从中抽了部分功能做了自己的mongo库, 然后我将muduo Protobuf作为附属<br>改成了ProtobufServer(包装了TcpServer).</p>\n<p>之后我便重新编写UE4部分的Protobuf收发部分的代码.<br>昨天晚上总算是将UE4打飞机的单机版 成功改造成了联机版. 使用的帧同步<br>服务器稳定性极佳, 而且内存占用很低, 想到了我之前写的Java服务器. 服务器CPU性能占用极少.</p>\n<p>初期设计的时候 单机每秒发送12包, 每包平均0.16kb. 单机每秒就是2kb.  如果有6个客户端<br>服务器算上广播 出站流量 72kb/s</p>\n<p>跑了下iftop看了下基本是这样.<br>12*6 = 72kb/s</p>\n<p>阿里云送的服务器1Mbps, 理论可以支持8个客户端同屏游戏<br>阿里云学生机5Mbps, 理论支持17个客户端同屏游戏</p>\n<p>当然了现在只同步了输入, 不过其他同步内容消耗的流量就很少了.</p>\n<p>服务器程序运行良好, 倒是UE4 偶尔会崩….</p>\n<p>后面慢慢完善打飞机和服务器</p>\n<p>使用框架很简单的就实现了 登录和游玩数据分开 很舒服. 当然了登录目前只是个摆设没有在服务端保存<br>跳过登录依然可以玩, 后面完善db服务器再说</p>\n<h1 id=\"第三部分-工程实践经验谈\"><a href=\"#第三部分-工程实践经验谈\" class=\"headerlink\" title=\"第三部分 工程实践经验谈\"></a>第三部分 工程实践经验谈</h1><h2 id=\"第九章-分布式-跳过\"><a href=\"#第九章-分布式-跳过\" class=\"headerlink\" title=\"第九章 分布式 跳过\"></a>第九章 分布式 跳过</h2><h2 id=\"第十章-C-编译链接模型精要\"><a href=\"#第十章-C-编译链接模型精要\" class=\"headerlink\" title=\"第十章 C++编译链接模型精要\"></a>第十章 C++编译链接模型精要</h2>"},{"title":"csapp笔记","date":"2020-06-07T01:09:20.000Z","top":140,"_content":"\n# 第一章 计算机系统漫游\n\n![](http://lsmg-img.oss-cn-beijing.aliyuncs.com/csapp/1-3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F.png)\n\n预处理->编译->汇编->链接\n\n```c++\n// hello.cpp\n#include <cstdio>\n#define PI 3.14\n\nint main()\n{\n    // 1111\n    //\n    printf(\"%f\\n\", PI);\n    printf(\"hello, world!\\n\");\n    return 0;\n}\n```\n\n预处理\n宏替换和注释消失 但是空行还在\n`g++ -E hello.cpp -o hello.i`\n`tail -9 hello.i`\n```c++\n# 5 \"hello.cpp\"\nint main()\n{\n\n\n    printf(\"%f\\n\", 3.14);\n    printf(\"hello, world!\\n\");\n    return 0;\n}\n```\n\n编译 生成汇编\n`g++ -S hello.i`\n```s\n\n        .file   \"hello.cpp\"\n        .text\n        .section        .rodata\n.LC1:\n        .string \"%f\\n\"\n.LC2:\n        .string \"hello, world!\"\n        .text\n        .globl  main\n        .type   main, @function\nmain:\n.LFB0:\n        .cfi_startproc\n        pushq   %rbp\n        .cfi_def_cfa_offset 16\n        .cfi_offset 6, -16\n        movq    %rsp, %rbp\n        .cfi_def_cfa_register 6\n        subq    $16, %rsp\n        movq    .LC0(%rip), %rax\n        movq    %rax, -8(%rbp)\n        movsd   -8(%rbp), %xmm0\n        leaq    .LC1(%rip), %rdi\n        movl    $1, %eax\n        call    printf@PLT\n        leaq    .LC2(%rip), %rdi\n        call    puts@PLT\n        movl    $0, %eax\n        leave\n        .cfi_def_cfa 7, 8\n        ret\n        .cfi_endproc\n.LFE0:\n        .size   main, .-main\n        .section        .rodata\n        .align 8\n.LC0:\n        .long   1374389535\n        .long   1074339512\n        .ident  \"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n\n```\n汇编 生成 可重定位二进制目标程序\ngcc编译器 -c参数 起到的作用是编译和汇编 -S参数 仅仅是编译\n`g++ -c hello.s`\n\n链接 生成执行文件\n`g++ hello.o -o hello`\n\n\n\n在不同进程间切换 交错执行的执行-上下文切换\n操作系统保持进程运行所需的所有状态信息 这种状态-上下文\n\n线程共享代码和全局数据\n\n# 第一部分 程序结构和执行\n## 第二章 信息存储\n\n孤立地讲,单个位不是非常有用. 然而, 当把位组合在一起, 再加上某种解释,即赋予不同可能位组合不同的含义, 我们就能表示任何有限集合的元素.\n\n\n# 第三章 程序的机器级表示\n\n\n\n## 第五章 优化程序性能\n\n编写高效的程序\n- 选择一组适当的算法和数据结构\n- 编写出编译器能够有效优化以转变为高效的可执行程序的源代码\n- 大项目的并行计算\n\n\n整数运算使用乘法的结合律和交换律, 当溢出的时候, 结果依然是一致的.\n但是浮点数使用结合律和交换律的时候, 在溢出时, 结果却不是一致的.\n\n整数的表示虽然只能编码一个相对较小的数值范围, 但是这种标识是精确地\n浮点数能编码一个较大的数值范围, 但是这种表示只是近似的.\n\n## 第六章 存储器层次结构","source":"_posts/读书记录140-csapp.md","raw":"---\ntitle: csapp笔记\ndate: 2020-06-07 9:09:20\ncategories: \n- 读书记录\ntags:\ntop: 140\n---\n\n# 第一章 计算机系统漫游\n\n![](http://lsmg-img.oss-cn-beijing.aliyuncs.com/csapp/1-3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F.png)\n\n预处理->编译->汇编->链接\n\n```c++\n// hello.cpp\n#include <cstdio>\n#define PI 3.14\n\nint main()\n{\n    // 1111\n    //\n    printf(\"%f\\n\", PI);\n    printf(\"hello, world!\\n\");\n    return 0;\n}\n```\n\n预处理\n宏替换和注释消失 但是空行还在\n`g++ -E hello.cpp -o hello.i`\n`tail -9 hello.i`\n```c++\n# 5 \"hello.cpp\"\nint main()\n{\n\n\n    printf(\"%f\\n\", 3.14);\n    printf(\"hello, world!\\n\");\n    return 0;\n}\n```\n\n编译 生成汇编\n`g++ -S hello.i`\n```s\n\n        .file   \"hello.cpp\"\n        .text\n        .section        .rodata\n.LC1:\n        .string \"%f\\n\"\n.LC2:\n        .string \"hello, world!\"\n        .text\n        .globl  main\n        .type   main, @function\nmain:\n.LFB0:\n        .cfi_startproc\n        pushq   %rbp\n        .cfi_def_cfa_offset 16\n        .cfi_offset 6, -16\n        movq    %rsp, %rbp\n        .cfi_def_cfa_register 6\n        subq    $16, %rsp\n        movq    .LC0(%rip), %rax\n        movq    %rax, -8(%rbp)\n        movsd   -8(%rbp), %xmm0\n        leaq    .LC1(%rip), %rdi\n        movl    $1, %eax\n        call    printf@PLT\n        leaq    .LC2(%rip), %rdi\n        call    puts@PLT\n        movl    $0, %eax\n        leave\n        .cfi_def_cfa 7, 8\n        ret\n        .cfi_endproc\n.LFE0:\n        .size   main, .-main\n        .section        .rodata\n        .align 8\n.LC0:\n        .long   1374389535\n        .long   1074339512\n        .ident  \"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0\"\n        .section        .note.GNU-stack,\"\",@progbits\n\n```\n汇编 生成 可重定位二进制目标程序\ngcc编译器 -c参数 起到的作用是编译和汇编 -S参数 仅仅是编译\n`g++ -c hello.s`\n\n链接 生成执行文件\n`g++ hello.o -o hello`\n\n\n\n在不同进程间切换 交错执行的执行-上下文切换\n操作系统保持进程运行所需的所有状态信息 这种状态-上下文\n\n线程共享代码和全局数据\n\n# 第一部分 程序结构和执行\n## 第二章 信息存储\n\n孤立地讲,单个位不是非常有用. 然而, 当把位组合在一起, 再加上某种解释,即赋予不同可能位组合不同的含义, 我们就能表示任何有限集合的元素.\n\n\n# 第三章 程序的机器级表示\n\n\n\n## 第五章 优化程序性能\n\n编写高效的程序\n- 选择一组适当的算法和数据结构\n- 编写出编译器能够有效优化以转变为高效的可执行程序的源代码\n- 大项目的并行计算\n\n\n整数运算使用乘法的结合律和交换律, 当溢出的时候, 结果依然是一致的.\n但是浮点数使用结合律和交换律的时候, 在溢出时, 结果却不是一致的.\n\n整数的表示虽然只能编码一个相对较小的数值范围, 但是这种标识是精确地\n浮点数能编码一个较大的数值范围, 但是这种表示只是近似的.\n\n## 第六章 存储器层次结构","slug":"读书记录140-csapp","published":1,"updated":"2020-12-05T02:31:35.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg7a0041f8uncc7o0le4","content":"<h1 id=\"第一章-计算机系统漫游\"><a href=\"#第一章-计算机系统漫游\" class=\"headerlink\" title=\"第一章 计算机系统漫游\"></a>第一章 计算机系统漫游</h1><p><img src=\"http://lsmg-img.oss-cn-beijing.aliyuncs.com/csapp/1-3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F.png\" alt=\"\"></p>\n<p>预处理-&gt;编译-&gt;汇编-&gt;链接</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hello.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PI 3.14</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1111</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%f\\n\"</span>, PI);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"hello, world!\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>预处理<br>宏替换和注释消失 但是空行还在<br><code>g++ -E hello.cpp -o hello.i</code><br><code>tail -9 hello.i</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">5</span> <span class=\"string\">\"hello.cpp\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%f\\n\"</span>, <span class=\"number\">3.14</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"hello, world!\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译 生成汇编<br><code>g++ -S hello.i</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">        .file   &quot;hello.cpp&quot;</span><br><span class=\"line\">        .text</span><br><span class=\"line\">        .section        .rodata</span><br><span class=\"line\">.LC1:</span><br><span class=\"line\">        .string &quot;%f\\n&quot;</span><br><span class=\"line\">.LC2:</span><br><span class=\"line\">        .string &quot;hello, world!&quot;</span><br><span class=\"line\">        .text</span><br><span class=\"line\">        .globl  main</span><br><span class=\"line\">        .type   main, @function</span><br><span class=\"line\">main:</span><br><span class=\"line\">.LFB0:</span><br><span class=\"line\">        .cfi_startproc</span><br><span class=\"line\">        pushq   %rbp</span><br><span class=\"line\">        .cfi_def_cfa_offset 16</span><br><span class=\"line\">        .cfi_offset 6, -16</span><br><span class=\"line\">        movq    %rsp, %rbp</span><br><span class=\"line\">        .cfi_def_cfa_register 6</span><br><span class=\"line\">        subq    $16, %rsp</span><br><span class=\"line\">        movq    .LC0(%rip), %rax</span><br><span class=\"line\">        movq    %rax, -8(%rbp)</span><br><span class=\"line\">        movsd   -8(%rbp), %xmm0</span><br><span class=\"line\">        leaq    .LC1(%rip), %rdi</span><br><span class=\"line\">        movl    $1, %eax</span><br><span class=\"line\">        call    printf@PLT</span><br><span class=\"line\">        leaq    .LC2(%rip), %rdi</span><br><span class=\"line\">        call    puts@PLT</span><br><span class=\"line\">        movl    $0, %eax</span><br><span class=\"line\">        leave</span><br><span class=\"line\">        .cfi_def_cfa 7, 8</span><br><span class=\"line\">        ret</span><br><span class=\"line\">        .cfi_endproc</span><br><span class=\"line\">.LFE0:</span><br><span class=\"line\">        .size   main, .-main</span><br><span class=\"line\">        .section        .rodata</span><br><span class=\"line\">        .align 8</span><br><span class=\"line\">.LC0:</span><br><span class=\"line\">        .long   1374389535</span><br><span class=\"line\">        .long   1074339512</span><br><span class=\"line\">        .ident  &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;</span><br><span class=\"line\">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>\n<p>汇编 生成 可重定位二进制目标程序<br>gcc编译器 -c参数 起到的作用是编译和汇编 -S参数 仅仅是编译<br><code>g++ -c hello.s</code></p>\n<p>链接 生成执行文件<br><code>g++ hello.o -o hello</code></p>\n<p>在不同进程间切换 交错执行的执行-上下文切换<br>操作系统保持进程运行所需的所有状态信息 这种状态-上下文</p>\n<p>线程共享代码和全局数据</p>\n<h1 id=\"第一部分-程序结构和执行\"><a href=\"#第一部分-程序结构和执行\" class=\"headerlink\" title=\"第一部分 程序结构和执行\"></a>第一部分 程序结构和执行</h1><h2 id=\"第二章-信息存储\"><a href=\"#第二章-信息存储\" class=\"headerlink\" title=\"第二章 信息存储\"></a>第二章 信息存储</h2><p>孤立地讲,单个位不是非常有用. 然而, 当把位组合在一起, 再加上某种解释,即赋予不同可能位组合不同的含义, 我们就能表示任何有限集合的元素.</p>\n<h1 id=\"第三章-程序的机器级表示\"><a href=\"#第三章-程序的机器级表示\" class=\"headerlink\" title=\"第三章 程序的机器级表示\"></a>第三章 程序的机器级表示</h1><h2 id=\"第五章-优化程序性能\"><a href=\"#第五章-优化程序性能\" class=\"headerlink\" title=\"第五章 优化程序性能\"></a>第五章 优化程序性能</h2><p>编写高效的程序</p>\n<ul>\n<li>选择一组适当的算法和数据结构</li>\n<li>编写出编译器能够有效优化以转变为高效的可执行程序的源代码</li>\n<li>大项目的并行计算</li>\n</ul>\n<p>整数运算使用乘法的结合律和交换律, 当溢出的时候, 结果依然是一致的.<br>但是浮点数使用结合律和交换律的时候, 在溢出时, 结果却不是一致的.</p>\n<p>整数的表示虽然只能编码一个相对较小的数值范围, 但是这种标识是精确地<br>浮点数能编码一个较大的数值范围, 但是这种表示只是近似的.</p>\n<h2 id=\"第六章-存储器层次结构\"><a href=\"#第六章-存储器层次结构\" class=\"headerlink\" title=\"第六章 存储器层次结构\"></a>第六章 存储器层次结构</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第一章-计算机系统漫游\"><a href=\"#第一章-计算机系统漫游\" class=\"headerlink\" title=\"第一章 计算机系统漫游\"></a>第一章 计算机系统漫游</h1><p><img src=\"http://lsmg-img.oss-cn-beijing.aliyuncs.com/csapp/1-3%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F.png\" alt=\"\"></p>\n<p>预处理-&gt;编译-&gt;汇编-&gt;链接</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hello.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PI 3.14</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1111</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%f\\n\"</span>, PI);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"hello, world!\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>预处理<br>宏替换和注释消失 但是空行还在<br><code>g++ -E hello.cpp -o hello.i</code><br><code>tail -9 hello.i</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"number\">5</span> <span class=\"string\">\"hello.cpp\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%f\\n\"</span>, <span class=\"number\">3.14</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"hello, world!\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译 生成汇编<br><code>g++ -S hello.i</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">        .file   &quot;hello.cpp&quot;</span><br><span class=\"line\">        .text</span><br><span class=\"line\">        .section        .rodata</span><br><span class=\"line\">.LC1:</span><br><span class=\"line\">        .string &quot;%f\\n&quot;</span><br><span class=\"line\">.LC2:</span><br><span class=\"line\">        .string &quot;hello, world!&quot;</span><br><span class=\"line\">        .text</span><br><span class=\"line\">        .globl  main</span><br><span class=\"line\">        .type   main, @function</span><br><span class=\"line\">main:</span><br><span class=\"line\">.LFB0:</span><br><span class=\"line\">        .cfi_startproc</span><br><span class=\"line\">        pushq   %rbp</span><br><span class=\"line\">        .cfi_def_cfa_offset 16</span><br><span class=\"line\">        .cfi_offset 6, -16</span><br><span class=\"line\">        movq    %rsp, %rbp</span><br><span class=\"line\">        .cfi_def_cfa_register 6</span><br><span class=\"line\">        subq    $16, %rsp</span><br><span class=\"line\">        movq    .LC0(%rip), %rax</span><br><span class=\"line\">        movq    %rax, -8(%rbp)</span><br><span class=\"line\">        movsd   -8(%rbp), %xmm0</span><br><span class=\"line\">        leaq    .LC1(%rip), %rdi</span><br><span class=\"line\">        movl    $1, %eax</span><br><span class=\"line\">        call    printf@PLT</span><br><span class=\"line\">        leaq    .LC2(%rip), %rdi</span><br><span class=\"line\">        call    puts@PLT</span><br><span class=\"line\">        movl    $0, %eax</span><br><span class=\"line\">        leave</span><br><span class=\"line\">        .cfi_def_cfa 7, 8</span><br><span class=\"line\">        ret</span><br><span class=\"line\">        .cfi_endproc</span><br><span class=\"line\">.LFE0:</span><br><span class=\"line\">        .size   main, .-main</span><br><span class=\"line\">        .section        .rodata</span><br><span class=\"line\">        .align 8</span><br><span class=\"line\">.LC0:</span><br><span class=\"line\">        .long   1374389535</span><br><span class=\"line\">        .long   1074339512</span><br><span class=\"line\">        .ident  &quot;GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0&quot;</span><br><span class=\"line\">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>\n<p>汇编 生成 可重定位二进制目标程序<br>gcc编译器 -c参数 起到的作用是编译和汇编 -S参数 仅仅是编译<br><code>g++ -c hello.s</code></p>\n<p>链接 生成执行文件<br><code>g++ hello.o -o hello</code></p>\n<p>在不同进程间切换 交错执行的执行-上下文切换<br>操作系统保持进程运行所需的所有状态信息 这种状态-上下文</p>\n<p>线程共享代码和全局数据</p>\n<h1 id=\"第一部分-程序结构和执行\"><a href=\"#第一部分-程序结构和执行\" class=\"headerlink\" title=\"第一部分 程序结构和执行\"></a>第一部分 程序结构和执行</h1><h2 id=\"第二章-信息存储\"><a href=\"#第二章-信息存储\" class=\"headerlink\" title=\"第二章 信息存储\"></a>第二章 信息存储</h2><p>孤立地讲,单个位不是非常有用. 然而, 当把位组合在一起, 再加上某种解释,即赋予不同可能位组合不同的含义, 我们就能表示任何有限集合的元素.</p>\n<h1 id=\"第三章-程序的机器级表示\"><a href=\"#第三章-程序的机器级表示\" class=\"headerlink\" title=\"第三章 程序的机器级表示\"></a>第三章 程序的机器级表示</h1><h2 id=\"第五章-优化程序性能\"><a href=\"#第五章-优化程序性能\" class=\"headerlink\" title=\"第五章 优化程序性能\"></a>第五章 优化程序性能</h2><p>编写高效的程序</p>\n<ul>\n<li>选择一组适当的算法和数据结构</li>\n<li>编写出编译器能够有效优化以转变为高效的可执行程序的源代码</li>\n<li>大项目的并行计算</li>\n</ul>\n<p>整数运算使用乘法的结合律和交换律, 当溢出的时候, 结果依然是一致的.<br>但是浮点数使用结合律和交换律的时候, 在溢出时, 结果却不是一致的.</p>\n<p>整数的表示虽然只能编码一个相对较小的数值范围, 但是这种标识是精确地<br>浮点数能编码一个较大的数值范围, 但是这种表示只是近似的.</p>\n<h2 id=\"第六章-存储器层次结构\"><a href=\"#第六章-存储器层次结构\" class=\"headerlink\" title=\"第六章 存储器层次结构\"></a>第六章 存储器层次结构</h2>"},{"title":"UNP记录","date":"2020-10-06T04:17:39.000Z","_content":"\n由于已经在Linux高性能服务器开发中详细说明过绝大部分系统函数\n\nLinux高性能服务器开发的重叠部分, 我会将新的点补充到原博客中, 这里仅作部分简单的说明\n\n# 第一章\n\n通过定义`包裹函数`可以缩短程序. 在muduo框架中就存在包裹函数 将系统函数进行包装\n\n函数中进行错误处理, 这样外部使用`包裹函数`包装好的系统函数的时候可以简化错误处理\n\n\n**daytimecpclient-domain.cpp**\n第一个样例程序稍作修改 可以解析域名  inet_addr没有请求网络 速度快 而gethostbyname会请求域名\n服务器速度可能慢\n```c++\nsockaddr_in server_addr{};\nif ((server_addr.sin_addr.s_addr = inet_addr(argv[1])) == INADDR_NONE)\n{\n    struct hostent* hostptr = gethostbyname(argv[1]);\n    if (!hostptr)\n    {\n        printf(\"invalid input %s\\n\", argv[1]);\n        exit(1);\n    }\n    server_addr.sin_addr.s_addr = *((unsigned long*)hostptr->h_addr);\n}\n```\n\n迭代服务器: 对于每个客户连接都执行迭代一次\n并发服务器: 同时处理多个客户连接\n\n#  第二章 传输层\n\n客户端 主动调用close之后 发送了FIN包\n\n服务端 接收到FIN包后read返回0\n\n服务器 read返回0之后调用close函数 发送FIN包\n\n客户端 接收服务器的FIN包\n\n**@@35 P TCP状态转换图@@**\n\n\n**@@36 P TCP状态转换和Socket函数间的联系@@**\n\n\n多宿主计算机  可能插有多块网卡\n\n通过bind到INADDR_ANY来监听多个接口的同一个端口\n\n\n# 第三章 套接字编程简介\n\n大多数套接字函数 都需要一个指向`套接字地址结构`的指针作为参数. 每个协议簇都定义了他自己的`套接字地址结构`. 这些结构的名字均`以sockaddr_开头`\n\n\n**@@61 P 不同套接字地址结构的比较@@**\n\n\n# 第四章 基本TCP套接字编程\n\n**connect函数**\n\nETIMEDOUT: 客户端没有收到SYN的回应 尝试几次后如果依然没有收到回应则返回错误\n\nECONNREFUSED: 服务器在指定端口上没有进程等待与之连接导致收到了RST回复  之后立即返回错误\n\nconnect失败之后 此套接字无法继续使用 需要close当前套接字后重新调用socket\n\n**bind函数**\n\n如果调用listen或者connect前没有调用bind则操作系统会分配一个临时端口. 对于客户端来说可以接受临时端口, 然而服务器一般都是需要指定端口 供外接连接. \n\n如果指定的端口为0 则认为没有指定端口 会分配临时端口. 如果地址指定为0(INADDR_ANY) 则系统选择IP地址\n\nRPC服务器可以使用临时端口, 但必须将临时端口注册到端口映射器, 这样客户端才能得到对应的临时端口, 之后进行连接\n\n可以使用getsockname获取到系统临时分配的地址和端口\n\n**listen函数**\n\nsocket函数创建的套接字默认被认为是主动套接字(准备调用connect) 使用listen函数将一个`未连接`的套接字转换成一个被动套接字\n\n内核为一个监听的系统套接字维护两个队列\n- 未完成队列 已经收到了SYN但还未完成三次握手\n- 已完成队列 已经进行了三次握手`等待accept从队列中取走` 已建立的连接 如果`此队列为空, accept阻塞`\n\n未完成队列+已完成队列的总长度 即为listen函数的第二个参数backlog\n\nconnect函数调用 -> 服务器收到了SYN包 -> 在未完成队列创建相关内容 -> 创建完毕后返回SYN和ACK -> 客户端返回ACK -> 从未完成队列移动到已完成队列队尾\n\n\nhttps://blog.csdn.net/yangbodong22011/article/details/60399728\n\n\n实际用Centos(内核为4.18版本)测试后, 实际情况为上方博客的情况. 即backlog是已完成队列大小, 而且会存在+1\n\n看到这里后想到之前遇到的一个BUG, 注册入`epollfd`中的`listenfd`没有设置成`ENONBLOCK`, `epoll_wait不会返回, 进而去调用accept`, 然而客户端`connect`函数返回显示已经建立连接.  --也就是connect返回说明连接建立, 发生在accpet函数调用前.\n\n\n当客户端发送FIN后服务器read类函数返回0\n\n**@@91 P exec函数之间的关系@@**\n\n**accept函数**\naccpet函数的第一个参数必须是 被动套接字 即调用过listen, 否则返回EINVAL错误\n\n\n# 第五章\n\n正常启动 正常终止时程序的表现与TCP协议的关系\n\n慢系统调用: 适用于那些可能永远阻塞的系统调用, accpet(没有新连接就一直阻塞), read(读取不到一直阻塞)等等.\n\nEINTR: 当阻塞于某个慢系统调用的进程, 捕获某个信号且相应信号处理函数返回时, 慢系统调用`可能`返回一个EINTR错误\n\n诸如read, write, select等来说可以忽略EINTR, 如下方这个常见的代码片段. **但是connect则不行, 否则立即返回错误??**\n\n```c++\nssize_t result = read(fd, buffer, sizeof buffer);\nif (errno == EINTR)\n{\n  continue;\n}\n\n```\n\n如果同时有N个SIGCHLD信号到达, 信号处理函数极可能执行不够N次.\n- UNIX信号没有排队概念\n- 问题导致的结果不确定, 即不确定调用多少次\n\n```c++\nvoid sigchld_handler(int signo)\n{\n  pid_t pid;\n  int stat;\n  while ((pid = waitpid(-1, &stat, WNOHANG)) > 0)\n  {\n    process\n  }\n  return;\n}\n```\n使用waitpid来获取所有已终止进程状态, 并且指定了`WNOHANG`防止不必要的阻塞.\n\n而wait则不能在这里替换waitpid, 因为wait只能阻塞\n\n\n\n**第五章 正常启动 正常终止 accept返回前终止 服务器进程终止 服务主机崩溃 主机崩溃后重启 主机关机**\n\n\n# 第六章 I/O 复用 select和poll函数\n\n进程需要一种预先告知内核的能力, 使得内核一旦发现进程指定的一个或多个I/O条件就绪, 他就通知进程. --IO复用\n\nUNIX可用的五种IO模型\n- 阻塞式I/O\n- 非阻塞式I/O\n- I/O复用\n- 信号驱动式I/O(SIGIO)\n- 异步I/O(POSIX的aio_系列函数)\n\n前四种都是同步IO, 因为他们在真正的IO阶段read,readfrom等导致了阻塞\n只有异步IO模型才是异步IO\n\n**@@低水位标记 ?@@**\n\n\n## select函数\n\n尽管timeval允许指定一个微秒级的分辨率, 但是真实的分辨率吗...... 部分实现的粗糙一些. 并且还有`调度延迟(定时器结束后, 内核还需要花时间调度相应进程运行)`\n\nstruct fd_set 一个集合,可以存储多个文件描述符\n内部是一个32位整数的数组, 数组第一个元素对应0~31描述符 一个二进制位代表一个描述符\n数组第二个元素对应32~63 以此类推\n\n可读条件\n- socket内核接收缓存区中的字节数大于或等于 其低水位标记\n- socket通信的对方关闭连接 读半连接关闭, 对socket的读操作返回0\n- 监听socket上有新的连接请求\n- socket上有未处理的错误, 可以使用getsockopt的SO_ERROR来读取和清除错误 套接字的读操作不阻塞 并返回-1\n\n可写条件\n- socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记, **且套接字已经连接, 或套接字不需要连接UDP**\n- socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号\n- socket使用非阻塞connect 连接成功或失败后\n- socket上有未处理的错误 套接字的写操作不阻塞 并返回-1\n\n异常条件\n- 发送带外数据\n\n当select返回可读事件后 如果不进行处理 则下次select调用会继续返回\n\n## shutdown\n\n1. close会将引用计数-1 等到为0时才关闭套接字. shutdown则可以无视此, 激发TCP的正常连接终止序列\n2. close会终止读和写两个方向的数据传送, 但由于TCP全双工有时需要告知对方我方发送已经完毕","source":"_posts/读书记录150-UNP.md","raw":"---\ntitle: UNP记录\ntags:\n  - null\ncategories:\n  - 读书记录\ndate: 2020-10-06 12:17:39\n---\n\n由于已经在Linux高性能服务器开发中详细说明过绝大部分系统函数\n\nLinux高性能服务器开发的重叠部分, 我会将新的点补充到原博客中, 这里仅作部分简单的说明\n\n# 第一章\n\n通过定义`包裹函数`可以缩短程序. 在muduo框架中就存在包裹函数 将系统函数进行包装\n\n函数中进行错误处理, 这样外部使用`包裹函数`包装好的系统函数的时候可以简化错误处理\n\n\n**daytimecpclient-domain.cpp**\n第一个样例程序稍作修改 可以解析域名  inet_addr没有请求网络 速度快 而gethostbyname会请求域名\n服务器速度可能慢\n```c++\nsockaddr_in server_addr{};\nif ((server_addr.sin_addr.s_addr = inet_addr(argv[1])) == INADDR_NONE)\n{\n    struct hostent* hostptr = gethostbyname(argv[1]);\n    if (!hostptr)\n    {\n        printf(\"invalid input %s\\n\", argv[1]);\n        exit(1);\n    }\n    server_addr.sin_addr.s_addr = *((unsigned long*)hostptr->h_addr);\n}\n```\n\n迭代服务器: 对于每个客户连接都执行迭代一次\n并发服务器: 同时处理多个客户连接\n\n#  第二章 传输层\n\n客户端 主动调用close之后 发送了FIN包\n\n服务端 接收到FIN包后read返回0\n\n服务器 read返回0之后调用close函数 发送FIN包\n\n客户端 接收服务器的FIN包\n\n**@@35 P TCP状态转换图@@**\n\n\n**@@36 P TCP状态转换和Socket函数间的联系@@**\n\n\n多宿主计算机  可能插有多块网卡\n\n通过bind到INADDR_ANY来监听多个接口的同一个端口\n\n\n# 第三章 套接字编程简介\n\n大多数套接字函数 都需要一个指向`套接字地址结构`的指针作为参数. 每个协议簇都定义了他自己的`套接字地址结构`. 这些结构的名字均`以sockaddr_开头`\n\n\n**@@61 P 不同套接字地址结构的比较@@**\n\n\n# 第四章 基本TCP套接字编程\n\n**connect函数**\n\nETIMEDOUT: 客户端没有收到SYN的回应 尝试几次后如果依然没有收到回应则返回错误\n\nECONNREFUSED: 服务器在指定端口上没有进程等待与之连接导致收到了RST回复  之后立即返回错误\n\nconnect失败之后 此套接字无法继续使用 需要close当前套接字后重新调用socket\n\n**bind函数**\n\n如果调用listen或者connect前没有调用bind则操作系统会分配一个临时端口. 对于客户端来说可以接受临时端口, 然而服务器一般都是需要指定端口 供外接连接. \n\n如果指定的端口为0 则认为没有指定端口 会分配临时端口. 如果地址指定为0(INADDR_ANY) 则系统选择IP地址\n\nRPC服务器可以使用临时端口, 但必须将临时端口注册到端口映射器, 这样客户端才能得到对应的临时端口, 之后进行连接\n\n可以使用getsockname获取到系统临时分配的地址和端口\n\n**listen函数**\n\nsocket函数创建的套接字默认被认为是主动套接字(准备调用connect) 使用listen函数将一个`未连接`的套接字转换成一个被动套接字\n\n内核为一个监听的系统套接字维护两个队列\n- 未完成队列 已经收到了SYN但还未完成三次握手\n- 已完成队列 已经进行了三次握手`等待accept从队列中取走` 已建立的连接 如果`此队列为空, accept阻塞`\n\n未完成队列+已完成队列的总长度 即为listen函数的第二个参数backlog\n\nconnect函数调用 -> 服务器收到了SYN包 -> 在未完成队列创建相关内容 -> 创建完毕后返回SYN和ACK -> 客户端返回ACK -> 从未完成队列移动到已完成队列队尾\n\n\nhttps://blog.csdn.net/yangbodong22011/article/details/60399728\n\n\n实际用Centos(内核为4.18版本)测试后, 实际情况为上方博客的情况. 即backlog是已完成队列大小, 而且会存在+1\n\n看到这里后想到之前遇到的一个BUG, 注册入`epollfd`中的`listenfd`没有设置成`ENONBLOCK`, `epoll_wait不会返回, 进而去调用accept`, 然而客户端`connect`函数返回显示已经建立连接.  --也就是connect返回说明连接建立, 发生在accpet函数调用前.\n\n\n当客户端发送FIN后服务器read类函数返回0\n\n**@@91 P exec函数之间的关系@@**\n\n**accept函数**\naccpet函数的第一个参数必须是 被动套接字 即调用过listen, 否则返回EINVAL错误\n\n\n# 第五章\n\n正常启动 正常终止时程序的表现与TCP协议的关系\n\n慢系统调用: 适用于那些可能永远阻塞的系统调用, accpet(没有新连接就一直阻塞), read(读取不到一直阻塞)等等.\n\nEINTR: 当阻塞于某个慢系统调用的进程, 捕获某个信号且相应信号处理函数返回时, 慢系统调用`可能`返回一个EINTR错误\n\n诸如read, write, select等来说可以忽略EINTR, 如下方这个常见的代码片段. **但是connect则不行, 否则立即返回错误??**\n\n```c++\nssize_t result = read(fd, buffer, sizeof buffer);\nif (errno == EINTR)\n{\n  continue;\n}\n\n```\n\n如果同时有N个SIGCHLD信号到达, 信号处理函数极可能执行不够N次.\n- UNIX信号没有排队概念\n- 问题导致的结果不确定, 即不确定调用多少次\n\n```c++\nvoid sigchld_handler(int signo)\n{\n  pid_t pid;\n  int stat;\n  while ((pid = waitpid(-1, &stat, WNOHANG)) > 0)\n  {\n    process\n  }\n  return;\n}\n```\n使用waitpid来获取所有已终止进程状态, 并且指定了`WNOHANG`防止不必要的阻塞.\n\n而wait则不能在这里替换waitpid, 因为wait只能阻塞\n\n\n\n**第五章 正常启动 正常终止 accept返回前终止 服务器进程终止 服务主机崩溃 主机崩溃后重启 主机关机**\n\n\n# 第六章 I/O 复用 select和poll函数\n\n进程需要一种预先告知内核的能力, 使得内核一旦发现进程指定的一个或多个I/O条件就绪, 他就通知进程. --IO复用\n\nUNIX可用的五种IO模型\n- 阻塞式I/O\n- 非阻塞式I/O\n- I/O复用\n- 信号驱动式I/O(SIGIO)\n- 异步I/O(POSIX的aio_系列函数)\n\n前四种都是同步IO, 因为他们在真正的IO阶段read,readfrom等导致了阻塞\n只有异步IO模型才是异步IO\n\n**@@低水位标记 ?@@**\n\n\n## select函数\n\n尽管timeval允许指定一个微秒级的分辨率, 但是真实的分辨率吗...... 部分实现的粗糙一些. 并且还有`调度延迟(定时器结束后, 内核还需要花时间调度相应进程运行)`\n\nstruct fd_set 一个集合,可以存储多个文件描述符\n内部是一个32位整数的数组, 数组第一个元素对应0~31描述符 一个二进制位代表一个描述符\n数组第二个元素对应32~63 以此类推\n\n可读条件\n- socket内核接收缓存区中的字节数大于或等于 其低水位标记\n- socket通信的对方关闭连接 读半连接关闭, 对socket的读操作返回0\n- 监听socket上有新的连接请求\n- socket上有未处理的错误, 可以使用getsockopt的SO_ERROR来读取和清除错误 套接字的读操作不阻塞 并返回-1\n\n可写条件\n- socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记, **且套接字已经连接, 或套接字不需要连接UDP**\n- socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号\n- socket使用非阻塞connect 连接成功或失败后\n- socket上有未处理的错误 套接字的写操作不阻塞 并返回-1\n\n异常条件\n- 发送带外数据\n\n当select返回可读事件后 如果不进行处理 则下次select调用会继续返回\n\n## shutdown\n\n1. close会将引用计数-1 等到为0时才关闭套接字. shutdown则可以无视此, 激发TCP的正常连接终止序列\n2. close会终止读和写两个方向的数据传送, 但由于TCP全双工有时需要告知对方我方发送已经完毕","slug":"读书记录150-UNP","published":1,"updated":"2020-12-05T02:31:35.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg7b0044f8unfpmkgymx","content":"<p>由于已经在Linux高性能服务器开发中详细说明过绝大部分系统函数</p>\n<p>Linux高性能服务器开发的重叠部分, 我会将新的点补充到原博客中, 这里仅作部分简单的说明</p>\n<h1 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h1><p>通过定义<code>包裹函数</code>可以缩短程序. 在muduo框架中就存在包裹函数 将系统函数进行包装</p>\n<p>函数中进行错误处理, 这样外部使用<code>包裹函数</code>包装好的系统函数的时候可以简化错误处理</p>\n<p><strong>daytimecpclient-domain.cpp</strong><br>第一个样例程序稍作修改 可以解析域名  inet_addr没有请求网络 速度快 而gethostbyname会请求域名<br>服务器速度可能慢</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sockaddr_in server_addr&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ((server_addr.sin_addr.s_addr = inet_addr(argv[<span class=\"number\">1</span>])) == INADDR_NONE)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span>* <span class=\"title\">hostptr</span> = <span class=\"title\">gethostbyname</span>(<span class=\"title\">argv</span>[1]);</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hostptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"invalid input %s\\n\"</span>, argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    server_addr.sin_addr.s_addr = *((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>*)hostptr-&gt;h_addr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>迭代服务器: 对于每个客户连接都执行迭代一次<br>并发服务器: 同时处理多个客户连接</p>\n<h1 id=\"第二章-传输层\"><a href=\"#第二章-传输层\" class=\"headerlink\" title=\"第二章 传输层\"></a>第二章 传输层</h1><p>客户端 主动调用close之后 发送了FIN包</p>\n<p>服务端 接收到FIN包后read返回0</p>\n<p>服务器 read返回0之后调用close函数 发送FIN包</p>\n<p>客户端 接收服务器的FIN包</p>\n<p><strong>@@35 P TCP状态转换图@@</strong></p>\n<p><strong>@@36 P TCP状态转换和Socket函数间的联系@@</strong></p>\n<p>多宿主计算机  可能插有多块网卡</p>\n<p>通过bind到INADDR_ANY来监听多个接口的同一个端口</p>\n<h1 id=\"第三章-套接字编程简介\"><a href=\"#第三章-套接字编程简介\" class=\"headerlink\" title=\"第三章 套接字编程简介\"></a>第三章 套接字编程简介</h1><p>大多数套接字函数 都需要一个指向<code>套接字地址结构</code>的指针作为参数. 每个协议簇都定义了他自己的<code>套接字地址结构</code>. 这些结构的名字均<code>以sockaddr_开头</code></p>\n<p><strong>@@61 P 不同套接字地址结构的比较@@</strong></p>\n<h1 id=\"第四章-基本TCP套接字编程\"><a href=\"#第四章-基本TCP套接字编程\" class=\"headerlink\" title=\"第四章 基本TCP套接字编程\"></a>第四章 基本TCP套接字编程</h1><p><strong>connect函数</strong></p>\n<p>ETIMEDOUT: 客户端没有收到SYN的回应 尝试几次后如果依然没有收到回应则返回错误</p>\n<p>ECONNREFUSED: 服务器在指定端口上没有进程等待与之连接导致收到了RST回复  之后立即返回错误</p>\n<p>connect失败之后 此套接字无法继续使用 需要close当前套接字后重新调用socket</p>\n<p><strong>bind函数</strong></p>\n<p>如果调用listen或者connect前没有调用bind则操作系统会分配一个临时端口. 对于客户端来说可以接受临时端口, 然而服务器一般都是需要指定端口 供外接连接. </p>\n<p>如果指定的端口为0 则认为没有指定端口 会分配临时端口. 如果地址指定为0(INADDR_ANY) 则系统选择IP地址</p>\n<p>RPC服务器可以使用临时端口, 但必须将临时端口注册到端口映射器, 这样客户端才能得到对应的临时端口, 之后进行连接</p>\n<p>可以使用getsockname获取到系统临时分配的地址和端口</p>\n<p><strong>listen函数</strong></p>\n<p>socket函数创建的套接字默认被认为是主动套接字(准备调用connect) 使用listen函数将一个<code>未连接</code>的套接字转换成一个被动套接字</p>\n<p>内核为一个监听的系统套接字维护两个队列</p>\n<ul>\n<li>未完成队列 已经收到了SYN但还未完成三次握手</li>\n<li>已完成队列 已经进行了三次握手<code>等待accept从队列中取走</code> 已建立的连接 如果<code>此队列为空, accept阻塞</code></li>\n</ul>\n<p>未完成队列+已完成队列的总长度 即为listen函数的第二个参数backlog</p>\n<p>connect函数调用 -&gt; 服务器收到了SYN包 -&gt; 在未完成队列创建相关内容 -&gt; 创建完毕后返回SYN和ACK -&gt; 客户端返回ACK -&gt; 从未完成队列移动到已完成队列队尾</p>\n<p><a href=\"https://blog.csdn.net/yangbodong22011/article/details/60399728\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yangbodong22011/article/details/60399728</a></p>\n<p>实际用Centos(内核为4.18版本)测试后, 实际情况为上方博客的情况. 即backlog是已完成队列大小, 而且会存在+1</p>\n<p>看到这里后想到之前遇到的一个BUG, 注册入<code>epollfd</code>中的<code>listenfd</code>没有设置成<code>ENONBLOCK</code>, <code>epoll_wait不会返回, 进而去调用accept</code>, 然而客户端<code>connect</code>函数返回显示已经建立连接.  –也就是connect返回说明连接建立, 发生在accpet函数调用前.</p>\n<p>当客户端发送FIN后服务器read类函数返回0</p>\n<p><strong>@@91 P exec函数之间的关系@@</strong></p>\n<p><strong>accept函数</strong><br>accpet函数的第一个参数必须是 被动套接字 即调用过listen, 否则返回EINVAL错误</p>\n<h1 id=\"第五章\"><a href=\"#第五章\" class=\"headerlink\" title=\"第五章\"></a>第五章</h1><p>正常启动 正常终止时程序的表现与TCP协议的关系</p>\n<p>慢系统调用: 适用于那些可能永远阻塞的系统调用, accpet(没有新连接就一直阻塞), read(读取不到一直阻塞)等等.</p>\n<p>EINTR: 当阻塞于某个慢系统调用的进程, 捕获某个信号且相应信号处理函数返回时, 慢系统调用<code>可能</code>返回一个EINTR错误</p>\n<p>诸如read, write, select等来说可以忽略EINTR, 如下方这个常见的代码片段. <strong>但是connect则不行, 否则立即返回错误??</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ssize_t</span> result = <span class=\"built_in\">read</span>(fd, <span class=\"built_in\">buffer</span>, <span class=\"keyword\">sizeof</span> <span class=\"built_in\">buffer</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (errno == EINTR)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果同时有N个SIGCHLD信号到达, 信号处理函数极可能执行不够N次.</p>\n<ul>\n<li>UNIX信号没有排队概念</li>\n<li>问题导致的结果不确定, 即不确定调用多少次</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sigchld_handler</span><span class=\"params\">(<span class=\"keyword\">int</span> signo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">pid_t</span> pid;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> stat;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((pid = waitpid(<span class=\"number\">-1</span>, &amp;stat, WNOHANG)) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">process</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用waitpid来获取所有已终止进程状态, 并且指定了<code>WNOHANG</code>防止不必要的阻塞.</p>\n<p>而wait则不能在这里替换waitpid, 因为wait只能阻塞</p>\n<p><strong>第五章 正常启动 正常终止 accept返回前终止 服务器进程终止 服务主机崩溃 主机崩溃后重启 主机关机</strong></p>\n<h1 id=\"第六章-I-O-复用-select和poll函数\"><a href=\"#第六章-I-O-复用-select和poll函数\" class=\"headerlink\" title=\"第六章 I/O 复用 select和poll函数\"></a>第六章 I/O 复用 select和poll函数</h1><p>进程需要一种预先告知内核的能力, 使得内核一旦发现进程指定的一个或多个I/O条件就绪, 他就通知进程. –IO复用</p>\n<p>UNIX可用的五种IO模型</p>\n<ul>\n<li>阻塞式I/O</li>\n<li>非阻塞式I/O</li>\n<li>I/O复用</li>\n<li>信号驱动式I/O(SIGIO)</li>\n<li>异步I/O(POSIX的aio_系列函数)</li>\n</ul>\n<p>前四种都是同步IO, 因为他们在真正的IO阶段read,readfrom等导致了阻塞<br>只有异步IO模型才是异步IO</p>\n<p><strong>@@低水位标记 ?@@</strong></p>\n<h2 id=\"select函数\"><a href=\"#select函数\" class=\"headerlink\" title=\"select函数\"></a>select函数</h2><p>尽管timeval允许指定一个微秒级的分辨率, 但是真实的分辨率吗…… 部分实现的粗糙一些. 并且还有<code>调度延迟(定时器结束后, 内核还需要花时间调度相应进程运行)</code></p>\n<p>struct fd_set 一个集合,可以存储多个文件描述符<br>内部是一个32位整数的数组, 数组第一个元素对应0<del>31描述符 一个二进制位代表一个描述符<br>数组第二个元素对应32</del>63 以此类推</p>\n<p>可读条件</p>\n<ul>\n<li>socket内核接收缓存区中的字节数大于或等于 其低水位标记</li>\n<li>socket通信的对方关闭连接 读半连接关闭, 对socket的读操作返回0</li>\n<li>监听socket上有新的连接请求</li>\n<li>socket上有未处理的错误, 可以使用getsockopt的SO_ERROR来读取和清除错误 套接字的读操作不阻塞 并返回-1</li>\n</ul>\n<p>可写条件</p>\n<ul>\n<li>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记, <strong>且套接字已经连接, 或套接字不需要连接UDP</strong></li>\n<li>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</li>\n<li>socket使用非阻塞connect 连接成功或失败后</li>\n<li>socket上有未处理的错误 套接字的写操作不阻塞 并返回-1</li>\n</ul>\n<p>异常条件</p>\n<ul>\n<li>发送带外数据</li>\n</ul>\n<p>当select返回可读事件后 如果不进行处理 则下次select调用会继续返回</p>\n<h2 id=\"shutdown\"><a href=\"#shutdown\" class=\"headerlink\" title=\"shutdown\"></a>shutdown</h2><ol>\n<li>close会将引用计数-1 等到为0时才关闭套接字. shutdown则可以无视此, 激发TCP的正常连接终止序列</li>\n<li>close会终止读和写两个方向的数据传送, 但由于TCP全双工有时需要告知对方我方发送已经完毕</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>由于已经在Linux高性能服务器开发中详细说明过绝大部分系统函数</p>\n<p>Linux高性能服务器开发的重叠部分, 我会将新的点补充到原博客中, 这里仅作部分简单的说明</p>\n<h1 id=\"第一章\"><a href=\"#第一章\" class=\"headerlink\" title=\"第一章\"></a>第一章</h1><p>通过定义<code>包裹函数</code>可以缩短程序. 在muduo框架中就存在包裹函数 将系统函数进行包装</p>\n<p>函数中进行错误处理, 这样外部使用<code>包裹函数</code>包装好的系统函数的时候可以简化错误处理</p>\n<p><strong>daytimecpclient-domain.cpp</strong><br>第一个样例程序稍作修改 可以解析域名  inet_addr没有请求网络 速度快 而gethostbyname会请求域名<br>服务器速度可能慢</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sockaddr_in server_addr&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ((server_addr.sin_addr.s_addr = inet_addr(argv[<span class=\"number\">1</span>])) == INADDR_NONE)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span>* <span class=\"title\">hostptr</span> = <span class=\"title\">gethostbyname</span>(<span class=\"title\">argv</span>[1]);</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hostptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"invalid input %s\\n\"</span>, argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    server_addr.sin_addr.s_addr = *((<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span>*)hostptr-&gt;h_addr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>迭代服务器: 对于每个客户连接都执行迭代一次<br>并发服务器: 同时处理多个客户连接</p>\n<h1 id=\"第二章-传输层\"><a href=\"#第二章-传输层\" class=\"headerlink\" title=\"第二章 传输层\"></a>第二章 传输层</h1><p>客户端 主动调用close之后 发送了FIN包</p>\n<p>服务端 接收到FIN包后read返回0</p>\n<p>服务器 read返回0之后调用close函数 发送FIN包</p>\n<p>客户端 接收服务器的FIN包</p>\n<p><strong>@@35 P TCP状态转换图@@</strong></p>\n<p><strong>@@36 P TCP状态转换和Socket函数间的联系@@</strong></p>\n<p>多宿主计算机  可能插有多块网卡</p>\n<p>通过bind到INADDR_ANY来监听多个接口的同一个端口</p>\n<h1 id=\"第三章-套接字编程简介\"><a href=\"#第三章-套接字编程简介\" class=\"headerlink\" title=\"第三章 套接字编程简介\"></a>第三章 套接字编程简介</h1><p>大多数套接字函数 都需要一个指向<code>套接字地址结构</code>的指针作为参数. 每个协议簇都定义了他自己的<code>套接字地址结构</code>. 这些结构的名字均<code>以sockaddr_开头</code></p>\n<p><strong>@@61 P 不同套接字地址结构的比较@@</strong></p>\n<h1 id=\"第四章-基本TCP套接字编程\"><a href=\"#第四章-基本TCP套接字编程\" class=\"headerlink\" title=\"第四章 基本TCP套接字编程\"></a>第四章 基本TCP套接字编程</h1><p><strong>connect函数</strong></p>\n<p>ETIMEDOUT: 客户端没有收到SYN的回应 尝试几次后如果依然没有收到回应则返回错误</p>\n<p>ECONNREFUSED: 服务器在指定端口上没有进程等待与之连接导致收到了RST回复  之后立即返回错误</p>\n<p>connect失败之后 此套接字无法继续使用 需要close当前套接字后重新调用socket</p>\n<p><strong>bind函数</strong></p>\n<p>如果调用listen或者connect前没有调用bind则操作系统会分配一个临时端口. 对于客户端来说可以接受临时端口, 然而服务器一般都是需要指定端口 供外接连接. </p>\n<p>如果指定的端口为0 则认为没有指定端口 会分配临时端口. 如果地址指定为0(INADDR_ANY) 则系统选择IP地址</p>\n<p>RPC服务器可以使用临时端口, 但必须将临时端口注册到端口映射器, 这样客户端才能得到对应的临时端口, 之后进行连接</p>\n<p>可以使用getsockname获取到系统临时分配的地址和端口</p>\n<p><strong>listen函数</strong></p>\n<p>socket函数创建的套接字默认被认为是主动套接字(准备调用connect) 使用listen函数将一个<code>未连接</code>的套接字转换成一个被动套接字</p>\n<p>内核为一个监听的系统套接字维护两个队列</p>\n<ul>\n<li>未完成队列 已经收到了SYN但还未完成三次握手</li>\n<li>已完成队列 已经进行了三次握手<code>等待accept从队列中取走</code> 已建立的连接 如果<code>此队列为空, accept阻塞</code></li>\n</ul>\n<p>未完成队列+已完成队列的总长度 即为listen函数的第二个参数backlog</p>\n<p>connect函数调用 -&gt; 服务器收到了SYN包 -&gt; 在未完成队列创建相关内容 -&gt; 创建完毕后返回SYN和ACK -&gt; 客户端返回ACK -&gt; 从未完成队列移动到已完成队列队尾</p>\n<p><a href=\"https://blog.csdn.net/yangbodong22011/article/details/60399728\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yangbodong22011/article/details/60399728</a></p>\n<p>实际用Centos(内核为4.18版本)测试后, 实际情况为上方博客的情况. 即backlog是已完成队列大小, 而且会存在+1</p>\n<p>看到这里后想到之前遇到的一个BUG, 注册入<code>epollfd</code>中的<code>listenfd</code>没有设置成<code>ENONBLOCK</code>, <code>epoll_wait不会返回, 进而去调用accept</code>, 然而客户端<code>connect</code>函数返回显示已经建立连接.  –也就是connect返回说明连接建立, 发生在accpet函数调用前.</p>\n<p>当客户端发送FIN后服务器read类函数返回0</p>\n<p><strong>@@91 P exec函数之间的关系@@</strong></p>\n<p><strong>accept函数</strong><br>accpet函数的第一个参数必须是 被动套接字 即调用过listen, 否则返回EINVAL错误</p>\n<h1 id=\"第五章\"><a href=\"#第五章\" class=\"headerlink\" title=\"第五章\"></a>第五章</h1><p>正常启动 正常终止时程序的表现与TCP协议的关系</p>\n<p>慢系统调用: 适用于那些可能永远阻塞的系统调用, accpet(没有新连接就一直阻塞), read(读取不到一直阻塞)等等.</p>\n<p>EINTR: 当阻塞于某个慢系统调用的进程, 捕获某个信号且相应信号处理函数返回时, 慢系统调用<code>可能</code>返回一个EINTR错误</p>\n<p>诸如read, write, select等来说可以忽略EINTR, 如下方这个常见的代码片段. <strong>但是connect则不行, 否则立即返回错误??</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ssize_t</span> result = <span class=\"built_in\">read</span>(fd, <span class=\"built_in\">buffer</span>, <span class=\"keyword\">sizeof</span> <span class=\"built_in\">buffer</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (errno == EINTR)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果同时有N个SIGCHLD信号到达, 信号处理函数极可能执行不够N次.</p>\n<ul>\n<li>UNIX信号没有排队概念</li>\n<li>问题导致的结果不确定, 即不确定调用多少次</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sigchld_handler</span><span class=\"params\">(<span class=\"keyword\">int</span> signo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">pid_t</span> pid;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> stat;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ((pid = waitpid(<span class=\"number\">-1</span>, &amp;stat, WNOHANG)) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">process</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用waitpid来获取所有已终止进程状态, 并且指定了<code>WNOHANG</code>防止不必要的阻塞.</p>\n<p>而wait则不能在这里替换waitpid, 因为wait只能阻塞</p>\n<p><strong>第五章 正常启动 正常终止 accept返回前终止 服务器进程终止 服务主机崩溃 主机崩溃后重启 主机关机</strong></p>\n<h1 id=\"第六章-I-O-复用-select和poll函数\"><a href=\"#第六章-I-O-复用-select和poll函数\" class=\"headerlink\" title=\"第六章 I/O 复用 select和poll函数\"></a>第六章 I/O 复用 select和poll函数</h1><p>进程需要一种预先告知内核的能力, 使得内核一旦发现进程指定的一个或多个I/O条件就绪, 他就通知进程. –IO复用</p>\n<p>UNIX可用的五种IO模型</p>\n<ul>\n<li>阻塞式I/O</li>\n<li>非阻塞式I/O</li>\n<li>I/O复用</li>\n<li>信号驱动式I/O(SIGIO)</li>\n<li>异步I/O(POSIX的aio_系列函数)</li>\n</ul>\n<p>前四种都是同步IO, 因为他们在真正的IO阶段read,readfrom等导致了阻塞<br>只有异步IO模型才是异步IO</p>\n<p><strong>@@低水位标记 ?@@</strong></p>\n<h2 id=\"select函数\"><a href=\"#select函数\" class=\"headerlink\" title=\"select函数\"></a>select函数</h2><p>尽管timeval允许指定一个微秒级的分辨率, 但是真实的分辨率吗…… 部分实现的粗糙一些. 并且还有<code>调度延迟(定时器结束后, 内核还需要花时间调度相应进程运行)</code></p>\n<p>struct fd_set 一个集合,可以存储多个文件描述符<br>内部是一个32位整数的数组, 数组第一个元素对应0<del>31描述符 一个二进制位代表一个描述符<br>数组第二个元素对应32</del>63 以此类推</p>\n<p>可读条件</p>\n<ul>\n<li>socket内核接收缓存区中的字节数大于或等于 其低水位标记</li>\n<li>socket通信的对方关闭连接 读半连接关闭, 对socket的读操作返回0</li>\n<li>监听socket上有新的连接请求</li>\n<li>socket上有未处理的错误, 可以使用getsockopt的SO_ERROR来读取和清除错误 套接字的读操作不阻塞 并返回-1</li>\n</ul>\n<p>可写条件</p>\n<ul>\n<li>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记, <strong>且套接字已经连接, 或套接字不需要连接UDP</strong></li>\n<li>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</li>\n<li>socket使用非阻塞connect 连接成功或失败后</li>\n<li>socket上有未处理的错误 套接字的写操作不阻塞 并返回-1</li>\n</ul>\n<p>异常条件</p>\n<ul>\n<li>发送带外数据</li>\n</ul>\n<p>当select返回可读事件后 如果不进行处理 则下次select调用会继续返回</p>\n<h2 id=\"shutdown\"><a href=\"#shutdown\" class=\"headerlink\" title=\"shutdown\"></a>shutdown</h2><ol>\n<li>close会将引用计数-1 等到为0时才关闭套接字. shutdown则可以无视此, 激发TCP的正常连接终止序列</li>\n<li>close会终止读和写两个方向的数据传送, 但由于TCP全双工有时需要告知对方我方发送已经完毕</li>\n</ol>\n"},{"title":"C++Primer学习","date":"2019-08-16T11:13:22.000Z","top":80,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/C%2B%2BPrimer.png","_content":"\n# TOOD\nexplicit 参见7.5.4节 265\n\n运算符优先级...........\n\n# 杂项\n\n**char 在默认情况下, 既不是有符号. 也不是无符号.**\n```c++\nchar a; // 此时a可能是 signed char 也可能是 unsigned char 可能会在不同系统之前产生错误\n// 可以显式声明, 来确保不会出现此错误\nsigned char a;\nunsigned char a; \n```\n\n**输入**\n```c++\nchar name[10];\ncin.getline(name, 10); // 可以读取换行符, 但不保存\ncin.get(name, 10); // 不读取换行符, 可能导致get到换行符\n\n// 空行和超出长度问题 将在后面说明\n```\n运算符优先级\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=59a3e1017d3e6709aa0d4dad5aaef458/63d9f2d3572c11df57c9a205612762d0f703c2f8.jpg)\n\n**基础的数组**\n```c++\nint a[] = {1, 2, 3, 4};\n// 下方由于 new 只是返回一个地址所以用 int* 接收 \nint* b = new int[4];\ncout << a[0] << endl; // 1\ncout << *(a + 1) << endl;// 2\n```\n**对指针解引用**\n第一印象是 解除引用, 然而并不是\n```c++\n/*\n\"*\"的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。也就是说，解引用是返回内存地址中保存的值。\n比如int a=10; int *p=&a;\ncout<<*p<<endl; 输出a的值，就是解引用操作。\n*/\n```\n\n\n**常用 宏**\n| 定义 | 说明 |\n| ----- | ----- |\n| `__FILE__` | 存放文件名的字符串字面值 |\n| `__LINE__` | 存放当前行号的整形字面值 |\n| `__TIME__` | 存放文件编译时间的字符串字面量 |\n| `__DATE__` | 存放文件编译日期的字符串字面值 |\n| `__VA_ARGS__` | 用来接受函数参数中`...`, 类似printf函数, 这个宏只能在宏中使用 |\n\n\n# 第一部分 基础知识\n\n## 第二章 变量和基本类型\n### 习题\n\n**2.2 与钱相关的数据存储 使用的类型**\n银行相关钱相关的数据 保存 使用整形, 不太可能使用浮点数. 浮点数运算可能会出现误差\n使用`1`代表`1RMB` 或者使用`1`代表`0.01RMB`\n\n**2.9 解释下列定义 对于非法说出错在哪里**\n```c++\nstd::cin >> int input_value; // error: expected primary-expression before ‘int’\n\nint i1 = {3.14};// narrowing conversion of ‘3.1400000000000001e+0’ from ‘double’ to ‘int’ inside { } [-Wnarrowing]\n\ndouble salary = wage = 9999.99;// error: ‘wage’ was not declared in this scope 如果定义wage则语句不报错\n\nint i2 = 3.14;\n```\n\n**2.10 下列变量的初始值是什么**\n\n内置类型变量未被显示初始化  函数体之外初始化为0  函数体内是未被定义的\n类\t一般都拥有默认的初始化方式\n```c++\nstd::string g_str; // 全局变量 且拥有默认初始化方式 为空字符串\nint g_int; // \t全局变量 初值为0\nint main()\n{\n\tint local_int; // 局部变量 未定义\n\tstd::string local_str; // 拥有默认初始化方式 空字符串\n}\n```\n\n**2.14 下面代码输出什么**\n起初一看 以为会是循环到溢出 直接就把代码码了下来运行 发现是正常的.\n就算for中 `int i = 0`改为`i = 0`依然不会溢出\nfor的i覆盖了外面的i\n```c++\n#include <iostream>\n\nint main()\n{\n    int i = 100, sum = 0;\n    for (int i = 0; i != 10; ++i)\n    {\n        sum += i;\n    }\n\n    std::cout << i << \" \" << sum << std::endl; //$ 100 45\n\n    return 0;\n}\n```\n\n输出~~~\n```c++\n#include <iostream>\n\nint main()\n{\n    int i, &ri = i;\n    i = 5;\n    ri = 10;\n\n    std::cout << i << \" \" << ri <<std::endl; //$ 10 10\n    return 0;\n}\n```\n\n\n### tips\n一个形如42的值被称为`字面值常量(literal)`, 这样的值你一看到(面), 就知道是多少\n\nscope 作用域\n\n### 无符号\n**unsigned int和int运算的时候 自动转换为unsigned**\n```c++\nunsigned int a = 10;\nint b = -11;\n\nstd::cout << a + b << std::endl; //$ 4294967295\n```\n\n**警惕for循环中的 无符号类型**\nsize_t\n\n\n### 声明定义初始化赋值\n**声明**\n声明不是定义, 可以多次声明\n指明变量的type和name.\n对于变量的声明需要使用`extern`关键字, 如果使用了`extern`关键字的同时初始化就成了定义\n```c++\nint i; // 声明并定义 未初始化\nextern int a; // 声明\nextern int a = 10; // 定义 声明 初始化\n```\n\n**定义**\n声明并定义, 只能定义一次\n定义的时候需要指定type和name. 申请空间, 可能进行初始化.\n\n\n**初始化 赋值**\n初始化 不是赋值\n初始化是创建变量时 赋予其一个初始值\n赋值是擦除当前的值 赋予新的值\n\n\n**变量类型选择**\n数值范围超过`int` 建议使用`long long`, `long`的长度仅是大于等于`int`\nchar类型可能是 `signed` 还可能是`unsigned` 如果针对范围有特殊要求 应该注明是否有无符号\n浮点运算建议使用double float经常精度不够, 然而两者运算效率却相差无几. `long double`反而绝大多数情况用不到\n\n### const\nconst变量必须被初始化\n\n所谓指向常量的引用或指针, 不过是指针或引用自以为是罢了, 他们觉得自己指向了常量, 所以自觉不去修改\n\n顶层const: 表示指针本身是常量\n底层const: 表示指针指向是一个常量\n指针本身是一个对象, 他可以指向另一个对象. 因此, 指针本身是不是常量, 以及指针所向是不是一个常量就是两个独立的问题.\n\n\n执行拷贝的时候, 常量是顶层const还是底层const区别明显, 顶层const可以视为不见\n然而底层const的限制不能忽视, 拷入和拷出对象必须具有相同的底层const资格\n\n**指针常量和类型别名**\n```c++\ntypedef char* pstring;\nconst pstring cstr = 0;\n```\n这里pstring是指向char的指针 const pstring是指向char的常量指针 指针指向不能变\n而不是简单地将pstring替换掉\n\n\n### constexpr\n在一个复杂系统中, 很难分辨一个初始值到底是不是常量表达式.\n当然可以定义一个const变量 并把初始值设定为我们认为的常量表达式, 然而实际依然有非常量表达式的情况\n\nC++11标准 将变量声明为constexpr由编译器来验证变量是否是一个常量表达式\n\n```c++\nconstexpr int mm = 20; // 20是常量表达式\nconstexpr int yy = mm + 1; // mf + 1是常量表达式\nconstexpr int sz = size(); // 当size是一个constexpr函数时才是正确的声明语句\n```\n\n指针和引用都能定义成constexpr, 但初始值受到严格限制.\nconstexpr指针的初始值必须是nullptr或者0 或者存储于某个固定地址中的对象(位于所有函数体之外)\nconstexpr引用能绑定到 某个固定地址中的对象\n\n**decltype和引用**\n`decltype((i)) d` 双层括号是引用\n`decltype(i) d`单层括号只有i是引用的时候 d才是引用\n\n## 第三章 字符串 向量和数组\n### 习题\n\n**3.34**\np1和p2指向同一数组中的元素, 则下面程序的功能是什么? 什么情况下程序是非法的?\np1 += p2 - p1;\n将p1移动到p2的位置  不会非法..........\n\n\n### {} = ()\n```c++\nstring a = \"cccc\";  // 只有一个参数值\nstring b(10, 'c'); // 拥有两个参数值 10和'c'\n```\n\n使用=, 进行拷贝初始化 只能提供一个初始值\n使用(), 进行直接初始化, 可以提供多个初始值进行初始化\n\n```c++\nclass A\n{\n  int a1 = 10;\n  int a2(10);\n  // temp.cpp:4:12: error: expected identifier before numeric constant\n  // int a2(10);\n  // temp.cpp:4:12: error: expected ‘,’ or ‘...’ before numeric constant\n  int a3{10};\n}\n```\n类内初始值 不能使用小括号\n\n\n列表初始化只能放在花括号中 \n\n### vector\nvector中不能保存引用, 因为使用引用就必须初始化.\n\n设想, 你设置了vector包含十个元素, 这十个空间就必须被初始化, \n然而引用必须要绑定到具体的对象上, 此时却没有对象进行绑定\n\n再者如果容器复制的时候 引用怎么复制?\n\n```c++\nvector<int> v1(10); // 10个元素, 全为0\nvector<int> v2{10}; // 一个元素, 为10\n\nvector<int> v3(10, 1); // 10个元素, 全为1\nvector<int> v4{10, 1}; // 两个元素, 10和1\n\n// -----------------------------------------\n\nvector<string> v5{\"hi\"}; // 列表初始化 有一个元素\nvector<string> v6(\"hi\"); // 错误不能使用字符串字面值构建vector元素\n\nvector<string> v7{10}; // 10个默认初始化的对象\nvector<string> v8{10, \"hi\"}; // 十个值为\"hi\"的元素\n```\n\n因为不能使用int来初始化string对象, 列表初始化要求列表值类型与尖括号种类型相同\nv7和v8并不是列表初始化, 而是转去尝试用默认值(默认值????)初始化\n\n这里感觉有点?去看了下英文原版\nthe compiler looks for\nother ways to initialize the object from the given values.\n\n\n\n**迭代器**\n使用的时候注意迭代器失效, \n\n### 数组和指针\n```c++\nint (*array_ptr)[10] = &arr; // 指向十个整数的数组\nint (&array_ref)[10] = arr; // 十个整数数组的引用\n```\n\n```c++\nint a[] = {0, 1, 2, 3, 4, 5, 6, 7};\n\nauto a1(a); // a1是指针类型\ndecltype(a) a2; //a2是有八个元素的数组\n\nint* b = std::begin(a); // 指向首元素\nint* c = std::end(a); // 指向最后一个元素的后一位\n\nptrdiff_t d = c - b; // ptrdiff_t 定义在cstddef中\n\nint* p = &a[2];\nint k = p[-1];// 内置下标运算符所用的索引值不是无符号型 可以为负\n```\n\n## 第四章 表达式\n当一个对象被用作右值的时候, 使用的是对象的值(内容)\n当一个对象被用做左值的时候, 使用的是对象的身份(在内存中的位置)\n\n如果表达式的求值结果是左值, decltype作用于该表达式得到一个引用类型.\n\n`int* p`\n解引用运算符生成左值 `decltype(*p)`得到的是`int&`\n取地址运算符生成右值 `decltype(&p)`的结果是`int**`\n\n\n大多数运算符没有规定按照什么顺序求值\n`int i = f1() * f2()`\n这两函数的调用顺序是未定义的\n\n只有四种运算符规定了运算对象的求值顺序\n短路求值\n`&&` 从左到右\n`||` 从左到右\n\n`?:`\n`,` 逗号运算符 从左到右 首先求值左侧然后丢掉结果 真正返回的是右侧结果\n\n\n书写表达式的建议\n1. 拿不准的时候最好使用括号来组合表达式. 括号不香吗?\n2. 如果改变了某个运算对象的值, 在表达使得其他地方就不要再使用这个运算对象\n\n`(-m) / n` 和 `m / (-n)` 等于 `-(m / n)`\n`m % (-n)` 等于 `m % n`\n`(-m) % n` 等于 `-(m % n)`\n\n\n```c++\nint ival, jval\nival = jval = 0;\n```\n赋值运算符右结合, 所以右侧的`jval = 0`是左侧赋值运算符的右侧运算对象\n又因为赋值运算符返回的是其左侧运算对象, 所以右侧赋值运算符的结果(Jval)赋给了ival\n\n\n赋值运算符的优先级低于关系运算符, 所以条件语句中, 赋值部分应该加上括号\n\n\n`sizeof *p`\nsizeof 不会实际求运算对象的值, 所以即使p是无效指针也不会有什么影响\nsizeof对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小\nsizeof对string对象和vector对象 只返回该类型固定部分的大小, 不会计算对象中元素占用了多少空间\nsizeof(string) 与string长度无关, 不同的编译器有不同的具体实现\nhttp://www.cplusplus.com/forum/general/218642/\n\nsizeof(vector<int>) 返回24字节 64位系统指针8字节 三个指针24字节 (头指针, 尾指针, 当前容量尾指针)\npointer _M_start;\npointer _M_finish;\npointer _M_end_of_storage;\n\n非内置类型基本都含有指针, 指向堆中分配的内存, 所以存在存储任意大小都会返回固定sizeof\n\n\n`const-name<type>(expr)`\n命名显式强制类型转换\n\nstatic_cast 静态类型转换 用于替代隐式类型转换\n- 子类向父类转换 安全\n- 父类向子类转换 无动态类型检查 不安全\n- 基本数据类型转换\n- 指针类型转换\n- 将任何其他类型转换为void类型\n\n任何具有明确定义的类型转换, 只要底层不包含const, 都能使用. 值类型转换以及指针类型转换\n如果类型不兼容, 则编译阶段报错.\n\ndynamic_cast\n运行时转换, 如果转换失败返回null. type和expr必须同是类指针或者类引用\n用于父类向子类的转换\n\nconst_cast\n增加或删除运算对象的底层const, 如果对象本身不是一个常量 获取写权限是合法的, 如果是常量则会产生未定义后果.\n\n\nreinterpret_cast\n为运算对象的位模式提供较低层次上的重新解析\nhttps://zhuanlan.zhihu.com/p/33040213\n\n\n## 第五章 语句\n\n\n即使不准备在default标签下做任何工作, 定义一个default标签也是有作用的. 可以告知读者, \n我们已经考虑到了默认情况, 只是目前什么也没做\n\n\n**switch-case关于变量定义的问题**\n```c++\n#include <string>\n#include <iostream>\nint main()\n{\n    switch (true)\n    {\n        case true:\n            std::string v1;\n            std::string v2 {};\n            int v3 = 0;\n            int v4;\n            break;\n\n        case false:\n            std::cout << v1 << std::endl;\n            std::cout << v2 << std::endl;\n            std::cout << v3 << std::endl;\n            std::cout << v4 << std::endl;\n            break;\n    }\n\n    return 0;\n}\n\n// 编译报错 注意没有   v4  控制流绕过了初始化变量的语句\n\nswitch-case.cpp: In function ‘int main()’:\nswitch-case.cpp:16:14: error: jump to case label [-fpermissive]\n         case false:\n              ^~~~~\nswitch-case.cpp:12:17: note:   crosses initialization of ‘int v3’\n             int v3 = 0;\n                 ^~\nswitch-case.cpp:11:25: note:   crosses initialization of ‘std::__cxx11::string v2’\n             std::string v2 {};\n                         ^~\nswitch-case.cpp:10:25: note:   crosses initialization of ‘std::__cxx11::string v1’\n             std::string v1;\n\n// 两个case语句加上括号后报错变为\nswitch-case.cpp: In function ‘int main()’:\nswitch-case.cpp:18:26: error: ‘v1’ was not declared in this scope\n             std::cout << v1 << std::endl;\n                          ^~\nswitch-case.cpp:19:26: error: ‘v2’ was not declared in this scope\n             std::cout << v2 << std::endl;\n                          ^~\nswitch-case.cpp:20:26: error: ‘v3’ was not declared in this scope\n             std::cout << v3 << std::endl;\n                          ^~\nswitch-case.cpp:21:26: error: ‘v4’ was not declared in this scope\n             std::cout << v4 << std::endl;\n```\n\n\n定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程\n\n\n牢记for语句头中定义的对象只在for循环体内可见.~~~~~~~~~~~\n\n\n**break continue**\n\nbreak负责终止离他最近的while, do while, for或者switch. 并从这些语句后的第一条开始继续执行\n\ncontinue语句终止最近的循环中当前迭代, 并立即开始下一次迭代\n\n**异常处理**\n代码可以使用throw来抛出异常\n大部分可以指定msg来初始化异常\nthrow exception_type(\"msg\")\n表中exception不能指定msg, 来初始化, 除此外表中其他都需要msg初始\n\n位于`stdexcept`头文件中\n\n| 错误名称        | 对应原因                       |\n| ---------------- | ---------------------------------- |\n| exception        | 最常见的问题 |\n| runtime_error    | 只有运行的时候才能查到错误         |\n| range_error      | 运行时错误: 超范围                 |\n| overflow_error   | 运行时错误: 上溢                   |\n| underflow_error  | 运行时错误: 下溢                   |\n| logic_error      | 程序逻辑错误                       |\n| domain_error     | 程序逻辑错误: 参数对应的结果不存在 |\n| invalid_argument | 程序逻辑错误: 无效参数             |\n| length_error     | 程序逻辑错误: 试图创建一个超出该类型最大长度的对象  如vector::reserve  |\n| out_of_range     | 程序逻辑错误: 超范围               |\n\n\n## 第六章 函数\n\n形参名是可选的, 但是由于无法使用未命名的形参, 所以一般都有一个名字.\n\n\n自动对象: 只存在于块执行期间的对象\n局部静态对象: 只在`第一次`经过对象语句时进行初始化, 直到程序终止才被销毁.\n\n\n数组引用形参\n```c++\nvoid print(int (&arr)[10])\n{\n    for (auto elem : arr)\n    {\n        cout << elem << endl;\n    }\n}\n```\n\n函数返回引用得到左值\n返回其他类型得到右值\n\np205页 还真没见过 返回数组指针这种形式\n\n\n## 第七章 类\n### 习题\n\n**7.25 Screen能安全的依赖于拷贝和赋值操作的默认版本吗**\nScreen中只有内置类型和string, 如果其含有动态管理的内存则不行\n当类需要分配类对象以外的资源时, 默认版本经常会失效\n\n\n默认构造函数, 会造成 内置类型和复合类型成员 默认初始化后 值未定义\n\n关于未定义这点我去写了小段程序看了下, 也搜了一下\n\nhttps://stackoverflow.com/a/2218275/11581349\n\nIt will be automatically initialized if\n- it's a class/struct instance in which the default constructor initializes all primitive types; like MyClass instance; 有默认构造函数类或者结构体, 并且默认构造函数初始化所有内置类型\n- you use array initializer syntax, e.g. int a[10] = {} (all zeroed) or int a[10] = {1,2}; (all zeroed except the first two items: a[0] == 1 and a[1] == 2) 使用了大括号初始化\n- same applies to non-aggregate classes/structs, e.g. MyClass instance = {}; (more information on this can be found here) 同大括号初始化\n- it's a global/extern variable 全局或者extern类型\n- the variable is defined static (no matter if inside a function or in global/namespace scope) 变量被声明为static\n\n\n默认初始化发生的情况\n\n- 不使用任何初始值定义一个非静态变量或者数组\n- 一个类本身含有类类型的成员且使用合成的默认构造函数\n- 类类型的成员没有在构造函数初始值列表中显示地初始化时\n\n值初始化\n\n- 数组初始化提供的初始值数量小于数组大小\n- 不使用初始值定义一个局部静态变量\n- 书写T()表达式 显示地请求值初始化\n\nmutable可变数据成员, 从远不会是const.  可以在const成员函数中对其进行修改\n\n类的GetBalance函数的函数体在整个Account类可见之后才被处理.\n\n编译器看到GetBalance的声明后 开始从类内(**类内会从使用Money前查找**)到类外寻找Money声明, 然后函数的返回值和bal成员变量的类型为double, 接着类可见之后处理函数体 函数会返回double类型的成员变量bal\n```c++\ntypedef double Money;\nstd::string balance = \"string\";\nclass Account\n{\npublic:\n    // typedef std::string Money; 这里则不会报错\n    Account() = default;\n    ~Account() = default;\n    Money GetBalance() const\n    { return balance;  }\nprivate:\n    // typedef std::string Money; 会报错 因为由于GetBalance函数已经使用了外部的Money\n    Money balance;\n};\nint main()\n{\n    Account account;\n    std::cout << account.GetBalance(); // $ 0\n    return 0;\n}\n```\n\n```c++\nclass Foo\n{\npublic:\n    Foo(int val):\n        bar1(val),\n        bar2(bar1){}\n\nprivate:\n    int bar1; // 更改两个顺序  将会导致先使用 bar1初始化bar2 然后使用val初始化bar1\n    int bar2;\n}\n```\n在我看了一些项目后使用的上面的写法, 然而这种写法却不合适 除非你严格按照变量顺序写.\n\n如果你将bar2和bar1的顺序不小心更换了, 难以排查的bug\n\n**使用默认构造函数声明对象 需要去掉对象名后的空括号对**\n```c++\nFoo foo(); // 错误\nFoo foo;\n```\n\n### 隐式的类类型转换\n\n如果构造函数只接受一个实参, 则它实际上定义了转换为此类类型的隐式转换机制 -- 称这种构造函数为**转换构造函数**\n\nFoo含有一个只有string类型的构造函数. 当一个函数的参数是Foo类型时. 你可以将string类型直接传递给这个函数. 会自动从string类型构造成Foo类型\n\n```c++\n// Value(string val); 可以加上explicit防止隐式类型转换\n// void Add(Value val);\n\nstring val1 = \"val1\";\nfoo.Add(val1); // 正确 隐式转换成Value\nfoo.Add(\"val2\"); // 错误 只能进行一步转换  需要从\"val2\"到string再到Value\n```\n\n\n### 聚合类 字面值常量类\n\n聚合类\n- 所有成员都是public\n- 没有定义任何构造函数\n- 没有类内初始值\n- 没有基类也没有virtual函数\n\n```c++\nclass Foo\n{\npublic:\n\tstd::string str;\n\tint val;\n};\nint main()\n{\n\tFoo foo = {\"1\", 1};\n}\n```\n\n字面值常量类\n- 数据成员都是字面值类型的聚合类\n\n如果一个类不是聚合类, 但是符合以下要求也是字面值类型常量类\n- 数据成员必须是字面值类型\n- 类必须含有一个constexpr构造函数\n- 如果一个数据成员含有类内初始值, 则初始值必须是一条常量表达式. 如果成员属于某种类类型, 则初始值必须使用成员自己的constexpr构造函数\n- 类必须使用默认析构函数\n\n# 第二部分 cpp标准库\n\n## 第八章 IO库\n\n想到了遇到过的`while(std::cin >> xx)`究竟是如何判断的呢? `>>`返回的对象是`std::cin`如何将其转换为`bool`?\n\n重载运算符\n```c++\nexplicit __CLR_OR_THIS_CALL operator bool() const {\n        return !fail();\n    }\n_NODISCARD bool __CLR_OR_THIS_CALL operator!() const {\n    return fail();\n}\n\nclass Foo\n{\npublic:\n\texplicit operator bool()\n\t{\n\t\tstd::cout << \"operator *\" << std::endl;\n\t\treturn true;\n\t}\n\tbool operator!()\n\t{\n\t\tstd::cout << \"operator !\" << std::endl;\n\t\treturn true;\n\t}\n};\nint main()\n{\n\tFoo foo;\n\tif (foo); // $ operator *\n\tif (!foo);// $ operator !\n}\n```\n\n\nendl  换行 刷新缓冲区\nflush 刷新缓冲区\nends  空字符 刷新缓冲区\n\n\nunitbuf 所有输出操作后都会立即刷新缓冲区\nnounitbuf 恢复正常的缓冲方式\n\n## 第九章 顺序容器\n\n### 习题\n\n\n**9.6 下面的程序有何错误 你应该如何修改它?**\n```c++\nlist<int> lst1;\nlist<int>::iterator iter1 = lst1.begin(),\niter2 = lst1.end();\nwhile (iter1 < iter2)\n```\n将`while (iter1 < iter2)` 改成`while(iter1 != iter2)`\n迭代器是指向元素的指针, 对于list来说比较元素指针大小无法判断\n@@@@\n\n\n**9.12 对于接受一个容器创建其拷贝的构造函数 和 接收两个迭代器创建拷贝的构造函数之间的不同**\n\n**创建拷贝**-要求容器类型和元素类型都相同\n**接收两个迭代器**-元素类型能够相互转化即可\n\n### 函数说明\n\nassign函数 仅顺序容器\n- 用指定元素的拷贝 替换左侧容器中的所有元素\n\nswap函数\n- 只会真正交换array的元素 与长度有关\n- 其他容器会交换内部的数据结构 常数时间完成\n\n除了string指向容器的迭代器 引用和指针在swap操作之后都不会失效 仍指向swap操作前的元素,\n但是这些元素已经属于不同的容器了\n\n关系运算符\n- 两个容器具有相同的大小 且所有元素两两对应相等 这两个容器相等 否则不等\n- 如果两个容器大小不同, 但较小的容器中每个元素都等于较大容器中对应元素 则较小容器 > 较大容器\n- 比较结果取决于第一个不相等的元素的比较结果 类似 compare\n\n\n容器的运算符 非迭代器\n== != 运算符 所有容器都支持\n< <= > >= 运算符 无序关联容器不支持\n\n\nsize_type 无符号整数 足够保存此种容器类型最大可能容器的大小\ndifference_type 带符号整数类型 足够保存两个迭代器之间的距离\nvalue_type 元素类型\n\n除了array之外其他容器的默认构造函数会创建一个指定类型的`空容器`\n\n只有`顺序容器`的`构造函数`才接`受大小参数` 关联容器并不支持\n\n如果元素类型是内置类型或者具有默认的构造函数的类类型,可以只为构造函数提供一个容器大小的参数\n如果元素类型没有默认构造函数 除了容器大小参数 还必须指定一个显示的元素初始值\n\n只有支持随机访问容器的迭代器才支持`operator<`, list只能使用`=`来判断迭代器\n\n成员访问函数`front`,`back`,`下标`,`at`访问返回的都是引用. 如果容器是一个const对象 则返回值是const的引用 \n\n大多数会使迭代器失效的函数如erase`会在调用后返回删除的后一个元素位置的迭代器`, 使用返回值替换原来的迭代器可以在删除元素的情况下遍历所有元素\n\n不要保存end返回的迭代器, 添加删除vector或string元素后都会失效. `while (x != v.end())`或者是`for(; x != v.end();)`\n\n\n向容器中添加元素\n- 目标是vector或string 且存储空间被重新分配, 则指向容器的迭代器指针引用都会失效. 如果存储空间没有被重新分配, 则插入位置后的三者都会失效\n- 目标是deque 插入到除首尾之外的任何位置都会使三者失效 首尾添加元素则迭代器失效 但是指向存在元素的引用和指针不会失效\n- 对于list和forward_list 三者仍然有效\n\n从容器中删除元素\n- vector和string 被删元素之前的三者仍有效\n- list和forward_list 三者仍有效\n- deque 首尾之外的任何位置删除元素 指向被删除元素外`其他任何元素`的三者也会失效 如果删除尾元素则`尾后迭代器`失效 其他迭代器和指针不受影响\n\n\n\n## 第十章 泛型算法\n\n迭代器使得算法不依赖于容器, 可以解引用迭代器得到值, 也可以移动访问其他元素\n\n不过迭代器依赖于元素类型 因为会使用如`==` `<`之类的操作符 作用在元素上得到结果\n\n小小accumulate也有很多细节问题\n- 函数的返回值类型与第三个参数相同, 需要序列中元素能够转换成第三个参数的类型\n- 遍历元素的结果是加在第三个参数上的\n\n\n一个lambad只有在其捕获列表中捕获一个他所在函数中的局部变量, 才能在函数体中使用该变量.\n\n捕获列表只用于局部非static变量, lambda可以直接使用局部static变量和他所在函数之外声明的名字\n\n`值传递`的变量在lambda创建的时候进行拷贝, 所以随后的修改不会影响到lambda内的值\n\n`引用捕获`的则需要确保在lambda执行期间, 被引用的变量时存在的\n\n| 形式 | 说明 |\n| `[]` | 空捕获列表. lambda不能使用所在函数变量 |\n| `[names]` | 逗号分隔的所在函数的局部变量列表. 默认使用拷贝, 如果变量名前有&则使用引用 |\n| `[&]` | 隐式捕获列表, 引用捕获 |\n| `[=]` | 隐式捕获列表, 值捕获 |\n| `[&, names]` | 引用捕获, names列表使用值捕获 |\n| `[=, names]` | 值捕获, names列表使用引用捕获 |\n\n\n谓词 - 一个可调用的表达式, 其返回结果是一个能用做条件的值\n- 一元谓词 只接收单一参数\n- 二元谓词 有两个参数\n\n\n| | |\n| --- | --- |\n| find_if | |\n| for_each | |\n| bind | 参数绑定, 可以进行诸如 一二元谓词互换的操作 参数重排 绑定引用参数|\n| ref | 返回对象的引用 |\n\n\n1. 普通迭代器\n2. 插入迭代器\n- back_inserter 创建一个使用push_back的迭代器(需容器支持push_back)\n- front_inserter 创建一个使用push_front的迭代器(需容器支持push_front)\n- insterer 创建一个使用insert的迭代器\n3. 流迭代器\n- istream_iterator\n- ostream_iterator\n4. 反向迭代器 - 除了forward_list均支持\n\n\n算法要求的迭代器类型 五类迭代器\n- 输入迭代器 只读, 不写, 单边扫描, 只能递增\n- 输出迭代器 只写, 不读, 单边扫描, 只能递增\n- 前向迭代器 读写 多遍 只能递增\n- 双向迭代器 读写 多遍 增减都可\n- 随机访问迭代器 读写 多遍 支持全部迭代器运算\n\n\n## 第十二章 动态内存与智能指针\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png)\n\n**make_share**\n\n**shared_ptr的拷贝和赋值**\n当进行拷贝或者赋值操作时候 shared_ptr都会记录有多少个其他的shared_ptr\n指向相同的对象\n\n引用计数增加的情况\n- 拷贝shared_ptr \n- 初始化其他shared_ptr指针\n- 作为参数传递给一个函数\n- 作为函数的返回值\n\n引用计数减少\n- 赋予新值\n- 被销毁(例如离开作用域)\n\n当引用计数为0的时候, 就会释放自己管理的对象\n\n**使用动态内存的原因**\n- 程序不知道自己需要使用多少对象 容器类\n- 程序不知道所需对象的准确类型\n- 程序需要在多个对象间共享数据\n\n**程序需要在多个对象间共享数据**\n一般情况\n```c++\nvector<string> v1; // empty\n{ // 新的作用域\n\tvector<string> v2 = {\"a\", \"b\", \"c\"};\n\tv1 = v2;\n} // 离开作用域 v2被销毁\n// v1中有三个元素, 是原来三个元素的拷贝\n```\n\n下面是我们要实现的情况\n```c++\nvector<string> v1; // empty\n{ // 新的作用域\n\tvector<string> v2 = {\"a\", \"b\", \"c\"};\n\tv1 = v2; // v1 v2共享相同的元素\n} // 离开作用域 v2被销毁 但v2的元素不能被销毁\n// v1中有三个元素, 指向原来三个元素\n```\n\n创建一个类来管理这个vector, 但是不能直接保存在其中, 因为当这个类的对象销毁的时候内部的vector也就销毁\n所以需要保存在动态内存中\n\n所以使用shared_ptr来管理动态分配的vector, 当最后一个vector的使用者被销毁的时候才释放内存\n\n确定下这个类提供的操作\n- 修改元素的操作会进行校验 不合法则抛出异常\n- 默认构造函数\n- 接受单一的initiaizer_list\\<string>类型的参数. 这个参数可以接受一个初始器的花括号列表\n\n\n**直接管理内存**\n\n了解到两个概念 一个`默认初始化`一个`值初始化`\n\n```c++\nint i, *pi1 = &i, *pi2 = nullptr;\ndouble *pd = new double(33), *pd2 = pd;\ndelete i; // 错误 i不是指针\ndelete pi1; // 未定义 pi1指向一个局部变量 具有潜在性危害\ndelete pd; // ok\ndelete pd2; // 未定义 内存已经被释放 具有潜在性危害\ndelete pi2; // 正确 释放空指针没有错误\n\nconst int *pci = new const int(1024);\ndelete pci // 正确 释放一个const对象\n\n// delete之后指针就变成了`空悬指针` 需要将其置为`nullptr`\n```\n\n**shared_ptr和new结合使用**\n\n```c++\n// 错误智能指针构造函数是explicit\n// 无法将内置指针隐式转换成一个智能指针, 必须使用直接初始化\nshared_ptr<int> p1 = new int(1024); \n\n// 正确  使用了直接初始化\nshared_ptr<int> p2(new int(1024));\n```\n\n定义和改变方式\n```c++\n// p管理内置指针q所指向的对象, q必须指向new分配的内存, 且能够转换为T*类型\nshared_ptr<T> p(q)\n\n// p从unique_ptr u那里接管了对象的所有权 将U置为空\nshared_ptr<T> p(u)\n\n// p 接管了内置指针q所指向的对象的所有权, q必须能转化为T* 类型\n// p将使用可调用对象d来代替delete\nshared_ptr<T> p(q, d)\n\n// p是shared_ptr p2的拷贝\n// p将用可调用对象d来代替delete\nshared_ptr<T> p(p2, d)\n\n// 若p是唯一指向其对象的shared_ptr, reset会释放此对象\n// 如果传递了可选的参数-内置指针q, 则会令p指向q 否则将p置为空\n// 如果还传递了d, 会调用d而不是delete来释放q\np.reset()\np.reset(q)\np.reset(q, d)\n```\n\n**注意**\n\n使用unique_ptr的时候要注意\n1. 不要在函数调用传参的括号中 使用临时变量 这样一旦函数调用完成就会被销毁\n```c++\nvoid process(shared_ptr<int> ptr)\n\nshared_ptr<int> p(new int(42 )) ; // 引用 = 1\nprocess(p); // 拷贝 会递增它的引用计数 ;在 process 中引用计数位为2\nint i = *p; // 正确 引用计数为1\n\nint *x(new int(1024)); // 危险 这是一个普通指针，不是一个智能指针\nprocess(x) ; // 错误 不能将 int* 转换为 一个 shared_ptr<int> \nprocess(shared_ptr<int> (x)); // 合法的，但内存会被释放! 因为临时对象会被销毁\nint j =*x //未定义的 是一个空悬指针!\n```\n\n2. 如果使用智能指针不要使用get函数初始化另一个智能指针或为其赋值\n因为一旦新生成的智能指针离开作用域或者被释放, 会影响到原来的智能指针\n```c++\nstd::shared_ptr<int> p = new int(8); // 不能将一个int* 赋值给shared_ptr<int>\n\nstd::shared_ptr<int> p1;\np1.reset(new int(8)); // 可以\n\nstd::shared_ptr<int> p2(new int(8)); // OK\n\n// 使用make_share来创建shared_ptr指针\nstd::shared_ptr<int> p3 = std::make_shared<int>(20);\nauto p4 = std::make_shared<int>(20);\n\n// make_share不能用来创建unique_ptr\nstd::unique_ptr<int> d;\nstd::unique_ptr<int> d1 (new int(8)); \n```\n\n\n3. unique_ptr不支持普通的赋值和拷贝操作, 因为unique_ptr要独占所指向的对象\n```c++\nstd::unique_ptr<int> d1 (new int(1)); \nstd::unique_ptr<int> d2 (new int(8)); \n\nd1.release(); // 释放原来所指向的对象\nd1.reset(d2.release()); // d2释放后由d1获取\n```\n\n**智能指针陷阱**\n1. 不使用相同的内置指针值初始化(或reset)多个智能指针\n2. 不使用delete get返回的指针\n3. 不使用get初始化或者reset另一个智能指针\n4. 如果你使用get返回指针, 当最后一个对应的智能指针销毁 这个指针就变成了垂悬指针\n5. 使用智能指针管理非new分配的内存, 需要传递一个删除器.\n\n**weak_ptr**\n不控制所指向对象生存周期, 指向一个shared_ptr管理的对象.\n\n\n\n由于weak_ptr不参与对应的shared_ptr的引用计数, vector可能已经被释放了\n释放后 lock将返回一个空指针\n\n\n**allocator 将内存的分配和对象的构造分离开**\n\n\n# 第三部分 类设计者的工具\n## 模板与泛型编程\n\n`template <typename T>`\n\n编译器用推断出的模板参数来`实例化`一个特定版本的函数.\n不同的模板参数类型`实例化`出不同的函数 然后进行调用.\n\n**模板类型参数**\n\n如果有多个模板参数\n```c++\n// 错误\ntemplate <typename T, U>\n\n// 正确\ntemplate <typename T, typename U>\n\n// 正确\ntemplate <typename T, class U>\n```\n\n**非类型模板参数**\n\n```c++\ntemplate <unsigned N, unsigned M>\nint compare(const char (&p1)[N], const char (&p2)[M])\n{\n\treturn strcmp(p1, p2);\n}\n\ncompare(\"hi\", \"mmm\");\nint compare(const char (&p1)[3], const char (&p2)[4]) // 注意空字符\n```\n编译器会使用字面常量的大小来代替N和M, 从而实例化模板\n\n非类型参数可以使`整形`或者是一个指向对象或者函数类型的`指针`或者`(左值)引用`\n绑定到`非类型整数参数`的实参必须是一个常量表达式.\n绑定到`指针`或者`引用非类型模板参数`的实参必须具有静态的生存期\n\n静态内存用来保存`局部static对象`, `类static数据成员`和`定义于任何函数之外的变量`\n栈内存用来保存定义在函数内的非static对象.\n分配在静态内存和栈内存的由编译器自动创建和销毁\n\n堆 用来存储动态分配的对象\n\n\n编译器遇到一个模板类型定义的时候并不会生成代码, 而是实例化出一个特定版本的时候才会实例化\n\n\n**使用类的类型成员**\n\n```c++\ntemplate <typename T>\n\nT::size_type* p;\n```\n默认情况下, C++语言假定通过域运算符访问名字而不是类型.\n如果想要使用模板类型参数(T)的类型成员(size_type) 必须使用`typename`而不是`class`\n\n\n**默认模板实参**\n\n```c++\ntemplate <typename T, typename F = less<T>>\nint compare(const T& v1, const T& v2, F f = f())\n{\n\tif (f(v1, v2)) return -1;\n\tif (f(v2, v1)) return 1;\n\treturn 0;\n}\n```\n\n# 第四部分 高级主题\n\ntuple这里看了, 例子写了总感觉实用性不是很大? 或许可以用在便捷处理输入参数?\n\nbiset感觉还是有点用\n```c++\nstd::bitset<32> b;\n\n// 以下位不足 高位都补0\n\nunsigned long long u = ULLONG_MAX;\nstd::bitset<32> bu(u);\n\nstd::string s1 = \"10101010101010\";\nstd::bitset<32> bs1(s1);\nstd::string s2 = \"ababaabbababb\";\n// std::bitset<32> bs2(s2); std::invalid_argument\n// a instand 0 b instand 1\nstd::bitset<32> bs2(s2, 0, 32, 'a', 'b');\n\nbu.any(); // 存在 置位(1) 的二进制位吗\nbu.all(); // 所有位都置位了吗\nbu.none(); // b中不存在置位的二进制位吗\nbu.count(); // 置位数目\nbu.size(); // 数目\n\nbu.test(1); // 位置1是置位的返回true 否则返回false\nbu.set(1, true); // 将1位 置 true->1 false->0\nbu.reset(1); // 将1位复位 置0\nbu.reset(); // 将所有位复位 置0\n\nbu.flip(1); // 1位取反\nbu.flip(); // 全部取反\nbu[1].flip();\n\nbu[1]; // 1位 1->true 0->false\n\nbu.to_ulong();\nbu.to_ullong();\n\nbu.to_string('a', 'b'); // 0->a 1->b\n```\n\n","source":"_posts/读书记录80-CPPPrimer.md","raw":"---\ntitle: C++Primer学习\ntags:\n  - null\ncategories:\n  - 读书记录\ndate: 2019-08-16 19:13:22\ntop: 80\n\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/C%2B%2BPrimer.png\n---\n\n# TOOD\nexplicit 参见7.5.4节 265\n\n运算符优先级...........\n\n# 杂项\n\n**char 在默认情况下, 既不是有符号. 也不是无符号.**\n```c++\nchar a; // 此时a可能是 signed char 也可能是 unsigned char 可能会在不同系统之前产生错误\n// 可以显式声明, 来确保不会出现此错误\nsigned char a;\nunsigned char a; \n```\n\n**输入**\n```c++\nchar name[10];\ncin.getline(name, 10); // 可以读取换行符, 但不保存\ncin.get(name, 10); // 不读取换行符, 可能导致get到换行符\n\n// 空行和超出长度问题 将在后面说明\n```\n运算符优先级\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=59a3e1017d3e6709aa0d4dad5aaef458/63d9f2d3572c11df57c9a205612762d0f703c2f8.jpg)\n\n**基础的数组**\n```c++\nint a[] = {1, 2, 3, 4};\n// 下方由于 new 只是返回一个地址所以用 int* 接收 \nint* b = new int[4];\ncout << a[0] << endl; // 1\ncout << *(a + 1) << endl;// 2\n```\n**对指针解引用**\n第一印象是 解除引用, 然而并不是\n```c++\n/*\n\"*\"的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。也就是说，解引用是返回内存地址中保存的值。\n比如int a=10; int *p=&a;\ncout<<*p<<endl; 输出a的值，就是解引用操作。\n*/\n```\n\n\n**常用 宏**\n| 定义 | 说明 |\n| ----- | ----- |\n| `__FILE__` | 存放文件名的字符串字面值 |\n| `__LINE__` | 存放当前行号的整形字面值 |\n| `__TIME__` | 存放文件编译时间的字符串字面量 |\n| `__DATE__` | 存放文件编译日期的字符串字面值 |\n| `__VA_ARGS__` | 用来接受函数参数中`...`, 类似printf函数, 这个宏只能在宏中使用 |\n\n\n# 第一部分 基础知识\n\n## 第二章 变量和基本类型\n### 习题\n\n**2.2 与钱相关的数据存储 使用的类型**\n银行相关钱相关的数据 保存 使用整形, 不太可能使用浮点数. 浮点数运算可能会出现误差\n使用`1`代表`1RMB` 或者使用`1`代表`0.01RMB`\n\n**2.9 解释下列定义 对于非法说出错在哪里**\n```c++\nstd::cin >> int input_value; // error: expected primary-expression before ‘int’\n\nint i1 = {3.14};// narrowing conversion of ‘3.1400000000000001e+0’ from ‘double’ to ‘int’ inside { } [-Wnarrowing]\n\ndouble salary = wage = 9999.99;// error: ‘wage’ was not declared in this scope 如果定义wage则语句不报错\n\nint i2 = 3.14;\n```\n\n**2.10 下列变量的初始值是什么**\n\n内置类型变量未被显示初始化  函数体之外初始化为0  函数体内是未被定义的\n类\t一般都拥有默认的初始化方式\n```c++\nstd::string g_str; // 全局变量 且拥有默认初始化方式 为空字符串\nint g_int; // \t全局变量 初值为0\nint main()\n{\n\tint local_int; // 局部变量 未定义\n\tstd::string local_str; // 拥有默认初始化方式 空字符串\n}\n```\n\n**2.14 下面代码输出什么**\n起初一看 以为会是循环到溢出 直接就把代码码了下来运行 发现是正常的.\n就算for中 `int i = 0`改为`i = 0`依然不会溢出\nfor的i覆盖了外面的i\n```c++\n#include <iostream>\n\nint main()\n{\n    int i = 100, sum = 0;\n    for (int i = 0; i != 10; ++i)\n    {\n        sum += i;\n    }\n\n    std::cout << i << \" \" << sum << std::endl; //$ 100 45\n\n    return 0;\n}\n```\n\n输出~~~\n```c++\n#include <iostream>\n\nint main()\n{\n    int i, &ri = i;\n    i = 5;\n    ri = 10;\n\n    std::cout << i << \" \" << ri <<std::endl; //$ 10 10\n    return 0;\n}\n```\n\n\n### tips\n一个形如42的值被称为`字面值常量(literal)`, 这样的值你一看到(面), 就知道是多少\n\nscope 作用域\n\n### 无符号\n**unsigned int和int运算的时候 自动转换为unsigned**\n```c++\nunsigned int a = 10;\nint b = -11;\n\nstd::cout << a + b << std::endl; //$ 4294967295\n```\n\n**警惕for循环中的 无符号类型**\nsize_t\n\n\n### 声明定义初始化赋值\n**声明**\n声明不是定义, 可以多次声明\n指明变量的type和name.\n对于变量的声明需要使用`extern`关键字, 如果使用了`extern`关键字的同时初始化就成了定义\n```c++\nint i; // 声明并定义 未初始化\nextern int a; // 声明\nextern int a = 10; // 定义 声明 初始化\n```\n\n**定义**\n声明并定义, 只能定义一次\n定义的时候需要指定type和name. 申请空间, 可能进行初始化.\n\n\n**初始化 赋值**\n初始化 不是赋值\n初始化是创建变量时 赋予其一个初始值\n赋值是擦除当前的值 赋予新的值\n\n\n**变量类型选择**\n数值范围超过`int` 建议使用`long long`, `long`的长度仅是大于等于`int`\nchar类型可能是 `signed` 还可能是`unsigned` 如果针对范围有特殊要求 应该注明是否有无符号\n浮点运算建议使用double float经常精度不够, 然而两者运算效率却相差无几. `long double`反而绝大多数情况用不到\n\n### const\nconst变量必须被初始化\n\n所谓指向常量的引用或指针, 不过是指针或引用自以为是罢了, 他们觉得自己指向了常量, 所以自觉不去修改\n\n顶层const: 表示指针本身是常量\n底层const: 表示指针指向是一个常量\n指针本身是一个对象, 他可以指向另一个对象. 因此, 指针本身是不是常量, 以及指针所向是不是一个常量就是两个独立的问题.\n\n\n执行拷贝的时候, 常量是顶层const还是底层const区别明显, 顶层const可以视为不见\n然而底层const的限制不能忽视, 拷入和拷出对象必须具有相同的底层const资格\n\n**指针常量和类型别名**\n```c++\ntypedef char* pstring;\nconst pstring cstr = 0;\n```\n这里pstring是指向char的指针 const pstring是指向char的常量指针 指针指向不能变\n而不是简单地将pstring替换掉\n\n\n### constexpr\n在一个复杂系统中, 很难分辨一个初始值到底是不是常量表达式.\n当然可以定义一个const变量 并把初始值设定为我们认为的常量表达式, 然而实际依然有非常量表达式的情况\n\nC++11标准 将变量声明为constexpr由编译器来验证变量是否是一个常量表达式\n\n```c++\nconstexpr int mm = 20; // 20是常量表达式\nconstexpr int yy = mm + 1; // mf + 1是常量表达式\nconstexpr int sz = size(); // 当size是一个constexpr函数时才是正确的声明语句\n```\n\n指针和引用都能定义成constexpr, 但初始值受到严格限制.\nconstexpr指针的初始值必须是nullptr或者0 或者存储于某个固定地址中的对象(位于所有函数体之外)\nconstexpr引用能绑定到 某个固定地址中的对象\n\n**decltype和引用**\n`decltype((i)) d` 双层括号是引用\n`decltype(i) d`单层括号只有i是引用的时候 d才是引用\n\n## 第三章 字符串 向量和数组\n### 习题\n\n**3.34**\np1和p2指向同一数组中的元素, 则下面程序的功能是什么? 什么情况下程序是非法的?\np1 += p2 - p1;\n将p1移动到p2的位置  不会非法..........\n\n\n### {} = ()\n```c++\nstring a = \"cccc\";  // 只有一个参数值\nstring b(10, 'c'); // 拥有两个参数值 10和'c'\n```\n\n使用=, 进行拷贝初始化 只能提供一个初始值\n使用(), 进行直接初始化, 可以提供多个初始值进行初始化\n\n```c++\nclass A\n{\n  int a1 = 10;\n  int a2(10);\n  // temp.cpp:4:12: error: expected identifier before numeric constant\n  // int a2(10);\n  // temp.cpp:4:12: error: expected ‘,’ or ‘...’ before numeric constant\n  int a3{10};\n}\n```\n类内初始值 不能使用小括号\n\n\n列表初始化只能放在花括号中 \n\n### vector\nvector中不能保存引用, 因为使用引用就必须初始化.\n\n设想, 你设置了vector包含十个元素, 这十个空间就必须被初始化, \n然而引用必须要绑定到具体的对象上, 此时却没有对象进行绑定\n\n再者如果容器复制的时候 引用怎么复制?\n\n```c++\nvector<int> v1(10); // 10个元素, 全为0\nvector<int> v2{10}; // 一个元素, 为10\n\nvector<int> v3(10, 1); // 10个元素, 全为1\nvector<int> v4{10, 1}; // 两个元素, 10和1\n\n// -----------------------------------------\n\nvector<string> v5{\"hi\"}; // 列表初始化 有一个元素\nvector<string> v6(\"hi\"); // 错误不能使用字符串字面值构建vector元素\n\nvector<string> v7{10}; // 10个默认初始化的对象\nvector<string> v8{10, \"hi\"}; // 十个值为\"hi\"的元素\n```\n\n因为不能使用int来初始化string对象, 列表初始化要求列表值类型与尖括号种类型相同\nv7和v8并不是列表初始化, 而是转去尝试用默认值(默认值????)初始化\n\n这里感觉有点?去看了下英文原版\nthe compiler looks for\nother ways to initialize the object from the given values.\n\n\n\n**迭代器**\n使用的时候注意迭代器失效, \n\n### 数组和指针\n```c++\nint (*array_ptr)[10] = &arr; // 指向十个整数的数组\nint (&array_ref)[10] = arr; // 十个整数数组的引用\n```\n\n```c++\nint a[] = {0, 1, 2, 3, 4, 5, 6, 7};\n\nauto a1(a); // a1是指针类型\ndecltype(a) a2; //a2是有八个元素的数组\n\nint* b = std::begin(a); // 指向首元素\nint* c = std::end(a); // 指向最后一个元素的后一位\n\nptrdiff_t d = c - b; // ptrdiff_t 定义在cstddef中\n\nint* p = &a[2];\nint k = p[-1];// 内置下标运算符所用的索引值不是无符号型 可以为负\n```\n\n## 第四章 表达式\n当一个对象被用作右值的时候, 使用的是对象的值(内容)\n当一个对象被用做左值的时候, 使用的是对象的身份(在内存中的位置)\n\n如果表达式的求值结果是左值, decltype作用于该表达式得到一个引用类型.\n\n`int* p`\n解引用运算符生成左值 `decltype(*p)`得到的是`int&`\n取地址运算符生成右值 `decltype(&p)`的结果是`int**`\n\n\n大多数运算符没有规定按照什么顺序求值\n`int i = f1() * f2()`\n这两函数的调用顺序是未定义的\n\n只有四种运算符规定了运算对象的求值顺序\n短路求值\n`&&` 从左到右\n`||` 从左到右\n\n`?:`\n`,` 逗号运算符 从左到右 首先求值左侧然后丢掉结果 真正返回的是右侧结果\n\n\n书写表达式的建议\n1. 拿不准的时候最好使用括号来组合表达式. 括号不香吗?\n2. 如果改变了某个运算对象的值, 在表达使得其他地方就不要再使用这个运算对象\n\n`(-m) / n` 和 `m / (-n)` 等于 `-(m / n)`\n`m % (-n)` 等于 `m % n`\n`(-m) % n` 等于 `-(m % n)`\n\n\n```c++\nint ival, jval\nival = jval = 0;\n```\n赋值运算符右结合, 所以右侧的`jval = 0`是左侧赋值运算符的右侧运算对象\n又因为赋值运算符返回的是其左侧运算对象, 所以右侧赋值运算符的结果(Jval)赋给了ival\n\n\n赋值运算符的优先级低于关系运算符, 所以条件语句中, 赋值部分应该加上括号\n\n\n`sizeof *p`\nsizeof 不会实际求运算对象的值, 所以即使p是无效指针也不会有什么影响\nsizeof对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小\nsizeof对string对象和vector对象 只返回该类型固定部分的大小, 不会计算对象中元素占用了多少空间\nsizeof(string) 与string长度无关, 不同的编译器有不同的具体实现\nhttp://www.cplusplus.com/forum/general/218642/\n\nsizeof(vector<int>) 返回24字节 64位系统指针8字节 三个指针24字节 (头指针, 尾指针, 当前容量尾指针)\npointer _M_start;\npointer _M_finish;\npointer _M_end_of_storage;\n\n非内置类型基本都含有指针, 指向堆中分配的内存, 所以存在存储任意大小都会返回固定sizeof\n\n\n`const-name<type>(expr)`\n命名显式强制类型转换\n\nstatic_cast 静态类型转换 用于替代隐式类型转换\n- 子类向父类转换 安全\n- 父类向子类转换 无动态类型检查 不安全\n- 基本数据类型转换\n- 指针类型转换\n- 将任何其他类型转换为void类型\n\n任何具有明确定义的类型转换, 只要底层不包含const, 都能使用. 值类型转换以及指针类型转换\n如果类型不兼容, 则编译阶段报错.\n\ndynamic_cast\n运行时转换, 如果转换失败返回null. type和expr必须同是类指针或者类引用\n用于父类向子类的转换\n\nconst_cast\n增加或删除运算对象的底层const, 如果对象本身不是一个常量 获取写权限是合法的, 如果是常量则会产生未定义后果.\n\n\nreinterpret_cast\n为运算对象的位模式提供较低层次上的重新解析\nhttps://zhuanlan.zhihu.com/p/33040213\n\n\n## 第五章 语句\n\n\n即使不准备在default标签下做任何工作, 定义一个default标签也是有作用的. 可以告知读者, \n我们已经考虑到了默认情况, 只是目前什么也没做\n\n\n**switch-case关于变量定义的问题**\n```c++\n#include <string>\n#include <iostream>\nint main()\n{\n    switch (true)\n    {\n        case true:\n            std::string v1;\n            std::string v2 {};\n            int v3 = 0;\n            int v4;\n            break;\n\n        case false:\n            std::cout << v1 << std::endl;\n            std::cout << v2 << std::endl;\n            std::cout << v3 << std::endl;\n            std::cout << v4 << std::endl;\n            break;\n    }\n\n    return 0;\n}\n\n// 编译报错 注意没有   v4  控制流绕过了初始化变量的语句\n\nswitch-case.cpp: In function ‘int main()’:\nswitch-case.cpp:16:14: error: jump to case label [-fpermissive]\n         case false:\n              ^~~~~\nswitch-case.cpp:12:17: note:   crosses initialization of ‘int v3’\n             int v3 = 0;\n                 ^~\nswitch-case.cpp:11:25: note:   crosses initialization of ‘std::__cxx11::string v2’\n             std::string v2 {};\n                         ^~\nswitch-case.cpp:10:25: note:   crosses initialization of ‘std::__cxx11::string v1’\n             std::string v1;\n\n// 两个case语句加上括号后报错变为\nswitch-case.cpp: In function ‘int main()’:\nswitch-case.cpp:18:26: error: ‘v1’ was not declared in this scope\n             std::cout << v1 << std::endl;\n                          ^~\nswitch-case.cpp:19:26: error: ‘v2’ was not declared in this scope\n             std::cout << v2 << std::endl;\n                          ^~\nswitch-case.cpp:20:26: error: ‘v3’ was not declared in this scope\n             std::cout << v3 << std::endl;\n                          ^~\nswitch-case.cpp:21:26: error: ‘v4’ was not declared in this scope\n             std::cout << v4 << std::endl;\n```\n\n\n定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程\n\n\n牢记for语句头中定义的对象只在for循环体内可见.~~~~~~~~~~~\n\n\n**break continue**\n\nbreak负责终止离他最近的while, do while, for或者switch. 并从这些语句后的第一条开始继续执行\n\ncontinue语句终止最近的循环中当前迭代, 并立即开始下一次迭代\n\n**异常处理**\n代码可以使用throw来抛出异常\n大部分可以指定msg来初始化异常\nthrow exception_type(\"msg\")\n表中exception不能指定msg, 来初始化, 除此外表中其他都需要msg初始\n\n位于`stdexcept`头文件中\n\n| 错误名称        | 对应原因                       |\n| ---------------- | ---------------------------------- |\n| exception        | 最常见的问题 |\n| runtime_error    | 只有运行的时候才能查到错误         |\n| range_error      | 运行时错误: 超范围                 |\n| overflow_error   | 运行时错误: 上溢                   |\n| underflow_error  | 运行时错误: 下溢                   |\n| logic_error      | 程序逻辑错误                       |\n| domain_error     | 程序逻辑错误: 参数对应的结果不存在 |\n| invalid_argument | 程序逻辑错误: 无效参数             |\n| length_error     | 程序逻辑错误: 试图创建一个超出该类型最大长度的对象  如vector::reserve  |\n| out_of_range     | 程序逻辑错误: 超范围               |\n\n\n## 第六章 函数\n\n形参名是可选的, 但是由于无法使用未命名的形参, 所以一般都有一个名字.\n\n\n自动对象: 只存在于块执行期间的对象\n局部静态对象: 只在`第一次`经过对象语句时进行初始化, 直到程序终止才被销毁.\n\n\n数组引用形参\n```c++\nvoid print(int (&arr)[10])\n{\n    for (auto elem : arr)\n    {\n        cout << elem << endl;\n    }\n}\n```\n\n函数返回引用得到左值\n返回其他类型得到右值\n\np205页 还真没见过 返回数组指针这种形式\n\n\n## 第七章 类\n### 习题\n\n**7.25 Screen能安全的依赖于拷贝和赋值操作的默认版本吗**\nScreen中只有内置类型和string, 如果其含有动态管理的内存则不行\n当类需要分配类对象以外的资源时, 默认版本经常会失效\n\n\n默认构造函数, 会造成 内置类型和复合类型成员 默认初始化后 值未定义\n\n关于未定义这点我去写了小段程序看了下, 也搜了一下\n\nhttps://stackoverflow.com/a/2218275/11581349\n\nIt will be automatically initialized if\n- it's a class/struct instance in which the default constructor initializes all primitive types; like MyClass instance; 有默认构造函数类或者结构体, 并且默认构造函数初始化所有内置类型\n- you use array initializer syntax, e.g. int a[10] = {} (all zeroed) or int a[10] = {1,2}; (all zeroed except the first two items: a[0] == 1 and a[1] == 2) 使用了大括号初始化\n- same applies to non-aggregate classes/structs, e.g. MyClass instance = {}; (more information on this can be found here) 同大括号初始化\n- it's a global/extern variable 全局或者extern类型\n- the variable is defined static (no matter if inside a function or in global/namespace scope) 变量被声明为static\n\n\n默认初始化发生的情况\n\n- 不使用任何初始值定义一个非静态变量或者数组\n- 一个类本身含有类类型的成员且使用合成的默认构造函数\n- 类类型的成员没有在构造函数初始值列表中显示地初始化时\n\n值初始化\n\n- 数组初始化提供的初始值数量小于数组大小\n- 不使用初始值定义一个局部静态变量\n- 书写T()表达式 显示地请求值初始化\n\nmutable可变数据成员, 从远不会是const.  可以在const成员函数中对其进行修改\n\n类的GetBalance函数的函数体在整个Account类可见之后才被处理.\n\n编译器看到GetBalance的声明后 开始从类内(**类内会从使用Money前查找**)到类外寻找Money声明, 然后函数的返回值和bal成员变量的类型为double, 接着类可见之后处理函数体 函数会返回double类型的成员变量bal\n```c++\ntypedef double Money;\nstd::string balance = \"string\";\nclass Account\n{\npublic:\n    // typedef std::string Money; 这里则不会报错\n    Account() = default;\n    ~Account() = default;\n    Money GetBalance() const\n    { return balance;  }\nprivate:\n    // typedef std::string Money; 会报错 因为由于GetBalance函数已经使用了外部的Money\n    Money balance;\n};\nint main()\n{\n    Account account;\n    std::cout << account.GetBalance(); // $ 0\n    return 0;\n}\n```\n\n```c++\nclass Foo\n{\npublic:\n    Foo(int val):\n        bar1(val),\n        bar2(bar1){}\n\nprivate:\n    int bar1; // 更改两个顺序  将会导致先使用 bar1初始化bar2 然后使用val初始化bar1\n    int bar2;\n}\n```\n在我看了一些项目后使用的上面的写法, 然而这种写法却不合适 除非你严格按照变量顺序写.\n\n如果你将bar2和bar1的顺序不小心更换了, 难以排查的bug\n\n**使用默认构造函数声明对象 需要去掉对象名后的空括号对**\n```c++\nFoo foo(); // 错误\nFoo foo;\n```\n\n### 隐式的类类型转换\n\n如果构造函数只接受一个实参, 则它实际上定义了转换为此类类型的隐式转换机制 -- 称这种构造函数为**转换构造函数**\n\nFoo含有一个只有string类型的构造函数. 当一个函数的参数是Foo类型时. 你可以将string类型直接传递给这个函数. 会自动从string类型构造成Foo类型\n\n```c++\n// Value(string val); 可以加上explicit防止隐式类型转换\n// void Add(Value val);\n\nstring val1 = \"val1\";\nfoo.Add(val1); // 正确 隐式转换成Value\nfoo.Add(\"val2\"); // 错误 只能进行一步转换  需要从\"val2\"到string再到Value\n```\n\n\n### 聚合类 字面值常量类\n\n聚合类\n- 所有成员都是public\n- 没有定义任何构造函数\n- 没有类内初始值\n- 没有基类也没有virtual函数\n\n```c++\nclass Foo\n{\npublic:\n\tstd::string str;\n\tint val;\n};\nint main()\n{\n\tFoo foo = {\"1\", 1};\n}\n```\n\n字面值常量类\n- 数据成员都是字面值类型的聚合类\n\n如果一个类不是聚合类, 但是符合以下要求也是字面值类型常量类\n- 数据成员必须是字面值类型\n- 类必须含有一个constexpr构造函数\n- 如果一个数据成员含有类内初始值, 则初始值必须是一条常量表达式. 如果成员属于某种类类型, 则初始值必须使用成员自己的constexpr构造函数\n- 类必须使用默认析构函数\n\n# 第二部分 cpp标准库\n\n## 第八章 IO库\n\n想到了遇到过的`while(std::cin >> xx)`究竟是如何判断的呢? `>>`返回的对象是`std::cin`如何将其转换为`bool`?\n\n重载运算符\n```c++\nexplicit __CLR_OR_THIS_CALL operator bool() const {\n        return !fail();\n    }\n_NODISCARD bool __CLR_OR_THIS_CALL operator!() const {\n    return fail();\n}\n\nclass Foo\n{\npublic:\n\texplicit operator bool()\n\t{\n\t\tstd::cout << \"operator *\" << std::endl;\n\t\treturn true;\n\t}\n\tbool operator!()\n\t{\n\t\tstd::cout << \"operator !\" << std::endl;\n\t\treturn true;\n\t}\n};\nint main()\n{\n\tFoo foo;\n\tif (foo); // $ operator *\n\tif (!foo);// $ operator !\n}\n```\n\n\nendl  换行 刷新缓冲区\nflush 刷新缓冲区\nends  空字符 刷新缓冲区\n\n\nunitbuf 所有输出操作后都会立即刷新缓冲区\nnounitbuf 恢复正常的缓冲方式\n\n## 第九章 顺序容器\n\n### 习题\n\n\n**9.6 下面的程序有何错误 你应该如何修改它?**\n```c++\nlist<int> lst1;\nlist<int>::iterator iter1 = lst1.begin(),\niter2 = lst1.end();\nwhile (iter1 < iter2)\n```\n将`while (iter1 < iter2)` 改成`while(iter1 != iter2)`\n迭代器是指向元素的指针, 对于list来说比较元素指针大小无法判断\n@@@@\n\n\n**9.12 对于接受一个容器创建其拷贝的构造函数 和 接收两个迭代器创建拷贝的构造函数之间的不同**\n\n**创建拷贝**-要求容器类型和元素类型都相同\n**接收两个迭代器**-元素类型能够相互转化即可\n\n### 函数说明\n\nassign函数 仅顺序容器\n- 用指定元素的拷贝 替换左侧容器中的所有元素\n\nswap函数\n- 只会真正交换array的元素 与长度有关\n- 其他容器会交换内部的数据结构 常数时间完成\n\n除了string指向容器的迭代器 引用和指针在swap操作之后都不会失效 仍指向swap操作前的元素,\n但是这些元素已经属于不同的容器了\n\n关系运算符\n- 两个容器具有相同的大小 且所有元素两两对应相等 这两个容器相等 否则不等\n- 如果两个容器大小不同, 但较小的容器中每个元素都等于较大容器中对应元素 则较小容器 > 较大容器\n- 比较结果取决于第一个不相等的元素的比较结果 类似 compare\n\n\n容器的运算符 非迭代器\n== != 运算符 所有容器都支持\n< <= > >= 运算符 无序关联容器不支持\n\n\nsize_type 无符号整数 足够保存此种容器类型最大可能容器的大小\ndifference_type 带符号整数类型 足够保存两个迭代器之间的距离\nvalue_type 元素类型\n\n除了array之外其他容器的默认构造函数会创建一个指定类型的`空容器`\n\n只有`顺序容器`的`构造函数`才接`受大小参数` 关联容器并不支持\n\n如果元素类型是内置类型或者具有默认的构造函数的类类型,可以只为构造函数提供一个容器大小的参数\n如果元素类型没有默认构造函数 除了容器大小参数 还必须指定一个显示的元素初始值\n\n只有支持随机访问容器的迭代器才支持`operator<`, list只能使用`=`来判断迭代器\n\n成员访问函数`front`,`back`,`下标`,`at`访问返回的都是引用. 如果容器是一个const对象 则返回值是const的引用 \n\n大多数会使迭代器失效的函数如erase`会在调用后返回删除的后一个元素位置的迭代器`, 使用返回值替换原来的迭代器可以在删除元素的情况下遍历所有元素\n\n不要保存end返回的迭代器, 添加删除vector或string元素后都会失效. `while (x != v.end())`或者是`for(; x != v.end();)`\n\n\n向容器中添加元素\n- 目标是vector或string 且存储空间被重新分配, 则指向容器的迭代器指针引用都会失效. 如果存储空间没有被重新分配, 则插入位置后的三者都会失效\n- 目标是deque 插入到除首尾之外的任何位置都会使三者失效 首尾添加元素则迭代器失效 但是指向存在元素的引用和指针不会失效\n- 对于list和forward_list 三者仍然有效\n\n从容器中删除元素\n- vector和string 被删元素之前的三者仍有效\n- list和forward_list 三者仍有效\n- deque 首尾之外的任何位置删除元素 指向被删除元素外`其他任何元素`的三者也会失效 如果删除尾元素则`尾后迭代器`失效 其他迭代器和指针不受影响\n\n\n\n## 第十章 泛型算法\n\n迭代器使得算法不依赖于容器, 可以解引用迭代器得到值, 也可以移动访问其他元素\n\n不过迭代器依赖于元素类型 因为会使用如`==` `<`之类的操作符 作用在元素上得到结果\n\n小小accumulate也有很多细节问题\n- 函数的返回值类型与第三个参数相同, 需要序列中元素能够转换成第三个参数的类型\n- 遍历元素的结果是加在第三个参数上的\n\n\n一个lambad只有在其捕获列表中捕获一个他所在函数中的局部变量, 才能在函数体中使用该变量.\n\n捕获列表只用于局部非static变量, lambda可以直接使用局部static变量和他所在函数之外声明的名字\n\n`值传递`的变量在lambda创建的时候进行拷贝, 所以随后的修改不会影响到lambda内的值\n\n`引用捕获`的则需要确保在lambda执行期间, 被引用的变量时存在的\n\n| 形式 | 说明 |\n| `[]` | 空捕获列表. lambda不能使用所在函数变量 |\n| `[names]` | 逗号分隔的所在函数的局部变量列表. 默认使用拷贝, 如果变量名前有&则使用引用 |\n| `[&]` | 隐式捕获列表, 引用捕获 |\n| `[=]` | 隐式捕获列表, 值捕获 |\n| `[&, names]` | 引用捕获, names列表使用值捕获 |\n| `[=, names]` | 值捕获, names列表使用引用捕获 |\n\n\n谓词 - 一个可调用的表达式, 其返回结果是一个能用做条件的值\n- 一元谓词 只接收单一参数\n- 二元谓词 有两个参数\n\n\n| | |\n| --- | --- |\n| find_if | |\n| for_each | |\n| bind | 参数绑定, 可以进行诸如 一二元谓词互换的操作 参数重排 绑定引用参数|\n| ref | 返回对象的引用 |\n\n\n1. 普通迭代器\n2. 插入迭代器\n- back_inserter 创建一个使用push_back的迭代器(需容器支持push_back)\n- front_inserter 创建一个使用push_front的迭代器(需容器支持push_front)\n- insterer 创建一个使用insert的迭代器\n3. 流迭代器\n- istream_iterator\n- ostream_iterator\n4. 反向迭代器 - 除了forward_list均支持\n\n\n算法要求的迭代器类型 五类迭代器\n- 输入迭代器 只读, 不写, 单边扫描, 只能递增\n- 输出迭代器 只写, 不读, 单边扫描, 只能递增\n- 前向迭代器 读写 多遍 只能递增\n- 双向迭代器 读写 多遍 增减都可\n- 随机访问迭代器 读写 多遍 支持全部迭代器运算\n\n\n## 第十二章 动态内存与智能指针\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png)\n\n**make_share**\n\n**shared_ptr的拷贝和赋值**\n当进行拷贝或者赋值操作时候 shared_ptr都会记录有多少个其他的shared_ptr\n指向相同的对象\n\n引用计数增加的情况\n- 拷贝shared_ptr \n- 初始化其他shared_ptr指针\n- 作为参数传递给一个函数\n- 作为函数的返回值\n\n引用计数减少\n- 赋予新值\n- 被销毁(例如离开作用域)\n\n当引用计数为0的时候, 就会释放自己管理的对象\n\n**使用动态内存的原因**\n- 程序不知道自己需要使用多少对象 容器类\n- 程序不知道所需对象的准确类型\n- 程序需要在多个对象间共享数据\n\n**程序需要在多个对象间共享数据**\n一般情况\n```c++\nvector<string> v1; // empty\n{ // 新的作用域\n\tvector<string> v2 = {\"a\", \"b\", \"c\"};\n\tv1 = v2;\n} // 离开作用域 v2被销毁\n// v1中有三个元素, 是原来三个元素的拷贝\n```\n\n下面是我们要实现的情况\n```c++\nvector<string> v1; // empty\n{ // 新的作用域\n\tvector<string> v2 = {\"a\", \"b\", \"c\"};\n\tv1 = v2; // v1 v2共享相同的元素\n} // 离开作用域 v2被销毁 但v2的元素不能被销毁\n// v1中有三个元素, 指向原来三个元素\n```\n\n创建一个类来管理这个vector, 但是不能直接保存在其中, 因为当这个类的对象销毁的时候内部的vector也就销毁\n所以需要保存在动态内存中\n\n所以使用shared_ptr来管理动态分配的vector, 当最后一个vector的使用者被销毁的时候才释放内存\n\n确定下这个类提供的操作\n- 修改元素的操作会进行校验 不合法则抛出异常\n- 默认构造函数\n- 接受单一的initiaizer_list\\<string>类型的参数. 这个参数可以接受一个初始器的花括号列表\n\n\n**直接管理内存**\n\n了解到两个概念 一个`默认初始化`一个`值初始化`\n\n```c++\nint i, *pi1 = &i, *pi2 = nullptr;\ndouble *pd = new double(33), *pd2 = pd;\ndelete i; // 错误 i不是指针\ndelete pi1; // 未定义 pi1指向一个局部变量 具有潜在性危害\ndelete pd; // ok\ndelete pd2; // 未定义 内存已经被释放 具有潜在性危害\ndelete pi2; // 正确 释放空指针没有错误\n\nconst int *pci = new const int(1024);\ndelete pci // 正确 释放一个const对象\n\n// delete之后指针就变成了`空悬指针` 需要将其置为`nullptr`\n```\n\n**shared_ptr和new结合使用**\n\n```c++\n// 错误智能指针构造函数是explicit\n// 无法将内置指针隐式转换成一个智能指针, 必须使用直接初始化\nshared_ptr<int> p1 = new int(1024); \n\n// 正确  使用了直接初始化\nshared_ptr<int> p2(new int(1024));\n```\n\n定义和改变方式\n```c++\n// p管理内置指针q所指向的对象, q必须指向new分配的内存, 且能够转换为T*类型\nshared_ptr<T> p(q)\n\n// p从unique_ptr u那里接管了对象的所有权 将U置为空\nshared_ptr<T> p(u)\n\n// p 接管了内置指针q所指向的对象的所有权, q必须能转化为T* 类型\n// p将使用可调用对象d来代替delete\nshared_ptr<T> p(q, d)\n\n// p是shared_ptr p2的拷贝\n// p将用可调用对象d来代替delete\nshared_ptr<T> p(p2, d)\n\n// 若p是唯一指向其对象的shared_ptr, reset会释放此对象\n// 如果传递了可选的参数-内置指针q, 则会令p指向q 否则将p置为空\n// 如果还传递了d, 会调用d而不是delete来释放q\np.reset()\np.reset(q)\np.reset(q, d)\n```\n\n**注意**\n\n使用unique_ptr的时候要注意\n1. 不要在函数调用传参的括号中 使用临时变量 这样一旦函数调用完成就会被销毁\n```c++\nvoid process(shared_ptr<int> ptr)\n\nshared_ptr<int> p(new int(42 )) ; // 引用 = 1\nprocess(p); // 拷贝 会递增它的引用计数 ;在 process 中引用计数位为2\nint i = *p; // 正确 引用计数为1\n\nint *x(new int(1024)); // 危险 这是一个普通指针，不是一个智能指针\nprocess(x) ; // 错误 不能将 int* 转换为 一个 shared_ptr<int> \nprocess(shared_ptr<int> (x)); // 合法的，但内存会被释放! 因为临时对象会被销毁\nint j =*x //未定义的 是一个空悬指针!\n```\n\n2. 如果使用智能指针不要使用get函数初始化另一个智能指针或为其赋值\n因为一旦新生成的智能指针离开作用域或者被释放, 会影响到原来的智能指针\n```c++\nstd::shared_ptr<int> p = new int(8); // 不能将一个int* 赋值给shared_ptr<int>\n\nstd::shared_ptr<int> p1;\np1.reset(new int(8)); // 可以\n\nstd::shared_ptr<int> p2(new int(8)); // OK\n\n// 使用make_share来创建shared_ptr指针\nstd::shared_ptr<int> p3 = std::make_shared<int>(20);\nauto p4 = std::make_shared<int>(20);\n\n// make_share不能用来创建unique_ptr\nstd::unique_ptr<int> d;\nstd::unique_ptr<int> d1 (new int(8)); \n```\n\n\n3. unique_ptr不支持普通的赋值和拷贝操作, 因为unique_ptr要独占所指向的对象\n```c++\nstd::unique_ptr<int> d1 (new int(1)); \nstd::unique_ptr<int> d2 (new int(8)); \n\nd1.release(); // 释放原来所指向的对象\nd1.reset(d2.release()); // d2释放后由d1获取\n```\n\n**智能指针陷阱**\n1. 不使用相同的内置指针值初始化(或reset)多个智能指针\n2. 不使用delete get返回的指针\n3. 不使用get初始化或者reset另一个智能指针\n4. 如果你使用get返回指针, 当最后一个对应的智能指针销毁 这个指针就变成了垂悬指针\n5. 使用智能指针管理非new分配的内存, 需要传递一个删除器.\n\n**weak_ptr**\n不控制所指向对象生存周期, 指向一个shared_ptr管理的对象.\n\n\n\n由于weak_ptr不参与对应的shared_ptr的引用计数, vector可能已经被释放了\n释放后 lock将返回一个空指针\n\n\n**allocator 将内存的分配和对象的构造分离开**\n\n\n# 第三部分 类设计者的工具\n## 模板与泛型编程\n\n`template <typename T>`\n\n编译器用推断出的模板参数来`实例化`一个特定版本的函数.\n不同的模板参数类型`实例化`出不同的函数 然后进行调用.\n\n**模板类型参数**\n\n如果有多个模板参数\n```c++\n// 错误\ntemplate <typename T, U>\n\n// 正确\ntemplate <typename T, typename U>\n\n// 正确\ntemplate <typename T, class U>\n```\n\n**非类型模板参数**\n\n```c++\ntemplate <unsigned N, unsigned M>\nint compare(const char (&p1)[N], const char (&p2)[M])\n{\n\treturn strcmp(p1, p2);\n}\n\ncompare(\"hi\", \"mmm\");\nint compare(const char (&p1)[3], const char (&p2)[4]) // 注意空字符\n```\n编译器会使用字面常量的大小来代替N和M, 从而实例化模板\n\n非类型参数可以使`整形`或者是一个指向对象或者函数类型的`指针`或者`(左值)引用`\n绑定到`非类型整数参数`的实参必须是一个常量表达式.\n绑定到`指针`或者`引用非类型模板参数`的实参必须具有静态的生存期\n\n静态内存用来保存`局部static对象`, `类static数据成员`和`定义于任何函数之外的变量`\n栈内存用来保存定义在函数内的非static对象.\n分配在静态内存和栈内存的由编译器自动创建和销毁\n\n堆 用来存储动态分配的对象\n\n\n编译器遇到一个模板类型定义的时候并不会生成代码, 而是实例化出一个特定版本的时候才会实例化\n\n\n**使用类的类型成员**\n\n```c++\ntemplate <typename T>\n\nT::size_type* p;\n```\n默认情况下, C++语言假定通过域运算符访问名字而不是类型.\n如果想要使用模板类型参数(T)的类型成员(size_type) 必须使用`typename`而不是`class`\n\n\n**默认模板实参**\n\n```c++\ntemplate <typename T, typename F = less<T>>\nint compare(const T& v1, const T& v2, F f = f())\n{\n\tif (f(v1, v2)) return -1;\n\tif (f(v2, v1)) return 1;\n\treturn 0;\n}\n```\n\n# 第四部分 高级主题\n\ntuple这里看了, 例子写了总感觉实用性不是很大? 或许可以用在便捷处理输入参数?\n\nbiset感觉还是有点用\n```c++\nstd::bitset<32> b;\n\n// 以下位不足 高位都补0\n\nunsigned long long u = ULLONG_MAX;\nstd::bitset<32> bu(u);\n\nstd::string s1 = \"10101010101010\";\nstd::bitset<32> bs1(s1);\nstd::string s2 = \"ababaabbababb\";\n// std::bitset<32> bs2(s2); std::invalid_argument\n// a instand 0 b instand 1\nstd::bitset<32> bs2(s2, 0, 32, 'a', 'b');\n\nbu.any(); // 存在 置位(1) 的二进制位吗\nbu.all(); // 所有位都置位了吗\nbu.none(); // b中不存在置位的二进制位吗\nbu.count(); // 置位数目\nbu.size(); // 数目\n\nbu.test(1); // 位置1是置位的返回true 否则返回false\nbu.set(1, true); // 将1位 置 true->1 false->0\nbu.reset(1); // 将1位复位 置0\nbu.reset(); // 将所有位复位 置0\n\nbu.flip(1); // 1位取反\nbu.flip(); // 全部取反\nbu[1].flip();\n\nbu[1]; // 1位 1->true 0->false\n\nbu.to_ulong();\nbu.to_ullong();\n\nbu.to_string('a', 'b'); // 0->a 1->b\n```\n\n","slug":"读书记录80-CPPPrimer","published":1,"updated":"2020-12-05T04:16:08.530Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg7b0045f8un0o4r89tp","content":"<h1 id=\"TOOD\"><a href=\"#TOOD\" class=\"headerlink\" title=\"TOOD\"></a>TOOD</h1><p>explicit 参见7.5.4节 265</p>\n<p>运算符优先级………..</p>\n<h1 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h1><p><strong>char 在默认情况下, 既不是有符号. 也不是无符号.</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a; <span class=\"comment\">// 此时a可能是 signed char 也可能是 unsigned char 可能会在不同系统之前产生错误</span></span><br><span class=\"line\"><span class=\"comment\">// 可以显式声明, 来确保不会出现此错误</span></span><br><span class=\"line\"><span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> a;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> a;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输入</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">cin</span>.getline(name, <span class=\"number\">10</span>); <span class=\"comment\">// 可以读取换行符, 但不保存</span></span><br><span class=\"line\"><span class=\"built_in\">cin</span>.<span class=\"built_in\">get</span>(name, <span class=\"number\">10</span>); <span class=\"comment\">// 不读取换行符, 可能导致get到换行符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 空行和超出长度问题 将在后面说明</span></span><br></pre></td></tr></table></figure>\n<p>运算符优先级<br><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=59a3e1017d3e6709aa0d4dad5aaef458/63d9f2d3572c11df57c9a205612762d0f703c2f8.jpg\" alt=\"\"></p>\n<p><strong>基础的数组</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 下方由于 new 只是返回一个地址所以用 int* 接收 </span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* b = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; a[<span class=\"number\">0</span>] &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; *(a + <span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p><strong>对指针解引用</strong><br>第一印象是 解除引用, 然而并不是</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\"*\"的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。也就是说，解引用是返回内存地址中保存的值。</span></span><br><span class=\"line\"><span class=\"comment\">比如int a=10; int *p=&amp;a;</span></span><br><span class=\"line\"><span class=\"comment\">cout&lt;&lt;*p&lt;&lt;endl; 输出a的值，就是解引用操作。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n<p><strong>常用 宏</strong><br>| 定义 | 说明 |<br>| —– | —– |<br>| <code>__FILE__</code> | 存放文件名的字符串字面值 |<br>| <code>__LINE__</code> | 存放当前行号的整形字面值 |<br>| <code>__TIME__</code> | 存放文件编译时间的字符串字面量 |<br>| <code>__DATE__</code> | 存放文件编译日期的字符串字面值 |<br>| <code>__VA_ARGS__</code> | 用来接受函数参数中<code>...</code>, 类似printf函数, 这个宏只能在宏中使用 |</p>\n<h1 id=\"第一部分-基础知识\"><a href=\"#第一部分-基础知识\" class=\"headerlink\" title=\"第一部分 基础知识\"></a>第一部分 基础知识</h1><h2 id=\"第二章-变量和基本类型\"><a href=\"#第二章-变量和基本类型\" class=\"headerlink\" title=\"第二章 变量和基本类型\"></a>第二章 变量和基本类型</h2><h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><p><strong>2.2 与钱相关的数据存储 使用的类型</strong><br>银行相关钱相关的数据 保存 使用整形, 不太可能使用浮点数. 浮点数运算可能会出现误差<br>使用<code>1</code>代表<code>1RMB</code> 或者使用<code>1</code>代表<code>0.01RMB</code></p>\n<p><strong>2.9 解释下列定义 对于非法说出错在哪里</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; <span class=\"keyword\">int</span> input_value; <span class=\"comment\">// error: expected primary-expression before ‘int’</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> i1 = &#123;<span class=\"number\">3.14</span>&#125;;<span class=\"comment\">// narrowing conversion of ‘3.1400000000000001e+0’ from ‘double’ to ‘int’ inside &#123; &#125; [-Wnarrowing]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> salary = wage = <span class=\"number\">9999.99</span>;<span class=\"comment\">// error: ‘wage’ was not declared in this scope 如果定义wage则语句不报错</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> i2 = <span class=\"number\">3.14</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2.10 下列变量的初始值是什么</strong></p>\n<p>内置类型变量未被显示初始化  函数体之外初始化为0  函数体内是未被定义的<br>类    一般都拥有默认的初始化方式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> g_str; <span class=\"comment\">// 全局变量 且拥有默认初始化方式 为空字符串</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> g_int; <span class=\"comment\">// \t全局变量 初值为0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> local_int; <span class=\"comment\">// 局部变量 未定义</span></span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> local_str; <span class=\"comment\">// 拥有默认初始化方式 空字符串</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2.14 下面代码输出什么</strong><br>起初一看 以为会是循环到溢出 直接就把代码码了下来运行 发现是正常的.<br>就算for中 <code>int i = 0</code>改为<code>i = 0</code>依然不会溢出<br>for的i覆盖了外面的i</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">100</span>, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sum += i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; <span class=\"comment\">//$ 100 45</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出<del>~</del></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, &amp;ri = i;</span><br><span class=\"line\">    i = <span class=\"number\">5</span>;</span><br><span class=\"line\">    ri = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; ri &lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; <span class=\"comment\">//$ 10 10</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h3><p>一个形如42的值被称为<code>字面值常量(literal)</code>, 这样的值你一看到(面), 就知道是多少</p>\n<p>scope 作用域</p>\n<h3 id=\"无符号\"><a href=\"#无符号\" class=\"headerlink\" title=\"无符号\"></a>无符号</h3><p><strong>unsigned int和int运算的时候 自动转换为unsigned</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">-11</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; <span class=\"comment\">//$ 4294967295</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>警惕for循环中的 无符号类型</strong><br>size_t</p>\n<h3 id=\"声明定义初始化赋值\"><a href=\"#声明定义初始化赋值\" class=\"headerlink\" title=\"声明定义初始化赋值\"></a>声明定义初始化赋值</h3><p><strong>声明</strong><br>声明不是定义, 可以多次声明<br>指明变量的type和name.<br>对于变量的声明需要使用<code>extern</code>关键字, 如果使用了<code>extern</code>关键字的同时初始化就成了定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i; <span class=\"comment\">// 声明并定义 未初始化</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> a; <span class=\"comment\">// 声明</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>; <span class=\"comment\">// 定义 声明 初始化</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>定义</strong><br>声明并定义, 只能定义一次<br>定义的时候需要指定type和name. 申请空间, 可能进行初始化.</p>\n<p><strong>初始化 赋值</strong><br>初始化 不是赋值<br>初始化是创建变量时 赋予其一个初始值<br>赋值是擦除当前的值 赋予新的值</p>\n<p><strong>变量类型选择</strong><br>数值范围超过<code>int</code> 建议使用<code>long long</code>, <code>long</code>的长度仅是大于等于<code>int</code><br>char类型可能是 <code>signed</code> 还可能是<code>unsigned</code> 如果针对范围有特殊要求 应该注明是否有无符号<br>浮点运算建议使用double float经常精度不够, 然而两者运算效率却相差无几. <code>long double</code>反而绝大多数情况用不到</p>\n<h3 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h3><p>const变量必须被初始化</p>\n<p>所谓指向常量的引用或指针, 不过是指针或引用自以为是罢了, 他们觉得自己指向了常量, 所以自觉不去修改</p>\n<p>顶层const: 表示指针本身是常量<br>底层const: 表示指针指向是一个常量<br>指针本身是一个对象, 他可以指向另一个对象. 因此, 指针本身是不是常量, 以及指针所向是不是一个常量就是两个独立的问题.</p>\n<p>执行拷贝的时候, 常量是顶层const还是底层const区别明显, 顶层const可以视为不见<br>然而底层const的限制不能忽视, 拷入和拷出对象必须具有相同的底层const资格</p>\n<p><strong>指针常量和类型别名</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span>* pstring;</span><br><span class=\"line\"><span class=\"keyword\">const</span> pstring cstr = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p>这里pstring是指向char的指针 const pstring是指向char的常量指针 指针指向不能变<br>而不是简单地将pstring替换掉</p>\n<h3 id=\"constexpr\"><a href=\"#constexpr\" class=\"headerlink\" title=\"constexpr\"></a>constexpr</h3><p>在一个复杂系统中, 很难分辨一个初始值到底是不是常量表达式.<br>当然可以定义一个const变量 并把初始值设定为我们认为的常量表达式, 然而实际依然有非常量表达式的情况</p>\n<p>C++11标准 将变量声明为constexpr由编译器来验证变量是否是一个常量表达式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> mm = <span class=\"number\">20</span>; <span class=\"comment\">// 20是常量表达式</span></span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> yy = mm + <span class=\"number\">1</span>; <span class=\"comment\">// mf + 1是常量表达式</span></span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> sz = <span class=\"built_in\">size</span>(); <span class=\"comment\">// 当size是一个constexpr函数时才是正确的声明语句</span></span><br></pre></td></tr></table></figure>\n\n<p>指针和引用都能定义成constexpr, 但初始值受到严格限制.<br>constexpr指针的初始值必须是nullptr或者0 或者存储于某个固定地址中的对象(位于所有函数体之外)<br>constexpr引用能绑定到 某个固定地址中的对象</p>\n<p><strong>decltype和引用</strong><br><code>decltype((i)) d</code> 双层括号是引用<br><code>decltype(i) d</code>单层括号只有i是引用的时候 d才是引用</p>\n<h2 id=\"第三章-字符串-向量和数组\"><a href=\"#第三章-字符串-向量和数组\" class=\"headerlink\" title=\"第三章 字符串 向量和数组\"></a>第三章 字符串 向量和数组</h2><h3 id=\"习题-1\"><a href=\"#习题-1\" class=\"headerlink\" title=\"习题\"></a>习题</h3><p><strong>3.34</strong><br>p1和p2指向同一数组中的元素, 则下面程序的功能是什么? 什么情况下程序是非法的?<br>p1 += p2 - p1;<br>将p1移动到p2的位置  不会非法……….</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"{} = ()\"></a>{} = ()</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> a = <span class=\"string\">\"cccc\"</span>;  <span class=\"comment\">// 只有一个参数值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"string\">'c'</span>)</span></span>; <span class=\"comment\">// 拥有两个参数值 10和'c'</span></span><br></pre></td></tr></table></figure>\n\n<p>使用=, 进行拷贝初始化 只能提供一个初始值<br>使用(), 进行直接初始化, 可以提供多个初始值进行初始化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> a1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">a2</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">// temp.cpp:4:12: error: expected identifier before numeric constant</span></span><br><span class=\"line\">  <span class=\"comment\">// int a2(10);</span></span><br><span class=\"line\">  <span class=\"comment\">// temp.cpp:4:12: error: expected ‘,’ or ‘...’ before numeric constant</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> a3&#123;<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类内初始值 不能使用小括号</p>\n<p>列表初始化只能放在花括号中 </p>\n<h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><p>vector中不能保存引用, 因为使用引用就必须初始化.</p>\n<p>设想, 你设置了vector包含十个元素, 这十个空间就必须被初始化,<br>然而引用必须要绑定到具体的对象上, 此时却没有对象进行绑定</p>\n<p>再者如果容器复制的时候 引用怎么复制?</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">v1</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>; <span class=\"comment\">// 10个元素, 全为0</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v2&#123;<span class=\"number\">10</span>&#125;; <span class=\"comment\">// 一个元素, 为10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">v3</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">1</span>)</span></span>; <span class=\"comment\">// 10个元素, 全为1</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v4&#123;<span class=\"number\">10</span>, <span class=\"number\">1</span>&#125;; <span class=\"comment\">// 两个元素, 10和1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -----------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v5&#123;<span class=\"string\">\"hi\"</span>&#125;; <span class=\"comment\">// 列表初始化 有一个元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">v6</span><span class=\"params\">(<span class=\"string\">\"hi\"</span>)</span></span>; <span class=\"comment\">// 错误不能使用字符串字面值构建vector元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v7&#123;<span class=\"number\">10</span>&#125;; <span class=\"comment\">// 10个默认初始化的对象</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v8&#123;<span class=\"number\">10</span>, <span class=\"string\">\"hi\"</span>&#125;; <span class=\"comment\">// 十个值为\"hi\"的元素</span></span><br></pre></td></tr></table></figure>\n\n<p>因为不能使用int来初始化string对象, 列表初始化要求列表值类型与尖括号种类型相同<br>v7和v8并不是列表初始化, 而是转去尝试用默认值(默认值????)初始化</p>\n<p>这里感觉有点?去看了下英文原版<br>the compiler looks for<br>other ways to initialize the object from the given values.</p>\n<p><strong>迭代器</strong><br>使用的时候注意迭代器失效, </p>\n<h3 id=\"数组和指针\"><a href=\"#数组和指针\" class=\"headerlink\" title=\"数组和指针\"></a>数组和指针</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (*array_ptr)[<span class=\"number\">10</span>] = &amp;arr; <span class=\"comment\">// 指向十个整数的数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> (&amp;array_ref)[<span class=\"number\">10</span>] = arr; <span class=\"comment\">// 十个整数数组的引用</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">a1</span><span class=\"params\">(a)</span></span>; <span class=\"comment\">// a1是指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(a) a2; <span class=\"comment\">//a2是有八个元素的数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>* b = <span class=\"built_in\">std</span>::<span class=\"built_in\">begin</span>(a); <span class=\"comment\">// 指向首元素</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* c = <span class=\"built_in\">std</span>::<span class=\"built_in\">end</span>(a); <span class=\"comment\">// 指向最后一个元素的后一位</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ptrdiff_t</span> d = c - b; <span class=\"comment\">// ptrdiff_t 定义在cstddef中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>* p = &amp;a[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> k = p[<span class=\"number\">-1</span>];<span class=\"comment\">// 内置下标运算符所用的索引值不是无符号型 可以为负</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第四章-表达式\"><a href=\"#第四章-表达式\" class=\"headerlink\" title=\"第四章 表达式\"></a>第四章 表达式</h2><p>当一个对象被用作右值的时候, 使用的是对象的值(内容)<br>当一个对象被用做左值的时候, 使用的是对象的身份(在内存中的位置)</p>\n<p>如果表达式的求值结果是左值, decltype作用于该表达式得到一个引用类型.</p>\n<p><code>int* p</code><br>解引用运算符生成左值 <code>decltype(*p)</code>得到的是<code>int&amp;</code><br>取地址运算符生成右值 <code>decltype(&amp;p)</code>的结果是<code>int**</code></p>\n<p>大多数运算符没有规定按照什么顺序求值<br><code>int i = f1() * f2()</code><br>这两函数的调用顺序是未定义的</p>\n<p>只有四种运算符规定了运算对象的求值顺序<br>短路求值<br><code>&amp;&amp;</code> 从左到右<br><code>||</code> 从左到右</p>\n<p><code>?:</code><br><code>,</code> 逗号运算符 从左到右 首先求值左侧然后丢掉结果 真正返回的是右侧结果</p>\n<p>书写表达式的建议</p>\n<ol>\n<li>拿不准的时候最好使用括号来组合表达式. 括号不香吗?</li>\n<li>如果改变了某个运算对象的值, 在表达使得其他地方就不要再使用这个运算对象</li>\n</ol>\n<p><code>(-m) / n</code> 和 <code>m / (-n)</code> 等于 <code>-(m / n)</code><br><code>m % (-n)</code> 等于 <code>m % n</code><br><code>(-m) % n</code> 等于 <code>-(m % n)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ival, jval</span><br><span class=\"line\">ival = jval = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p>赋值运算符右结合, 所以右侧的<code>jval = 0</code>是左侧赋值运算符的右侧运算对象<br>又因为赋值运算符返回的是其左侧运算对象, 所以右侧赋值运算符的结果(Jval)赋给了ival</p>\n<p>赋值运算符的优先级低于关系运算符, 所以条件语句中, 赋值部分应该加上括号</p>\n<p><code>sizeof *p</code><br>sizeof 不会实际求运算对象的值, 所以即使p是无效指针也不会有什么影响<br>sizeof对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小<br>sizeof对string对象和vector对象 只返回该类型固定部分的大小, 不会计算对象中元素占用了多少空间<br>sizeof(string) 与string长度无关, 不同的编译器有不同的具体实现<br><a href=\"http://www.cplusplus.com/forum/general/218642/\" target=\"_blank\" rel=\"noopener\">http://www.cplusplus.com/forum/general/218642/</a></p>\n<p>sizeof(vector<int>) 返回24字节 64位系统指针8字节 三个指针24字节 (头指针, 尾指针, 当前容量尾指针)<br>pointer <em>M</em>start;<br>pointer <em>M</em>finish;<br>pointer <em>M</em>end_of_storage;</p>\n<p>非内置类型基本都含有指针, 指向堆中分配的内存, 所以存在存储任意大小都会返回固定sizeof</p>\n<p><code>const-name&lt;type&gt;(expr)</code><br>命名显式强制类型转换</p>\n<p>static_cast 静态类型转换 用于替代隐式类型转换</p>\n<ul>\n<li>子类向父类转换 安全</li>\n<li>父类向子类转换 无动态类型检查 不安全</li>\n<li>基本数据类型转换</li>\n<li>指针类型转换</li>\n<li>将任何其他类型转换为void类型</li>\n</ul>\n<p>任何具有明确定义的类型转换, 只要底层不包含const, 都能使用. 值类型转换以及指针类型转换<br>如果类型不兼容, 则编译阶段报错.</p>\n<p>dynamic_cast<br>运行时转换, 如果转换失败返回null. type和expr必须同是类指针或者类引用<br>用于父类向子类的转换</p>\n<p>const_cast<br>增加或删除运算对象的底层const, 如果对象本身不是一个常量 获取写权限是合法的, 如果是常量则会产生未定义后果.</p>\n<p>reinterpret_cast<br>为运算对象的位模式提供较低层次上的重新解析<br><a href=\"https://zhuanlan.zhihu.com/p/33040213\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/33040213</a></p>\n<h2 id=\"第五章-语句\"><a href=\"#第五章-语句\" class=\"headerlink\" title=\"第五章 语句\"></a>第五章 语句</h2><p>即使不准备在default标签下做任何工作, 定义一个default标签也是有作用的. 可以告知读者,<br>我们已经考虑到了默认情况, 只是目前什么也没做</p>\n<p><strong>switch-case关于变量定义的问题</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"literal\">true</span>:</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> v1;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> v2 &#123;&#125;;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> v3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> v4;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"literal\">false</span>:</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v1 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v2 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v3 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v4 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译报错 注意没有   v4  控制流绕过了初始化变量的语句</span></span><br><span class=\"line\"></span><br><span class=\"line\">switch-case.cpp: In function ‘int main()’:</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">16</span>:<span class=\"number\">14</span>: error: jump to <span class=\"keyword\">case</span> label [-fpermissive]</span><br><span class=\"line\">         <span class=\"keyword\">case</span> <span class=\"literal\">false</span>:</span><br><span class=\"line\">              ^~~~~</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">12</span>:<span class=\"number\">17</span>: note:   crosses initialization of ‘<span class=\"keyword\">int</span> v3’</span><br><span class=\"line\">             <span class=\"keyword\">int</span> v3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">                 ^~</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">11</span>:<span class=\"number\">25</span>: note:   crosses initialization of ‘<span class=\"built_in\">std</span>::__cxx11::<span class=\"built_in\">string</span> v2’</span><br><span class=\"line\">             <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> v2 &#123;&#125;;</span><br><span class=\"line\">                         ^~</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">10</span>:<span class=\"number\">25</span>: note:   crosses initialization of ‘<span class=\"built_in\">std</span>::__cxx11::<span class=\"built_in\">string</span> v1’</span><br><span class=\"line\">             <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> v1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 两个case语句加上括号后报错变为</span></span><br><span class=\"line\">switch-case.cpp: In function ‘int main()’:</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">18</span>:<span class=\"number\">26</span>: error: ‘v1’ was <span class=\"keyword\">not</span> declared in <span class=\"keyword\">this</span> scope</span><br><span class=\"line\">             <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v1 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                          ^~</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">19</span>:<span class=\"number\">26</span>: error: ‘v2’ was <span class=\"keyword\">not</span> declared in <span class=\"keyword\">this</span> scope</span><br><span class=\"line\">             <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v2 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                          ^~</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">20</span>:<span class=\"number\">26</span>: error: ‘v3’ was <span class=\"keyword\">not</span> declared in <span class=\"keyword\">this</span> scope</span><br><span class=\"line\">             <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v3 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                          ^~</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">21</span>:<span class=\"number\">26</span>: error: ‘v4’ was <span class=\"keyword\">not</span> declared in <span class=\"keyword\">this</span> scope</span><br><span class=\"line\">             <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v4 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程</p>\n<p>牢记for语句头中定义的对象只在for循环体内可见.<del>~</del></p>\n<p><strong>break continue</strong></p>\n<p>break负责终止离他最近的while, do while, for或者switch. 并从这些语句后的第一条开始继续执行</p>\n<p>continue语句终止最近的循环中当前迭代, 并立即开始下一次迭代</p>\n<p><strong>异常处理</strong><br>代码可以使用throw来抛出异常<br>大部分可以指定msg来初始化异常<br>throw exception_type(“msg”)<br>表中exception不能指定msg, 来初始化, 除此外表中其他都需要msg初始</p>\n<p>位于<code>stdexcept</code>头文件中</p>\n<table>\n<thead>\n<tr>\n<th>错误名称</th>\n<th>对应原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>exception</td>\n<td>最常见的问题</td>\n</tr>\n<tr>\n<td>runtime_error</td>\n<td>只有运行的时候才能查到错误</td>\n</tr>\n<tr>\n<td>range_error</td>\n<td>运行时错误: 超范围</td>\n</tr>\n<tr>\n<td>overflow_error</td>\n<td>运行时错误: 上溢</td>\n</tr>\n<tr>\n<td>underflow_error</td>\n<td>运行时错误: 下溢</td>\n</tr>\n<tr>\n<td>logic_error</td>\n<td>程序逻辑错误</td>\n</tr>\n<tr>\n<td>domain_error</td>\n<td>程序逻辑错误: 参数对应的结果不存在</td>\n</tr>\n<tr>\n<td>invalid_argument</td>\n<td>程序逻辑错误: 无效参数</td>\n</tr>\n<tr>\n<td>length_error</td>\n<td>程序逻辑错误: 试图创建一个超出该类型最大长度的对象  如vector::reserve</td>\n</tr>\n<tr>\n<td>out_of_range</td>\n<td>程序逻辑错误: 超范围</td>\n</tr>\n</tbody></table>\n<h2 id=\"第六章-函数\"><a href=\"#第六章-函数\" class=\"headerlink\" title=\"第六章 函数\"></a>第六章 函数</h2><p>形参名是可选的, 但是由于无法使用未命名的形参, 所以一般都有一个名字.</p>\n<p>自动对象: 只存在于块执行期间的对象<br>局部静态对象: 只在<code>第一次</code>经过对象语句时进行初始化, 直到程序终止才被销毁.</p>\n<p>数组引用形参</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> (&amp;arr)[<span class=\"number\">10</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> elem : arr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; elem &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数返回引用得到左值<br>返回其他类型得到右值</p>\n<p>p205页 还真没见过 返回数组指针这种形式</p>\n<h2 id=\"第七章-类\"><a href=\"#第七章-类\" class=\"headerlink\" title=\"第七章 类\"></a>第七章 类</h2><h3 id=\"习题-2\"><a href=\"#习题-2\" class=\"headerlink\" title=\"习题\"></a>习题</h3><p><strong>7.25 Screen能安全的依赖于拷贝和赋值操作的默认版本吗</strong><br>Screen中只有内置类型和string, 如果其含有动态管理的内存则不行<br>当类需要分配类对象以外的资源时, 默认版本经常会失效</p>\n<p>默认构造函数, 会造成 内置类型和复合类型成员 默认初始化后 值未定义</p>\n<p>关于未定义这点我去写了小段程序看了下, 也搜了一下</p>\n<p><a href=\"https://stackoverflow.com/a/2218275/11581349\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/a/2218275/11581349</a></p>\n<p>It will be automatically initialized if</p>\n<ul>\n<li>it’s a class/struct instance in which the default constructor initializes all primitive types; like MyClass instance; 有默认构造函数类或者结构体, 并且默认构造函数初始化所有内置类型</li>\n<li>you use array initializer syntax, e.g. int a[10] = {} (all zeroed) or int a[10] = {1,2}; (all zeroed except the first two items: a[0] == 1 and a[1] == 2) 使用了大括号初始化</li>\n<li>same applies to non-aggregate classes/structs, e.g. MyClass instance = {}; (more information on this can be found here) 同大括号初始化</li>\n<li>it’s a global/extern variable 全局或者extern类型</li>\n<li>the variable is defined static (no matter if inside a function or in global/namespace scope) 变量被声明为static</li>\n</ul>\n<p>默认初始化发生的情况</p>\n<ul>\n<li>不使用任何初始值定义一个非静态变量或者数组</li>\n<li>一个类本身含有类类型的成员且使用合成的默认构造函数</li>\n<li>类类型的成员没有在构造函数初始值列表中显示地初始化时</li>\n</ul>\n<p>值初始化</p>\n<ul>\n<li>数组初始化提供的初始值数量小于数组大小</li>\n<li>不使用初始值定义一个局部静态变量</li>\n<li>书写T()表达式 显示地请求值初始化</li>\n</ul>\n<p>mutable可变数据成员, 从远不会是const.  可以在const成员函数中对其进行修改</p>\n<p>类的GetBalance函数的函数体在整个Account类可见之后才被处理.</p>\n<p>编译器看到GetBalance的声明后 开始从类内(<strong>类内会从使用Money前查找</strong>)到类外寻找Money声明, 然后函数的返回值和bal成员变量的类型为double, 接着类可见之后处理函数体 函数会返回double类型的成员变量bal</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">double</span> Money;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> balance = <span class=\"string\">\"string\"</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// typedef std::string Money; 这里则不会报错</span></span><br><span class=\"line\">    Account() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    ~Account() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"function\">Money <span class=\"title\">GetBalance</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> balance;  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// typedef std::string Money; 会报错 因为由于GetBalance函数已经使用了外部的Money</span></span><br><span class=\"line\">    Money balance;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Account account;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; account.GetBalance(); <span class=\"comment\">// $ 0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Foo(<span class=\"keyword\">int</span> val):</span><br><span class=\"line\">        bar1(val),</span><br><span class=\"line\">        bar2(bar1)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bar1; <span class=\"comment\">// 更改两个顺序  将会导致先使用 bar1初始化bar2 然后使用val初始化bar1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bar2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在我看了一些项目后使用的上面的写法, 然而这种写法却不合适 除非你严格按照变量顺序写.</p>\n<p>如果你将bar2和bar1的顺序不小心更换了, 难以排查的bug</p>\n<p><strong>使用默认构造函数声明对象 需要去掉对象名后的空括号对</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Foo <span class=\"title\">foo</span><span class=\"params\">()</span></span>; <span class=\"comment\">// 错误</span></span><br><span class=\"line\">Foo foo;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"隐式的类类型转换\"><a href=\"#隐式的类类型转换\" class=\"headerlink\" title=\"隐式的类类型转换\"></a>隐式的类类型转换</h3><p>如果构造函数只接受一个实参, 则它实际上定义了转换为此类类型的隐式转换机制 – 称这种构造函数为<strong>转换构造函数</strong></p>\n<p>Foo含有一个只有string类型的构造函数. 当一个函数的参数是Foo类型时. 你可以将string类型直接传递给这个函数. 会自动从string类型构造成Foo类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Value(string val); 可以加上explicit防止隐式类型转换</span></span><br><span class=\"line\"><span class=\"comment\">// void Add(Value val);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> val1 = <span class=\"string\">\"val1\"</span>;</span><br><span class=\"line\">foo.Add(val1); <span class=\"comment\">// 正确 隐式转换成Value</span></span><br><span class=\"line\">foo.Add(<span class=\"string\">\"val2\"</span>); <span class=\"comment\">// 错误 只能进行一步转换  需要从\"val2\"到string再到Value</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"聚合类-字面值常量类\"><a href=\"#聚合类-字面值常量类\" class=\"headerlink\" title=\"聚合类 字面值常量类\"></a>聚合类 字面值常量类</h3><p>聚合类</p>\n<ul>\n<li>所有成员都是public</li>\n<li>没有定义任何构造函数</li>\n<li>没有类内初始值</li>\n<li>没有基类也没有virtual函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> str;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> val;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tFoo foo = &#123;<span class=\"string\">\"1\"</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>字面值常量类</p>\n<ul>\n<li>数据成员都是字面值类型的聚合类</li>\n</ul>\n<p>如果一个类不是聚合类, 但是符合以下要求也是字面值类型常量类</p>\n<ul>\n<li>数据成员必须是字面值类型</li>\n<li>类必须含有一个constexpr构造函数</li>\n<li>如果一个数据成员含有类内初始值, 则初始值必须是一条常量表达式. 如果成员属于某种类类型, 则初始值必须使用成员自己的constexpr构造函数</li>\n<li>类必须使用默认析构函数</li>\n</ul>\n<h1 id=\"第二部分-cpp标准库\"><a href=\"#第二部分-cpp标准库\" class=\"headerlink\" title=\"第二部分 cpp标准库\"></a>第二部分 cpp标准库</h1><h2 id=\"第八章-IO库\"><a href=\"#第八章-IO库\" class=\"headerlink\" title=\"第八章 IO库\"></a>第八章 IO库</h2><p>想到了遇到过的<code>while(std::cin &gt;&gt; xx)</code>究竟是如何判断的呢? <code>&gt;&gt;</code>返回的对象是<code>std::cin</code>如何将其转换为<code>bool</code>?</p>\n<p>重载运算符</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">explicit</span> __CLR_OR_THIS_CALL <span class=\"keyword\">operator</span> <span class=\"title\">bool</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !fail();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">_NODISCARD <span class=\"keyword\">bool</span> __CLR_OR_THIS_CALL <span class=\"keyword\">operator</span>!() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fail();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"keyword\">operator</span> <span class=\"title\">bool</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"operator *\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"operator !\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tFoo foo;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (foo); <span class=\"comment\">// $ operator *</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!foo);<span class=\"comment\">// $ operator !</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>endl  换行 刷新缓冲区<br>flush 刷新缓冲区<br>ends  空字符 刷新缓冲区</p>\n<p>unitbuf 所有输出操作后都会立即刷新缓冲区<br>nounitbuf 恢复正常的缓冲方式</p>\n<h2 id=\"第九章-顺序容器\"><a href=\"#第九章-顺序容器\" class=\"headerlink\" title=\"第九章 顺序容器\"></a>第九章 顺序容器</h2><h3 id=\"习题-3\"><a href=\"#习题-3\" class=\"headerlink\" title=\"习题\"></a>习题</h3><p><strong>9.6 下面的程序有何错误 你应该如何修改它?</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; lst1;</span><br><span class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator iter1 = lst1.<span class=\"built_in\">begin</span>(),</span><br><span class=\"line\">iter2 = lst1.<span class=\"built_in\">end</span>();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iter1 &lt; iter2)</span><br></pre></td></tr></table></figure>\n<p>将<code>while (iter1 &lt; iter2)</code> 改成<code>while(iter1 != iter2)</code><br>迭代器是指向元素的指针, 对于list来说比较元素指针大小无法判断<br>@@@@</p>\n<p><strong>9.12 对于接受一个容器创建其拷贝的构造函数 和 接收两个迭代器创建拷贝的构造函数之间的不同</strong></p>\n<p><strong>创建拷贝</strong>-要求容器类型和元素类型都相同<br><strong>接收两个迭代器</strong>-元素类型能够相互转化即可</p>\n<h3 id=\"函数说明\"><a href=\"#函数说明\" class=\"headerlink\" title=\"函数说明\"></a>函数说明</h3><p>assign函数 仅顺序容器</p>\n<ul>\n<li>用指定元素的拷贝 替换左侧容器中的所有元素</li>\n</ul>\n<p>swap函数</p>\n<ul>\n<li>只会真正交换array的元素 与长度有关</li>\n<li>其他容器会交换内部的数据结构 常数时间完成</li>\n</ul>\n<p>除了string指向容器的迭代器 引用和指针在swap操作之后都不会失效 仍指向swap操作前的元素,<br>但是这些元素已经属于不同的容器了</p>\n<p>关系运算符</p>\n<ul>\n<li>两个容器具有相同的大小 且所有元素两两对应相等 这两个容器相等 否则不等</li>\n<li>如果两个容器大小不同, 但较小的容器中每个元素都等于较大容器中对应元素 则较小容器 &gt; 较大容器</li>\n<li>比较结果取决于第一个不相等的元素的比较结果 类似 compare</li>\n</ul>\n<p>容器的运算符 非迭代器<br>== != 运算符 所有容器都支持<br>&lt; &lt;= &gt; &gt;= 运算符 无序关联容器不支持</p>\n<p>size_type 无符号整数 足够保存此种容器类型最大可能容器的大小<br>difference_type 带符号整数类型 足够保存两个迭代器之间的距离<br>value_type 元素类型</p>\n<p>除了array之外其他容器的默认构造函数会创建一个指定类型的<code>空容器</code></p>\n<p>只有<code>顺序容器</code>的<code>构造函数</code>才接<code>受大小参数</code> 关联容器并不支持</p>\n<p>如果元素类型是内置类型或者具有默认的构造函数的类类型,可以只为构造函数提供一个容器大小的参数<br>如果元素类型没有默认构造函数 除了容器大小参数 还必须指定一个显示的元素初始值</p>\n<p>只有支持随机访问容器的迭代器才支持<code>operator&lt;</code>, list只能使用<code>=</code>来判断迭代器</p>\n<p>成员访问函数<code>front</code>,<code>back</code>,<code>下标</code>,<code>at</code>访问返回的都是引用. 如果容器是一个const对象 则返回值是const的引用 </p>\n<p>大多数会使迭代器失效的函数如erase<code>会在调用后返回删除的后一个元素位置的迭代器</code>, 使用返回值替换原来的迭代器可以在删除元素的情况下遍历所有元素</p>\n<p>不要保存end返回的迭代器, 添加删除vector或string元素后都会失效. <code>while (x != v.end())</code>或者是<code>for(; x != v.end();)</code></p>\n<p>向容器中添加元素</p>\n<ul>\n<li>目标是vector或string 且存储空间被重新分配, 则指向容器的迭代器指针引用都会失效. 如果存储空间没有被重新分配, 则插入位置后的三者都会失效</li>\n<li>目标是deque 插入到除首尾之外的任何位置都会使三者失效 首尾添加元素则迭代器失效 但是指向存在元素的引用和指针不会失效</li>\n<li>对于list和forward_list 三者仍然有效</li>\n</ul>\n<p>从容器中删除元素</p>\n<ul>\n<li>vector和string 被删元素之前的三者仍有效</li>\n<li>list和forward_list 三者仍有效</li>\n<li>deque 首尾之外的任何位置删除元素 指向被删除元素外<code>其他任何元素</code>的三者也会失效 如果删除尾元素则<code>尾后迭代器</code>失效 其他迭代器和指针不受影响</li>\n</ul>\n<h2 id=\"第十章-泛型算法\"><a href=\"#第十章-泛型算法\" class=\"headerlink\" title=\"第十章 泛型算法\"></a>第十章 泛型算法</h2><p>迭代器使得算法不依赖于容器, 可以解引用迭代器得到值, 也可以移动访问其他元素</p>\n<p>不过迭代器依赖于元素类型 因为会使用如<code>==</code> <code>&lt;</code>之类的操作符 作用在元素上得到结果</p>\n<p>小小accumulate也有很多细节问题</p>\n<ul>\n<li>函数的返回值类型与第三个参数相同, 需要序列中元素能够转换成第三个参数的类型</li>\n<li>遍历元素的结果是加在第三个参数上的</li>\n</ul>\n<p>一个lambad只有在其捕获列表中捕获一个他所在函数中的局部变量, 才能在函数体中使用该变量.</p>\n<p>捕获列表只用于局部非static变量, lambda可以直接使用局部static变量和他所在函数之外声明的名字</p>\n<p><code>值传递</code>的变量在lambda创建的时候进行拷贝, 所以随后的修改不会影响到lambda内的值</p>\n<p><code>引用捕获</code>的则需要确保在lambda执行期间, 被引用的变量时存在的</p>\n<p>| 形式 | 说明 |<br>| <code>[]</code> | 空捕获列表. lambda不能使用所在函数变量 |<br>| <code>[names]</code> | 逗号分隔的所在函数的局部变量列表. 默认使用拷贝, 如果变量名前有&amp;则使用引用 |<br>| <code>[&amp;]</code> | 隐式捕获列表, 引用捕获 |<br>| <code>[=]</code> | 隐式捕获列表, 值捕获 |<br>| <code>[&amp;, names]</code> | 引用捕获, names列表使用值捕获 |<br>| <code>[=, names]</code> | 值捕获, names列表使用引用捕获 |</p>\n<p>谓词 - 一个可调用的表达式, 其返回结果是一个能用做条件的值</p>\n<ul>\n<li>一元谓词 只接收单一参数</li>\n<li>二元谓词 有两个参数</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>find_if</td>\n<td></td>\n</tr>\n<tr>\n<td>for_each</td>\n<td></td>\n</tr>\n<tr>\n<td>bind</td>\n<td>参数绑定, 可以进行诸如 一二元谓词互换的操作 参数重排 绑定引用参数</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>返回对象的引用</td>\n</tr>\n</tbody></table>\n<ol>\n<li>普通迭代器</li>\n<li>插入迭代器</li>\n</ol>\n<ul>\n<li>back_inserter 创建一个使用push_back的迭代器(需容器支持push_back)</li>\n<li>front_inserter 创建一个使用push_front的迭代器(需容器支持push_front)</li>\n<li>insterer 创建一个使用insert的迭代器</li>\n</ul>\n<ol start=\"3\">\n<li>流迭代器</li>\n</ol>\n<ul>\n<li>istream_iterator</li>\n<li>ostream_iterator</li>\n</ul>\n<ol start=\"4\">\n<li>反向迭代器 - 除了forward_list均支持</li>\n</ol>\n<p>算法要求的迭代器类型 五类迭代器</p>\n<ul>\n<li>输入迭代器 只读, 不写, 单边扫描, 只能递增</li>\n<li>输出迭代器 只写, 不读, 单边扫描, 只能递增</li>\n<li>前向迭代器 读写 多遍 只能递增</li>\n<li>双向迭代器 读写 多遍 增减都可</li>\n<li>随机访问迭代器 读写 多遍 支持全部迭代器运算</li>\n</ul>\n<h2 id=\"第十二章-动态内存与智能指针\"><a href=\"#第十二章-动态内存与智能指针\" class=\"headerlink\" title=\"第十二章 动态内存与智能指针\"></a>第十二章 动态内存与智能指针</h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png\" alt=\"\"></p>\n<p><strong>make_share</strong></p>\n<p><strong>shared_ptr的拷贝和赋值</strong><br>当进行拷贝或者赋值操作时候 shared_ptr都会记录有多少个其他的shared_ptr<br>指向相同的对象</p>\n<p>引用计数增加的情况</p>\n<ul>\n<li>拷贝shared_ptr </li>\n<li>初始化其他shared_ptr指针</li>\n<li>作为参数传递给一个函数</li>\n<li>作为函数的返回值</li>\n</ul>\n<p>引用计数减少</p>\n<ul>\n<li>赋予新值</li>\n<li>被销毁(例如离开作用域)</li>\n</ul>\n<p>当引用计数为0的时候, 就会释放自己管理的对象</p>\n<p><strong>使用动态内存的原因</strong></p>\n<ul>\n<li>程序不知道自己需要使用多少对象 容器类</li>\n<li>程序不知道所需对象的准确类型</li>\n<li>程序需要在多个对象间共享数据</li>\n</ul>\n<p><strong>程序需要在多个对象间共享数据</strong><br>一般情况</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v1; <span class=\"comment\">// empty</span></span><br><span class=\"line\">&#123; <span class=\"comment\">// 新的作用域</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v2 = &#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;;</span><br><span class=\"line\">\tv1 = v2;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 离开作用域 v2被销毁</span></span><br><span class=\"line\"><span class=\"comment\">// v1中有三个元素, 是原来三个元素的拷贝</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是我们要实现的情况</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v1; <span class=\"comment\">// empty</span></span><br><span class=\"line\">&#123; <span class=\"comment\">// 新的作用域</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v2 = &#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;;</span><br><span class=\"line\">\tv1 = v2; <span class=\"comment\">// v1 v2共享相同的元素</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 离开作用域 v2被销毁 但v2的元素不能被销毁</span></span><br><span class=\"line\"><span class=\"comment\">// v1中有三个元素, 指向原来三个元素</span></span><br></pre></td></tr></table></figure>\n\n<p>创建一个类来管理这个vector, 但是不能直接保存在其中, 因为当这个类的对象销毁的时候内部的vector也就销毁<br>所以需要保存在动态内存中</p>\n<p>所以使用shared_ptr来管理动态分配的vector, 当最后一个vector的使用者被销毁的时候才释放内存</p>\n<p>确定下这个类提供的操作</p>\n<ul>\n<li>修改元素的操作会进行校验 不合法则抛出异常</li>\n<li>默认构造函数</li>\n<li>接受单一的initiaizer_list&lt;string&gt;类型的参数. 这个参数可以接受一个初始器的花括号列表</li>\n</ul>\n<p><strong>直接管理内存</strong></p>\n<p>了解到两个概念 一个<code>默认初始化</code>一个<code>值初始化</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i, *pi1 = &amp;i, *pi2 = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> *pd = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>(<span class=\"number\">33</span>), *pd2 = pd;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> i; <span class=\"comment\">// 错误 i不是指针</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pi1; <span class=\"comment\">// 未定义 pi1指向一个局部变量 具有潜在性危害</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pd; <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pd2; <span class=\"comment\">// 未定义 内存已经被释放 具有潜在性危害</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pi2; <span class=\"comment\">// 正确 释放空指针没有错误</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *pci = <span class=\"keyword\">new</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">delete</span> pci <span class=\"comment\">// 正确 释放一个const对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// delete之后指针就变成了`空悬指针` 需要将其置为`nullptr`</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>shared_ptr和new结合使用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误智能指针构造函数是explicit</span></span><br><span class=\"line\"><span class=\"comment\">// 无法将内置指针隐式转换成一个智能指针, 必须使用直接初始化</span></span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确  使用了直接初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>))</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>定义和改变方式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p管理内置指针q所指向的对象, q必须指向new分配的内存, 且能够转换为T*类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(q)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p从unique_ptr u那里接管了对象的所有权 将U置为空</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p 接管了内置指针q所指向的对象的所有权, q必须能转化为T* 类型</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p将使用可调用对象d来代替delete</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(q, d)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p是shared_ptr p2的拷贝</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p将用可调用对象d来代替delete</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(p2, d)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 若p是唯一指向其对象的shared_ptr, reset会释放此对象</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 如果传递了可选的参数-内置指针q, 则会令p指向q 否则将p置为空</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 如果还传递了d, 会调用d而不是delete来释放q</span></span></span><br><span class=\"line\">p.reset()</span><br><span class=\"line\">p.reset(q)</span><br><span class=\"line\">p.reset(q, d)</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong></p>\n<p>使用unique_ptr的时候要注意</p>\n<ol>\n<li><p>不要在函数调用传参的括号中 使用临时变量 这样一旦函数调用完成就会被销毁</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; ptr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">42</span> ))</span> </span>; <span class=\"comment\">// 引用 = 1</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(p); <span class=\"comment\">// 拷贝 会递增它的引用计数 ;在 process 中引用计数位为2</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = *p; <span class=\"comment\">// 正确 引用计数为1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">x</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>))</span></span>; <span class=\"comment\">// 危险 这是一个普通指针，不是一个智能指针</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(x) ; <span class=\"comment\">// 错误 不能将 int* 转换为 一个 shared_ptr&lt;int&gt; </span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; (x)); <span class=\"comment\">// 合法的，但内存会被释放! 因为临时对象会被销毁</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> j =*x <span class=\"comment\">//未定义的 是一个空悬指针!</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果使用智能指针不要使用get函数初始化另一个智能指针或为其赋值<br>因为一旦新生成的智能指针离开作用域或者被释放, 会影响到原来的智能指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>); <span class=\"comment\">// 不能将一个int* 赋值给shared_ptr&lt;int&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p1;</span><br><span class=\"line\">p1.reset(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>)); <span class=\"comment\">// 可以</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>))</span></span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用make_share来创建shared_ptr指针</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p3 = <span class=\"built_in\">std</span>::make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">auto</span> p4 = <span class=\"built_in\">std</span>::make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// make_share不能用来创建unique_ptr</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; d;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">d1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>))</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ol>\n<ol start=\"3\">\n<li>unique_ptr不支持普通的赋值和拷贝操作, 因为unique_ptr要独占所指向的对象<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">d1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1</span>))</span></span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">d2</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>))</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\">d1.<span class=\"built_in\">release</span>(); <span class=\"comment\">// 释放原来所指向的对象</span></span><br><span class=\"line\">d1.reset(d2.<span class=\"built_in\">release</span>()); <span class=\"comment\">// d2释放后由d1获取</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><strong>智能指针陷阱</strong></p>\n<ol>\n<li>不使用相同的内置指针值初始化(或reset)多个智能指针</li>\n<li>不使用delete get返回的指针</li>\n<li>不使用get初始化或者reset另一个智能指针</li>\n<li>如果你使用get返回指针, 当最后一个对应的智能指针销毁 这个指针就变成了垂悬指针</li>\n<li>使用智能指针管理非new分配的内存, 需要传递一个删除器.</li>\n</ol>\n<p><strong>weak_ptr</strong><br>不控制所指向对象生存周期, 指向一个shared_ptr管理的对象.</p>\n<p>由于weak_ptr不参与对应的shared_ptr的引用计数, vector可能已经被释放了<br>释放后 lock将返回一个空指针</p>\n<p><strong>allocator 将内存的分配和对象的构造分离开</strong></p>\n<h1 id=\"第三部分-类设计者的工具\"><a href=\"#第三部分-类设计者的工具\" class=\"headerlink\" title=\"第三部分 类设计者的工具\"></a>第三部分 类设计者的工具</h1><h2 id=\"模板与泛型编程\"><a href=\"#模板与泛型编程\" class=\"headerlink\" title=\"模板与泛型编程\"></a>模板与泛型编程</h2><p><code>template &lt;typename T&gt;</code></p>\n<p>编译器用推断出的模板参数来<code>实例化</code>一个特定版本的函数.<br>不同的模板参数类型<code>实例化</code>出不同的函数 然后进行调用.</p>\n<p><strong>模板类型参数</strong></p>\n<p>如果有多个模板参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, U&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">U</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>非类型模板参数</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">unsigned</span> N, <span class=\"keyword\">unsigned</span> M&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p1)[N], <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p2)[M])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>(p1, p2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">compare(<span class=\"string\">\"hi\"</span>, <span class=\"string\">\"mmm\"</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p1)[<span class=\"number\">3</span>], <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p2)[<span class=\"number\">4</span>])</span> <span class=\"comment\">// 注意空字符</span></span></span><br></pre></td></tr></table></figure>\n<p>编译器会使用字面常量的大小来代替N和M, 从而实例化模板</p>\n<p>非类型参数可以使<code>整形</code>或者是一个指向对象或者函数类型的<code>指针</code>或者<code>(左值)引用</code><br>绑定到<code>非类型整数参数</code>的实参必须是一个常量表达式.<br>绑定到<code>指针</code>或者<code>引用非类型模板参数</code>的实参必须具有静态的生存期</p>\n<p>静态内存用来保存<code>局部static对象</code>, <code>类static数据成员</code>和<code>定义于任何函数之外的变量</code><br>栈内存用来保存定义在函数内的非static对象.<br>分配在静态内存和栈内存的由编译器自动创建和销毁</p>\n<p>堆 用来存储动态分配的对象</p>\n<p>编译器遇到一个模板类型定义的时候并不会生成代码, 而是实例化出一个特定版本的时候才会实例化</p>\n<p><strong>使用类的类型成员</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">T::size_type* p;</span><br></pre></td></tr></table></figure>\n<p>默认情况下, C++语言假定通过域运算符访问名字而不是类型.<br>如果想要使用模板类型参数(T)的类型成员(size_type) 必须使用<code>typename</code>而不是<code>class</code></p>\n<p><strong>默认模板实参</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> F = less&lt;T&gt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> compare(<span class=\"keyword\">const</span> T&amp; v1, <span class=\"keyword\">const</span> T&amp; v2, F f = f())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (f(v1, v2)) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (f(v2, v1)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第四部分-高级主题\"><a href=\"#第四部分-高级主题\" class=\"headerlink\" title=\"第四部分 高级主题\"></a>第四部分 高级主题</h1><p>tuple这里看了, 例子写了总感觉实用性不是很大? 或许可以用在便捷处理输入参数?</p>\n<p>biset感觉还是有点用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">bitset</span>&lt;32&gt; b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下位不足 高位都补0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> u = ULLONG_MAX;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">bitset</span>&lt;32&gt; <span class=\"title\">bu</span><span class=\"params\">(u)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> s1 = <span class=\"string\">\"10101010101010\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">bitset</span>&lt;32&gt; <span class=\"title\">bs1</span><span class=\"params\">(s1)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> s2 = <span class=\"string\">\"ababaabbababb\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// std::bitset&lt;32&gt; bs2(s2); std::invalid_argument</span></span><br><span class=\"line\"><span class=\"comment\">// a instand 0 b instand 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">bitset</span>&lt;32&gt; <span class=\"title\">bs2</span><span class=\"params\">(s2, <span class=\"number\">0</span>, <span class=\"number\">32</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bu.any(); <span class=\"comment\">// 存在 置位(1) 的二进制位吗</span></span><br><span class=\"line\">bu.all(); <span class=\"comment\">// 所有位都置位了吗</span></span><br><span class=\"line\">bu.none(); <span class=\"comment\">// b中不存在置位的二进制位吗</span></span><br><span class=\"line\">bu.count(); <span class=\"comment\">// 置位数目</span></span><br><span class=\"line\">bu.<span class=\"built_in\">size</span>(); <span class=\"comment\">// 数目</span></span><br><span class=\"line\"></span><br><span class=\"line\">bu.test(<span class=\"number\">1</span>); <span class=\"comment\">// 位置1是置位的返回true 否则返回false</span></span><br><span class=\"line\">bu.<span class=\"built_in\">set</span>(<span class=\"number\">1</span>, <span class=\"literal\">true</span>); <span class=\"comment\">// 将1位 置 true-&gt;1 false-&gt;0</span></span><br><span class=\"line\">bu.reset(<span class=\"number\">1</span>); <span class=\"comment\">// 将1位复位 置0</span></span><br><span class=\"line\">bu.reset(); <span class=\"comment\">// 将所有位复位 置0</span></span><br><span class=\"line\"></span><br><span class=\"line\">bu.flip(<span class=\"number\">1</span>); <span class=\"comment\">// 1位取反</span></span><br><span class=\"line\">bu.flip(); <span class=\"comment\">// 全部取反</span></span><br><span class=\"line\">bu[<span class=\"number\">1</span>].flip();</span><br><span class=\"line\"></span><br><span class=\"line\">bu[<span class=\"number\">1</span>]; <span class=\"comment\">// 1位 1-&gt;true 0-&gt;false</span></span><br><span class=\"line\"></span><br><span class=\"line\">bu.to_ulong();</span><br><span class=\"line\">bu.to_ullong();</span><br><span class=\"line\"></span><br><span class=\"line\">bu.to_string(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>); <span class=\"comment\">// 0-&gt;a 1-&gt;b</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TOOD\"><a href=\"#TOOD\" class=\"headerlink\" title=\"TOOD\"></a>TOOD</h1><p>explicit 参见7.5.4节 265</p>\n<p>运算符优先级………..</p>\n<h1 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h1><p><strong>char 在默认情况下, 既不是有符号. 也不是无符号.</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a; <span class=\"comment\">// 此时a可能是 signed char 也可能是 unsigned char 可能会在不同系统之前产生错误</span></span><br><span class=\"line\"><span class=\"comment\">// 可以显式声明, 来确保不会出现此错误</span></span><br><span class=\"line\"><span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> a;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> a;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输入</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">cin</span>.getline(name, <span class=\"number\">10</span>); <span class=\"comment\">// 可以读取换行符, 但不保存</span></span><br><span class=\"line\"><span class=\"built_in\">cin</span>.<span class=\"built_in\">get</span>(name, <span class=\"number\">10</span>); <span class=\"comment\">// 不读取换行符, 可能导致get到换行符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 空行和超出长度问题 将在后面说明</span></span><br></pre></td></tr></table></figure>\n<p>运算符优先级<br><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=59a3e1017d3e6709aa0d4dad5aaef458/63d9f2d3572c11df57c9a205612762d0f703c2f8.jpg\" alt=\"\"></p>\n<p><strong>基础的数组</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 下方由于 new 只是返回一个地址所以用 int* 接收 </span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* b = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; a[<span class=\"number\">0</span>] &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; *(a + <span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p><strong>对指针解引用</strong><br>第一印象是 解除引用, 然而并不是</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\"*\"的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。也就是说，解引用是返回内存地址中保存的值。</span></span><br><span class=\"line\"><span class=\"comment\">比如int a=10; int *p=&amp;a;</span></span><br><span class=\"line\"><span class=\"comment\">cout&lt;&lt;*p&lt;&lt;endl; 输出a的值，就是解引用操作。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n<p><strong>常用 宏</strong><br>| 定义 | 说明 |<br>| —– | —– |<br>| <code>__FILE__</code> | 存放文件名的字符串字面值 |<br>| <code>__LINE__</code> | 存放当前行号的整形字面值 |<br>| <code>__TIME__</code> | 存放文件编译时间的字符串字面量 |<br>| <code>__DATE__</code> | 存放文件编译日期的字符串字面值 |<br>| <code>__VA_ARGS__</code> | 用来接受函数参数中<code>...</code>, 类似printf函数, 这个宏只能在宏中使用 |</p>\n<h1 id=\"第一部分-基础知识\"><a href=\"#第一部分-基础知识\" class=\"headerlink\" title=\"第一部分 基础知识\"></a>第一部分 基础知识</h1><h2 id=\"第二章-变量和基本类型\"><a href=\"#第二章-变量和基本类型\" class=\"headerlink\" title=\"第二章 变量和基本类型\"></a>第二章 变量和基本类型</h2><h3 id=\"习题\"><a href=\"#习题\" class=\"headerlink\" title=\"习题\"></a>习题</h3><p><strong>2.2 与钱相关的数据存储 使用的类型</strong><br>银行相关钱相关的数据 保存 使用整形, 不太可能使用浮点数. 浮点数运算可能会出现误差<br>使用<code>1</code>代表<code>1RMB</code> 或者使用<code>1</code>代表<code>0.01RMB</code></p>\n<p><strong>2.9 解释下列定义 对于非法说出错在哪里</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cin</span> &gt;&gt; <span class=\"keyword\">int</span> input_value; <span class=\"comment\">// error: expected primary-expression before ‘int’</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> i1 = &#123;<span class=\"number\">3.14</span>&#125;;<span class=\"comment\">// narrowing conversion of ‘3.1400000000000001e+0’ from ‘double’ to ‘int’ inside &#123; &#125; [-Wnarrowing]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">double</span> salary = wage = <span class=\"number\">9999.99</span>;<span class=\"comment\">// error: ‘wage’ was not declared in this scope 如果定义wage则语句不报错</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> i2 = <span class=\"number\">3.14</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2.10 下列变量的初始值是什么</strong></p>\n<p>内置类型变量未被显示初始化  函数体之外初始化为0  函数体内是未被定义的<br>类    一般都拥有默认的初始化方式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> g_str; <span class=\"comment\">// 全局变量 且拥有默认初始化方式 为空字符串</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> g_int; <span class=\"comment\">// \t全局变量 初值为0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> local_int; <span class=\"comment\">// 局部变量 未定义</span></span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> local_str; <span class=\"comment\">// 拥有默认初始化方式 空字符串</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>2.14 下面代码输出什么</strong><br>起初一看 以为会是循环到溢出 直接就把代码码了下来运行 发现是正常的.<br>就算for中 <code>int i = 0</code>改为<code>i = 0</code>依然不会溢出<br>for的i覆盖了外面的i</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">100</span>, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i != <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        sum += i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; <span class=\"comment\">//$ 100 45</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出<del>~</del></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i, &amp;ri = i;</span><br><span class=\"line\">    i = <span class=\"number\">5</span>;</span><br><span class=\"line\">    ri = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\" \"</span> &lt;&lt; ri &lt;&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; <span class=\"comment\">//$ 10 10</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h3><p>一个形如42的值被称为<code>字面值常量(literal)</code>, 这样的值你一看到(面), 就知道是多少</p>\n<p>scope 作用域</p>\n<h3 id=\"无符号\"><a href=\"#无符号\" class=\"headerlink\" title=\"无符号\"></a>无符号</h3><p><strong>unsigned int和int运算的时候 自动转换为unsigned</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">-11</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>; <span class=\"comment\">//$ 4294967295</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>警惕for循环中的 无符号类型</strong><br>size_t</p>\n<h3 id=\"声明定义初始化赋值\"><a href=\"#声明定义初始化赋值\" class=\"headerlink\" title=\"声明定义初始化赋值\"></a>声明定义初始化赋值</h3><p><strong>声明</strong><br>声明不是定义, 可以多次声明<br>指明变量的type和name.<br>对于变量的声明需要使用<code>extern</code>关键字, 如果使用了<code>extern</code>关键字的同时初始化就成了定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i; <span class=\"comment\">// 声明并定义 未初始化</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> a; <span class=\"comment\">// 声明</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>; <span class=\"comment\">// 定义 声明 初始化</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>定义</strong><br>声明并定义, 只能定义一次<br>定义的时候需要指定type和name. 申请空间, 可能进行初始化.</p>\n<p><strong>初始化 赋值</strong><br>初始化 不是赋值<br>初始化是创建变量时 赋予其一个初始值<br>赋值是擦除当前的值 赋予新的值</p>\n<p><strong>变量类型选择</strong><br>数值范围超过<code>int</code> 建议使用<code>long long</code>, <code>long</code>的长度仅是大于等于<code>int</code><br>char类型可能是 <code>signed</code> 还可能是<code>unsigned</code> 如果针对范围有特殊要求 应该注明是否有无符号<br>浮点运算建议使用double float经常精度不够, 然而两者运算效率却相差无几. <code>long double</code>反而绝大多数情况用不到</p>\n<h3 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h3><p>const变量必须被初始化</p>\n<p>所谓指向常量的引用或指针, 不过是指针或引用自以为是罢了, 他们觉得自己指向了常量, 所以自觉不去修改</p>\n<p>顶层const: 表示指针本身是常量<br>底层const: 表示指针指向是一个常量<br>指针本身是一个对象, 他可以指向另一个对象. 因此, 指针本身是不是常量, 以及指针所向是不是一个常量就是两个独立的问题.</p>\n<p>执行拷贝的时候, 常量是顶层const还是底层const区别明显, 顶层const可以视为不见<br>然而底层const的限制不能忽视, 拷入和拷出对象必须具有相同的底层const资格</p>\n<p><strong>指针常量和类型别名</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span>* pstring;</span><br><span class=\"line\"><span class=\"keyword\">const</span> pstring cstr = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p>这里pstring是指向char的指针 const pstring是指向char的常量指针 指针指向不能变<br>而不是简单地将pstring替换掉</p>\n<h3 id=\"constexpr\"><a href=\"#constexpr\" class=\"headerlink\" title=\"constexpr\"></a>constexpr</h3><p>在一个复杂系统中, 很难分辨一个初始值到底是不是常量表达式.<br>当然可以定义一个const变量 并把初始值设定为我们认为的常量表达式, 然而实际依然有非常量表达式的情况</p>\n<p>C++11标准 将变量声明为constexpr由编译器来验证变量是否是一个常量表达式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> mm = <span class=\"number\">20</span>; <span class=\"comment\">// 20是常量表达式</span></span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> yy = mm + <span class=\"number\">1</span>; <span class=\"comment\">// mf + 1是常量表达式</span></span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> sz = <span class=\"built_in\">size</span>(); <span class=\"comment\">// 当size是一个constexpr函数时才是正确的声明语句</span></span><br></pre></td></tr></table></figure>\n\n<p>指针和引用都能定义成constexpr, 但初始值受到严格限制.<br>constexpr指针的初始值必须是nullptr或者0 或者存储于某个固定地址中的对象(位于所有函数体之外)<br>constexpr引用能绑定到 某个固定地址中的对象</p>\n<p><strong>decltype和引用</strong><br><code>decltype((i)) d</code> 双层括号是引用<br><code>decltype(i) d</code>单层括号只有i是引用的时候 d才是引用</p>\n<h2 id=\"第三章-字符串-向量和数组\"><a href=\"#第三章-字符串-向量和数组\" class=\"headerlink\" title=\"第三章 字符串 向量和数组\"></a>第三章 字符串 向量和数组</h2><h3 id=\"习题-1\"><a href=\"#习题-1\" class=\"headerlink\" title=\"习题\"></a>习题</h3><p><strong>3.34</strong><br>p1和p2指向同一数组中的元素, 则下面程序的功能是什么? 什么情况下程序是非法的?<br>p1 += p2 - p1;<br>将p1移动到p2的位置  不会非法……….</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"{} = ()\"></a>{} = ()</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span> a = <span class=\"string\">\"cccc\"</span>;  <span class=\"comment\">// 只有一个参数值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"string\">'c'</span>)</span></span>; <span class=\"comment\">// 拥有两个参数值 10和'c'</span></span><br></pre></td></tr></table></figure>\n\n<p>使用=, 进行拷贝初始化 只能提供一个初始值<br>使用(), 进行直接初始化, 可以提供多个初始值进行初始化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> a1 = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">a2</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"comment\">// temp.cpp:4:12: error: expected identifier before numeric constant</span></span><br><span class=\"line\">  <span class=\"comment\">// int a2(10);</span></span><br><span class=\"line\">  <span class=\"comment\">// temp.cpp:4:12: error: expected ‘,’ or ‘...’ before numeric constant</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> a3&#123;<span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>类内初始值 不能使用小括号</p>\n<p>列表初始化只能放在花括号中 </p>\n<h3 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h3><p>vector中不能保存引用, 因为使用引用就必须初始化.</p>\n<p>设想, 你设置了vector包含十个元素, 这十个空间就必须被初始化,<br>然而引用必须要绑定到具体的对象上, 此时却没有对象进行绑定</p>\n<p>再者如果容器复制的时候 引用怎么复制?</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">v1</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>; <span class=\"comment\">// 10个元素, 全为0</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v2&#123;<span class=\"number\">10</span>&#125;; <span class=\"comment\">// 一个元素, 为10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">v3</span><span class=\"params\">(<span class=\"number\">10</span>, <span class=\"number\">1</span>)</span></span>; <span class=\"comment\">// 10个元素, 全为1</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v4&#123;<span class=\"number\">10</span>, <span class=\"number\">1</span>&#125;; <span class=\"comment\">// 两个元素, 10和1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -----------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v5&#123;<span class=\"string\">\"hi\"</span>&#125;; <span class=\"comment\">// 列表初始化 有一个元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; <span class=\"title\">v6</span><span class=\"params\">(<span class=\"string\">\"hi\"</span>)</span></span>; <span class=\"comment\">// 错误不能使用字符串字面值构建vector元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v7&#123;<span class=\"number\">10</span>&#125;; <span class=\"comment\">// 10个默认初始化的对象</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v8&#123;<span class=\"number\">10</span>, <span class=\"string\">\"hi\"</span>&#125;; <span class=\"comment\">// 十个值为\"hi\"的元素</span></span><br></pre></td></tr></table></figure>\n\n<p>因为不能使用int来初始化string对象, 列表初始化要求列表值类型与尖括号种类型相同<br>v7和v8并不是列表初始化, 而是转去尝试用默认值(默认值????)初始化</p>\n<p>这里感觉有点?去看了下英文原版<br>the compiler looks for<br>other ways to initialize the object from the given values.</p>\n<p><strong>迭代器</strong><br>使用的时候注意迭代器失效, </p>\n<h3 id=\"数组和指针\"><a href=\"#数组和指针\" class=\"headerlink\" title=\"数组和指针\"></a>数组和指针</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (*array_ptr)[<span class=\"number\">10</span>] = &amp;arr; <span class=\"comment\">// 指向十个整数的数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> (&amp;array_ref)[<span class=\"number\">10</span>] = arr; <span class=\"comment\">// 十个整数数组的引用</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">a1</span><span class=\"params\">(a)</span></span>; <span class=\"comment\">// a1是指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(a) a2; <span class=\"comment\">//a2是有八个元素的数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>* b = <span class=\"built_in\">std</span>::<span class=\"built_in\">begin</span>(a); <span class=\"comment\">// 指向首元素</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* c = <span class=\"built_in\">std</span>::<span class=\"built_in\">end</span>(a); <span class=\"comment\">// 指向最后一个元素的后一位</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">ptrdiff_t</span> d = c - b; <span class=\"comment\">// ptrdiff_t 定义在cstddef中</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span>* p = &amp;a[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> k = p[<span class=\"number\">-1</span>];<span class=\"comment\">// 内置下标运算符所用的索引值不是无符号型 可以为负</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第四章-表达式\"><a href=\"#第四章-表达式\" class=\"headerlink\" title=\"第四章 表达式\"></a>第四章 表达式</h2><p>当一个对象被用作右值的时候, 使用的是对象的值(内容)<br>当一个对象被用做左值的时候, 使用的是对象的身份(在内存中的位置)</p>\n<p>如果表达式的求值结果是左值, decltype作用于该表达式得到一个引用类型.</p>\n<p><code>int* p</code><br>解引用运算符生成左值 <code>decltype(*p)</code>得到的是<code>int&amp;</code><br>取地址运算符生成右值 <code>decltype(&amp;p)</code>的结果是<code>int**</code></p>\n<p>大多数运算符没有规定按照什么顺序求值<br><code>int i = f1() * f2()</code><br>这两函数的调用顺序是未定义的</p>\n<p>只有四种运算符规定了运算对象的求值顺序<br>短路求值<br><code>&amp;&amp;</code> 从左到右<br><code>||</code> 从左到右</p>\n<p><code>?:</code><br><code>,</code> 逗号运算符 从左到右 首先求值左侧然后丢掉结果 真正返回的是右侧结果</p>\n<p>书写表达式的建议</p>\n<ol>\n<li>拿不准的时候最好使用括号来组合表达式. 括号不香吗?</li>\n<li>如果改变了某个运算对象的值, 在表达使得其他地方就不要再使用这个运算对象</li>\n</ol>\n<p><code>(-m) / n</code> 和 <code>m / (-n)</code> 等于 <code>-(m / n)</code><br><code>m % (-n)</code> 等于 <code>m % n</code><br><code>(-m) % n</code> 等于 <code>-(m % n)</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> ival, jval</span><br><span class=\"line\">ival = jval = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<p>赋值运算符右结合, 所以右侧的<code>jval = 0</code>是左侧赋值运算符的右侧运算对象<br>又因为赋值运算符返回的是其左侧运算对象, 所以右侧赋值运算符的结果(Jval)赋给了ival</p>\n<p>赋值运算符的优先级低于关系运算符, 所以条件语句中, 赋值部分应该加上括号</p>\n<p><code>sizeof *p</code><br>sizeof 不会实际求运算对象的值, 所以即使p是无效指针也不会有什么影响<br>sizeof对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小<br>sizeof对string对象和vector对象 只返回该类型固定部分的大小, 不会计算对象中元素占用了多少空间<br>sizeof(string) 与string长度无关, 不同的编译器有不同的具体实现<br><a href=\"http://www.cplusplus.com/forum/general/218642/\" target=\"_blank\" rel=\"noopener\">http://www.cplusplus.com/forum/general/218642/</a></p>\n<p>sizeof(vector<int>) 返回24字节 64位系统指针8字节 三个指针24字节 (头指针, 尾指针, 当前容量尾指针)<br>pointer <em>M</em>start;<br>pointer <em>M</em>finish;<br>pointer <em>M</em>end_of_storage;</p>\n<p>非内置类型基本都含有指针, 指向堆中分配的内存, 所以存在存储任意大小都会返回固定sizeof</p>\n<p><code>const-name&lt;type&gt;(expr)</code><br>命名显式强制类型转换</p>\n<p>static_cast 静态类型转换 用于替代隐式类型转换</p>\n<ul>\n<li>子类向父类转换 安全</li>\n<li>父类向子类转换 无动态类型检查 不安全</li>\n<li>基本数据类型转换</li>\n<li>指针类型转换</li>\n<li>将任何其他类型转换为void类型</li>\n</ul>\n<p>任何具有明确定义的类型转换, 只要底层不包含const, 都能使用. 值类型转换以及指针类型转换<br>如果类型不兼容, 则编译阶段报错.</p>\n<p>dynamic_cast<br>运行时转换, 如果转换失败返回null. type和expr必须同是类指针或者类引用<br>用于父类向子类的转换</p>\n<p>const_cast<br>增加或删除运算对象的底层const, 如果对象本身不是一个常量 获取写权限是合法的, 如果是常量则会产生未定义后果.</p>\n<p>reinterpret_cast<br>为运算对象的位模式提供较低层次上的重新解析<br><a href=\"https://zhuanlan.zhihu.com/p/33040213\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/33040213</a></p>\n<h2 id=\"第五章-语句\"><a href=\"#第五章-语句\" class=\"headerlink\" title=\"第五章 语句\"></a>第五章 语句</h2><p>即使不准备在default标签下做任何工作, 定义一个default标签也是有作用的. 可以告知读者,<br>我们已经考虑到了默认情况, 只是目前什么也没做</p>\n<p><strong>switch-case关于变量定义的问题</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"literal\">true</span>:</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> v1;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> v2 &#123;&#125;;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> v3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> v4;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"literal\">false</span>:</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v1 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v2 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v3 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v4 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译报错 注意没有   v4  控制流绕过了初始化变量的语句</span></span><br><span class=\"line\"></span><br><span class=\"line\">switch-case.cpp: In function ‘int main()’:</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">16</span>:<span class=\"number\">14</span>: error: jump to <span class=\"keyword\">case</span> label [-fpermissive]</span><br><span class=\"line\">         <span class=\"keyword\">case</span> <span class=\"literal\">false</span>:</span><br><span class=\"line\">              ^~~~~</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">12</span>:<span class=\"number\">17</span>: note:   crosses initialization of ‘<span class=\"keyword\">int</span> v3’</span><br><span class=\"line\">             <span class=\"keyword\">int</span> v3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">                 ^~</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">11</span>:<span class=\"number\">25</span>: note:   crosses initialization of ‘<span class=\"built_in\">std</span>::__cxx11::<span class=\"built_in\">string</span> v2’</span><br><span class=\"line\">             <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> v2 &#123;&#125;;</span><br><span class=\"line\">                         ^~</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">10</span>:<span class=\"number\">25</span>: note:   crosses initialization of ‘<span class=\"built_in\">std</span>::__cxx11::<span class=\"built_in\">string</span> v1’</span><br><span class=\"line\">             <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> v1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 两个case语句加上括号后报错变为</span></span><br><span class=\"line\">switch-case.cpp: In function ‘int main()’:</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">18</span>:<span class=\"number\">26</span>: error: ‘v1’ was <span class=\"keyword\">not</span> declared in <span class=\"keyword\">this</span> scope</span><br><span class=\"line\">             <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v1 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                          ^~</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">19</span>:<span class=\"number\">26</span>: error: ‘v2’ was <span class=\"keyword\">not</span> declared in <span class=\"keyword\">this</span> scope</span><br><span class=\"line\">             <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v2 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                          ^~</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">20</span>:<span class=\"number\">26</span>: error: ‘v3’ was <span class=\"keyword\">not</span> declared in <span class=\"keyword\">this</span> scope</span><br><span class=\"line\">             <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v3 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">                          ^~</span><br><span class=\"line\"><span class=\"keyword\">switch</span>-<span class=\"keyword\">case</span>.cpp:<span class=\"number\">21</span>:<span class=\"number\">26</span>: error: ‘v4’ was <span class=\"keyword\">not</span> declared in <span class=\"keyword\">this</span> scope</span><br><span class=\"line\">             <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; v4 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>\n\n\n<p>定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程</p>\n<p>牢记for语句头中定义的对象只在for循环体内可见.<del>~</del></p>\n<p><strong>break continue</strong></p>\n<p>break负责终止离他最近的while, do while, for或者switch. 并从这些语句后的第一条开始继续执行</p>\n<p>continue语句终止最近的循环中当前迭代, 并立即开始下一次迭代</p>\n<p><strong>异常处理</strong><br>代码可以使用throw来抛出异常<br>大部分可以指定msg来初始化异常<br>throw exception_type(“msg”)<br>表中exception不能指定msg, 来初始化, 除此外表中其他都需要msg初始</p>\n<p>位于<code>stdexcept</code>头文件中</p>\n<table>\n<thead>\n<tr>\n<th>错误名称</th>\n<th>对应原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>exception</td>\n<td>最常见的问题</td>\n</tr>\n<tr>\n<td>runtime_error</td>\n<td>只有运行的时候才能查到错误</td>\n</tr>\n<tr>\n<td>range_error</td>\n<td>运行时错误: 超范围</td>\n</tr>\n<tr>\n<td>overflow_error</td>\n<td>运行时错误: 上溢</td>\n</tr>\n<tr>\n<td>underflow_error</td>\n<td>运行时错误: 下溢</td>\n</tr>\n<tr>\n<td>logic_error</td>\n<td>程序逻辑错误</td>\n</tr>\n<tr>\n<td>domain_error</td>\n<td>程序逻辑错误: 参数对应的结果不存在</td>\n</tr>\n<tr>\n<td>invalid_argument</td>\n<td>程序逻辑错误: 无效参数</td>\n</tr>\n<tr>\n<td>length_error</td>\n<td>程序逻辑错误: 试图创建一个超出该类型最大长度的对象  如vector::reserve</td>\n</tr>\n<tr>\n<td>out_of_range</td>\n<td>程序逻辑错误: 超范围</td>\n</tr>\n</tbody></table>\n<h2 id=\"第六章-函数\"><a href=\"#第六章-函数\" class=\"headerlink\" title=\"第六章 函数\"></a>第六章 函数</h2><p>形参名是可选的, 但是由于无法使用未命名的形参, 所以一般都有一个名字.</p>\n<p>自动对象: 只存在于块执行期间的对象<br>局部静态对象: 只在<code>第一次</code>经过对象语句时进行初始化, 直到程序终止才被销毁.</p>\n<p>数组引用形参</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> (&amp;arr)[<span class=\"number\">10</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> elem : arr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; elem &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>函数返回引用得到左值<br>返回其他类型得到右值</p>\n<p>p205页 还真没见过 返回数组指针这种形式</p>\n<h2 id=\"第七章-类\"><a href=\"#第七章-类\" class=\"headerlink\" title=\"第七章 类\"></a>第七章 类</h2><h3 id=\"习题-2\"><a href=\"#习题-2\" class=\"headerlink\" title=\"习题\"></a>习题</h3><p><strong>7.25 Screen能安全的依赖于拷贝和赋值操作的默认版本吗</strong><br>Screen中只有内置类型和string, 如果其含有动态管理的内存则不行<br>当类需要分配类对象以外的资源时, 默认版本经常会失效</p>\n<p>默认构造函数, 会造成 内置类型和复合类型成员 默认初始化后 值未定义</p>\n<p>关于未定义这点我去写了小段程序看了下, 也搜了一下</p>\n<p><a href=\"https://stackoverflow.com/a/2218275/11581349\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/a/2218275/11581349</a></p>\n<p>It will be automatically initialized if</p>\n<ul>\n<li>it’s a class/struct instance in which the default constructor initializes all primitive types; like MyClass instance; 有默认构造函数类或者结构体, 并且默认构造函数初始化所有内置类型</li>\n<li>you use array initializer syntax, e.g. int a[10] = {} (all zeroed) or int a[10] = {1,2}; (all zeroed except the first two items: a[0] == 1 and a[1] == 2) 使用了大括号初始化</li>\n<li>same applies to non-aggregate classes/structs, e.g. MyClass instance = {}; (more information on this can be found here) 同大括号初始化</li>\n<li>it’s a global/extern variable 全局或者extern类型</li>\n<li>the variable is defined static (no matter if inside a function or in global/namespace scope) 变量被声明为static</li>\n</ul>\n<p>默认初始化发生的情况</p>\n<ul>\n<li>不使用任何初始值定义一个非静态变量或者数组</li>\n<li>一个类本身含有类类型的成员且使用合成的默认构造函数</li>\n<li>类类型的成员没有在构造函数初始值列表中显示地初始化时</li>\n</ul>\n<p>值初始化</p>\n<ul>\n<li>数组初始化提供的初始值数量小于数组大小</li>\n<li>不使用初始值定义一个局部静态变量</li>\n<li>书写T()表达式 显示地请求值初始化</li>\n</ul>\n<p>mutable可变数据成员, 从远不会是const.  可以在const成员函数中对其进行修改</p>\n<p>类的GetBalance函数的函数体在整个Account类可见之后才被处理.</p>\n<p>编译器看到GetBalance的声明后 开始从类内(<strong>类内会从使用Money前查找</strong>)到类外寻找Money声明, 然后函数的返回值和bal成员变量的类型为double, 接着类可见之后处理函数体 函数会返回double类型的成员变量bal</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">double</span> Money;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> balance = <span class=\"string\">\"string\"</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// typedef std::string Money; 这里则不会报错</span></span><br><span class=\"line\">    Account() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    ~Account() = <span class=\"keyword\">default</span>;</span><br><span class=\"line\">    <span class=\"function\">Money <span class=\"title\">GetBalance</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123; <span class=\"keyword\">return</span> balance;  &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// typedef std::string Money; 会报错 因为由于GetBalance函数已经使用了外部的Money</span></span><br><span class=\"line\">    Money balance;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Account account;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; account.GetBalance(); <span class=\"comment\">// $ 0</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Foo(<span class=\"keyword\">int</span> val):</span><br><span class=\"line\">        bar1(val),</span><br><span class=\"line\">        bar2(bar1)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> bar1; <span class=\"comment\">// 更改两个顺序  将会导致先使用 bar1初始化bar2 然后使用val初始化bar1</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bar2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在我看了一些项目后使用的上面的写法, 然而这种写法却不合适 除非你严格按照变量顺序写.</p>\n<p>如果你将bar2和bar1的顺序不小心更换了, 难以排查的bug</p>\n<p><strong>使用默认构造函数声明对象 需要去掉对象名后的空括号对</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Foo <span class=\"title\">foo</span><span class=\"params\">()</span></span>; <span class=\"comment\">// 错误</span></span><br><span class=\"line\">Foo foo;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"隐式的类类型转换\"><a href=\"#隐式的类类型转换\" class=\"headerlink\" title=\"隐式的类类型转换\"></a>隐式的类类型转换</h3><p>如果构造函数只接受一个实参, 则它实际上定义了转换为此类类型的隐式转换机制 – 称这种构造函数为<strong>转换构造函数</strong></p>\n<p>Foo含有一个只有string类型的构造函数. 当一个函数的参数是Foo类型时. 你可以将string类型直接传递给这个函数. 会自动从string类型构造成Foo类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Value(string val); 可以加上explicit防止隐式类型转换</span></span><br><span class=\"line\"><span class=\"comment\">// void Add(Value val);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">string</span> val1 = <span class=\"string\">\"val1\"</span>;</span><br><span class=\"line\">foo.Add(val1); <span class=\"comment\">// 正确 隐式转换成Value</span></span><br><span class=\"line\">foo.Add(<span class=\"string\">\"val2\"</span>); <span class=\"comment\">// 错误 只能进行一步转换  需要从\"val2\"到string再到Value</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"聚合类-字面值常量类\"><a href=\"#聚合类-字面值常量类\" class=\"headerlink\" title=\"聚合类 字面值常量类\"></a>聚合类 字面值常量类</h3><p>聚合类</p>\n<ul>\n<li>所有成员都是public</li>\n<li>没有定义任何构造函数</li>\n<li>没有类内初始值</li>\n<li>没有基类也没有virtual函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> str;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> val;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tFoo foo = &#123;<span class=\"string\">\"1\"</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>字面值常量类</p>\n<ul>\n<li>数据成员都是字面值类型的聚合类</li>\n</ul>\n<p>如果一个类不是聚合类, 但是符合以下要求也是字面值类型常量类</p>\n<ul>\n<li>数据成员必须是字面值类型</li>\n<li>类必须含有一个constexpr构造函数</li>\n<li>如果一个数据成员含有类内初始值, 则初始值必须是一条常量表达式. 如果成员属于某种类类型, 则初始值必须使用成员自己的constexpr构造函数</li>\n<li>类必须使用默认析构函数</li>\n</ul>\n<h1 id=\"第二部分-cpp标准库\"><a href=\"#第二部分-cpp标准库\" class=\"headerlink\" title=\"第二部分 cpp标准库\"></a>第二部分 cpp标准库</h1><h2 id=\"第八章-IO库\"><a href=\"#第八章-IO库\" class=\"headerlink\" title=\"第八章 IO库\"></a>第八章 IO库</h2><p>想到了遇到过的<code>while(std::cin &gt;&gt; xx)</code>究竟是如何判断的呢? <code>&gt;&gt;</code>返回的对象是<code>std::cin</code>如何将其转换为<code>bool</code>?</p>\n<p>重载运算符</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">explicit</span> __CLR_OR_THIS_CALL <span class=\"keyword\">operator</span> <span class=\"title\">bool</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !fail();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">_NODISCARD <span class=\"keyword\">bool</span> __CLR_OR_THIS_CALL <span class=\"keyword\">operator</span>!() <span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fail();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"keyword\">operator</span> <span class=\"title\">bool</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">\t</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"operator *\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>!()</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"operator !\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tFoo foo;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (foo); <span class=\"comment\">// $ operator *</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!foo);<span class=\"comment\">// $ operator !</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>endl  换行 刷新缓冲区<br>flush 刷新缓冲区<br>ends  空字符 刷新缓冲区</p>\n<p>unitbuf 所有输出操作后都会立即刷新缓冲区<br>nounitbuf 恢复正常的缓冲方式</p>\n<h2 id=\"第九章-顺序容器\"><a href=\"#第九章-顺序容器\" class=\"headerlink\" title=\"第九章 顺序容器\"></a>第九章 顺序容器</h2><h3 id=\"习题-3\"><a href=\"#习题-3\" class=\"headerlink\" title=\"习题\"></a>习题</h3><p><strong>9.6 下面的程序有何错误 你应该如何修改它?</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt; lst1;</span><br><span class=\"line\"><span class=\"built_in\">list</span>&lt;<span class=\"keyword\">int</span>&gt;::iterator iter1 = lst1.<span class=\"built_in\">begin</span>(),</span><br><span class=\"line\">iter2 = lst1.<span class=\"built_in\">end</span>();</span><br><span class=\"line\"><span class=\"keyword\">while</span> (iter1 &lt; iter2)</span><br></pre></td></tr></table></figure>\n<p>将<code>while (iter1 &lt; iter2)</code> 改成<code>while(iter1 != iter2)</code><br>迭代器是指向元素的指针, 对于list来说比较元素指针大小无法判断<br>@@@@</p>\n<p><strong>9.12 对于接受一个容器创建其拷贝的构造函数 和 接收两个迭代器创建拷贝的构造函数之间的不同</strong></p>\n<p><strong>创建拷贝</strong>-要求容器类型和元素类型都相同<br><strong>接收两个迭代器</strong>-元素类型能够相互转化即可</p>\n<h3 id=\"函数说明\"><a href=\"#函数说明\" class=\"headerlink\" title=\"函数说明\"></a>函数说明</h3><p>assign函数 仅顺序容器</p>\n<ul>\n<li>用指定元素的拷贝 替换左侧容器中的所有元素</li>\n</ul>\n<p>swap函数</p>\n<ul>\n<li>只会真正交换array的元素 与长度有关</li>\n<li>其他容器会交换内部的数据结构 常数时间完成</li>\n</ul>\n<p>除了string指向容器的迭代器 引用和指针在swap操作之后都不会失效 仍指向swap操作前的元素,<br>但是这些元素已经属于不同的容器了</p>\n<p>关系运算符</p>\n<ul>\n<li>两个容器具有相同的大小 且所有元素两两对应相等 这两个容器相等 否则不等</li>\n<li>如果两个容器大小不同, 但较小的容器中每个元素都等于较大容器中对应元素 则较小容器 &gt; 较大容器</li>\n<li>比较结果取决于第一个不相等的元素的比较结果 类似 compare</li>\n</ul>\n<p>容器的运算符 非迭代器<br>== != 运算符 所有容器都支持<br>&lt; &lt;= &gt; &gt;= 运算符 无序关联容器不支持</p>\n<p>size_type 无符号整数 足够保存此种容器类型最大可能容器的大小<br>difference_type 带符号整数类型 足够保存两个迭代器之间的距离<br>value_type 元素类型</p>\n<p>除了array之外其他容器的默认构造函数会创建一个指定类型的<code>空容器</code></p>\n<p>只有<code>顺序容器</code>的<code>构造函数</code>才接<code>受大小参数</code> 关联容器并不支持</p>\n<p>如果元素类型是内置类型或者具有默认的构造函数的类类型,可以只为构造函数提供一个容器大小的参数<br>如果元素类型没有默认构造函数 除了容器大小参数 还必须指定一个显示的元素初始值</p>\n<p>只有支持随机访问容器的迭代器才支持<code>operator&lt;</code>, list只能使用<code>=</code>来判断迭代器</p>\n<p>成员访问函数<code>front</code>,<code>back</code>,<code>下标</code>,<code>at</code>访问返回的都是引用. 如果容器是一个const对象 则返回值是const的引用 </p>\n<p>大多数会使迭代器失效的函数如erase<code>会在调用后返回删除的后一个元素位置的迭代器</code>, 使用返回值替换原来的迭代器可以在删除元素的情况下遍历所有元素</p>\n<p>不要保存end返回的迭代器, 添加删除vector或string元素后都会失效. <code>while (x != v.end())</code>或者是<code>for(; x != v.end();)</code></p>\n<p>向容器中添加元素</p>\n<ul>\n<li>目标是vector或string 且存储空间被重新分配, 则指向容器的迭代器指针引用都会失效. 如果存储空间没有被重新分配, 则插入位置后的三者都会失效</li>\n<li>目标是deque 插入到除首尾之外的任何位置都会使三者失效 首尾添加元素则迭代器失效 但是指向存在元素的引用和指针不会失效</li>\n<li>对于list和forward_list 三者仍然有效</li>\n</ul>\n<p>从容器中删除元素</p>\n<ul>\n<li>vector和string 被删元素之前的三者仍有效</li>\n<li>list和forward_list 三者仍有效</li>\n<li>deque 首尾之外的任何位置删除元素 指向被删除元素外<code>其他任何元素</code>的三者也会失效 如果删除尾元素则<code>尾后迭代器</code>失效 其他迭代器和指针不受影响</li>\n</ul>\n<h2 id=\"第十章-泛型算法\"><a href=\"#第十章-泛型算法\" class=\"headerlink\" title=\"第十章 泛型算法\"></a>第十章 泛型算法</h2><p>迭代器使得算法不依赖于容器, 可以解引用迭代器得到值, 也可以移动访问其他元素</p>\n<p>不过迭代器依赖于元素类型 因为会使用如<code>==</code> <code>&lt;</code>之类的操作符 作用在元素上得到结果</p>\n<p>小小accumulate也有很多细节问题</p>\n<ul>\n<li>函数的返回值类型与第三个参数相同, 需要序列中元素能够转换成第三个参数的类型</li>\n<li>遍历元素的结果是加在第三个参数上的</li>\n</ul>\n<p>一个lambad只有在其捕获列表中捕获一个他所在函数中的局部变量, 才能在函数体中使用该变量.</p>\n<p>捕获列表只用于局部非static变量, lambda可以直接使用局部static变量和他所在函数之外声明的名字</p>\n<p><code>值传递</code>的变量在lambda创建的时候进行拷贝, 所以随后的修改不会影响到lambda内的值</p>\n<p><code>引用捕获</code>的则需要确保在lambda执行期间, 被引用的变量时存在的</p>\n<p>| 形式 | 说明 |<br>| <code>[]</code> | 空捕获列表. lambda不能使用所在函数变量 |<br>| <code>[names]</code> | 逗号分隔的所在函数的局部变量列表. 默认使用拷贝, 如果变量名前有&amp;则使用引用 |<br>| <code>[&amp;]</code> | 隐式捕获列表, 引用捕获 |<br>| <code>[=]</code> | 隐式捕获列表, 值捕获 |<br>| <code>[&amp;, names]</code> | 引用捕获, names列表使用值捕获 |<br>| <code>[=, names]</code> | 值捕获, names列表使用引用捕获 |</p>\n<p>谓词 - 一个可调用的表达式, 其返回结果是一个能用做条件的值</p>\n<ul>\n<li>一元谓词 只接收单一参数</li>\n<li>二元谓词 有两个参数</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>find_if</td>\n<td></td>\n</tr>\n<tr>\n<td>for_each</td>\n<td></td>\n</tr>\n<tr>\n<td>bind</td>\n<td>参数绑定, 可以进行诸如 一二元谓词互换的操作 参数重排 绑定引用参数</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>返回对象的引用</td>\n</tr>\n</tbody></table>\n<ol>\n<li>普通迭代器</li>\n<li>插入迭代器</li>\n</ol>\n<ul>\n<li>back_inserter 创建一个使用push_back的迭代器(需容器支持push_back)</li>\n<li>front_inserter 创建一个使用push_front的迭代器(需容器支持push_front)</li>\n<li>insterer 创建一个使用insert的迭代器</li>\n</ul>\n<ol start=\"3\">\n<li>流迭代器</li>\n</ol>\n<ul>\n<li>istream_iterator</li>\n<li>ostream_iterator</li>\n</ul>\n<ol start=\"4\">\n<li>反向迭代器 - 除了forward_list均支持</li>\n</ol>\n<p>算法要求的迭代器类型 五类迭代器</p>\n<ul>\n<li>输入迭代器 只读, 不写, 单边扫描, 只能递增</li>\n<li>输出迭代器 只写, 不读, 单边扫描, 只能递增</li>\n<li>前向迭代器 读写 多遍 只能递增</li>\n<li>双向迭代器 读写 多遍 增减都可</li>\n<li>随机访问迭代器 读写 多遍 支持全部迭代器运算</li>\n</ul>\n<h2 id=\"第十二章-动态内存与智能指针\"><a href=\"#第十二章-动态内存与智能指针\" class=\"headerlink\" title=\"第十二章 动态内存与智能指针\"></a>第十二章 动态内存与智能指针</h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/CPPPrimer/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png\" alt=\"\"></p>\n<p><strong>make_share</strong></p>\n<p><strong>shared_ptr的拷贝和赋值</strong><br>当进行拷贝或者赋值操作时候 shared_ptr都会记录有多少个其他的shared_ptr<br>指向相同的对象</p>\n<p>引用计数增加的情况</p>\n<ul>\n<li>拷贝shared_ptr </li>\n<li>初始化其他shared_ptr指针</li>\n<li>作为参数传递给一个函数</li>\n<li>作为函数的返回值</li>\n</ul>\n<p>引用计数减少</p>\n<ul>\n<li>赋予新值</li>\n<li>被销毁(例如离开作用域)</li>\n</ul>\n<p>当引用计数为0的时候, 就会释放自己管理的对象</p>\n<p><strong>使用动态内存的原因</strong></p>\n<ul>\n<li>程序不知道自己需要使用多少对象 容器类</li>\n<li>程序不知道所需对象的准确类型</li>\n<li>程序需要在多个对象间共享数据</li>\n</ul>\n<p><strong>程序需要在多个对象间共享数据</strong><br>一般情况</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v1; <span class=\"comment\">// empty</span></span><br><span class=\"line\">&#123; <span class=\"comment\">// 新的作用域</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v2 = &#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;;</span><br><span class=\"line\">\tv1 = v2;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 离开作用域 v2被销毁</span></span><br><span class=\"line\"><span class=\"comment\">// v1中有三个元素, 是原来三个元素的拷贝</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是我们要实现的情况</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v1; <span class=\"comment\">// empty</span></span><br><span class=\"line\">&#123; <span class=\"comment\">// 新的作用域</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v2 = &#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;;</span><br><span class=\"line\">\tv1 = v2; <span class=\"comment\">// v1 v2共享相同的元素</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 离开作用域 v2被销毁 但v2的元素不能被销毁</span></span><br><span class=\"line\"><span class=\"comment\">// v1中有三个元素, 指向原来三个元素</span></span><br></pre></td></tr></table></figure>\n\n<p>创建一个类来管理这个vector, 但是不能直接保存在其中, 因为当这个类的对象销毁的时候内部的vector也就销毁<br>所以需要保存在动态内存中</p>\n<p>所以使用shared_ptr来管理动态分配的vector, 当最后一个vector的使用者被销毁的时候才释放内存</p>\n<p>确定下这个类提供的操作</p>\n<ul>\n<li>修改元素的操作会进行校验 不合法则抛出异常</li>\n<li>默认构造函数</li>\n<li>接受单一的initiaizer_list&lt;string&gt;类型的参数. 这个参数可以接受一个初始器的花括号列表</li>\n</ul>\n<p><strong>直接管理内存</strong></p>\n<p>了解到两个概念 一个<code>默认初始化</code>一个<code>值初始化</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i, *pi1 = &amp;i, *pi2 = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> *pd = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>(<span class=\"number\">33</span>), *pd2 = pd;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> i; <span class=\"comment\">// 错误 i不是指针</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pi1; <span class=\"comment\">// 未定义 pi1指向一个局部变量 具有潜在性危害</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pd; <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pd2; <span class=\"comment\">// 未定义 内存已经被释放 具有潜在性危害</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pi2; <span class=\"comment\">// 正确 释放空指针没有错误</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *pci = <span class=\"keyword\">new</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">delete</span> pci <span class=\"comment\">// 正确 释放一个const对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// delete之后指针就变成了`空悬指针` 需要将其置为`nullptr`</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>shared_ptr和new结合使用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误智能指针构造函数是explicit</span></span><br><span class=\"line\"><span class=\"comment\">// 无法将内置指针隐式转换成一个智能指针, 必须使用直接初始化</span></span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确  使用了直接初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>))</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>定义和改变方式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p管理内置指针q所指向的对象, q必须指向new分配的内存, 且能够转换为T*类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(q)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p从unique_ptr u那里接管了对象的所有权 将U置为空</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p 接管了内置指针q所指向的对象的所有权, q必须能转化为T* 类型</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p将使用可调用对象d来代替delete</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(q, d)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p是shared_ptr p2的拷贝</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p将用可调用对象d来代替delete</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(p2, d)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 若p是唯一指向其对象的shared_ptr, reset会释放此对象</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 如果传递了可选的参数-内置指针q, 则会令p指向q 否则将p置为空</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 如果还传递了d, 会调用d而不是delete来释放q</span></span></span><br><span class=\"line\">p.reset()</span><br><span class=\"line\">p.reset(q)</span><br><span class=\"line\">p.reset(q, d)</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong></p>\n<p>使用unique_ptr的时候要注意</p>\n<ol>\n<li><p>不要在函数调用传参的括号中 使用临时变量 这样一旦函数调用完成就会被销毁</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; ptr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">42</span> ))</span> </span>; <span class=\"comment\">// 引用 = 1</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(p); <span class=\"comment\">// 拷贝 会递增它的引用计数 ;在 process 中引用计数位为2</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = *p; <span class=\"comment\">// 正确 引用计数为1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">x</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>))</span></span>; <span class=\"comment\">// 危险 这是一个普通指针，不是一个智能指针</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(x) ; <span class=\"comment\">// 错误 不能将 int* 转换为 一个 shared_ptr&lt;int&gt; </span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; (x)); <span class=\"comment\">// 合法的，但内存会被释放! 因为临时对象会被销毁</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> j =*x <span class=\"comment\">//未定义的 是一个空悬指针!</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果使用智能指针不要使用get函数初始化另一个智能指针或为其赋值<br>因为一旦新生成的智能指针离开作用域或者被释放, 会影响到原来的智能指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>); <span class=\"comment\">// 不能将一个int* 赋值给shared_ptr&lt;int&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p1;</span><br><span class=\"line\">p1.reset(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>)); <span class=\"comment\">// 可以</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>))</span></span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用make_share来创建shared_ptr指针</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p3 = <span class=\"built_in\">std</span>::make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">auto</span> p4 = <span class=\"built_in\">std</span>::make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// make_share不能用来创建unique_ptr</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; d;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">d1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>))</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ol>\n<ol start=\"3\">\n<li>unique_ptr不支持普通的赋值和拷贝操作, 因为unique_ptr要独占所指向的对象<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">d1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1</span>))</span></span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">d2</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>))</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\">d1.<span class=\"built_in\">release</span>(); <span class=\"comment\">// 释放原来所指向的对象</span></span><br><span class=\"line\">d1.reset(d2.<span class=\"built_in\">release</span>()); <span class=\"comment\">// d2释放后由d1获取</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p><strong>智能指针陷阱</strong></p>\n<ol>\n<li>不使用相同的内置指针值初始化(或reset)多个智能指针</li>\n<li>不使用delete get返回的指针</li>\n<li>不使用get初始化或者reset另一个智能指针</li>\n<li>如果你使用get返回指针, 当最后一个对应的智能指针销毁 这个指针就变成了垂悬指针</li>\n<li>使用智能指针管理非new分配的内存, 需要传递一个删除器.</li>\n</ol>\n<p><strong>weak_ptr</strong><br>不控制所指向对象生存周期, 指向一个shared_ptr管理的对象.</p>\n<p>由于weak_ptr不参与对应的shared_ptr的引用计数, vector可能已经被释放了<br>释放后 lock将返回一个空指针</p>\n<p><strong>allocator 将内存的分配和对象的构造分离开</strong></p>\n<h1 id=\"第三部分-类设计者的工具\"><a href=\"#第三部分-类设计者的工具\" class=\"headerlink\" title=\"第三部分 类设计者的工具\"></a>第三部分 类设计者的工具</h1><h2 id=\"模板与泛型编程\"><a href=\"#模板与泛型编程\" class=\"headerlink\" title=\"模板与泛型编程\"></a>模板与泛型编程</h2><p><code>template &lt;typename T&gt;</code></p>\n<p>编译器用推断出的模板参数来<code>实例化</code>一个特定版本的函数.<br>不同的模板参数类型<code>实例化</code>出不同的函数 然后进行调用.</p>\n<p><strong>模板类型参数</strong></p>\n<p>如果有多个模板参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, U&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">U</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>非类型模板参数</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">unsigned</span> N, <span class=\"keyword\">unsigned</span> M&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p1)[N], <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p2)[M])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>(p1, p2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">compare(<span class=\"string\">\"hi\"</span>, <span class=\"string\">\"mmm\"</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p1)[<span class=\"number\">3</span>], <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p2)[<span class=\"number\">4</span>])</span> <span class=\"comment\">// 注意空字符</span></span></span><br></pre></td></tr></table></figure>\n<p>编译器会使用字面常量的大小来代替N和M, 从而实例化模板</p>\n<p>非类型参数可以使<code>整形</code>或者是一个指向对象或者函数类型的<code>指针</code>或者<code>(左值)引用</code><br>绑定到<code>非类型整数参数</code>的实参必须是一个常量表达式.<br>绑定到<code>指针</code>或者<code>引用非类型模板参数</code>的实参必须具有静态的生存期</p>\n<p>静态内存用来保存<code>局部static对象</code>, <code>类static数据成员</code>和<code>定义于任何函数之外的变量</code><br>栈内存用来保存定义在函数内的非static对象.<br>分配在静态内存和栈内存的由编译器自动创建和销毁</p>\n<p>堆 用来存储动态分配的对象</p>\n<p>编译器遇到一个模板类型定义的时候并不会生成代码, 而是实例化出一个特定版本的时候才会实例化</p>\n<p><strong>使用类的类型成员</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">T::size_type* p;</span><br></pre></td></tr></table></figure>\n<p>默认情况下, C++语言假定通过域运算符访问名字而不是类型.<br>如果想要使用模板类型参数(T)的类型成员(size_type) 必须使用<code>typename</code>而不是<code>class</code></p>\n<p><strong>默认模板实参</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> F = less&lt;T&gt;&gt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> compare(<span class=\"keyword\">const</span> T&amp; v1, <span class=\"keyword\">const</span> T&amp; v2, F f = f())</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (f(v1, v2)) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (f(v2, v1)) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"第四部分-高级主题\"><a href=\"#第四部分-高级主题\" class=\"headerlink\" title=\"第四部分 高级主题\"></a>第四部分 高级主题</h1><p>tuple这里看了, 例子写了总感觉实用性不是很大? 或许可以用在便捷处理输入参数?</p>\n<p>biset感觉还是有点用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">bitset</span>&lt;32&gt; b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下位不足 高位都补0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> u = ULLONG_MAX;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">bitset</span>&lt;32&gt; <span class=\"title\">bu</span><span class=\"params\">(u)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> s1 = <span class=\"string\">\"10101010101010\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">bitset</span>&lt;32&gt; <span class=\"title\">bs1</span><span class=\"params\">(s1)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> s2 = <span class=\"string\">\"ababaabbababb\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// std::bitset&lt;32&gt; bs2(s2); std::invalid_argument</span></span><br><span class=\"line\"><span class=\"comment\">// a instand 0 b instand 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">bitset</span>&lt;32&gt; <span class=\"title\">bs2</span><span class=\"params\">(s2, <span class=\"number\">0</span>, <span class=\"number\">32</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bu.any(); <span class=\"comment\">// 存在 置位(1) 的二进制位吗</span></span><br><span class=\"line\">bu.all(); <span class=\"comment\">// 所有位都置位了吗</span></span><br><span class=\"line\">bu.none(); <span class=\"comment\">// b中不存在置位的二进制位吗</span></span><br><span class=\"line\">bu.count(); <span class=\"comment\">// 置位数目</span></span><br><span class=\"line\">bu.<span class=\"built_in\">size</span>(); <span class=\"comment\">// 数目</span></span><br><span class=\"line\"></span><br><span class=\"line\">bu.test(<span class=\"number\">1</span>); <span class=\"comment\">// 位置1是置位的返回true 否则返回false</span></span><br><span class=\"line\">bu.<span class=\"built_in\">set</span>(<span class=\"number\">1</span>, <span class=\"literal\">true</span>); <span class=\"comment\">// 将1位 置 true-&gt;1 false-&gt;0</span></span><br><span class=\"line\">bu.reset(<span class=\"number\">1</span>); <span class=\"comment\">// 将1位复位 置0</span></span><br><span class=\"line\">bu.reset(); <span class=\"comment\">// 将所有位复位 置0</span></span><br><span class=\"line\"></span><br><span class=\"line\">bu.flip(<span class=\"number\">1</span>); <span class=\"comment\">// 1位取反</span></span><br><span class=\"line\">bu.flip(); <span class=\"comment\">// 全部取反</span></span><br><span class=\"line\">bu[<span class=\"number\">1</span>].flip();</span><br><span class=\"line\"></span><br><span class=\"line\">bu[<span class=\"number\">1</span>]; <span class=\"comment\">// 1位 1-&gt;true 0-&gt;false</span></span><br><span class=\"line\"></span><br><span class=\"line\">bu.to_ulong();</span><br><span class=\"line\">bu.to_ullong();</span><br><span class=\"line\"></span><br><span class=\"line\">bu.to_string(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>); <span class=\"comment\">// 0-&gt;a 1-&gt;b</span></span><br></pre></td></tr></table></figure>\n\n"},{"title":"Linux高性能服务器-理论部分","date":"2020-03-06T14:53:00.000Z","top":99,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg","_content":"距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.\n半年后开始准备补上这四章\n\n2020年7月16日12:37:33\n\n大二暑假了, 准备把这本书没读完的部分 读完 整理下已读的部分\n基础理论部分, 由于已经上完了计算机网络这门课, 另出了一篇博客. 这里就不详细写了\n主要整理后面的内容分\n\n\n\n\n# 第一章 TCP/IP协议族\n## TCP/IP协议族体系结构和主要协议\n协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg)\n\n不同层次之间, 通过接口互相交流, 这样方便了各层次的修改\n\n**应用层**\n负责处理应用程序的逻辑\n\n**表示层**\n定义了数据的格式及加密\n\n**会话层**\n它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的\n\n**传输层**\n为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.\n此层存在两大协议TCP协议和UDP协议\nTCP协议(Transmission Control Protocol 传输控制协议)\n- 为应用层提供`可靠的, 面向连接, 基于流的服务`\n- 通过`超时重传`和`数据确认`等确保数据正常送达.\n- TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器\n```\n0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Source Port          |       Destination Port        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sequence Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Acknowledgment Number                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Data |           |U|A|P|R|S|F|                               |\n| Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n|       |           |G|K|H|T|N|N|                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Checksum            |         Urgent Pointer        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             data                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n\n\nUPD协议(User Datagram Protocol 用户数据报协议)\n- 为应用层提供`不可靠的, 无连接的, 基于数据报的服务`\n- 一般需要自己处理`数据确认`和`超时重传`的问题\n- 通信两者不存储状态, 每次发送都需要指定地址信息. `有自己的长度`\n```\n 0      7 8     15 16    23 24    31\n+--------+--------+--------+--------+\n|     Source      |   Destination   |\n|      Port       |      Port       |\n+--------+--------+--------+--------+\n|                 |                 |\n|     Length      |    Checksum     |\n+--------+--------+--------+--------+\n|\n|          data octets ...\n+---------------- ...\n\n    User Datagram Header Format\n```\n\n\n\n**网络层**\n实现了数据包的选路和转发.  只有数据包到不了目标地址, 就`下一跳`(hop by hop), 选择最近的.\n*IP协议(Internet Protocol)* 以及 *ICMP协议(Internet Control Message Protocol)* \n后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)\n\n**数据链路层**\n实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.\n存在两个协议 *ARP协议(Address Resolve Protocol, 地址解析协议)*. 还有*RARP(Reverse ~, 逆地址解析协议)*.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议*ARP欺骗, 可能与这个有关, 目前不去学习*\n\n**封装**\n上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.\n被TCP封装的数据成为 `TCP报文段`\n- 内核部分发送成功后删除数据\n\n被UDP封装的数据成为 `UDP数据报`\n- 发送后即删除\n\n再经IP封装后成为`IP数据报`\n最后经过数据链路层封装后为 `帧`\n\n以太网最大数据帧1518字节 抛去14头部 帧尾4校验\nMTU: 帧的最大传输单元 一般为1500字节\nMSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头 - 20TCP头 还有额外的40字节可选部分\n\n**ARP**\nARP协议能实现任意网络层地址到任意物理地址的转换\n\n# 第二章 IP协议详解\nIP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一\nIP协议为上层协议提供无状态, 无连接, 不可靠的服务\n\nIP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制\n\n当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png)\n\n\n路由机制\n\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png)\n\n\n给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤\n- 查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步\n- 查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到....... 否则下一步\n- 选择默认路由项, 通常意味着下一跳路由是网关\n\n\n# 第三章 TCP协议详解\n\nTcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.\n\nUDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断\n\nISN-初始序号值\n32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移\n32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答\n\nACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为`确认报文段`\nPSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间\nRST标志: 要求对方重新建立连接 携带......`复位报文段`\nSYN标志: 标志请求建立一个连接 携带......`同步报文段`\nFIN标志: 通知对方本端连接要关闭了, 携带..`结束报文段`\n\n16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据\n16位校验和: `可靠传输的重要保障`发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验`TCP头部`和`数据部分`\n\n额外参数之窗口扩大因子, TCP连接初始化时, 双方使用该选项协商通告窗口的扩大因子. \n通告窗口大小是16位即最大65535字节, 但实际会比这个要大\n假设通告窗口大小为N, 扩大因子是M(位移数, 0-14) 实际通告窗口大小为 N*2^M, 或者称为N左移M位\n\n\n**TCP连接的建立和关闭**\n\n```s\n# 同步报文段 需要占用一个序号值\n\n10:19:15.870206 IP localhost.46836 > localhost.8222: Flags [S], seq 559157932, win 43690, options [mss 65495,sackOK,TS val 2968784041 ecr 0,nop,wscale 7], length 0\n10:19:15.870219 IP localhost.8222 > localhost.46836: Flags [S.], seq 900113542, ack 559157933, win 43690, options [mss 65495,sackOK,TS val 2968784041 ecr 2968784041,nop,wscale 7], length 0\n10:19:15.870228 IP localhost.46836 > localhost.8222: Flags [.], ack 1, win 342, options [nop,nop,TS val 2968784041 ecr 2968784041], length 0\n\n10:19:18.113588 IP localhost.46836 > localhost.8222: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 2968786284 ecr 2968784041], length 0\n# 由于被动方没有数据要发送同时发送了 FIN ACK \n10:19:18.113664 IP localhost.8222 > localhost.46836: Flags [F.], seq 1, ack 2, win 342, options [nop,nop,TS val 2968786284 ecr 2968786284], length 0\n10:19:18.113678 IP localhost.46836 > localhost.8222: Flags [.], ack 2, win 342, options [nop,nop,TS val 2968786284 ecr 2968786284], length 0\n\n\n# 完整序号\n10:31:15.259169 IP localhost.46944 > localhost.8222: Flags [S], seq 898081536, win 43690, options [mss 65495,sackOK,TS val 2969503401 ecr 0,nop,wscale 7], length 0\n10:31:15.259180 IP localhost.8222 > localhost.46944: Flags [S.], seq 3168567292, ack 898081537, win 43690, options [mss 65495,sackOK,TS val 2969503401 ecr 2969503401,nop,wscale 7], length 0\n10:31:15.259190 IP localhost.46944 > localhost.8222: Flags [.], ack 3168567293, win 342, options [nop,nop,TS val 2969503401 ecr 2969503401], length 0\n\n10:31:17.144633 IP localhost.46944 > localhost.8222: Flags [F.], seq 898081537, ack 3168567293, win 342, options [nop,nop,TS val 2969505287 ecr 2969503401], length 0\n10:31:17.144800 IP localhost.8222 > localhost.46944: Flags [F.], seq 3168567293, ack 898081538, win 342, options [nop,nop,TS val 2969505287 ecr 2969505287], length 0\n10:31:17.144814 IP localhost.46944 > localhost.8222: Flags [.], ack 3168567294, win 342, options [nop,nop,TS val 2969505287 ecr 2969505287], length 0\n\n```\n\n**TCP超时重传**\nTCP服务必须能够进行超时重传\n这就需要为每个TCP报文段维护一个重传定时器, 发送时启动\n如果超时后依然没有收到回复则进行重发 并重置定时器\n\n超时时间 0.2 0.4 0.8 1.6 3.2 单位是秒, 类似TCP超时重连\n重传最多次数 默认15\n\n**拥塞控制**\n提高网络利用率, 降低丢包率 保证网络资源对每条数据流的公平性 --拥塞控制\n\n# 第四章TCP/IP通信案例\n\n上游服务器: 一个HTTP请求可能被多个代理服务器转发, 后面的服务器称为前面的服务器的上游服务器\n\n正向代理服务器: 要求客户端自己设置代理服务器的地址, 客户将每次请求都直接发送到该代理服务器,并由代理服务器来请求目标资源\n反向代理服务器: 被设置在服务器端, 客户端无需进行设置. 用代理服务器接收网络上的请求, 然后将请求转发给内网上的服务器, 并将从内部服务器上得到的结果返回给客户端, 代理服务器对外表现为一个真正的服务器.\n","source":"_posts/读书记录99-高性能服务器编程读书记录理论部分.md","raw":"---\ntitle: Linux高性能服务器-理论部分\ntags:\n  - null\ncategories:\n  - 读书记录\ndate: 2020-03-06 22:53:00\ntop: 99\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg\n---\n距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.\n半年后开始准备补上这四章\n\n2020年7月16日12:37:33\n\n大二暑假了, 准备把这本书没读完的部分 读完 整理下已读的部分\n基础理论部分, 由于已经上完了计算机网络这门课, 另出了一篇博客. 这里就不详细写了\n主要整理后面的内容分\n\n\n\n\n# 第一章 TCP/IP协议族\n## TCP/IP协议族体系结构和主要协议\n协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg)\n\n不同层次之间, 通过接口互相交流, 这样方便了各层次的修改\n\n**应用层**\n负责处理应用程序的逻辑\n\n**表示层**\n定义了数据的格式及加密\n\n**会话层**\n它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的\n\n**传输层**\n为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.\n此层存在两大协议TCP协议和UDP协议\nTCP协议(Transmission Control Protocol 传输控制协议)\n- 为应用层提供`可靠的, 面向连接, 基于流的服务`\n- 通过`超时重传`和`数据确认`等确保数据正常送达.\n- TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器\n```\n0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Source Port          |       Destination Port        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sequence Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Acknowledgment Number                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Data |           |U|A|P|R|S|F|                               |\n| Offset| Reserved  |R|C|S|S|Y|I|            Window             |\n|       |           |G|K|H|T|N|N|                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           Checksum            |         Urgent Pointer        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Options                    |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             data                              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n\n\nUPD协议(User Datagram Protocol 用户数据报协议)\n- 为应用层提供`不可靠的, 无连接的, 基于数据报的服务`\n- 一般需要自己处理`数据确认`和`超时重传`的问题\n- 通信两者不存储状态, 每次发送都需要指定地址信息. `有自己的长度`\n```\n 0      7 8     15 16    23 24    31\n+--------+--------+--------+--------+\n|     Source      |   Destination   |\n|      Port       |      Port       |\n+--------+--------+--------+--------+\n|                 |                 |\n|     Length      |    Checksum     |\n+--------+--------+--------+--------+\n|\n|          data octets ...\n+---------------- ...\n\n    User Datagram Header Format\n```\n\n\n\n**网络层**\n实现了数据包的选路和转发.  只有数据包到不了目标地址, 就`下一跳`(hop by hop), 选择最近的.\n*IP协议(Internet Protocol)* 以及 *ICMP协议(Internet Control Message Protocol)* \n后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)\n\n**数据链路层**\n实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.\n存在两个协议 *ARP协议(Address Resolve Protocol, 地址解析协议)*. 还有*RARP(Reverse ~, 逆地址解析协议)*.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议*ARP欺骗, 可能与这个有关, 目前不去学习*\n\n**封装**\n上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.\n被TCP封装的数据成为 `TCP报文段`\n- 内核部分发送成功后删除数据\n\n被UDP封装的数据成为 `UDP数据报`\n- 发送后即删除\n\n再经IP封装后成为`IP数据报`\n最后经过数据链路层封装后为 `帧`\n\n以太网最大数据帧1518字节 抛去14头部 帧尾4校验\nMTU: 帧的最大传输单元 一般为1500字节\nMSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头 - 20TCP头 还有额外的40字节可选部分\n\n**ARP**\nARP协议能实现任意网络层地址到任意物理地址的转换\n\n# 第二章 IP协议详解\nIP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一\nIP协议为上层协议提供无状态, 无连接, 不可靠的服务\n\nIP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制\n\n当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png)\n\n\n路由机制\n\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png)\n\n\n给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤\n- 查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步\n- 查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到....... 否则下一步\n- 选择默认路由项, 通常意味着下一跳路由是网关\n\n\n# 第三章 TCP协议详解\n\nTcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.\n\nUDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断\n\nISN-初始序号值\n32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移\n32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答\n\nACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为`确认报文段`\nPSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间\nRST标志: 要求对方重新建立连接 携带......`复位报文段`\nSYN标志: 标志请求建立一个连接 携带......`同步报文段`\nFIN标志: 通知对方本端连接要关闭了, 携带..`结束报文段`\n\n16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据\n16位校验和: `可靠传输的重要保障`发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验`TCP头部`和`数据部分`\n\n额外参数之窗口扩大因子, TCP连接初始化时, 双方使用该选项协商通告窗口的扩大因子. \n通告窗口大小是16位即最大65535字节, 但实际会比这个要大\n假设通告窗口大小为N, 扩大因子是M(位移数, 0-14) 实际通告窗口大小为 N*2^M, 或者称为N左移M位\n\n\n**TCP连接的建立和关闭**\n\n```s\n# 同步报文段 需要占用一个序号值\n\n10:19:15.870206 IP localhost.46836 > localhost.8222: Flags [S], seq 559157932, win 43690, options [mss 65495,sackOK,TS val 2968784041 ecr 0,nop,wscale 7], length 0\n10:19:15.870219 IP localhost.8222 > localhost.46836: Flags [S.], seq 900113542, ack 559157933, win 43690, options [mss 65495,sackOK,TS val 2968784041 ecr 2968784041,nop,wscale 7], length 0\n10:19:15.870228 IP localhost.46836 > localhost.8222: Flags [.], ack 1, win 342, options [nop,nop,TS val 2968784041 ecr 2968784041], length 0\n\n10:19:18.113588 IP localhost.46836 > localhost.8222: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 2968786284 ecr 2968784041], length 0\n# 由于被动方没有数据要发送同时发送了 FIN ACK \n10:19:18.113664 IP localhost.8222 > localhost.46836: Flags [F.], seq 1, ack 2, win 342, options [nop,nop,TS val 2968786284 ecr 2968786284], length 0\n10:19:18.113678 IP localhost.46836 > localhost.8222: Flags [.], ack 2, win 342, options [nop,nop,TS val 2968786284 ecr 2968786284], length 0\n\n\n# 完整序号\n10:31:15.259169 IP localhost.46944 > localhost.8222: Flags [S], seq 898081536, win 43690, options [mss 65495,sackOK,TS val 2969503401 ecr 0,nop,wscale 7], length 0\n10:31:15.259180 IP localhost.8222 > localhost.46944: Flags [S.], seq 3168567292, ack 898081537, win 43690, options [mss 65495,sackOK,TS val 2969503401 ecr 2969503401,nop,wscale 7], length 0\n10:31:15.259190 IP localhost.46944 > localhost.8222: Flags [.], ack 3168567293, win 342, options [nop,nop,TS val 2969503401 ecr 2969503401], length 0\n\n10:31:17.144633 IP localhost.46944 > localhost.8222: Flags [F.], seq 898081537, ack 3168567293, win 342, options [nop,nop,TS val 2969505287 ecr 2969503401], length 0\n10:31:17.144800 IP localhost.8222 > localhost.46944: Flags [F.], seq 3168567293, ack 898081538, win 342, options [nop,nop,TS val 2969505287 ecr 2969505287], length 0\n10:31:17.144814 IP localhost.46944 > localhost.8222: Flags [.], ack 3168567294, win 342, options [nop,nop,TS val 2969505287 ecr 2969505287], length 0\n\n```\n\n**TCP超时重传**\nTCP服务必须能够进行超时重传\n这就需要为每个TCP报文段维护一个重传定时器, 发送时启动\n如果超时后依然没有收到回复则进行重发 并重置定时器\n\n超时时间 0.2 0.4 0.8 1.6 3.2 单位是秒, 类似TCP超时重连\n重传最多次数 默认15\n\n**拥塞控制**\n提高网络利用率, 降低丢包率 保证网络资源对每条数据流的公平性 --拥塞控制\n\n# 第四章TCP/IP通信案例\n\n上游服务器: 一个HTTP请求可能被多个代理服务器转发, 后面的服务器称为前面的服务器的上游服务器\n\n正向代理服务器: 要求客户端自己设置代理服务器的地址, 客户将每次请求都直接发送到该代理服务器,并由代理服务器来请求目标资源\n反向代理服务器: 被设置在服务器端, 客户端无需进行设置. 用代理服务器接收网络上的请求, 然后将请求转发给内网上的服务器, 并将从内部服务器上得到的结果返回给客户端, 代理服务器对外表现为一个真正的服务器.\n","slug":"读书记录99-高性能服务器编程读书记录理论部分","published":1,"updated":"2020-12-05T02:31:35.592Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg7d0048f8unhb5b0531","content":"<p>距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.<br>半年后开始准备补上这四章</p>\n<p>2020年7月16日12:37:33</p>\n<p>大二暑假了, 准备把这本书没读完的部分 读完 整理下已读的部分<br>基础理论部分, 由于已经上完了计算机网络这门课, 另出了一篇博客. 这里就不详细写了<br>主要整理后面的内容分</p>\n<h1 id=\"第一章-TCP-IP协议族\"><a href=\"#第一章-TCP-IP协议族\" class=\"headerlink\" title=\"第一章 TCP/IP协议族\"></a>第一章 TCP/IP协议族</h1><h2 id=\"TCP-IP协议族体系结构和主要协议\"><a href=\"#TCP-IP协议族体系结构和主要协议\" class=\"headerlink\" title=\"TCP/IP协议族体系结构和主要协议\"></a>TCP/IP协议族体系结构和主要协议</h2><p>协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg\" alt=\"\"></p>\n<p>不同层次之间, 通过接口互相交流, 这样方便了各层次的修改</p>\n<p><strong>应用层</strong><br>负责处理应用程序的逻辑</p>\n<p><strong>表示层</strong><br>定义了数据的格式及加密</p>\n<p><strong>会话层</strong><br>它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的</p>\n<p><strong>传输层</strong><br>为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.<br>此层存在两大协议TCP协议和UDP协议<br>TCP协议(Transmission Control Protocol 传输控制协议)</p>\n<ul>\n<li>为应用层提供<code>可靠的, 面向连接, 基于流的服务</code></li>\n<li>通过<code>超时重传</code>和<code>数据确认</code>等确保数据正常送达.</li>\n<li>TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0                   1                   2                   3</span><br><span class=\"line\">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|          Source Port          |       Destination Port        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                        Sequence Number                        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                    Acknowledgment Number                      |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class=\"line\">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class=\"line\">|       |           |G|K|H|T|N|N|                               |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|           Checksum            |         Urgent Pointer        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                    Options                    |    Padding    |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                             data                              |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<p>UPD协议(User Datagram Protocol 用户数据报协议)</p>\n<ul>\n<li>为应用层提供<code>不可靠的, 无连接的, 基于数据报的服务</code></li>\n<li>一般需要自己处理<code>数据确认</code>和<code>超时重传</code>的问题</li>\n<li>通信两者不存储状态, 每次发送都需要指定地址信息. <code>有自己的长度</code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 0      7 8     15 16    23 24    31</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|     Source      |   Destination   |</span><br><span class=\"line\">|      Port       |      Port       |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|                 |                 |</span><br><span class=\"line\">|     Length      |    Checksum     |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|</span><br><span class=\"line\">|          data octets ...</span><br><span class=\"line\">+---------------- ...</span><br><span class=\"line\"></span><br><span class=\"line\">    User Datagram Header Format</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<p><strong>网络层</strong><br>实现了数据包的选路和转发.  只有数据包到不了目标地址, 就<code>下一跳</code>(hop by hop), 选择最近的.<br><em>IP协议(Internet Protocol)</em> 以及 <em>ICMP协议(Internet Control Message Protocol)</em><br>后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)</p>\n<p><strong>数据链路层</strong><br>实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.<br>存在两个协议 <em>ARP协议(Address Resolve Protocol, 地址解析协议)</em>. 还有<em>RARP(Reverse ~, 逆地址解析协议)</em>.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议<em>ARP欺骗, 可能与这个有关, 目前不去学习</em></p>\n<p><strong>封装</strong><br>上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.<br>被TCP封装的数据成为 <code>TCP报文段</code></p>\n<ul>\n<li>内核部分发送成功后删除数据</li>\n</ul>\n<p>被UDP封装的数据成为 <code>UDP数据报</code></p>\n<ul>\n<li>发送后即删除</li>\n</ul>\n<p>再经IP封装后成为<code>IP数据报</code><br>最后经过数据链路层封装后为 <code>帧</code></p>\n<p>以太网最大数据帧1518字节 抛去14头部 帧尾4校验<br>MTU: 帧的最大传输单元 一般为1500字节<br>MSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头 - 20TCP头 还有额外的40字节可选部分</p>\n<p><strong>ARP</strong><br>ARP协议能实现任意网络层地址到任意物理地址的转换</p>\n<h1 id=\"第二章-IP协议详解\"><a href=\"#第二章-IP协议详解\" class=\"headerlink\" title=\"第二章 IP协议详解\"></a>第二章 IP协议详解</h1><p>IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一<br>IP协议为上层协议提供无状态, 无连接, 不可靠的服务</p>\n<p>IP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制</p>\n<p>当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png\" alt=\"\"></p>\n<p>路由机制</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png\" alt=\"\"></p>\n<p>给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤</p>\n<ul>\n<li>查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步</li>\n<li>查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到……. 否则下一步</li>\n<li>选择默认路由项, 通常意味着下一跳路由是网关</li>\n</ul>\n<h1 id=\"第三章-TCP协议详解\"><a href=\"#第三章-TCP协议详解\" class=\"headerlink\" title=\"第三章 TCP协议详解\"></a>第三章 TCP协议详解</h1><p>Tcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.</p>\n<p>UDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断</p>\n<p>ISN-初始序号值<br>32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移<br>32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答</p>\n<p>ACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为<code>确认报文段</code><br>PSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间<br>RST标志: 要求对方重新建立连接 携带……<code>复位报文段</code><br>SYN标志: 标志请求建立一个连接 携带……<code>同步报文段</code><br>FIN标志: 通知对方本端连接要关闭了, 携带..<code>结束报文段</code></p>\n<p>16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据<br>16位校验和: <code>可靠传输的重要保障</code>发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验<code>TCP头部</code>和<code>数据部分</code></p>\n<p>额外参数之窗口扩大因子, TCP连接初始化时, 双方使用该选项协商通告窗口的扩大因子.<br>通告窗口大小是16位即最大65535字节, 但实际会比这个要大<br>假设通告窗口大小为N, 扩大因子是M(位移数, 0-14) 实际通告窗口大小为 N*2^M, 或者称为N左移M位</p>\n<p><strong>TCP连接的建立和关闭</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 同步报文段 需要占用一个序号值</span><br><span class=\"line\"></span><br><span class=\"line\">10:19:15.870206 IP localhost.46836 &gt; localhost.8222: Flags [S], seq 559157932, win 43690, options [mss 65495,sackOK,TS val 2968784041 ecr 0,nop,wscale 7], length 0</span><br><span class=\"line\">10:19:15.870219 IP localhost.8222 &gt; localhost.46836: Flags [S.], seq 900113542, ack 559157933, win 43690, options [mss 65495,sackOK,TS val 2968784041 ecr 2968784041,nop,wscale 7], length 0</span><br><span class=\"line\">10:19:15.870228 IP localhost.46836 &gt; localhost.8222: Flags [.], ack 1, win 342, options [nop,nop,TS val 2968784041 ecr 2968784041], length 0</span><br><span class=\"line\"></span><br><span class=\"line\">10:19:18.113588 IP localhost.46836 &gt; localhost.8222: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 2968786284 ecr 2968784041], length 0</span><br><span class=\"line\"># 由于被动方没有数据要发送同时发送了 FIN ACK </span><br><span class=\"line\">10:19:18.113664 IP localhost.8222 &gt; localhost.46836: Flags [F.], seq 1, ack 2, win 342, options [nop,nop,TS val 2968786284 ecr 2968786284], length 0</span><br><span class=\"line\">10:19:18.113678 IP localhost.46836 &gt; localhost.8222: Flags [.], ack 2, win 342, options [nop,nop,TS val 2968786284 ecr 2968786284], length 0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 完整序号</span><br><span class=\"line\">10:31:15.259169 IP localhost.46944 &gt; localhost.8222: Flags [S], seq 898081536, win 43690, options [mss 65495,sackOK,TS val 2969503401 ecr 0,nop,wscale 7], length 0</span><br><span class=\"line\">10:31:15.259180 IP localhost.8222 &gt; localhost.46944: Flags [S.], seq 3168567292, ack 898081537, win 43690, options [mss 65495,sackOK,TS val 2969503401 ecr 2969503401,nop,wscale 7], length 0</span><br><span class=\"line\">10:31:15.259190 IP localhost.46944 &gt; localhost.8222: Flags [.], ack 3168567293, win 342, options [nop,nop,TS val 2969503401 ecr 2969503401], length 0</span><br><span class=\"line\"></span><br><span class=\"line\">10:31:17.144633 IP localhost.46944 &gt; localhost.8222: Flags [F.], seq 898081537, ack 3168567293, win 342, options [nop,nop,TS val 2969505287 ecr 2969503401], length 0</span><br><span class=\"line\">10:31:17.144800 IP localhost.8222 &gt; localhost.46944: Flags [F.], seq 3168567293, ack 898081538, win 342, options [nop,nop,TS val 2969505287 ecr 2969505287], length 0</span><br><span class=\"line\">10:31:17.144814 IP localhost.46944 &gt; localhost.8222: Flags [.], ack 3168567294, win 342, options [nop,nop,TS val 2969505287 ecr 2969505287], length 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>TCP超时重传</strong><br>TCP服务必须能够进行超时重传<br>这就需要为每个TCP报文段维护一个重传定时器, 发送时启动<br>如果超时后依然没有收到回复则进行重发 并重置定时器</p>\n<p>超时时间 0.2 0.4 0.8 1.6 3.2 单位是秒, 类似TCP超时重连<br>重传最多次数 默认15</p>\n<p><strong>拥塞控制</strong><br>提高网络利用率, 降低丢包率 保证网络资源对每条数据流的公平性 –拥塞控制</p>\n<h1 id=\"第四章TCP-IP通信案例\"><a href=\"#第四章TCP-IP通信案例\" class=\"headerlink\" title=\"第四章TCP/IP通信案例\"></a>第四章TCP/IP通信案例</h1><p>上游服务器: 一个HTTP请求可能被多个代理服务器转发, 后面的服务器称为前面的服务器的上游服务器</p>\n<p>正向代理服务器: 要求客户端自己设置代理服务器的地址, 客户将每次请求都直接发送到该代理服务器,并由代理服务器来请求目标资源<br>反向代理服务器: 被设置在服务器端, 客户端无需进行设置. 用代理服务器接收网络上的请求, 然后将请求转发给内网上的服务器, 并将从内部服务器上得到的结果返回给客户端, 代理服务器对外表现为一个真正的服务器.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.<br>半年后开始准备补上这四章</p>\n<p>2020年7月16日12:37:33</p>\n<p>大二暑假了, 准备把这本书没读完的部分 读完 整理下已读的部分<br>基础理论部分, 由于已经上完了计算机网络这门课, 另出了一篇博客. 这里就不详细写了<br>主要整理后面的内容分</p>\n<h1 id=\"第一章-TCP-IP协议族\"><a href=\"#第一章-TCP-IP协议族\" class=\"headerlink\" title=\"第一章 TCP/IP协议族\"></a>第一章 TCP/IP协议族</h1><h2 id=\"TCP-IP协议族体系结构和主要协议\"><a href=\"#TCP-IP协议族体系结构和主要协议\" class=\"headerlink\" title=\"TCP/IP协议族体系结构和主要协议\"></a>TCP/IP协议族体系结构和主要协议</h2><p>协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg\" alt=\"\"></p>\n<p>不同层次之间, 通过接口互相交流, 这样方便了各层次的修改</p>\n<p><strong>应用层</strong><br>负责处理应用程序的逻辑</p>\n<p><strong>表示层</strong><br>定义了数据的格式及加密</p>\n<p><strong>会话层</strong><br>它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的</p>\n<p><strong>传输层</strong><br>为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.<br>此层存在两大协议TCP协议和UDP协议<br>TCP协议(Transmission Control Protocol 传输控制协议)</p>\n<ul>\n<li>为应用层提供<code>可靠的, 面向连接, 基于流的服务</code></li>\n<li>通过<code>超时重传</code>和<code>数据确认</code>等确保数据正常送达.</li>\n<li>TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0                   1                   2                   3</span><br><span class=\"line\">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|          Source Port          |       Destination Port        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                        Sequence Number                        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                    Acknowledgment Number                      |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|  Data |           |U|A|P|R|S|F|                               |</span><br><span class=\"line\">| Offset| Reserved  |R|C|S|S|Y|I|            Window             |</span><br><span class=\"line\">|       |           |G|K|H|T|N|N|                               |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|           Checksum            |         Urgent Pointer        |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                    Options                    |    Padding    |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class=\"line\">|                             data                              |</span><br><span class=\"line\">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ul>\n<p>UPD协议(User Datagram Protocol 用户数据报协议)</p>\n<ul>\n<li>为应用层提供<code>不可靠的, 无连接的, 基于数据报的服务</code></li>\n<li>一般需要自己处理<code>数据确认</code>和<code>超时重传</code>的问题</li>\n<li>通信两者不存储状态, 每次发送都需要指定地址信息. <code>有自己的长度</code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 0      7 8     15 16    23 24    31</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|     Source      |   Destination   |</span><br><span class=\"line\">|      Port       |      Port       |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|                 |                 |</span><br><span class=\"line\">|     Length      |    Checksum     |</span><br><span class=\"line\">+--------+--------+--------+--------+</span><br><span class=\"line\">|</span><br><span class=\"line\">|          data octets ...</span><br><span class=\"line\">+---------------- ...</span><br><span class=\"line\"></span><br><span class=\"line\">    User Datagram Header Format</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ul>\n<p><strong>网络层</strong><br>实现了数据包的选路和转发.  只有数据包到不了目标地址, 就<code>下一跳</code>(hop by hop), 选择最近的.<br><em>IP协议(Internet Protocol)</em> 以及 <em>ICMP协议(Internet Control Message Protocol)</em><br>后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)</p>\n<p><strong>数据链路层</strong><br>实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.<br>存在两个协议 <em>ARP协议(Address Resolve Protocol, 地址解析协议)</em>. 还有<em>RARP(Reverse ~, 逆地址解析协议)</em>.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议<em>ARP欺骗, 可能与这个有关, 目前不去学习</em></p>\n<p><strong>封装</strong><br>上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.<br>被TCP封装的数据成为 <code>TCP报文段</code></p>\n<ul>\n<li>内核部分发送成功后删除数据</li>\n</ul>\n<p>被UDP封装的数据成为 <code>UDP数据报</code></p>\n<ul>\n<li>发送后即删除</li>\n</ul>\n<p>再经IP封装后成为<code>IP数据报</code><br>最后经过数据链路层封装后为 <code>帧</code></p>\n<p>以太网最大数据帧1518字节 抛去14头部 帧尾4校验<br>MTU: 帧的最大传输单元 一般为1500字节<br>MSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头 - 20TCP头 还有额外的40字节可选部分</p>\n<p><strong>ARP</strong><br>ARP协议能实现任意网络层地址到任意物理地址的转换</p>\n<h1 id=\"第二章-IP协议详解\"><a href=\"#第二章-IP协议详解\" class=\"headerlink\" title=\"第二章 IP协议详解\"></a>第二章 IP协议详解</h1><p>IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一<br>IP协议为上层协议提供无状态, 无连接, 不可靠的服务</p>\n<p>IP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制</p>\n<p>当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png\" alt=\"\"></p>\n<p>路由机制</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png\" alt=\"\"></p>\n<p>给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤</p>\n<ul>\n<li>查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步</li>\n<li>查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到……. 否则下一步</li>\n<li>选择默认路由项, 通常意味着下一跳路由是网关</li>\n</ul>\n<h1 id=\"第三章-TCP协议详解\"><a href=\"#第三章-TCP协议详解\" class=\"headerlink\" title=\"第三章 TCP协议详解\"></a>第三章 TCP协议详解</h1><p>Tcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.</p>\n<p>UDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断</p>\n<p>ISN-初始序号值<br>32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移<br>32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答</p>\n<p>ACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为<code>确认报文段</code><br>PSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间<br>RST标志: 要求对方重新建立连接 携带……<code>复位报文段</code><br>SYN标志: 标志请求建立一个连接 携带……<code>同步报文段</code><br>FIN标志: 通知对方本端连接要关闭了, 携带..<code>结束报文段</code></p>\n<p>16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据<br>16位校验和: <code>可靠传输的重要保障</code>发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验<code>TCP头部</code>和<code>数据部分</code></p>\n<p>额外参数之窗口扩大因子, TCP连接初始化时, 双方使用该选项协商通告窗口的扩大因子.<br>通告窗口大小是16位即最大65535字节, 但实际会比这个要大<br>假设通告窗口大小为N, 扩大因子是M(位移数, 0-14) 实际通告窗口大小为 N*2^M, 或者称为N左移M位</p>\n<p><strong>TCP连接的建立和关闭</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 同步报文段 需要占用一个序号值</span><br><span class=\"line\"></span><br><span class=\"line\">10:19:15.870206 IP localhost.46836 &gt; localhost.8222: Flags [S], seq 559157932, win 43690, options [mss 65495,sackOK,TS val 2968784041 ecr 0,nop,wscale 7], length 0</span><br><span class=\"line\">10:19:15.870219 IP localhost.8222 &gt; localhost.46836: Flags [S.], seq 900113542, ack 559157933, win 43690, options [mss 65495,sackOK,TS val 2968784041 ecr 2968784041,nop,wscale 7], length 0</span><br><span class=\"line\">10:19:15.870228 IP localhost.46836 &gt; localhost.8222: Flags [.], ack 1, win 342, options [nop,nop,TS val 2968784041 ecr 2968784041], length 0</span><br><span class=\"line\"></span><br><span class=\"line\">10:19:18.113588 IP localhost.46836 &gt; localhost.8222: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 2968786284 ecr 2968784041], length 0</span><br><span class=\"line\"># 由于被动方没有数据要发送同时发送了 FIN ACK </span><br><span class=\"line\">10:19:18.113664 IP localhost.8222 &gt; localhost.46836: Flags [F.], seq 1, ack 2, win 342, options [nop,nop,TS val 2968786284 ecr 2968786284], length 0</span><br><span class=\"line\">10:19:18.113678 IP localhost.46836 &gt; localhost.8222: Flags [.], ack 2, win 342, options [nop,nop,TS val 2968786284 ecr 2968786284], length 0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 完整序号</span><br><span class=\"line\">10:31:15.259169 IP localhost.46944 &gt; localhost.8222: Flags [S], seq 898081536, win 43690, options [mss 65495,sackOK,TS val 2969503401 ecr 0,nop,wscale 7], length 0</span><br><span class=\"line\">10:31:15.259180 IP localhost.8222 &gt; localhost.46944: Flags [S.], seq 3168567292, ack 898081537, win 43690, options [mss 65495,sackOK,TS val 2969503401 ecr 2969503401,nop,wscale 7], length 0</span><br><span class=\"line\">10:31:15.259190 IP localhost.46944 &gt; localhost.8222: Flags [.], ack 3168567293, win 342, options [nop,nop,TS val 2969503401 ecr 2969503401], length 0</span><br><span class=\"line\"></span><br><span class=\"line\">10:31:17.144633 IP localhost.46944 &gt; localhost.8222: Flags [F.], seq 898081537, ack 3168567293, win 342, options [nop,nop,TS val 2969505287 ecr 2969503401], length 0</span><br><span class=\"line\">10:31:17.144800 IP localhost.8222 &gt; localhost.46944: Flags [F.], seq 3168567293, ack 898081538, win 342, options [nop,nop,TS val 2969505287 ecr 2969505287], length 0</span><br><span class=\"line\">10:31:17.144814 IP localhost.46944 &gt; localhost.8222: Flags [.], ack 3168567294, win 342, options [nop,nop,TS val 2969505287 ecr 2969505287], length 0</span><br></pre></td></tr></table></figure>\n\n<p><strong>TCP超时重传</strong><br>TCP服务必须能够进行超时重传<br>这就需要为每个TCP报文段维护一个重传定时器, 发送时启动<br>如果超时后依然没有收到回复则进行重发 并重置定时器</p>\n<p>超时时间 0.2 0.4 0.8 1.6 3.2 单位是秒, 类似TCP超时重连<br>重传最多次数 默认15</p>\n<p><strong>拥塞控制</strong><br>提高网络利用率, 降低丢包率 保证网络资源对每条数据流的公平性 –拥塞控制</p>\n<h1 id=\"第四章TCP-IP通信案例\"><a href=\"#第四章TCP-IP通信案例\" class=\"headerlink\" title=\"第四章TCP/IP通信案例\"></a>第四章TCP/IP通信案例</h1><p>上游服务器: 一个HTTP请求可能被多个代理服务器转发, 后面的服务器称为前面的服务器的上游服务器</p>\n<p>正向代理服务器: 要求客户端自己设置代理服务器的地址, 客户将每次请求都直接发送到该代理服务器,并由代理服务器来请求目标资源<br>反向代理服务器: 被设置在服务器端, 客户端无需进行设置. 用代理服务器接收网络上的请求, 然后将请求转发给内网上的服务器, 并将从内部服务器上得到的结果返回给客户端, 代理服务器对外表现为一个真正的服务器.</p>\n"},{"title":"EPOLLET丢失新连接事件","date":"2020-08-03T15:03:08.000Z","_content":"\n谨以此文献给我, 两次踩坑.\n\n第一次是根据muduo写我的mongo\n\n第二次则是后来我又根据muduo写higan. ~~框架名字不是重点~~\n\n\n# 症状描述\n\n1. 最首先的症状就是使用ab压测的时候, 压测会在快结束的时候卡住 而且压测过程中也会出现卡顿\n```\nPS C:\\Users\\XXX> ab -n 1000 -c 94 -k  http://10.4.160.96:1022/hello\nThis is ApacheBench, Version 2.3 <$Revision: 1874286 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking 10.4.160.96 (be patient)\nCompleted 100 requests\nCompleted 200 requests\nCompleted 300 requests\nCompleted 400 requests\nCompleted 500 requests\nCompleted 600 requests\nCompleted 700 requests\nCompleted 800 requests\nCompleted 900 requests\napr_pollset_poll: The timeout specified has expired (70007)\nTotal of 996 requests completed\n```\n2. 这时候已经建立的连接不受影响 却无法建立新的连接 debug的时候发现会出现建立已经关闭的连接\n3. 上面的问题发生与不发生 跟我是否开多线程有关, 如果我不建立额外的EventLoopThread就不会出现这个问题\n\n\n# 第一波排查 线程之间互相影响\n\n因为问题出现与否 与我是否设置多线程有关, 我就开始排查线程之间的影响.\n重点放在了muduo的RunInLoop函数. 因为这个函数我一直不是明白怎么回事.\n最终根据muduo的设计思想 一个EventLoop对应一个Thread.\n结合RunInLoop就可以达到谁的事件谁处理的效果\n\n举个例子, 连接中断后, 子线程返回相应的事件 要去调用TcpServer的RemoveConnection将自己移除, 如果不使用RunInLoop\n当有多个子线程 同时触发同样的事件 同时去对map进行删除操作 必然需要加锁. 况且连接连接的时候也要对map进行插入操作.\n使用RunInLoop判断后得知是子线程在调用RunInLoop而非对应的线程, 就将任务存储到了相关的EventLoop中. 而EventLoop中存储的任务只有其所属的Thread才能处理.\n所以实现了统一所有子线程的移除连接操作到了主线程中, 而连接的建立也是主线程操作, 最终避免了加锁.\n\n然后那个swap命令处理任务度列减少加锁的时间也很赞\n\n最终我加上了几处重要的RunInLoop, 不过并没有解决问题.............\n\n# 第二波排查 到底返回了多少事件?\n\n我在Acceptor等多个可读事件回调的位置加了计数器, 这时候最先发现的就是连接建立数量不对.\n\n上边996个完成请求缺了4个, 并且正好连接建立了90个连接, 而非设置的并发94, 也是少了4个.\n\n我先怀疑是否是ab压测的处理, 我试了下muduo多线程下94个连接 higan单线程94连接,多线程90连接, 排除了ab的问题\n\n少的链接去了哪里? 我使用netstat命令发现 正好是四个CLOSE_WAIT 我去看了下ab的包正好是114字节 说明了少的四个链接的位置\n而且这四个端口号正好是从本该是第91个连接的端口号开始的.\n```\n[root@fish ~]# netstat -an | grep 1022\ntcp        4      0 0.0.0.0:1022            0.0.0.0:*               LISTEN     \ntcp      114      0 10.4.160.96:1022        10.4.160.95:8785        CLOSE_WAIT \ntcp      114      0 10.4.160.96:1022        10.4.160.95:8787        CLOSE_WAIT \ntcp      114      0 10.4.160.96:1022        10.4.160.95:8786        CLOSE_WAIT \ntcp      114      0 10.4.160.96:1022        10.4.160.95:8784        CLOSE_WAIT \n```\n其实netstat不对劲早就发现了, 然而并不理解netstat命令 没有重视问题.\n\n使用Man命令察看了 第二列是Recv-Q 对于CLOSE_WAIT来说是未接收的字节数 对于LISTEN则是未接收的连接数\n\n\n# 第三波排查 为什么这四个连接没有被接受\n\n首先我发现了我这行代码写的有问题, 而我的epoll_events_是一个vector 后面的代码有扩容逻辑 难道是因为max_event太小导致的ET模式漏掉事件?\n并不是, 未被返回的事件是不会被忽略的 只有你从内核中将事件接收出来, 下次才不会提醒\n```c++\n// 源代码为 int event_num = epoll_wait(epollfd_, &*epoll_events_.begin(), 一个常数, timeout);\n// 修改后为 int event_num = epoll_wait(epollfd_, &*epoll_events_.begin(), static_cast<int>(epoll_events_.size()), timeout);\n```\n\n只能继续排查了, 因为知道了Recv-Q的存在 直接搜索几个关键字 找到了这个网页\n\nhttps://www.cnblogs.com/cxt-janson/p/9273440.html\n\n最后我尝试将EPOLLET模式改为EPOLLLT正常了!!!!!!\n\n# 仍存在的问题\n\n为什么只有我在启用多线程的时候才会发生丢失连接的现象? 这个问题目前还没找到.\n\n# 反思\n\n我最先排查的重点是线程之间的影响, 我对于muduo的多线程处理机制还是不熟悉, 自以为是了某些地方. \n\n连接建立的数量不对的时候虽然发现了Recv-Q以及CLOSE_WAIT 但由于对Tcp连接状态的理解以及netstat命令的不熟悉, 导致走了弯路.\n","source":"_posts/采坑记-EPOLLET丢失新连接事件.md","raw":"---\ntitle: EPOLLET丢失新连接事件\ndate: 2020-08-03 23:03:08\ntags:\n  - 采坑记\ncategories:\n  - 采坑记\n---\n\n谨以此文献给我, 两次踩坑.\n\n第一次是根据muduo写我的mongo\n\n第二次则是后来我又根据muduo写higan. ~~框架名字不是重点~~\n\n\n# 症状描述\n\n1. 最首先的症状就是使用ab压测的时候, 压测会在快结束的时候卡住 而且压测过程中也会出现卡顿\n```\nPS C:\\Users\\XXX> ab -n 1000 -c 94 -k  http://10.4.160.96:1022/hello\nThis is ApacheBench, Version 2.3 <$Revision: 1874286 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking 10.4.160.96 (be patient)\nCompleted 100 requests\nCompleted 200 requests\nCompleted 300 requests\nCompleted 400 requests\nCompleted 500 requests\nCompleted 600 requests\nCompleted 700 requests\nCompleted 800 requests\nCompleted 900 requests\napr_pollset_poll: The timeout specified has expired (70007)\nTotal of 996 requests completed\n```\n2. 这时候已经建立的连接不受影响 却无法建立新的连接 debug的时候发现会出现建立已经关闭的连接\n3. 上面的问题发生与不发生 跟我是否开多线程有关, 如果我不建立额外的EventLoopThread就不会出现这个问题\n\n\n# 第一波排查 线程之间互相影响\n\n因为问题出现与否 与我是否设置多线程有关, 我就开始排查线程之间的影响.\n重点放在了muduo的RunInLoop函数. 因为这个函数我一直不是明白怎么回事.\n最终根据muduo的设计思想 一个EventLoop对应一个Thread.\n结合RunInLoop就可以达到谁的事件谁处理的效果\n\n举个例子, 连接中断后, 子线程返回相应的事件 要去调用TcpServer的RemoveConnection将自己移除, 如果不使用RunInLoop\n当有多个子线程 同时触发同样的事件 同时去对map进行删除操作 必然需要加锁. 况且连接连接的时候也要对map进行插入操作.\n使用RunInLoop判断后得知是子线程在调用RunInLoop而非对应的线程, 就将任务存储到了相关的EventLoop中. 而EventLoop中存储的任务只有其所属的Thread才能处理.\n所以实现了统一所有子线程的移除连接操作到了主线程中, 而连接的建立也是主线程操作, 最终避免了加锁.\n\n然后那个swap命令处理任务度列减少加锁的时间也很赞\n\n最终我加上了几处重要的RunInLoop, 不过并没有解决问题.............\n\n# 第二波排查 到底返回了多少事件?\n\n我在Acceptor等多个可读事件回调的位置加了计数器, 这时候最先发现的就是连接建立数量不对.\n\n上边996个完成请求缺了4个, 并且正好连接建立了90个连接, 而非设置的并发94, 也是少了4个.\n\n我先怀疑是否是ab压测的处理, 我试了下muduo多线程下94个连接 higan单线程94连接,多线程90连接, 排除了ab的问题\n\n少的链接去了哪里? 我使用netstat命令发现 正好是四个CLOSE_WAIT 我去看了下ab的包正好是114字节 说明了少的四个链接的位置\n而且这四个端口号正好是从本该是第91个连接的端口号开始的.\n```\n[root@fish ~]# netstat -an | grep 1022\ntcp        4      0 0.0.0.0:1022            0.0.0.0:*               LISTEN     \ntcp      114      0 10.4.160.96:1022        10.4.160.95:8785        CLOSE_WAIT \ntcp      114      0 10.4.160.96:1022        10.4.160.95:8787        CLOSE_WAIT \ntcp      114      0 10.4.160.96:1022        10.4.160.95:8786        CLOSE_WAIT \ntcp      114      0 10.4.160.96:1022        10.4.160.95:8784        CLOSE_WAIT \n```\n其实netstat不对劲早就发现了, 然而并不理解netstat命令 没有重视问题.\n\n使用Man命令察看了 第二列是Recv-Q 对于CLOSE_WAIT来说是未接收的字节数 对于LISTEN则是未接收的连接数\n\n\n# 第三波排查 为什么这四个连接没有被接受\n\n首先我发现了我这行代码写的有问题, 而我的epoll_events_是一个vector 后面的代码有扩容逻辑 难道是因为max_event太小导致的ET模式漏掉事件?\n并不是, 未被返回的事件是不会被忽略的 只有你从内核中将事件接收出来, 下次才不会提醒\n```c++\n// 源代码为 int event_num = epoll_wait(epollfd_, &*epoll_events_.begin(), 一个常数, timeout);\n// 修改后为 int event_num = epoll_wait(epollfd_, &*epoll_events_.begin(), static_cast<int>(epoll_events_.size()), timeout);\n```\n\n只能继续排查了, 因为知道了Recv-Q的存在 直接搜索几个关键字 找到了这个网页\n\nhttps://www.cnblogs.com/cxt-janson/p/9273440.html\n\n最后我尝试将EPOLLET模式改为EPOLLLT正常了!!!!!!\n\n# 仍存在的问题\n\n为什么只有我在启用多线程的时候才会发生丢失连接的现象? 这个问题目前还没找到.\n\n# 反思\n\n我最先排查的重点是线程之间的影响, 我对于muduo的多线程处理机制还是不熟悉, 自以为是了某些地方. \n\n连接建立的数量不对的时候虽然发现了Recv-Q以及CLOSE_WAIT 但由于对Tcp连接状态的理解以及netstat命令的不熟悉, 导致走了弯路.\n","slug":"采坑记-EPOLLET丢失新连接事件","published":1,"updated":"2020-08-03T15:55:56.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg7e0049f8un4ddf1k2g","content":"<p>谨以此文献给我, 两次踩坑.</p>\n<p>第一次是根据muduo写我的mongo</p>\n<p>第二次则是后来我又根据muduo写higan. <del>框架名字不是重点</del></p>\n<h1 id=\"症状描述\"><a href=\"#症状描述\" class=\"headerlink\" title=\"症状描述\"></a>症状描述</h1><ol>\n<li>最首先的症状就是使用ab压测的时候, 压测会在快结束的时候卡住 而且压测过程中也会出现卡顿<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PS C:\\Users\\XXX&gt; ab -n 1000 -c 94 -k  http:&#x2F;&#x2F;10.4.160.96:1022&#x2F;hello</span><br><span class=\"line\">This is ApacheBench, Version 2.3 &lt;$Revision: 1874286 $&gt;</span><br><span class=\"line\">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http:&#x2F;&#x2F;www.zeustech.net&#x2F;</span><br><span class=\"line\">Licensed to The Apache Software Foundation, http:&#x2F;&#x2F;www.apache.org&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">Benchmarking 10.4.160.96 (be patient)</span><br><span class=\"line\">Completed 100 requests</span><br><span class=\"line\">Completed 200 requests</span><br><span class=\"line\">Completed 300 requests</span><br><span class=\"line\">Completed 400 requests</span><br><span class=\"line\">Completed 500 requests</span><br><span class=\"line\">Completed 600 requests</span><br><span class=\"line\">Completed 700 requests</span><br><span class=\"line\">Completed 800 requests</span><br><span class=\"line\">Completed 900 requests</span><br><span class=\"line\">apr_pollset_poll: The timeout specified has expired (70007)</span><br><span class=\"line\">Total of 996 requests completed</span><br></pre></td></tr></table></figure></li>\n<li>这时候已经建立的连接不受影响 却无法建立新的连接 debug的时候发现会出现建立已经关闭的连接</li>\n<li>上面的问题发生与不发生 跟我是否开多线程有关, 如果我不建立额外的EventLoopThread就不会出现这个问题</li>\n</ol>\n<h1 id=\"第一波排查-线程之间互相影响\"><a href=\"#第一波排查-线程之间互相影响\" class=\"headerlink\" title=\"第一波排查 线程之间互相影响\"></a>第一波排查 线程之间互相影响</h1><p>因为问题出现与否 与我是否设置多线程有关, 我就开始排查线程之间的影响.<br>重点放在了muduo的RunInLoop函数. 因为这个函数我一直不是明白怎么回事.<br>最终根据muduo的设计思想 一个EventLoop对应一个Thread.<br>结合RunInLoop就可以达到谁的事件谁处理的效果</p>\n<p>举个例子, 连接中断后, 子线程返回相应的事件 要去调用TcpServer的RemoveConnection将自己移除, 如果不使用RunInLoop<br>当有多个子线程 同时触发同样的事件 同时去对map进行删除操作 必然需要加锁. 况且连接连接的时候也要对map进行插入操作.<br>使用RunInLoop判断后得知是子线程在调用RunInLoop而非对应的线程, 就将任务存储到了相关的EventLoop中. 而EventLoop中存储的任务只有其所属的Thread才能处理.<br>所以实现了统一所有子线程的移除连接操作到了主线程中, 而连接的建立也是主线程操作, 最终避免了加锁.</p>\n<p>然后那个swap命令处理任务度列减少加锁的时间也很赞</p>\n<p>最终我加上了几处重要的RunInLoop, 不过并没有解决问题………….</p>\n<h1 id=\"第二波排查-到底返回了多少事件\"><a href=\"#第二波排查-到底返回了多少事件\" class=\"headerlink\" title=\"第二波排查 到底返回了多少事件?\"></a>第二波排查 到底返回了多少事件?</h1><p>我在Acceptor等多个可读事件回调的位置加了计数器, 这时候最先发现的就是连接建立数量不对.</p>\n<p>上边996个完成请求缺了4个, 并且正好连接建立了90个连接, 而非设置的并发94, 也是少了4个.</p>\n<p>我先怀疑是否是ab压测的处理, 我试了下muduo多线程下94个连接 higan单线程94连接,多线程90连接, 排除了ab的问题</p>\n<p>少的链接去了哪里? 我使用netstat命令发现 正好是四个CLOSE_WAIT 我去看了下ab的包正好是114字节 说明了少的四个链接的位置<br>而且这四个端口号正好是从本该是第91个连接的端口号开始的.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@fish ~]# netstat -an | grep 1022</span><br><span class=\"line\">tcp        4      0 0.0.0.0:1022            0.0.0.0:*               LISTEN     </span><br><span class=\"line\">tcp      114      0 10.4.160.96:1022        10.4.160.95:8785        CLOSE_WAIT </span><br><span class=\"line\">tcp      114      0 10.4.160.96:1022        10.4.160.95:8787        CLOSE_WAIT </span><br><span class=\"line\">tcp      114      0 10.4.160.96:1022        10.4.160.95:8786        CLOSE_WAIT </span><br><span class=\"line\">tcp      114      0 10.4.160.96:1022        10.4.160.95:8784        CLOSE_WAIT</span><br></pre></td></tr></table></figure>\n<p>其实netstat不对劲早就发现了, 然而并不理解netstat命令 没有重视问题.</p>\n<p>使用Man命令察看了 第二列是Recv-Q 对于CLOSE_WAIT来说是未接收的字节数 对于LISTEN则是未接收的连接数</p>\n<h1 id=\"第三波排查-为什么这四个连接没有被接受\"><a href=\"#第三波排查-为什么这四个连接没有被接受\" class=\"headerlink\" title=\"第三波排查 为什么这四个连接没有被接受\"></a>第三波排查 为什么这四个连接没有被接受</h1><p>首先我发现了我这行代码写的有问题, 而我的epoll_events_是一个vector 后面的代码有扩容逻辑 难道是因为max_event太小导致的ET模式漏掉事件?<br>并不是, 未被返回的事件是不会被忽略的 只有你从内核中将事件接收出来, 下次才不会提醒</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源代码为 int event_num = epoll_wait(epollfd_, &amp;*epoll_events_.begin(), 一个常数, timeout);</span></span><br><span class=\"line\"><span class=\"comment\">// 修改后为 int event_num = epoll_wait(epollfd_, &amp;*epoll_events_.begin(), static_cast&lt;int&gt;(epoll_events_.size()), timeout);</span></span><br></pre></td></tr></table></figure>\n\n<p>只能继续排查了, 因为知道了Recv-Q的存在 直接搜索几个关键字 找到了这个网页</p>\n<p><a href=\"https://www.cnblogs.com/cxt-janson/p/9273440.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/cxt-janson/p/9273440.html</a></p>\n<p>最后我尝试将EPOLLET模式改为EPOLLLT正常了!!!!!!</p>\n<h1 id=\"仍存在的问题\"><a href=\"#仍存在的问题\" class=\"headerlink\" title=\"仍存在的问题\"></a>仍存在的问题</h1><p>为什么只有我在启用多线程的时候才会发生丢失连接的现象? 这个问题目前还没找到.</p>\n<h1 id=\"反思\"><a href=\"#反思\" class=\"headerlink\" title=\"反思\"></a>反思</h1><p>我最先排查的重点是线程之间的影响, 我对于muduo的多线程处理机制还是不熟悉, 自以为是了某些地方. </p>\n<p>连接建立的数量不对的时候虽然发现了Recv-Q以及CLOSE_WAIT 但由于对Tcp连接状态的理解以及netstat命令的不熟悉, 导致走了弯路.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>谨以此文献给我, 两次踩坑.</p>\n<p>第一次是根据muduo写我的mongo</p>\n<p>第二次则是后来我又根据muduo写higan. <del>框架名字不是重点</del></p>\n<h1 id=\"症状描述\"><a href=\"#症状描述\" class=\"headerlink\" title=\"症状描述\"></a>症状描述</h1><ol>\n<li>最首先的症状就是使用ab压测的时候, 压测会在快结束的时候卡住 而且压测过程中也会出现卡顿<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PS C:\\Users\\XXX&gt; ab -n 1000 -c 94 -k  http:&#x2F;&#x2F;10.4.160.96:1022&#x2F;hello</span><br><span class=\"line\">This is ApacheBench, Version 2.3 &lt;$Revision: 1874286 $&gt;</span><br><span class=\"line\">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http:&#x2F;&#x2F;www.zeustech.net&#x2F;</span><br><span class=\"line\">Licensed to The Apache Software Foundation, http:&#x2F;&#x2F;www.apache.org&#x2F;</span><br><span class=\"line\"></span><br><span class=\"line\">Benchmarking 10.4.160.96 (be patient)</span><br><span class=\"line\">Completed 100 requests</span><br><span class=\"line\">Completed 200 requests</span><br><span class=\"line\">Completed 300 requests</span><br><span class=\"line\">Completed 400 requests</span><br><span class=\"line\">Completed 500 requests</span><br><span class=\"line\">Completed 600 requests</span><br><span class=\"line\">Completed 700 requests</span><br><span class=\"line\">Completed 800 requests</span><br><span class=\"line\">Completed 900 requests</span><br><span class=\"line\">apr_pollset_poll: The timeout specified has expired (70007)</span><br><span class=\"line\">Total of 996 requests completed</span><br></pre></td></tr></table></figure></li>\n<li>这时候已经建立的连接不受影响 却无法建立新的连接 debug的时候发现会出现建立已经关闭的连接</li>\n<li>上面的问题发生与不发生 跟我是否开多线程有关, 如果我不建立额外的EventLoopThread就不会出现这个问题</li>\n</ol>\n<h1 id=\"第一波排查-线程之间互相影响\"><a href=\"#第一波排查-线程之间互相影响\" class=\"headerlink\" title=\"第一波排查 线程之间互相影响\"></a>第一波排查 线程之间互相影响</h1><p>因为问题出现与否 与我是否设置多线程有关, 我就开始排查线程之间的影响.<br>重点放在了muduo的RunInLoop函数. 因为这个函数我一直不是明白怎么回事.<br>最终根据muduo的设计思想 一个EventLoop对应一个Thread.<br>结合RunInLoop就可以达到谁的事件谁处理的效果</p>\n<p>举个例子, 连接中断后, 子线程返回相应的事件 要去调用TcpServer的RemoveConnection将自己移除, 如果不使用RunInLoop<br>当有多个子线程 同时触发同样的事件 同时去对map进行删除操作 必然需要加锁. 况且连接连接的时候也要对map进行插入操作.<br>使用RunInLoop判断后得知是子线程在调用RunInLoop而非对应的线程, 就将任务存储到了相关的EventLoop中. 而EventLoop中存储的任务只有其所属的Thread才能处理.<br>所以实现了统一所有子线程的移除连接操作到了主线程中, 而连接的建立也是主线程操作, 最终避免了加锁.</p>\n<p>然后那个swap命令处理任务度列减少加锁的时间也很赞</p>\n<p>最终我加上了几处重要的RunInLoop, 不过并没有解决问题………….</p>\n<h1 id=\"第二波排查-到底返回了多少事件\"><a href=\"#第二波排查-到底返回了多少事件\" class=\"headerlink\" title=\"第二波排查 到底返回了多少事件?\"></a>第二波排查 到底返回了多少事件?</h1><p>我在Acceptor等多个可读事件回调的位置加了计数器, 这时候最先发现的就是连接建立数量不对.</p>\n<p>上边996个完成请求缺了4个, 并且正好连接建立了90个连接, 而非设置的并发94, 也是少了4个.</p>\n<p>我先怀疑是否是ab压测的处理, 我试了下muduo多线程下94个连接 higan单线程94连接,多线程90连接, 排除了ab的问题</p>\n<p>少的链接去了哪里? 我使用netstat命令发现 正好是四个CLOSE_WAIT 我去看了下ab的包正好是114字节 说明了少的四个链接的位置<br>而且这四个端口号正好是从本该是第91个连接的端口号开始的.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@fish ~]# netstat -an | grep 1022</span><br><span class=\"line\">tcp        4      0 0.0.0.0:1022            0.0.0.0:*               LISTEN     </span><br><span class=\"line\">tcp      114      0 10.4.160.96:1022        10.4.160.95:8785        CLOSE_WAIT </span><br><span class=\"line\">tcp      114      0 10.4.160.96:1022        10.4.160.95:8787        CLOSE_WAIT </span><br><span class=\"line\">tcp      114      0 10.4.160.96:1022        10.4.160.95:8786        CLOSE_WAIT </span><br><span class=\"line\">tcp      114      0 10.4.160.96:1022        10.4.160.95:8784        CLOSE_WAIT</span><br></pre></td></tr></table></figure>\n<p>其实netstat不对劲早就发现了, 然而并不理解netstat命令 没有重视问题.</p>\n<p>使用Man命令察看了 第二列是Recv-Q 对于CLOSE_WAIT来说是未接收的字节数 对于LISTEN则是未接收的连接数</p>\n<h1 id=\"第三波排查-为什么这四个连接没有被接受\"><a href=\"#第三波排查-为什么这四个连接没有被接受\" class=\"headerlink\" title=\"第三波排查 为什么这四个连接没有被接受\"></a>第三波排查 为什么这四个连接没有被接受</h1><p>首先我发现了我这行代码写的有问题, 而我的epoll_events_是一个vector 后面的代码有扩容逻辑 难道是因为max_event太小导致的ET模式漏掉事件?<br>并不是, 未被返回的事件是不会被忽略的 只有你从内核中将事件接收出来, 下次才不会提醒</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源代码为 int event_num = epoll_wait(epollfd_, &amp;*epoll_events_.begin(), 一个常数, timeout);</span></span><br><span class=\"line\"><span class=\"comment\">// 修改后为 int event_num = epoll_wait(epollfd_, &amp;*epoll_events_.begin(), static_cast&lt;int&gt;(epoll_events_.size()), timeout);</span></span><br></pre></td></tr></table></figure>\n\n<p>只能继续排查了, 因为知道了Recv-Q的存在 直接搜索几个关键字 找到了这个网页</p>\n<p><a href=\"https://www.cnblogs.com/cxt-janson/p/9273440.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/cxt-janson/p/9273440.html</a></p>\n<p>最后我尝试将EPOLLET模式改为EPOLLLT正常了!!!!!!</p>\n<h1 id=\"仍存在的问题\"><a href=\"#仍存在的问题\" class=\"headerlink\" title=\"仍存在的问题\"></a>仍存在的问题</h1><p>为什么只有我在启用多线程的时候才会发生丢失连接的现象? 这个问题目前还没找到.</p>\n<h1 id=\"反思\"><a href=\"#反思\" class=\"headerlink\" title=\"反思\"></a>反思</h1><p>我最先排查的重点是线程之间的影响, 我对于muduo的多线程处理机制还是不熟悉, 自以为是了某些地方. </p>\n<p>连接建立的数量不对的时候虽然发现了Recv-Q以及CLOSE_WAIT 但由于对Tcp连接状态的理解以及netstat命令的不熟悉, 导致走了弯路.</p>\n"},{"title":"头文件互相引用","date":"2020-02-07T08:37:08.000Z","_content":"写在前头 本文中的**编译**二字基本都带加粗, 因为目前为止我还没做学到过**编译**器相关的东西, \n姑且将`那个执行过程`称为**编译**, 所以加粗\n# 现象\n二月六号的时候 我在写那个小游戏, 写头文件`a.h`发现即使引用了一个头文件`b.h`, 也没有办法使用定义在那个头文件之中的结构体.\n\n其实有点我没在意: 当我在`a.h`文件中引用`b.h`的时候`b.h`会变成`invaild`, 这里其实就已经提示了\n```c++\n// a.h\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#include \"b.h\"\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\n\n// b.h\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n#include \"a.h\"\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\n// main.cpp\n#include \"a.h\" // a.h中有b.h就只include a.h\nint main()\n{\n    A a{};\n    B b{};\n}\n\nerror: ‘A’ does not name a type\nerror: ‘B’ does not name a type\n```\n# 原因\n## 先说一下 #ifndef #endif\n`ifndef`全称`if not defined`\n意思是如果`#ifndef`后面的宏没有被定义 就继续**编译**其中的内容\n继续**编译**`#ifndef`的下一句就是`#define`这个宏, 这样这个宏就被定义了\n第二次**编译**遇到这个头文件的时候, `#ifndef`后面的宏已经被定义了就跳过了if中的内容\n\n## #include的作用\n将 #include右边的文件展开到此文件中\n\n## 问题解释\n这样当你在main函数中 `#include \"a.h\"`的时候`a.h`之中的内容就被展开\n变成如下\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#include \"b.h\"\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\n\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n还有一个include同样操作得到如下\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n#include \"a.h\"\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n我猜测**编译**的时候是逐行执行的, 至少在头文件的这部分是逐行执行\n这样执行完了`行号为2 3 4 5`的四个宏 准备执行`行号为6`的这一行`#include \"a.h\"`继续展开\n得到如下\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#include \"b.h\"\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n可能有些乱 但仔细理解还是能到这里. 这下继续逐行执行 准备是`行号为6`的这一行(也可能是行号7的部分, 区别就是在include的下一行展开还是本行展开)`#ifndef UNTITLED1_A_H`\n这个宏就判断`UNTITLED1_A_H`是不是被定义了, 恩被定义了(第三行代码)跳到对应的`#endif`, 这样就防止了头文件\n无穷无尽的调用 我将跳过的部分注释掉方便继续分析\n\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n//#ifndef UNTITLED1_A_H\n//#define UNTITLED1_A_H\n//#include \"b.h\"\n//class A\n//{\n//   B *b;\n//};\n//#endif //UNTITLED1_A_H\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n下一行就是`第十四行`的`class B`的**编译**, 那么问题来了`第16行`的`A`是啥东西??.\n\n这里报错报了两行 我大胆推测一下 `class B`的**编译**的出错后, 依然在继续这个过程, 到了`class A`的时候\n发现其中的`B`又是啥呢? 推测不同头文件编译互不影响 所以出现了两行报错\n\n我们回到`class B`的头文件在`class B`的前面加上一行`class A;` 得到如下代码\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n//#ifndef UNTITLED1_A_H\n//#define UNTITLED1_A_H\n//#include \"b.h\"\n//class A\n//{\n//   B *b;\n//};\n//#endif //UNTITLED1_A_H\nclass A;\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n\n到了这里你会发现A的报错消失了, 因为这次在**编译**`class B`的时候事先知道了`A`是一个类并且你必须把\n`class B`之中的这一句`A *a;`写成指针, 因为指针大小确定, 而且没有初始化, 所以**编译**就能通过, 如果你写成\n`A a;`依然会报错, 因为不知道A具体是个啥 最起码的内存都没法分配\n\n好的下面继续, 你发现虽然A的报错消失了 但是`B`的报错还在, 我这里依然推测下, 不同头文件之间的**编译**互不影响,\n所以依然不知道`B`是什么此时按照上面操作加入`class B;`前置声明, **编译**正确通过.\n\n虽然两个头文件**编译**互不影响, 但是既然是main.cpp把他们引进来的 就同时对main.cpp起作用 自然就知道了A和B是啥\n\n\n虽然这个问题网上答案很多, 但我对此还是很多不理解, 所以在做某些推测的情况下, 分析出来了这些原因. 如果有误,请直接评论中指出. 这也算是本人的第一篇写的认真的博客","source":"_posts/采坑记-头文件互相引用.md","raw":"---\ntitle: 头文件互相引用\ndate: 2020-02-07 16:37:08\ntags:\n  - 采坑记\ncategories:\n  - 采坑记\n---\n写在前头 本文中的**编译**二字基本都带加粗, 因为目前为止我还没做学到过**编译**器相关的东西, \n姑且将`那个执行过程`称为**编译**, 所以加粗\n# 现象\n二月六号的时候 我在写那个小游戏, 写头文件`a.h`发现即使引用了一个头文件`b.h`, 也没有办法使用定义在那个头文件之中的结构体.\n\n其实有点我没在意: 当我在`a.h`文件中引用`b.h`的时候`b.h`会变成`invaild`, 这里其实就已经提示了\n```c++\n// a.h\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#include \"b.h\"\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\n\n// b.h\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n#include \"a.h\"\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\n// main.cpp\n#include \"a.h\" // a.h中有b.h就只include a.h\nint main()\n{\n    A a{};\n    B b{};\n}\n\nerror: ‘A’ does not name a type\nerror: ‘B’ does not name a type\n```\n# 原因\n## 先说一下 #ifndef #endif\n`ifndef`全称`if not defined`\n意思是如果`#ifndef`后面的宏没有被定义 就继续**编译**其中的内容\n继续**编译**`#ifndef`的下一句就是`#define`这个宏, 这样这个宏就被定义了\n第二次**编译**遇到这个头文件的时候, `#ifndef`后面的宏已经被定义了就跳过了if中的内容\n\n## #include的作用\n将 #include右边的文件展开到此文件中\n\n## 问题解释\n这样当你在main函数中 `#include \"a.h\"`的时候`a.h`之中的内容就被展开\n变成如下\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#include \"b.h\"\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\n\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n还有一个include同样操作得到如下\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n#include \"a.h\"\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n我猜测**编译**的时候是逐行执行的, 至少在头文件的这部分是逐行执行\n这样执行完了`行号为2 3 4 5`的四个宏 准备执行`行号为6`的这一行`#include \"a.h\"`继续展开\n得到如下\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#include \"b.h\"\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n可能有些乱 但仔细理解还是能到这里. 这下继续逐行执行 准备是`行号为6`的这一行(也可能是行号7的部分, 区别就是在include的下一行展开还是本行展开)`#ifndef UNTITLED1_A_H`\n这个宏就判断`UNTITLED1_A_H`是不是被定义了, 恩被定义了(第三行代码)跳到对应的`#endif`, 这样就防止了头文件\n无穷无尽的调用 我将跳过的部分注释掉方便继续分析\n\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n//#ifndef UNTITLED1_A_H\n//#define UNTITLED1_A_H\n//#include \"b.h\"\n//class A\n//{\n//   B *b;\n//};\n//#endif //UNTITLED1_A_H\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n下一行就是`第十四行`的`class B`的**编译**, 那么问题来了`第16行`的`A`是啥东西??.\n\n这里报错报了两行 我大胆推测一下 `class B`的**编译**的出错后, 依然在继续这个过程, 到了`class A`的时候\n发现其中的`B`又是啥呢? 推测不同头文件编译互不影响 所以出现了两行报错\n\n我们回到`class B`的头文件在`class B`的前面加上一行`class A;` 得到如下代码\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n//#ifndef UNTITLED1_A_H\n//#define UNTITLED1_A_H\n//#include \"b.h\"\n//class A\n//{\n//   B *b;\n//};\n//#endif //UNTITLED1_A_H\nclass A;\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n\n到了这里你会发现A的报错消失了, 因为这次在**编译**`class B`的时候事先知道了`A`是一个类并且你必须把\n`class B`之中的这一句`A *a;`写成指针, 因为指针大小确定, 而且没有初始化, 所以**编译**就能通过, 如果你写成\n`A a;`依然会报错, 因为不知道A具体是个啥 最起码的内存都没法分配\n\n好的下面继续, 你发现虽然A的报错消失了 但是`B`的报错还在, 我这里依然推测下, 不同头文件之间的**编译**互不影响,\n所以依然不知道`B`是什么此时按照上面操作加入`class B;`前置声明, **编译**正确通过.\n\n虽然两个头文件**编译**互不影响, 但是既然是main.cpp把他们引进来的 就同时对main.cpp起作用 自然就知道了A和B是啥\n\n\n虽然这个问题网上答案很多, 但我对此还是很多不理解, 所以在做某些推测的情况下, 分析出来了这些原因. 如果有误,请直接评论中指出. 这也算是本人的第一篇写的认真的博客","slug":"采坑记-头文件互相引用","published":1,"updated":"2020-08-03T15:03:03.835Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg7f004cf8un0bd9gnku","content":"<p>写在前头 本文中的<strong>编译</strong>二字基本都带加粗, 因为目前为止我还没做学到过<strong>编译</strong>器相关的东西,<br>姑且将<code>那个执行过程</code>称为<strong>编译</strong>, 所以加粗</p>\n<h1 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h1><p>二月六号的时候 我在写那个小游戏, 写头文件<code>a.h</code>发现即使引用了一个头文件<code>b.h</code>, 也没有办法使用定义在那个头文件之中的结构体.</p>\n<p>其实有点我没在意: 当我在<code>a.h</code>文件中引用<code>b.h</code>的时候<code>b.h</code>会变成<code>invaild</code>, 这里其实就已经提示了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span> <span class=\"comment\">// a.h中有b.h就只include a.h</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">error: ‘A’ does <span class=\"keyword\">not</span> name a type</span><br><span class=\"line\">error: ‘B’ does <span class=\"keyword\">not</span> name a type</span><br></pre></td></tr></table></figure>\n<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h1><h2 id=\"先说一下-ifndef-endif\"><a href=\"#先说一下-ifndef-endif\" class=\"headerlink\" title=\"先说一下 #ifndef #endif\"></a>先说一下 #ifndef #endif</h2><p><code>ifndef</code>全称<code>if not defined</code><br>意思是如果<code>#ifndef</code>后面的宏没有被定义 就继续<strong>编译</strong>其中的内容<br>继续<strong>编译</strong><code>#ifndef</code>的下一句就是<code>#define</code>这个宏, 这样这个宏就被定义了<br>第二次<strong>编译</strong>遇到这个头文件的时候, <code>#ifndef</code>后面的宏已经被定义了就跳过了if中的内容</p>\n<h2 id=\"include的作用\"><a href=\"#include的作用\" class=\"headerlink\" title=\"#include的作用\"></a>#include的作用</h2><p>将 #include右边的文件展开到此文件中</p>\n<h2 id=\"问题解释\"><a href=\"#问题解释\" class=\"headerlink\" title=\"问题解释\"></a>问题解释</h2><p>这样当你在main函数中 <code>#include &quot;a.h&quot;</code>的时候<code>a.h</code>之中的内容就被展开<br>变成如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有一个include同样操作得到如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我猜测<strong>编译</strong>的时候是逐行执行的, 至少在头文件的这部分是逐行执行<br>这样执行完了<code>行号为2 3 4 5</code>的四个宏 准备执行<code>行号为6</code>的这一行<code>#include &quot;a.h&quot;</code>继续展开<br>得到如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可能有些乱 但仔细理解还是能到这里. 这下继续逐行执行 准备是<code>行号为6</code>的这一行(也可能是行号7的部分, 区别就是在include的下一行展开还是本行展开)<code>#ifndef UNTITLED1_A_H</code><br>这个宏就判断<code>UNTITLED1_A_H</code>是不是被定义了, 恩被定义了(第三行代码)跳到对应的<code>#endif</code>, 这样就防止了头文件<br>无穷无尽的调用 我将跳过的部分注释掉方便继续分析</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"comment\">//#ifndef UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#define UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#include \"b.h\"</span></span><br><span class=\"line\"><span class=\"comment\">//class A</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   B *b;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">//#endif //UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下一行就是<code>第十四行</code>的<code>class B</code>的<strong>编译</strong>, 那么问题来了<code>第16行</code>的<code>A</code>是啥东西??.</p>\n<p>这里报错报了两行 我大胆推测一下 <code>class B</code>的<strong>编译</strong>的出错后, 依然在继续这个过程, 到了<code>class A</code>的时候<br>发现其中的<code>B</code>又是啥呢? 推测不同头文件编译互不影响 所以出现了两行报错</p>\n<p>我们回到<code>class B</code>的头文件在<code>class B</code>的前面加上一行<code>class A;</code> 得到如下代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"comment\">//#ifndef UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#define UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#include \"b.h\"</span></span><br><span class=\"line\"><span class=\"comment\">//class A</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   B *b;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">//#endif //UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到了这里你会发现A的报错消失了, 因为这次在<strong>编译</strong><code>class B</code>的时候事先知道了<code>A</code>是一个类并且你必须把<br><code>class B</code>之中的这一句<code>A *a;</code>写成指针, 因为指针大小确定, 而且没有初始化, 所以<strong>编译</strong>就能通过, 如果你写成<br><code>A a;</code>依然会报错, 因为不知道A具体是个啥 最起码的内存都没法分配</p>\n<p>好的下面继续, 你发现虽然A的报错消失了 但是<code>B</code>的报错还在, 我这里依然推测下, 不同头文件之间的<strong>编译</strong>互不影响,<br>所以依然不知道<code>B</code>是什么此时按照上面操作加入<code>class B;</code>前置声明, <strong>编译</strong>正确通过.</p>\n<p>虽然两个头文件<strong>编译</strong>互不影响, 但是既然是main.cpp把他们引进来的 就同时对main.cpp起作用 自然就知道了A和B是啥</p>\n<p>虽然这个问题网上答案很多, 但我对此还是很多不理解, 所以在做某些推测的情况下, 分析出来了这些原因. 如果有误,请直接评论中指出. 这也算是本人的第一篇写的认真的博客</p>\n","site":{"data":{}},"excerpt":"","more":"<p>写在前头 本文中的<strong>编译</strong>二字基本都带加粗, 因为目前为止我还没做学到过<strong>编译</strong>器相关的东西,<br>姑且将<code>那个执行过程</code>称为<strong>编译</strong>, 所以加粗</p>\n<h1 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h1><p>二月六号的时候 我在写那个小游戏, 写头文件<code>a.h</code>发现即使引用了一个头文件<code>b.h</code>, 也没有办法使用定义在那个头文件之中的结构体.</p>\n<p>其实有点我没在意: 当我在<code>a.h</code>文件中引用<code>b.h</code>的时候<code>b.h</code>会变成<code>invaild</code>, 这里其实就已经提示了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span> <span class=\"comment\">// a.h中有b.h就只include a.h</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">error: ‘A’ does <span class=\"keyword\">not</span> name a type</span><br><span class=\"line\">error: ‘B’ does <span class=\"keyword\">not</span> name a type</span><br></pre></td></tr></table></figure>\n<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h1><h2 id=\"先说一下-ifndef-endif\"><a href=\"#先说一下-ifndef-endif\" class=\"headerlink\" title=\"先说一下 #ifndef #endif\"></a>先说一下 #ifndef #endif</h2><p><code>ifndef</code>全称<code>if not defined</code><br>意思是如果<code>#ifndef</code>后面的宏没有被定义 就继续<strong>编译</strong>其中的内容<br>继续<strong>编译</strong><code>#ifndef</code>的下一句就是<code>#define</code>这个宏, 这样这个宏就被定义了<br>第二次<strong>编译</strong>遇到这个头文件的时候, <code>#ifndef</code>后面的宏已经被定义了就跳过了if中的内容</p>\n<h2 id=\"include的作用\"><a href=\"#include的作用\" class=\"headerlink\" title=\"#include的作用\"></a>#include的作用</h2><p>将 #include右边的文件展开到此文件中</p>\n<h2 id=\"问题解释\"><a href=\"#问题解释\" class=\"headerlink\" title=\"问题解释\"></a>问题解释</h2><p>这样当你在main函数中 <code>#include &quot;a.h&quot;</code>的时候<code>a.h</code>之中的内容就被展开<br>变成如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有一个include同样操作得到如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我猜测<strong>编译</strong>的时候是逐行执行的, 至少在头文件的这部分是逐行执行<br>这样执行完了<code>行号为2 3 4 5</code>的四个宏 准备执行<code>行号为6</code>的这一行<code>#include &quot;a.h&quot;</code>继续展开<br>得到如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可能有些乱 但仔细理解还是能到这里. 这下继续逐行执行 准备是<code>行号为6</code>的这一行(也可能是行号7的部分, 区别就是在include的下一行展开还是本行展开)<code>#ifndef UNTITLED1_A_H</code><br>这个宏就判断<code>UNTITLED1_A_H</code>是不是被定义了, 恩被定义了(第三行代码)跳到对应的<code>#endif</code>, 这样就防止了头文件<br>无穷无尽的调用 我将跳过的部分注释掉方便继续分析</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"comment\">//#ifndef UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#define UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#include \"b.h\"</span></span><br><span class=\"line\"><span class=\"comment\">//class A</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   B *b;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">//#endif //UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下一行就是<code>第十四行</code>的<code>class B</code>的<strong>编译</strong>, 那么问题来了<code>第16行</code>的<code>A</code>是啥东西??.</p>\n<p>这里报错报了两行 我大胆推测一下 <code>class B</code>的<strong>编译</strong>的出错后, 依然在继续这个过程, 到了<code>class A</code>的时候<br>发现其中的<code>B</code>又是啥呢? 推测不同头文件编译互不影响 所以出现了两行报错</p>\n<p>我们回到<code>class B</code>的头文件在<code>class B</code>的前面加上一行<code>class A;</code> 得到如下代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"comment\">//#ifndef UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#define UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#include \"b.h\"</span></span><br><span class=\"line\"><span class=\"comment\">//class A</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   B *b;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">//#endif //UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到了这里你会发现A的报错消失了, 因为这次在<strong>编译</strong><code>class B</code>的时候事先知道了<code>A</code>是一个类并且你必须把<br><code>class B</code>之中的这一句<code>A *a;</code>写成指针, 因为指针大小确定, 而且没有初始化, 所以<strong>编译</strong>就能通过, 如果你写成<br><code>A a;</code>依然会报错, 因为不知道A具体是个啥 最起码的内存都没法分配</p>\n<p>好的下面继续, 你发现虽然A的报错消失了 但是<code>B</code>的报错还在, 我这里依然推测下, 不同头文件之间的<strong>编译</strong>互不影响,<br>所以依然不知道<code>B</code>是什么此时按照上面操作加入<code>class B;</code>前置声明, <strong>编译</strong>正确通过.</p>\n<p>虽然两个头文件<strong>编译</strong>互不影响, 但是既然是main.cpp把他们引进来的 就同时对main.cpp起作用 自然就知道了A和B是啥</p>\n<p>虽然这个问题网上答案很多, 但我对此还是很多不理解, 所以在做某些推测的情况下, 分析出来了这些原因. 如果有误,请直接评论中指出. 这也算是本人的第一篇写的认真的博客</p>\n"},{"title":"由muduo tie引出的 delete this","date":"2020-11-26T09:37:08.000Z","_content":"\n在半个多月以前 看完了深度探索C++对象模型, 然而只是粗略的过了一遍. 并没有结合具体的例子去深刻的理解下\n\n\n如果delete this 不会遇到 那这样呢?\n```c++\n#include <cstdio>\n\nvoid Delete();\n\nclass Foo\n{\npublic:\n\n    Foo()\n    {\n        bar_ = 111111;\n    }\n    ~Foo()\n    {\n        printf(\"~Foo()\\n\");\n    }\n\n    void Bar1()\n    {\n        printf(\"Bar1()\\n\");\n    }\n    void Bar()\n    {\n        Delete();\n        printf(\"bar: %d\\n\", bar_);\n        Bar1();\n    }\n\n    int bar_;\n};\n\nFoo* foo = nullptr;\nbool del = false;\nvoid Delete()\n{\n    if (!del)\n    {\n        del = true;\n        delete foo;\n    }\n}\n\nint main()\n{\n    foo = new Foo;\n    foo->Bar();\n    printf(\"\\n\");\n    foo->Bar();\n\n    return 0;\n}  \n```\n\n程序安然的结束了, 但是发现 成员变量bar的值已经被初始化了, 由于delete释放了内存.\n\n```\n~Foo()\nbar: 0\nBar1()\n\nbar: 0\nBar1()\n```\n\n同时delete是两步操作\n1. 调用对象的析构函数 (析构函数中调用 会导致递归)\n2. 释放相关空间\n\n[官方解释](https://isocpp.org/wiki/faq/freestore-mgmt#delete-this)\n\n\n**成员变量指针类型**\n```c++\n#include <cstdio>\n#include <functional>\n\nclass Foo\n{\npublic:\n    \n    void Bar1()\n    {\n        if (bar_)\n        {\n            bar_();\n        }\n    }\n\n    void Bar2()\n    {\n        bar_();\n    }\n    std::function<void()> bar_;\n};\n\nFoo* foo = nullptr;\n\nvoid PrintfBar()\n{\n    printf(\"Bar\\n\");\n}\n\nint main()\n{\n    foo = new Foo;\n    foo->bar_ = PrintfBar;\n\n    foo->Bar1(); // Bar\n    foo->Bar2(); // Bar\n\n    delete foo;\n\n    foo->Bar1(); // Segmentation fault (core dumped)\n\n    foo->Bar2();\n\n    return 0;\n}\n```\n\n测试后所有对指针型成员变量的 解引用操作都会导致`Segmentation fault (core dumped)` 所以下面的代码也有了解释\n\n一个困扰我很久的BUG 即为程序会在HandleEvent触发`Segmentation fault (core dumped)`的原因找到了\n```c++\nvoid Channel::HandleEvent()\n{\n\t/**\n\t * lock增加TcpConnectionPtr的引用计数 防止从TcpServer中erase后 直接销毁TcpConnection\n\t *\n\t * 否则如果不增加引用计数 当TcpConnection被销毁后, 所管理的Channel也将会被销毁\n\t * 在这之后 不能再使用TcpConnection和Channel的任何 成员函数和成员变量\n\t *\n\t * 有点类似于在一个 new出来的对象的成员函数中 delete自己\n\t * 详见 https://stackoverflow.com/questions/7039597/what-will-happen-if-you-do-delete-this-in-a-member-function\n\t *\n\t * 经过查阅后自己对深度探索C++对象模型 有了更深得理解\n\t */\n\tstd::shared_ptr<void> guard = tie_.lock();\n\tif (!guard)\n\t{\n\t\tLOG_WARN(\"connection: %s is closed\", connection_name.c_str());\n\t}\n\n\tif (event_ & XEPOLLIN)\n\t{\n        if (readable_callback_)\n        {\n            readable_callback_();\n        }\n\t}\n}\n```","source":"_posts/采坑记-delete this.md","raw":"---\ntitle: 由muduo tie引出的 delete this\ndate: 2020-11-26 17:37:08\ntags:\n  - 采坑记\ncategories:\n  - 采坑记\n---\n\n在半个多月以前 看完了深度探索C++对象模型, 然而只是粗略的过了一遍. 并没有结合具体的例子去深刻的理解下\n\n\n如果delete this 不会遇到 那这样呢?\n```c++\n#include <cstdio>\n\nvoid Delete();\n\nclass Foo\n{\npublic:\n\n    Foo()\n    {\n        bar_ = 111111;\n    }\n    ~Foo()\n    {\n        printf(\"~Foo()\\n\");\n    }\n\n    void Bar1()\n    {\n        printf(\"Bar1()\\n\");\n    }\n    void Bar()\n    {\n        Delete();\n        printf(\"bar: %d\\n\", bar_);\n        Bar1();\n    }\n\n    int bar_;\n};\n\nFoo* foo = nullptr;\nbool del = false;\nvoid Delete()\n{\n    if (!del)\n    {\n        del = true;\n        delete foo;\n    }\n}\n\nint main()\n{\n    foo = new Foo;\n    foo->Bar();\n    printf(\"\\n\");\n    foo->Bar();\n\n    return 0;\n}  \n```\n\n程序安然的结束了, 但是发现 成员变量bar的值已经被初始化了, 由于delete释放了内存.\n\n```\n~Foo()\nbar: 0\nBar1()\n\nbar: 0\nBar1()\n```\n\n同时delete是两步操作\n1. 调用对象的析构函数 (析构函数中调用 会导致递归)\n2. 释放相关空间\n\n[官方解释](https://isocpp.org/wiki/faq/freestore-mgmt#delete-this)\n\n\n**成员变量指针类型**\n```c++\n#include <cstdio>\n#include <functional>\n\nclass Foo\n{\npublic:\n    \n    void Bar1()\n    {\n        if (bar_)\n        {\n            bar_();\n        }\n    }\n\n    void Bar2()\n    {\n        bar_();\n    }\n    std::function<void()> bar_;\n};\n\nFoo* foo = nullptr;\n\nvoid PrintfBar()\n{\n    printf(\"Bar\\n\");\n}\n\nint main()\n{\n    foo = new Foo;\n    foo->bar_ = PrintfBar;\n\n    foo->Bar1(); // Bar\n    foo->Bar2(); // Bar\n\n    delete foo;\n\n    foo->Bar1(); // Segmentation fault (core dumped)\n\n    foo->Bar2();\n\n    return 0;\n}\n```\n\n测试后所有对指针型成员变量的 解引用操作都会导致`Segmentation fault (core dumped)` 所以下面的代码也有了解释\n\n一个困扰我很久的BUG 即为程序会在HandleEvent触发`Segmentation fault (core dumped)`的原因找到了\n```c++\nvoid Channel::HandleEvent()\n{\n\t/**\n\t * lock增加TcpConnectionPtr的引用计数 防止从TcpServer中erase后 直接销毁TcpConnection\n\t *\n\t * 否则如果不增加引用计数 当TcpConnection被销毁后, 所管理的Channel也将会被销毁\n\t * 在这之后 不能再使用TcpConnection和Channel的任何 成员函数和成员变量\n\t *\n\t * 有点类似于在一个 new出来的对象的成员函数中 delete自己\n\t * 详见 https://stackoverflow.com/questions/7039597/what-will-happen-if-you-do-delete-this-in-a-member-function\n\t *\n\t * 经过查阅后自己对深度探索C++对象模型 有了更深得理解\n\t */\n\tstd::shared_ptr<void> guard = tie_.lock();\n\tif (!guard)\n\t{\n\t\tLOG_WARN(\"connection: %s is closed\", connection_name.c_str());\n\t}\n\n\tif (event_ & XEPOLLIN)\n\t{\n        if (readable_callback_)\n        {\n            readable_callback_();\n        }\n\t}\n}\n```","slug":"采坑记-delete this","published":1,"updated":"2020-11-26T11:23:57.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg7f004ef8unbpxdhh5r","content":"<p>在半个多月以前 看完了深度探索C++对象模型, 然而只是粗略的过了一遍. 并没有结合具体的例子去深刻的理解下</p>\n<p>如果delete this 不会遇到 那这样呢?</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Delete</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    Foo()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bar_ = <span class=\"number\">111111</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Foo()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"~Foo()\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bar1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Bar1()\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bar</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Delete();</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"bar: %d\\n\"</span>, bar_);</span><br><span class=\"line\">        Bar1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bar_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo* foo = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> del = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Delete</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!del)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        del = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> foo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    foo = <span class=\"keyword\">new</span> Foo;</span><br><span class=\"line\">    foo-&gt;Bar();</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    foo-&gt;Bar();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序安然的结束了, 但是发现 成员变量bar的值已经被初始化了, 由于delete释放了内存.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~Foo()</span><br><span class=\"line\">bar: 0</span><br><span class=\"line\">Bar1()</span><br><span class=\"line\"></span><br><span class=\"line\">bar: 0</span><br><span class=\"line\">Bar1()</span><br></pre></td></tr></table></figure>\n\n<p>同时delete是两步操作</p>\n<ol>\n<li>调用对象的析构函数 (析构函数中调用 会导致递归)</li>\n<li>释放相关空间</li>\n</ol>\n<p><a href=\"https://isocpp.org/wiki/faq/freestore-mgmt#delete-this\" target=\"_blank\" rel=\"noopener\">官方解释</a></p>\n<p><strong>成员变量指针类型</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bar1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bar_)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            bar_();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bar2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        bar_();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; bar_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo* foo = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintfBar</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Bar\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    foo = <span class=\"keyword\">new</span> Foo;</span><br><span class=\"line\">    foo-&gt;bar_ = PrintfBar;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo-&gt;Bar1(); <span class=\"comment\">// Bar</span></span><br><span class=\"line\">    foo-&gt;Bar2(); <span class=\"comment\">// Bar</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo-&gt;Bar1(); <span class=\"comment\">// Segmentation fault (core dumped)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    foo-&gt;Bar2();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试后所有对指针型成员变量的 解引用操作都会导致<code>Segmentation fault (core dumped)</code> 所以下面的代码也有了解释</p>\n<p>一个困扰我很久的BUG 即为程序会在HandleEvent触发<code>Segmentation fault (core dumped)</code>的原因找到了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Channel::HandleEvent</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * lock增加TcpConnectionPtr的引用计数 防止从TcpServer中erase后 直接销毁TcpConnection</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * 否则如果不增加引用计数 当TcpConnection被销毁后, 所管理的Channel也将会被销毁</span></span><br><span class=\"line\"><span class=\"comment\">\t * 在这之后 不能再使用TcpConnection和Channel的任何 成员函数和成员变量</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * 有点类似于在一个 new出来的对象的成员函数中 delete自己</span></span><br><span class=\"line\"><span class=\"comment\">\t * 详见 https://stackoverflow.com/questions/7039597/what-will-happen-if-you-do-delete-this-in-a-member-function</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * 经过查阅后自己对深度探索C++对象模型 有了更深得理解</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">void</span>&gt; guard = tie_.lock();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!guard)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tLOG_WARN(<span class=\"string\">\"connection: %s is closed\"</span>, connection_name.c_str());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (event_ &amp; XEPOLLIN)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (readable_callback_)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            readable_callback_();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>在半个多月以前 看完了深度探索C++对象模型, 然而只是粗略的过了一遍. 并没有结合具体的例子去深刻的理解下</p>\n<p>如果delete this 不会遇到 那这样呢?</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Delete</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    Foo()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        bar_ = <span class=\"number\">111111</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ~Foo()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"~Foo()\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bar1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Bar1()\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bar</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        Delete();</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"bar: %d\\n\"</span>, bar_);</span><br><span class=\"line\">        Bar1();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> bar_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo* foo = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> del = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Delete</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!del)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        del = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> foo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    foo = <span class=\"keyword\">new</span> Foo;</span><br><span class=\"line\">    foo-&gt;Bar();</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    foo-&gt;Bar();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>程序安然的结束了, 但是发现 成员变量bar的值已经被初始化了, 由于delete释放了内存.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~Foo()</span><br><span class=\"line\">bar: 0</span><br><span class=\"line\">Bar1()</span><br><span class=\"line\"></span><br><span class=\"line\">bar: 0</span><br><span class=\"line\">Bar1()</span><br></pre></td></tr></table></figure>\n\n<p>同时delete是两步操作</p>\n<ol>\n<li>调用对象的析构函数 (析构函数中调用 会导致递归)</li>\n<li>释放相关空间</li>\n</ol>\n<p><a href=\"https://isocpp.org/wiki/faq/freestore-mgmt#delete-this\" target=\"_blank\" rel=\"noopener\">官方解释</a></p>\n<p><strong>成员变量指针类型</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bar1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (bar_)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            bar_();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bar2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        bar_();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; bar_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo* foo = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintfBar</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Bar\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    foo = <span class=\"keyword\">new</span> Foo;</span><br><span class=\"line\">    foo-&gt;bar_ = PrintfBar;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo-&gt;Bar1(); <span class=\"comment\">// Bar</span></span><br><span class=\"line\">    foo-&gt;Bar2(); <span class=\"comment\">// Bar</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo-&gt;Bar1(); <span class=\"comment\">// Segmentation fault (core dumped)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    foo-&gt;Bar2();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>测试后所有对指针型成员变量的 解引用操作都会导致<code>Segmentation fault (core dumped)</code> 所以下面的代码也有了解释</p>\n<p>一个困扰我很久的BUG 即为程序会在HandleEvent触发<code>Segmentation fault (core dumped)</code>的原因找到了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Channel::HandleEvent</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * lock增加TcpConnectionPtr的引用计数 防止从TcpServer中erase后 直接销毁TcpConnection</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * 否则如果不增加引用计数 当TcpConnection被销毁后, 所管理的Channel也将会被销毁</span></span><br><span class=\"line\"><span class=\"comment\">\t * 在这之后 不能再使用TcpConnection和Channel的任何 成员函数和成员变量</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * 有点类似于在一个 new出来的对象的成员函数中 delete自己</span></span><br><span class=\"line\"><span class=\"comment\">\t * 详见 https://stackoverflow.com/questions/7039597/what-will-happen-if-you-do-delete-this-in-a-member-function</span></span><br><span class=\"line\"><span class=\"comment\">\t *</span></span><br><span class=\"line\"><span class=\"comment\">\t * 经过查阅后自己对深度探索C++对象模型 有了更深得理解</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">void</span>&gt; guard = tie_.lock();</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!guard)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tLOG_WARN(<span class=\"string\">\"connection: %s is closed\"</span>, connection_name.c_str());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (event_ &amp; XEPOLLIN)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (readable_callback_)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            readable_callback_();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"循环判断中使用无符号类型","date":"2020-03-06T09:37:08.000Z","_content":"\n下面的代码 会产生错误.\n```c++\nvector<int> test;\nfor (int i = 0; i < test.size() - 1; ++i)\n{\n}\n```\n无符号类型的数值和有符号类型的数值进行运算(包括算数逻辑运算等)会将有符号类型的数值转换成无符号类型的数值.\n\n但是对于char short等小于int的数值运算的时候 会转换成int 纯正的int\n对于unsigned char在转换成int时，无论最高位是0还是1，都补0\nsigned char的则高位时1补1 0补0\n```c++\n// 0*23 1\n// 1*23 0\n// 1*24 本来是int 但被当作了 无符号int 所以输出\nunsigned int a = 1;\nint b = -2;\nif (a < b) // 逻辑运算也转换了\n{\n    cout << \"a < b\" << endl; // 输出\n}\ncout << a + b << endl; // 4294967295\n\n\n//   11111111 11111111 11111111 11111111\n//   00000000 00000000 00000000 00000010\n// 1 00000000 00000000 00000000 00000001\nunsigned int c = 2; // 0*22 1 0\nint d = -1; // 1*24\nif (c < d)\n{\n    cout << \"c < d\" << endl; // 输出\n}\ncout << c + d << endl; // 1   直接把高位的1溢出了 留下了0\n\n// 2*23 1\n// 1*23 0\n// 1*24 被转换成了int 所以输出-1\nunsigned char e = 1;\nchar f = -2;\nif (e < f)\n{\n    cout << \"e < f\" << endl; // 没有输出\n}\ncout << e + f << endl; // -1\n\nunsigned char g = 2;\nchar h = -1;\nif (g < h)\n{\n    cout << \"g < h\" << endl; // 未输出\n}\ncout << g + h << endl; // 1\n```","source":"_posts/采坑记-循环判断之无符号类型.md","raw":"---\ntitle: 循环判断中使用无符号类型\ndate: 2020-03-06 17:37:08\ntags:\n  - 采坑记\ncategories:\n  - 采坑记\n---\n\n下面的代码 会产生错误.\n```c++\nvector<int> test;\nfor (int i = 0; i < test.size() - 1; ++i)\n{\n}\n```\n无符号类型的数值和有符号类型的数值进行运算(包括算数逻辑运算等)会将有符号类型的数值转换成无符号类型的数值.\n\n但是对于char short等小于int的数值运算的时候 会转换成int 纯正的int\n对于unsigned char在转换成int时，无论最高位是0还是1，都补0\nsigned char的则高位时1补1 0补0\n```c++\n// 0*23 1\n// 1*23 0\n// 1*24 本来是int 但被当作了 无符号int 所以输出\nunsigned int a = 1;\nint b = -2;\nif (a < b) // 逻辑运算也转换了\n{\n    cout << \"a < b\" << endl; // 输出\n}\ncout << a + b << endl; // 4294967295\n\n\n//   11111111 11111111 11111111 11111111\n//   00000000 00000000 00000000 00000010\n// 1 00000000 00000000 00000000 00000001\nunsigned int c = 2; // 0*22 1 0\nint d = -1; // 1*24\nif (c < d)\n{\n    cout << \"c < d\" << endl; // 输出\n}\ncout << c + d << endl; // 1   直接把高位的1溢出了 留下了0\n\n// 2*23 1\n// 1*23 0\n// 1*24 被转换成了int 所以输出-1\nunsigned char e = 1;\nchar f = -2;\nif (e < f)\n{\n    cout << \"e < f\" << endl; // 没有输出\n}\ncout << e + f << endl; // -1\n\nunsigned char g = 2;\nchar h = -1;\nif (g < h)\n{\n    cout << \"g < h\" << endl; // 未输出\n}\ncout << g + h << endl; // 1\n```","slug":"采坑记-循环判断之无符号类型","published":1,"updated":"2020-08-03T15:03:00.342Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg7g004gf8un7knk5ydk","content":"<p>下面的代码 会产生错误.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; test;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; test.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>无符号类型的数值和有符号类型的数值进行运算(包括算数逻辑运算等)会将有符号类型的数值转换成无符号类型的数值.</p>\n<p>但是对于char short等小于int的数值运算的时候 会转换成int 纯正的int<br>对于unsigned char在转换成int时，无论最高位是0还是1，都补0<br>signed char的则高位时1补1 0补0</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 0*23 1</span></span><br><span class=\"line\"><span class=\"comment\">// 1*23 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1*24 本来是int 但被当作了 无符号int 所以输出</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">-2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a &lt; b) <span class=\"comment\">// 逻辑运算也转换了</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a &lt; b\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 4294967295</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//   11111111 11111111 11111111 11111111</span></span><br><span class=\"line\"><span class=\"comment\">//   00000000 00000000 00000000 00000010</span></span><br><span class=\"line\"><span class=\"comment\">// 1 00000000 00000000 00000000 00000001</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> c = <span class=\"number\">2</span>; <span class=\"comment\">// 0*22 1 0</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> d = <span class=\"number\">-1</span>; <span class=\"comment\">// 1*24</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (c &lt; d)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"c &lt; d\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; c + d &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1   直接把高位的1溢出了 留下了0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2*23 1</span></span><br><span class=\"line\"><span class=\"comment\">// 1*23 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1*24 被转换成了int 所以输出-1</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> e = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> f = <span class=\"number\">-2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (e &lt; f)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"e &lt; f\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 没有输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; e + f &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> g = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> h = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (g &lt; h)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"g &lt; h\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 未输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; g + h &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>下面的代码 会产生错误.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; test;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; test.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>无符号类型的数值和有符号类型的数值进行运算(包括算数逻辑运算等)会将有符号类型的数值转换成无符号类型的数值.</p>\n<p>但是对于char short等小于int的数值运算的时候 会转换成int 纯正的int<br>对于unsigned char在转换成int时，无论最高位是0还是1，都补0<br>signed char的则高位时1补1 0补0</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 0*23 1</span></span><br><span class=\"line\"><span class=\"comment\">// 1*23 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1*24 本来是int 但被当作了 无符号int 所以输出</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">-2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a &lt; b) <span class=\"comment\">// 逻辑运算也转换了</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a &lt; b\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 4294967295</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//   11111111 11111111 11111111 11111111</span></span><br><span class=\"line\"><span class=\"comment\">//   00000000 00000000 00000000 00000010</span></span><br><span class=\"line\"><span class=\"comment\">// 1 00000000 00000000 00000000 00000001</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> c = <span class=\"number\">2</span>; <span class=\"comment\">// 0*22 1 0</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> d = <span class=\"number\">-1</span>; <span class=\"comment\">// 1*24</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (c &lt; d)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"c &lt; d\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; c + d &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1   直接把高位的1溢出了 留下了0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2*23 1</span></span><br><span class=\"line\"><span class=\"comment\">// 1*23 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1*24 被转换成了int 所以输出-1</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> e = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> f = <span class=\"number\">-2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (e &lt; f)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"e &lt; f\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 没有输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; e + f &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> g = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> h = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (g &lt; h)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"g &lt; h\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 未输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; g + h &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>"},{"title":"P2P直播平台","date":"2020-12-02T04:50:02.000Z","_content":"\n# 项目说明\n\n**当前进度 支持多个RTMP推流者推流 支持多个HTTP-FLV拉流者拉取对应的流观看**\n\n**使用C++17标准 Windows和Centos平台均使用gcc编译通过正常使用**\n\n**运行后在两个推流者四个观看者情况下 Linux占用内存6MB Windows占用内存1MB CPU使用极低**\n\n**支持IPV4和IPV6**\n\n服务器端代码量 包含网络部分 5000余行\n\nHttpFlv拉流的播放器目前测试通过PotPlayer, VLC, flv.js\n\nRTMP推流播放器仅测试过Obs\n\n网络部分学习自 https://github.com/chenshuo/muduo\n\n跨平台支持学习自 https://github.com/balloonwj/flamingo\n\nHTTP包装 RTMP解析 FLV解析 参考自网络相关文档\n\n# 项目规划\n\n开发轻量级跨Windows和Linux的可用于P2P直播的`服务器端`和`观看客户端`\n\n项目不打算开发UI方面的功能, 视频将使用第三方的支持HttpFlv拉流的播放器来播放(如PotPlayer)\n\n## 开发进度\n\n支持多个RTMP推流者推流(已完成)\n\n支持多个HTTP-FLV拉流者拉取对应的流观看(已完成)\n\n开发`观看客户端`主要用于从`服务器端`接收FLV数据 本地转化成HttpFlv格式 供`HttpFlv拉流软件本地拉取` (未开发)\n\n`观看者客户端`可以从`服务器端`获取数据也可以通过P2P技术与其他`观看者客户端`进行共享 (未开发)\n\n## 初版\n\n主播使用`RTMP推流软件(如Obs)`将RTMP流发送到`服务器端` `服务器端`将Rtmp流解析生成FLV数据包装在HTTP中推送给观看者\n\n观看者直接使用`服务器端`生成的HTTPFLV地址 拉流观看\n\n\n## P2P版本 (未开发)\n\n# 使用说明\n\n**编译执行文件**\n下载源代码后在Windows平台或者Linux平台编译\n```shell\ngit clone https://github.com/HiganFish/LiveBroadcast.git\n\ncd LiveBroadcast/LiveBroadcastServer/\n\nmkdir build && cd build\n\ncmake ..\n\nmake -j4\n```\n生成运行文件`LiveBroadcastServer`\n\n\n**运行服务器**\n```shell\n./LiveBroadcastServer 4000 4100 # 4000 Rtmp推流端口 4100 HTTP-FLV拉流端口\n```\n\n**Obs推流**\n```shell\n# 设置->推流->服务器\nrtmp://[::1]:4000/test-push  # 注意 rtmp和http链接的对应关系 默认是相同的路径为同一个房间\nrtmp://127.0.0.1:4000/test-push # 可以在main.cpp中修改映射关系\n```\n\n**HTTP-FLV拉流**\n```shell\nhttp://[::1]:4000/test-push # 注意 rtmp和http链接的对应关系 默认是相同的路径为同一个房间\nhttp://127.0.0.1:4000/test-push # 可以在main.cpp中修改映射关系\n```\n\n# 项目所需技术\n\n## 服务器端\n\n### FLV\nFLV文件由一个FileHeader起头 后面为若干个FileTag 直到文件结束前四个字节\n最后四个字节是上一个FileTag的大小减去4\n\nFLV文件格式\n```\nclass FileHeader\n{\n\tchar flv[3]; // FLV\n\tuint8_t version; // 1\n\tuint8_t type_flags; // 5\n\tuint32_t header_length; // 9\n};\n\nclass FileTag\n{\n\tuint32_t previous_tag_size; // 不含previous_tag_size  sizeof 上一个Tag - 4\n\tuint8_t tag_type; // 音频 8 视频 9 scripts 18\n\tuint8_t data_size[3]; // AudioTag VideoTag 的数据长度 从stream_id后开始算起\n\tuint8_t timestamp[3];\n\tuint8_t timestamp_extend;\n\tuint8_t stream_id[3]; // 0\n\n\tchar* data;\n};\n```\n\n前三个Tag可以认为有特殊作用 所以单独说一下\n\n以后的所有Tag均为音视频数据\n```\nFileHeader file_header; // 每次开始都要发送一次\nFileTag info_tag; // 每次开始都要发送一次\nFileTag sps_pps_tag; // 每次开始都要发送一次 第一个视频tag存储编码信息\nFileTag audio_tag; // 每次开始都要发送一次 第一个音频tag存储编码信息\n\nFileTag data[N]; // 真正的数据部分\n```\n\n每次有`观看者客户端`连接的时候 都要发送一次`file_header`,`info_tag`和`sps_pps_tag` 以及`audio_tag`之后便是数据部分\n\n### RTMP\n\n#### RTMP握手协议\nObs客户端首先会发送C1 服务器端直接将C1作为S1发送回去, Obs会发送C2 服务端继续发送C1作为S2 握手成功\n\n\n商定窗口大小\n```\n-->\nconnect\n\n<-- Window Acknowledgement Size 5000000\n[02 00 00 00 00 00 04 05 00 00 00 00 00 4c 4b 40]\n\n\n<-- Set Peer Bandwidth 5000000,Dynamic|Set Chunk Size 4096|_result('NetConnection.Connect.Success')\n[02 00 00 00 00 00 05 06 00 00 00 00 00 4c 4b 40 02]\n[02 00 00 00 00 00 04 01 00 00 00 00 00 00 10 00]\n[03 00 00 00 00 00 be 14 00 00 00 00 02 00 07 5f 72 65 73 75 6c 74 00 3f f0 00 00 00 00 00 00 03 00 06 66 6d 73 56 65 72 02 00 0d 46 4d 53 2f 33 2c 30 2c 31 2c 31 32 33 00 0c 63 61 70 61 62 69 6c 69 74 69 65 73 00 40 3f 00 00 00 00 00 00 00 00 09 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74 75 73 00 04 63 6f 64 65 02 00 1d 4e 65 74 43 6f 6e 6e 65 63 74 69 6f 6e 2e 43 6f 6e 6e 65 63 74 2e 53 75 63 63 65 73 73 00 0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 15 43 6f 6e 6e 65 63 74 69 6f 6e 20 73 75 63 63 65 65 64 65 64 2e 00 0e 6f 62 6a 65 63 74 45 6e 63 6f 64 69 6e 67 00 00 00 00 00 00 00 00 00 00 00 09]\n\n```\n\n建立流\n```\n-->\nreleaseStream\nFCPublish\ncreateStream\n<-- _result()\n[03 00 00 00 00 00 1d 14 00 00 00 00 02 00 07 5f 72 65 73 75 6c 74 00 40 10 00 00 00 00 00 00 05 00 3f f0 00 00 00 00 00 00]\n\n\n\n\n-->\npublish\n<-- onStatus('NetStream.Publish.Start')\n[05 00 00 00 00 00 69 14 01 00 00 00 02 00 08 6f 6e 53 74 61 74 75 73 00 00 00 00 00 00 00 00 00 05 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74 75 73 00 04 63 6f 64 65 02 00 17 4e 65 74 53 74 72 65 61 6d 2e 50 75 62 6c 69 73 68 2e 53 74 61 72 74 00 0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 10 53 74 61 72 74 20 70 75 62 6c 69 73 68 69 6e 67 00 00 09]\n\n```\n\n至此连接建立完毕, Obs开始推流\n\n#### RTMP推流协议部分\n\nRTMP的消息单元称为Message单个Message太大被拆分为多块 包装在Message Chunk中发送\n\n所以服务器端需要从TCP流中获取Message Chunk组装出Message 再从Message中获取到音视频数据\n\n\n##### Message Chunk\n`Message Chunk` = `Message Chunk Header` + `Chunk Data`\n\n`Message Chunk Header` = `Basic Header` + `Message Header` + `extern timestamp`\n\n如以下例子\n```\n0000   04 00 00 00 00 00 31 09 01 00 00 00 17 00 00 00\n0010   00 01 64 00 28 ff e1 00 1d 67 64 00 28 ac d9 40\n0020   78 02 27 e5 9a 80 80 80 a0 00 00 03 00 20 00 00\n0030   07 91 e3 06 32 c0 01 00 04 68 ef bc b0\n```\n\n**Basic Header** \n```\n04 = 00  00 0100// fmt = 0 csid = 4\n```\n1字节 初期只关注csid为4的数据部分, 因为csid为4时对应音视频数据\n\n**Message Header**\n\nfmt = 0 11字节\n```\n00 00 00 // timestamp\n00 00 31 // msglength\n09 // typeid 9视频\n01 00 00 00 // 小端存储  message stream id\n```\n\nfmt = 1 7字节\n```\n00 00 00 // timestamp 前一个块时间戳与当前块时间戳的差值，即相对时间戳\n00 00 31 // msglength\n09 // typeid 9视频\n// 不含 message stream id 此时块与之前的块取相同的消息流ID\n```\n\nfmt = 2 3字节\n```\n00 00 00 // timestamp 前一个块时间戳与当前块时间戳的差值，即相对时间戳\n// 不含 msglength 与前一个相同\n// 09 不含typeid 9视频\n// 不含 message stream id 此时块与之前的块取相同的消息流ID\n```\n\nfmt = 3 0字节\n```\n不含头 一个消息被分成多个的时候 使用这个类型\n```\n\n至于`Chunk Data`就是Flv的data部分\n\nObs发送`@SetDataFrame()`其中Data为info_tag的data部分\nObs发送`Audio Data`其中Data为audio_tag的data部分  音频数据包\nObs发送`Video Data`其中Data为sps_pps_tag的data部分  视频数据包\n\n之后便是正常画面声音的Flv数据发送.\n\n# 文件介绍\n```\n├── CMakeLists.txt\n├── main.cpp\n├── network # 网络部分学习自muduo\n│   ├── Acceptor.cpp\n│   ├── Acceptor.h\n│   ├── Callback.h\n│   ├── Channel.cpp\n│   ├── Channel.h\n│   ├── EventLoop.cpp\n│   ├── EventLoop.h\n│   ├── InetAddress.cpp\n│   ├── InetAddress.h\n│   ├── multiplexing\n│   │   ├── Epoll.cpp\n│   │   ├── Epoll.h\n│   │   ├── MultiplexingBase.cpp\n│   │   ├── MultiplexingBase.h\n│   │   ├── Select.cpp\n│   │   └── Select.h\n│   ├── PlatformNetwork.cpp # 网络跨平台相关学习自flamingo\n│   ├── PlatformNetwork.h # 网络跨平台相关学习自flamingo\n│   ├── protocol # 将Rtmp推流者和HTTPFlv拉流者的TCP连接包装\n│   │   ├── RtmpClientConnection.cpp\n│   │   ├── RtmpClientConnection.h\n│   │   ├── RtmpServerConnection.cpp\n│   │   └── RtmpServerConnection.h\n│   ├── Socket.cpp\n│   ├── Socket.h\n│   ├── SocketOps.cpp\n│   ├── SocketOps.h\n│   ├── TcpConnection.cpp\n│   ├── TcpConnection.h\n│   ├── TcpServer.cpp\n│   ├── TcpServer.h\n│   └── test\n│       └── TcpServerTest.cpp\n└── utils\n    ├── Buffer.cpp\n    ├── Buffer.h\n    ├── codec\n    │   ├── FlvCodec.cpp # FLV解析\n    │   ├── FlvCodec.h\n    │   ├── FlvManager.cpp # 管理FLV的解析 保存重要的几个Tag\n    │   ├── FlvManager.h\n    │   ├── RtmpCodec.cpp # Rtmp解析\n    │   ├── RtmpCodec.h\n    │   ├── RtmpManager.cpp # 管理Rtmp解析 将Rtmp数据部分转换成FlvTag\n    │   ├── RtmpManager.h\n    │   └── test\n    │       ├── FlvManagerTest.cpp\n    │       └── RtmpManagerTest.cpp\n    ├── File.cpp # 文件读写工具类\n    ├── File.h\n    ├── Format.cpp # 字符串格式化\n    ├── Format.h\n    ├── Logger.cpp # 简易低性能日志\n    ├── Logger.h\n    ├── PlatformBase.cpp # 基础部分跨平台代码\n    ├── PlatformBase.h\n    ├── test\n    │   └── LoggerTest.cpp\n    ├── Timestamp.cpp\n    └── Timestamp.h\n\n8 directories, 55 files\n```\n","source":"_posts/项目制作-P2P直播平台.md","raw":"---\ntitle: P2P直播平台\ntags:\ncategories:\n  - 项目制作\ndate: 2020-12-02 12:50:02\n---\n\n# 项目说明\n\n**当前进度 支持多个RTMP推流者推流 支持多个HTTP-FLV拉流者拉取对应的流观看**\n\n**使用C++17标准 Windows和Centos平台均使用gcc编译通过正常使用**\n\n**运行后在两个推流者四个观看者情况下 Linux占用内存6MB Windows占用内存1MB CPU使用极低**\n\n**支持IPV4和IPV6**\n\n服务器端代码量 包含网络部分 5000余行\n\nHttpFlv拉流的播放器目前测试通过PotPlayer, VLC, flv.js\n\nRTMP推流播放器仅测试过Obs\n\n网络部分学习自 https://github.com/chenshuo/muduo\n\n跨平台支持学习自 https://github.com/balloonwj/flamingo\n\nHTTP包装 RTMP解析 FLV解析 参考自网络相关文档\n\n# 项目规划\n\n开发轻量级跨Windows和Linux的可用于P2P直播的`服务器端`和`观看客户端`\n\n项目不打算开发UI方面的功能, 视频将使用第三方的支持HttpFlv拉流的播放器来播放(如PotPlayer)\n\n## 开发进度\n\n支持多个RTMP推流者推流(已完成)\n\n支持多个HTTP-FLV拉流者拉取对应的流观看(已完成)\n\n开发`观看客户端`主要用于从`服务器端`接收FLV数据 本地转化成HttpFlv格式 供`HttpFlv拉流软件本地拉取` (未开发)\n\n`观看者客户端`可以从`服务器端`获取数据也可以通过P2P技术与其他`观看者客户端`进行共享 (未开发)\n\n## 初版\n\n主播使用`RTMP推流软件(如Obs)`将RTMP流发送到`服务器端` `服务器端`将Rtmp流解析生成FLV数据包装在HTTP中推送给观看者\n\n观看者直接使用`服务器端`生成的HTTPFLV地址 拉流观看\n\n\n## P2P版本 (未开发)\n\n# 使用说明\n\n**编译执行文件**\n下载源代码后在Windows平台或者Linux平台编译\n```shell\ngit clone https://github.com/HiganFish/LiveBroadcast.git\n\ncd LiveBroadcast/LiveBroadcastServer/\n\nmkdir build && cd build\n\ncmake ..\n\nmake -j4\n```\n生成运行文件`LiveBroadcastServer`\n\n\n**运行服务器**\n```shell\n./LiveBroadcastServer 4000 4100 # 4000 Rtmp推流端口 4100 HTTP-FLV拉流端口\n```\n\n**Obs推流**\n```shell\n# 设置->推流->服务器\nrtmp://[::1]:4000/test-push  # 注意 rtmp和http链接的对应关系 默认是相同的路径为同一个房间\nrtmp://127.0.0.1:4000/test-push # 可以在main.cpp中修改映射关系\n```\n\n**HTTP-FLV拉流**\n```shell\nhttp://[::1]:4000/test-push # 注意 rtmp和http链接的对应关系 默认是相同的路径为同一个房间\nhttp://127.0.0.1:4000/test-push # 可以在main.cpp中修改映射关系\n```\n\n# 项目所需技术\n\n## 服务器端\n\n### FLV\nFLV文件由一个FileHeader起头 后面为若干个FileTag 直到文件结束前四个字节\n最后四个字节是上一个FileTag的大小减去4\n\nFLV文件格式\n```\nclass FileHeader\n{\n\tchar flv[3]; // FLV\n\tuint8_t version; // 1\n\tuint8_t type_flags; // 5\n\tuint32_t header_length; // 9\n};\n\nclass FileTag\n{\n\tuint32_t previous_tag_size; // 不含previous_tag_size  sizeof 上一个Tag - 4\n\tuint8_t tag_type; // 音频 8 视频 9 scripts 18\n\tuint8_t data_size[3]; // AudioTag VideoTag 的数据长度 从stream_id后开始算起\n\tuint8_t timestamp[3];\n\tuint8_t timestamp_extend;\n\tuint8_t stream_id[3]; // 0\n\n\tchar* data;\n};\n```\n\n前三个Tag可以认为有特殊作用 所以单独说一下\n\n以后的所有Tag均为音视频数据\n```\nFileHeader file_header; // 每次开始都要发送一次\nFileTag info_tag; // 每次开始都要发送一次\nFileTag sps_pps_tag; // 每次开始都要发送一次 第一个视频tag存储编码信息\nFileTag audio_tag; // 每次开始都要发送一次 第一个音频tag存储编码信息\n\nFileTag data[N]; // 真正的数据部分\n```\n\n每次有`观看者客户端`连接的时候 都要发送一次`file_header`,`info_tag`和`sps_pps_tag` 以及`audio_tag`之后便是数据部分\n\n### RTMP\n\n#### RTMP握手协议\nObs客户端首先会发送C1 服务器端直接将C1作为S1发送回去, Obs会发送C2 服务端继续发送C1作为S2 握手成功\n\n\n商定窗口大小\n```\n-->\nconnect\n\n<-- Window Acknowledgement Size 5000000\n[02 00 00 00 00 00 04 05 00 00 00 00 00 4c 4b 40]\n\n\n<-- Set Peer Bandwidth 5000000,Dynamic|Set Chunk Size 4096|_result('NetConnection.Connect.Success')\n[02 00 00 00 00 00 05 06 00 00 00 00 00 4c 4b 40 02]\n[02 00 00 00 00 00 04 01 00 00 00 00 00 00 10 00]\n[03 00 00 00 00 00 be 14 00 00 00 00 02 00 07 5f 72 65 73 75 6c 74 00 3f f0 00 00 00 00 00 00 03 00 06 66 6d 73 56 65 72 02 00 0d 46 4d 53 2f 33 2c 30 2c 31 2c 31 32 33 00 0c 63 61 70 61 62 69 6c 69 74 69 65 73 00 40 3f 00 00 00 00 00 00 00 00 09 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74 75 73 00 04 63 6f 64 65 02 00 1d 4e 65 74 43 6f 6e 6e 65 63 74 69 6f 6e 2e 43 6f 6e 6e 65 63 74 2e 53 75 63 63 65 73 73 00 0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 15 43 6f 6e 6e 65 63 74 69 6f 6e 20 73 75 63 63 65 65 64 65 64 2e 00 0e 6f 62 6a 65 63 74 45 6e 63 6f 64 69 6e 67 00 00 00 00 00 00 00 00 00 00 00 09]\n\n```\n\n建立流\n```\n-->\nreleaseStream\nFCPublish\ncreateStream\n<-- _result()\n[03 00 00 00 00 00 1d 14 00 00 00 00 02 00 07 5f 72 65 73 75 6c 74 00 40 10 00 00 00 00 00 00 05 00 3f f0 00 00 00 00 00 00]\n\n\n\n\n-->\npublish\n<-- onStatus('NetStream.Publish.Start')\n[05 00 00 00 00 00 69 14 01 00 00 00 02 00 08 6f 6e 53 74 61 74 75 73 00 00 00 00 00 00 00 00 00 05 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74 75 73 00 04 63 6f 64 65 02 00 17 4e 65 74 53 74 72 65 61 6d 2e 50 75 62 6c 69 73 68 2e 53 74 61 72 74 00 0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 10 53 74 61 72 74 20 70 75 62 6c 69 73 68 69 6e 67 00 00 09]\n\n```\n\n至此连接建立完毕, Obs开始推流\n\n#### RTMP推流协议部分\n\nRTMP的消息单元称为Message单个Message太大被拆分为多块 包装在Message Chunk中发送\n\n所以服务器端需要从TCP流中获取Message Chunk组装出Message 再从Message中获取到音视频数据\n\n\n##### Message Chunk\n`Message Chunk` = `Message Chunk Header` + `Chunk Data`\n\n`Message Chunk Header` = `Basic Header` + `Message Header` + `extern timestamp`\n\n如以下例子\n```\n0000   04 00 00 00 00 00 31 09 01 00 00 00 17 00 00 00\n0010   00 01 64 00 28 ff e1 00 1d 67 64 00 28 ac d9 40\n0020   78 02 27 e5 9a 80 80 80 a0 00 00 03 00 20 00 00\n0030   07 91 e3 06 32 c0 01 00 04 68 ef bc b0\n```\n\n**Basic Header** \n```\n04 = 00  00 0100// fmt = 0 csid = 4\n```\n1字节 初期只关注csid为4的数据部分, 因为csid为4时对应音视频数据\n\n**Message Header**\n\nfmt = 0 11字节\n```\n00 00 00 // timestamp\n00 00 31 // msglength\n09 // typeid 9视频\n01 00 00 00 // 小端存储  message stream id\n```\n\nfmt = 1 7字节\n```\n00 00 00 // timestamp 前一个块时间戳与当前块时间戳的差值，即相对时间戳\n00 00 31 // msglength\n09 // typeid 9视频\n// 不含 message stream id 此时块与之前的块取相同的消息流ID\n```\n\nfmt = 2 3字节\n```\n00 00 00 // timestamp 前一个块时间戳与当前块时间戳的差值，即相对时间戳\n// 不含 msglength 与前一个相同\n// 09 不含typeid 9视频\n// 不含 message stream id 此时块与之前的块取相同的消息流ID\n```\n\nfmt = 3 0字节\n```\n不含头 一个消息被分成多个的时候 使用这个类型\n```\n\n至于`Chunk Data`就是Flv的data部分\n\nObs发送`@SetDataFrame()`其中Data为info_tag的data部分\nObs发送`Audio Data`其中Data为audio_tag的data部分  音频数据包\nObs发送`Video Data`其中Data为sps_pps_tag的data部分  视频数据包\n\n之后便是正常画面声音的Flv数据发送.\n\n# 文件介绍\n```\n├── CMakeLists.txt\n├── main.cpp\n├── network # 网络部分学习自muduo\n│   ├── Acceptor.cpp\n│   ├── Acceptor.h\n│   ├── Callback.h\n│   ├── Channel.cpp\n│   ├── Channel.h\n│   ├── EventLoop.cpp\n│   ├── EventLoop.h\n│   ├── InetAddress.cpp\n│   ├── InetAddress.h\n│   ├── multiplexing\n│   │   ├── Epoll.cpp\n│   │   ├── Epoll.h\n│   │   ├── MultiplexingBase.cpp\n│   │   ├── MultiplexingBase.h\n│   │   ├── Select.cpp\n│   │   └── Select.h\n│   ├── PlatformNetwork.cpp # 网络跨平台相关学习自flamingo\n│   ├── PlatformNetwork.h # 网络跨平台相关学习自flamingo\n│   ├── protocol # 将Rtmp推流者和HTTPFlv拉流者的TCP连接包装\n│   │   ├── RtmpClientConnection.cpp\n│   │   ├── RtmpClientConnection.h\n│   │   ├── RtmpServerConnection.cpp\n│   │   └── RtmpServerConnection.h\n│   ├── Socket.cpp\n│   ├── Socket.h\n│   ├── SocketOps.cpp\n│   ├── SocketOps.h\n│   ├── TcpConnection.cpp\n│   ├── TcpConnection.h\n│   ├── TcpServer.cpp\n│   ├── TcpServer.h\n│   └── test\n│       └── TcpServerTest.cpp\n└── utils\n    ├── Buffer.cpp\n    ├── Buffer.h\n    ├── codec\n    │   ├── FlvCodec.cpp # FLV解析\n    │   ├── FlvCodec.h\n    │   ├── FlvManager.cpp # 管理FLV的解析 保存重要的几个Tag\n    │   ├── FlvManager.h\n    │   ├── RtmpCodec.cpp # Rtmp解析\n    │   ├── RtmpCodec.h\n    │   ├── RtmpManager.cpp # 管理Rtmp解析 将Rtmp数据部分转换成FlvTag\n    │   ├── RtmpManager.h\n    │   └── test\n    │       ├── FlvManagerTest.cpp\n    │       └── RtmpManagerTest.cpp\n    ├── File.cpp # 文件读写工具类\n    ├── File.h\n    ├── Format.cpp # 字符串格式化\n    ├── Format.h\n    ├── Logger.cpp # 简易低性能日志\n    ├── Logger.h\n    ├── PlatformBase.cpp # 基础部分跨平台代码\n    ├── PlatformBase.h\n    ├── test\n    │   └── LoggerTest.cpp\n    ├── Timestamp.cpp\n    └── Timestamp.h\n\n8 directories, 55 files\n```\n","slug":"项目制作-P2P直播平台","published":1,"updated":"2020-12-02T11:11:25.538Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg7h004if8un51pzh2i9","content":"<h1 id=\"项目说明\"><a href=\"#项目说明\" class=\"headerlink\" title=\"项目说明\"></a>项目说明</h1><p><strong>当前进度 支持多个RTMP推流者推流 支持多个HTTP-FLV拉流者拉取对应的流观看</strong></p>\n<p><strong>使用C++17标准 Windows和Centos平台均使用gcc编译通过正常使用</strong></p>\n<p><strong>运行后在两个推流者四个观看者情况下 Linux占用内存6MB Windows占用内存1MB CPU使用极低</strong></p>\n<p><strong>支持IPV4和IPV6</strong></p>\n<p>服务器端代码量 包含网络部分 5000余行</p>\n<p>HttpFlv拉流的播放器目前测试通过PotPlayer, VLC, flv.js</p>\n<p>RTMP推流播放器仅测试过Obs</p>\n<p>网络部分学习自 <a href=\"https://github.com/chenshuo/muduo\" target=\"_blank\" rel=\"noopener\">https://github.com/chenshuo/muduo</a></p>\n<p>跨平台支持学习自 <a href=\"https://github.com/balloonwj/flamingo\" target=\"_blank\" rel=\"noopener\">https://github.com/balloonwj/flamingo</a></p>\n<p>HTTP包装 RTMP解析 FLV解析 参考自网络相关文档</p>\n<h1 id=\"项目规划\"><a href=\"#项目规划\" class=\"headerlink\" title=\"项目规划\"></a>项目规划</h1><p>开发轻量级跨Windows和Linux的可用于P2P直播的<code>服务器端</code>和<code>观看客户端</code></p>\n<p>项目不打算开发UI方面的功能, 视频将使用第三方的支持HttpFlv拉流的播放器来播放(如PotPlayer)</p>\n<h2 id=\"开发进度\"><a href=\"#开发进度\" class=\"headerlink\" title=\"开发进度\"></a>开发进度</h2><p>支持多个RTMP推流者推流(已完成)</p>\n<p>支持多个HTTP-FLV拉流者拉取对应的流观看(已完成)</p>\n<p>开发<code>观看客户端</code>主要用于从<code>服务器端</code>接收FLV数据 本地转化成HttpFlv格式 供<code>HttpFlv拉流软件本地拉取</code> (未开发)</p>\n<p><code>观看者客户端</code>可以从<code>服务器端</code>获取数据也可以通过P2P技术与其他<code>观看者客户端</code>进行共享 (未开发)</p>\n<h2 id=\"初版\"><a href=\"#初版\" class=\"headerlink\" title=\"初版\"></a>初版</h2><p>主播使用<code>RTMP推流软件(如Obs)</code>将RTMP流发送到<code>服务器端</code> <code>服务器端</code>将Rtmp流解析生成FLV数据包装在HTTP中推送给观看者</p>\n<p>观看者直接使用<code>服务器端</code>生成的HTTPFLV地址 拉流观看</p>\n<h2 id=\"P2P版本-未开发\"><a href=\"#P2P版本-未开发\" class=\"headerlink\" title=\"P2P版本 (未开发)\"></a>P2P版本 (未开发)</h2><h1 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h1><p><strong>编译执行文件</strong><br>下载源代码后在Windows平台或者Linux平台编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/HiganFish/LiveBroadcast.git</span><br><span class=\"line\"></span><br><span class=\"line\">cd LiveBroadcast/LiveBroadcastServer/</span><br><span class=\"line\"></span><br><span class=\"line\">mkdir build &amp;&amp; cd build</span><br><span class=\"line\"></span><br><span class=\"line\">cmake ..</span><br><span class=\"line\"></span><br><span class=\"line\">make -j4</span><br></pre></td></tr></table></figure>\n<p>生成运行文件<code>LiveBroadcastServer</code></p>\n<p><strong>运行服务器</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./LiveBroadcastServer 4000 4100 # 4000 Rtmp推流端口 4100 HTTP-FLV拉流端口</span><br></pre></td></tr></table></figure>\n\n<p><strong>Obs推流</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 设置-&gt;推流-&gt;服务器</span></span><br><span class=\"line\">rtmp://[::1]:4000/test-push  # 注意 rtmp和http链接的对应关系 默认是相同的路径为同一个房间</span><br><span class=\"line\">rtmp://127.0.0.1:4000/test-push # 可以在main.cpp中修改映射关系</span><br></pre></td></tr></table></figure>\n\n<p><strong>HTTP-FLV拉流</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://[::1]:4000/test-push # 注意 rtmp和http链接的对应关系 默认是相同的路径为同一个房间</span><br><span class=\"line\">http://127.0.0.1:4000/test-push # 可以在main.cpp中修改映射关系</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"项目所需技术\"><a href=\"#项目所需技术\" class=\"headerlink\" title=\"项目所需技术\"></a>项目所需技术</h1><h2 id=\"服务器端\"><a href=\"#服务器端\" class=\"headerlink\" title=\"服务器端\"></a>服务器端</h2><h3 id=\"FLV\"><a href=\"#FLV\" class=\"headerlink\" title=\"FLV\"></a>FLV</h3><p>FLV文件由一个FileHeader起头 后面为若干个FileTag 直到文件结束前四个字节<br>最后四个字节是上一个FileTag的大小减去4</p>\n<p>FLV文件格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class FileHeader</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar flv[3]; &#x2F;&#x2F; FLV</span><br><span class=\"line\">\tuint8_t version; &#x2F;&#x2F; 1</span><br><span class=\"line\">\tuint8_t type_flags; &#x2F;&#x2F; 5</span><br><span class=\"line\">\tuint32_t header_length; &#x2F;&#x2F; 9</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class FileTag</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tuint32_t previous_tag_size; &#x2F;&#x2F; 不含previous_tag_size  sizeof 上一个Tag - 4</span><br><span class=\"line\">\tuint8_t tag_type; &#x2F;&#x2F; 音频 8 视频 9 scripts 18</span><br><span class=\"line\">\tuint8_t data_size[3]; &#x2F;&#x2F; AudioTag VideoTag 的数据长度 从stream_id后开始算起</span><br><span class=\"line\">\tuint8_t timestamp[3];</span><br><span class=\"line\">\tuint8_t timestamp_extend;</span><br><span class=\"line\">\tuint8_t stream_id[3]; &#x2F;&#x2F; 0</span><br><span class=\"line\"></span><br><span class=\"line\">\tchar* data;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>前三个Tag可以认为有特殊作用 所以单独说一下</p>\n<p>以后的所有Tag均为音视频数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileHeader file_header; &#x2F;&#x2F; 每次开始都要发送一次</span><br><span class=\"line\">FileTag info_tag; &#x2F;&#x2F; 每次开始都要发送一次</span><br><span class=\"line\">FileTag sps_pps_tag; &#x2F;&#x2F; 每次开始都要发送一次 第一个视频tag存储编码信息</span><br><span class=\"line\">FileTag audio_tag; &#x2F;&#x2F; 每次开始都要发送一次 第一个音频tag存储编码信息</span><br><span class=\"line\"></span><br><span class=\"line\">FileTag data[N]; &#x2F;&#x2F; 真正的数据部分</span><br></pre></td></tr></table></figure>\n\n<p>每次有<code>观看者客户端</code>连接的时候 都要发送一次<code>file_header</code>,<code>info_tag</code>和<code>sps_pps_tag</code> 以及<code>audio_tag</code>之后便是数据部分</p>\n<h3 id=\"RTMP\"><a href=\"#RTMP\" class=\"headerlink\" title=\"RTMP\"></a>RTMP</h3><h4 id=\"RTMP握手协议\"><a href=\"#RTMP握手协议\" class=\"headerlink\" title=\"RTMP握手协议\"></a>RTMP握手协议</h4><p>Obs客户端首先会发送C1 服务器端直接将C1作为S1发送回去, Obs会发送C2 服务端继续发送C1作为S2 握手成功</p>\n<p>商定窗口大小</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--&gt;</span><br><span class=\"line\">connect</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;-- Window Acknowledgement Size 5000000</span><br><span class=\"line\">[02 00 00 00 00 00 04 05 00 00 00 00 00 4c 4b 40]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;-- Set Peer Bandwidth 5000000,Dynamic|Set Chunk Size 4096|_result(&#39;NetConnection.Connect.Success&#39;)</span><br><span class=\"line\">[02 00 00 00 00 00 05 06 00 00 00 00 00 4c 4b 40 02]</span><br><span class=\"line\">[02 00 00 00 00 00 04 01 00 00 00 00 00 00 10 00]</span><br><span class=\"line\">[03 00 00 00 00 00 be 14 00 00 00 00 02 00 07 5f 72 65 73 75 6c 74 00 3f f0 00 00 00 00 00 00 03 00 06 66 6d 73 56 65 72 02 00 0d 46 4d 53 2f 33 2c 30 2c 31 2c 31 32 33 00 0c 63 61 70 61 62 69 6c 69 74 69 65 73 00 40 3f 00 00 00 00 00 00 00 00 09 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74 75 73 00 04 63 6f 64 65 02 00 1d 4e 65 74 43 6f 6e 6e 65 63 74 69 6f 6e 2e 43 6f 6e 6e 65 63 74 2e 53 75 63 63 65 73 73 00 0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 15 43 6f 6e 6e 65 63 74 69 6f 6e 20 73 75 63 63 65 65 64 65 64 2e 00 0e 6f 62 6a 65 63 74 45 6e 63 6f 64 69 6e 67 00 00 00 00 00 00 00 00 00 00 00 09]</span><br></pre></td></tr></table></figure>\n\n<p>建立流</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--&gt;</span><br><span class=\"line\">releaseStream</span><br><span class=\"line\">FCPublish</span><br><span class=\"line\">createStream</span><br><span class=\"line\">&lt;-- _result()</span><br><span class=\"line\">[03 00 00 00 00 00 1d 14 00 00 00 00 02 00 07 5f 72 65 73 75 6c 74 00 40 10 00 00 00 00 00 00 05 00 3f f0 00 00 00 00 00 00]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">--&gt;</span><br><span class=\"line\">publish</span><br><span class=\"line\">&lt;-- onStatus(&#39;NetStream.Publish.Start&#39;)</span><br><span class=\"line\">[05 00 00 00 00 00 69 14 01 00 00 00 02 00 08 6f 6e 53 74 61 74 75 73 00 00 00 00 00 00 00 00 00 05 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74 75 73 00 04 63 6f 64 65 02 00 17 4e 65 74 53 74 72 65 61 6d 2e 50 75 62 6c 69 73 68 2e 53 74 61 72 74 00 0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 10 53 74 61 72 74 20 70 75 62 6c 69 73 68 69 6e 67 00 00 09]</span><br></pre></td></tr></table></figure>\n\n<p>至此连接建立完毕, Obs开始推流</p>\n<h4 id=\"RTMP推流协议部分\"><a href=\"#RTMP推流协议部分\" class=\"headerlink\" title=\"RTMP推流协议部分\"></a>RTMP推流协议部分</h4><p>RTMP的消息单元称为Message单个Message太大被拆分为多块 包装在Message Chunk中发送</p>\n<p>所以服务器端需要从TCP流中获取Message Chunk组装出Message 再从Message中获取到音视频数据</p>\n<h5 id=\"Message-Chunk\"><a href=\"#Message-Chunk\" class=\"headerlink\" title=\"Message Chunk\"></a>Message Chunk</h5><p><code>Message Chunk</code> = <code>Message Chunk Header</code> + <code>Chunk Data</code></p>\n<p><code>Message Chunk Header</code> = <code>Basic Header</code> + <code>Message Header</code> + <code>extern timestamp</code></p>\n<p>如以下例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000   04 00 00 00 00 00 31 09 01 00 00 00 17 00 00 00</span><br><span class=\"line\">0010   00 01 64 00 28 ff e1 00 1d 67 64 00 28 ac d9 40</span><br><span class=\"line\">0020   78 02 27 e5 9a 80 80 80 a0 00 00 03 00 20 00 00</span><br><span class=\"line\">0030   07 91 e3 06 32 c0 01 00 04 68 ef bc b0</span><br></pre></td></tr></table></figure>\n\n<p><strong>Basic Header</strong> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04 &#x3D; 00  00 0100&#x2F;&#x2F; fmt &#x3D; 0 csid &#x3D; 4</span><br></pre></td></tr></table></figure>\n<p>1字节 初期只关注csid为4的数据部分, 因为csid为4时对应音视频数据</p>\n<p><strong>Message Header</strong></p>\n<p>fmt = 0 11字节</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00 00 00 &#x2F;&#x2F; timestamp</span><br><span class=\"line\">00 00 31 &#x2F;&#x2F; msglength</span><br><span class=\"line\">09 &#x2F;&#x2F; typeid 9视频</span><br><span class=\"line\">01 00 00 00 &#x2F;&#x2F; 小端存储  message stream id</span><br></pre></td></tr></table></figure>\n\n<p>fmt = 1 7字节</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00 00 00 &#x2F;&#x2F; timestamp 前一个块时间戳与当前块时间戳的差值，即相对时间戳</span><br><span class=\"line\">00 00 31 &#x2F;&#x2F; msglength</span><br><span class=\"line\">09 &#x2F;&#x2F; typeid 9视频</span><br><span class=\"line\">&#x2F;&#x2F; 不含 message stream id 此时块与之前的块取相同的消息流ID</span><br></pre></td></tr></table></figure>\n\n<p>fmt = 2 3字节</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00 00 00 &#x2F;&#x2F; timestamp 前一个块时间戳与当前块时间戳的差值，即相对时间戳</span><br><span class=\"line\">&#x2F;&#x2F; 不含 msglength 与前一个相同</span><br><span class=\"line\">&#x2F;&#x2F; 09 不含typeid 9视频</span><br><span class=\"line\">&#x2F;&#x2F; 不含 message stream id 此时块与之前的块取相同的消息流ID</span><br></pre></td></tr></table></figure>\n\n<p>fmt = 3 0字节</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">不含头 一个消息被分成多个的时候 使用这个类型</span><br></pre></td></tr></table></figure>\n\n<p>至于<code>Chunk Data</code>就是Flv的data部分</p>\n<p>Obs发送<code>@SetDataFrame()</code>其中Data为info_tag的data部分<br>Obs发送<code>Audio Data</code>其中Data为audio_tag的data部分  音频数据包<br>Obs发送<code>Video Data</code>其中Data为sps_pps_tag的data部分  视频数据包</p>\n<p>之后便是正常画面声音的Flv数据发送.</p>\n<h1 id=\"文件介绍\"><a href=\"#文件介绍\" class=\"headerlink\" title=\"文件介绍\"></a>文件介绍</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── CMakeLists.txt</span><br><span class=\"line\">├── main.cpp</span><br><span class=\"line\">├── network # 网络部分学习自muduo</span><br><span class=\"line\">│   ├── Acceptor.cpp</span><br><span class=\"line\">│   ├── Acceptor.h</span><br><span class=\"line\">│   ├── Callback.h</span><br><span class=\"line\">│   ├── Channel.cpp</span><br><span class=\"line\">│   ├── Channel.h</span><br><span class=\"line\">│   ├── EventLoop.cpp</span><br><span class=\"line\">│   ├── EventLoop.h</span><br><span class=\"line\">│   ├── InetAddress.cpp</span><br><span class=\"line\">│   ├── InetAddress.h</span><br><span class=\"line\">│   ├── multiplexing</span><br><span class=\"line\">│   │   ├── Epoll.cpp</span><br><span class=\"line\">│   │   ├── Epoll.h</span><br><span class=\"line\">│   │   ├── MultiplexingBase.cpp</span><br><span class=\"line\">│   │   ├── MultiplexingBase.h</span><br><span class=\"line\">│   │   ├── Select.cpp</span><br><span class=\"line\">│   │   └── Select.h</span><br><span class=\"line\">│   ├── PlatformNetwork.cpp # 网络跨平台相关学习自flamingo</span><br><span class=\"line\">│   ├── PlatformNetwork.h # 网络跨平台相关学习自flamingo</span><br><span class=\"line\">│   ├── protocol # 将Rtmp推流者和HTTPFlv拉流者的TCP连接包装</span><br><span class=\"line\">│   │   ├── RtmpClientConnection.cpp</span><br><span class=\"line\">│   │   ├── RtmpClientConnection.h</span><br><span class=\"line\">│   │   ├── RtmpServerConnection.cpp</span><br><span class=\"line\">│   │   └── RtmpServerConnection.h</span><br><span class=\"line\">│   ├── Socket.cpp</span><br><span class=\"line\">│   ├── Socket.h</span><br><span class=\"line\">│   ├── SocketOps.cpp</span><br><span class=\"line\">│   ├── SocketOps.h</span><br><span class=\"line\">│   ├── TcpConnection.cpp</span><br><span class=\"line\">│   ├── TcpConnection.h</span><br><span class=\"line\">│   ├── TcpServer.cpp</span><br><span class=\"line\">│   ├── TcpServer.h</span><br><span class=\"line\">│   └── test</span><br><span class=\"line\">│       └── TcpServerTest.cpp</span><br><span class=\"line\">└── utils</span><br><span class=\"line\">    ├── Buffer.cpp</span><br><span class=\"line\">    ├── Buffer.h</span><br><span class=\"line\">    ├── codec</span><br><span class=\"line\">    │   ├── FlvCodec.cpp # FLV解析</span><br><span class=\"line\">    │   ├── FlvCodec.h</span><br><span class=\"line\">    │   ├── FlvManager.cpp # 管理FLV的解析 保存重要的几个Tag</span><br><span class=\"line\">    │   ├── FlvManager.h</span><br><span class=\"line\">    │   ├── RtmpCodec.cpp # Rtmp解析</span><br><span class=\"line\">    │   ├── RtmpCodec.h</span><br><span class=\"line\">    │   ├── RtmpManager.cpp # 管理Rtmp解析 将Rtmp数据部分转换成FlvTag</span><br><span class=\"line\">    │   ├── RtmpManager.h</span><br><span class=\"line\">    │   └── test</span><br><span class=\"line\">    │       ├── FlvManagerTest.cpp</span><br><span class=\"line\">    │       └── RtmpManagerTest.cpp</span><br><span class=\"line\">    ├── File.cpp # 文件读写工具类</span><br><span class=\"line\">    ├── File.h</span><br><span class=\"line\">    ├── Format.cpp # 字符串格式化</span><br><span class=\"line\">    ├── Format.h</span><br><span class=\"line\">    ├── Logger.cpp # 简易低性能日志</span><br><span class=\"line\">    ├── Logger.h</span><br><span class=\"line\">    ├── PlatformBase.cpp # 基础部分跨平台代码</span><br><span class=\"line\">    ├── PlatformBase.h</span><br><span class=\"line\">    ├── test</span><br><span class=\"line\">    │   └── LoggerTest.cpp</span><br><span class=\"line\">    ├── Timestamp.cpp</span><br><span class=\"line\">    └── Timestamp.h</span><br><span class=\"line\"></span><br><span class=\"line\">8 directories, 55 files</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"项目说明\"><a href=\"#项目说明\" class=\"headerlink\" title=\"项目说明\"></a>项目说明</h1><p><strong>当前进度 支持多个RTMP推流者推流 支持多个HTTP-FLV拉流者拉取对应的流观看</strong></p>\n<p><strong>使用C++17标准 Windows和Centos平台均使用gcc编译通过正常使用</strong></p>\n<p><strong>运行后在两个推流者四个观看者情况下 Linux占用内存6MB Windows占用内存1MB CPU使用极低</strong></p>\n<p><strong>支持IPV4和IPV6</strong></p>\n<p>服务器端代码量 包含网络部分 5000余行</p>\n<p>HttpFlv拉流的播放器目前测试通过PotPlayer, VLC, flv.js</p>\n<p>RTMP推流播放器仅测试过Obs</p>\n<p>网络部分学习自 <a href=\"https://github.com/chenshuo/muduo\" target=\"_blank\" rel=\"noopener\">https://github.com/chenshuo/muduo</a></p>\n<p>跨平台支持学习自 <a href=\"https://github.com/balloonwj/flamingo\" target=\"_blank\" rel=\"noopener\">https://github.com/balloonwj/flamingo</a></p>\n<p>HTTP包装 RTMP解析 FLV解析 参考自网络相关文档</p>\n<h1 id=\"项目规划\"><a href=\"#项目规划\" class=\"headerlink\" title=\"项目规划\"></a>项目规划</h1><p>开发轻量级跨Windows和Linux的可用于P2P直播的<code>服务器端</code>和<code>观看客户端</code></p>\n<p>项目不打算开发UI方面的功能, 视频将使用第三方的支持HttpFlv拉流的播放器来播放(如PotPlayer)</p>\n<h2 id=\"开发进度\"><a href=\"#开发进度\" class=\"headerlink\" title=\"开发进度\"></a>开发进度</h2><p>支持多个RTMP推流者推流(已完成)</p>\n<p>支持多个HTTP-FLV拉流者拉取对应的流观看(已完成)</p>\n<p>开发<code>观看客户端</code>主要用于从<code>服务器端</code>接收FLV数据 本地转化成HttpFlv格式 供<code>HttpFlv拉流软件本地拉取</code> (未开发)</p>\n<p><code>观看者客户端</code>可以从<code>服务器端</code>获取数据也可以通过P2P技术与其他<code>观看者客户端</code>进行共享 (未开发)</p>\n<h2 id=\"初版\"><a href=\"#初版\" class=\"headerlink\" title=\"初版\"></a>初版</h2><p>主播使用<code>RTMP推流软件(如Obs)</code>将RTMP流发送到<code>服务器端</code> <code>服务器端</code>将Rtmp流解析生成FLV数据包装在HTTP中推送给观看者</p>\n<p>观看者直接使用<code>服务器端</code>生成的HTTPFLV地址 拉流观看</p>\n<h2 id=\"P2P版本-未开发\"><a href=\"#P2P版本-未开发\" class=\"headerlink\" title=\"P2P版本 (未开发)\"></a>P2P版本 (未开发)</h2><h1 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h1><p><strong>编译执行文件</strong><br>下载源代码后在Windows平台或者Linux平台编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/HiganFish/LiveBroadcast.git</span><br><span class=\"line\"></span><br><span class=\"line\">cd LiveBroadcast/LiveBroadcastServer/</span><br><span class=\"line\"></span><br><span class=\"line\">mkdir build &amp;&amp; cd build</span><br><span class=\"line\"></span><br><span class=\"line\">cmake ..</span><br><span class=\"line\"></span><br><span class=\"line\">make -j4</span><br></pre></td></tr></table></figure>\n<p>生成运行文件<code>LiveBroadcastServer</code></p>\n<p><strong>运行服务器</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./LiveBroadcastServer 4000 4100 # 4000 Rtmp推流端口 4100 HTTP-FLV拉流端口</span><br></pre></td></tr></table></figure>\n\n<p><strong>Obs推流</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 设置-&gt;推流-&gt;服务器</span></span><br><span class=\"line\">rtmp://[::1]:4000/test-push  # 注意 rtmp和http链接的对应关系 默认是相同的路径为同一个房间</span><br><span class=\"line\">rtmp://127.0.0.1:4000/test-push # 可以在main.cpp中修改映射关系</span><br></pre></td></tr></table></figure>\n\n<p><strong>HTTP-FLV拉流</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://[::1]:4000/test-push # 注意 rtmp和http链接的对应关系 默认是相同的路径为同一个房间</span><br><span class=\"line\">http://127.0.0.1:4000/test-push # 可以在main.cpp中修改映射关系</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"项目所需技术\"><a href=\"#项目所需技术\" class=\"headerlink\" title=\"项目所需技术\"></a>项目所需技术</h1><h2 id=\"服务器端\"><a href=\"#服务器端\" class=\"headerlink\" title=\"服务器端\"></a>服务器端</h2><h3 id=\"FLV\"><a href=\"#FLV\" class=\"headerlink\" title=\"FLV\"></a>FLV</h3><p>FLV文件由一个FileHeader起头 后面为若干个FileTag 直到文件结束前四个字节<br>最后四个字节是上一个FileTag的大小减去4</p>\n<p>FLV文件格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class FileHeader</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tchar flv[3]; &#x2F;&#x2F; FLV</span><br><span class=\"line\">\tuint8_t version; &#x2F;&#x2F; 1</span><br><span class=\"line\">\tuint8_t type_flags; &#x2F;&#x2F; 5</span><br><span class=\"line\">\tuint32_t header_length; &#x2F;&#x2F; 9</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">class FileTag</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tuint32_t previous_tag_size; &#x2F;&#x2F; 不含previous_tag_size  sizeof 上一个Tag - 4</span><br><span class=\"line\">\tuint8_t tag_type; &#x2F;&#x2F; 音频 8 视频 9 scripts 18</span><br><span class=\"line\">\tuint8_t data_size[3]; &#x2F;&#x2F; AudioTag VideoTag 的数据长度 从stream_id后开始算起</span><br><span class=\"line\">\tuint8_t timestamp[3];</span><br><span class=\"line\">\tuint8_t timestamp_extend;</span><br><span class=\"line\">\tuint8_t stream_id[3]; &#x2F;&#x2F; 0</span><br><span class=\"line\"></span><br><span class=\"line\">\tchar* data;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>前三个Tag可以认为有特殊作用 所以单独说一下</p>\n<p>以后的所有Tag均为音视频数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileHeader file_header; &#x2F;&#x2F; 每次开始都要发送一次</span><br><span class=\"line\">FileTag info_tag; &#x2F;&#x2F; 每次开始都要发送一次</span><br><span class=\"line\">FileTag sps_pps_tag; &#x2F;&#x2F; 每次开始都要发送一次 第一个视频tag存储编码信息</span><br><span class=\"line\">FileTag audio_tag; &#x2F;&#x2F; 每次开始都要发送一次 第一个音频tag存储编码信息</span><br><span class=\"line\"></span><br><span class=\"line\">FileTag data[N]; &#x2F;&#x2F; 真正的数据部分</span><br></pre></td></tr></table></figure>\n\n<p>每次有<code>观看者客户端</code>连接的时候 都要发送一次<code>file_header</code>,<code>info_tag</code>和<code>sps_pps_tag</code> 以及<code>audio_tag</code>之后便是数据部分</p>\n<h3 id=\"RTMP\"><a href=\"#RTMP\" class=\"headerlink\" title=\"RTMP\"></a>RTMP</h3><h4 id=\"RTMP握手协议\"><a href=\"#RTMP握手协议\" class=\"headerlink\" title=\"RTMP握手协议\"></a>RTMP握手协议</h4><p>Obs客户端首先会发送C1 服务器端直接将C1作为S1发送回去, Obs会发送C2 服务端继续发送C1作为S2 握手成功</p>\n<p>商定窗口大小</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--&gt;</span><br><span class=\"line\">connect</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;-- Window Acknowledgement Size 5000000</span><br><span class=\"line\">[02 00 00 00 00 00 04 05 00 00 00 00 00 4c 4b 40]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;-- Set Peer Bandwidth 5000000,Dynamic|Set Chunk Size 4096|_result(&#39;NetConnection.Connect.Success&#39;)</span><br><span class=\"line\">[02 00 00 00 00 00 05 06 00 00 00 00 00 4c 4b 40 02]</span><br><span class=\"line\">[02 00 00 00 00 00 04 01 00 00 00 00 00 00 10 00]</span><br><span class=\"line\">[03 00 00 00 00 00 be 14 00 00 00 00 02 00 07 5f 72 65 73 75 6c 74 00 3f f0 00 00 00 00 00 00 03 00 06 66 6d 73 56 65 72 02 00 0d 46 4d 53 2f 33 2c 30 2c 31 2c 31 32 33 00 0c 63 61 70 61 62 69 6c 69 74 69 65 73 00 40 3f 00 00 00 00 00 00 00 00 09 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74 75 73 00 04 63 6f 64 65 02 00 1d 4e 65 74 43 6f 6e 6e 65 63 74 69 6f 6e 2e 43 6f 6e 6e 65 63 74 2e 53 75 63 63 65 73 73 00 0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 15 43 6f 6e 6e 65 63 74 69 6f 6e 20 73 75 63 63 65 65 64 65 64 2e 00 0e 6f 62 6a 65 63 74 45 6e 63 6f 64 69 6e 67 00 00 00 00 00 00 00 00 00 00 00 09]</span><br></pre></td></tr></table></figure>\n\n<p>建立流</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--&gt;</span><br><span class=\"line\">releaseStream</span><br><span class=\"line\">FCPublish</span><br><span class=\"line\">createStream</span><br><span class=\"line\">&lt;-- _result()</span><br><span class=\"line\">[03 00 00 00 00 00 1d 14 00 00 00 00 02 00 07 5f 72 65 73 75 6c 74 00 40 10 00 00 00 00 00 00 05 00 3f f0 00 00 00 00 00 00]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">--&gt;</span><br><span class=\"line\">publish</span><br><span class=\"line\">&lt;-- onStatus(&#39;NetStream.Publish.Start&#39;)</span><br><span class=\"line\">[05 00 00 00 00 00 69 14 01 00 00 00 02 00 08 6f 6e 53 74 61 74 75 73 00 00 00 00 00 00 00 00 00 05 03 00 05 6c 65 76 65 6c 02 00 06 73 74 61 74 75 73 00 04 63 6f 64 65 02 00 17 4e 65 74 53 74 72 65 61 6d 2e 50 75 62 6c 69 73 68 2e 53 74 61 72 74 00 0b 64 65 73 63 72 69 70 74 69 6f 6e 02 00 10 53 74 61 72 74 20 70 75 62 6c 69 73 68 69 6e 67 00 00 09]</span><br></pre></td></tr></table></figure>\n\n<p>至此连接建立完毕, Obs开始推流</p>\n<h4 id=\"RTMP推流协议部分\"><a href=\"#RTMP推流协议部分\" class=\"headerlink\" title=\"RTMP推流协议部分\"></a>RTMP推流协议部分</h4><p>RTMP的消息单元称为Message单个Message太大被拆分为多块 包装在Message Chunk中发送</p>\n<p>所以服务器端需要从TCP流中获取Message Chunk组装出Message 再从Message中获取到音视频数据</p>\n<h5 id=\"Message-Chunk\"><a href=\"#Message-Chunk\" class=\"headerlink\" title=\"Message Chunk\"></a>Message Chunk</h5><p><code>Message Chunk</code> = <code>Message Chunk Header</code> + <code>Chunk Data</code></p>\n<p><code>Message Chunk Header</code> = <code>Basic Header</code> + <code>Message Header</code> + <code>extern timestamp</code></p>\n<p>如以下例子</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000   04 00 00 00 00 00 31 09 01 00 00 00 17 00 00 00</span><br><span class=\"line\">0010   00 01 64 00 28 ff e1 00 1d 67 64 00 28 ac d9 40</span><br><span class=\"line\">0020   78 02 27 e5 9a 80 80 80 a0 00 00 03 00 20 00 00</span><br><span class=\"line\">0030   07 91 e3 06 32 c0 01 00 04 68 ef bc b0</span><br></pre></td></tr></table></figure>\n\n<p><strong>Basic Header</strong> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">04 &#x3D; 00  00 0100&#x2F;&#x2F; fmt &#x3D; 0 csid &#x3D; 4</span><br></pre></td></tr></table></figure>\n<p>1字节 初期只关注csid为4的数据部分, 因为csid为4时对应音视频数据</p>\n<p><strong>Message Header</strong></p>\n<p>fmt = 0 11字节</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00 00 00 &#x2F;&#x2F; timestamp</span><br><span class=\"line\">00 00 31 &#x2F;&#x2F; msglength</span><br><span class=\"line\">09 &#x2F;&#x2F; typeid 9视频</span><br><span class=\"line\">01 00 00 00 &#x2F;&#x2F; 小端存储  message stream id</span><br></pre></td></tr></table></figure>\n\n<p>fmt = 1 7字节</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00 00 00 &#x2F;&#x2F; timestamp 前一个块时间戳与当前块时间戳的差值，即相对时间戳</span><br><span class=\"line\">00 00 31 &#x2F;&#x2F; msglength</span><br><span class=\"line\">09 &#x2F;&#x2F; typeid 9视频</span><br><span class=\"line\">&#x2F;&#x2F; 不含 message stream id 此时块与之前的块取相同的消息流ID</span><br></pre></td></tr></table></figure>\n\n<p>fmt = 2 3字节</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">00 00 00 &#x2F;&#x2F; timestamp 前一个块时间戳与当前块时间戳的差值，即相对时间戳</span><br><span class=\"line\">&#x2F;&#x2F; 不含 msglength 与前一个相同</span><br><span class=\"line\">&#x2F;&#x2F; 09 不含typeid 9视频</span><br><span class=\"line\">&#x2F;&#x2F; 不含 message stream id 此时块与之前的块取相同的消息流ID</span><br></pre></td></tr></table></figure>\n\n<p>fmt = 3 0字节</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">不含头 一个消息被分成多个的时候 使用这个类型</span><br></pre></td></tr></table></figure>\n\n<p>至于<code>Chunk Data</code>就是Flv的data部分</p>\n<p>Obs发送<code>@SetDataFrame()</code>其中Data为info_tag的data部分<br>Obs发送<code>Audio Data</code>其中Data为audio_tag的data部分  音频数据包<br>Obs发送<code>Video Data</code>其中Data为sps_pps_tag的data部分  视频数据包</p>\n<p>之后便是正常画面声音的Flv数据发送.</p>\n<h1 id=\"文件介绍\"><a href=\"#文件介绍\" class=\"headerlink\" title=\"文件介绍\"></a>文件介绍</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── CMakeLists.txt</span><br><span class=\"line\">├── main.cpp</span><br><span class=\"line\">├── network # 网络部分学习自muduo</span><br><span class=\"line\">│   ├── Acceptor.cpp</span><br><span class=\"line\">│   ├── Acceptor.h</span><br><span class=\"line\">│   ├── Callback.h</span><br><span class=\"line\">│   ├── Channel.cpp</span><br><span class=\"line\">│   ├── Channel.h</span><br><span class=\"line\">│   ├── EventLoop.cpp</span><br><span class=\"line\">│   ├── EventLoop.h</span><br><span class=\"line\">│   ├── InetAddress.cpp</span><br><span class=\"line\">│   ├── InetAddress.h</span><br><span class=\"line\">│   ├── multiplexing</span><br><span class=\"line\">│   │   ├── Epoll.cpp</span><br><span class=\"line\">│   │   ├── Epoll.h</span><br><span class=\"line\">│   │   ├── MultiplexingBase.cpp</span><br><span class=\"line\">│   │   ├── MultiplexingBase.h</span><br><span class=\"line\">│   │   ├── Select.cpp</span><br><span class=\"line\">│   │   └── Select.h</span><br><span class=\"line\">│   ├── PlatformNetwork.cpp # 网络跨平台相关学习自flamingo</span><br><span class=\"line\">│   ├── PlatformNetwork.h # 网络跨平台相关学习自flamingo</span><br><span class=\"line\">│   ├── protocol # 将Rtmp推流者和HTTPFlv拉流者的TCP连接包装</span><br><span class=\"line\">│   │   ├── RtmpClientConnection.cpp</span><br><span class=\"line\">│   │   ├── RtmpClientConnection.h</span><br><span class=\"line\">│   │   ├── RtmpServerConnection.cpp</span><br><span class=\"line\">│   │   └── RtmpServerConnection.h</span><br><span class=\"line\">│   ├── Socket.cpp</span><br><span class=\"line\">│   ├── Socket.h</span><br><span class=\"line\">│   ├── SocketOps.cpp</span><br><span class=\"line\">│   ├── SocketOps.h</span><br><span class=\"line\">│   ├── TcpConnection.cpp</span><br><span class=\"line\">│   ├── TcpConnection.h</span><br><span class=\"line\">│   ├── TcpServer.cpp</span><br><span class=\"line\">│   ├── TcpServer.h</span><br><span class=\"line\">│   └── test</span><br><span class=\"line\">│       └── TcpServerTest.cpp</span><br><span class=\"line\">└── utils</span><br><span class=\"line\">    ├── Buffer.cpp</span><br><span class=\"line\">    ├── Buffer.h</span><br><span class=\"line\">    ├── codec</span><br><span class=\"line\">    │   ├── FlvCodec.cpp # FLV解析</span><br><span class=\"line\">    │   ├── FlvCodec.h</span><br><span class=\"line\">    │   ├── FlvManager.cpp # 管理FLV的解析 保存重要的几个Tag</span><br><span class=\"line\">    │   ├── FlvManager.h</span><br><span class=\"line\">    │   ├── RtmpCodec.cpp # Rtmp解析</span><br><span class=\"line\">    │   ├── RtmpCodec.h</span><br><span class=\"line\">    │   ├── RtmpManager.cpp # 管理Rtmp解析 将Rtmp数据部分转换成FlvTag</span><br><span class=\"line\">    │   ├── RtmpManager.h</span><br><span class=\"line\">    │   └── test</span><br><span class=\"line\">    │       ├── FlvManagerTest.cpp</span><br><span class=\"line\">    │       └── RtmpManagerTest.cpp</span><br><span class=\"line\">    ├── File.cpp # 文件读写工具类</span><br><span class=\"line\">    ├── File.h</span><br><span class=\"line\">    ├── Format.cpp # 字符串格式化</span><br><span class=\"line\">    ├── Format.h</span><br><span class=\"line\">    ├── Logger.cpp # 简易低性能日志</span><br><span class=\"line\">    ├── Logger.h</span><br><span class=\"line\">    ├── PlatformBase.cpp # 基础部分跨平台代码</span><br><span class=\"line\">    ├── PlatformBase.h</span><br><span class=\"line\">    ├── test</span><br><span class=\"line\">    │   └── LoggerTest.cpp</span><br><span class=\"line\">    ├── Timestamp.cpp</span><br><span class=\"line\">    └── Timestamp.h</span><br><span class=\"line\"></span><br><span class=\"line\">8 directories, 55 files</span><br></pre></td></tr></table></figure>\n"},{"title":"陀螺球(废弃)","date":"2020-06-02T04:50:02.000Z","_content":"\n# 基础设计\n## 基本玩法\n使用手机陀螺仪控制圆形小球的移动.  存在各种关卡组件以及小球装备 从初始点最终到达目的地\n\n首先考虑制作出地图编辑器\n玩家可以下载并游玩其他人创建的地图\n\n其次增加双人联机的功能 双人共同通关?\n\n包含计时以及通关星数 通过碰撞获得两颗星 关卡时间一颗星\n\n## 关卡组件\n\n| 物品代码 | 物品名称 | 物品描述 |\n| --- | --- | --- | \n| 10001 | 基础方块 | 提供基础阻挡功能 |\n| 10002 | 出生点 | |\n| 10003 | 终点 | |\n| 10004 | 关卡星星 | 用于增加通关星数 |\n| 10100 | 加速 | 提供一个方向的瞬时力 |\n\n### 基础方块\n\n均使用int\n\n| 10001 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z | 物品缩放X | 物品缩放Y | 物品缩放Z |\n\n### 出生点\n\n| 10002 | 位置X | 位置Y | 位置Z |\n\n### 终点\n\n| 10003 | 位置X | 位置Y | 位置Z |\n\n### 关卡星星\n\n| 10004 | 位置X | 位置Y | 位置Z |\n\n增加一颗通关星1\n\n| 10005 | 位置X | 位置Y | 位置Z |\n\n增加一颗通关星2\n\n### 加速\n\n| 10100 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z |\n\n提供方块对向的瞬时力\n- 用于改善体验\n- 用于所短时间完成要求\n\n### 传送\n| 10101 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z | 颜色代码 |\n\n\n## 小球装备\n\n\n## 地图设计\n\n# 前端实现\n\n创建基础方块父类\n\n父类必要组件\n- Static Mesh\n\n父类函数\n- Serialize(TArray<int32>& Data);\n\n必要成员变量\n- 物品代码\n- 物品参数数量\n\n## 地图保存\n\n\n调用各个组件的Serialize将各自的数据保存入Data\n\n## 地图加载\n\nstruct Component\n{\n  TSubclassOf<组件父类> Obj\n  int Nums 生成此组件需要的参数数量\n}\n\nTMap<int32, Component>","source":"_posts/项目制作-陀螺球.md","raw":"---\ntitle: 陀螺球(废弃)\ntags:\n  - 陀螺球\ncategories:\n  - 项目制作\ndate: 2020-06-02 12:50:02\n---\n\n# 基础设计\n## 基本玩法\n使用手机陀螺仪控制圆形小球的移动.  存在各种关卡组件以及小球装备 从初始点最终到达目的地\n\n首先考虑制作出地图编辑器\n玩家可以下载并游玩其他人创建的地图\n\n其次增加双人联机的功能 双人共同通关?\n\n包含计时以及通关星数 通过碰撞获得两颗星 关卡时间一颗星\n\n## 关卡组件\n\n| 物品代码 | 物品名称 | 物品描述 |\n| --- | --- | --- | \n| 10001 | 基础方块 | 提供基础阻挡功能 |\n| 10002 | 出生点 | |\n| 10003 | 终点 | |\n| 10004 | 关卡星星 | 用于增加通关星数 |\n| 10100 | 加速 | 提供一个方向的瞬时力 |\n\n### 基础方块\n\n均使用int\n\n| 10001 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z | 物品缩放X | 物品缩放Y | 物品缩放Z |\n\n### 出生点\n\n| 10002 | 位置X | 位置Y | 位置Z |\n\n### 终点\n\n| 10003 | 位置X | 位置Y | 位置Z |\n\n### 关卡星星\n\n| 10004 | 位置X | 位置Y | 位置Z |\n\n增加一颗通关星1\n\n| 10005 | 位置X | 位置Y | 位置Z |\n\n增加一颗通关星2\n\n### 加速\n\n| 10100 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z |\n\n提供方块对向的瞬时力\n- 用于改善体验\n- 用于所短时间完成要求\n\n### 传送\n| 10101 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z | 颜色代码 |\n\n\n## 小球装备\n\n\n## 地图设计\n\n# 前端实现\n\n创建基础方块父类\n\n父类必要组件\n- Static Mesh\n\n父类函数\n- Serialize(TArray<int32>& Data);\n\n必要成员变量\n- 物品代码\n- 物品参数数量\n\n## 地图保存\n\n\n调用各个组件的Serialize将各自的数据保存入Data\n\n## 地图加载\n\nstruct Component\n{\n  TSubclassOf<组件父类> Obj\n  int Nums 生成此组件需要的参数数量\n}\n\nTMap<int32, Component>","slug":"项目制作-陀螺球","published":1,"updated":"2020-11-09T08:02:09.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckibtjg7i004lf8unaxebf43x","content":"<h1 id=\"基础设计\"><a href=\"#基础设计\" class=\"headerlink\" title=\"基础设计\"></a>基础设计</h1><h2 id=\"基本玩法\"><a href=\"#基本玩法\" class=\"headerlink\" title=\"基本玩法\"></a>基本玩法</h2><p>使用手机陀螺仪控制圆形小球的移动.  存在各种关卡组件以及小球装备 从初始点最终到达目的地</p>\n<p>首先考虑制作出地图编辑器<br>玩家可以下载并游玩其他人创建的地图</p>\n<p>其次增加双人联机的功能 双人共同通关?</p>\n<p>包含计时以及通关星数 通过碰撞获得两颗星 关卡时间一颗星</p>\n<h2 id=\"关卡组件\"><a href=\"#关卡组件\" class=\"headerlink\" title=\"关卡组件\"></a>关卡组件</h2><table>\n<thead>\n<tr>\n<th>物品代码</th>\n<th>物品名称</th>\n<th>物品描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>10001</td>\n<td>基础方块</td>\n<td>提供基础阻挡功能</td>\n</tr>\n<tr>\n<td>10002</td>\n<td>出生点</td>\n<td></td>\n</tr>\n<tr>\n<td>10003</td>\n<td>终点</td>\n<td></td>\n</tr>\n<tr>\n<td>10004</td>\n<td>关卡星星</td>\n<td>用于增加通关星数</td>\n</tr>\n<tr>\n<td>10100</td>\n<td>加速</td>\n<td>提供一个方向的瞬时力</td>\n</tr>\n</tbody></table>\n<h3 id=\"基础方块\"><a href=\"#基础方块\" class=\"headerlink\" title=\"基础方块\"></a>基础方块</h3><p>均使用int</p>\n<p>| 10001 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z | 物品缩放X | 物品缩放Y | 物品缩放Z |</p>\n<h3 id=\"出生点\"><a href=\"#出生点\" class=\"headerlink\" title=\"出生点\"></a>出生点</h3><p>| 10002 | 位置X | 位置Y | 位置Z |</p>\n<h3 id=\"终点\"><a href=\"#终点\" class=\"headerlink\" title=\"终点\"></a>终点</h3><p>| 10003 | 位置X | 位置Y | 位置Z |</p>\n<h3 id=\"关卡星星\"><a href=\"#关卡星星\" class=\"headerlink\" title=\"关卡星星\"></a>关卡星星</h3><p>| 10004 | 位置X | 位置Y | 位置Z |</p>\n<p>增加一颗通关星1</p>\n<p>| 10005 | 位置X | 位置Y | 位置Z |</p>\n<p>增加一颗通关星2</p>\n<h3 id=\"加速\"><a href=\"#加速\" class=\"headerlink\" title=\"加速\"></a>加速</h3><p>| 10100 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z |</p>\n<p>提供方块对向的瞬时力</p>\n<ul>\n<li>用于改善体验</li>\n<li>用于所短时间完成要求</li>\n</ul>\n<h3 id=\"传送\"><a href=\"#传送\" class=\"headerlink\" title=\"传送\"></a>传送</h3><p>| 10101 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z | 颜色代码 |</p>\n<h2 id=\"小球装备\"><a href=\"#小球装备\" class=\"headerlink\" title=\"小球装备\"></a>小球装备</h2><h2 id=\"地图设计\"><a href=\"#地图设计\" class=\"headerlink\" title=\"地图设计\"></a>地图设计</h2><h1 id=\"前端实现\"><a href=\"#前端实现\" class=\"headerlink\" title=\"前端实现\"></a>前端实现</h1><p>创建基础方块父类</p>\n<p>父类必要组件</p>\n<ul>\n<li>Static Mesh</li>\n</ul>\n<p>父类函数</p>\n<ul>\n<li>Serialize(TArray<int32>&amp; Data);</li>\n</ul>\n<p>必要成员变量</p>\n<ul>\n<li>物品代码</li>\n<li>物品参数数量</li>\n</ul>\n<h2 id=\"地图保存\"><a href=\"#地图保存\" class=\"headerlink\" title=\"地图保存\"></a>地图保存</h2><p>调用各个组件的Serialize将各自的数据保存入Data</p>\n<h2 id=\"地图加载\"><a href=\"#地图加载\" class=\"headerlink\" title=\"地图加载\"></a>地图加载</h2><p>struct Component<br>{<br>  TSubclassOf&lt;组件父类&gt; Obj<br>  int Nums 生成此组件需要的参数数量<br>}</p>\n<p>TMap&lt;int32, Component&gt;</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基础设计\"><a href=\"#基础设计\" class=\"headerlink\" title=\"基础设计\"></a>基础设计</h1><h2 id=\"基本玩法\"><a href=\"#基本玩法\" class=\"headerlink\" title=\"基本玩法\"></a>基本玩法</h2><p>使用手机陀螺仪控制圆形小球的移动.  存在各种关卡组件以及小球装备 从初始点最终到达目的地</p>\n<p>首先考虑制作出地图编辑器<br>玩家可以下载并游玩其他人创建的地图</p>\n<p>其次增加双人联机的功能 双人共同通关?</p>\n<p>包含计时以及通关星数 通过碰撞获得两颗星 关卡时间一颗星</p>\n<h2 id=\"关卡组件\"><a href=\"#关卡组件\" class=\"headerlink\" title=\"关卡组件\"></a>关卡组件</h2><table>\n<thead>\n<tr>\n<th>物品代码</th>\n<th>物品名称</th>\n<th>物品描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>10001</td>\n<td>基础方块</td>\n<td>提供基础阻挡功能</td>\n</tr>\n<tr>\n<td>10002</td>\n<td>出生点</td>\n<td></td>\n</tr>\n<tr>\n<td>10003</td>\n<td>终点</td>\n<td></td>\n</tr>\n<tr>\n<td>10004</td>\n<td>关卡星星</td>\n<td>用于增加通关星数</td>\n</tr>\n<tr>\n<td>10100</td>\n<td>加速</td>\n<td>提供一个方向的瞬时力</td>\n</tr>\n</tbody></table>\n<h3 id=\"基础方块\"><a href=\"#基础方块\" class=\"headerlink\" title=\"基础方块\"></a>基础方块</h3><p>均使用int</p>\n<p>| 10001 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z | 物品缩放X | 物品缩放Y | 物品缩放Z |</p>\n<h3 id=\"出生点\"><a href=\"#出生点\" class=\"headerlink\" title=\"出生点\"></a>出生点</h3><p>| 10002 | 位置X | 位置Y | 位置Z |</p>\n<h3 id=\"终点\"><a href=\"#终点\" class=\"headerlink\" title=\"终点\"></a>终点</h3><p>| 10003 | 位置X | 位置Y | 位置Z |</p>\n<h3 id=\"关卡星星\"><a href=\"#关卡星星\" class=\"headerlink\" title=\"关卡星星\"></a>关卡星星</h3><p>| 10004 | 位置X | 位置Y | 位置Z |</p>\n<p>增加一颗通关星1</p>\n<p>| 10005 | 位置X | 位置Y | 位置Z |</p>\n<p>增加一颗通关星2</p>\n<h3 id=\"加速\"><a href=\"#加速\" class=\"headerlink\" title=\"加速\"></a>加速</h3><p>| 10100 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z |</p>\n<p>提供方块对向的瞬时力</p>\n<ul>\n<li>用于改善体验</li>\n<li>用于所短时间完成要求</li>\n</ul>\n<h3 id=\"传送\"><a href=\"#传送\" class=\"headerlink\" title=\"传送\"></a>传送</h3><p>| 10101 | 位置X | 位置Y | 位置Z | 物品旋转X | 物品旋转Y | 物品旋转Z | 颜色代码 |</p>\n<h2 id=\"小球装备\"><a href=\"#小球装备\" class=\"headerlink\" title=\"小球装备\"></a>小球装备</h2><h2 id=\"地图设计\"><a href=\"#地图设计\" class=\"headerlink\" title=\"地图设计\"></a>地图设计</h2><h1 id=\"前端实现\"><a href=\"#前端实现\" class=\"headerlink\" title=\"前端实现\"></a>前端实现</h1><p>创建基础方块父类</p>\n<p>父类必要组件</p>\n<ul>\n<li>Static Mesh</li>\n</ul>\n<p>父类函数</p>\n<ul>\n<li>Serialize(TArray<int32>&amp; Data);</li>\n</ul>\n<p>必要成员变量</p>\n<ul>\n<li>物品代码</li>\n<li>物品参数数量</li>\n</ul>\n<h2 id=\"地图保存\"><a href=\"#地图保存\" class=\"headerlink\" title=\"地图保存\"></a>地图保存</h2><p>调用各个组件的Serialize将各自的数据保存入Data</p>\n<h2 id=\"地图加载\"><a href=\"#地图加载\" class=\"headerlink\" title=\"地图加载\"></a>地图加载</h2><p>struct Component<br>{<br>  TSubclassOf&lt;组件父类&gt; Obj<br>  int Nums 生成此组件需要的参数数量<br>}</p>\n<p>TMap&lt;int32, Component&gt;</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckibtjg5t0004f8unawmueadg","category_id":"ckibtjg5r0002f8un0x9660y4","_id":"ckibtjg5x0009f8un8prd6pod"},{"post_id":"ckibtjg5l0000f8un42xa68a5","category_id":"ckibtjg5r0002f8un0x9660y4","_id":"ckibtjg5y000cf8un4m0j8mca"},{"post_id":"ckibtjg5t0005f8un9dkneo7a","category_id":"ckibtjg5r0002f8un0x9660y4","_id":"ckibtjg5z000ef8unh9wt4tdp"},{"post_id":"ckibtjg5v0007f8un18qveu5o","category_id":"ckibtjg5r0002f8un0x9660y4","_id":"ckibtjg60000hf8un44zea3jz"},{"post_id":"ckibtjg5p0001f8un6jpo4zuf","category_id":"ckibtjg5r0002f8un0x9660y4","_id":"ckibtjg61000jf8uney7z7d59"},{"post_id":"ckibtjg5s0003f8undi562jyq","category_id":"ckibtjg5r0002f8un0x9660y4","_id":"ckibtjg66000mf8un1wlu87nc"},{"post_id":"ckibtjg5z000df8un7lugd7j4","category_id":"ckibtjg5r0002f8un0x9660y4","_id":"ckibtjg68000pf8unaa0bh694"},{"post_id":"ckibtjg60000gf8unap3ebblh","category_id":"ckibtjg5r0002f8un0x9660y4","_id":"ckibtjg69000sf8uncjlphul6"},{"post_id":"ckibtjg5x0008f8un1ec504jr","category_id":"ckibtjg5r0002f8un0x9660y4","_id":"ckibtjg6a000uf8unchxj6e99"},{"post_id":"ckibtjg5x0008f8un1ec504jr","category_id":"ckibtjg5z000ff8unalx0ew8r","_id":"ckibtjg6b000zf8un0xuf4sy8"},{"post_id":"ckibtjg5y000bf8unacel1w0l","category_id":"ckibtjg5r0002f8un0x9660y4","_id":"ckibtjg6d0011f8unh4nsb46p"},{"post_id":"ckibtjg5y000bf8unacel1w0l","category_id":"ckibtjg5z000ff8unalx0ew8r","_id":"ckibtjg6e0015f8un8u9daumb"},{"post_id":"ckibtjg60000if8un07wg4z95","category_id":"ckibtjg68000qf8un8u54dryz","_id":"ckibtjg6f0018f8unanl52v7g"},{"post_id":"ckibtjg66000lf8un9e1zebks","category_id":"ckibtjg68000qf8un8u54dryz","_id":"ckibtjg6g001bf8unexfzbuu3"},{"post_id":"ckibtjg67000of8unffxb4ise","category_id":"ckibtjg68000qf8un8u54dryz","_id":"ckibtjg6h001ff8une4rzemdf"},{"post_id":"ckibtjg6g001af8unclfyey67","category_id":"ckibtjg6f0019f8un64ud8skc","_id":"ckibtjg6j001kf8unfrek8v88"},{"post_id":"ckibtjg68000rf8uncjvn3rta","category_id":"ckibtjg6f0019f8un64ud8skc","_id":"ckibtjg6k001of8undsusbgbc"},{"post_id":"ckibtjg69000tf8un101rdnyu","category_id":"ckibtjg6f0019f8un64ud8skc","_id":"ckibtjg6l001tf8unebtk9bwf"},{"post_id":"ckibtjg6b000yf8un2fkkhkgf","category_id":"ckibtjg6f0019f8un64ud8skc","_id":"ckibtjg6n001zf8un7wwk7pvw"},{"post_id":"ckibtjg6c0010f8un22z588aq","category_id":"ckibtjg6f0019f8un64ud8skc","_id":"ckibtjg6o0024f8una6oq7oc2"},{"post_id":"ckibtjg6e0013f8un7yeg2paw","category_id":"ckibtjg6f0019f8un64ud8skc","_id":"ckibtjg6q0029f8undie80laa"},{"post_id":"ckibtjg6f0017f8und42g4zl7","category_id":"ckibtjg6o0023f8un172k26up","_id":"ckibtjg6u002ff8un0hio4oj1"},{"post_id":"ckibtjg6h001df8un8geihcsq","category_id":"ckibtjg6s002bf8un6pv2894o","_id":"ckibtjg6v002nf8ungkalcz28"},{"post_id":"ckibtjg6i001hf8un48i872t9","category_id":"ckibtjg6o0023f8un172k26up","_id":"ckibtjg6x002tf8un3fvgczdk"},{"post_id":"ckibtjg6j001jf8un805r5mfa","category_id":"ckibtjg6s002bf8un6pv2894o","_id":"ckibtjg6z002zf8un0ue1hgid"},{"post_id":"ckibtjg6k001nf8un7yigfpn2","category_id":"ckibtjg6o0023f8un172k26up","_id":"ckibtjg710035f8unfyqhdqcz"},{"post_id":"ckibtjg6l001qf8und9tzgsk4","category_id":"ckibtjg6o0023f8un172k26up","_id":"ckibtjg720039f8uncvf70l0c"},{"post_id":"ckibtjg6l001uf8un45tfh599","category_id":"ckibtjg700034f8un83798r1l","_id":"ckibtjg74003hf8un2r0j57rr"},{"post_id":"ckibtjg6m001vf8un5n6q8p8x","category_id":"ckibtjg700034f8un83798r1l","_id":"ckibtjg75003mf8un2v985qzg"},{"post_id":"ckibtjg6n0020f8unevaecwbs","category_id":"ckibtjg700034f8un83798r1l","_id":"ckibtjg78003sf8un87wd3e2e"},{"post_id":"ckibtjg6o0021f8unejqd8dea","category_id":"ckibtjg700034f8un83798r1l","_id":"ckibtjg79003xf8unf2ra0dbv"},{"post_id":"ckibtjg6p0025f8un2yvz2pml","category_id":"ckibtjg77003rf8un9dusd2c2","_id":"ckibtjg7b0043f8un56eyhfki"},{"post_id":"ckibtjg6p0027f8un13e9alc0","category_id":"ckibtjg77003rf8un9dusd2c2","_id":"ckibtjg7d0047f8unc4b66fc2"},{"post_id":"ckibtjg6q002af8unel6s9auc","category_id":"ckibtjg77003rf8un9dusd2c2","_id":"ckibtjg7e004bf8unam758vqu"},{"post_id":"ckibtjg6s002cf8unfkd6100u","category_id":"ckibtjg77003rf8un9dusd2c2","_id":"ckibtjg7g004ff8ung0b6hmrm"},{"post_id":"ckibtjg6v002kf8unhzwqafcn","category_id":"ckibtjg77003rf8un9dusd2c2","_id":"ckibtjg7k004uf8un2ee79a00"},{"post_id":"ckibtjg6w002qf8un5owh9rrl","category_id":"ckibtjg7j004tf8uneuoec5lp","_id":"ckibtjg7k004yf8un87b53ezu"},{"post_id":"ckibtjg6y002vf8un58k4dzt3","category_id":"ckibtjg7j004tf8uneuoec5lp","_id":"ckibtjg7k004zf8un6r964n8r"},{"post_id":"ckibtjg700032f8unhr7khtja","category_id":"ckibtjg7j004tf8uneuoec5lp","_id":"ckibtjg7m0054f8una90o5zk6"},{"post_id":"ckibtjg72003cf8uneqvm829i","category_id":"ckibtjg7m0055f8un4eul8kg5","_id":"ckibtjg7n0057f8una2rn5qo3"},{"post_id":"ckibtjg73003ef8unc9wvfxsv","category_id":"ckibtjg7n0056f8unha9y44tm","_id":"ckibtjg7o005af8unadn00fhs"},{"post_id":"ckibtjg74003if8unhq4l2wb5","category_id":"ckibtjg7n0056f8unha9y44tm","_id":"ckibtjg7o005cf8un4hl0a4if"},{"post_id":"ckibtjg75003kf8unaa8708a5","category_id":"ckibtjg7n0056f8unha9y44tm","_id":"ckibtjg7p005ef8unhezze7yo"},{"post_id":"ckibtjg76003of8un9v6kgemh","category_id":"ckibtjg7n0056f8unha9y44tm","_id":"ckibtjg7p005gf8un5bdqa5uh"},{"post_id":"ckibtjg77003qf8un7cfa7p8r","category_id":"ckibtjg7n0056f8unha9y44tm","_id":"ckibtjg7q005if8ung3j96v4s"},{"post_id":"ckibtjg78003uf8unfk8pajid","category_id":"ckibtjg7n0056f8unha9y44tm","_id":"ckibtjg7r005kf8ung3unb82g"},{"post_id":"ckibtjg79003wf8un7t0j4r2y","category_id":"ckibtjg7n0056f8unha9y44tm","_id":"ckibtjg7r005mf8un2kuhbm94"},{"post_id":"ckibtjg79003zf8unbq55ed1w","category_id":"ckibtjg7n0056f8unha9y44tm","_id":"ckibtjg7s005of8unev1hfuam"},{"post_id":"ckibtjg7a0041f8uncc7o0le4","category_id":"ckibtjg7n0056f8unha9y44tm","_id":"ckibtjg7s005qf8una7zf1x8r"},{"post_id":"ckibtjg7b0044f8unfpmkgymx","category_id":"ckibtjg7n0056f8unha9y44tm","_id":"ckibtjg7s005sf8un0hce16pe"},{"post_id":"ckibtjg7b0045f8un0o4r89tp","category_id":"ckibtjg7n0056f8unha9y44tm","_id":"ckibtjg7t005uf8un7wrr11bt"},{"post_id":"ckibtjg7d0048f8unhb5b0531","category_id":"ckibtjg7n0056f8unha9y44tm","_id":"ckibtjg7t005vf8un35hz9hm4"},{"post_id":"ckibtjg7e0049f8un4ddf1k2g","category_id":"ckibtjg7t005tf8unere8f0mi","_id":"ckibtjg7t005yf8une5gq6xw0"},{"post_id":"ckibtjg7f004cf8un0bd9gnku","category_id":"ckibtjg7t005tf8unere8f0mi","_id":"ckibtjg7u0060f8unfh7v0fkq"},{"post_id":"ckibtjg7f004ef8unbpxdhh5r","category_id":"ckibtjg7t005tf8unere8f0mi","_id":"ckibtjg7v0061f8un1y34bxug"},{"post_id":"ckibtjg6t002ef8un96of9b5j","category_id":"ckibtjg7e004af8ungx6ncyc2","_id":"ckibtjg7w0064f8un694v7qlq"},{"post_id":"ckibtjg6t002ef8un96of9b5j","category_id":"ckibtjg7u005zf8un2ydv3qur","_id":"ckibtjg7w0065f8un5sj84cg3"},{"post_id":"ckibtjg7g004gf8un7knk5ydk","category_id":"ckibtjg7t005tf8unere8f0mi","_id":"ckibtjg7w0066f8un0df2gohs"},{"post_id":"ckibtjg7h004if8un51pzh2i9","category_id":"ckibtjg7v0063f8undbwme95x","_id":"ckibtjg7w0068f8un28gz4o5p"},{"post_id":"ckibtjg6u002if8un9z5s5als","category_id":"ckibtjg7e004af8ungx6ncyc2","_id":"ckibtjg7x006bf8unhtvuhazc"},{"post_id":"ckibtjg6u002if8un9z5s5als","category_id":"ckibtjg7w0067f8unemh0bjed","_id":"ckibtjg7x006cf8un7bw740to"},{"post_id":"ckibtjg7i004lf8unaxebf43x","category_id":"ckibtjg7v0063f8undbwme95x","_id":"ckibtjg7x006ef8un8yardwiq"},{"post_id":"ckibtjg6w002pf8unacvw5qus","category_id":"ckibtjg7e004af8ungx6ncyc2","_id":"ckibtjg7y006ff8un3mb64441"},{"post_id":"ckibtjg6w002pf8unacvw5qus","category_id":"ckibtjg7w0067f8unemh0bjed","_id":"ckibtjg7y006hf8ungo5h81s7"},{"post_id":"ckibtjg6y002wf8une4tlhnju","category_id":"ckibtjg7k004xf8un9to7b0n6","_id":"ckibtjg7y006jf8un09sm58ks"},{"post_id":"ckibtjg6y002wf8une4tlhnju","category_id":"ckibtjg7x006df8un7xx6dr6o","_id":"ckibtjg7y006kf8un5wx922hz"},{"post_id":"ckibtjg6z0030f8unek72c0xh","category_id":"ckibtjg7k004xf8un9to7b0n6","_id":"ckibtjg7z006mf8un0t8vhks2"},{"post_id":"ckibtjg6z0030f8unek72c0xh","category_id":"ckibtjg7x006df8un7xx6dr6o","_id":"ckibtjg7z006nf8un9tur65dj"},{"post_id":"ckibtjg710036f8un5n82gst5","category_id":"ckibtjg7k004xf8un9to7b0n6","_id":"ckibtjg7z006of8un741a4gqe"},{"post_id":"ckibtjg710036f8un5n82gst5","category_id":"ckibtjg7x006df8un7xx6dr6o","_id":"ckibtjg7z006pf8un8beth8aj"},{"post_id":"ckibtjg710038f8un7uaccuck","category_id":"ckibtjg7k004xf8un9to7b0n6","_id":"ckibtjg7z006qf8un3n3j1lc9"},{"post_id":"ckibtjg710038f8un7uaccuck","category_id":"ckibtjg7x006df8un7xx6dr6o","_id":"ckibtjg7z006rf8un01kt14p6"}],"PostTag":[{"post_id":"ckibtjg60000if8un07wg4z95","tag_id":"ckibtjg67000nf8un4i0425c3","_id":"ckibtjg6a000xf8un89jhe866"},{"post_id":"ckibtjg68000rf8uncjvn3rta","tag_id":"ckibtjg6a000wf8unb7zqg89d","_id":"ckibtjg6e0016f8unae7y1oj5"},{"post_id":"ckibtjg69000tf8un101rdnyu","tag_id":"ckibtjg6e0014f8uncu98a2rr","_id":"ckibtjg6h001ef8una5ba1vb8"},{"post_id":"ckibtjg6b000yf8un2fkkhkgf","tag_id":"ckibtjg6g001cf8ungofd4t1g","_id":"ckibtjg6j001lf8un39ut32pc"},{"post_id":"ckibtjg6c0010f8un22z588aq","tag_id":"ckibtjg6i001if8unefvradyo","_id":"ckibtjg6l001rf8un8spraz5k"},{"post_id":"ckibtjg6e0013f8un7yeg2paw","tag_id":"ckibtjg6k001pf8undjyeef0w","_id":"ckibtjg6n001xf8una5556jif"},{"post_id":"ckibtjg6g001af8unclfyey67","tag_id":"ckibtjg6m001wf8une6e3cfwu","_id":"ckibtjg6p0026f8un7w8b0b7x"},{"post_id":"ckibtjg6l001qf8und9tzgsk4","tag_id":"ckibtjg6o0022f8ung3c532bl","_id":"ckibtjg6u002hf8un67ada7rq"},{"post_id":"ckibtjg6l001qf8und9tzgsk4","tag_id":"ckibtjg6q0028f8un5zbfa8k9","_id":"ckibtjg6u002jf8un29fl9tn3"},{"post_id":"ckibtjg6p0025f8un2yvz2pml","tag_id":"ckibtjg6t002df8ung1xcbps2","_id":"ckibtjg6w002of8un3mm09zh6"},{"post_id":"ckibtjg6p0027f8un13e9alc0","tag_id":"ckibtjg6t002df8ung1xcbps2","_id":"ckibtjg6x002uf8un6h0s99qc"},{"post_id":"ckibtjg6q002af8unel6s9auc","tag_id":"ckibtjg6x002rf8un1p8kc2l2","_id":"ckibtjg700031f8uncwwbfscf"},{"post_id":"ckibtjg6s002cf8unfkd6100u","tag_id":"ckibtjg6t002df8ung1xcbps2","_id":"ckibtjg710037f8un7tacdces"},{"post_id":"ckibtjg6t002ef8un96of9b5j","tag_id":"ckibtjg700033f8un1n294nyw","_id":"ckibtjg73003df8ungctx88ch"},{"post_id":"ckibtjg6u002if8un9z5s5als","tag_id":"ckibtjg700033f8un1n294nyw","_id":"ckibtjg75003jf8un2djs032q"},{"post_id":"ckibtjg6v002kf8unhzwqafcn","tag_id":"ckibtjg74003ff8un1b6g9zow","_id":"ckibtjg77003pf8unb65ve9y5"},{"post_id":"ckibtjg6w002pf8unacvw5qus","tag_id":"ckibtjg700033f8un1n294nyw","_id":"ckibtjg78003vf8un2lh3gdn9"},{"post_id":"ckibtjg72003cf8uneqvm829i","tag_id":"ckibtjg78003tf8unbr5v3cmr","_id":"ckibtjg7a0040f8un9mgqbuwb"},{"post_id":"ckibtjg7g004gf8un7knk5ydk","tag_id":"ckibtjg7f004df8undxll0gk8","_id":"ckibtjg7i004kf8ung2ni9y8k"},{"post_id":"ckibtjg7e0049f8un4ddf1k2g","tag_id":"ckibtjg7f004df8undxll0gk8","_id":"ckibtjg7i004nf8un6foi2048"},{"post_id":"ckibtjg7f004cf8un0bd9gnku","tag_id":"ckibtjg7f004df8undxll0gk8","_id":"ckibtjg7j004pf8un55rn6b23"},{"post_id":"ckibtjg7f004ef8unbpxdhh5r","tag_id":"ckibtjg7f004df8undxll0gk8","_id":"ckibtjg7j004sf8un6f6ae58o"},{"post_id":"ckibtjg7i004lf8unaxebf43x","tag_id":"ckibtjg7j004rf8un4issc6ji","_id":"ckibtjg7k004vf8unazpp6w7l"}],"Tag":[{"name":"Git操作","_id":"ckibtjg67000nf8un4i0425c3"},{"name":"spf-13","_id":"ckibtjg6a000wf8unb7zqg89d"},{"name":"GDB调试","_id":"ckibtjg6e0014f8uncu98a2rr"},{"name":"Linux","_id":"ckibtjg6g001cf8ungofd4t1g"},{"name":"Shell","_id":"ckibtjg6i001if8unefvradyo"},{"name":"权限管理","_id":"ckibtjg6k001pf8undjyeef0w"},{"name":"网络配置","_id":"ckibtjg6m001wf8une6e3cfwu"},{"name":"肉疼","_id":"ckibtjg6o0022f8ung3c532bl"},{"name":"小方说","_id":"ckibtjg6q0028f8un5zbfa8k9"},{"name":"递归分治","_id":"ckibtjg6t002df8ung1xcbps2"},{"name":"动态规划","_id":"ckibtjg6x002rf8un1p8kc2l2"},{"name":"腾讯游戏学院","_id":"ckibtjg700033f8un1n294nyw"},{"name":"中心扩散","_id":"ckibtjg74003ff8un1b6g9zow"},{"name":"自底向上?","_id":"ckibtjg78003tf8unbr5v3cmr"},{"name":"采坑记","_id":"ckibtjg7f004df8undxll0gk8"},{"name":"陀螺球","_id":"ckibtjg7j004rf8un4issc6ji"}]}}