{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/favicons/android-chrome-192x192.png","path":"favicons/android-chrome-192x192.png","modified":1,"renderable":0},{"_id":"source/favicons/browserconfig.xml","path":"favicons/browserconfig.xml","modified":1,"renderable":0},{"_id":"source/favicons/apple-touch-icon.png","path":"favicons/apple-touch-icon.png","modified":1,"renderable":0},{"_id":"source/favicons/favicon-16x16.png","path":"favicons/favicon-16x16.png","modified":1,"renderable":0},{"_id":"source/favicons/site.webmanifest","path":"favicons/site.webmanifest","modified":1,"renderable":0},{"_id":"source/favicons/favicon-32x32.png","path":"favicons/favicon-32x32.png","modified":1,"renderable":0},{"_id":"source/favicons/favicon.ico","path":"favicons/favicon.ico","modified":1,"renderable":0},{"_id":"source/favicons/mstile-150x150.png","path":"favicons/mstile-150x150.png","modified":1,"renderable":0},{"_id":"themes/ylion/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"source/favicons/android-chrome-512x512.png","path":"favicons/android-chrome-512x512.png","modified":1,"renderable":0},{"_id":"themes/ylion/source/css/base.less","path":"css/base.less","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/app.js","path":"js/app.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/highsong.js","path":"js/highsong.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/pages/article-exp.less","path":"css/pages/article-exp.less","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/pages/archive.less","path":"css/pages/archive.less","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/pages/comments.css","path":"css/pages/comments.css","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/pages/othersPages.less","path":"css/pages/othersPages.less","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/pages/post.less","path":"css/pages/post.less","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/thirdParty/font-awesome.min.css","path":"css/thirdParty/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/ylion/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/thirdParty/busuanzi.min.js","path":"js/thirdParty/busuanzi.min.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/thirdParty/highlight/github.css","path":"css/thirdParty/highlight/github.css","modified":1,"renderable":1},{"_id":"themes/ylion/source/css/thirdParty/highlight/solarized-light.css","path":"css/thirdParty/highlight/solarized-light.css","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.min.js","path":"js/thirdParty/gitment.browser.min.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/thirdParty/highlight.pack.js","path":"js/thirdParty/highlight.pack.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/thirdParty/leancloud.min.js","path":"js/thirdParty/leancloud.min.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.js","path":"js/thirdParty/gitment.browser.js","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.js.map","path":"js/thirdParty/gitment.browser.js.map","modified":1,"renderable":1},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.min.js.map","path":"js/thirdParty/gitment.browser.min.js.map","modified":1,"renderable":1}],"Cache":[{"_id":"themes/ylion/.gitignore","hash":"6e3a09b0d19dfe679aa416609d58581ea6bfa9b2","modified":1569415848000},{"_id":"themes/ylion/CHANGELOG.md","hash":"c47c138626fe4917696ff5e96e629e78130ca5c6","modified":1569415848000},{"_id":"themes/ylion/404.md","hash":"35eab98f14ba0ce50cba8f63b6e0d80328eb2fd0","modified":1569415848000},{"_id":"source/CNAME","hash":"5d1b3c534b5001bee37dc2a8e8da866b00c2eb73","modified":1582768766363},{"_id":"themes/ylion/LICENSE","hash":"5e65ec894a8c1a584620276b0b2d79a63101201c","modified":1569415848000},{"_id":"themes/ylion/_config.yml","hash":"6789564f7cf5bcf0105006d9092c7ed50411c423","modified":1583223156369},{"_id":"themes/ylion/README.md","hash":"31892094943eb72c371dc8df6c197c3403b8ab9a","modified":1569415848000},{"_id":"themes/ylion/package.json","hash":"dc7a8b087254bfe3f83d09a5a8a0e0ab87885192","modified":1569415848000},{"_id":"source/_posts/CPP-CPP基础-2.md","hash":"294972eeb0e57ce1e1c597a8e4b42b8e3b6fe448","modified":1580458067178},{"_id":"source/_posts/3DMAX-3dmax快捷键及基础知识.md","hash":"e6d9810b53641a6332f50b454d7006dd3c92ae87","modified":1581950939145},{"_id":"source/_posts/CPP-CPP基础-指针.md","hash":"ad30d100b711e58ef8d996fcff0ec42f75c28336","modified":1579779312218},{"_id":"source/_posts/CPP-CPP采坑-循环判断之无符号类型.md","hash":"2928d49435e5f821a222c98cf1fb7c043b44622d","modified":1583497085173},{"_id":"source/_posts/CPP-CPP基础-牛客.md","hash":"bc5ca871c8e22044f487f1ef41c61a34340345a9","modified":1579779308099},{"_id":"source/_posts/CPP-CPP重点-CPP11特性.md","hash":"a6b641f6ced34b6ad50f1e58c5693500722a6b26","modified":1584704995392},{"_id":"source/_posts/CPP-CPP重点-CMAKE.md","hash":"3ad3c230afe490a5aafd26c28688e18f3dbb046c","modified":1582122915526},{"_id":"source/_posts/CPP-CPP采坑-头文件互相引用.md","hash":"36b7da44cc1ee271a20265ead90728477ac61777","modified":1581070188656},{"_id":"source/_posts/CPP-CPP重点-定义与声明详解.md","hash":"85164e5f3a5a14a1db3c02fcc402b3c417c785cf","modified":1582773976583},{"_id":"source/_posts/CPP-CPP重点-STL记录.md","hash":"d17fc076551200b9a31b5ac983e2eb80f7cbed53","modified":1583824104354},{"_id":"source/_posts/CPP-CPP重点-编程规范.md","hash":"8184158365c24f4b54fcd3c4df3804375238475e","modified":1583416714793},{"_id":"source/_posts/CPP-CPP重点-字节对齐.md","hash":"e564bde826e217acb3c177e15f58b7144852c62a","modified":1581064693076},{"_id":"source/_posts/CPP-Socket理论-Send返回值探析.md","hash":"61b3afdef5dd2d4a290f46d5ac4922fbda644824","modified":1584678031293},{"_id":"source/_posts/CPP-源码学习-Libevent代码初期了解.md","hash":"b9ac4f60cc33600deb8fe5147d894b4728681f49","modified":1583584091301},{"_id":"source/_posts/CPP-读书记录100-高性能服务器编程读书记录初级部分.md","hash":"6794831a33a10a88fc40b86e650b333cff5d720d","modified":1584169856792},{"_id":"source/_posts/CPP-源码学习-Jsoncpp代码阅读.md","hash":"5c5ca91a6cc90c9c29f545757c5f63d9c36bf20b","modified":1583308364944},{"_id":"source/_posts/CPP-读书记录80-CPPPrimer.md","hash":"fa30eaf54df3b040c37838d6bd8c7b829f5a7dd0","modified":1584752430637},{"_id":"source/_posts/CPP-读书记录115-UNP卷二.md","hash":"8a890ddeaee98713993e0199508ca25035aa5e01","modified":1584717589144},{"_id":"source/_posts/CPP-读书记录102-高性能服务器编程读书记录进程线程部分.md","hash":"b3b669745bc06ae17955bf460120bc006d8b3170","modified":1584236604692},{"_id":"source/_posts/CPP-读书记录101-高性能服务器编程读书记录高级部分.md","hash":"aaff33649d8d11e978d50127810bb4f290783d6d","modified":1584169861496},{"_id":"source/_posts/CPP-读书记录110-Effective读书记录.md","hash":"2e1e6cabc76bf7f128783cbb8e88f020dce3bc8c","modified":1583504124766},{"_id":"source/_posts/CPP-读书记录99-高性能服务器编程读书记录理论部分.md","hash":"1ee62e5ef97afcaed80a12215abf67e75d1b178b","modified":1584446952437},{"_id":"source/_posts/Git-commit规范.md","hash":"51d5d8d09d462bbff7e8c2ae83e392fe9c66a468","modified":1583585466525},{"_id":"source/_posts/Git-基础操作.md","hash":"8054bad8a2406fbad5a216a71811eca7d79703c3","modified":1583585448846},{"_id":"source/_posts/UE4-网络-数据传输.md","hash":"8a70bb8f2344464ac0856144a0e0153bef44e14e","modified":1583761012520},{"_id":"source/_posts/学习记录-操作系统点带面.md","hash":"81ac2cafa756edd3d0340403ef99ce698b9037c0","modified":1584182486689},{"_id":"source/_posts/Git-分支管理和实际应用.md","hash":"0fad26afc27a7822168466031d36876b11716af1","modified":1583999324746},{"_id":"source/_posts/学习记录-大二寒假.md","hash":"9074a4dfea258a172690e4149dcdeeaad5c9903d","modified":1584182421181},{"_id":"source/_posts/学习记录-大一暑假.md","hash":"a2315312caf69106cf88543c8d414b4a9253f40f","modified":1584182433230},{"_id":"source/_posts/小游戏-联机打砖块.md","hash":"93418b48cc1a408c278e123aea486a5d96909e45","modified":1582122922496},{"_id":"source/_posts/操作系统-GDB调试.md","hash":"2047011dc49e038a51bcdfd44dd9304faf964158","modified":1584434360200},{"_id":"source/_posts/操作系统-Linux使用.md","hash":"89d498700b7cee8a91230d1ce333545e9a83c272","modified":1584420976103},{"_id":"source/_posts/操作系统-csapp.md","hash":"4238c41a8ddd95cce5e59485524703ec71ee5819","modified":1584180931077},{"_id":"source/_posts/数据库-Mysql-Mysql基本使用.md","hash":"99a19ac98f47feebdf2ddcc69a94abee9fc8707a","modified":1583481576342},{"_id":"source/_posts/游戏知识-腾讯游戏学院-如何进入游戏开发行业.md","hash":"d21558281664cd236bd76b2ad66b3e1f6509d9f3","modified":1583417096802},{"_id":"source/_posts/操作系统-权限相关.md","hash":"cf12f74bcb3581d7d42b0b5ce2599ed367313a00","modified":1584180844755},{"_id":"source/_posts/数据库-MongoDB-MongoDB基本使用.md","hash":"06222a68660d7cf6f0222234d2fbef7b8502a876","modified":1583481244325},{"_id":"source/_posts/算法90-算法刷题记录-数据结构简单应用.md","hash":"557eb9c6ab61a9e2e99c83d02b2f0e6f663ae5f0","modified":1584608475798},{"_id":"source/_posts/游戏知识-腾讯游戏学院-球球.md","hash":"bddb7428227520d7a9a000cb26b9cf7d740c043a","modified":1583419334972},{"_id":"source/_posts/游戏知识-服务器-服务器通信.md","hash":"5ca2b3ae622f33b618bb4a3271836f3d9ea4f3cc","modified":1583417099979},{"_id":"source/_posts/算法91-算法刷题记录-算法.md","hash":"3e8e602ac59ca74e22df92929363260da0d7e59a","modified":1584607456156},{"_id":"source/_posts/算法92-算法理论-算法分类学习.md","hash":"682c360da05152fc5a30b5f6ec50ea346bc5a132","modified":1584417380086},{"_id":"source/favicons/android-chrome-192x192.png","hash":"05d291f0be2766b4f46a62fbabdc10b3d6ff092a","modified":1580092054000},{"_id":"source/favicons/browserconfig.xml","hash":"974aea18bda5a95802c06b80126ab1d96d91d708","modified":1580092054000},{"_id":"source/favicons/apple-touch-icon.png","hash":"f208d1156aee20488a1f98d902f5a674a7cc6d84","modified":1580092054000},{"_id":"source/favicons/favicon-16x16.png","hash":"c92eeb1df6654eb34f9cf354e3922a794021e377","modified":1580092054000},{"_id":"source/favicons/site.webmanifest","hash":"13e5aa58eb2182d8ace63266856c8cc29c47c083","modified":1580092056000},{"_id":"themes/ylion/_neededFile/search.ejs","hash":"5aed86cf52b0f0746426cbddbb96913880638d4c","modified":1569415848000},{"_id":"themes/ylion/languages/default.yml","hash":"ee1626dab2f76c04f07b49b3016f7e8354b907df","modified":1569415848000},{"_id":"themes/ylion/languages/ko.yml","hash":"a4dc4646a61974dee8983c9cfd72ff4c4b26fbe3","modified":1569415848000},{"_id":"themes/ylion/languages/zh-CN.yml","hash":"267909418b5be5441c4ff44dfdf5003ee4bb9209","modified":1569415848000},{"_id":"themes/ylion/languages/zh-TW.yml","hash":"3e0fdbe453d96f3e6467e7aa97e60d1e93196398","modified":1569415848000},{"_id":"source/favicons/favicon-32x32.png","hash":"8c3bb4b352237b05f8119644d91099c5288ca2b6","modified":1580092054000},{"_id":"source/favicons/favicon.ico","hash":"7819f8009e037fa738545f5645efc32457ebb9e0","modified":1580092056000},{"_id":"source/favicons/mstile-150x150.png","hash":"266c87b17aa65bed8a431b5d88281ce488b03c6f","modified":1580092056000},{"_id":"themes/ylion/layout/archive.ejs","hash":"913edfb62e33bd4eab564c62304d03833a5378a0","modified":1569415848000},{"_id":"themes/ylion/layout/category.ejs","hash":"ebd05ceb75be73e84ddf085ccfdb24c07162d0fa","modified":1569415848000},{"_id":"themes/ylion/layout/layout.ejs","hash":"a6410ed79ed77d83e3bbe064188a50b45a9af739","modified":1569415848000},{"_id":"themes/ylion/layout/tag.ejs","hash":"9b42656e75c58e7145e52408b51f017f6b6d9464","modified":1569415848000},{"_id":"themes/ylion/layout/index.ejs","hash":"f5dfbcfcdaab7a6c2b77d0d371335c569801352f","modified":1569415848000},{"_id":"themes/ylion/layout/post.ejs","hash":"3475e67bab1ef4c1a782d64cb8bdf7c719c877cb","modified":1582768276416},{"_id":"themes/ylion/layout/page.ejs","hash":"febe98fb69248e8d1638dc83a25a17ee16ebeeca","modified":1569415848000},{"_id":"themes/ylion/source/favicon.ico","hash":"38591b263c047efbb16cd04a51a2d43316e3ebac","modified":1569415848000},{"_id":"source/favicons/android-chrome-512x512.png","hash":"e02dcf98fa3f146bfdd7bc74046b913627f8abee","modified":1580092054000},{"_id":"themes/ylion/layout/_partial/archive.ejs","hash":"a36b8d1a3ee2442444cba08e6afebde783e3f581","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/comments.ejs","hash":"cd927a126c35cfd47abf3a568bcdc2a30b3e6fad","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/gallery.ejs","hash":"3afb29dba43eedcbe55d98131a95de23affe846f","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/head.ejs","hash":"8af3ec434d29c8e7354cb2e144041e7cbfc85f53","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/article-meta.ejs","hash":"dd844ba05438c5a6b93323f0ccdd0157057c044e","modified":1569415848000},{"_id":"themes/ylion/layout/_thirdParty/baidu_an.ejs","hash":"c8ff48ffdc16a94b7d24037a953f7442789a3f86","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/header.ejs","hash":"fb7534e90746553d4b13f0c81512cdff47104bf7","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/after-footer.ejs","hash":"1a11f6c5d8afd45baf6829638ec1b2fbf30be974","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/footer.ejs","hash":"134a566a57942fcbfb06663305de6078702f5b94","modified":1569415848000},{"_id":"themes/ylion/layout/_thirdParty/baidu_sitemap.ejs","hash":"5fbadc6b28c1f850269381b7dc843dbf10499b51","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/pagination.ejs","hash":"eb0f07bfb4a19a9027ea861904541ecfcb96936a","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/sidebar.ejs","hash":"5989030b7f02af282211a306759ddbdac47536c7","modified":1569415848000},{"_id":"themes/ylion/layout/_thirdParty/google_analytics.ejs","hash":"0d100d7ad555bea422f5c02126bf6fb14fa82a8b","modified":1569415848000},{"_id":"themes/ylion/layout/_widget/archive.ejs","hash":"3d89804f2b5d4a7718125c8fe4b9fde289efd34c","modified":1569415848000},{"_id":"themes/ylion/layout/_thirdParty/google_sitemap.ejs","hash":"4d57bbf3e53a334760e1540eb4b7a2b65268962d","modified":1569415848000},{"_id":"themes/ylion/layout/_thirdParty/mathjax.ejs","hash":"d29b18efe49cae48846f74f53e0a6d1e1e3e98a7","modified":1569415848000},{"_id":"themes/ylion/layout/_widget/category.ejs","hash":"dcd285e44e45d2b4d845c39815db2e1840953f96","modified":1569415848000},{"_id":"themes/ylion/layout/_widget/friends.ejs","hash":"b62e2965c6940ce994cb5db5fd5f32fc9a3401d8","modified":1569415848000},{"_id":"themes/ylion/layout/_widget/notification.ejs","hash":"c32a1a7aebb0714f1415bed286a9a39b79a2c985","modified":1569415848000},{"_id":"themes/ylion/layout/_widget/popular.ejs","hash":"3b671d247b2b3ec3560c904263a6b93b4da61d63","modified":1569415848000},{"_id":"themes/ylion/layout/_widget/tagcloud.ejs","hash":"e739c974437ace225251c9a23a5d6ef7adf3f5c5","modified":1569415848000},{"_id":"themes/ylion/scripts/filter/emptycode.filter.js","hash":"7c0440d1a4b0f798e060504519cc6a39b5f29e9b","modified":1569415848000},{"_id":"themes/ylion/scripts/filter/translation.filter.js","hash":"5ec9cde7e4dbd659fe1adb4211c07a375b7049b5","modified":1569415848000},{"_id":"themes/ylion/scripts/generator/index.js","hash":"7df7ea4a2265301644879c9ded9a6e78bb006448","modified":1569415848000},{"_id":"themes/ylion/scripts/helper/getCurPosts.js","hash":"e9d58b03448d74a60978e97c463652af28d9931c","modified":1569415848000},{"_id":"themes/ylion/scripts/helper/my_paginator.js","hash":"f42b8683428546b914ead3df83cc0a19eaa2712d","modified":1569415848000},{"_id":"themes/ylion/scripts/helper/pickImgs.js","hash":"f26c478a78d94f89611095025d9a2c08065c700f","modified":1569415848000},{"_id":"themes/ylion/scripts/helper/sortPosts.js","hash":"a6c073157b2fb53cb3ef5825ca3ccd7a38e3d63a","modified":1569415848000},{"_id":"themes/ylion/layout/_thirdParty/disqus.ejs","hash":"67d8349201a7b508c378a7124b295245a0095768","modified":1569415848000},{"_id":"themes/ylion/layout/_thirdParty/duoshuo.ejs","hash":"f2c4f7ec5ea94796f2a7f87b6b04353dfe07300d","modified":1569415848000},{"_id":"themes/ylion/source/css/base.less","hash":"1d501cd1b75980e6058de48a664434bdad45c3cc","modified":1569415848000},{"_id":"themes/ylion/source/css/_variable.less","hash":"a113fb91689ef444bd650c04306ad99628f63dc7","modified":1569415848000},{"_id":"themes/ylion/source/css/_func.less","hash":"c8804cb0effe6177775ba27ff8781431ec0d6282","modified":1569415848000},{"_id":"themes/ylion/source/js/search.js","hash":"553b02d5ea62a97885d4405a6cbbe8685ba27b73","modified":1569415848000},{"_id":"themes/ylion/source/js/app.js","hash":"c257da122c1bff2c989c87a247e962ab6913d991","modified":1569415848000},{"_id":"themes/ylion/translate/korean/README_kr.md","hash":"f6c7ab74db9a288656f57ba2d01837f7dd1256a3","modified":1569415848000},{"_id":"themes/ylion/translate/korean/_config_kr.yml","hash":"f86a88597aec2ce2033351dc0dca0b1508d80425","modified":1569415848000},{"_id":"themes/ylion/source/js/highsong.js","hash":"a103f4e3a9b337668fe2c937dd66c4a4963733df","modified":1569415848000},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1569415848000},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/_head-sections/IE.ejs","hash":"292033d3eaec35593cb229d58eab7043022bd3a5","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/_head-sections/seo.ejs","hash":"4898581e4aff0c1800213f9a05b612105d7a77ee","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/_head-sections/title.ejs","hash":"5cf4842a152b85d02ed83206b300d5b5d8998c51","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/_head-sections/script.ejs","hash":"4ef9cf901a81f59b8788bebba0fb16d74d37d87f","modified":1569415848000},{"_id":"themes/ylion/layout/_partial/_head-sections/style.ejs","hash":"6596c472dc32b194afc96309a6327ea30aab0834","modified":1569415848000},{"_id":"themes/ylion/scripts/generator/lib/generator.js","hash":"68cd4fc227f71bb035ac069c00fc714f4a42da99","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_article-meta.less","hash":"5e5318560835ee9922cb7be75e810e99c62549bf","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_footer.less","hash":"41ba98f0688556d880604bcf4e2f471e5b92b40d","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_media.less","hash":"34b03d8f51e15f746e00b17579310fd6cdc652f9","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_after-footer.less","hash":"2a851257ea9a4fe3157123d7c1f941f974deaa58","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_animation.less","hash":"9393f207f1840f7a1bcd5cc7a3086ae3c6122d66","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_pagination.less","hash":"fccf9b341e51cb426753609ac42a5ba140198c24","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_header.less","hash":"0b26efafd609e62ddda2fa23348bfd43ca7a467e","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_reset.less","hash":"fa0ea262c80660c5cf2f3c84fe74a09ec4c0ac8f","modified":1569415848000},{"_id":"themes/ylion/source/css/pages/article-exp.less","hash":"f87e35ad474eba21029acbda840dc91c9284275d","modified":1569415848000},{"_id":"themes/ylion/source/css/_base/_sidebar.less","hash":"dbd121c923141472c84a1fc607d55f8f083edee0","modified":1569415848000},{"_id":"themes/ylion/source/css/pages/archive.less","hash":"4250b13fcfd16045ccd70b40ea74e296111b1b7b","modified":1569415848000},{"_id":"themes/ylion/source/css/pages/comments.css","hash":"ee7e553676fa58acf12ffbb34decce30f733f4bc","modified":1569415848000},{"_id":"themes/ylion/source/css/pages/othersPages.less","hash":"e346c1fd2a12608e6f1e8a2d98e4652164b4208e","modified":1569415848000},{"_id":"themes/ylion/source/css/pages/post.less","hash":"b699f3fa3a701e84a32f05396b399b806e9a42f6","modified":1569415848000},{"_id":"themes/ylion/source/css/thirdParty/font-awesome.min.css","hash":"d2c7e3e8ed62f73240fde919253822bc7ce12b15","modified":1569415848000},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1569415848000},{"_id":"themes/ylion/source/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1569415848000},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1569415848000},{"_id":"themes/ylion/source/js/thirdParty/busuanzi.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1569415848000},{"_id":"themes/ylion/source/css/thirdParty/highlight/github.css","hash":"e5cdc036897bef17b0a40bd3310fb35a202df2b3","modified":1569415848000},{"_id":"themes/ylion/source/css/thirdParty/highlight/solarized-light.css","hash":"10bd5d6b6f332e32edd377f16d3b8ed04713ae81","modified":1569415848000},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.min.js","hash":"5cb10e77f44ad075512ee4a3fd518d9a5257a80c","modified":1569415848000},{"_id":"themes/ylion/source/js/thirdParty/highlight.pack.js","hash":"3c707416d178e317afa6fc552fc181d08ccc9c8c","modified":1569415848000},{"_id":"themes/ylion/source/js/thirdParty/leancloud.min.js","hash":"f80bcc588670fbf8fe720b7b7c31789b640e649b","modified":1569415848000},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.js","hash":"240ce6fc52400cd8b8302cc242e61504e7d86938","modified":1569415848000},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.js.map","hash":"b921d63b0e593bfc456068b40516dc0ea442dc53","modified":1569415848000},{"_id":"themes/ylion/source/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1569415848000},{"_id":"themes/ylion/source/js/thirdParty/gitment.browser.min.js.map","hash":"6cd313c386f1dfb5093fb4f71ed29796e01134f4","modified":1569415848000},{"_id":"public/atom.xml","hash":"9ec51aa976065cdde0ee93b1eae661bd00b77a6e","modified":1584752704056},{"_id":"public/sitemap.xml","hash":"10d1d26abadfe998ba21f3b6768e772a6f2e4f85","modified":1584752704056},{"_id":"public/search.xml","hash":"7ab3592ee0a7c6eb2b6d7261f10277cd094fceb6","modified":1584752704056},{"_id":"public/2020/03/学习记录-操作系统点带面/index.html","hash":"475a6ac674df0633c5be745d13b43f47f6566d47","modified":1584752704056},{"_id":"public/2020/03/算法92-算法理论-算法分类学习/index.html","hash":"17a87aaca976dd8c98a97935009267389bb05af3","modified":1584752704056},{"_id":"public/2020/03/CPP-读书记录115-UNP卷二/index.html","hash":"0ddaf5f40115f08100b50eb7a6e8c76ddb64da1b","modified":1584752704056},{"_id":"public/2020/03/CPP-Socket理论-Send返回值探析/index.html","hash":"1eab4c614c249add0c8012fa205bc149ef7c91dc","modified":1584752704056},{"_id":"public/2020/03/操作系统-Linux使用/index.html","hash":"b5b145744974471d726ce95ac35e767c65acd1d3","modified":1584752704056},{"_id":"public/2020/03/操作系统-GDB调试/index.html","hash":"8d30df7b1d446240ea1516b80bbf34e273c12fb5","modified":1584752704056},{"_id":"public/2020/03/操作系统-csapp/index.html","hash":"10fe6dcd70bd23841bcd55d7a1fa49cf9a768c3b","modified":1584752704056},{"_id":"public/2020/03/操作系统-权限相关/index.html","hash":"864b4fcd588593fab5e7f8bfdf3cb0dbf7f3c8f8","modified":1584752704056},{"_id":"public/2020/03/UE4-网络-数据传输/index.html","hash":"63c68146f53a3f849223487145cd814d0253719d","modified":1584752704056},{"_id":"public/2020/03/CPP-读书记录99-高性能服务器编程读书记录理论部分/index.html","hash":"d483afafb4a66029865692d85e2b53d6b2c4b5db","modified":1584752704056},{"_id":"public/2020/03/Git-分支管理和实际应用/index.html","hash":"bea992bdb02b1a70fa2c87600bb22eac8d1cfd62","modified":1584752704056},{"_id":"public/2020/03/CPP-CPP采坑-循环判断之无符号类型/index.html","hash":"af1efc7e7e8752b4f917b2c51cb0e00da349ba16","modified":1584752704056},{"_id":"public/2020/03/数据库-Mysql-Mysql基本使用/index.html","hash":"625ab60e63b6dd361ee6cca0b533206ea41d1a79","modified":1584752704056},{"_id":"public/2020/03/游戏知识-腾讯游戏学院-球球/index.html","hash":"a68ffd1bca39a68a4b2b84b6839a9f00d2fd91d2","modified":1584752704056},{"_id":"public/2020/03/算法90-算法刷题记录-数据结构简单应用/index.html","hash":"a779053f888f22dacf244ffa9a075bb8a3c4a0b3","modified":1584752704056},{"_id":"public/2020/03/算法91-算法刷题记录-算法/index.html","hash":"e2fb91eb6f2cd2b54642e63df93e0d4b83b5da9a","modified":1584752704056},{"_id":"public/2020/03/CPP-CPP重点-STL记录/index.html","hash":"09b228258e1293de1887dc6406858ff91e6f6584","modified":1584752704056},{"_id":"public/archives/2019/08/index.html","hash":"8d5fd446ac1a00871a04a3284decb9488c16061f","modified":1584752704056},{"_id":"public/archives/2019/07/index.html","hash":"cf0274bbd23276850ef58030fde9adf1449474d8","modified":1584752704056},{"_id":"public/archives/2019/10/index.html","hash":"4aeaebfe814d6784ad8f5c6698cceb4dbac92b66","modified":1584752704056},{"_id":"public/archives/2019/11/index.html","hash":"4a30284ba32cad433220f2364441aa835a8ce0c0","modified":1584752704056},{"_id":"public/archives/2019/12/index.html","hash":"c6c55fc398e41467cb3aabbd5391aa7717d607f6","modified":1584752704056},{"_id":"public/archives/2020/page/3/index.html","hash":"f9ac8c88d57beeaa8ac070348fc33df75a9e03a6","modified":1584752704056},{"_id":"public/archives/2020/01/index.html","hash":"2199e93489e1fd4aa6f5e0dd7ef9a8e59664f8d3","modified":1584752704056},{"_id":"public/archives/2020/03/page/2/index.html","hash":"133ff3004d3204ec4a1cea4386068f4006e3aa2c","modified":1584752704056},{"_id":"public/categories/3DMAX/index.html","hash":"bec5020ffe59bdc15ce2536534799deaf2a185b1","modified":1584752704056},{"_id":"public/categories/CPP/CPP基础/index.html","hash":"d260d2d1b8cbda2700177a11c7abd64a25fcfde6","modified":1584752704056},{"_id":"public/categories/CPP/CPP踩坑/index.html","hash":"03d0735e963ed9362f1ddc8c7be033baa321bbcf","modified":1584752704056},{"_id":"public/categories/CPP/Socket理论/index.html","hash":"bd024e71a7abe917b27a4bda0253db98b34a413a","modified":1584752704056},{"_id":"public/categories/CPP/源码学习/index.html","hash":"08e0275e821ac0b842975f4ba705c200dca504db","modified":1584752704056},{"_id":"public/categories/必备技能/index.html","hash":"1a83de46e5dd0966129327fd37ee25173fe4afc6","modified":1584752704056},{"_id":"public/categories/UE4/index.html","hash":"6707dce50903b0b5a3cd60de00068fdad5ed3f34","modified":1584752704056},{"_id":"public/categories/学习记录/index.html","hash":"4104e11be59582f092dfc85a2fff69c28a480ab4","modified":1584752704056},{"_id":"public/categories/小游戏/index.html","hash":"6d6d1bfa20f9ba16beda8e31b462ae08352fce1d","modified":1584752704056},{"_id":"public/categories/操作系统/index.html","hash":"ab8ca1648df8e01b006ed5b72d6243d15823730e","modified":1584752704056},{"_id":"public/categories/数据库/index.html","hash":"af6728ec72e96bfcf28eb9a88c91c96182232356","modified":1584752704056},{"_id":"public/categories/游戏知识/index.html","hash":"d7f6bf0e527a905aa3d663c2288168974108ce27","modified":1584752704056},{"_id":"public/categories/算法/index.html","hash":"9d16e356fb22d4ca2c87ab9d8b02055325d3fe7a","modified":1584752704056},{"_id":"public/categories/必备技能/Git操作/index.html","hash":"440e6b83018ce88d9cbd342f2b8a326542e6c032","modified":1584752704056},{"_id":"public/categories/UE4/网络/index.html","hash":"c7d3ff1a9e314a9d31a1062d2abbf6defd357ef3","modified":1584752704056},{"_id":"public/categories/数据库/Mysql/index.html","hash":"10727ec6d220aca2a943d6a5c9a5f6314abed871","modified":1584752704056},{"_id":"public/categories/游戏知识/腾讯游戏学院/index.html","hash":"2c948b30702cb21049c2ffe3dacd15b3962815d6","modified":1584752704056},{"_id":"public/categories/数据库/MongoDB/index.html","hash":"8f9fee9d67fed0def8f21f6279aa0279ad25db40","modified":1584752704056},{"_id":"public/categories/算法/算法刷题记录/index.html","hash":"b22992e2793f4387f1536ef42f193156c1d90795","modified":1584752704056},{"_id":"public/categories/游戏知识/服务器/index.html","hash":"a7d72a77b61c37ca45a24fe424348e8ab7c09b72","modified":1584752704056},{"_id":"public/categories/算法/算法理论/index.html","hash":"2a897612dfc904c42c4fcce4a2a6d86beb9a1ee0","modified":1584752704056},{"_id":"public/tags/3DMAX/index.html","hash":"5b92248af1e136b746f6f1776829c01ec270fecc","modified":1584752704056},{"_id":"public/tags/CPP踩坑记/index.html","hash":"ebf2708b2fe1690dd41d87a2158b95e5ac5e21dc","modified":1584752704056},{"_id":"public/tags/CPP/index.html","hash":"7a2904383eef0adfb11671989113b2802da87a2d","modified":1584752704056},{"_id":"public/tags/Git操作/index.html","hash":"a7a1ef83b5f599603b5bce92c0d34995e5004eb4","modified":1584752704056},{"_id":"public/tags/小游戏/index.html","hash":"d9ab586eb234aef7221f5c885ce93eeb24316ff4","modified":1584752704056},{"_id":"public/tags/GDB调试/index.html","hash":"b3bd7cbf3929263275a0fd93767e7e7deb23fa39","modified":1584752704056},{"_id":"public/tags/Linux/index.html","hash":"46f69e5757dd8f8a1da7a49728df91f1901c1a12","modified":1584752704056},{"_id":"public/tags/csapp/index.html","hash":"f5996833f338b41650fdf4023a6ed44d7ab354db","modified":1584752704056},{"_id":"public/tags/Mysql/index.html","hash":"d34b0c81b96eb07e6b28d01aa37d226a0e101d3f","modified":1584752704056},{"_id":"public/tags/腾讯游戏学院/index.html","hash":"eafc9f1fa095d134f87ff8b5059410a452473886","modified":1584752704056},{"_id":"public/tags/权限管理/index.html","hash":"81a4a1c071187bb0de6e4798c43f7a4dfdf87efa","modified":1584752704056},{"_id":"public/tags/MongoDB/index.html","hash":"f3b16317fd5f2580e26a647fe9f4f1340332f687","modified":1584752704056},{"_id":"public/2020/03/CPP-源码学习-Jsoncpp代码阅读/index.html","hash":"a7495ab81a27d0a3d3a1aaebdfe0033f04d357f0","modified":1584752704056},{"_id":"public/2020/02/CPP-CPP重点-定义与声明详解/index.html","hash":"65b910af976c860667dd5b226133d4a4ea273082","modified":1584752704056},{"_id":"public/2020/02/CPP-读书记录110-Effective读书记录/index.html","hash":"18d7db57ce6dfc6ddb59c2dde5f99a0bec9f3aef","modified":1584752704056},{"_id":"public/2020/02/CPP-读书记录102-高性能服务器编程读书记录进程线程部分/index.html","hash":"2f6d454177c8e2def4d1d7cb64b5e23c230620ca","modified":1584752704056},{"_id":"public/2020/02/Git-commit规范/index.html","hash":"96936db9862b0073fd33bad3cdaee21bd920df3d","modified":1584752704056},{"_id":"public/2020/02/CPP-CPP重点-CPP11特性/index.html","hash":"a721a5850ef0a89a69b92f17d869f225c6d1b149","modified":1584752704056},{"_id":"public/2020/02/CPP-源码学习-Libevent代码初期了解/index.html","hash":"de1e1880e837d06c861c5f0f10e3d12ee64d46bb","modified":1584752704056},{"_id":"public/2020/02/小游戏-联机打砖块/index.html","hash":"74ca26d56bb90a38b03a73db549e4e5888c49a5c","modified":1584752704056},{"_id":"public/2020/02/3DMAX-3dmax快捷键及基础知识/index.html","hash":"ad332daef1e3c41d47b0bad19b22f5b9e153dc65","modified":1584752704056},{"_id":"public/2020/02/Git-基础操作/index.html","hash":"830a200664014a7ab3df55766065be01833ad739","modified":1584752704056},{"_id":"public/2020/02/CPP-CPP重点-CMAKE/index.html","hash":"280988346c0a2b583870c20e0118c413b43ba1de","modified":1584752704056},{"_id":"public/2020/02/CPP-CPP采坑-头文件互相引用/index.html","hash":"feeb32f7c6cfa500e6e0b4490b00973f17aaa3fc","modified":1584752704056},{"_id":"public/2020/02/学习记录-大二寒假/index.html","hash":"fd73c8a51e301c59df30a14427deb7e8ab4009b3","modified":1584752704056},{"_id":"public/2020/02/CPP-CPP重点-字节对齐/index.html","hash":"e7b562f237006bdaac515ae75f6a4e832fa37db8","modified":1584752704056},{"_id":"public/2020/01/CPP-CPP重点-编程规范/index.html","hash":"2eb6b835f50c534bd2e430ef8365cd851e14a3ee","modified":1584752704056},{"_id":"public/2019/12/游戏知识-服务器-服务器通信/index.html","hash":"196031b9cc6a06c242b3a8f68b510ac2c430c935","modified":1584752704056},{"_id":"public/2019/12/游戏知识-腾讯游戏学院-如何进入游戏开发行业/index.html","hash":"4c077502c9a8590a26c5bcbc42e3a0ea21312e6e","modified":1584752704056},{"_id":"public/2019/10/CPP-CPP基础-2/index.html","hash":"4f3f878fa212deda97eaf11628c7fe59991eb2f4","modified":1584752704056},{"_id":"public/2019/11/CPP-CPP基础-指针/index.html","hash":"b22b614cbc26fa126e7f316583e2118a4989d478","modified":1584752704056},{"_id":"public/2019/10/CPP-CPP基础-牛客/index.html","hash":"5dea204630845c44cda0e20311bec567866e14c9","modified":1584752704056},{"_id":"public/2019/10/数据库-MongoDB-MongoDB基本使用/index.html","hash":"287222bb19e3485bfb0ebeea5ee9d2fa134d066f","modified":1584752704056},{"_id":"public/2019/08/CPP-读书记录101-高性能服务器编程读书记录高级部分/index.html","hash":"0ce03e20461055e173516d7199ba4e989596eda1","modified":1584752704056},{"_id":"public/2019/08/CPP-读书记录80-CPPPrimer/index.html","hash":"18b5b08279c9199e5476a32dc55130bad7a55e13","modified":1584752704056},{"_id":"public/2019/08/CPP-读书记录100-高性能服务器编程读书记录初级部分/index.html","hash":"3b91dc2cb5144813b6b350c34cb62d78c8c5d7d6","modified":1584752704056},{"_id":"public/archives/index.html","hash":"76145f01191da87e8dc72e6b1cbce89b54be1707","modified":1584752704056},{"_id":"public/2019/07/学习记录-大一暑假/index.html","hash":"2a0905bb078d08ca90a77197675d0a5f64baf72f","modified":1584752704056},{"_id":"public/archives/page/2/index.html","hash":"7b591c6c8c80f45dcb23eddb4980fc00cc22c585","modified":1584752704056},{"_id":"public/archives/page/3/index.html","hash":"ae85ff481d94ac0ef9aed0e9ea6b3ede6035d9ba","modified":1584752704056},{"_id":"public/archives/2019/index.html","hash":"fbc30bd8acfe0c8db2ffff072a514a242b1dd2c2","modified":1584752704056},{"_id":"public/archives/2020/index.html","hash":"ede1a1540bd29838c4aef7d09d01693be487a3aa","modified":1584752704056},{"_id":"public/archives/2020/page/2/index.html","hash":"f39fbef8f3a68fb8be4fbe1dd9df0151f7113fd0","modified":1584752704056},{"_id":"public/archives/2020/02/index.html","hash":"21ceff07414a814f95d267006183d98d98503bd3","modified":1584752704056},{"_id":"public/archives/2020/03/index.html","hash":"0c0137f85c7b9357242171f6a354685d1c47bb1d","modified":1584752704056},{"_id":"public/categories/CPP/index.html","hash":"e3b926f8adb5953833b9fbe1faa3e1bf0d8d0ece","modified":1584752704056},{"_id":"public/categories/CPP/page/2/index.html","hash":"194a95b8f65e43d1bfe918b03c44b219d996cb53","modified":1584752704056},{"_id":"public/categories/CPP/CPP重点/index.html","hash":"dd749ebbe57f0c7c38a4d6d3e6ba04982a58e18a","modified":1584752704056},{"_id":"public/categories/CPP/服务器编程-书籍记录/index.html","hash":"51d715c654cdaadcdffe753bbdb878ab7b1031e3","modified":1584752704056},{"_id":"public/index.html","hash":"49569b3838c32f65984e806083a66aa66d892ef4","modified":1584752704056},{"_id":"public/page/3/index.html","hash":"574e18d4753f9d5cc2d76e01ff4ee3e0800c8860","modified":1584752704056},{"_id":"public/page/2/index.html","hash":"99340d6a67f3285098fdaed1351f3bce87c02a65","modified":1584752704056},{"_id":"public/CNAME","hash":"5d1b3c534b5001bee37dc2a8e8da866b00c2eb73","modified":1584752704056},{"_id":"public/favicons/android-chrome-192x192.png","hash":"05d291f0be2766b4f46a62fbabdc10b3d6ff092a","modified":1584752704056},{"_id":"public/favicons/browserconfig.xml","hash":"974aea18bda5a95802c06b80126ab1d96d91d708","modified":1584752704056},{"_id":"public/favicons/favicon-32x32.png","hash":"8c3bb4b352237b05f8119644d91099c5288ca2b6","modified":1584752704056},{"_id":"public/favicons/favicon-16x16.png","hash":"c92eeb1df6654eb34f9cf354e3922a794021e377","modified":1584752704056},{"_id":"public/favicons/site.webmanifest","hash":"13e5aa58eb2182d8ace63266856c8cc29c47c083","modified":1584752704056},{"_id":"public/favicons/apple-touch-icon.png","hash":"f208d1156aee20488a1f98d902f5a674a7cc6d84","modified":1584752704056},{"_id":"public/favicons/favicon.ico","hash":"7819f8009e037fa738545f5645efc32457ebb9e0","modified":1584752704056},{"_id":"public/favicons/mstile-150x150.png","hash":"266c87b17aa65bed8a431b5d88281ce488b03c6f","modified":1584752704056},{"_id":"public/favicon.ico","hash":"38591b263c047efbb16cd04a51a2d43316e3ebac","modified":1584752704056},{"_id":"public/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1584752704056},{"_id":"public/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1584752704056},{"_id":"public/js/search.js","hash":"600a37dbbc5377e5e7ded6ce993badc30211afee","modified":1584752704056},{"_id":"public/js/highsong.js","hash":"8138f104a8607b93bce3d7c3641e069952f3849b","modified":1584752704056},{"_id":"public/js/thirdParty/busuanzi.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1584752704056},{"_id":"public/css/thirdParty/highlight/github.css","hash":"e5cdc036897bef17b0a40bd3310fb35a202df2b3","modified":1584752704056},{"_id":"public/css/thirdParty/highlight/solarized-light.css","hash":"10bd5d6b6f332e32edd377f16d3b8ed04713ae81","modified":1584752704056},{"_id":"public/js/app.js","hash":"647c1cf899574d9d3c979ade87ba18e1559a8d78","modified":1584752704056},{"_id":"public/css/pages/comments.css","hash":"ee7e553676fa58acf12ffbb34decce30f733f4bc","modified":1584752704056},{"_id":"public/css/thirdParty/font-awesome.min.css","hash":"d2c7e3e8ed62f73240fde919253822bc7ce12b15","modified":1584752704056},{"_id":"public/js/thirdParty/gitment.browser.min.js","hash":"5cb10e77f44ad075512ee4a3fd518d9a5257a80c","modified":1584752704056},{"_id":"public/js/thirdParty/gitment.browser.js","hash":"0711b1ae17b2dd8767ec60dabe5d71b75037cedc","modified":1584752704056},{"_id":"public/js/thirdParty/highlight.pack.js","hash":"3c707416d178e317afa6fc552fc181d08ccc9c8c","modified":1584752704056},{"_id":"public/js/thirdParty/leancloud.min.js","hash":"2c4846325ac8f0b036a3b37d2176ed81b3a51d60","modified":1584752704056},{"_id":"public/favicons/android-chrome-512x512.png","hash":"e02dcf98fa3f146bfdd7bc74046b913627f8abee","modified":1584752704056},{"_id":"public/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1584752704056},{"_id":"public/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1584752704056},{"_id":"public/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1584752704056},{"_id":"public/js/thirdParty/gitment.browser.js.map","hash":"b921d63b0e593bfc456068b40516dc0ea442dc53","modified":1584752704056},{"_id":"public/css/pages/article-exp.css","hash":"ff3ff2ca0629ae9c93f9c4dc44571d72342853c1","modified":1584752704056},{"_id":"public/css/pages/archive.css","hash":"0d7bd6c5971b30d19ae01c8fb99f2b7db090ad22","modified":1584752704056},{"_id":"public/css/pages/othersPages.css","hash":"d374c64bd2cb94613fd25a4902de5382a9ffba8b","modified":1584752704056},{"_id":"public/css/pages/post.css","hash":"8c24a714cb49c1b68ffc9821360d71bc3c97fbd6","modified":1584752704056},{"_id":"public/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1584752704056},{"_id":"public/css/base.css","hash":"00fdb8e72e44066bfc0b10e85c978025f45c912c","modified":1584752704056},{"_id":"public/js/thirdParty/gitment.browser.min.js.map","hash":"6cd313c386f1dfb5093fb4f71ed29796e01134f4","modified":1584752704056}],"Category":[{"name":"CPP","_id":"ck80wucuj00028cuo4yid11ki"},{"name":"3DMAX","_id":"ck80wucun00078cuo7wp858la"},{"name":"CPP基础","parent":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucus000g8cuog9ned79a"},{"name":"CPP重点","parent":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucuz000x8cuo2ysec6so"},{"name":"CPP踩坑","parent":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucv300178cuogf0x9vg4"},{"name":"Socket理论","parent":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucvk00288cuo48gw8jrg"},{"name":"源码学习","parent":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucvm002g8cuoh3kv9di4"},{"name":"服务器编程-书籍记录","parent":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucvo002n8cuo6nin6m5v"},{"name":"必备技能","_id":"ck80wucw1003u8cuofhznac2s"},{"name":"UE4","_id":"ck80wucw200418cuoetcp1xcm"},{"name":"学习记录","_id":"ck80wucw200428cuohyg84u1x"},{"name":"小游戏","_id":"ck80wucw300468cuocqx4hlsw"},{"name":"操作系统","_id":"ck80wucw400498cuo7pd7dvm1"},{"name":"数据库","_id":"ck80wucw5004f8cuogeli5bsm"},{"name":"游戏知识","_id":"ck80wucw5004i8cuoagzdhqw4"},{"name":"算法","_id":"ck80wucw6004l8cuoe8suc7bq"},{"name":"Git操作","parent":"ck80wucw1003u8cuofhznac2s","_id":"ck80wucw8004r8cuofsmaaxvk"},{"name":"网络","parent":"ck80wucw200418cuoetcp1xcm","_id":"ck80wucw9004t8cuo9yes6yud"},{"name":"Mysql","parent":"ck80wucw5004f8cuogeli5bsm","_id":"ck80wucwa004z8cuo3xuuficg"},{"name":"腾讯游戏学院","parent":"ck80wucw5004i8cuoagzdhqw4","_id":"ck80wucwa00538cuo67ms56vx"},{"name":"MongoDB","parent":"ck80wucw5004f8cuogeli5bsm","_id":"ck80wucwa00568cuoekmofe3e"},{"name":"算法刷题记录","parent":"ck80wucw6004l8cuoe8suc7bq","_id":"ck80wucwb00598cuoc4vsde7k"},{"name":"服务器","parent":"ck80wucw5004i8cuoagzdhqw4","_id":"ck80wucwb005c8cuocnwph8f5"},{"name":"算法理论","parent":"ck80wucw6004l8cuoe8suc7bq","_id":"ck80wucwc005h8cuo5db0hn05"}],"Data":[],"Page":[],"Post":[{"title":"C++薄书整理","date":"2019-10-20T11:13:22.000Z","_content":"\n# 定义新量\n\nauto 自动根据初始值的类型进行自动类型推导.\ndecltype 根据表达式的类型定义对象\n\n右值引用, 操纵右值对象\n`std::move()`, 可以将一个\n\n**枚举**\n不限定作用域的定义\nenum color {red, green, blue};\n限定在类型内部的作用域\nenum class color {red, green, blue};\n`color a = color::red`\n\n# 函数\n数组传参的长度处理\n- 直接传递数组长度\n- 使用C风格字符串(默认结尾有标志)\n- 使用C++11的新函数begin()和end()同时传递首尾地址\n\n函数指针\n`bool (*pf)(int, int)` 可以指向\n`bool max(int a,int b)`\n调用 `pf(1, 1)`即可\n常用于函数的参数是一个函数的返回值\n\n**Lambda**\n`[]() -> return type {statements}`\n中括号代表lambda引导, 其中的captures子句在同一作用域下lambda主体捕获(访问)哪些对象\n以及如何捕获这些对象\n- 可以为空, 不会访问外围对象\n- [=] 代表用值捕获的方式\n- [&] 代表引用捕获\n\n# 类\n**辅助函数**\n定义辅助函数, 有点像Java里面的重写toString()函数(最常见的代表的例子)\n```c++\nostream &print(ostream &os)\n{\n\tos << 1 << endl;\n\treturn os;\n}\n```\n**友元函数**\n一个类的辅助函数从概念上可以看成类的接口, 虽然和类的关系很密切, 但并不是类的成员, 所以不能直接访问私有成员\nC++ 中可以将该类函数声明为该类的友元.\n这样就能访问到类的非公有成员.\n在函数的前面加上`friend`关键字\n**友元类**\n如果A想访问B的私有成员, 可以在B内声明`friend class A`, 这样就可以在B内访问A的私有成员\n*友元关系是单向的, 不具有交换性, 同时也不具有传递性*\n\n**构造函数**\n默认构造函数没有参数, 或者所有的参数都具有默认值\nC++11允许在显示定义构造函数的情况下使用默认构造函数\n需要在默认构造函数后面加上`= default`\n*使用默认构造函数创建类对象时, 切忌在对象名后I使用圆括号, 成了一个函数声明*\n\n**初始值列表**\nT(int a, int b):a_(a), b_(b){}\n引用和const修饰的必须用初始值列表初始化, 初始的顺序取决于数据成员在类内的定义顺序,\n而非初始值列表的顺序\n\n**简化构造函数**\n实际将自己的带参构造函数, 给定默认值, 这样就实现了默认构造函数和带参构造函数的合并\n\n**复制构造函数**\n参数为该类的引用\n\n**委托构造函数**\n减少构造函数代码量\n实际就是一个构造函数后面加上`:`调用另一个构造函数, 同时传入参数\n```c++\nclass A\n{\n\tint bar1_;\n\tint bar2_;\n\tA(int b1):A(b1, 2){}\n\tA(int b1, int b2):bar1_(b1), bar2_(b2){}\n}\n```\n**运算符重载**\nT operator /(A, B);\n双目运算符两个参数\n单目运算符一个参数\n对于二元运算符, 左侧运算对象传递给第一个参数, 右侧运算对象传递给第二个参数.\n\n运算符重载的声明和定义的分离\n放在类成员中的运算符重载, 需要算入默认的this指针参数\n```c++\n// test.h\n#include <cstdio>\nclass Test\n{\npublic:\n    Test(int a, int b);\n    Test& operator+(const Test& right);\n\tvoid PrintAB();\nprivate:\n\tint a_;\n\tint b_;\n};\n// test.cpp\n#include \"test.h\"\nTest::Test(int a, int b)\n{\n    a_ = a;\n    b_ = b;\n}\nTest& Test::operator+(const Test& right)\n{\n    Test test(this->a_ + right.a_, this->b_ + right.b_);\n    return test;\n}\nvoid Test::PrintAB()\n{\n    printf(\"%d %d\\n\", a_, b_);\n}\n// main.cpp\nint main()\n{\n    Test test1(1, 1);\n    Test test2(2, 2);\n    Test test = test1 + test2;\n    test.PrintAB();\n    return 0;\n}\n\n// ++ -- \nTest& operator++(); // 前置版本\nTest operator++(int); // 后置版本\n```\n**类成员指针**\n*数据成员指针* (private不能通过指针访问)\n其值是数据成员所在地址相对于对象起始地址的偏移值\n```c++\nA T::*p1 = &T::x\nint A::*p1 = &A::value\nA a;\n// 使用方式\na.*p = ......................;\n```\np1指向T类中的 A类型的x数据成员\n`A T::`可以用`auto`\n\n*成员函数指针*\n```c++\nint (A::*pf)();\npf = &A::GetValue;\n// 当然可以使用auto 来简化\nauto pf2 = &A::GetValue;\n// 使用方式\n(a.*pf)();\n\n```\n\n----\n统一初始化\n`X x1 = {0} 和 X x2 {0}` 这两种是不同的实现!!, 大多数情况下这两个是相通的, 然而当\n`explicit构造函数`存在的时候`前者的初始化是错误的`\n\n`int x{0} int x= 0 int x(0)` 最后一个是错误的可能会和函数声明冲突\n```c++\nclass A\n{\n\ttypedef int x;\n\tint z(x);\n}\n```\n\n另外还存在一个\n```c++\nstd::atomic<int> a1{0}; // OK\nstd::atomic<int> a2(0); // OK\nstd::atomic<int> a3 = 0; // Error\n```\n这个错误的原因是copy-initialization引起的\n这个copy-initialization发生在`T x = a`的声明, 下面我把原博客的部分重要英文替换成中文或代码描述\n`std::atomic<int> a3 = 0` 从`int类型`赋值到`可能是 cv-qualified`的`class type`\n[cv-qualified](https://stackoverflow.com/questions/27527642/what-does-cv-qualified-mean)\n```c++\n// ***cv-qualified***\n// non cv_qualified\nint first; \nchar *second; \n\n// cv-qualified \nconst int third; \nvolatile char * fourth; \n```\n`std::atomic<int> a3 = 0` 满足了这个条件属于`copy-initialization`\n[copy-initialization](https://www.quora.com/What-is-the-difference-between-copy-initialization-and-direct-initialization-of-objects-in-c++)\n[直接初始化和复制初始化的区别](https://blog.csdn.net/ljianhui/article/details/9245661)\n直接初始化会直接用参数生成对象, 而复制初始化会`用参数生成临时对象, 然后将这个对象复制到正要创建的对象`\n```c++\nclass A\n{\npublic:\n        A () { } //直接初始化会调用这个构造函数\n        A (const A& a) { } //复制初始化会调用这个\n}\n```\n接下来需要通过`std::atomic<int>(int)`把0转换成成一个纯右值(prvalue)的临时对象\n[纯右值](https://zh.cppreference.com/w/cpp/language/value_category)\n[纯右值](https://www.cnblogs.com/zpcdbky/p/5275959.html)\n然后再将这个临时对象用直接初始化(调用复制构造函数), 然而`std::atomic<int>`把拷贝\n构造函数给禁用了, 就会出错\n`std::atomic<int> a3 {0}`这个会直接调用接收int的构造函数\n\n回到`X x1 = {0}`这里, 这个表达式是一个复制构造, 用一个braced-init-list(指的{0}). \n这里有两个阶段\n首先是会把单个参数的构造函数汇总起来(得到A-list)供选择, 如果其中没有合适的构造函数, 再将候选列表\n转换为所有构造函数\n\n如果如果A-list没有构造函数, 并且class T存在默认构造函数, 第一阶段就会被忽略\n如果在一个使用`{}`的初始化, 并且选择到了`explicit 构造函数头上`就会报错\n\n`explicit`可以防止在调用某个成员函数的时候, 实参类型(通过构造函数之一)自动转换成相应参数,\n但此时这个函数需要其他的成员变量参与到函数运行, 恰巧这时所需要的其他成员变量没有得到合适的初始化, 就会发生错误(没有得到合适初始化的原因就是, 自动调用了不合适的构造函数生成了这个函数所需要的参数(一般是对象))\n\n@2019年10月26日21:25:58@算是第一次解决一个环环相扣的问题, 精力有点不足了\nhttps://zhuanlan.zhihu.com/p/21102748 后续会继续进行理解\n[这里还发现一个](https://blog.csdn.net/spaceyqy/article/details/22730939)\n\n# 模板, 泛型 动态内存, 数据结构\n```c++\ntemplate <typename T>\nconst T& GetMax(const T& a, const T& b)\n{\n    return a > b ? a : b;\n}\nint main()\n{\n    std::cout << GetMax(1, 2);\n\tstd::cout << GetMax<int>(1, 2); // 显示指定模板类型\n    return 0; \n}\n```\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/C%2B%2B%E5%86%85%E5%AD%98.png)\nC++堆的内存需要手动new和delete, 如果一个对象new出来没有在能被释放的时候释放就会造成--**内存泄漏**(需要及时delete不需要的对象)\n一个指向动态内存的指针, 在动态内存被释放后, 指针依然指向原来的地址--**空悬指针**(释放内存后将相应的指针设置为nullptr)\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png)\n","source":"_posts/CPP-CPP基础-2.md","raw":"---\ntitle: C++薄书整理\ntags:\n  - null\ncategories:\n  - CPP\n  - CPP基础\ndate: 2019-10-20 19:13:22\n---\n\n# 定义新量\n\nauto 自动根据初始值的类型进行自动类型推导.\ndecltype 根据表达式的类型定义对象\n\n右值引用, 操纵右值对象\n`std::move()`, 可以将一个\n\n**枚举**\n不限定作用域的定义\nenum color {red, green, blue};\n限定在类型内部的作用域\nenum class color {red, green, blue};\n`color a = color::red`\n\n# 函数\n数组传参的长度处理\n- 直接传递数组长度\n- 使用C风格字符串(默认结尾有标志)\n- 使用C++11的新函数begin()和end()同时传递首尾地址\n\n函数指针\n`bool (*pf)(int, int)` 可以指向\n`bool max(int a,int b)`\n调用 `pf(1, 1)`即可\n常用于函数的参数是一个函数的返回值\n\n**Lambda**\n`[]() -> return type {statements}`\n中括号代表lambda引导, 其中的captures子句在同一作用域下lambda主体捕获(访问)哪些对象\n以及如何捕获这些对象\n- 可以为空, 不会访问外围对象\n- [=] 代表用值捕获的方式\n- [&] 代表引用捕获\n\n# 类\n**辅助函数**\n定义辅助函数, 有点像Java里面的重写toString()函数(最常见的代表的例子)\n```c++\nostream &print(ostream &os)\n{\n\tos << 1 << endl;\n\treturn os;\n}\n```\n**友元函数**\n一个类的辅助函数从概念上可以看成类的接口, 虽然和类的关系很密切, 但并不是类的成员, 所以不能直接访问私有成员\nC++ 中可以将该类函数声明为该类的友元.\n这样就能访问到类的非公有成员.\n在函数的前面加上`friend`关键字\n**友元类**\n如果A想访问B的私有成员, 可以在B内声明`friend class A`, 这样就可以在B内访问A的私有成员\n*友元关系是单向的, 不具有交换性, 同时也不具有传递性*\n\n**构造函数**\n默认构造函数没有参数, 或者所有的参数都具有默认值\nC++11允许在显示定义构造函数的情况下使用默认构造函数\n需要在默认构造函数后面加上`= default`\n*使用默认构造函数创建类对象时, 切忌在对象名后I使用圆括号, 成了一个函数声明*\n\n**初始值列表**\nT(int a, int b):a_(a), b_(b){}\n引用和const修饰的必须用初始值列表初始化, 初始的顺序取决于数据成员在类内的定义顺序,\n而非初始值列表的顺序\n\n**简化构造函数**\n实际将自己的带参构造函数, 给定默认值, 这样就实现了默认构造函数和带参构造函数的合并\n\n**复制构造函数**\n参数为该类的引用\n\n**委托构造函数**\n减少构造函数代码量\n实际就是一个构造函数后面加上`:`调用另一个构造函数, 同时传入参数\n```c++\nclass A\n{\n\tint bar1_;\n\tint bar2_;\n\tA(int b1):A(b1, 2){}\n\tA(int b1, int b2):bar1_(b1), bar2_(b2){}\n}\n```\n**运算符重载**\nT operator /(A, B);\n双目运算符两个参数\n单目运算符一个参数\n对于二元运算符, 左侧运算对象传递给第一个参数, 右侧运算对象传递给第二个参数.\n\n运算符重载的声明和定义的分离\n放在类成员中的运算符重载, 需要算入默认的this指针参数\n```c++\n// test.h\n#include <cstdio>\nclass Test\n{\npublic:\n    Test(int a, int b);\n    Test& operator+(const Test& right);\n\tvoid PrintAB();\nprivate:\n\tint a_;\n\tint b_;\n};\n// test.cpp\n#include \"test.h\"\nTest::Test(int a, int b)\n{\n    a_ = a;\n    b_ = b;\n}\nTest& Test::operator+(const Test& right)\n{\n    Test test(this->a_ + right.a_, this->b_ + right.b_);\n    return test;\n}\nvoid Test::PrintAB()\n{\n    printf(\"%d %d\\n\", a_, b_);\n}\n// main.cpp\nint main()\n{\n    Test test1(1, 1);\n    Test test2(2, 2);\n    Test test = test1 + test2;\n    test.PrintAB();\n    return 0;\n}\n\n// ++ -- \nTest& operator++(); // 前置版本\nTest operator++(int); // 后置版本\n```\n**类成员指针**\n*数据成员指针* (private不能通过指针访问)\n其值是数据成员所在地址相对于对象起始地址的偏移值\n```c++\nA T::*p1 = &T::x\nint A::*p1 = &A::value\nA a;\n// 使用方式\na.*p = ......................;\n```\np1指向T类中的 A类型的x数据成员\n`A T::`可以用`auto`\n\n*成员函数指针*\n```c++\nint (A::*pf)();\npf = &A::GetValue;\n// 当然可以使用auto 来简化\nauto pf2 = &A::GetValue;\n// 使用方式\n(a.*pf)();\n\n```\n\n----\n统一初始化\n`X x1 = {0} 和 X x2 {0}` 这两种是不同的实现!!, 大多数情况下这两个是相通的, 然而当\n`explicit构造函数`存在的时候`前者的初始化是错误的`\n\n`int x{0} int x= 0 int x(0)` 最后一个是错误的可能会和函数声明冲突\n```c++\nclass A\n{\n\ttypedef int x;\n\tint z(x);\n}\n```\n\n另外还存在一个\n```c++\nstd::atomic<int> a1{0}; // OK\nstd::atomic<int> a2(0); // OK\nstd::atomic<int> a3 = 0; // Error\n```\n这个错误的原因是copy-initialization引起的\n这个copy-initialization发生在`T x = a`的声明, 下面我把原博客的部分重要英文替换成中文或代码描述\n`std::atomic<int> a3 = 0` 从`int类型`赋值到`可能是 cv-qualified`的`class type`\n[cv-qualified](https://stackoverflow.com/questions/27527642/what-does-cv-qualified-mean)\n```c++\n// ***cv-qualified***\n// non cv_qualified\nint first; \nchar *second; \n\n// cv-qualified \nconst int third; \nvolatile char * fourth; \n```\n`std::atomic<int> a3 = 0` 满足了这个条件属于`copy-initialization`\n[copy-initialization](https://www.quora.com/What-is-the-difference-between-copy-initialization-and-direct-initialization-of-objects-in-c++)\n[直接初始化和复制初始化的区别](https://blog.csdn.net/ljianhui/article/details/9245661)\n直接初始化会直接用参数生成对象, 而复制初始化会`用参数生成临时对象, 然后将这个对象复制到正要创建的对象`\n```c++\nclass A\n{\npublic:\n        A () { } //直接初始化会调用这个构造函数\n        A (const A& a) { } //复制初始化会调用这个\n}\n```\n接下来需要通过`std::atomic<int>(int)`把0转换成成一个纯右值(prvalue)的临时对象\n[纯右值](https://zh.cppreference.com/w/cpp/language/value_category)\n[纯右值](https://www.cnblogs.com/zpcdbky/p/5275959.html)\n然后再将这个临时对象用直接初始化(调用复制构造函数), 然而`std::atomic<int>`把拷贝\n构造函数给禁用了, 就会出错\n`std::atomic<int> a3 {0}`这个会直接调用接收int的构造函数\n\n回到`X x1 = {0}`这里, 这个表达式是一个复制构造, 用一个braced-init-list(指的{0}). \n这里有两个阶段\n首先是会把单个参数的构造函数汇总起来(得到A-list)供选择, 如果其中没有合适的构造函数, 再将候选列表\n转换为所有构造函数\n\n如果如果A-list没有构造函数, 并且class T存在默认构造函数, 第一阶段就会被忽略\n如果在一个使用`{}`的初始化, 并且选择到了`explicit 构造函数头上`就会报错\n\n`explicit`可以防止在调用某个成员函数的时候, 实参类型(通过构造函数之一)自动转换成相应参数,\n但此时这个函数需要其他的成员变量参与到函数运行, 恰巧这时所需要的其他成员变量没有得到合适的初始化, 就会发生错误(没有得到合适初始化的原因就是, 自动调用了不合适的构造函数生成了这个函数所需要的参数(一般是对象))\n\n@2019年10月26日21:25:58@算是第一次解决一个环环相扣的问题, 精力有点不足了\nhttps://zhuanlan.zhihu.com/p/21102748 后续会继续进行理解\n[这里还发现一个](https://blog.csdn.net/spaceyqy/article/details/22730939)\n\n# 模板, 泛型 动态内存, 数据结构\n```c++\ntemplate <typename T>\nconst T& GetMax(const T& a, const T& b)\n{\n    return a > b ? a : b;\n}\nint main()\n{\n    std::cout << GetMax(1, 2);\n\tstd::cout << GetMax<int>(1, 2); // 显示指定模板类型\n    return 0; \n}\n```\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/C%2B%2B%E5%86%85%E5%AD%98.png)\nC++堆的内存需要手动new和delete, 如果一个对象new出来没有在能被释放的时候释放就会造成--**内存泄漏**(需要及时delete不需要的对象)\n一个指向动态内存的指针, 在动态内存被释放后, 指针依然指向原来的地址--**空悬指针**(释放内存后将相应的指针设置为nullptr)\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png)\n","slug":"CPP-CPP基础-2","published":1,"updated":"2020-01-31T08:07:47.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucud00008cuocrbjh7rs","content":"<h1 id=\"定义新量\"><a href=\"#定义新量\" class=\"headerlink\" title=\"定义新量\"></a>定义新量</h1><p>auto 自动根据初始值的类型进行自动类型推导.<br>decltype 根据表达式的类型定义对象</p>\n<p>右值引用, 操纵右值对象<br><code>std::move()</code>, 可以将一个</p>\n<p><strong>枚举</strong><br>不限定作用域的定义<br>enum color {red, green, blue};<br>限定在类型内部的作用域<br>enum class color {red, green, blue};<br><code>color a = color::red</code></p>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><p>数组传参的长度处理</p>\n<ul>\n<li>直接传递数组长度</li>\n<li>使用C风格字符串(默认结尾有标志)</li>\n<li>使用C++11的新函数begin()和end()同时传递首尾地址</li>\n</ul>\n<p>函数指针<br><code>bool (*pf)(int, int)</code> 可以指向<br><code>bool max(int a,int b)</code><br>调用 <code>pf(1, 1)</code>即可<br>常用于函数的参数是一个函数的返回值</p>\n<p><strong>Lambda</strong><br><code>[]() -&gt; return type {statements}</code><br>中括号代表lambda引导, 其中的captures子句在同一作用域下lambda主体捕获(访问)哪些对象<br>以及如何捕获这些对象</p>\n<ul>\n<li>可以为空, 不会访问外围对象</li>\n<li>[=] 代表用值捕获的方式</li>\n<li>[&amp;] 代表引用捕获</li>\n</ul>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><p><strong>辅助函数</strong><br>定义辅助函数, 有点像Java里面的重写toString()函数(最常见的代表的例子)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ostream &amp;<span class=\"title\">print</span><span class=\"params\">(ostream &amp;os)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tos &lt;&lt; <span class=\"number\">1</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> os;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>友元函数</strong><br>一个类的辅助函数从概念上可以看成类的接口, 虽然和类的关系很密切, 但并不是类的成员, 所以不能直接访问私有成员<br>C++ 中可以将该类函数声明为该类的友元.<br>这样就能访问到类的非公有成员.<br>在函数的前面加上<code>friend</code>关键字<br><strong>友元类</strong><br>如果A想访问B的私有成员, 可以在B内声明<code>friend class A</code>, 这样就可以在B内访问A的私有成员<br><em>友元关系是单向的, 不具有交换性, 同时也不具有传递性</em></p>\n<p><strong>构造函数</strong><br>默认构造函数没有参数, 或者所有的参数都具有默认值<br>C++11允许在显示定义构造函数的情况下使用默认构造函数<br>需要在默认构造函数后面加上<code>= default</code><br><em>使用默认构造函数创建类对象时, 切忌在对象名后I使用圆括号, 成了一个函数声明</em></p>\n<p><strong>初始值列表</strong><br>T(int a, int b):a_(a), b_(b){}<br>引用和const修饰的必须用初始值列表初始化, 初始的顺序取决于数据成员在类内的定义顺序,<br>而非初始值列表的顺序</p>\n<p><strong>简化构造函数</strong><br>实际将自己的带参构造函数, 给定默认值, 这样就实现了默认构造函数和带参构造函数的合并</p>\n<p><strong>复制构造函数</strong><br>参数为该类的引用</p>\n<p><strong>委托构造函数</strong><br>减少构造函数代码量<br>实际就是一个构造函数后面加上<code>:</code>调用另一个构造函数, 同时传入参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> bar1_;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> bar2_;</span><br><span class=\"line\">\tA(<span class=\"keyword\">int</span> b1):A(b1, <span class=\"number\">2</span>)&#123;&#125;</span><br><span class=\"line\">\tA(<span class=\"keyword\">int</span> b1, <span class=\"keyword\">int</span> b2):bar1_(b1), bar2_(b2)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>运算符重载</strong><br>T operator /(A, B);<br>双目运算符两个参数<br>单目运算符一个参数<br>对于二元运算符, 左侧运算对象传递给第一个参数, 右侧运算对象传递给第二个参数.</p>\n<p>运算符重载的声明和定义的分离<br>放在类成员中的运算符重载, 需要算入默认的this指针参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Test(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b);</span><br><span class=\"line\">    Test&amp; <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Test&amp; right);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintAB</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a_;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// test.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"test.h\"</span></span></span><br><span class=\"line\">Test::Test(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    a_ = a;</span><br><span class=\"line\">    b_ = b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Test&amp; Test::<span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Test&amp; right)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">this</span>-&gt;a_ + right.a_, <span class=\"keyword\">this</span>-&gt;b_ + right.b_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> test;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Test::PrintAB</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\\n\"</span>, a_, b_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">test1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">test2</span><span class=\"params\">(<span class=\"number\">2</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">    Test test = test1 + test2;</span><br><span class=\"line\">    test.PrintAB();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ++ -- </span></span><br><span class=\"line\">Test&amp; <span class=\"keyword\">operator</span>++(); <span class=\"comment\">// 前置版本</span></span><br><span class=\"line\">Test <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>); <span class=\"comment\">// 后置版本</span></span><br></pre></td></tr></table></figure>\n<p><strong>类成员指针</strong><br><em>数据成员指针</em> (private不能通过指针访问)<br>其值是数据成员所在地址相对于对象起始地址的偏移值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A T::*p1 = &amp;T::x</span><br><span class=\"line\"><span class=\"keyword\">int</span> A::*p1 = &amp;A::value</span><br><span class=\"line\">A a;</span><br><span class=\"line\"><span class=\"comment\">// 使用方式</span></span><br><span class=\"line\">a.*p = ......................;</span><br></pre></td></tr></table></figure>\n<p>p1指向T类中的 A类型的x数据成员<br><code>A T::</code>可以用<code>auto</code></p>\n<p><em>成员函数指针</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (A::*pf)();</span><br><span class=\"line\">pf = &amp;A::GetValue;</span><br><span class=\"line\"><span class=\"comment\">// 当然可以使用auto 来简化</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> pf2 = &amp;A::GetValue;</span><br><span class=\"line\"><span class=\"comment\">// 使用方式</span></span><br><span class=\"line\">(a.*pf)();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>统一初始化<br><code>X x1 = {0} 和 X x2 {0}</code> 这两种是不同的实现!!, 大多数情况下这两个是相通的, 然而当<br><code>explicit构造函数</code>存在的时候<code>前者的初始化是错误的</code></p>\n<p><code>int x{0} int x= 0 int x(0)</code> 最后一个是错误的可能会和函数声明冲突</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">z</span><span class=\"params\">(x)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外还存在一个</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::atomic&lt;<span class=\"keyword\">int</span>&gt; a1&#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::atomic&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">a2</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::atomic&lt;<span class=\"keyword\">int</span>&gt; a3 = <span class=\"number\">0</span>; <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>这个错误的原因是copy-initialization引起的<br>这个copy-initialization发生在<code>T x = a</code>的声明, 下面我把原博客的部分重要英文替换成中文或代码描述<br><code>std::atomic&lt;int&gt; a3 = 0</code> 从<code>int类型</code>赋值到<code>可能是 cv-qualified</code>的<code>class type</code><br><a href=\"https://stackoverflow.com/questions/27527642/what-does-cv-qualified-mean\" target=\"_blank\" rel=\"noopener\">cv-qualified</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ***cv-qualified***</span></span><br><span class=\"line\"><span class=\"comment\">// non cv_qualified</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> first; </span><br><span class=\"line\"><span class=\"keyword\">char</span> *second; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cv-qualified </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> third; </span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">char</span> * fourth;</span><br></pre></td></tr></table></figure>\n<p><code>std::atomic&lt;int&gt; a3 = 0</code> 满足了这个条件属于<code>copy-initialization</code><br><a href=\"https://www.quora.com/What-is-the-difference-between-copy-initialization-and-direct-initialization-of-objects-in-c++\" target=\"_blank\" rel=\"noopener\">copy-initialization</a><br><a href=\"https://blog.csdn.net/ljianhui/article/details/9245661\" target=\"_blank\" rel=\"noopener\">直接初始化和复制初始化的区别</a><br>直接初始化会直接用参数生成对象, 而复制初始化会<code>用参数生成临时对象, 然后将这个对象复制到正要创建的对象</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">        A () &#123; &#125; <span class=\"comment\">//直接初始化会调用这个构造函数</span></span><br><span class=\"line\">        A (<span class=\"keyword\">const</span> A&amp; a) &#123; &#125; <span class=\"comment\">//复制初始化会调用这个</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来需要通过<code>std::atomic&lt;int&gt;(int)</code>把0转换成成一个纯右值(prvalue)的临时对象<br><a href=\"https://zh.cppreference.com/w/cpp/language/value_category\" target=\"_blank\" rel=\"noopener\">纯右值</a><br><a href=\"https://www.cnblogs.com/zpcdbky/p/5275959.html\" target=\"_blank\" rel=\"noopener\">纯右值</a><br>然后再将这个临时对象用直接初始化(调用复制构造函数), 然而<code>std::atomic&lt;int&gt;</code>把拷贝<br>构造函数给禁用了, 就会出错<br><code>std::atomic&lt;int&gt; a3 {0}</code>这个会直接调用接收int的构造函数</p>\n<p>回到<code>X x1 = {0}</code>这里, 这个表达式是一个复制构造, 用一个braced-init-list(指的{0}).<br>这里有两个阶段<br>首先是会把单个参数的构造函数汇总起来(得到A-list)供选择, 如果其中没有合适的构造函数, 再将候选列表<br>转换为所有构造函数</p>\n<p>如果如果A-list没有构造函数, 并且class T存在默认构造函数, 第一阶段就会被忽略<br>如果在一个使用<code>{}</code>的初始化, 并且选择到了<code>explicit 构造函数头上</code>就会报错</p>\n<p><code>explicit</code>可以防止在调用某个成员函数的时候, 实参类型(通过构造函数之一)自动转换成相应参数,<br>但此时这个函数需要其他的成员变量参与到函数运行, 恰巧这时所需要的其他成员变量没有得到合适的初始化, 就会发生错误(没有得到合适初始化的原因就是, 自动调用了不合适的构造函数生成了这个函数所需要的参数(一般是对象))</p>\n<p>@2019年10月26日21:25:58@算是第一次解决一个环环相扣的问题, 精力有点不足了<br><a href=\"https://zhuanlan.zhihu.com/p/21102748\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/21102748</a> 后续会继续进行理解<br><a href=\"https://blog.csdn.net/spaceyqy/article/details/22730939\" target=\"_blank\" rel=\"noopener\">这里还发现一个</a></p>\n<h1 id=\"模板-泛型-动态内存-数据结构\"><a href=\"#模板-泛型-动态内存-数据结构\" class=\"headerlink\" title=\"模板, 泛型 动态内存, 数据结构\"></a>模板, 泛型 动态内存, 数据结构</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> T&amp; <span class=\"title\">GetMax</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp; a, <span class=\"keyword\">const</span> T&amp; b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &gt; b ? a : b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; GetMax(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; GetMax&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 显示指定模板类型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/C%2B%2B%E5%86%85%E5%AD%98.png\" alt=\"\"><br>C++堆的内存需要手动new和delete, 如果一个对象new出来没有在能被释放的时候释放就会造成–<strong>内存泄漏</strong>(需要及时delete不需要的对象)<br>一个指向动态内存的指针, 在动态内存被释放后, 指针依然指向原来的地址–<strong>空悬指针</strong>(释放内存后将相应的指针设置为nullptr)</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"定义新量\"><a href=\"#定义新量\" class=\"headerlink\" title=\"定义新量\"></a>定义新量</h1><p>auto 自动根据初始值的类型进行自动类型推导.<br>decltype 根据表达式的类型定义对象</p>\n<p>右值引用, 操纵右值对象<br><code>std::move()</code>, 可以将一个</p>\n<p><strong>枚举</strong><br>不限定作用域的定义<br>enum color {red, green, blue};<br>限定在类型内部的作用域<br>enum class color {red, green, blue};<br><code>color a = color::red</code></p>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><p>数组传参的长度处理</p>\n<ul>\n<li>直接传递数组长度</li>\n<li>使用C风格字符串(默认结尾有标志)</li>\n<li>使用C++11的新函数begin()和end()同时传递首尾地址</li>\n</ul>\n<p>函数指针<br><code>bool (*pf)(int, int)</code> 可以指向<br><code>bool max(int a,int b)</code><br>调用 <code>pf(1, 1)</code>即可<br>常用于函数的参数是一个函数的返回值</p>\n<p><strong>Lambda</strong><br><code>[]() -&gt; return type {statements}</code><br>中括号代表lambda引导, 其中的captures子句在同一作用域下lambda主体捕获(访问)哪些对象<br>以及如何捕获这些对象</p>\n<ul>\n<li>可以为空, 不会访问外围对象</li>\n<li>[=] 代表用值捕获的方式</li>\n<li>[&amp;] 代表引用捕获</li>\n</ul>\n<h1 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h1><p><strong>辅助函数</strong><br>定义辅助函数, 有点像Java里面的重写toString()函数(最常见的代表的例子)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ostream &amp;<span class=\"title\">print</span><span class=\"params\">(ostream &amp;os)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tos &lt;&lt; <span class=\"number\">1</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> os;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>友元函数</strong><br>一个类的辅助函数从概念上可以看成类的接口, 虽然和类的关系很密切, 但并不是类的成员, 所以不能直接访问私有成员<br>C++ 中可以将该类函数声明为该类的友元.<br>这样就能访问到类的非公有成员.<br>在函数的前面加上<code>friend</code>关键字<br><strong>友元类</strong><br>如果A想访问B的私有成员, 可以在B内声明<code>friend class A</code>, 这样就可以在B内访问A的私有成员<br><em>友元关系是单向的, 不具有交换性, 同时也不具有传递性</em></p>\n<p><strong>构造函数</strong><br>默认构造函数没有参数, 或者所有的参数都具有默认值<br>C++11允许在显示定义构造函数的情况下使用默认构造函数<br>需要在默认构造函数后面加上<code>= default</code><br><em>使用默认构造函数创建类对象时, 切忌在对象名后I使用圆括号, 成了一个函数声明</em></p>\n<p><strong>初始值列表</strong><br>T(int a, int b):a_(a), b_(b){}<br>引用和const修饰的必须用初始值列表初始化, 初始的顺序取决于数据成员在类内的定义顺序,<br>而非初始值列表的顺序</p>\n<p><strong>简化构造函数</strong><br>实际将自己的带参构造函数, 给定默认值, 这样就实现了默认构造函数和带参构造函数的合并</p>\n<p><strong>复制构造函数</strong><br>参数为该类的引用</p>\n<p><strong>委托构造函数</strong><br>减少构造函数代码量<br>实际就是一个构造函数后面加上<code>:</code>调用另一个构造函数, 同时传入参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> bar1_;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> bar2_;</span><br><span class=\"line\">\tA(<span class=\"keyword\">int</span> b1):A(b1, <span class=\"number\">2</span>)&#123;&#125;</span><br><span class=\"line\">\tA(<span class=\"keyword\">int</span> b1, <span class=\"keyword\">int</span> b2):bar1_(b1), bar2_(b2)&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>运算符重载</strong><br>T operator /(A, B);<br>双目运算符两个参数<br>单目运算符一个参数<br>对于二元运算符, 左侧运算对象传递给第一个参数, 右侧运算对象传递给第二个参数.</p>\n<p>运算符重载的声明和定义的分离<br>放在类成员中的运算符重载, 需要算入默认的this指针参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// test.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Test(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b);</span><br><span class=\"line\">    Test&amp; <span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Test&amp; right);</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintAB</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a_;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// test.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"test.h\"</span></span></span><br><span class=\"line\">Test::Test(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    a_ = a;</span><br><span class=\"line\">    b_ = b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Test&amp; Test::<span class=\"keyword\">operator</span>+(<span class=\"keyword\">const</span> Test&amp; right)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">this</span>-&gt;a_ + right.a_, <span class=\"keyword\">this</span>-&gt;b_ + right.b_)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> test;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Test::PrintAB</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %d\\n\"</span>, a_, b_);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">test1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Test <span class=\"title\">test2</span><span class=\"params\">(<span class=\"number\">2</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\">    Test test = test1 + test2;</span><br><span class=\"line\">    test.PrintAB();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ++ -- </span></span><br><span class=\"line\">Test&amp; <span class=\"keyword\">operator</span>++(); <span class=\"comment\">// 前置版本</span></span><br><span class=\"line\">Test <span class=\"keyword\">operator</span>++(<span class=\"keyword\">int</span>); <span class=\"comment\">// 后置版本</span></span><br></pre></td></tr></table></figure>\n<p><strong>类成员指针</strong><br><em>数据成员指针</em> (private不能通过指针访问)<br>其值是数据成员所在地址相对于对象起始地址的偏移值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A T::*p1 = &amp;T::x</span><br><span class=\"line\"><span class=\"keyword\">int</span> A::*p1 = &amp;A::value</span><br><span class=\"line\">A a;</span><br><span class=\"line\"><span class=\"comment\">// 使用方式</span></span><br><span class=\"line\">a.*p = ......................;</span><br></pre></td></tr></table></figure>\n<p>p1指向T类中的 A类型的x数据成员<br><code>A T::</code>可以用<code>auto</code></p>\n<p><em>成员函数指针</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (A::*pf)();</span><br><span class=\"line\">pf = &amp;A::GetValue;</span><br><span class=\"line\"><span class=\"comment\">// 当然可以使用auto 来简化</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> pf2 = &amp;A::GetValue;</span><br><span class=\"line\"><span class=\"comment\">// 使用方式</span></span><br><span class=\"line\">(a.*pf)();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>统一初始化<br><code>X x1 = {0} 和 X x2 {0}</code> 这两种是不同的实现!!, 大多数情况下这两个是相通的, 然而当<br><code>explicit构造函数</code>存在的时候<code>前者的初始化是错误的</code></p>\n<p><code>int x{0} int x= 0 int x(0)</code> 最后一个是错误的可能会和函数声明冲突</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">z</span><span class=\"params\">(x)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外还存在一个</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::atomic&lt;<span class=\"keyword\">int</span>&gt; a1&#123;<span class=\"number\">0</span>&#125;; <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::atomic&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">a2</span><span class=\"params\">(<span class=\"number\">0</span>)</span></span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::atomic&lt;<span class=\"keyword\">int</span>&gt; a3 = <span class=\"number\">0</span>; <span class=\"comment\">// Error</span></span><br></pre></td></tr></table></figure>\n<p>这个错误的原因是copy-initialization引起的<br>这个copy-initialization发生在<code>T x = a</code>的声明, 下面我把原博客的部分重要英文替换成中文或代码描述<br><code>std::atomic&lt;int&gt; a3 = 0</code> 从<code>int类型</code>赋值到<code>可能是 cv-qualified</code>的<code>class type</code><br><a href=\"https://stackoverflow.com/questions/27527642/what-does-cv-qualified-mean\" target=\"_blank\" rel=\"noopener\">cv-qualified</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ***cv-qualified***</span></span><br><span class=\"line\"><span class=\"comment\">// non cv_qualified</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> first; </span><br><span class=\"line\"><span class=\"keyword\">char</span> *second; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cv-qualified </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> third; </span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">char</span> * fourth;</span><br></pre></td></tr></table></figure>\n<p><code>std::atomic&lt;int&gt; a3 = 0</code> 满足了这个条件属于<code>copy-initialization</code><br><a href=\"https://www.quora.com/What-is-the-difference-between-copy-initialization-and-direct-initialization-of-objects-in-c++\" target=\"_blank\" rel=\"noopener\">copy-initialization</a><br><a href=\"https://blog.csdn.net/ljianhui/article/details/9245661\" target=\"_blank\" rel=\"noopener\">直接初始化和复制初始化的区别</a><br>直接初始化会直接用参数生成对象, 而复制初始化会<code>用参数生成临时对象, 然后将这个对象复制到正要创建的对象</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">        A () &#123; &#125; <span class=\"comment\">//直接初始化会调用这个构造函数</span></span><br><span class=\"line\">        A (<span class=\"keyword\">const</span> A&amp; a) &#123; &#125; <span class=\"comment\">//复制初始化会调用这个</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来需要通过<code>std::atomic&lt;int&gt;(int)</code>把0转换成成一个纯右值(prvalue)的临时对象<br><a href=\"https://zh.cppreference.com/w/cpp/language/value_category\" target=\"_blank\" rel=\"noopener\">纯右值</a><br><a href=\"https://www.cnblogs.com/zpcdbky/p/5275959.html\" target=\"_blank\" rel=\"noopener\">纯右值</a><br>然后再将这个临时对象用直接初始化(调用复制构造函数), 然而<code>std::atomic&lt;int&gt;</code>把拷贝<br>构造函数给禁用了, 就会出错<br><code>std::atomic&lt;int&gt; a3 {0}</code>这个会直接调用接收int的构造函数</p>\n<p>回到<code>X x1 = {0}</code>这里, 这个表达式是一个复制构造, 用一个braced-init-list(指的{0}).<br>这里有两个阶段<br>首先是会把单个参数的构造函数汇总起来(得到A-list)供选择, 如果其中没有合适的构造函数, 再将候选列表<br>转换为所有构造函数</p>\n<p>如果如果A-list没有构造函数, 并且class T存在默认构造函数, 第一阶段就会被忽略<br>如果在一个使用<code>{}</code>的初始化, 并且选择到了<code>explicit 构造函数头上</code>就会报错</p>\n<p><code>explicit</code>可以防止在调用某个成员函数的时候, 实参类型(通过构造函数之一)自动转换成相应参数,<br>但此时这个函数需要其他的成员变量参与到函数运行, 恰巧这时所需要的其他成员变量没有得到合适的初始化, 就会发生错误(没有得到合适初始化的原因就是, 自动调用了不合适的构造函数生成了这个函数所需要的参数(一般是对象))</p>\n<p>@2019年10月26日21:25:58@算是第一次解决一个环环相扣的问题, 精力有点不足了<br><a href=\"https://zhuanlan.zhihu.com/p/21102748\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/21102748</a> 后续会继续进行理解<br><a href=\"https://blog.csdn.net/spaceyqy/article/details/22730939\" target=\"_blank\" rel=\"noopener\">这里还发现一个</a></p>\n<h1 id=\"模板-泛型-动态内存-数据结构\"><a href=\"#模板-泛型-动态内存-数据结构\" class=\"headerlink\" title=\"模板, 泛型 动态内存, 数据结构\"></a>模板, 泛型 动态内存, 数据结构</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> T&amp; <span class=\"title\">GetMax</span><span class=\"params\">(<span class=\"keyword\">const</span> T&amp; a, <span class=\"keyword\">const</span> T&amp; b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a &gt; b ? a : b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; GetMax(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; GetMax&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// 显示指定模板类型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/C%2B%2B%E5%86%85%E5%AD%98.png\" alt=\"\"><br>C++堆的内存需要手动new和delete, 如果一个对象new出来没有在能被释放的时候释放就会造成–<strong>内存泄漏</strong>(需要及时delete不需要的对象)<br>一个指向动态内存的指针, 在动态内存被释放后, 指针依然指向原来的地址–<strong>空悬指针</strong>(释放内存后将相应的指针设置为nullptr)</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png\" alt=\"\"></p>\n"},{"title":"3DMAX快捷键及基础知识","date":"2020-02-16T08:37:08.000Z","img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/3dmax%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.jpg","_content":"\n由于自己日后可能需要使用3d建模, 所以今天学习了下. 为了速成 看的B站的一个视频. 感觉效果还行吧.\n基础的建模可以完成了, 后续需要的话 再继续学习\n\n|按键|功能|\n|---|---|\n|||\n|shift|绘制直线|\n|删除键|可以回退一次|\n|||\n|W|移动|\n|E|旋转|\n|R|缩放|\n|||\n|F3|线框显示模式|\n|F4|实体+线框限时模式|\n|||\n|Shift|按住可以复制|\n|||\n|Alt+T+A|阵列|\n|Alt+T+M|镜像|\n|Alt+A+对齐|\n|Shitf+I|间隔工具|\n|||\n|Ctrl+X|专家模式, 隐藏所有多余的东西 获得最大的空间|\n|Alt+X|半透明显示|\n|Ctrl+Shift+X|变换虚拟体显示切换 可以看到变换虚拟体的明显变化|\n|O|自适应降级|\n\n**编辑样条线->顶点**\n优化 在线上添加点\n焊接 连接两点\n自动焊接 两点在距离之内自动焊接\n\n**车削修改器**\n将二维图形 指定一个轴然后旋转 得到立体图形\n\n**可编辑多边形**\n*细分曲面*\n迭代次数2-3\n无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)\n*细分置换-经常使用置换网格WSM修改器*\n需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图\n*绘制变形-未学-用于雕刻地形*\n**倒角剖面和扫描的区别**\n1. 结合点不同\n2. 倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓\n3. 倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.","source":"_posts/3DMAX-3dmax快捷键及基础知识.md","raw":"---\ntitle: 3DMAX快捷键及基础知识\ndate: 2020-02-16 16:37:08\ntags:\n  - 3DMAX\ncategories:\n  - 3DMAX\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/3dmax%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.jpg\n---\n\n由于自己日后可能需要使用3d建模, 所以今天学习了下. 为了速成 看的B站的一个视频. 感觉效果还行吧.\n基础的建模可以完成了, 后续需要的话 再继续学习\n\n|按键|功能|\n|---|---|\n|||\n|shift|绘制直线|\n|删除键|可以回退一次|\n|||\n|W|移动|\n|E|旋转|\n|R|缩放|\n|||\n|F3|线框显示模式|\n|F4|实体+线框限时模式|\n|||\n|Shift|按住可以复制|\n|||\n|Alt+T+A|阵列|\n|Alt+T+M|镜像|\n|Alt+A+对齐|\n|Shitf+I|间隔工具|\n|||\n|Ctrl+X|专家模式, 隐藏所有多余的东西 获得最大的空间|\n|Alt+X|半透明显示|\n|Ctrl+Shift+X|变换虚拟体显示切换 可以看到变换虚拟体的明显变化|\n|O|自适应降级|\n\n**编辑样条线->顶点**\n优化 在线上添加点\n焊接 连接两点\n自动焊接 两点在距离之内自动焊接\n\n**车削修改器**\n将二维图形 指定一个轴然后旋转 得到立体图形\n\n**可编辑多边形**\n*细分曲面*\n迭代次数2-3\n无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)\n*细分置换-经常使用置换网格WSM修改器*\n需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图\n*绘制变形-未学-用于雕刻地形*\n**倒角剖面和扫描的区别**\n1. 结合点不同\n2. 倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓\n3. 倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.","slug":"3DMAX-3dmax快捷键及基础知识","published":1,"updated":"2020-02-17T14:48:59.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucui00018cuo02ut25o2","content":"<p>由于自己日后可能需要使用3d建模, 所以今天学习了下. 为了速成 看的B站的一个视频. 感觉效果还行吧.<br>基础的建模可以完成了, 后续需要的话 再继续学习</p>\n<table>\n<thead>\n<tr>\n<th>按键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shift</td>\n<td>绘制直线</td>\n</tr>\n<tr>\n<td>删除键</td>\n<td>可以回退一次</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>W</td>\n<td>移动</td>\n</tr>\n<tr>\n<td>E</td>\n<td>旋转</td>\n</tr>\n<tr>\n<td>R</td>\n<td>缩放</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>F3</td>\n<td>线框显示模式</td>\n</tr>\n<tr>\n<td>F4</td>\n<td>实体+线框限时模式</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Shift</td>\n<td>按住可以复制</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Alt+T+A</td>\n<td>阵列</td>\n</tr>\n<tr>\n<td>Alt+T+M</td>\n<td>镜像</td>\n</tr>\n<tr>\n<td>Alt+A+对齐</td>\n<td></td>\n</tr>\n<tr>\n<td>Shitf+I</td>\n<td>间隔工具</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Ctrl+X</td>\n<td>专家模式, 隐藏所有多余的东西 获得最大的空间</td>\n</tr>\n<tr>\n<td>Alt+X</td>\n<td>半透明显示</td>\n</tr>\n<tr>\n<td>Ctrl+Shift+X</td>\n<td>变换虚拟体显示切换 可以看到变换虚拟体的明显变化</td>\n</tr>\n<tr>\n<td>O</td>\n<td>自适应降级</td>\n</tr>\n</tbody></table>\n<p><strong>编辑样条线-&gt;顶点</strong><br>优化 在线上添加点<br>焊接 连接两点<br>自动焊接 两点在距离之内自动焊接</p>\n<p><strong>车削修改器</strong><br>将二维图形 指定一个轴然后旋转 得到立体图形</p>\n<p><strong>可编辑多边形</strong><br><em>细分曲面</em><br>迭代次数2-3<br>无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)<br><em>细分置换-经常使用置换网格WSM修改器</em><br>需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图<br><em>绘制变形-未学-用于雕刻地形</em><br><strong>倒角剖面和扫描的区别</strong></p>\n<ol>\n<li>结合点不同</li>\n<li>倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓</li>\n<li>倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>由于自己日后可能需要使用3d建模, 所以今天学习了下. 为了速成 看的B站的一个视频. 感觉效果还行吧.<br>基础的建模可以完成了, 后续需要的话 再继续学习</p>\n<table>\n<thead>\n<tr>\n<th>按键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shift</td>\n<td>绘制直线</td>\n</tr>\n<tr>\n<td>删除键</td>\n<td>可以回退一次</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>W</td>\n<td>移动</td>\n</tr>\n<tr>\n<td>E</td>\n<td>旋转</td>\n</tr>\n<tr>\n<td>R</td>\n<td>缩放</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>F3</td>\n<td>线框显示模式</td>\n</tr>\n<tr>\n<td>F4</td>\n<td>实体+线框限时模式</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Shift</td>\n<td>按住可以复制</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Alt+T+A</td>\n<td>阵列</td>\n</tr>\n<tr>\n<td>Alt+T+M</td>\n<td>镜像</td>\n</tr>\n<tr>\n<td>Alt+A+对齐</td>\n<td></td>\n</tr>\n<tr>\n<td>Shitf+I</td>\n<td>间隔工具</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Ctrl+X</td>\n<td>专家模式, 隐藏所有多余的东西 获得最大的空间</td>\n</tr>\n<tr>\n<td>Alt+X</td>\n<td>半透明显示</td>\n</tr>\n<tr>\n<td>Ctrl+Shift+X</td>\n<td>变换虚拟体显示切换 可以看到变换虚拟体的明显变化</td>\n</tr>\n<tr>\n<td>O</td>\n<td>自适应降级</td>\n</tr>\n</tbody></table>\n<p><strong>编辑样条线-&gt;顶点</strong><br>优化 在线上添加点<br>焊接 连接两点<br>自动焊接 两点在距离之内自动焊接</p>\n<p><strong>车削修改器</strong><br>将二维图形 指定一个轴然后旋转 得到立体图形</p>\n<p><strong>可编辑多边形</strong><br><em>细分曲面</em><br>迭代次数2-3<br>无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)<br><em>细分置换-经常使用置换网格WSM修改器</em><br>需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图<br><em>绘制变形-未学-用于雕刻地形</em><br><strong>倒角剖面和扫描的区别</strong></p>\n<ol>\n<li>结合点不同</li>\n<li>倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓</li>\n<li>倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.</li>\n</ol>\n"},{"title":"循环判断中使用无符号类型","date":"2020-03-06T09:37:08.000Z","_content":"\n下面的代码 会产生错误.\n```c++\nvector<int> test;\nfor (int i = 0; i < test.size() - 1; ++i)\n{\n}\n```\n无符号类型的数值和有符号类型的数值进行运算(包括算数逻辑运算等)会将有符号类型的数值转换成无符号类型的数值.\n\n但是对于char short等小于int的数值运算的时候 会转换成int 纯正的int\n对于unsigned char在转换成int时，无论最高位是0还是1，都补0\nsigned char的则高位时1补1 0补0\n```c++\n// 0*23 1\n// 1*23 0\n// 1*24 本来是int 但被当作了 无符号int 所以输出\nunsigned int a = 1;\nint b = -2;\nif (a < b) // 逻辑运算也转换了\n{\n    cout << \"a < b\" << endl; // 输出\n}\ncout << a + b << endl; // 4294967295\n\n\n//   11111111 11111111 11111111 11111111\n//   00000000 00000000 00000000 00000010\n// 1 00000000 00000000 00000000 00000001\nunsigned int c = 2; // 0*22 1 0\nint d = -1; // 1*24\nif (c < d)\n{\n    cout << \"c < d\" << endl; // 输出\n}\ncout << c + d << endl; // 1   直接把高位的1溢出了 留下了0\n\n// 2*23 1\n// 1*23 0\n// 1*24 被转换成了int 所以输出-1\nunsigned char e = 1;\nchar f = -2;\nif (e < f)\n{\n    cout << \"e < f\" << endl; // 没有输出\n}\ncout << e + f << endl; // -1\n\nunsigned char g = 2;\nchar h = -1;\nif (g < h)\n{\n    cout << \"g < h\" << endl; // 未输出\n}\ncout << g + h << endl; // 1\n```","source":"_posts/CPP-CPP采坑-循环判断之无符号类型.md","raw":"---\ntitle: 循环判断中使用无符号类型\ndate: 2020-03-06 17:37:08\ntags:\n  - CPP踩坑记\n  - CPP\ncategories:\n  - CPP\n  - CPP踩坑\n---\n\n下面的代码 会产生错误.\n```c++\nvector<int> test;\nfor (int i = 0; i < test.size() - 1; ++i)\n{\n}\n```\n无符号类型的数值和有符号类型的数值进行运算(包括算数逻辑运算等)会将有符号类型的数值转换成无符号类型的数值.\n\n但是对于char short等小于int的数值运算的时候 会转换成int 纯正的int\n对于unsigned char在转换成int时，无论最高位是0还是1，都补0\nsigned char的则高位时1补1 0补0\n```c++\n// 0*23 1\n// 1*23 0\n// 1*24 本来是int 但被当作了 无符号int 所以输出\nunsigned int a = 1;\nint b = -2;\nif (a < b) // 逻辑运算也转换了\n{\n    cout << \"a < b\" << endl; // 输出\n}\ncout << a + b << endl; // 4294967295\n\n\n//   11111111 11111111 11111111 11111111\n//   00000000 00000000 00000000 00000010\n// 1 00000000 00000000 00000000 00000001\nunsigned int c = 2; // 0*22 1 0\nint d = -1; // 1*24\nif (c < d)\n{\n    cout << \"c < d\" << endl; // 输出\n}\ncout << c + d << endl; // 1   直接把高位的1溢出了 留下了0\n\n// 2*23 1\n// 1*23 0\n// 1*24 被转换成了int 所以输出-1\nunsigned char e = 1;\nchar f = -2;\nif (e < f)\n{\n    cout << \"e < f\" << endl; // 没有输出\n}\ncout << e + f << endl; // -1\n\nunsigned char g = 2;\nchar h = -1;\nif (g < h)\n{\n    cout << \"g < h\" << endl; // 未输出\n}\ncout << g + h << endl; // 1\n```","slug":"CPP-CPP采坑-循环判断之无符号类型","published":1,"updated":"2020-03-06T12:18:05.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucuk00038cuobsgk65yh","content":"<p>下面的代码 会产生错误.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; test;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; test.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>无符号类型的数值和有符号类型的数值进行运算(包括算数逻辑运算等)会将有符号类型的数值转换成无符号类型的数值.</p>\n<p>但是对于char short等小于int的数值运算的时候 会转换成int 纯正的int<br>对于unsigned char在转换成int时，无论最高位是0还是1，都补0<br>signed char的则高位时1补1 0补0</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 0*23 1</span></span><br><span class=\"line\"><span class=\"comment\">// 1*23 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1*24 本来是int 但被当作了 无符号int 所以输出</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">-2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a &lt; b) <span class=\"comment\">// 逻辑运算也转换了</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a &lt; b\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 4294967295</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//   11111111 11111111 11111111 11111111</span></span><br><span class=\"line\"><span class=\"comment\">//   00000000 00000000 00000000 00000010</span></span><br><span class=\"line\"><span class=\"comment\">// 1 00000000 00000000 00000000 00000001</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> c = <span class=\"number\">2</span>; <span class=\"comment\">// 0*22 1 0</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> d = <span class=\"number\">-1</span>; <span class=\"comment\">// 1*24</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (c &lt; d)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"c &lt; d\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; c + d &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1   直接把高位的1溢出了 留下了0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2*23 1</span></span><br><span class=\"line\"><span class=\"comment\">// 1*23 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1*24 被转换成了int 所以输出-1</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> e = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> f = <span class=\"number\">-2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (e &lt; f)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"e &lt; f\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 没有输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; e + f &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> g = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> h = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (g &lt; h)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"g &lt; h\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 未输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; g + h &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>下面的代码 会产生错误.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; test;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; test.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; ++i)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>无符号类型的数值和有符号类型的数值进行运算(包括算数逻辑运算等)会将有符号类型的数值转换成无符号类型的数值.</p>\n<p>但是对于char short等小于int的数值运算的时候 会转换成int 纯正的int<br>对于unsigned char在转换成int时，无论最高位是0还是1，都补0<br>signed char的则高位时1补1 0补0</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 0*23 1</span></span><br><span class=\"line\"><span class=\"comment\">// 1*23 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1*24 本来是int 但被当作了 无符号int 所以输出</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">-2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a &lt; b) <span class=\"comment\">// 逻辑运算也转换了</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"a &lt; b\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; a + b &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 4294967295</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//   11111111 11111111 11111111 11111111</span></span><br><span class=\"line\"><span class=\"comment\">//   00000000 00000000 00000000 00000010</span></span><br><span class=\"line\"><span class=\"comment\">// 1 00000000 00000000 00000000 00000001</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> c = <span class=\"number\">2</span>; <span class=\"comment\">// 0*22 1 0</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> d = <span class=\"number\">-1</span>; <span class=\"comment\">// 1*24</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (c &lt; d)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"c &lt; d\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; c + d &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1   直接把高位的1溢出了 留下了0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2*23 1</span></span><br><span class=\"line\"><span class=\"comment\">// 1*23 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1*24 被转换成了int 所以输出-1</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> e = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> f = <span class=\"number\">-2</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (e &lt; f)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"e &lt; f\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 没有输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; e + f &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// -1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> g = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> h = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (g &lt; h)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"g &lt; h\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 未输出</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; g + h &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>"},{"title":"指针","date":"2019-11-07T14:26:22.000Z","_content":"\n指针的话, 自己是要学会自己去理解各种组合. 首先只要定义复杂指针肯定会涉及到运算符优先级\n根据运算符优先级判断这个定义的含义\n\n# 指针的定义识别\n## 由运算符优先级判断\n下面列出常见到的运算符\n\n`[]`中括号这个的优先级最高, 跟括号并列.(排除域运算符).\n\t从左到右的结合性 -意味着`p[]`中`[]`会先跟`p结合`而不是中括号右边的内容\n`()`与之结合成为函数\n\t从左到右的结合性\n`*`其次是这个符号\n\t从右到左的结合性\n\n两个大头\n`int *p[3]`和`int (*p)[3]`\n前者由于`[]`的优先级更高p与之结合说明p是**数组***得到p本质是什么 数组OR指针*\n再与`*`结合说明**数组中的元素**是**指针***第二次结合 如果第一次是数组-则为数组中的内容, 第一次是指针-则为指针的指向*\n再与int结合 说明数组中**指针指向**的是int\n\n后者`*`先与p结合说明p是一个**指针**\n再与`[]`结合说明**指针指向**的内容是**数组**\n再与int结合说明**数组中的内容**是int\n\n---\n本质上定义函数相关的也可以这样理解\n`int p(int)`和`int (*p)(int)`\n前者p先与`()`结合说明p是一个**函数**\n在**查看括号中的内容**说明有int的参数\n最后与左侧int结合说明返回类型\n\n后者p先与`*`结合说明p是一个**指针**\n与`()`结合说明**指针指向**的是**函数**\n在**查看括号中的内容**说明有int的参数\n最后与左侧int结合说明返回类型\n\n## 判断指针的类型\n去除指针声明语句中的指针名称, 剩下的部分就是指针的类型.\n`int* p`得到`int*`, 说明指针的类型是`int*`\n`int (*p)[3]` 说明指针的类型是`int (*)[3]`\n\n## 指针指向的类型\n去除指针声明语句中的指针名称, 以及名称左边的指针声明符*, 剩下的部分是指针指向的类型\n`int* p`得到`int`说明指针指向的类型就是`int`\n`int (*p)[3]`得到`int()[3]`说明指针指向的类型就是`int()[3]`\n\n## 指针的值\n指针存储的即为指向一个内存区域的地址值\n","source":"_posts/CPP-CPP基础-指针.md","raw":"---\ntitle: 指针\ntags:\n  - null\ncategories:\n  - CPP\n  - CPP基础\ndate: 2019-11-07 22:26:22\n---\n\n指针的话, 自己是要学会自己去理解各种组合. 首先只要定义复杂指针肯定会涉及到运算符优先级\n根据运算符优先级判断这个定义的含义\n\n# 指针的定义识别\n## 由运算符优先级判断\n下面列出常见到的运算符\n\n`[]`中括号这个的优先级最高, 跟括号并列.(排除域运算符).\n\t从左到右的结合性 -意味着`p[]`中`[]`会先跟`p结合`而不是中括号右边的内容\n`()`与之结合成为函数\n\t从左到右的结合性\n`*`其次是这个符号\n\t从右到左的结合性\n\n两个大头\n`int *p[3]`和`int (*p)[3]`\n前者由于`[]`的优先级更高p与之结合说明p是**数组***得到p本质是什么 数组OR指针*\n再与`*`结合说明**数组中的元素**是**指针***第二次结合 如果第一次是数组-则为数组中的内容, 第一次是指针-则为指针的指向*\n再与int结合 说明数组中**指针指向**的是int\n\n后者`*`先与p结合说明p是一个**指针**\n再与`[]`结合说明**指针指向**的内容是**数组**\n再与int结合说明**数组中的内容**是int\n\n---\n本质上定义函数相关的也可以这样理解\n`int p(int)`和`int (*p)(int)`\n前者p先与`()`结合说明p是一个**函数**\n在**查看括号中的内容**说明有int的参数\n最后与左侧int结合说明返回类型\n\n后者p先与`*`结合说明p是一个**指针**\n与`()`结合说明**指针指向**的是**函数**\n在**查看括号中的内容**说明有int的参数\n最后与左侧int结合说明返回类型\n\n## 判断指针的类型\n去除指针声明语句中的指针名称, 剩下的部分就是指针的类型.\n`int* p`得到`int*`, 说明指针的类型是`int*`\n`int (*p)[3]` 说明指针的类型是`int (*)[3]`\n\n## 指针指向的类型\n去除指针声明语句中的指针名称, 以及名称左边的指针声明符*, 剩下的部分是指针指向的类型\n`int* p`得到`int`说明指针指向的类型就是`int`\n`int (*p)[3]`得到`int()[3]`说明指针指向的类型就是`int()[3]`\n\n## 指针的值\n指针存储的即为指向一个内存区域的地址值\n","slug":"CPP-CPP基础-指针","published":1,"updated":"2020-01-23T11:35:12.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucul00058cuo4u6qbbla","content":"<p>指针的话, 自己是要学会自己去理解各种组合. 首先只要定义复杂指针肯定会涉及到运算符优先级<br>根据运算符优先级判断这个定义的含义</p>\n<h1 id=\"指针的定义识别\"><a href=\"#指针的定义识别\" class=\"headerlink\" title=\"指针的定义识别\"></a>指针的定义识别</h1><h2 id=\"由运算符优先级判断\"><a href=\"#由运算符优先级判断\" class=\"headerlink\" title=\"由运算符优先级判断\"></a>由运算符优先级判断</h2><p>下面列出常见到的运算符</p>\n<p><code>[]</code>中括号这个的优先级最高, 跟括号并列.(排除域运算符).<br>    从左到右的结合性 -意味着<code>p[]</code>中<code>[]</code>会先跟<code>p结合</code>而不是中括号右边的内容<br><code>()</code>与之结合成为函数<br>    从左到右的结合性<br><code>*</code>其次是这个符号<br>    从右到左的结合性</p>\n<p>两个大头<br><code>int *p[3]</code>和<code>int (*p)[3]</code><br>前者由于<code>[]</code>的优先级更高p与之结合说明p是<strong>数组*</strong>得到p本质是什么 数组OR指针*<br>再与<code>*</code>结合说明<strong>数组中的元素</strong>是<strong>指针*</strong>第二次结合 如果第一次是数组-则为数组中的内容, 第一次是指针-则为指针的指向*<br>再与int结合 说明数组中<strong>指针指向</strong>的是int</p>\n<p>后者<code>*</code>先与p结合说明p是一个<strong>指针</strong><br>再与<code>[]</code>结合说明<strong>指针指向</strong>的内容是<strong>数组</strong><br>再与int结合说明<strong>数组中的内容</strong>是int</p>\n<hr>\n<p>本质上定义函数相关的也可以这样理解<br><code>int p(int)</code>和<code>int (*p)(int)</code><br>前者p先与<code>()</code>结合说明p是一个<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p>\n<p>后者p先与<code>*</code>结合说明p是一个<strong>指针</strong><br>与<code>()</code>结合说明<strong>指针指向</strong>的是<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p>\n<h2 id=\"判断指针的类型\"><a href=\"#判断指针的类型\" class=\"headerlink\" title=\"判断指针的类型\"></a>判断指针的类型</h2><p>去除指针声明语句中的指针名称, 剩下的部分就是指针的类型.<br><code>int* p</code>得到<code>int*</code>, 说明指针的类型是<code>int*</code><br><code>int (*p)[3]</code> 说明指针的类型是<code>int (*)[3]</code></p>\n<h2 id=\"指针指向的类型\"><a href=\"#指针指向的类型\" class=\"headerlink\" title=\"指针指向的类型\"></a>指针指向的类型</h2><p>去除指针声明语句中的指针名称, 以及名称左边的指针声明符<em>, 剩下的部分是指针指向的类型<br>`int</em> p<code>得到</code>int<code>说明指针指向的类型就是</code>int<code></code>int (*p)[3]<code>得到</code>int()[3]<code>说明指针指向的类型就是</code>int()[3]`</p>\n<h2 id=\"指针的值\"><a href=\"#指针的值\" class=\"headerlink\" title=\"指针的值\"></a>指针的值</h2><p>指针存储的即为指向一个内存区域的地址值</p>\n","site":{"data":{}},"excerpt":"","more":"<p>指针的话, 自己是要学会自己去理解各种组合. 首先只要定义复杂指针肯定会涉及到运算符优先级<br>根据运算符优先级判断这个定义的含义</p>\n<h1 id=\"指针的定义识别\"><a href=\"#指针的定义识别\" class=\"headerlink\" title=\"指针的定义识别\"></a>指针的定义识别</h1><h2 id=\"由运算符优先级判断\"><a href=\"#由运算符优先级判断\" class=\"headerlink\" title=\"由运算符优先级判断\"></a>由运算符优先级判断</h2><p>下面列出常见到的运算符</p>\n<p><code>[]</code>中括号这个的优先级最高, 跟括号并列.(排除域运算符).<br>    从左到右的结合性 -意味着<code>p[]</code>中<code>[]</code>会先跟<code>p结合</code>而不是中括号右边的内容<br><code>()</code>与之结合成为函数<br>    从左到右的结合性<br><code>*</code>其次是这个符号<br>    从右到左的结合性</p>\n<p>两个大头<br><code>int *p[3]</code>和<code>int (*p)[3]</code><br>前者由于<code>[]</code>的优先级更高p与之结合说明p是<strong>数组*</strong>得到p本质是什么 数组OR指针*<br>再与<code>*</code>结合说明<strong>数组中的元素</strong>是<strong>指针*</strong>第二次结合 如果第一次是数组-则为数组中的内容, 第一次是指针-则为指针的指向*<br>再与int结合 说明数组中<strong>指针指向</strong>的是int</p>\n<p>后者<code>*</code>先与p结合说明p是一个<strong>指针</strong><br>再与<code>[]</code>结合说明<strong>指针指向</strong>的内容是<strong>数组</strong><br>再与int结合说明<strong>数组中的内容</strong>是int</p>\n<hr>\n<p>本质上定义函数相关的也可以这样理解<br><code>int p(int)</code>和<code>int (*p)(int)</code><br>前者p先与<code>()</code>结合说明p是一个<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p>\n<p>后者p先与<code>*</code>结合说明p是一个<strong>指针</strong><br>与<code>()</code>结合说明<strong>指针指向</strong>的是<strong>函数</strong><br>在<strong>查看括号中的内容</strong>说明有int的参数<br>最后与左侧int结合说明返回类型</p>\n<h2 id=\"判断指针的类型\"><a href=\"#判断指针的类型\" class=\"headerlink\" title=\"判断指针的类型\"></a>判断指针的类型</h2><p>去除指针声明语句中的指针名称, 剩下的部分就是指针的类型.<br><code>int* p</code>得到<code>int*</code>, 说明指针的类型是<code>int*</code><br><code>int (*p)[3]</code> 说明指针的类型是<code>int (*)[3]</code></p>\n<h2 id=\"指针指向的类型\"><a href=\"#指针指向的类型\" class=\"headerlink\" title=\"指针指向的类型\"></a>指针指向的类型</h2><p>去除指针声明语句中的指针名称, 以及名称左边的指针声明符<em>, 剩下的部分是指针指向的类型<br>`int</em> p<code>得到</code>int<code>说明指针指向的类型就是</code>int<code></code>int (*p)[3]<code>得到</code>int()[3]<code>说明指针指向的类型就是</code>int()[3]`</p>\n<h2 id=\"指针的值\"><a href=\"#指针的值\" class=\"headerlink\" title=\"指针的值\"></a>指针的值</h2><p>指针存储的即为指向一个内存区域的地址值</p>\n"},{"title":"牛客整理","date":"2019-10-19T04:31:37.000Z","_content":"\n# 运算出结果类\n```c++\nchar a=101;\nint sum=200;\na+=27;sum+=a;\nprintf(\"%d\\n\",sum);\n```\na为 -128~127 \n 127  = 0111 1111\n\"128\"= 1000 0000 (-128的补码)\n\n关于1000 0000代表-128 我偶然发现一个博客有种恍然大悟的感觉\n[浅析为什么char类型的范围是 —128~+127](https://blog.csdn.net/daiyutage/article/details/8575248)\n这个博客实在是写的太好了\n\n---\n```c++\nchar a,b,c,d;\nscanf(\"%c,%c,%d,%d\",&a,&b,&c,&d);\nprintf(\"%c,%c,%c,%c\",a,b,c,d);\n}\n```\n%c进行输入会进行转化后存入\n输入 1 即认为输入 '1' 转换成49存入\n\n---\n\n# 类相关\n## 虚函数\n纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。\n凡是含有纯虚函数的类叫做 抽象类 。这种类不能声明对象，只是作为基类为派生类服务.\n除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。\n\n## 静态\n静态成员可以作为默认实参\n\n# 定义类\n\n# 基础中的基础\n这部分有些只保留题目, 不做解析 便于自己想象\n```c++\nunsigned int k = 20;\nwhile (k >= 0)\n{\n\t--k;\n}\n```\n\n下面三个函数全部错误\n```\nvoid test1()\n{\n    unsigned char array[MAX_CHAR+1],i; // 这个函数在于MAX_CHAR可能会大于255导致i永远无法达到\n    for(i=0;i<=MAX_CHAR;i++){\n        array[i]=i;\n    }\n}\nchar*test2()\n{\n    char p[] = \"hello world\";\n    return p;\n}\nchar *p =test2();\nvoid test3(){\n    char str[10];\n    str++;\n    *str='0';\n}\n```\n---\n\n# 基础中的Api\n虽然自己还没用过, 但还是要积累\n```c++\nfor(i=4;i>1;i--)\n{\n\tfor(j=1;j<i;j++)\n\t{\n\t\tputchar('#');\n\t}\n}\n```\n开始看到这个题目, 为putchar是放到缓冲区中, 结果就是正常的输出\n","source":"_posts/CPP-CPP基础-牛客.md","raw":"---\ntitle: 牛客整理\ntags:\n  - null\ncategories:\n  - CPP\n  - CPP基础\ndate: 2019-10-19 12:31:37\n---\n\n# 运算出结果类\n```c++\nchar a=101;\nint sum=200;\na+=27;sum+=a;\nprintf(\"%d\\n\",sum);\n```\na为 -128~127 \n 127  = 0111 1111\n\"128\"= 1000 0000 (-128的补码)\n\n关于1000 0000代表-128 我偶然发现一个博客有种恍然大悟的感觉\n[浅析为什么char类型的范围是 —128~+127](https://blog.csdn.net/daiyutage/article/details/8575248)\n这个博客实在是写的太好了\n\n---\n```c++\nchar a,b,c,d;\nscanf(\"%c,%c,%d,%d\",&a,&b,&c,&d);\nprintf(\"%c,%c,%c,%c\",a,b,c,d);\n}\n```\n%c进行输入会进行转化后存入\n输入 1 即认为输入 '1' 转换成49存入\n\n---\n\n# 类相关\n## 虚函数\n纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。\n凡是含有纯虚函数的类叫做 抽象类 。这种类不能声明对象，只是作为基类为派生类服务.\n除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。\n\n## 静态\n静态成员可以作为默认实参\n\n# 定义类\n\n# 基础中的基础\n这部分有些只保留题目, 不做解析 便于自己想象\n```c++\nunsigned int k = 20;\nwhile (k >= 0)\n{\n\t--k;\n}\n```\n\n下面三个函数全部错误\n```\nvoid test1()\n{\n    unsigned char array[MAX_CHAR+1],i; // 这个函数在于MAX_CHAR可能会大于255导致i永远无法达到\n    for(i=0;i<=MAX_CHAR;i++){\n        array[i]=i;\n    }\n}\nchar*test2()\n{\n    char p[] = \"hello world\";\n    return p;\n}\nchar *p =test2();\nvoid test3(){\n    char str[10];\n    str++;\n    *str='0';\n}\n```\n---\n\n# 基础中的Api\n虽然自己还没用过, 但还是要积累\n```c++\nfor(i=4;i>1;i--)\n{\n\tfor(j=1;j<i;j++)\n\t{\n\t\tputchar('#');\n\t}\n}\n```\n开始看到这个题目, 为putchar是放到缓冲区中, 结果就是正常的输出\n","slug":"CPP-CPP基础-牛客","published":1,"updated":"2020-01-23T11:35:08.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucum00068cuodc45f0mp","content":"<h1 id=\"运算出结果类\"><a href=\"#运算出结果类\" class=\"headerlink\" title=\"运算出结果类\"></a>运算出结果类</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a=<span class=\"number\">101</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum=<span class=\"number\">200</span>;</span><br><span class=\"line\">a+=<span class=\"number\">27</span>;sum+=a;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,sum);</span><br></pre></td></tr></table></figure>\n<p>a为 -128~127<br> 127  = 0111 1111<br>“128”= 1000 0000 (-128的补码)</p>\n<p>关于1000 0000代表-128 我偶然发现一个博客有种恍然大悟的感觉<br><a href=\"https://blog.csdn.net/daiyutage/article/details/8575248\" target=\"_blank\" rel=\"noopener\">浅析为什么char类型的范围是 —128~+127</a><br>这个博客实在是写的太好了</p>\n<hr>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a,b,c,d;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c,%c,%d,%d\"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%c,%c,%c,%c\"</span>,a,b,c,d);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>%c进行输入会进行转化后存入<br>输入 1 即认为输入 ‘1’ 转换成49存入</p>\n<hr>\n<h1 id=\"类相关\"><a href=\"#类相关\" class=\"headerlink\" title=\"类相关\"></a>类相关</h1><h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。<br>凡是含有纯虚函数的类叫做 抽象类 。这种类不能声明对象，只是作为基类为派生类服务.<br>除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</p>\n<h2 id=\"静态\"><a href=\"#静态\" class=\"headerlink\" title=\"静态\"></a>静态</h2><p>静态成员可以作为默认实参</p>\n<h1 id=\"定义类\"><a href=\"#定义类\" class=\"headerlink\" title=\"定义类\"></a>定义类</h1><h1 id=\"基础中的基础\"><a href=\"#基础中的基础\" class=\"headerlink\" title=\"基础中的基础\"></a>基础中的基础</h1><p>这部分有些只保留题目, 不做解析 便于自己想象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> k = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (k &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t--k;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面三个函数全部错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test1()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned char array[MAX_CHAR+1],i; &#x2F;&#x2F; 这个函数在于MAX_CHAR可能会大于255导致i永远无法达到</span><br><span class=\"line\">    for(i&#x3D;0;i&lt;&#x3D;MAX_CHAR;i++)&#123;</span><br><span class=\"line\">        array[i]&#x3D;i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">char*test2()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char p[] &#x3D; &quot;hello world&quot;;</span><br><span class=\"line\">    return p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">char *p &#x3D;test2();</span><br><span class=\"line\">void test3()&#123;</span><br><span class=\"line\">    char str[10];</span><br><span class=\"line\">    str++;</span><br><span class=\"line\">    *str&#x3D;&#39;0&#39;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"基础中的Api\"><a href=\"#基础中的Api\" class=\"headerlink\" title=\"基础中的Api\"></a>基础中的Api</h1><p>虽然自己还没用过, 但还是要积累</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">4</span>;i&gt;<span class=\"number\">1</span>;i--)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(j=<span class=\"number\">1</span>;j&lt;i;j++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">putchar</span>(<span class=\"string\">'#'</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>开始看到这个题目, 为putchar是放到缓冲区中, 结果就是正常的输出</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"运算出结果类\"><a href=\"#运算出结果类\" class=\"headerlink\" title=\"运算出结果类\"></a>运算出结果类</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a=<span class=\"number\">101</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum=<span class=\"number\">200</span>;</span><br><span class=\"line\">a+=<span class=\"number\">27</span>;sum+=a;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>,sum);</span><br></pre></td></tr></table></figure>\n<p>a为 -128~127<br> 127  = 0111 1111<br>“128”= 1000 0000 (-128的补码)</p>\n<p>关于1000 0000代表-128 我偶然发现一个博客有种恍然大悟的感觉<br><a href=\"https://blog.csdn.net/daiyutage/article/details/8575248\" target=\"_blank\" rel=\"noopener\">浅析为什么char类型的范围是 —128~+127</a><br>这个博客实在是写的太好了</p>\n<hr>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a,b,c,d;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">\"%c,%c,%d,%d\"</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%c,%c,%c,%c\"</span>,a,b,c,d);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>%c进行输入会进行转化后存入<br>输入 1 即认为输入 ‘1’ 转换成49存入</p>\n<hr>\n<h1 id=\"类相关\"><a href=\"#类相关\" class=\"headerlink\" title=\"类相关\"></a>类相关</h1><h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。<br>凡是含有纯虚函数的类叫做 抽象类 。这种类不能声明对象，只是作为基类为派生类服务.<br>除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。</p>\n<h2 id=\"静态\"><a href=\"#静态\" class=\"headerlink\" title=\"静态\"></a>静态</h2><p>静态成员可以作为默认实参</p>\n<h1 id=\"定义类\"><a href=\"#定义类\" class=\"headerlink\" title=\"定义类\"></a>定义类</h1><h1 id=\"基础中的基础\"><a href=\"#基础中的基础\" class=\"headerlink\" title=\"基础中的基础\"></a>基础中的基础</h1><p>这部分有些只保留题目, 不做解析 便于自己想象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> k = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (k &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t--k;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面三个函数全部错误</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void test1()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned char array[MAX_CHAR+1],i; &#x2F;&#x2F; 这个函数在于MAX_CHAR可能会大于255导致i永远无法达到</span><br><span class=\"line\">    for(i&#x3D;0;i&lt;&#x3D;MAX_CHAR;i++)&#123;</span><br><span class=\"line\">        array[i]&#x3D;i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">char*test2()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char p[] &#x3D; &quot;hello world&quot;;</span><br><span class=\"line\">    return p;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">char *p &#x3D;test2();</span><br><span class=\"line\">void test3()&#123;</span><br><span class=\"line\">    char str[10];</span><br><span class=\"line\">    str++;</span><br><span class=\"line\">    *str&#x3D;&#39;0&#39;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h1 id=\"基础中的Api\"><a href=\"#基础中的Api\" class=\"headerlink\" title=\"基础中的Api\"></a>基础中的Api</h1><p>虽然自己还没用过, 但还是要积累</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">4</span>;i&gt;<span class=\"number\">1</span>;i--)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(j=<span class=\"number\">1</span>;j&lt;i;j++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">putchar</span>(<span class=\"string\">'#'</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>开始看到这个题目, 为putchar是放到缓冲区中, 结果就是正常的输出</p>\n"},{"title":"CPP11特性","date":"2020-02-19T09:41:27.000Z","_content":"# Lambda\n参考资料\nhttps://zh.cppreference.com/w/cpp/language/lambda\nhttps://blog.csdn.net/qq_34199383/article/details/80469780\n\n```c++\n[ 捕获 ] ( 形参 ) -> ret { 函数体 }\n[ 捕获 ] ( 形参 ) { 函数体 }\n[ 捕获 ] { 函数体 }\n\n& 以引用隐式捕获被使用的自动变量\n= 以复制隐式捕获被使用的自动变量\n\n[&]{};          // OK：默认以引用捕获\n[&, i]{};       // OK：以引用捕获，但 i 以值捕获\n\n[=]{};          // OK：默认以复制捕获\n[=, &i]{};      // OK：以复制捕获，但 i 以引用捕获\n\n[this]{}; // 获取this指针, 如果使用了&和=则会默认包括this\n```\n**使用场景一**\n以sort为代表的函数 需要传入函数的函数\n```c++\n// 原版\nbool compare(int &a, int &b)\n{\n\treturn a > b;\n}\n\nxxx(compare);\n\n// 新版\nxxx([](int a, int b){return a > b;});\n```\n**使用场景二**\n```c++\nauto add = [](int a, int b){return a + b;};\nint bar = add(1, 2);\n```\n\n# 类型特性\nhttps://zh.cppreference.com/w/cpp/types#.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29\n\n神仙的头文件<type_traits> 可以判断一个值是否是某个类型\n\n比如判断一个值\n是不是 整形\n是不是 void\n是不是 数组 等等\n\n目前不知道用在什么地方合适..... 留个连接备用吧\n\n# 花括号初始\n\n# 函数对象\n## std::function  functional\n```c++\n#include <functional>\n#include <iostream>\n\nvoid PrintA()\n{\n    std::cout << \"A\" << std::endl;\n}\nvoid PrintB(int bar)\n{\n    std::cout << \"B\" << std::endl;\n}\nint main()\n{\n    std::function<void()> FPrintA = PrintA;\n    FPrintA();\n\n    std::function<void(int)> FPrintB = PrintB;\n    FPrintB(1);\n\n// 感觉配合Lambad 挺不错, 在一个函数中经常使用的功能可以这样定义\n    std::function<void()> FLambad = [](){std::cout << \"Lambad\" << std::endl;};\n    FLambad();\n\t\n\t// 不过使用auto貌似更简单\n\tauto ALambad = [](){std::cout << \"Lambad\" << std::endl;};\n    ALambad();\n}\n\n$ A\n$ B\n$ Lambad\n```\n\n## std::bind std::ref std::cref\n今天在学习\nhttps://github.com/baloonwj/flamingo\n的时候, 从中发现的这个函数. 这个函数跟std::function 一起使用.\n竟然实现了回调函数调用类的成员函数!!!!\n\nhttps://zh.cppreference.com/w/cpp/utility/functional/bind\n\n```c++\n#include <functional>\n#include <cstdio>\n\nvoid f(int n1, int n2, int n3, int n4)\n{\n    printf(\"f function-->n1: %d, n2: %d, n3: %d, n4: %d\\n\", n1, n2, n3, n4);\n}\n\nvoid ff(int &n1, int& n2, const int& n3)\n{\n    printf(\"before ff function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n    n1 = 11;\n    n2 = 22;\n    // n3 = 33; 编译错误\n    printf(\"after ff function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n}\n\nint main()\n{\n    auto f1 = std::bind(f, std::placeholders::_2, std::placeholders::_3, 666, std::placeholders::_1);\n\n    f1(1, 2, 3, 4, 5);\n    // infunction-->n1: 2, n2: 3, n3: 666, n4: 1\n    // 1 绑定_1  2绑定_2  3绑定_3   // 4 5被忽略\n    // 按照 f1的顺序传入参数\n    // 所以调用为 f(2, 3, 666, 1);\n\n    int n1 = 1, n2 = 2, n3 = 3;\n    auto ff1 = std::bind(ff, n1, std::ref(n2), std::cref(n3));\n    n1 = -1;\n    n2 = -2;\n    n3 = -3;\n    printf(\"before ff1 function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n    ff1(n1, n2, n3);\n    printf(\"after ff1 function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n    // before ff1 function-->n1: -1, n2: -2, n3: -3\n    // before ff function-- > n1: 1, n2 : -2, n3 : -3 // 这里说明了值传递 参数是绑定时就决定好了 引用参数还是可以改变的\n    // after ff function-- > n1: 11, n2 : 22, n3 : -3\n    // after ff1 function-- > n1: -1, n2 : 22, n3 : -3 // 引用传入成功改变, 值传入和const引用传入未变\n\n    // std::ref 按引用传入参数 std::cref按const引用传入参数\n}\n```\n\n\n\n## std::pair utility std::tuple tuple\n\nhttps://zh.cppreference.com/w/cpp/utility/tuple\n\npair是 结构体模板, 可在一个单元中存储两个相异对象. pair是tuple拥有两个元素的特殊情况\n\ntuple是固定大小的异类值(啥是异类值??)汇集\n```c++\nstd::tuple<int, double > GetInfoById(int id)\n{\n    if (id == 0) return std::make_tuple(1, 1.1);\n    if (id == 1) return std::make_tuple(2, 2.2);\n\n    throw std::invalid_argument(\"id\");\n}\n\nint main()\n{\n    auto info = GetInfoById(0);\n\t// 获取指定位置\n    std::cout << \"1:\" << std::get<0>(info)\n            << \" 2:\" << std::get<1>(info) << std::endl;\n\n    int val1;\n    double val2;\n\t// 直接创建引用的tuple\n    std::tie(val1, val2) = GetInfoById(1);\n    std::cout << \"1:\" << val1\n              << \" 2:\" << val2 << std::endl;\n\t\t\t  \n$ 1:1 2:1.1\n$ 1:2 2:2.2\n}\n```","source":"_posts/CPP-CPP重点-CPP11特性.md","raw":"---\ntitle: CPP11特性\ndate: 2020-02-19 17:41:27\ntags:\ncategories:\n - CPP\n - CPP重点\n---\n# Lambda\n参考资料\nhttps://zh.cppreference.com/w/cpp/language/lambda\nhttps://blog.csdn.net/qq_34199383/article/details/80469780\n\n```c++\n[ 捕获 ] ( 形参 ) -> ret { 函数体 }\n[ 捕获 ] ( 形参 ) { 函数体 }\n[ 捕获 ] { 函数体 }\n\n& 以引用隐式捕获被使用的自动变量\n= 以复制隐式捕获被使用的自动变量\n\n[&]{};          // OK：默认以引用捕获\n[&, i]{};       // OK：以引用捕获，但 i 以值捕获\n\n[=]{};          // OK：默认以复制捕获\n[=, &i]{};      // OK：以复制捕获，但 i 以引用捕获\n\n[this]{}; // 获取this指针, 如果使用了&和=则会默认包括this\n```\n**使用场景一**\n以sort为代表的函数 需要传入函数的函数\n```c++\n// 原版\nbool compare(int &a, int &b)\n{\n\treturn a > b;\n}\n\nxxx(compare);\n\n// 新版\nxxx([](int a, int b){return a > b;});\n```\n**使用场景二**\n```c++\nauto add = [](int a, int b){return a + b;};\nint bar = add(1, 2);\n```\n\n# 类型特性\nhttps://zh.cppreference.com/w/cpp/types#.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29\n\n神仙的头文件<type_traits> 可以判断一个值是否是某个类型\n\n比如判断一个值\n是不是 整形\n是不是 void\n是不是 数组 等等\n\n目前不知道用在什么地方合适..... 留个连接备用吧\n\n# 花括号初始\n\n# 函数对象\n## std::function  functional\n```c++\n#include <functional>\n#include <iostream>\n\nvoid PrintA()\n{\n    std::cout << \"A\" << std::endl;\n}\nvoid PrintB(int bar)\n{\n    std::cout << \"B\" << std::endl;\n}\nint main()\n{\n    std::function<void()> FPrintA = PrintA;\n    FPrintA();\n\n    std::function<void(int)> FPrintB = PrintB;\n    FPrintB(1);\n\n// 感觉配合Lambad 挺不错, 在一个函数中经常使用的功能可以这样定义\n    std::function<void()> FLambad = [](){std::cout << \"Lambad\" << std::endl;};\n    FLambad();\n\t\n\t// 不过使用auto貌似更简单\n\tauto ALambad = [](){std::cout << \"Lambad\" << std::endl;};\n    ALambad();\n}\n\n$ A\n$ B\n$ Lambad\n```\n\n## std::bind std::ref std::cref\n今天在学习\nhttps://github.com/baloonwj/flamingo\n的时候, 从中发现的这个函数. 这个函数跟std::function 一起使用.\n竟然实现了回调函数调用类的成员函数!!!!\n\nhttps://zh.cppreference.com/w/cpp/utility/functional/bind\n\n```c++\n#include <functional>\n#include <cstdio>\n\nvoid f(int n1, int n2, int n3, int n4)\n{\n    printf(\"f function-->n1: %d, n2: %d, n3: %d, n4: %d\\n\", n1, n2, n3, n4);\n}\n\nvoid ff(int &n1, int& n2, const int& n3)\n{\n    printf(\"before ff function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n    n1 = 11;\n    n2 = 22;\n    // n3 = 33; 编译错误\n    printf(\"after ff function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n}\n\nint main()\n{\n    auto f1 = std::bind(f, std::placeholders::_2, std::placeholders::_3, 666, std::placeholders::_1);\n\n    f1(1, 2, 3, 4, 5);\n    // infunction-->n1: 2, n2: 3, n3: 666, n4: 1\n    // 1 绑定_1  2绑定_2  3绑定_3   // 4 5被忽略\n    // 按照 f1的顺序传入参数\n    // 所以调用为 f(2, 3, 666, 1);\n\n    int n1 = 1, n2 = 2, n3 = 3;\n    auto ff1 = std::bind(ff, n1, std::ref(n2), std::cref(n3));\n    n1 = -1;\n    n2 = -2;\n    n3 = -3;\n    printf(\"before ff1 function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n    ff1(n1, n2, n3);\n    printf(\"after ff1 function-->n1: %d, n2: %d, n3: %d\\n\", n1, n2, n3);\n    // before ff1 function-->n1: -1, n2: -2, n3: -3\n    // before ff function-- > n1: 1, n2 : -2, n3 : -3 // 这里说明了值传递 参数是绑定时就决定好了 引用参数还是可以改变的\n    // after ff function-- > n1: 11, n2 : 22, n3 : -3\n    // after ff1 function-- > n1: -1, n2 : 22, n3 : -3 // 引用传入成功改变, 值传入和const引用传入未变\n\n    // std::ref 按引用传入参数 std::cref按const引用传入参数\n}\n```\n\n\n\n## std::pair utility std::tuple tuple\n\nhttps://zh.cppreference.com/w/cpp/utility/tuple\n\npair是 结构体模板, 可在一个单元中存储两个相异对象. pair是tuple拥有两个元素的特殊情况\n\ntuple是固定大小的异类值(啥是异类值??)汇集\n```c++\nstd::tuple<int, double > GetInfoById(int id)\n{\n    if (id == 0) return std::make_tuple(1, 1.1);\n    if (id == 1) return std::make_tuple(2, 2.2);\n\n    throw std::invalid_argument(\"id\");\n}\n\nint main()\n{\n    auto info = GetInfoById(0);\n\t// 获取指定位置\n    std::cout << \"1:\" << std::get<0>(info)\n            << \" 2:\" << std::get<1>(info) << std::endl;\n\n    int val1;\n    double val2;\n\t// 直接创建引用的tuple\n    std::tie(val1, val2) = GetInfoById(1);\n    std::cout << \"1:\" << val1\n              << \" 2:\" << val2 << std::endl;\n\t\t\t  \n$ 1:1 2:1.1\n$ 1:2 2:2.2\n}\n```","slug":"CPP-CPP重点-CPP11特性","published":1,"updated":"2020-03-20T11:49:55.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucun00088cuo7xmu9zv1","content":"<h1 id=\"Lambda\"><a href=\"#Lambda\" class=\"headerlink\" title=\"Lambda\"></a>Lambda</h1><p>参考资料<br><a href=\"https://zh.cppreference.com/w/cpp/language/lambda\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/language/lambda</a><br><a href=\"https://blog.csdn.net/qq_34199383/article/details/80469780\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_34199383/article/details/80469780</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ 捕获 ] ( 形参 ) -&gt; ret &#123; 函数体 &#125;</span><br><span class=\"line\">[ 捕获 ] ( 形参 ) &#123; 函数体 &#125;</span><br><span class=\"line\">[ 捕获 ] &#123; 函数体 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&amp; 以引用隐式捕获被使用的自动变量</span><br><span class=\"line\">= 以复制隐式捕获被使用的自动变量</span><br><span class=\"line\"></span><br><span class=\"line\">[&amp;]&#123;&#125;;          <span class=\"comment\">// OK：默认以引用捕获</span></span><br><span class=\"line\">[&amp;, i]&#123;&#125;;       <span class=\"comment\">// OK：以引用捕获，但 i 以值捕获</span></span><br><span class=\"line\"></span><br><span class=\"line\">[=]&#123;&#125;;          <span class=\"comment\">// OK：默认以复制捕获</span></span><br><span class=\"line\">[=, &amp;i]&#123;&#125;;      <span class=\"comment\">// OK：以复制捕获，但 i 以引用捕获</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">this</span>]&#123;&#125;; <span class=\"comment\">// 获取this指针, 如果使用了&amp;和=则会默认包括this</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用场景一</strong><br>以sort为代表的函数 需要传入函数的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原版</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;a, <span class=\"keyword\">int</span> &amp;b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a &gt; b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">xxx(compare);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新版</span></span><br><span class=\"line\">xxx([](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)&#123;<span class=\"keyword\">return</span> a &gt; b;&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>使用场景二</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> add = [](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)&#123;<span class=\"keyword\">return</span> a + b;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bar = add(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"类型特性\"><a href=\"#类型特性\" class=\"headerlink\" title=\"类型特性\"></a>类型特性</h1><p><a href=\"https://zh.cppreference.com/w/cpp/types#.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/types#.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29</a></p>\n<p>神仙的头文件<type_traits> 可以判断一个值是否是某个类型</p>\n<p>比如判断一个值<br>是不是 整形<br>是不是 void<br>是不是 数组 等等</p>\n<p>目前不知道用在什么地方合适….. 留个连接备用吧</p>\n<h1 id=\"花括号初始\"><a href=\"#花括号初始\" class=\"headerlink\" title=\"花括号初始\"></a>花括号初始</h1><h1 id=\"函数对象\"><a href=\"#函数对象\" class=\"headerlink\" title=\"函数对象\"></a>函数对象</h1><h2 id=\"std-function-functional\"><a href=\"#std-function-functional\" class=\"headerlink\" title=\"std::function  functional\"></a>std::function  functional</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintA</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintB</span><span class=\"params\">(<span class=\"keyword\">int</span> bar)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; FPrintA = PrintA;</span><br><span class=\"line\">    FPrintA();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>(<span class=\"keyword\">int</span>)&gt; FPrintB = PrintB;</span><br><span class=\"line\">    FPrintB(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 感觉配合Lambad 挺不错, 在一个函数中经常使用的功能可以这样定义</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; FLambad = []()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Lambad\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;;</span><br><span class=\"line\">    FLambad();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 不过使用auto貌似更简单</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> ALambad = []()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Lambad\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;;</span><br><span class=\"line\">    ALambad();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$ A</span><br><span class=\"line\">$ B</span><br><span class=\"line\">$ Lambad</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"std-bind-std-ref-std-cref\"><a href=\"#std-bind-std-ref-std-cref\" class=\"headerlink\" title=\"std::bind std::ref std::cref\"></a>std::bind std::ref std::cref</h2><p>今天在学习<br><a href=\"https://github.com/baloonwj/flamingo\" target=\"_blank\" rel=\"noopener\">https://github.com/baloonwj/flamingo</a><br>的时候, 从中发现的这个函数. 这个函数跟std::function 一起使用.<br>竟然实现了回调函数调用类的成员函数!!!!</p>\n<p><a href=\"https://zh.cppreference.com/w/cpp/utility/functional/bind\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/utility/functional/bind</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> n1, <span class=\"keyword\">int</span> n2, <span class=\"keyword\">int</span> n3, <span class=\"keyword\">int</span> n4)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"f function--&gt;n1: %d, n2: %d, n3: %d, n4: %d\\n\"</span>, n1, n2, n3, n4);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ff</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;n1, <span class=\"keyword\">int</span>&amp; n2, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; n3)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"before ff function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">    n1 = <span class=\"number\">11</span>;</span><br><span class=\"line\">    n2 = <span class=\"number\">22</span>;</span><br><span class=\"line\">    <span class=\"comment\">// n3 = 33; 编译错误</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"after ff function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f1 = <span class=\"built_in\">std</span>::bind(f, <span class=\"built_in\">std</span>::placeholders::_2, <span class=\"built_in\">std</span>::placeholders::_3, <span class=\"number\">666</span>, <span class=\"built_in\">std</span>::placeholders::_1);</span><br><span class=\"line\"></span><br><span class=\"line\">    f1(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"comment\">// infunction--&gt;n1: 2, n2: 3, n3: 666, n4: 1</span></span><br><span class=\"line\">    <span class=\"comment\">// 1 绑定_1  2绑定_2  3绑定_3   // 4 5被忽略</span></span><br><span class=\"line\">    <span class=\"comment\">// 按照 f1的顺序传入参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以调用为 f(2, 3, 666, 1);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n1 = <span class=\"number\">1</span>, n2 = <span class=\"number\">2</span>, n3 = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> ff1 = <span class=\"built_in\">std</span>::bind(ff, n1, <span class=\"built_in\">std</span>::ref(n2), <span class=\"built_in\">std</span>::cref(n3));</span><br><span class=\"line\">    n1 = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    n2 = <span class=\"number\">-2</span>;</span><br><span class=\"line\">    n3 = <span class=\"number\">-3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"before ff1 function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">    ff1(n1, n2, n3);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"after ff1 function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">    <span class=\"comment\">// before ff1 function--&gt;n1: -1, n2: -2, n3: -3</span></span><br><span class=\"line\">    <span class=\"comment\">// before ff function-- &gt; n1: 1, n2 : -2, n3 : -3 // 这里说明了值传递 参数是绑定时就决定好了 引用参数还是可以改变的</span></span><br><span class=\"line\">    <span class=\"comment\">// after ff function-- &gt; n1: 11, n2 : 22, n3 : -3</span></span><br><span class=\"line\">    <span class=\"comment\">// after ff1 function-- &gt; n1: -1, n2 : 22, n3 : -3 // 引用传入成功改变, 值传入和const引用传入未变</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// std::ref 按引用传入参数 std::cref按const引用传入参数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"std-pair-utility-std-tuple-tuple\"><a href=\"#std-pair-utility-std-tuple-tuple\" class=\"headerlink\" title=\"std::pair utility std::tuple tuple\"></a>std::pair utility std::tuple tuple</h2><p><a href=\"https://zh.cppreference.com/w/cpp/utility/tuple\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/utility/tuple</a></p>\n<p>pair是 结构体模板, 可在一个单元中存储两个相异对象. pair是tuple拥有两个元素的特殊情况</p>\n<p>tuple是固定大小的异类值(啥是异类值??)汇集</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::tuple&lt;int, double &gt; GetInfoById(int id)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (id == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::make_tuple(<span class=\"number\">1</span>, <span class=\"number\">1.1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (id == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::make_tuple(<span class=\"number\">2</span>, <span class=\"number\">2.2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::invalid_argument(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> info = GetInfoById(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 获取指定位置</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"1:\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">get</span>&lt;<span class=\"number\">0</span>&gt;(info)</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\" 2:\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">get</span>&lt;<span class=\"number\">1</span>&gt;(info) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val1;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> val2;</span><br><span class=\"line\">\t<span class=\"comment\">// 直接创建引用的tuple</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::tie(val1, val2) = GetInfoById(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"1:\"</span> &lt;&lt; val1</span><br><span class=\"line\">              &lt;&lt; <span class=\"string\">\" 2:\"</span> &lt;&lt; val2 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t\t  </span><br><span class=\"line\">$ <span class=\"number\">1</span>:<span class=\"number\">1</span> <span class=\"number\">2</span>:<span class=\"number\">1.1</span></span><br><span class=\"line\">$ <span class=\"number\">1</span>:<span class=\"number\">2</span> <span class=\"number\">2</span>:<span class=\"number\">2.2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Lambda\"><a href=\"#Lambda\" class=\"headerlink\" title=\"Lambda\"></a>Lambda</h1><p>参考资料<br><a href=\"https://zh.cppreference.com/w/cpp/language/lambda\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/language/lambda</a><br><a href=\"https://blog.csdn.net/qq_34199383/article/details/80469780\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_34199383/article/details/80469780</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ 捕获 ] ( 形参 ) -&gt; ret &#123; 函数体 &#125;</span><br><span class=\"line\">[ 捕获 ] ( 形参 ) &#123; 函数体 &#125;</span><br><span class=\"line\">[ 捕获 ] &#123; 函数体 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&amp; 以引用隐式捕获被使用的自动变量</span><br><span class=\"line\">= 以复制隐式捕获被使用的自动变量</span><br><span class=\"line\"></span><br><span class=\"line\">[&amp;]&#123;&#125;;          <span class=\"comment\">// OK：默认以引用捕获</span></span><br><span class=\"line\">[&amp;, i]&#123;&#125;;       <span class=\"comment\">// OK：以引用捕获，但 i 以值捕获</span></span><br><span class=\"line\"></span><br><span class=\"line\">[=]&#123;&#125;;          <span class=\"comment\">// OK：默认以复制捕获</span></span><br><span class=\"line\">[=, &amp;i]&#123;&#125;;      <span class=\"comment\">// OK：以复制捕获，但 i 以引用捕获</span></span><br><span class=\"line\"></span><br><span class=\"line\">[<span class=\"keyword\">this</span>]&#123;&#125;; <span class=\"comment\">// 获取this指针, 如果使用了&amp;和=则会默认包括this</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用场景一</strong><br>以sort为代表的函数 需要传入函数的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原版</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;a, <span class=\"keyword\">int</span> &amp;b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a &gt; b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">xxx(compare);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新版</span></span><br><span class=\"line\">xxx([](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)&#123;<span class=\"keyword\">return</span> a &gt; b;&#125;);</span><br></pre></td></tr></table></figure>\n<p><strong>使用场景二</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> add = [](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)&#123;<span class=\"keyword\">return</span> a + b;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> bar = add(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"类型特性\"><a href=\"#类型特性\" class=\"headerlink\" title=\"类型特性\"></a>类型特性</h1><p><a href=\"https://zh.cppreference.com/w/cpp/types#.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/types#.E7.B1.BB.E5.9E.8B.E7.89.B9.E6.80.A7.28C.2B.2B11_.E8.B5.B7.29</a></p>\n<p>神仙的头文件<type_traits> 可以判断一个值是否是某个类型</p>\n<p>比如判断一个值<br>是不是 整形<br>是不是 void<br>是不是 数组 等等</p>\n<p>目前不知道用在什么地方合适….. 留个连接备用吧</p>\n<h1 id=\"花括号初始\"><a href=\"#花括号初始\" class=\"headerlink\" title=\"花括号初始\"></a>花括号初始</h1><h1 id=\"函数对象\"><a href=\"#函数对象\" class=\"headerlink\" title=\"函数对象\"></a>函数对象</h1><h2 id=\"std-function-functional\"><a href=\"#std-function-functional\" class=\"headerlink\" title=\"std::function  functional\"></a>std::function  functional</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintA</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">PrintB</span><span class=\"params\">(<span class=\"keyword\">int</span> bar)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; FPrintA = PrintA;</span><br><span class=\"line\">    FPrintA();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>(<span class=\"keyword\">int</span>)&gt; FPrintB = PrintB;</span><br><span class=\"line\">    FPrintB(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 感觉配合Lambad 挺不错, 在一个函数中经常使用的功能可以这样定义</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">void</span>()&gt; FLambad = []()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Lambad\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;;</span><br><span class=\"line\">    FLambad();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 不过使用auto貌似更简单</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> ALambad = []()&#123;<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Lambad\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;&#125;;</span><br><span class=\"line\">    ALambad();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$ A</span><br><span class=\"line\">$ B</span><br><span class=\"line\">$ Lambad</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"std-bind-std-ref-std-cref\"><a href=\"#std-bind-std-ref-std-cref\" class=\"headerlink\" title=\"std::bind std::ref std::cref\"></a>std::bind std::ref std::cref</h2><p>今天在学习<br><a href=\"https://github.com/baloonwj/flamingo\" target=\"_blank\" rel=\"noopener\">https://github.com/baloonwj/flamingo</a><br>的时候, 从中发现的这个函数. 这个函数跟std::function 一起使用.<br>竟然实现了回调函数调用类的成员函数!!!!</p>\n<p><a href=\"https://zh.cppreference.com/w/cpp/utility/functional/bind\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/utility/functional/bind</a></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> n1, <span class=\"keyword\">int</span> n2, <span class=\"keyword\">int</span> n3, <span class=\"keyword\">int</span> n4)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"f function--&gt;n1: %d, n2: %d, n3: %d, n4: %d\\n\"</span>, n1, n2, n3, n4);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ff</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;n1, <span class=\"keyword\">int</span>&amp; n2, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; n3)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"before ff function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">    n1 = <span class=\"number\">11</span>;</span><br><span class=\"line\">    n2 = <span class=\"number\">22</span>;</span><br><span class=\"line\">    <span class=\"comment\">// n3 = 33; 编译错误</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"after ff function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f1 = <span class=\"built_in\">std</span>::bind(f, <span class=\"built_in\">std</span>::placeholders::_2, <span class=\"built_in\">std</span>::placeholders::_3, <span class=\"number\">666</span>, <span class=\"built_in\">std</span>::placeholders::_1);</span><br><span class=\"line\"></span><br><span class=\"line\">    f1(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">    <span class=\"comment\">// infunction--&gt;n1: 2, n2: 3, n3: 666, n4: 1</span></span><br><span class=\"line\">    <span class=\"comment\">// 1 绑定_1  2绑定_2  3绑定_3   // 4 5被忽略</span></span><br><span class=\"line\">    <span class=\"comment\">// 按照 f1的顺序传入参数</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以调用为 f(2, 3, 666, 1);</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n1 = <span class=\"number\">1</span>, n2 = <span class=\"number\">2</span>, n3 = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> ff1 = <span class=\"built_in\">std</span>::bind(ff, n1, <span class=\"built_in\">std</span>::ref(n2), <span class=\"built_in\">std</span>::cref(n3));</span><br><span class=\"line\">    n1 = <span class=\"number\">-1</span>;</span><br><span class=\"line\">    n2 = <span class=\"number\">-2</span>;</span><br><span class=\"line\">    n3 = <span class=\"number\">-3</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"before ff1 function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">    ff1(n1, n2, n3);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"after ff1 function--&gt;n1: %d, n2: %d, n3: %d\\n\"</span>, n1, n2, n3);</span><br><span class=\"line\">    <span class=\"comment\">// before ff1 function--&gt;n1: -1, n2: -2, n3: -3</span></span><br><span class=\"line\">    <span class=\"comment\">// before ff function-- &gt; n1: 1, n2 : -2, n3 : -3 // 这里说明了值传递 参数是绑定时就决定好了 引用参数还是可以改变的</span></span><br><span class=\"line\">    <span class=\"comment\">// after ff function-- &gt; n1: 11, n2 : 22, n3 : -3</span></span><br><span class=\"line\">    <span class=\"comment\">// after ff1 function-- &gt; n1: -1, n2 : 22, n3 : -3 // 引用传入成功改变, 值传入和const引用传入未变</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// std::ref 按引用传入参数 std::cref按const引用传入参数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"std-pair-utility-std-tuple-tuple\"><a href=\"#std-pair-utility-std-tuple-tuple\" class=\"headerlink\" title=\"std::pair utility std::tuple tuple\"></a>std::pair utility std::tuple tuple</h2><p><a href=\"https://zh.cppreference.com/w/cpp/utility/tuple\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/utility/tuple</a></p>\n<p>pair是 结构体模板, 可在一个单元中存储两个相异对象. pair是tuple拥有两个元素的特殊情况</p>\n<p>tuple是固定大小的异类值(啥是异类值??)汇集</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::tuple&lt;int, double &gt; GetInfoById(int id)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (id == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::make_tuple(<span class=\"number\">1</span>, <span class=\"number\">1.1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (id == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"built_in\">std</span>::make_tuple(<span class=\"number\">2</span>, <span class=\"number\">2.2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::invalid_argument(<span class=\"string\">\"id\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> info = GetInfoById(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"comment\">// 获取指定位置</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"1:\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">get</span>&lt;<span class=\"number\">0</span>&gt;(info)</span><br><span class=\"line\">            &lt;&lt; <span class=\"string\">\" 2:\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">get</span>&lt;<span class=\"number\">1</span>&gt;(info) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> val1;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> val2;</span><br><span class=\"line\">\t<span class=\"comment\">// 直接创建引用的tuple</span></span><br><span class=\"line\">    <span class=\"built_in\">std</span>::tie(val1, val2) = GetInfoById(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"1:\"</span> &lt;&lt; val1</span><br><span class=\"line\">              &lt;&lt; <span class=\"string\">\" 2:\"</span> &lt;&lt; val2 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t\t  </span><br><span class=\"line\">$ <span class=\"number\">1</span>:<span class=\"number\">1</span> <span class=\"number\">2</span>:<span class=\"number\">1.1</span></span><br><span class=\"line\">$ <span class=\"number\">1</span>:<span class=\"number\">2</span> <span class=\"number\">2</span>:<span class=\"number\">2.2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"CMAKE","date":"2020-02-06T09:07:45.000Z","_content":"CMAKE并不打算专门去学, 所以就用到哪里学到哪里\n\n今天clion写项目 遇到一个问题 明明写了aux_source_directory 却依然提示没有加入. 后来查了下, 并不推荐使用那个命令.\n可能会存在一些问题\nhttps://cmake.org/cmake/help/latest/command/aux_source_directory.html\n\n\n```cmake\n# 必须片段\n# CMake 最低版本号要求\ncmake_minimum_required (VERSION 2.8)\n# 项目信息\nproject (Demo1)\n# 指定生成目标\nadd_executable(Demo main.cc)\n\n# 多文件\n# 如果一味地在add_executable中添加源文件, 会导致太长了\n# 将dir目录中所有源文件保存在变量中\naux_source_directory(. DIR_SOURCE)\n# 将变量赋值给Demo\nadd_executable(Demo ${DIR_SOURCE})\n\n# 多文件多目录\n# 需要在主目录和子文件夹中都编写CMakeLists.txt文件\n\n# 主文件添加子目录\nadd_subdirectory(dir1)\n# 添加链接库\ntarget_link_libraries(Demo Foo)\n\n# dir1目录中\naux_source_directory(. DIR1_SOURCE)\n# 生成链接库 Foo 在主文件中添加即可\nadd_library(Foo ${DIR1_SOURCE})\n```\n\n# CMAKE和MAKE之间的区别\n[博客原文](https://my.oschina.net/xunxun/blog/86781)\n\n自己的理解\n通过为cmake编写CMakeList文件, cmake即可按照规则生成相应的Makefile文件\n然后make读取Makefile文件就可以按照规则将源代码编译\n\n总的来说cmake就是为make生成Makefile文件, (Makefile文件可以自己编写, 也可以用Cmake生成)\n应该是编写CMakeList的代码量少于或者简单于Makefile, 简化了操作","source":"_posts/CPP-CPP重点-CMAKE.md","raw":"---\ntitle: CMAKE\ndate: 2020-02-06 17:07:45\ntags:\ncategories:\n  - CPP\n  - CPP重点\n---\nCMAKE并不打算专门去学, 所以就用到哪里学到哪里\n\n今天clion写项目 遇到一个问题 明明写了aux_source_directory 却依然提示没有加入. 后来查了下, 并不推荐使用那个命令.\n可能会存在一些问题\nhttps://cmake.org/cmake/help/latest/command/aux_source_directory.html\n\n\n```cmake\n# 必须片段\n# CMake 最低版本号要求\ncmake_minimum_required (VERSION 2.8)\n# 项目信息\nproject (Demo1)\n# 指定生成目标\nadd_executable(Demo main.cc)\n\n# 多文件\n# 如果一味地在add_executable中添加源文件, 会导致太长了\n# 将dir目录中所有源文件保存在变量中\naux_source_directory(. DIR_SOURCE)\n# 将变量赋值给Demo\nadd_executable(Demo ${DIR_SOURCE})\n\n# 多文件多目录\n# 需要在主目录和子文件夹中都编写CMakeLists.txt文件\n\n# 主文件添加子目录\nadd_subdirectory(dir1)\n# 添加链接库\ntarget_link_libraries(Demo Foo)\n\n# dir1目录中\naux_source_directory(. DIR1_SOURCE)\n# 生成链接库 Foo 在主文件中添加即可\nadd_library(Foo ${DIR1_SOURCE})\n```\n\n# CMAKE和MAKE之间的区别\n[博客原文](https://my.oschina.net/xunxun/blog/86781)\n\n自己的理解\n通过为cmake编写CMakeList文件, cmake即可按照规则生成相应的Makefile文件\n然后make读取Makefile文件就可以按照规则将源代码编译\n\n总的来说cmake就是为make生成Makefile文件, (Makefile文件可以自己编写, 也可以用Cmake生成)\n应该是编写CMakeList的代码量少于或者简单于Makefile, 简化了操作","slug":"CPP-CPP重点-CMAKE","published":1,"updated":"2020-02-19T14:35:15.526Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucup000b8cuo552n01tf","content":"<p>CMAKE并不打算专门去学, 所以就用到哪里学到哪里</p>\n<p>今天clion写项目 遇到一个问题 明明写了aux_source_directory 却依然提示没有加入. 后来查了下, 并不推荐使用那个命令.<br>可能会存在一些问题<br><a href=\"https://cmake.org/cmake/help/latest/command/aux_source_directory.html\" target=\"_blank\" rel=\"noopener\">https://cmake.org/cmake/help/latest/command/aux_source_directory.html</a></p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 必须片段</span></span><br><span class=\"line\"><span class=\"comment\"># CMake 最低版本号要求</span></span><br><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span> (VERSION <span class=\"number\">2.8</span>)</span><br><span class=\"line\"><span class=\"comment\"># 项目信息</span></span><br><span class=\"line\"><span class=\"keyword\">project</span> (Demo1)</span><br><span class=\"line\"><span class=\"comment\"># 指定生成目标</span></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(Demo main.cc)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多文件</span></span><br><span class=\"line\"><span class=\"comment\"># 如果一味地在add_executable中添加源文件, 会导致太长了</span></span><br><span class=\"line\"><span class=\"comment\"># 将dir目录中所有源文件保存在变量中</span></span><br><span class=\"line\"><span class=\"keyword\">aux_source_directory</span>(. DIR_SOURCE)</span><br><span class=\"line\"><span class=\"comment\"># 将变量赋值给Demo</span></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(Demo <span class=\"variable\">$&#123;DIR_SOURCE&#125;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多文件多目录</span></span><br><span class=\"line\"><span class=\"comment\"># 需要在主目录和子文件夹中都编写CMakeLists.txt文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 主文件添加子目录</span></span><br><span class=\"line\"><span class=\"keyword\">add_subdirectory</span>(dir1)</span><br><span class=\"line\"><span class=\"comment\"># 添加链接库</span></span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(Demo Foo)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># dir1目录中</span></span><br><span class=\"line\"><span class=\"keyword\">aux_source_directory</span>(. DIR1_SOURCE)</span><br><span class=\"line\"><span class=\"comment\"># 生成链接库 Foo 在主文件中添加即可</span></span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(Foo <span class=\"variable\">$&#123;DIR1_SOURCE&#125;</span>)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"CMAKE和MAKE之间的区别\"><a href=\"#CMAKE和MAKE之间的区别\" class=\"headerlink\" title=\"CMAKE和MAKE之间的区别\"></a>CMAKE和MAKE之间的区别</h1><p><a href=\"https://my.oschina.net/xunxun/blog/86781\" target=\"_blank\" rel=\"noopener\">博客原文</a></p>\n<p>自己的理解<br>通过为cmake编写CMakeList文件, cmake即可按照规则生成相应的Makefile文件<br>然后make读取Makefile文件就可以按照规则将源代码编译</p>\n<p>总的来说cmake就是为make生成Makefile文件, (Makefile文件可以自己编写, 也可以用Cmake生成)<br>应该是编写CMakeList的代码量少于或者简单于Makefile, 简化了操作</p>\n","site":{"data":{}},"excerpt":"","more":"<p>CMAKE并不打算专门去学, 所以就用到哪里学到哪里</p>\n<p>今天clion写项目 遇到一个问题 明明写了aux_source_directory 却依然提示没有加入. 后来查了下, 并不推荐使用那个命令.<br>可能会存在一些问题<br><a href=\"https://cmake.org/cmake/help/latest/command/aux_source_directory.html\" target=\"_blank\" rel=\"noopener\">https://cmake.org/cmake/help/latest/command/aux_source_directory.html</a></p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 必须片段</span></span><br><span class=\"line\"><span class=\"comment\"># CMake 最低版本号要求</span></span><br><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span> (VERSION <span class=\"number\">2.8</span>)</span><br><span class=\"line\"><span class=\"comment\"># 项目信息</span></span><br><span class=\"line\"><span class=\"keyword\">project</span> (Demo1)</span><br><span class=\"line\"><span class=\"comment\"># 指定生成目标</span></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(Demo main.cc)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多文件</span></span><br><span class=\"line\"><span class=\"comment\"># 如果一味地在add_executable中添加源文件, 会导致太长了</span></span><br><span class=\"line\"><span class=\"comment\"># 将dir目录中所有源文件保存在变量中</span></span><br><span class=\"line\"><span class=\"keyword\">aux_source_directory</span>(. DIR_SOURCE)</span><br><span class=\"line\"><span class=\"comment\"># 将变量赋值给Demo</span></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(Demo <span class=\"variable\">$&#123;DIR_SOURCE&#125;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 多文件多目录</span></span><br><span class=\"line\"><span class=\"comment\"># 需要在主目录和子文件夹中都编写CMakeLists.txt文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 主文件添加子目录</span></span><br><span class=\"line\"><span class=\"keyword\">add_subdirectory</span>(dir1)</span><br><span class=\"line\"><span class=\"comment\"># 添加链接库</span></span><br><span class=\"line\"><span class=\"keyword\">target_link_libraries</span>(Demo Foo)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># dir1目录中</span></span><br><span class=\"line\"><span class=\"keyword\">aux_source_directory</span>(. DIR1_SOURCE)</span><br><span class=\"line\"><span class=\"comment\"># 生成链接库 Foo 在主文件中添加即可</span></span><br><span class=\"line\"><span class=\"keyword\">add_library</span>(Foo <span class=\"variable\">$&#123;DIR1_SOURCE&#125;</span>)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"CMAKE和MAKE之间的区别\"><a href=\"#CMAKE和MAKE之间的区别\" class=\"headerlink\" title=\"CMAKE和MAKE之间的区别\"></a>CMAKE和MAKE之间的区别</h1><p><a href=\"https://my.oschina.net/xunxun/blog/86781\" target=\"_blank\" rel=\"noopener\">博客原文</a></p>\n<p>自己的理解<br>通过为cmake编写CMakeList文件, cmake即可按照规则生成相应的Makefile文件<br>然后make读取Makefile文件就可以按照规则将源代码编译</p>\n<p>总的来说cmake就是为make生成Makefile文件, (Makefile文件可以自己编写, 也可以用Cmake生成)<br>应该是编写CMakeList的代码量少于或者简单于Makefile, 简化了操作</p>\n"},{"title":"头文件互相引用","date":"2020-02-07T08:37:08.000Z","_content":"写在前头 本文中的**编译**二字基本都带加粗, 因为目前为止我还没做学到过**编译**器相关的东西, \n姑且将`那个执行过程`称为**编译**, 所以加粗\n# 现象\n二月六号的时候 我在写那个小游戏, 写头文件`a.h`发现即使引用了一个头文件`b.h`, 也没有办法使用定义在那个头文件之中的结构体.\n\n其实有点我没在意: 当我在`a.h`文件中引用`b.h`的时候`b.h`会变成`invaild`, 这里其实就已经提示了\n```c++\n// a.h\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#include \"b.h\"\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\n\n// b.h\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n#include \"a.h\"\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\n// main.cpp\n#include \"a.h\" // a.h中有b.h就只include a.h\nint main()\n{\n    A a{};\n    B b{};\n}\n\nerror: ‘A’ does not name a type\nerror: ‘B’ does not name a type\n```\n# 原因\n## 先说一下 #ifndef #endif\n`ifndef`全称`if not defined`\n意思是如果`#ifndef`后面的宏没有被定义 就继续**编译**其中的内容\n继续**编译**`#ifndef`的下一句就是`#define`这个宏, 这样这个宏就被定义了\n第二次**编译**遇到这个头文件的时候, `#ifndef`后面的宏已经被定义了就跳过了if中的内容\n\n## #include的作用\n将 #include右边的文件展开到此文件中\n\n## 问题解释\n这样当你在main函数中 `#include \"a.h\"`的时候`a.h`之中的内容就被展开\n变成如下\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#include \"b.h\"\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\n\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n还有一个include同样操作得到如下\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n#include \"a.h\"\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n我猜测**编译**的时候是逐行执行的, 至少在头文件的这部分是逐行执行\n这样执行完了`行号为2 3 4 5`的四个宏 准备执行`行号为6`的这一行`#include \"a.h\"`继续展开\n得到如下\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#include \"b.h\"\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n可能有些乱 但仔细理解还是能到这里. 这下继续逐行执行 准备是`行号为6`的这一行(也可能是行号7的部分, 区别就是在include的下一行展开还是本行展开)`#ifndef UNTITLED1_A_H`\n这个宏就判断`UNTITLED1_A_H`是不是被定义了, 恩被定义了(第三行代码)跳到对应的`#endif`, 这样就防止了头文件\n无穷无尽的调用 我将跳过的部分注释掉方便继续分析\n\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n//#ifndef UNTITLED1_A_H\n//#define UNTITLED1_A_H\n//#include \"b.h\"\n//class A\n//{\n//   B *b;\n//};\n//#endif //UNTITLED1_A_H\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n下一行就是`第十四行`的`class B`的**编译**, 那么问题来了`第16行`的`A`是啥东西??.\n\n这里报错报了两行 我大胆推测一下 `class B`的**编译**的出错后, 依然在继续这个过程, 到了`class A`的时候\n发现其中的`B`又是啥呢? 推测不同头文件编译互不影响 所以出现了两行报错\n\n我们回到`class B`的头文件在`class B`的前面加上一行`class A;` 得到如下代码\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n//#ifndef UNTITLED1_A_H\n//#define UNTITLED1_A_H\n//#include \"b.h\"\n//class A\n//{\n//   B *b;\n//};\n//#endif //UNTITLED1_A_H\nclass A;\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n\n到了这里你会发现A的报错消失了, 因为这次在**编译**`class B`的时候事先知道了`A`是一个类并且你必须把\n`class B`之中的这一句`A *a;`写成指针, 因为指针大小确定, 而且没有初始化, 所以**编译**就能通过, 如果你写成\n`A a;`依然会报错, 因为不知道A具体是个啥 最起码的内存都没法分配\n\n好的下面继续, 你发现虽然A的报错消失了 但是`B`的报错还在, 我这里依然推测下, 不同头文件之间的**编译**互不影响,\n所以依然不知道`B`是什么此时按照上面操作加入`class B;`前置声明, **编译**正确通过.\n\n虽然两个头文件**编译**互不影响, 但是既然是main.cpp把他们引进来的 就同时对main.cpp起作用 自然就知道了A和B是啥\n\n\n虽然这个问题网上答案很多, 但我对此还是很多不理解, 所以在做某些推测的情况下, 分析出来了这些原因. 如果有误,请直接评论中指出. 这也算是本人的第一篇写的认真的博客","source":"_posts/CPP-CPP采坑-头文件互相引用.md","raw":"---\ntitle: 头文件互相引用\ndate: 2020-02-07 16:37:08\ntags:\n  - CPP踩坑记\n  - CPP\ncategories:\n  - CPP\n  - CPP踩坑\n---\n写在前头 本文中的**编译**二字基本都带加粗, 因为目前为止我还没做学到过**编译**器相关的东西, \n姑且将`那个执行过程`称为**编译**, 所以加粗\n# 现象\n二月六号的时候 我在写那个小游戏, 写头文件`a.h`发现即使引用了一个头文件`b.h`, 也没有办法使用定义在那个头文件之中的结构体.\n\n其实有点我没在意: 当我在`a.h`文件中引用`b.h`的时候`b.h`会变成`invaild`, 这里其实就已经提示了\n```c++\n// a.h\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#include \"b.h\"\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\n\n// b.h\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n#include \"a.h\"\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\n// main.cpp\n#include \"a.h\" // a.h中有b.h就只include a.h\nint main()\n{\n    A a{};\n    B b{};\n}\n\nerror: ‘A’ does not name a type\nerror: ‘B’ does not name a type\n```\n# 原因\n## 先说一下 #ifndef #endif\n`ifndef`全称`if not defined`\n意思是如果`#ifndef`后面的宏没有被定义 就继续**编译**其中的内容\n继续**编译**`#ifndef`的下一句就是`#define`这个宏, 这样这个宏就被定义了\n第二次**编译**遇到这个头文件的时候, `#ifndef`后面的宏已经被定义了就跳过了if中的内容\n\n## #include的作用\n将 #include右边的文件展开到此文件中\n\n## 问题解释\n这样当你在main函数中 `#include \"a.h\"`的时候`a.h`之中的内容就被展开\n变成如下\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#include \"b.h\"\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\n\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n还有一个include同样操作得到如下\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n#include \"a.h\"\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n我猜测**编译**的时候是逐行执行的, 至少在头文件的这部分是逐行执行\n这样执行完了`行号为2 3 4 5`的四个宏 准备执行`行号为6`的这一行`#include \"a.h\"`继续展开\n得到如下\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#include \"b.h\"\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n可能有些乱 但仔细理解还是能到这里. 这下继续逐行执行 准备是`行号为6`的这一行(也可能是行号7的部分, 区别就是在include的下一行展开还是本行展开)`#ifndef UNTITLED1_A_H`\n这个宏就判断`UNTITLED1_A_H`是不是被定义了, 恩被定义了(第三行代码)跳到对应的`#endif`, 这样就防止了头文件\n无穷无尽的调用 我将跳过的部分注释掉方便继续分析\n\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n//#ifndef UNTITLED1_A_H\n//#define UNTITLED1_A_H\n//#include \"b.h\"\n//class A\n//{\n//   B *b;\n//};\n//#endif //UNTITLED1_A_H\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n下一行就是`第十四行`的`class B`的**编译**, 那么问题来了`第16行`的`A`是啥东西??.\n\n这里报错报了两行 我大胆推测一下 `class B`的**编译**的出错后, 依然在继续这个过程, 到了`class A`的时候\n发现其中的`B`又是啥呢? 推测不同头文件编译互不影响 所以出现了两行报错\n\n我们回到`class B`的头文件在`class B`的前面加上一行`class A;` 得到如下代码\n```c++\n// main.cpp\n#ifndef UNTITLED1_A_H\n#define UNTITLED1_A_H\n#ifndef UNTITLED1_B_H\n#define UNTITLED1_B_H\n//#ifndef UNTITLED1_A_H\n//#define UNTITLED1_A_H\n//#include \"b.h\"\n//class A\n//{\n//   B *b;\n//};\n//#endif //UNTITLED1_A_H\nclass A;\nclass B\n{\n    A *a;\n};\n\n#endif //UNTITLED1_B_H\nclass A\n{\n    B *b;\n};\n#endif //UNTITLED1_A_H\nint main()\n{\n    A a{};\n    B b{};\n}\n```\n\n到了这里你会发现A的报错消失了, 因为这次在**编译**`class B`的时候事先知道了`A`是一个类并且你必须把\n`class B`之中的这一句`A *a;`写成指针, 因为指针大小确定, 而且没有初始化, 所以**编译**就能通过, 如果你写成\n`A a;`依然会报错, 因为不知道A具体是个啥 最起码的内存都没法分配\n\n好的下面继续, 你发现虽然A的报错消失了 但是`B`的报错还在, 我这里依然推测下, 不同头文件之间的**编译**互不影响,\n所以依然不知道`B`是什么此时按照上面操作加入`class B;`前置声明, **编译**正确通过.\n\n虽然两个头文件**编译**互不影响, 但是既然是main.cpp把他们引进来的 就同时对main.cpp起作用 自然就知道了A和B是啥\n\n\n虽然这个问题网上答案很多, 但我对此还是很多不理解, 所以在做某些推测的情况下, 分析出来了这些原因. 如果有误,请直接评论中指出. 这也算是本人的第一篇写的认真的博客","slug":"CPP-CPP采坑-头文件互相引用","published":1,"updated":"2020-02-07T10:09:48.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucuq000d8cuocc1x1mot","content":"<p>写在前头 本文中的<strong>编译</strong>二字基本都带加粗, 因为目前为止我还没做学到过<strong>编译</strong>器相关的东西,<br>姑且将<code>那个执行过程</code>称为<strong>编译</strong>, 所以加粗</p>\n<h1 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h1><p>二月六号的时候 我在写那个小游戏, 写头文件<code>a.h</code>发现即使引用了一个头文件<code>b.h</code>, 也没有办法使用定义在那个头文件之中的结构体.</p>\n<p>其实有点我没在意: 当我在<code>a.h</code>文件中引用<code>b.h</code>的时候<code>b.h</code>会变成<code>invaild</code>, 这里其实就已经提示了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span> <span class=\"comment\">// a.h中有b.h就只include a.h</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">error: ‘A’ does <span class=\"keyword\">not</span> name a type</span><br><span class=\"line\">error: ‘B’ does <span class=\"keyword\">not</span> name a type</span><br></pre></td></tr></table></figure>\n<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h1><h2 id=\"先说一下-ifndef-endif\"><a href=\"#先说一下-ifndef-endif\" class=\"headerlink\" title=\"先说一下 #ifndef #endif\"></a>先说一下 #ifndef #endif</h2><p><code>ifndef</code>全称<code>if not defined</code><br>意思是如果<code>#ifndef</code>后面的宏没有被定义 就继续<strong>编译</strong>其中的内容<br>继续<strong>编译</strong><code>#ifndef</code>的下一句就是<code>#define</code>这个宏, 这样这个宏就被定义了<br>第二次<strong>编译</strong>遇到这个头文件的时候, <code>#ifndef</code>后面的宏已经被定义了就跳过了if中的内容</p>\n<h2 id=\"include的作用\"><a href=\"#include的作用\" class=\"headerlink\" title=\"#include的作用\"></a>#include的作用</h2><p>将 #include右边的文件展开到此文件中</p>\n<h2 id=\"问题解释\"><a href=\"#问题解释\" class=\"headerlink\" title=\"问题解释\"></a>问题解释</h2><p>这样当你在main函数中 <code>#include &quot;a.h&quot;</code>的时候<code>a.h</code>之中的内容就被展开<br>变成如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有一个include同样操作得到如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我猜测<strong>编译</strong>的时候是逐行执行的, 至少在头文件的这部分是逐行执行<br>这样执行完了<code>行号为2 3 4 5</code>的四个宏 准备执行<code>行号为6</code>的这一行<code>#include &quot;a.h&quot;</code>继续展开<br>得到如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可能有些乱 但仔细理解还是能到这里. 这下继续逐行执行 准备是<code>行号为6</code>的这一行(也可能是行号7的部分, 区别就是在include的下一行展开还是本行展开)<code>#ifndef UNTITLED1_A_H</code><br>这个宏就判断<code>UNTITLED1_A_H</code>是不是被定义了, 恩被定义了(第三行代码)跳到对应的<code>#endif</code>, 这样就防止了头文件<br>无穷无尽的调用 我将跳过的部分注释掉方便继续分析</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"comment\">//#ifndef UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#define UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#include \"b.h\"</span></span><br><span class=\"line\"><span class=\"comment\">//class A</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   B *b;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">//#endif //UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下一行就是<code>第十四行</code>的<code>class B</code>的<strong>编译</strong>, 那么问题来了<code>第16行</code>的<code>A</code>是啥东西??.</p>\n<p>这里报错报了两行 我大胆推测一下 <code>class B</code>的<strong>编译</strong>的出错后, 依然在继续这个过程, 到了<code>class A</code>的时候<br>发现其中的<code>B</code>又是啥呢? 推测不同头文件编译互不影响 所以出现了两行报错</p>\n<p>我们回到<code>class B</code>的头文件在<code>class B</code>的前面加上一行<code>class A;</code> 得到如下代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"comment\">//#ifndef UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#define UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#include \"b.h\"</span></span><br><span class=\"line\"><span class=\"comment\">//class A</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   B *b;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">//#endif //UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到了这里你会发现A的报错消失了, 因为这次在<strong>编译</strong><code>class B</code>的时候事先知道了<code>A</code>是一个类并且你必须把<br><code>class B</code>之中的这一句<code>A *a;</code>写成指针, 因为指针大小确定, 而且没有初始化, 所以<strong>编译</strong>就能通过, 如果你写成<br><code>A a;</code>依然会报错, 因为不知道A具体是个啥 最起码的内存都没法分配</p>\n<p>好的下面继续, 你发现虽然A的报错消失了 但是<code>B</code>的报错还在, 我这里依然推测下, 不同头文件之间的<strong>编译</strong>互不影响,<br>所以依然不知道<code>B</code>是什么此时按照上面操作加入<code>class B;</code>前置声明, <strong>编译</strong>正确通过.</p>\n<p>虽然两个头文件<strong>编译</strong>互不影响, 但是既然是main.cpp把他们引进来的 就同时对main.cpp起作用 自然就知道了A和B是啥</p>\n<p>虽然这个问题网上答案很多, 但我对此还是很多不理解, 所以在做某些推测的情况下, 分析出来了这些原因. 如果有误,请直接评论中指出. 这也算是本人的第一篇写的认真的博客</p>\n","site":{"data":{}},"excerpt":"","more":"<p>写在前头 本文中的<strong>编译</strong>二字基本都带加粗, 因为目前为止我还没做学到过<strong>编译</strong>器相关的东西,<br>姑且将<code>那个执行过程</code>称为<strong>编译</strong>, 所以加粗</p>\n<h1 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h1><p>二月六号的时候 我在写那个小游戏, 写头文件<code>a.h</code>发现即使引用了一个头文件<code>b.h</code>, 也没有办法使用定义在那个头文件之中的结构体.</p>\n<p>其实有点我没在意: 当我在<code>a.h</code>文件中引用<code>b.h</code>的时候<code>b.h</code>会变成<code>invaild</code>, 这里其实就已经提示了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// b.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span> <span class=\"comment\">// a.h中有b.h就只include a.h</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">error: ‘A’ does <span class=\"keyword\">not</span> name a type</span><br><span class=\"line\">error: ‘B’ does <span class=\"keyword\">not</span> name a type</span><br></pre></td></tr></table></figure>\n<h1 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h1><h2 id=\"先说一下-ifndef-endif\"><a href=\"#先说一下-ifndef-endif\" class=\"headerlink\" title=\"先说一下 #ifndef #endif\"></a>先说一下 #ifndef #endif</h2><p><code>ifndef</code>全称<code>if not defined</code><br>意思是如果<code>#ifndef</code>后面的宏没有被定义 就继续<strong>编译</strong>其中的内容<br>继续<strong>编译</strong><code>#ifndef</code>的下一句就是<code>#define</code>这个宏, 这样这个宏就被定义了<br>第二次<strong>编译</strong>遇到这个头文件的时候, <code>#ifndef</code>后面的宏已经被定义了就跳过了if中的内容</p>\n<h2 id=\"include的作用\"><a href=\"#include的作用\" class=\"headerlink\" title=\"#include的作用\"></a>#include的作用</h2><p>将 #include右边的文件展开到此文件中</p>\n<h2 id=\"问题解释\"><a href=\"#问题解释\" class=\"headerlink\" title=\"问题解释\"></a>问题解释</h2><p>这样当你在main函数中 <code>#include &quot;a.h&quot;</code>的时候<code>a.h</code>之中的内容就被展开<br>变成如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还有一个include同样操作得到如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"a.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我猜测<strong>编译</strong>的时候是逐行执行的, 至少在头文件的这部分是逐行执行<br>这样执行完了<code>行号为2 3 4 5</code>的四个宏 准备执行<code>行号为6</code>的这一行<code>#include &quot;a.h&quot;</code>继续展开<br>得到如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"b.h\"</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可能有些乱 但仔细理解还是能到这里. 这下继续逐行执行 准备是<code>行号为6</code>的这一行(也可能是行号7的部分, 区别就是在include的下一行展开还是本行展开)<code>#ifndef UNTITLED1_A_H</code><br>这个宏就判断<code>UNTITLED1_A_H</code>是不是被定义了, 恩被定义了(第三行代码)跳到对应的<code>#endif</code>, 这样就防止了头文件<br>无穷无尽的调用 我将跳过的部分注释掉方便继续分析</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"comment\">//#ifndef UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#define UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#include \"b.h\"</span></span><br><span class=\"line\"><span class=\"comment\">//class A</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   B *b;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">//#endif //UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下一行就是<code>第十四行</code>的<code>class B</code>的<strong>编译</strong>, 那么问题来了<code>第16行</code>的<code>A</code>是啥东西??.</p>\n<p>这里报错报了两行 我大胆推测一下 <code>class B</code>的<strong>编译</strong>的出错后, 依然在继续这个过程, 到了<code>class A</code>的时候<br>发现其中的<code>B</code>又是啥呢? 推测不同头文件编译互不影响 所以出现了两行报错</p>\n<p>我们回到<code>class B</code>的头文件在<code>class B</code>的前面加上一行<code>class A;</code> 得到如下代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> UNTITLED1_B_H</span></span><br><span class=\"line\"><span class=\"comment\">//#ifndef UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#define UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"comment\">//#include \"b.h\"</span></span><br><span class=\"line\"><span class=\"comment\">//class A</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   B *b;</span></span><br><span class=\"line\"><span class=\"comment\">//&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">//#endif //UNTITLED1_A_H</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    A *a;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_B_H</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    B *b;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">//UNTITLED1_A_H</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    A a&#123;&#125;;</span><br><span class=\"line\">    B b&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到了这里你会发现A的报错消失了, 因为这次在<strong>编译</strong><code>class B</code>的时候事先知道了<code>A</code>是一个类并且你必须把<br><code>class B</code>之中的这一句<code>A *a;</code>写成指针, 因为指针大小确定, 而且没有初始化, 所以<strong>编译</strong>就能通过, 如果你写成<br><code>A a;</code>依然会报错, 因为不知道A具体是个啥 最起码的内存都没法分配</p>\n<p>好的下面继续, 你发现虽然A的报错消失了 但是<code>B</code>的报错还在, 我这里依然推测下, 不同头文件之间的<strong>编译</strong>互不影响,<br>所以依然不知道<code>B</code>是什么此时按照上面操作加入<code>class B;</code>前置声明, <strong>编译</strong>正确通过.</p>\n<p>虽然两个头文件<strong>编译</strong>互不影响, 但是既然是main.cpp把他们引进来的 就同时对main.cpp起作用 自然就知道了A和B是啥</p>\n<p>虽然这个问题网上答案很多, 但我对此还是很多不理解, 所以在做某些推测的情况下, 分析出来了这些原因. 如果有误,请直接评论中指出. 这也算是本人的第一篇写的认真的博客</p>\n"},{"title":"定义与声明详解","date":"2020-02-27T02:38:08.000Z","_content":"# 变量声明和变量定义\n\n变量声明: 用于向程序表明变量的类型和名字\n变量定义: 用于为变量*分配存储空间*, 同时可为变量指定初始值\n\n定义时会自动声明, 变量只能被定义一次, 却可以声明多次\nextern声明不是定义\n\n```c++\nextern int i; // 声明i 但没有定义i\nint i; // 定义且声明i\n\nextern int i = 10; // 定义并声明\n\n// 如果再函数体内部试图初始化一个由extern标记的变量,会引发错误\n```\n\n# extern\n只有extern声明位于函数外部的时候,才能被初始化\n\n**在C++中 可以用来声明全局变量**\n```c++\n// file1.cpp\nint global_int = 1;\n\n// file2.cpp\nextern int global_int;\n// 后面可以直接使用 global_int, 因为他在其他地方定义了\n```","source":"_posts/CPP-CPP重点-定义与声明详解.md","raw":"---\ntitle: 定义与声明详解\ndate: 2020-02-27 10:38:08\ntags:\ncategories:\n - CPP\n - CPP重点\n---\n# 变量声明和变量定义\n\n变量声明: 用于向程序表明变量的类型和名字\n变量定义: 用于为变量*分配存储空间*, 同时可为变量指定初始值\n\n定义时会自动声明, 变量只能被定义一次, 却可以声明多次\nextern声明不是定义\n\n```c++\nextern int i; // 声明i 但没有定义i\nint i; // 定义且声明i\n\nextern int i = 10; // 定义并声明\n\n// 如果再函数体内部试图初始化一个由extern标记的变量,会引发错误\n```\n\n# extern\n只有extern声明位于函数外部的时候,才能被初始化\n\n**在C++中 可以用来声明全局变量**\n```c++\n// file1.cpp\nint global_int = 1;\n\n// file2.cpp\nextern int global_int;\n// 后面可以直接使用 global_int, 因为他在其他地方定义了\n```","slug":"CPP-CPP重点-定义与声明详解","published":1,"updated":"2020-02-27T03:26:16.583Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucur000f8cuo828i6kya","content":"<h1 id=\"变量声明和变量定义\"><a href=\"#变量声明和变量定义\" class=\"headerlink\" title=\"变量声明和变量定义\"></a>变量声明和变量定义</h1><p>变量声明: 用于向程序表明变量的类型和名字<br>变量定义: 用于为变量<em>分配存储空间</em>, 同时可为变量指定初始值</p>\n<p>定义时会自动声明, 变量只能被定义一次, 却可以声明多次<br>extern声明不是定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// 声明i 但没有定义i</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i; <span class=\"comment\">// 定义且声明i</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i = <span class=\"number\">10</span>; <span class=\"comment\">// 定义并声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果再函数体内部试图初始化一个由extern标记的变量,会引发错误</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"extern\"><a href=\"#extern\" class=\"headerlink\" title=\"extern\"></a>extern</h1><p>只有extern声明位于函数外部的时候,才能被初始化</p>\n<p><strong>在C++中 可以用来声明全局变量</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file1.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> global_int = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// file2.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> global_int;</span><br><span class=\"line\"><span class=\"comment\">// 后面可以直接使用 global_int, 因为他在其他地方定义了</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"变量声明和变量定义\"><a href=\"#变量声明和变量定义\" class=\"headerlink\" title=\"变量声明和变量定义\"></a>变量声明和变量定义</h1><p>变量声明: 用于向程序表明变量的类型和名字<br>变量定义: 用于为变量<em>分配存储空间</em>, 同时可为变量指定初始值</p>\n<p>定义时会自动声明, 变量只能被定义一次, 却可以声明多次<br>extern声明不是定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i; <span class=\"comment\">// 声明i 但没有定义i</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i; <span class=\"comment\">// 定义且声明i</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> i = <span class=\"number\">10</span>; <span class=\"comment\">// 定义并声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果再函数体内部试图初始化一个由extern标记的变量,会引发错误</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"extern\"><a href=\"#extern\" class=\"headerlink\" title=\"extern\"></a>extern</h1><p>只有extern声明位于函数外部的时候,才能被初始化</p>\n<p><strong>在C++中 可以用来声明全局变量</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// file1.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> global_int = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// file2.cpp</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> global_int;</span><br><span class=\"line\"><span class=\"comment\">// 后面可以直接使用 global_int, 因为他在其他地方定义了</span></span><br></pre></td></tr></table></figure>"},{"title":"STL与实现记录","date":"2020-03-01T02:26:55.000Z","img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E5%B0%81%E9%9D%A2.jpg","_content":"\n# 容器库\n| 顺序容器 | 按序访问 |\n| --- | --- |\n| array | 静态的连续数组 |\n| vector | 动态的连续数组 |\n| deque | 双端队列 |\n| forward_list | 单链表 |\n| list | 双链表 |\n\n\n| 关联容器 | 能实现快速查找O(logn) |\n| --- | --- |\n| set | 唯一key的集合, 按照key排序 |\n| map | k v集合, 按照k排序, k是唯一的 |\n| multiset | key的集合 按照key排序 |\n| multimap | k v的集合, 按照key排序 |\n\n| 无序关联容器 | 快速查找均摊O(1)最坏O(n)的无序(哈希)数据结构 |\n| --- | --- |\n| unordered_set | 唯一key的集合, 按照key生成散列 |\n| unordered_map | 唯一key, k v的集合, 按照key生成散列 |\n| unordered_multiset | key的集合, 按照key生成散列 |\n| unordered_multimap | k v的集合, 按照key生成散列 |\n\n| 容器适配器 | 提供顺序容器的不同接口 |\n| --- | --- |\n| stack | 适配一个容器提供栈 |\n| queue | 适配一个容器提供队列 |\n| priority_queue | 适配一个容器提供优先级队列 |\n\n# map\n## lower_bound()和 upper_bound()\n**lower_bound(const Key& key)**\nhttps://zh.cppreference.com/w/cpp/container/map/lower_bound\n返回指向首个不小于 key 的元素的迭代器。若找不到这种元素，则返回尾后迭代器\n\n\n\n**upper_bound()**\n返回指向首个大于 key 的元素的迭代器。\n\n# vertor\n| 函数名称 | 使用详解 |\n| --- | --- |\n| at [] | 获取指定位置的元素 有边界检查 |\n| insert | 在指定位置的前面插入, 可以插入单项, vector和数组 |\n| max_size | 理论最大容量 |\n| capacity | 实际最大容量 |\n\n\n# 图片Warn\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8.png)\n\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8.png)\n\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8.png)\n\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8.png)","source":"_posts/CPP-CPP重点-STL记录.md","raw":"---\ntitle: STL与实现记录\ndate: 2020-03-01 10:26:55\ntags:\ncategories:\n  - CPP\n  - CPP重点\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E5%B0%81%E9%9D%A2.jpg\n---\n\n# 容器库\n| 顺序容器 | 按序访问 |\n| --- | --- |\n| array | 静态的连续数组 |\n| vector | 动态的连续数组 |\n| deque | 双端队列 |\n| forward_list | 单链表 |\n| list | 双链表 |\n\n\n| 关联容器 | 能实现快速查找O(logn) |\n| --- | --- |\n| set | 唯一key的集合, 按照key排序 |\n| map | k v集合, 按照k排序, k是唯一的 |\n| multiset | key的集合 按照key排序 |\n| multimap | k v的集合, 按照key排序 |\n\n| 无序关联容器 | 快速查找均摊O(1)最坏O(n)的无序(哈希)数据结构 |\n| --- | --- |\n| unordered_set | 唯一key的集合, 按照key生成散列 |\n| unordered_map | 唯一key, k v的集合, 按照key生成散列 |\n| unordered_multiset | key的集合, 按照key生成散列 |\n| unordered_multimap | k v的集合, 按照key生成散列 |\n\n| 容器适配器 | 提供顺序容器的不同接口 |\n| --- | --- |\n| stack | 适配一个容器提供栈 |\n| queue | 适配一个容器提供队列 |\n| priority_queue | 适配一个容器提供优先级队列 |\n\n# map\n## lower_bound()和 upper_bound()\n**lower_bound(const Key& key)**\nhttps://zh.cppreference.com/w/cpp/container/map/lower_bound\n返回指向首个不小于 key 的元素的迭代器。若找不到这种元素，则返回尾后迭代器\n\n\n\n**upper_bound()**\n返回指向首个大于 key 的元素的迭代器。\n\n# vertor\n| 函数名称 | 使用详解 |\n| --- | --- |\n| at [] | 获取指定位置的元素 有边界检查 |\n| insert | 在指定位置的前面插入, 可以插入单项, vector和数组 |\n| max_size | 理论最大容量 |\n| capacity | 实际最大容量 |\n\n\n# 图片Warn\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8.png)\n\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8.png)\n\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8.png)\n\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8.png)","slug":"CPP-CPP重点-STL记录","published":1,"updated":"2020-03-10T07:08:24.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucut000i8cuo5zfb4zsx","content":"<h1 id=\"容器库\"><a href=\"#容器库\" class=\"headerlink\" title=\"容器库\"></a>容器库</h1><table>\n<thead>\n<tr>\n<th>顺序容器</th>\n<th>按序访问</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>array</td>\n<td>静态的连续数组</td>\n</tr>\n<tr>\n<td>vector</td>\n<td>动态的连续数组</td>\n</tr>\n<tr>\n<td>deque</td>\n<td>双端队列</td>\n</tr>\n<tr>\n<td>forward_list</td>\n<td>单链表</td>\n</tr>\n<tr>\n<td>list</td>\n<td>双链表</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>关联容器</th>\n<th>能实现快速查找O(logn)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>set</td>\n<td>唯一key的集合, 按照key排序</td>\n</tr>\n<tr>\n<td>map</td>\n<td>k v集合, 按照k排序, k是唯一的</td>\n</tr>\n<tr>\n<td>multiset</td>\n<td>key的集合 按照key排序</td>\n</tr>\n<tr>\n<td>multimap</td>\n<td>k v的集合, 按照key排序</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>无序关联容器</th>\n<th>快速查找均摊O(1)最坏O(n)的无序(哈希)数据结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>unordered_set</td>\n<td>唯一key的集合, 按照key生成散列</td>\n</tr>\n<tr>\n<td>unordered_map</td>\n<td>唯一key, k v的集合, 按照key生成散列</td>\n</tr>\n<tr>\n<td>unordered_multiset</td>\n<td>key的集合, 按照key生成散列</td>\n</tr>\n<tr>\n<td>unordered_multimap</td>\n<td>k v的集合, 按照key生成散列</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>容器适配器</th>\n<th>提供顺序容器的不同接口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>stack</td>\n<td>适配一个容器提供栈</td>\n</tr>\n<tr>\n<td>queue</td>\n<td>适配一个容器提供队列</td>\n</tr>\n<tr>\n<td>priority_queue</td>\n<td>适配一个容器提供优先级队列</td>\n</tr>\n</tbody></table>\n<h1 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h1><h2 id=\"lower-bound-和-upper-bound\"><a href=\"#lower-bound-和-upper-bound\" class=\"headerlink\" title=\"lower_bound()和 upper_bound()\"></a>lower_bound()和 upper_bound()</h2><p><strong>lower_bound(const Key&amp; key)</strong><br><a href=\"https://zh.cppreference.com/w/cpp/container/map/lower_bound\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/container/map/lower_bound</a><br>返回指向首个不小于 key 的元素的迭代器。若找不到这种元素，则返回尾后迭代器</p>\n<p><strong>upper_bound()</strong><br>返回指向首个大于 key 的元素的迭代器。</p>\n<h1 id=\"vertor\"><a href=\"#vertor\" class=\"headerlink\" title=\"vertor\"></a>vertor</h1><table>\n<thead>\n<tr>\n<th>函数名称</th>\n<th>使用详解</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>at []</td>\n<td>获取指定位置的元素 有边界检查</td>\n</tr>\n<tr>\n<td>insert</td>\n<td>在指定位置的前面插入, 可以插入单项, vector和数组</td>\n</tr>\n<tr>\n<td>max_size</td>\n<td>理论最大容量</td>\n</tr>\n<tr>\n<td>capacity</td>\n<td>实际最大容量</td>\n</tr>\n</tbody></table>\n<h1 id=\"图片Warn\"><a href=\"#图片Warn\" class=\"headerlink\" title=\"图片Warn\"></a>图片Warn</h1><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8.png\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8.png\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8.png\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"容器库\"><a href=\"#容器库\" class=\"headerlink\" title=\"容器库\"></a>容器库</h1><table>\n<thead>\n<tr>\n<th>顺序容器</th>\n<th>按序访问</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>array</td>\n<td>静态的连续数组</td>\n</tr>\n<tr>\n<td>vector</td>\n<td>动态的连续数组</td>\n</tr>\n<tr>\n<td>deque</td>\n<td>双端队列</td>\n</tr>\n<tr>\n<td>forward_list</td>\n<td>单链表</td>\n</tr>\n<tr>\n<td>list</td>\n<td>双链表</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>关联容器</th>\n<th>能实现快速查找O(logn)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>set</td>\n<td>唯一key的集合, 按照key排序</td>\n</tr>\n<tr>\n<td>map</td>\n<td>k v集合, 按照k排序, k是唯一的</td>\n</tr>\n<tr>\n<td>multiset</td>\n<td>key的集合 按照key排序</td>\n</tr>\n<tr>\n<td>multimap</td>\n<td>k v的集合, 按照key排序</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>无序关联容器</th>\n<th>快速查找均摊O(1)最坏O(n)的无序(哈希)数据结构</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>unordered_set</td>\n<td>唯一key的集合, 按照key生成散列</td>\n</tr>\n<tr>\n<td>unordered_map</td>\n<td>唯一key, k v的集合, 按照key生成散列</td>\n</tr>\n<tr>\n<td>unordered_multiset</td>\n<td>key的集合, 按照key生成散列</td>\n</tr>\n<tr>\n<td>unordered_multimap</td>\n<td>k v的集合, 按照key生成散列</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>容器适配器</th>\n<th>提供顺序容器的不同接口</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>stack</td>\n<td>适配一个容器提供栈</td>\n</tr>\n<tr>\n<td>queue</td>\n<td>适配一个容器提供队列</td>\n</tr>\n<tr>\n<td>priority_queue</td>\n<td>适配一个容器提供优先级队列</td>\n</tr>\n</tbody></table>\n<h1 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h1><h2 id=\"lower-bound-和-upper-bound\"><a href=\"#lower-bound-和-upper-bound\" class=\"headerlink\" title=\"lower_bound()和 upper_bound()\"></a>lower_bound()和 upper_bound()</h2><p><strong>lower_bound(const Key&amp; key)</strong><br><a href=\"https://zh.cppreference.com/w/cpp/container/map/lower_bound\" target=\"_blank\" rel=\"noopener\">https://zh.cppreference.com/w/cpp/container/map/lower_bound</a><br>返回指向首个不小于 key 的元素的迭代器。若找不到这种元素，则返回尾后迭代器</p>\n<p><strong>upper_bound()</strong><br>返回指向首个大于 key 的元素的迭代器。</p>\n<h1 id=\"vertor\"><a href=\"#vertor\" class=\"headerlink\" title=\"vertor\"></a>vertor</h1><table>\n<thead>\n<tr>\n<th>函数名称</th>\n<th>使用详解</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>at []</td>\n<td>获取指定位置的元素 有边界检查</td>\n</tr>\n<tr>\n<td>insert</td>\n<td>在指定位置的前面插入, 可以插入单项, vector和数组</td>\n</tr>\n<tr>\n<td>max_size</td>\n<td>理论最大容量</td>\n</tr>\n<tr>\n<td>capacity</td>\n<td>实际最大容量</td>\n</tr>\n</tbody></table>\n<h1 id=\"图片Warn\"><a href=\"#图片Warn\" class=\"headerlink\" title=\"图片Warn\"></a>图片Warn</h1><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8.png\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8.png\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8.png\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/STL%E8%AE%B0%E5%BD%95/%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8.png\" alt=\"\"></p>\n"},{"title":"编程规范","date":"2020-01-23T11:35:50.502Z","_content":"\n**第一点**\n有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. \n```c++\n// 推荐\nnamespace myproject {\nnamespace foo_bar {\nvoid Function1();\nvoid Function2();\n}  // namespace foo_bar\n}  // namespace myproject\n\n// 不推荐\nnamespace myproject {\nclass FooBar {\n public:\n  static void Function1();\n  static void Function2();\n};\n}  // namespace myproject\n```\n\n**第二点**\n局部变量应当声明和初始化同时进行, 推荐使用C++11的花括号\n\n*如果在循环中, 不要将对象的声明放入其中*, 每次进入作用域都会调用构造函数, 每次退出都会调用析构函数\n\n**第三点-类相关**\n不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.\n\n不要定义隐式类型转换. \n\n对于转换运算符和单参数构造函数, 请使用 explicit 关键字.\n- 单参数构造函数有可能会被无意地用作隐式类型转换.\n\n如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.\n- MyClass(const MyClass&) = delete;\n- MyClass& operator=(const MyClass&) = delete;\n\n仅当`只有`数据成员的时候`struct`, `其他一律`使用class\n\n使用组合常常比使用继承更合理\n- 所有的继承`必须是public`, \n\n多重继承(真正需要的时候很少)\n- 最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.\n\n除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量\n- 重载运算符, 容易造成代码混乱, 因为没有统一的重载规范\n\n数据成员都必须是私有的\n\n**第四点-函数相关**\n\n输入参数在先, 后跟输出参数.\n\n编写简短函数\n\n所有按引用传递的参数必须加上 const.\n\n函数重载\n- 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,\n而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.\n- 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.\n\n省却参数\n\n函数返回类型后置语法\n- `auto foo(int x) -> int` 对于简单的类型, 优点体现不出\n- 对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别?????.\n\n**杂项**\n在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。\n\n**第五点命名-版本最多的地方**\n\n文件命名\n- 全部小写包含`_`最好\n- C++ 文件要以 .cc 结尾, 头文件以 .h 结尾.\n\n类型名称 - 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数\n- 类型名称的每个单词首字母均大写, 不包含下划线`MyExcitingClass`\n\n变量命名\n- 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾\n\n常量命名\n- 全部大写\n- 声明为 constexpr 或 const\n\n函数命名\n- 每个单词首字母大写, 没有下划线\n- 首字母缩写的单词, 经常对其的第一个字母大写\n\n命名空间命名\n- 小写字母命名\n\n枚举命名\n- 枚举的命名应当和 常量 或 宏 一致\n\n**第六点-格式**\n\n缩进四个空格\n\n函数定义与声明\n- 左圆括号总是和函数名在同一行.(没有标准,,,,,,,,,, emmm 我想我还是换行吧)\n- 函数名和左圆括号间永远没有空格.\n- 圆括号与参数间没有空格.\n\n","source":"_posts/CPP-CPP重点-编程规范.md","raw":"title: 编程规范\ntags:\n  - null\ncategories:\n  - CPP\n  - CPP重点\ndate: 2019-10-2518:06:46\n---\n\n**第一点**\n有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. \n```c++\n// 推荐\nnamespace myproject {\nnamespace foo_bar {\nvoid Function1();\nvoid Function2();\n}  // namespace foo_bar\n}  // namespace myproject\n\n// 不推荐\nnamespace myproject {\nclass FooBar {\n public:\n  static void Function1();\n  static void Function2();\n};\n}  // namespace myproject\n```\n\n**第二点**\n局部变量应当声明和初始化同时进行, 推荐使用C++11的花括号\n\n*如果在循环中, 不要将对象的声明放入其中*, 每次进入作用域都会调用构造函数, 每次退出都会调用析构函数\n\n**第三点-类相关**\n不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.\n\n不要定义隐式类型转换. \n\n对于转换运算符和单参数构造函数, 请使用 explicit 关键字.\n- 单参数构造函数有可能会被无意地用作隐式类型转换.\n\n如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.\n- MyClass(const MyClass&) = delete;\n- MyClass& operator=(const MyClass&) = delete;\n\n仅当`只有`数据成员的时候`struct`, `其他一律`使用class\n\n使用组合常常比使用继承更合理\n- 所有的继承`必须是public`, \n\n多重继承(真正需要的时候很少)\n- 最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.\n\n除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量\n- 重载运算符, 容易造成代码混乱, 因为没有统一的重载规范\n\n数据成员都必须是私有的\n\n**第四点-函数相关**\n\n输入参数在先, 后跟输出参数.\n\n编写简短函数\n\n所有按引用传递的参数必须加上 const.\n\n函数重载\n- 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,\n而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.\n- 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.\n\n省却参数\n\n函数返回类型后置语法\n- `auto foo(int x) -> int` 对于简单的类型, 优点体现不出\n- 对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别?????.\n\n**杂项**\n在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。\n\n**第五点命名-版本最多的地方**\n\n文件命名\n- 全部小写包含`_`最好\n- C++ 文件要以 .cc 结尾, 头文件以 .h 结尾.\n\n类型名称 - 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数\n- 类型名称的每个单词首字母均大写, 不包含下划线`MyExcitingClass`\n\n变量命名\n- 变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾\n\n常量命名\n- 全部大写\n- 声明为 constexpr 或 const\n\n函数命名\n- 每个单词首字母大写, 没有下划线\n- 首字母缩写的单词, 经常对其的第一个字母大写\n\n命名空间命名\n- 小写字母命名\n\n枚举命名\n- 枚举的命名应当和 常量 或 宏 一致\n\n**第六点-格式**\n\n缩进四个空格\n\n函数定义与声明\n- 左圆括号总是和函数名在同一行.(没有标准,,,,,,,,,, emmm 我想我还是换行吧)\n- 函数名和左圆括号间永远没有空格.\n- 圆括号与参数间没有空格.\n\n","slug":"CPP-CPP重点-编程规范","published":1,"updated":"2020-03-05T13:58:34.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucuu000k8cuo3tc92b6d","content":"<p><strong>第一点</strong><br>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 推荐</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> myproject &#123;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> foo_bar &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Function1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Function2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace foo_bar</span></span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace myproject</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不推荐</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> myproject &#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooBar</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Function1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Function2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace myproject</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>第二点</strong><br>局部变量应当声明和初始化同时进行, 推荐使用C++11的花括号</p>\n<p><em>如果在循环中, 不要将对象的声明放入其中</em>, 每次进入作用域都会调用构造函数, 每次退出都会调用析构函数</p>\n<p><strong>第三点-类相关</strong><br>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p>\n<p>不要定义隐式类型转换. </p>\n<p>对于转换运算符和单参数构造函数, 请使用 explicit 关键字.</p>\n<ul>\n<li>单参数构造函数有可能会被无意地用作隐式类型转换.</li>\n</ul>\n<p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p>\n<ul>\n<li>MyClass(const MyClass&amp;) = delete;</li>\n<li>MyClass&amp; operator=(const MyClass&amp;) = delete;</li>\n</ul>\n<p>仅当<code>只有</code>数据成员的时候<code>struct</code>, <code>其他一律</code>使用class</p>\n<p>使用组合常常比使用继承更合理</p>\n<ul>\n<li>所有的继承<code>必须是public</code>, </li>\n</ul>\n<p>多重继承(真正需要的时候很少)</p>\n<ul>\n<li>最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.</li>\n</ul>\n<p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量</p>\n<ul>\n<li>重载运算符, 容易造成代码混乱, 因为没有统一的重载规范</li>\n</ul>\n<p>数据成员都必须是私有的</p>\n<p><strong>第四点-函数相关</strong></p>\n<p>输入参数在先, 后跟输出参数.</p>\n<p>编写简短函数</p>\n<p>所有按引用传递的参数必须加上 const.</p>\n<p>函数重载</p>\n<ul>\n<li>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,<br>而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</li>\n<li>如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.</li>\n</ul>\n<p>省却参数</p>\n<p>函数返回类型后置语法</p>\n<ul>\n<li><code>auto foo(int x) -&gt; int</code> 对于简单的类型, 优点体现不出</li>\n<li>对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别?????.</li>\n</ul>\n<p><strong>杂项</strong><br>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p>\n<p><strong>第五点命名-版本最多的地方</strong></p>\n<p>文件命名</p>\n<ul>\n<li>全部小写包含<code>_</code>最好</li>\n<li>C++ 文件要以 .cc 结尾, 头文件以 .h 结尾.</li>\n</ul>\n<p>类型名称 - 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数</p>\n<ul>\n<li>类型名称的每个单词首字母均大写, 不包含下划线<code>MyExcitingClass</code></li>\n</ul>\n<p>变量命名</p>\n<ul>\n<li>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾</li>\n</ul>\n<p>常量命名</p>\n<ul>\n<li>全部大写</li>\n<li>声明为 constexpr 或 const</li>\n</ul>\n<p>函数命名</p>\n<ul>\n<li>每个单词首字母大写, 没有下划线</li>\n<li>首字母缩写的单词, 经常对其的第一个字母大写</li>\n</ul>\n<p>命名空间命名</p>\n<ul>\n<li>小写字母命名</li>\n</ul>\n<p>枚举命名</p>\n<ul>\n<li>枚举的命名应当和 常量 或 宏 一致</li>\n</ul>\n<p><strong>第六点-格式</strong></p>\n<p>缩进四个空格</p>\n<p>函数定义与声明</p>\n<ul>\n<li>左圆括号总是和函数名在同一行.(没有标准,,,,,,,,,, emmm 我想我还是换行吧)</li>\n<li>函数名和左圆括号间永远没有空格.</li>\n<li>圆括号与参数间没有空格.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>第一点</strong><br>有时, 把函数的定义同类的实例脱钩是有益的, 甚至是必要的. 这样的函数可以被定义成静态成员, 或是非成员函数. 非成员函数不应依赖于外部变量, 应尽量置于某个命名空间内. </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 推荐</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> myproject &#123;</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> foo_bar &#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Function1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Function2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace foo_bar</span></span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace myproject</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不推荐</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> myproject &#123;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooBar</span> &#123;</span></span><br><span class=\"line\"> <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Function1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">Function2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;  <span class=\"comment\">// namespace myproject</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>第二点</strong><br>局部变量应当声明和初始化同时进行, 推荐使用C++11的花括号</p>\n<p><em>如果在循环中, 不要将对象的声明放入其中</em>, 每次进入作用域都会调用构造函数, 每次退出都会调用析构函数</p>\n<p><strong>第三点-类相关</strong><br>不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.</p>\n<p>不要定义隐式类型转换. </p>\n<p>对于转换运算符和单参数构造函数, 请使用 explicit 关键字.</p>\n<ul>\n<li>单参数构造函数有可能会被无意地用作隐式类型转换.</li>\n</ul>\n<p>如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.</p>\n<ul>\n<li>MyClass(const MyClass&amp;) = delete;</li>\n<li>MyClass&amp; operator=(const MyClass&amp;) = delete;</li>\n</ul>\n<p>仅当<code>只有</code>数据成员的时候<code>struct</code>, <code>其他一律</code>使用class</p>\n<p>使用组合常常比使用继承更合理</p>\n<ul>\n<li>所有的继承<code>必须是public</code>, </li>\n</ul>\n<p>多重继承(真正需要的时候很少)</p>\n<ul>\n<li>最多只有一个基类是非抽象类; 其它基类都是以 Interface 为后缀的 纯接口类.</li>\n</ul>\n<p>除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量</p>\n<ul>\n<li>重载运算符, 容易造成代码混乱, 因为没有统一的重载规范</li>\n</ul>\n<p>数据成员都必须是私有的</p>\n<p><strong>第四点-函数相关</strong></p>\n<p>输入参数在先, 后跟输出参数.</p>\n<p>编写简短函数</p>\n<p>所有按引用传递的参数必须加上 const.</p>\n<p>函数重载</p>\n<ul>\n<li>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹,<br>而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.</li>\n<li>如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用 std::vector 以便使用者可以用 列表初始化 指定参数.</li>\n</ul>\n<p>省却参数</p>\n<p>函数返回类型后置语法</p>\n<ul>\n<li><code>auto foo(int x) -&gt; int</code> 对于简单的类型, 优点体现不出</li>\n<li>对于复杂的情况, 例如类域中的类型声明或者以函数参数的形式书写的类型, 写法的不同会造成区别?????.</li>\n</ul>\n<p><strong>杂项</strong><br>在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。</p>\n<p><strong>第五点命名-版本最多的地方</strong></p>\n<p>文件命名</p>\n<ul>\n<li>全部小写包含<code>_</code>最好</li>\n<li>C++ 文件要以 .cc 结尾, 头文件以 .h 结尾.</li>\n</ul>\n<p>类型名称 - 类, 结构体, 类型定义 (typedef), 枚举, 类型模板参数</p>\n<ul>\n<li>类型名称的每个单词首字母均大写, 不包含下划线<code>MyExcitingClass</code></li>\n</ul>\n<p>变量命名</p>\n<ul>\n<li>变量 (包括函数参数) 和数据成员名一律小写, 单词之间用下划线连接. 类的成员变量以下划线结尾</li>\n</ul>\n<p>常量命名</p>\n<ul>\n<li>全部大写</li>\n<li>声明为 constexpr 或 const</li>\n</ul>\n<p>函数命名</p>\n<ul>\n<li>每个单词首字母大写, 没有下划线</li>\n<li>首字母缩写的单词, 经常对其的第一个字母大写</li>\n</ul>\n<p>命名空间命名</p>\n<ul>\n<li>小写字母命名</li>\n</ul>\n<p>枚举命名</p>\n<ul>\n<li>枚举的命名应当和 常量 或 宏 一致</li>\n</ul>\n<p><strong>第六点-格式</strong></p>\n<p>缩进四个空格</p>\n<p>函数定义与声明</p>\n<ul>\n<li>左圆括号总是和函数名在同一行.(没有标准,,,,,,,,,, emmm 我想我还是换行吧)</li>\n<li>函数名和左圆括号间永远没有空格.</li>\n<li>圆括号与参数间没有空格.</li>\n</ul>\n"},{"title":"字节对齐","date":"2020-02-06T03:38:08.000Z","img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png","_content":"以前在牛客碰到不少字节对齐的题目, 当时只是为了记住而记住 今天我在学习自定义TCP二进制数据包\n的时候 遇到了必须考虑下字节对齐的情景.\n\n**解释**\n现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。--百度百科\n\n**原因**\n各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况\n但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。--百度百科\n\n\n```c++\nstruct Foo\n{\n\tchar foo1;\n    int foo2;\n    short foo3;\n}\n\nsizeof(Foo) = 12\nsizeof(char) + sizeof(int) + sizeof(short) = 7\n```\n说明内存中并不是连续存储的这三个变量;\n\n```c++\nFoo foo1{'1', 2, 3};\nwrite(fd, &foo1, sizeof(foo1));\n```\n// hexdump 查看\n0000000 5631 0000 0002 0000 0003 0000\n对应图示如下\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png)\n\n第一字节 0x31 正好是 '1' *蓝色区域*\n二三四字节 为填充 *红色区域*\n因为sizeof(int)=4所以foo2的偏移量是四的倍数 , 故需要填充三个字节 3+1 = 4\n\n第五六七八字节 0x02对应2 *灰色区域*\n这里没有填充是因为sizeof(short)=2所以foo3的偏移量是2的倍数 由于偏移量是8 所以不需要填充\n\n第九十字节 0x03 对应3\n第十一十二字节填充*黑色区域*\n因为此结构中最大的sizeof()=4所以需要将字节数对齐到4的倍数 目前10字节 所以需要填充2字节到\n12字节满足四的倍数","source":"_posts/CPP-CPP重点-字节对齐.md","raw":"---\ntitle: 字节对齐\ndate: 2020-02-06 11:38:08\ntags:\ncategories:\n  - CPP\n  - CPP重点\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png\n---\n以前在牛客碰到不少字节对齐的题目, 当时只是为了记住而记住 今天我在学习自定义TCP二进制数据包\n的时候 遇到了必须考虑下字节对齐的情景.\n\n**解释**\n现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。--百度百科\n\n**原因**\n各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况\n但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。--百度百科\n\n\n```c++\nstruct Foo\n{\n\tchar foo1;\n    int foo2;\n    short foo3;\n}\n\nsizeof(Foo) = 12\nsizeof(char) + sizeof(int) + sizeof(short) = 7\n```\n说明内存中并不是连续存储的这三个变量;\n\n```c++\nFoo foo1{'1', 2, 3};\nwrite(fd, &foo1, sizeof(foo1));\n```\n// hexdump 查看\n0000000 5631 0000 0002 0000 0003 0000\n对应图示如下\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png)\n\n第一字节 0x31 正好是 '1' *蓝色区域*\n二三四字节 为填充 *红色区域*\n因为sizeof(int)=4所以foo2的偏移量是四的倍数 , 故需要填充三个字节 3+1 = 4\n\n第五六七八字节 0x02对应2 *灰色区域*\n这里没有填充是因为sizeof(short)=2所以foo3的偏移量是2的倍数 由于偏移量是8 所以不需要填充\n\n第九十字节 0x03 对应3\n第十一十二字节填充*黑色区域*\n因为此结构中最大的sizeof()=4所以需要将字节数对齐到4的倍数 目前10字节 所以需要填充2字节到\n12字节满足四的倍数","slug":"CPP-CPP重点-字节对齐","published":1,"updated":"2020-02-07T08:38:13.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucuv000n8cuo7n5x6ic1","content":"<p>以前在牛客碰到不少字节对齐的题目, 当时只是为了记住而记住 今天我在学习自定义TCP二进制数据包<br>的时候 遇到了必须考虑下字节对齐的情景.</p>\n<p><strong>解释</strong><br>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。–百度百科</p>\n<p><strong>原因</strong><br>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况<br>但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。–百度百科</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> foo1;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> foo2;</span><br><span class=\"line\">    short foo3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span>(Foo) = <span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) + <span class=\"keyword\">sizeof</span>(short) = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<p>说明内存中并不是连续存储的这三个变量;</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo foo1&#123;<span class=\"string\">'1'</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">write</span>(fd, &amp;foo1, <span class=\"keyword\">sizeof</span>(foo1));</span><br></pre></td></tr></table></figure>\n<p>// hexdump 查看<br>0000000 5631 0000 0002 0000 0003 0000<br>对应图示如下<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png\" alt=\"\"></p>\n<p>第一字节 0x31 正好是 ‘1’ <em>蓝色区域</em><br>二三四字节 为填充 <em>红色区域</em><br>因为sizeof(int)=4所以foo2的偏移量是四的倍数 , 故需要填充三个字节 3+1 = 4</p>\n<p>第五六七八字节 0x02对应2 <em>灰色区域</em><br>这里没有填充是因为sizeof(short)=2所以foo3的偏移量是2的倍数 由于偏移量是8 所以不需要填充</p>\n<p>第九十字节 0x03 对应3<br>第十一十二字节填充<em>黑色区域</em><br>因为此结构中最大的sizeof()=4所以需要将字节数对齐到4的倍数 目前10字节 所以需要填充2字节到<br>12字节满足四的倍数</p>\n","site":{"data":{}},"excerpt":"","more":"<p>以前在牛客碰到不少字节对齐的题目, 当时只是为了记住而记住 今天我在学习自定义TCP二进制数据包<br>的时候 遇到了必须考虑下字节对齐的情景.</p>\n<p><strong>解释</strong><br>现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。–百度百科</p>\n<p><strong>原因</strong><br>各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况<br>但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。–百度百科</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Foo</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> foo1;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> foo2;</span><br><span class=\"line\">    short foo3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span>(Foo) = <span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) + <span class=\"keyword\">sizeof</span>(short) = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n<p>说明内存中并不是连续存储的这三个变量;</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo foo1&#123;<span class=\"string\">'1'</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">write</span>(fd, &amp;foo1, <span class=\"keyword\">sizeof</span>(foo1));</span><br></pre></td></tr></table></figure>\n<p>// hexdump 查看<br>0000000 5631 0000 0002 0000 0003 0000<br>对应图示如下<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png\" alt=\"\"></p>\n<p>第一字节 0x31 正好是 ‘1’ <em>蓝色区域</em><br>二三四字节 为填充 <em>红色区域</em><br>因为sizeof(int)=4所以foo2的偏移量是四的倍数 , 故需要填充三个字节 3+1 = 4</p>\n<p>第五六七八字节 0x02对应2 <em>灰色区域</em><br>这里没有填充是因为sizeof(short)=2所以foo3的偏移量是2的倍数 由于偏移量是8 所以不需要填充</p>\n<p>第九十字节 0x03 对应3<br>第十一十二字节填充<em>黑色区域</em><br>因为此结构中最大的sizeof()=4所以需要将字节数对齐到4的倍数 目前10字节 所以需要填充2字节到<br>12字节满足四的倍数</p>\n"},{"title":"Send返回值引出的(非)阻塞IO","date":"2020-03-20T03:14:20.000Z","_content":"# 现存疑问\n1. WNOWAIT和O_NONBLOCK 的关系?\n2. 当非阻塞send时, 返回值与什么有关? 本地socket发送缓冲区空余还是对端空余?\n3. 对端接收缓冲区满了会发生什么?\n4. 暂且认为send返回值是拷贝到缓冲区中的字节数, 如果这些数据没有成功发送呢?\n5. send函数发送的字节数 超出了recv端的接受能力 会发生什么?\n\n最近这两天在实战一个http服务器的编写.\n\n遇到了一个问题: send的返回值小于传入的len, 因为我仅调用一次send函数 导致页面一直显示加载\n\n然后找了下为什么? 什么时候? send返回值会小于len;\n\n# send\nhttps://stackoverflow.com/questions/14700906/socket-programming-send-return-value\n\n```\nIn practice, send() in blocking mode sends all the data, regardless of what the documentation says, unless there was an error, in which case nothing is sent.\n实战中, send() 处于阻塞状态会发送所有的数据, 除非发生错误 但这会导致数据没有发送\n\nIn non-blocking mode, it sends whatever will fit into the socket send buffer and returns that length if > 0. If the socket send buffer is full, it returns -1 with errno = EWOULDBLOCK/EAGAIN.\n在非阻塞模式下, 只要能放入socket发送缓冲区 就返回放入的长度 如果缓冲区满了就返回-1 设置EWOULDBLOCK/EAGAIN\n```\n\n[非阻塞模式下 send 和 recv 函数的返回值](https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247486643&idx=1&sn=9db678398f390759ff81b354ef056000&chksm=fc70f75fcb077e49363b087ba45609fdfbcba286338e70c2d4c7092e83e2d3feac56455e02a2&scene=27#wechat_redirect)\n\n这篇博客里也说明了这个问题. 下面是原博客的代码稍作修改\n```c++\n//推荐的方式二：在一个循环里面根据偏移量发送数据\nbool SendData(const char* buf , int buf_length)\n{\n    //已发送的字节数目\n    int sent_bytes = 0;\n    int ret = 0;\n    while (true)\n    {\n        ret = send(fd, buf + sent_bytes, buf_length - sent_bytes, 0);\n        if (ret == -1)\n        {\n            if (errno == EAGIN)\n            {\n                //严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍\n                break;\n            }             \n            else if (errno == EINTR)\n            {\n                continue;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else if (ret == 0)\n        {\n            //认为对端关闭了连接\n            return false;\n        }\n\n        sent_bytes += ret;\n        if (sent_bytes == buf_length)\n        {\n            break;\n        }\n        //稍稍降低 CPU 的使用率\n        usleep(1);\n    }\n    return true;\n}\n```","source":"_posts/CPP-Socket理论-Send返回值探析.md","raw":"---\ntitle: Send返回值引出的(非)阻塞IO\ndate: 2020-03-20 11:14:20\ntags:\ncategories:\n  - CPP\n  - Socket理论\n---\n# 现存疑问\n1. WNOWAIT和O_NONBLOCK 的关系?\n2. 当非阻塞send时, 返回值与什么有关? 本地socket发送缓冲区空余还是对端空余?\n3. 对端接收缓冲区满了会发生什么?\n4. 暂且认为send返回值是拷贝到缓冲区中的字节数, 如果这些数据没有成功发送呢?\n5. send函数发送的字节数 超出了recv端的接受能力 会发生什么?\n\n最近这两天在实战一个http服务器的编写.\n\n遇到了一个问题: send的返回值小于传入的len, 因为我仅调用一次send函数 导致页面一直显示加载\n\n然后找了下为什么? 什么时候? send返回值会小于len;\n\n# send\nhttps://stackoverflow.com/questions/14700906/socket-programming-send-return-value\n\n```\nIn practice, send() in blocking mode sends all the data, regardless of what the documentation says, unless there was an error, in which case nothing is sent.\n实战中, send() 处于阻塞状态会发送所有的数据, 除非发生错误 但这会导致数据没有发送\n\nIn non-blocking mode, it sends whatever will fit into the socket send buffer and returns that length if > 0. If the socket send buffer is full, it returns -1 with errno = EWOULDBLOCK/EAGAIN.\n在非阻塞模式下, 只要能放入socket发送缓冲区 就返回放入的长度 如果缓冲区满了就返回-1 设置EWOULDBLOCK/EAGAIN\n```\n\n[非阻塞模式下 send 和 recv 函数的返回值](https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247486643&idx=1&sn=9db678398f390759ff81b354ef056000&chksm=fc70f75fcb077e49363b087ba45609fdfbcba286338e70c2d4c7092e83e2d3feac56455e02a2&scene=27#wechat_redirect)\n\n这篇博客里也说明了这个问题. 下面是原博客的代码稍作修改\n```c++\n//推荐的方式二：在一个循环里面根据偏移量发送数据\nbool SendData(const char* buf , int buf_length)\n{\n    //已发送的字节数目\n    int sent_bytes = 0;\n    int ret = 0;\n    while (true)\n    {\n        ret = send(fd, buf + sent_bytes, buf_length - sent_bytes, 0);\n        if (ret == -1)\n        {\n            if (errno == EAGIN)\n            {\n                //严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍\n                break;\n            }             \n            else if (errno == EINTR)\n            {\n                continue;\n            }\n            else\n            {\n                return false;\n            }\n        }\n        else if (ret == 0)\n        {\n            //认为对端关闭了连接\n            return false;\n        }\n\n        sent_bytes += ret;\n        if (sent_bytes == buf_length)\n        {\n            break;\n        }\n        //稍稍降低 CPU 的使用率\n        usleep(1);\n    }\n    return true;\n}\n```","slug":"CPP-Socket理论-Send返回值探析","published":1,"updated":"2020-03-20T04:20:31.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucuw000p8cuoccmfcael","content":"<h1 id=\"现存疑问\"><a href=\"#现存疑问\" class=\"headerlink\" title=\"现存疑问\"></a>现存疑问</h1><ol>\n<li>WNOWAIT和O_NONBLOCK 的关系?</li>\n<li>当非阻塞send时, 返回值与什么有关? 本地socket发送缓冲区空余还是对端空余?</li>\n<li>对端接收缓冲区满了会发生什么?</li>\n<li>暂且认为send返回值是拷贝到缓冲区中的字节数, 如果这些数据没有成功发送呢?</li>\n<li>send函数发送的字节数 超出了recv端的接受能力 会发生什么?</li>\n</ol>\n<p>最近这两天在实战一个http服务器的编写.</p>\n<p>遇到了一个问题: send的返回值小于传入的len, 因为我仅调用一次send函数 导致页面一直显示加载</p>\n<p>然后找了下为什么? 什么时候? send返回值会小于len;</p>\n<h1 id=\"send\"><a href=\"#send\" class=\"headerlink\" title=\"send\"></a>send</h1><p><a href=\"https://stackoverflow.com/questions/14700906/socket-programming-send-return-value\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/14700906/socket-programming-send-return-value</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In practice, send() in blocking mode sends all the data, regardless of what the documentation says, unless there was an error, in which case nothing is sent.</span><br><span class=\"line\">实战中, send() 处于阻塞状态会发送所有的数据, 除非发生错误 但这会导致数据没有发送</span><br><span class=\"line\"></span><br><span class=\"line\">In non-blocking mode, it sends whatever will fit into the socket send buffer and returns that length if &gt; 0. If the socket send buffer is full, it returns -1 with errno &#x3D; EWOULDBLOCK&#x2F;EAGAIN.</span><br><span class=\"line\">在非阻塞模式下, 只要能放入socket发送缓冲区 就返回放入的长度 如果缓冲区满了就返回-1 设置EWOULDBLOCK&#x2F;EAGAIN</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247486643&idx=1&sn=9db678398f390759ff81b354ef056000&chksm=fc70f75fcb077e49363b087ba45609fdfbcba286338e70c2d4c7092e83e2d3feac56455e02a2&scene=27#wechat_redirect\" target=\"_blank\" rel=\"noopener\">非阻塞模式下 send 和 recv 函数的返回值</a></p>\n<p>这篇博客里也说明了这个问题. 下面是原博客的代码稍作修改</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//推荐的方式二：在一个循环里面根据偏移量发送数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SendData</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* buf , <span class=\"keyword\">int</span> buf_length)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//已发送的字节数目</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sent_bytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ret = send(fd, buf + sent_bytes, buf_length - sent_bytes, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (errno == EAGIN)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;             </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (errno == EINTR)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//认为对端关闭了连接</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sent_bytes += ret;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sent_bytes == buf_length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//稍稍降低 CPU 的使用率</span></span><br><span class=\"line\">        usleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"现存疑问\"><a href=\"#现存疑问\" class=\"headerlink\" title=\"现存疑问\"></a>现存疑问</h1><ol>\n<li>WNOWAIT和O_NONBLOCK 的关系?</li>\n<li>当非阻塞send时, 返回值与什么有关? 本地socket发送缓冲区空余还是对端空余?</li>\n<li>对端接收缓冲区满了会发生什么?</li>\n<li>暂且认为send返回值是拷贝到缓冲区中的字节数, 如果这些数据没有成功发送呢?</li>\n<li>send函数发送的字节数 超出了recv端的接受能力 会发生什么?</li>\n</ol>\n<p>最近这两天在实战一个http服务器的编写.</p>\n<p>遇到了一个问题: send的返回值小于传入的len, 因为我仅调用一次send函数 导致页面一直显示加载</p>\n<p>然后找了下为什么? 什么时候? send返回值会小于len;</p>\n<h1 id=\"send\"><a href=\"#send\" class=\"headerlink\" title=\"send\"></a>send</h1><p><a href=\"https://stackoverflow.com/questions/14700906/socket-programming-send-return-value\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/14700906/socket-programming-send-return-value</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In practice, send() in blocking mode sends all the data, regardless of what the documentation says, unless there was an error, in which case nothing is sent.</span><br><span class=\"line\">实战中, send() 处于阻塞状态会发送所有的数据, 除非发生错误 但这会导致数据没有发送</span><br><span class=\"line\"></span><br><span class=\"line\">In non-blocking mode, it sends whatever will fit into the socket send buffer and returns that length if &gt; 0. If the socket send buffer is full, it returns -1 with errno &#x3D; EWOULDBLOCK&#x2F;EAGAIN.</span><br><span class=\"line\">在非阻塞模式下, 只要能放入socket发送缓冲区 就返回放入的长度 如果缓冲区满了就返回-1 设置EWOULDBLOCK&#x2F;EAGAIN</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU2MTkwMTE4Nw==&mid=2247486643&idx=1&sn=9db678398f390759ff81b354ef056000&chksm=fc70f75fcb077e49363b087ba45609fdfbcba286338e70c2d4c7092e83e2d3feac56455e02a2&scene=27#wechat_redirect\" target=\"_blank\" rel=\"noopener\">非阻塞模式下 send 和 recv 函数的返回值</a></p>\n<p>这篇博客里也说明了这个问题. 下面是原博客的代码稍作修改</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//推荐的方式二：在一个循环里面根据偏移量发送数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SendData</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* buf , <span class=\"keyword\">int</span> buf_length)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//已发送的字节数目</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sent_bytes = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ret = send(fd, buf + sent_bytes, buf_length - sent_bytes, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (errno == EAGIN)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">//严谨的做法，这里如果发不出去，应该缓存尚未发出去的数据，后面介绍</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;             </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (errno == EINTR)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">//认为对端关闭了连接</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        sent_bytes += ret;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sent_bytes == buf_length)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//稍稍降低 CPU 的使用率</span></span><br><span class=\"line\">        usleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Libevent代码初期了解","date":"2020-02-19T06:56:55.000Z","img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Libevent%E5%B0%81%E9%9D%A2.png","_content":"学习来源\n<Linux 高性能服务器编程>\n# I/O框架库概述\n## Reactor模式\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-1IO%E6%A1%86%E6%9E%B6%E7%BB%84%E7%BB%84%E4%BB%B6.png)\n句柄(Handler)\n由于统一了事件源, 一个事件一般跟一个句柄绑定在一起, 事件就绪之后 会通过句柄通知这一个事件.\n在Linux中 I/O 事件对应的句柄->文件描述符, 信号事件->信号值\n\n事件多路分发器(EventDemultiplexer)\n事件的到来是随机的, 异步的. 所以只能通过一个循环一直等待事件并进行处理 --- 事件循环\n一般通过IO复用实现 select poll epoll_wait\n\n事件处理器(EventHandle)\n具体事件处理器(ConcreteEventHandler)\n事件处理器执行事件对应的业务逻辑, 通常包含一个或多个handler_event回调函数, 这些回调函数在事件循环中被执行\n\nReactor\nhandler_events: 执行事件循环 重复等待事件, 然后依次调用对应的事件处理器\nregister_handler: 向事件多路分发器中注册事件\nremove_handler: 从中删除一个事件\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-2%20IO%E6%A1%86%E6%9E%B6%E5%BA%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE.png)\n\n## Libevent源码分析\n```c++\n#include <sys/signal.h>\n#include <event.h>\n#include <cstdio>\n\nvoid signal_cb(int fd, short event, void* argc)\n{\n    event_base* base = (event_base*)argc;\n    timeval delay = {2, 0};\n\n    printf(\"Caught an interrupt signal\\n\");\n    event_base_loopexit(base, &delay);\n}\n\nvoid timeout_cb(int fd, short event, void* argc)\n{\n    printf(\"timeout\\n\");\n}\nint main()\n{\n    // 相当于创建一个Reactor实例\n    event_base* base = event_init();\n    \n    event* signal_event = evsignal_new(base, SIGINT, signal_cb, base);\n    event_add(signal_event, nullptr);\n    \n    event* timeout_event = evtimer_new(base, timeout_cb, nullptr);\n    timeval tv{1, 0};\n    event_add(timeout_event, &tv);\n    \n    event_base_dispatch(base);\n    event_free(signal_event);\n    event_free(timeout_event);\n    event_base_free(base);\n}\n```\n创建一个事件处理器 然后为绑定上相应的回调函数.\n然后把这个事件处理器注册到事件队列中中,\n\n然后事件多路分发器依靠循环一直等待事件的到来, 事件到来后通知相应的事件处理器\nReactor则管理这些\n\n首先要去了解下 `事件处理器` 对应的就是event这个结构体\n```c++\nstruct event {\n\tstruct event_callback ev_evcallback;\n\n\t// 事件处理器从属的 event_base\n\tstruct event_base *ev_base;\n\t// 信号值 或者 文件描述符\n\tevutil_socket_t ev_fd;\n\t// 定时器的超时时间\n\tstruct timeval ev_timeout;\n\t\n\t// 仅用于定时事件\n\tunion {\n\t\t// 队列--指出在通用定时器中的位置\n\t\tTAILQ_ENTRY(event) ev_next_with_common_timeout;\n\t\t// 时间堆--指出了在时间堆中的位置\n\t\tint min_heap_idx;\n\t} ev_timeout_pos;\n\n\tunion {\n\t\tstruct {\n\t\t\t// 通过这个成员 将具有相同文件描述符的IO事件处理器串联起来\n\t\t\tLIST_ENTRY (event) ev_io_next;\n\t\t\tstruct timeval ev_timeout;\n\t\t} ev_io;\n\t\tstruct {\n\t\t\t// 相同信号的串联起来\n\t\t\tLIST_ENTRY (event) ev_signal_next;\n\t\t\tshort ev_ncalls;\n\t\t\t/* Allows deletes in callback */\n\t\t\tshort *ev_pncalls;\n\t\t} ev_signal;\n\t} ev_;\n\n\t// 事件类型, 可以通过位处理设置非互斥事件\n\tshort ev_events;\n\t// 当前激活事件的类型, 说明被激活的原因\n\tshort ev_res;\n};\n```\n可以看到其中有很多的属性, 三种事件对应的不同的属性.\n\n这些属性的填充函数\n`evsignal_new``evtimer_new`是宏 统一调用`event_new`\n`event_new`调用`event_assign`来进行主要的填充\n\n\n```\n//@通过宏封装注册函数\n\n一个事件生成函数 经过宏的封装(可以自动填充某些此事件用不到的参数)可以更方便的对应不同事件的生成, 既统一了注册, 又方便用户调用\n```\n属性之一便是回调函数, 事件回调函数有自己的规定\n```\n//@统一事件回调函数\n\nvoid (*callback)(evutil_socket_t, short, void *)\n这样能够统一回调函数的格式, 同时方便管理\n```\n事件处理器创建完毕, 该把事件处理器添加到事件注册队列. 样例代码中通过的`event_add`函数来实现将事件处理器添加到事件注册队列\n`event_add`实际由`event_add_nolock_`实现 所以接下来是`event_add_nolock_`函数的说明\n\n```\n//@事件处理器的分发实现\n将传入的event按照不同类型的事件处理器 分别处理\n(因为event_new已经填充了ev_events说明事件类型)\n\nIO事件 添加绑定\n信号事件 绑定相应的信号\n定时器 放入相关的的时间管理数据结构中\n```\n使用`event_queue_insert_inserted`进行注册\n这里的代码2.1.11 与书上的差别较大, 少了多一半的功能, 也没有被抽成函数, 暂不知道对应的功能代码去了哪里\n照书上来说`event_queue_insert_inserted`实现的是将事件处理器加入到`event_base`的某个事件队列中. 对于新添加的IO和信号事件处理器, 还需要让事件多路分发器来监听对应的事件, 然后建立相应的映射关系. 分别使用`evmap_io_add_`和`evmap_signal_add_`(相当于图中的`register_event`)建立映射. \n\n`evmap_io_add_`中有一个结构体`event_io_map`\n`event_io_map`会根据不同的平台最终对应不同的数据结构\n\n`evmap_io_add_`函数\n函数中用到的东西, 我目前吸收不了....... 总之是为将IO事件处理器加入到`event_base`的事件队列中实现的\n\n`eventop`结构体 是`event_base`中封装IO复用机制的结构体, 提供了统一的接口\n```c++\n// 为给定的event_base声明后端的结构体\nstruct eventop {\n\t// 后端IO复用技术的名称\n\tconst char *name;\n\n\t// 初始化 函数需要初始化所有要用的属性\n\t// 返回的指针会被event_init存储在event_base.evbase\n\t// 失败后返回NULL\n\tvoid *(*init)(struct event_base *);\n\t// 注册事件\n\tint (*add)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);\n\t// 删除事件\n\tint (*del)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);\n\t// 等待事件\n\tint (*dispatch)(struct event_base *, struct timeval *);\n\t// 释放IO复用机制使用的资源\n\tvoid (*dealloc)(struct event_base *);\n\t// 标记fork后是否需要重新初始化event_base的标志位\n\tint need_reinit;\n\t// 用于设定io复用技术支持的一些特性\n\tenum event_method_feature features;\n\t// 额外内存的分配\n\tsize_t fdinfo_len;\n};\n```\n\n`event_base`是Libevent的Reactor. 超长结构体 删除了我不理解的部分\n```c++\nstruct event_base {\n\t// 记录选择的I/O复用机制\n\tconst struct eventop *evsel;\n\t// 指向IO复用机制真正存储的数据\n\tvoid *evbase;\n\n\t// 事件变换队列 如果一个文件描述符上注册的事件被多次修改, 则可以使用缓冲避免重复的系统调用\n\t// 比如epoll_ctl, 仅能用于时间复杂度O(1)的IO复用技术\n\tstruct event_changelist changelist;\n\n\t// 信号的后端处理机制\n\tconst struct eventop *evsigsel;\n\t// 信号事件处理器使用的数据结构, 其中封装了socketpair创建的管道. 用于信号处理函数和\n\t// 事件多路分发器之间的通信, 统一事件源的思路\n\tstruct evsig_info sig;\n\n\t// 添加到event_base的虚拟(所有, 激活)事件数量, 虚拟(所有, 激活)事件最大数量\n\tint virtual_event_count;\n\tint virtual_event_count_max;\n\tint event_count;\n\tint event_count_max;\n\tint event_count_active;\n\tint event_count_active_max;\n\n\t// 处理完事件后 是否退出循环\n\tint event_gotterm;\n\t// 是否立即终止循环\n\tint event_break;\n\t// 是否启动一个新的事件循环\n\tint event_continue;\n\n\t// 当前正在处理的活动事件队列的优先级\n\tint event_running_priority;\n\n\t// 标记事件循环是否已经启动, 防止重入\n\tint running_loop;\n\n\t// 活动事件队列数组. 索引值越小的队列优先级越高. 高优先级的活动事件队列中的事件处理器被优先处理\n\tstruct evcallback_list *activequeues;\n\t// 活动事件队列数组的大小 说明有nactivequeues个不同优先级的活动事件队列\n\tint nactivequeues;\n\t/** A list of event_callbacks that should become active the next time\n\t * we process events, but not this time. */\n\tstruct evcallback_list active_later_queue;\n\n\t// 共同超时逻辑\n\n\t// 管理通用定时器队列 实体数量 总数\n\tstruct common_timeout_list **common_timeout_queues;\n\tint n_common_timeouts;\n\tint n_common_timeouts_allocated;\n\n\t// 文件描述符和IO事件之间的映射关系表\n\tstruct event_io_map io;\n\t// 信号值和信号事件之间的映射关系表\n\tstruct event_signal_map sigmap;\n\t// 时间堆\n\tstruct min_heap timeheap;\n\n\t// 管理系统时间的成员\n\tstruct timeval tv_cache;\n\tstruct evutil_monotonic_timer monotonic_timer;\n\tstruct timeval tv_clock_diff;\n\ttime_t last_updated_clock_diff;\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\t// 多线程支持\n\t\n\t// 当前运行该event_base的事件循环的线程\n\tunsigned long th_owner_id;\n\t// 独占锁\n\tvoid *th_base_lock;\n\t// 当前事件循环正在执行哪个事件处理器的回调函数\n\tvoid *current_event_cond;\n\t// 等待的线程数\n\tint current_event_waiters;\n#endif\n\t// 正在处理的事件处理器的回调函数\n\tstruct event_callback *current_event;\n};\n```\n\n事件循环, libevent的动力, 即事件循环\n\n这次读了一下helloworld的 这一部分代码\n```c++\nstatic void\nlistener_cb(struct evconnlistener *listener, evutil_socket_t fd,\n    struct sockaddr *sa, int socklen, void *user_data)\n{\n\tstruct event_base *base = user_data;\n\tstruct bufferevent *bev;\n\n\tbev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);\n\tif (!bev) {\n\t\tfprintf(stderr, \"Error constructing bufferevent!\");\n\t\tevent_base_loopbreak(base);\n\t\treturn;\n\t}\n\t// 设置新创建的bufferevent的 读写回调函数 启动写事件 禁用读事件\n\tbufferevent_setcb(bev, NULL, conn_writecb, conn_eventcb, NULL);\n\tbufferevent_enable(bev, EV_WRITE);\n\tbufferevent_disable(bev, EV_READ);\n\n\tbufferevent_write(bev, MESSAGE, strlen(MESSAGE));\n}\n```\nbufferevent_socket_new 创建了读和写event 设置了真实的回调函数`bufferevent_writecb`等 然后\nbufferevent_enable是真正的事件注册函数， 将上面生成的event注册进入eventbase\n`EV_WRITE`对应的epoll事件是`EPOLLOUT`\n`bufferevent_write`将要写出的数据放入到缓冲区中。 一旦epollwait返回了 就去调用`bufferevent_writecb`将缓冲区\n的内容写出， 然后同时调用用户设置的回调函数\n\n\n2020年3月7日20:26:02\n这次又读了下 系统是怎么区分不同事件来调用回调函数的, 结果返现框架将系统的事件类型对应成自己的事件类型\n```c++\nif (what & (EPOLLHUP|EPOLLERR)) {\n\tev = EV_READ | EV_WRITE;\n} else {\n\tif (what & EPOLLIN)\n\t\tev |= EV_READ;\n\tif (what & EPOLLOUT)\n\t\tev |= EV_WRITE;\n\tif (what & EPOLLRDHUP)\n\t\tev |= EV_CLOSED;\n}\n```\n然后传入`evmap_io_active_`函数, 进而将ev保存到`ev_res`中然后直接作为参数 传给了回调函数","source":"_posts/CPP-源码学习-Libevent代码初期了解.md","raw":"---\ntitle: Libevent代码初期了解\ndate: 2020-02-19 14:56:55\ntags:\ncategories:\n - CPP\n - 源码学习\n \nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/Libevent%E5%B0%81%E9%9D%A2.png\n---\n学习来源\n<Linux 高性能服务器编程>\n# I/O框架库概述\n## Reactor模式\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-1IO%E6%A1%86%E6%9E%B6%E7%BB%84%E7%BB%84%E4%BB%B6.png)\n句柄(Handler)\n由于统一了事件源, 一个事件一般跟一个句柄绑定在一起, 事件就绪之后 会通过句柄通知这一个事件.\n在Linux中 I/O 事件对应的句柄->文件描述符, 信号事件->信号值\n\n事件多路分发器(EventDemultiplexer)\n事件的到来是随机的, 异步的. 所以只能通过一个循环一直等待事件并进行处理 --- 事件循环\n一般通过IO复用实现 select poll epoll_wait\n\n事件处理器(EventHandle)\n具体事件处理器(ConcreteEventHandler)\n事件处理器执行事件对应的业务逻辑, 通常包含一个或多个handler_event回调函数, 这些回调函数在事件循环中被执行\n\nReactor\nhandler_events: 执行事件循环 重复等待事件, 然后依次调用对应的事件处理器\nregister_handler: 向事件多路分发器中注册事件\nremove_handler: 从中删除一个事件\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-2%20IO%E6%A1%86%E6%9E%B6%E5%BA%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE.png)\n\n## Libevent源码分析\n```c++\n#include <sys/signal.h>\n#include <event.h>\n#include <cstdio>\n\nvoid signal_cb(int fd, short event, void* argc)\n{\n    event_base* base = (event_base*)argc;\n    timeval delay = {2, 0};\n\n    printf(\"Caught an interrupt signal\\n\");\n    event_base_loopexit(base, &delay);\n}\n\nvoid timeout_cb(int fd, short event, void* argc)\n{\n    printf(\"timeout\\n\");\n}\nint main()\n{\n    // 相当于创建一个Reactor实例\n    event_base* base = event_init();\n    \n    event* signal_event = evsignal_new(base, SIGINT, signal_cb, base);\n    event_add(signal_event, nullptr);\n    \n    event* timeout_event = evtimer_new(base, timeout_cb, nullptr);\n    timeval tv{1, 0};\n    event_add(timeout_event, &tv);\n    \n    event_base_dispatch(base);\n    event_free(signal_event);\n    event_free(timeout_event);\n    event_base_free(base);\n}\n```\n创建一个事件处理器 然后为绑定上相应的回调函数.\n然后把这个事件处理器注册到事件队列中中,\n\n然后事件多路分发器依靠循环一直等待事件的到来, 事件到来后通知相应的事件处理器\nReactor则管理这些\n\n首先要去了解下 `事件处理器` 对应的就是event这个结构体\n```c++\nstruct event {\n\tstruct event_callback ev_evcallback;\n\n\t// 事件处理器从属的 event_base\n\tstruct event_base *ev_base;\n\t// 信号值 或者 文件描述符\n\tevutil_socket_t ev_fd;\n\t// 定时器的超时时间\n\tstruct timeval ev_timeout;\n\t\n\t// 仅用于定时事件\n\tunion {\n\t\t// 队列--指出在通用定时器中的位置\n\t\tTAILQ_ENTRY(event) ev_next_with_common_timeout;\n\t\t// 时间堆--指出了在时间堆中的位置\n\t\tint min_heap_idx;\n\t} ev_timeout_pos;\n\n\tunion {\n\t\tstruct {\n\t\t\t// 通过这个成员 将具有相同文件描述符的IO事件处理器串联起来\n\t\t\tLIST_ENTRY (event) ev_io_next;\n\t\t\tstruct timeval ev_timeout;\n\t\t} ev_io;\n\t\tstruct {\n\t\t\t// 相同信号的串联起来\n\t\t\tLIST_ENTRY (event) ev_signal_next;\n\t\t\tshort ev_ncalls;\n\t\t\t/* Allows deletes in callback */\n\t\t\tshort *ev_pncalls;\n\t\t} ev_signal;\n\t} ev_;\n\n\t// 事件类型, 可以通过位处理设置非互斥事件\n\tshort ev_events;\n\t// 当前激活事件的类型, 说明被激活的原因\n\tshort ev_res;\n};\n```\n可以看到其中有很多的属性, 三种事件对应的不同的属性.\n\n这些属性的填充函数\n`evsignal_new``evtimer_new`是宏 统一调用`event_new`\n`event_new`调用`event_assign`来进行主要的填充\n\n\n```\n//@通过宏封装注册函数\n\n一个事件生成函数 经过宏的封装(可以自动填充某些此事件用不到的参数)可以更方便的对应不同事件的生成, 既统一了注册, 又方便用户调用\n```\n属性之一便是回调函数, 事件回调函数有自己的规定\n```\n//@统一事件回调函数\n\nvoid (*callback)(evutil_socket_t, short, void *)\n这样能够统一回调函数的格式, 同时方便管理\n```\n事件处理器创建完毕, 该把事件处理器添加到事件注册队列. 样例代码中通过的`event_add`函数来实现将事件处理器添加到事件注册队列\n`event_add`实际由`event_add_nolock_`实现 所以接下来是`event_add_nolock_`函数的说明\n\n```\n//@事件处理器的分发实现\n将传入的event按照不同类型的事件处理器 分别处理\n(因为event_new已经填充了ev_events说明事件类型)\n\nIO事件 添加绑定\n信号事件 绑定相应的信号\n定时器 放入相关的的时间管理数据结构中\n```\n使用`event_queue_insert_inserted`进行注册\n这里的代码2.1.11 与书上的差别较大, 少了多一半的功能, 也没有被抽成函数, 暂不知道对应的功能代码去了哪里\n照书上来说`event_queue_insert_inserted`实现的是将事件处理器加入到`event_base`的某个事件队列中. 对于新添加的IO和信号事件处理器, 还需要让事件多路分发器来监听对应的事件, 然后建立相应的映射关系. 分别使用`evmap_io_add_`和`evmap_signal_add_`(相当于图中的`register_event`)建立映射. \n\n`evmap_io_add_`中有一个结构体`event_io_map`\n`event_io_map`会根据不同的平台最终对应不同的数据结构\n\n`evmap_io_add_`函数\n函数中用到的东西, 我目前吸收不了....... 总之是为将IO事件处理器加入到`event_base`的事件队列中实现的\n\n`eventop`结构体 是`event_base`中封装IO复用机制的结构体, 提供了统一的接口\n```c++\n// 为给定的event_base声明后端的结构体\nstruct eventop {\n\t// 后端IO复用技术的名称\n\tconst char *name;\n\n\t// 初始化 函数需要初始化所有要用的属性\n\t// 返回的指针会被event_init存储在event_base.evbase\n\t// 失败后返回NULL\n\tvoid *(*init)(struct event_base *);\n\t// 注册事件\n\tint (*add)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);\n\t// 删除事件\n\tint (*del)(struct event_base *, evutil_socket_t fd, short old, short events, void *fdinfo);\n\t// 等待事件\n\tint (*dispatch)(struct event_base *, struct timeval *);\n\t// 释放IO复用机制使用的资源\n\tvoid (*dealloc)(struct event_base *);\n\t// 标记fork后是否需要重新初始化event_base的标志位\n\tint need_reinit;\n\t// 用于设定io复用技术支持的一些特性\n\tenum event_method_feature features;\n\t// 额外内存的分配\n\tsize_t fdinfo_len;\n};\n```\n\n`event_base`是Libevent的Reactor. 超长结构体 删除了我不理解的部分\n```c++\nstruct event_base {\n\t// 记录选择的I/O复用机制\n\tconst struct eventop *evsel;\n\t// 指向IO复用机制真正存储的数据\n\tvoid *evbase;\n\n\t// 事件变换队列 如果一个文件描述符上注册的事件被多次修改, 则可以使用缓冲避免重复的系统调用\n\t// 比如epoll_ctl, 仅能用于时间复杂度O(1)的IO复用技术\n\tstruct event_changelist changelist;\n\n\t// 信号的后端处理机制\n\tconst struct eventop *evsigsel;\n\t// 信号事件处理器使用的数据结构, 其中封装了socketpair创建的管道. 用于信号处理函数和\n\t// 事件多路分发器之间的通信, 统一事件源的思路\n\tstruct evsig_info sig;\n\n\t// 添加到event_base的虚拟(所有, 激活)事件数量, 虚拟(所有, 激活)事件最大数量\n\tint virtual_event_count;\n\tint virtual_event_count_max;\n\tint event_count;\n\tint event_count_max;\n\tint event_count_active;\n\tint event_count_active_max;\n\n\t// 处理完事件后 是否退出循环\n\tint event_gotterm;\n\t// 是否立即终止循环\n\tint event_break;\n\t// 是否启动一个新的事件循环\n\tint event_continue;\n\n\t// 当前正在处理的活动事件队列的优先级\n\tint event_running_priority;\n\n\t// 标记事件循环是否已经启动, 防止重入\n\tint running_loop;\n\n\t// 活动事件队列数组. 索引值越小的队列优先级越高. 高优先级的活动事件队列中的事件处理器被优先处理\n\tstruct evcallback_list *activequeues;\n\t// 活动事件队列数组的大小 说明有nactivequeues个不同优先级的活动事件队列\n\tint nactivequeues;\n\t/** A list of event_callbacks that should become active the next time\n\t * we process events, but not this time. */\n\tstruct evcallback_list active_later_queue;\n\n\t// 共同超时逻辑\n\n\t// 管理通用定时器队列 实体数量 总数\n\tstruct common_timeout_list **common_timeout_queues;\n\tint n_common_timeouts;\n\tint n_common_timeouts_allocated;\n\n\t// 文件描述符和IO事件之间的映射关系表\n\tstruct event_io_map io;\n\t// 信号值和信号事件之间的映射关系表\n\tstruct event_signal_map sigmap;\n\t// 时间堆\n\tstruct min_heap timeheap;\n\n\t// 管理系统时间的成员\n\tstruct timeval tv_cache;\n\tstruct evutil_monotonic_timer monotonic_timer;\n\tstruct timeval tv_clock_diff;\n\ttime_t last_updated_clock_diff;\n\n#ifndef EVENT__DISABLE_THREAD_SUPPORT\n\t// 多线程支持\n\t\n\t// 当前运行该event_base的事件循环的线程\n\tunsigned long th_owner_id;\n\t// 独占锁\n\tvoid *th_base_lock;\n\t// 当前事件循环正在执行哪个事件处理器的回调函数\n\tvoid *current_event_cond;\n\t// 等待的线程数\n\tint current_event_waiters;\n#endif\n\t// 正在处理的事件处理器的回调函数\n\tstruct event_callback *current_event;\n};\n```\n\n事件循环, libevent的动力, 即事件循环\n\n这次读了一下helloworld的 这一部分代码\n```c++\nstatic void\nlistener_cb(struct evconnlistener *listener, evutil_socket_t fd,\n    struct sockaddr *sa, int socklen, void *user_data)\n{\n\tstruct event_base *base = user_data;\n\tstruct bufferevent *bev;\n\n\tbev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);\n\tif (!bev) {\n\t\tfprintf(stderr, \"Error constructing bufferevent!\");\n\t\tevent_base_loopbreak(base);\n\t\treturn;\n\t}\n\t// 设置新创建的bufferevent的 读写回调函数 启动写事件 禁用读事件\n\tbufferevent_setcb(bev, NULL, conn_writecb, conn_eventcb, NULL);\n\tbufferevent_enable(bev, EV_WRITE);\n\tbufferevent_disable(bev, EV_READ);\n\n\tbufferevent_write(bev, MESSAGE, strlen(MESSAGE));\n}\n```\nbufferevent_socket_new 创建了读和写event 设置了真实的回调函数`bufferevent_writecb`等 然后\nbufferevent_enable是真正的事件注册函数， 将上面生成的event注册进入eventbase\n`EV_WRITE`对应的epoll事件是`EPOLLOUT`\n`bufferevent_write`将要写出的数据放入到缓冲区中。 一旦epollwait返回了 就去调用`bufferevent_writecb`将缓冲区\n的内容写出， 然后同时调用用户设置的回调函数\n\n\n2020年3月7日20:26:02\n这次又读了下 系统是怎么区分不同事件来调用回调函数的, 结果返现框架将系统的事件类型对应成自己的事件类型\n```c++\nif (what & (EPOLLHUP|EPOLLERR)) {\n\tev = EV_READ | EV_WRITE;\n} else {\n\tif (what & EPOLLIN)\n\t\tev |= EV_READ;\n\tif (what & EPOLLOUT)\n\t\tev |= EV_WRITE;\n\tif (what & EPOLLRDHUP)\n\t\tev |= EV_CLOSED;\n}\n```\n然后传入`evmap_io_active_`函数, 进而将ev保存到`ev_res`中然后直接作为参数 传给了回调函数","slug":"CPP-源码学习-Libevent代码初期了解","published":1,"updated":"2020-03-07T12:28:11.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucux000t8cuo9c0gd3eu","content":"<p>学习来源<br>&lt;Linux 高性能服务器编程&gt;</p>\n<h1 id=\"I-O框架库概述\"><a href=\"#I-O框架库概述\" class=\"headerlink\" title=\"I/O框架库概述\"></a>I/O框架库概述</h1><h2 id=\"Reactor模式\"><a href=\"#Reactor模式\" class=\"headerlink\" title=\"Reactor模式\"></a>Reactor模式</h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-1IO%E6%A1%86%E6%9E%B6%E7%BB%84%E7%BB%84%E4%BB%B6.png\" alt=\"\"><br>句柄(Handler)<br>由于统一了事件源, 一个事件一般跟一个句柄绑定在一起, 事件就绪之后 会通过句柄通知这一个事件.<br>在Linux中 I/O 事件对应的句柄-&gt;文件描述符, 信号事件-&gt;信号值</p>\n<p>事件多路分发器(EventDemultiplexer)<br>事件的到来是随机的, 异步的. 所以只能通过一个循环一直等待事件并进行处理 — 事件循环<br>一般通过IO复用实现 select poll epoll_wait</p>\n<p>事件处理器(EventHandle)<br>具体事件处理器(ConcreteEventHandler)<br>事件处理器执行事件对应的业务逻辑, 通常包含一个或多个handler_event回调函数, 这些回调函数在事件循环中被执行</p>\n<p>Reactor<br>handler_events: 执行事件循环 重复等待事件, 然后依次调用对应的事件处理器<br>register_handler: 向事件多路分发器中注册事件<br>remove_handler: 从中删除一个事件</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-2%20IO%E6%A1%86%E6%9E%B6%E5%BA%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE.png\" alt=\"\"></p>\n<h2 id=\"Libevent源码分析\"><a href=\"#Libevent源码分析\" class=\"headerlink\" title=\"Libevent源码分析\"></a>Libevent源码分析</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/signal.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;event.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">signal_cb</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, short event, <span class=\"keyword\">void</span>* argc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    event_base* base = (event_base*)argc;</span><br><span class=\"line\">    timeval <span class=\"built_in\">delay</span> = &#123;<span class=\"number\">2</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Caught an interrupt signal\\n\"</span>);</span><br><span class=\"line\">    event_base_loopexit(base, &amp;<span class=\"built_in\">delay</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">timeout_cb</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, short event, <span class=\"keyword\">void</span>* argc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"timeout\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 相当于创建一个Reactor实例</span></span><br><span class=\"line\">    event_base* base = event_init();</span><br><span class=\"line\">    </span><br><span class=\"line\">    event* signal_event = evsignal_new(base, SIGINT, signal_cb, base);</span><br><span class=\"line\">    event_add(signal_event, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    event* timeout_event = evtimer_new(base, timeout_cb, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    timeval tv&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    event_add(timeout_event, &amp;tv);</span><br><span class=\"line\">    </span><br><span class=\"line\">    event_base_dispatch(base);</span><br><span class=\"line\">    event_free(signal_event);</span><br><span class=\"line\">    event_free(timeout_event);</span><br><span class=\"line\">    event_base_free(base);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建一个事件处理器 然后为绑定上相应的回调函数.<br>然后把这个事件处理器注册到事件队列中中,</p>\n<p>然后事件多路分发器依靠循环一直等待事件的到来, 事件到来后通知相应的事件处理器<br>Reactor则管理这些</p>\n<p>首先要去了解下 <code>事件处理器</code> 对应的就是event这个结构体</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_callback</span> <span class=\"title\">ev_evcallback</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 事件处理器从属的 event_base</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_base</span> *<span class=\"title\">ev_base</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 信号值 或者 文件描述符</span></span><br><span class=\"line\">\t<span class=\"keyword\">evutil_socket_t</span> ev_fd;</span><br><span class=\"line\">\t<span class=\"comment\">// 定时器的超时时间</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">ev_timeout</span>;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 仅用于定时事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 队列--指出在通用定时器中的位置</span></span><br><span class=\"line\">\t\tTAILQ_ENTRY(event) ev_next_with_common_timeout;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 时间堆--指出了在时间堆中的位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> min_heap_idx;</span><br><span class=\"line\">\t&#125; ev_timeout_pos;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 通过这个成员 将具有相同文件描述符的IO事件处理器串联起来</span></span><br><span class=\"line\">\t\t\tLIST_ENTRY (event) ev_io_next;</span><br><span class=\"line\">\t\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">ev_timeout</span>;</span></span><br><span class=\"line\">\t\t&#125; ev_io;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 相同信号的串联起来</span></span><br><span class=\"line\">\t\t\tLIST_ENTRY (event) ev_signal_next;</span><br><span class=\"line\">\t\t\tshort ev_ncalls;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* Allows deletes in callback */</span></span><br><span class=\"line\">\t\t\tshort *ev_pncalls;</span><br><span class=\"line\">\t\t&#125; ev_signal;</span><br><span class=\"line\">\t&#125; ev_;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 事件类型, 可以通过位处理设置非互斥事件</span></span><br><span class=\"line\">\tshort ev_events;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前激活事件的类型, 说明被激活的原因</span></span><br><span class=\"line\">\tshort ev_res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到其中有很多的属性, 三种事件对应的不同的属性.</p>\n<p>这些属性的填充函数<br><code>evsignal_new``evtimer_new</code>是宏 统一调用<code>event_new</code><br><code>event_new</code>调用<code>event_assign</code>来进行主要的填充</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;@通过宏封装注册函数</span><br><span class=\"line\"></span><br><span class=\"line\">一个事件生成函数 经过宏的封装(可以自动填充某些此事件用不到的参数)可以更方便的对应不同事件的生成, 既统一了注册, 又方便用户调用</span><br></pre></td></tr></table></figure>\n<p>属性之一便是回调函数, 事件回调函数有自己的规定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;@统一事件回调函数</span><br><span class=\"line\"></span><br><span class=\"line\">void (*callback)(evutil_socket_t, short, void *)</span><br><span class=\"line\">这样能够统一回调函数的格式, 同时方便管理</span><br></pre></td></tr></table></figure>\n<p>事件处理器创建完毕, 该把事件处理器添加到事件注册队列. 样例代码中通过的<code>event_add</code>函数来实现将事件处理器添加到事件注册队列<br><code>event_add</code>实际由<code>event_add_nolock_</code>实现 所以接下来是<code>event_add_nolock_</code>函数的说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;@事件处理器的分发实现</span><br><span class=\"line\">将传入的event按照不同类型的事件处理器 分别处理</span><br><span class=\"line\">(因为event_new已经填充了ev_events说明事件类型)</span><br><span class=\"line\"></span><br><span class=\"line\">IO事件 添加绑定</span><br><span class=\"line\">信号事件 绑定相应的信号</span><br><span class=\"line\">定时器 放入相关的的时间管理数据结构中</span><br></pre></td></tr></table></figure>\n<p>使用<code>event_queue_insert_inserted</code>进行注册<br>这里的代码2.1.11 与书上的差别较大, 少了多一半的功能, 也没有被抽成函数, 暂不知道对应的功能代码去了哪里<br>照书上来说<code>event_queue_insert_inserted</code>实现的是将事件处理器加入到<code>event_base</code>的某个事件队列中. 对于新添加的IO和信号事件处理器, 还需要让事件多路分发器来监听对应的事件, 然后建立相应的映射关系. 分别使用<code>evmap_io_add_</code>和<code>evmap_signal_add_</code>(相当于图中的<code>register_event</code>)建立映射. </p>\n<p><code>evmap_io_add_</code>中有一个结构体<code>event_io_map</code><br><code>event_io_map</code>会根据不同的平台最终对应不同的数据结构</p>\n<p><code>evmap_io_add_</code>函数<br>函数中用到的东西, 我目前吸收不了……. 总之是为将IO事件处理器加入到<code>event_base</code>的事件队列中实现的</p>\n<p><code>eventop</code>结构体 是<code>event_base</code>中封装IO复用机制的结构体, 提供了统一的接口</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为给定的event_base声明后端的结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventop</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 后端IO复用技术的名称</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 初始化 函数需要初始化所有要用的属性</span></span><br><span class=\"line\">\t<span class=\"comment\">// 返回的指针会被event_init存储在event_base.evbase</span></span><br><span class=\"line\">\t<span class=\"comment\">// 失败后返回NULL</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *(*init)(struct event_base *);</span><br><span class=\"line\">\t<span class=\"comment\">// 注册事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*add)(struct event_base *, <span class=\"keyword\">evutil_socket_t</span> fd, short old, short events, <span class=\"keyword\">void</span> *fdinfo);</span><br><span class=\"line\">\t<span class=\"comment\">// 删除事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*del)(struct event_base *, <span class=\"keyword\">evutil_socket_t</span> fd, short old, short events, <span class=\"keyword\">void</span> *fdinfo);</span><br><span class=\"line\">\t<span class=\"comment\">// 等待事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*dispatch)(struct event_base *, struct timeval *);</span><br><span class=\"line\">\t<span class=\"comment\">// 释放IO复用机制使用的资源</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*dealloc)(struct event_base *);</span><br><span class=\"line\">\t<span class=\"comment\">// 标记fork后是否需要重新初始化event_base的标志位</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> need_reinit;</span><br><span class=\"line\">\t<span class=\"comment\">// 用于设定io复用技术支持的一些特性</span></span><br><span class=\"line\">\t<span class=\"keyword\">enum</span> event_method_feature features;</span><br><span class=\"line\">\t<span class=\"comment\">// 额外内存的分配</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> fdinfo_len;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>event_base</code>是Libevent的Reactor. 超长结构体 删除了我不理解的部分</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_base</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 记录选择的I/O复用机制</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventop</span> *<span class=\"title\">evsel</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向IO复用机制真正存储的数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *evbase;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 事件变换队列 如果一个文件描述符上注册的事件被多次修改, 则可以使用缓冲避免重复的系统调用</span></span><br><span class=\"line\">\t<span class=\"comment\">// 比如epoll_ctl, 仅能用于时间复杂度O(1)的IO复用技术</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_changelist</span> <span class=\"title\">changelist</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 信号的后端处理机制</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventop</span> *<span class=\"title\">evsigsel</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 信号事件处理器使用的数据结构, 其中封装了socketpair创建的管道. 用于信号处理函数和</span></span><br><span class=\"line\">\t<span class=\"comment\">// 事件多路分发器之间的通信, 统一事件源的思路</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evsig_info</span> <span class=\"title\">sig</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 添加到event_base的虚拟(所有, 激活)事件数量, 虚拟(所有, 激活)事件最大数量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> virtual_event_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> virtual_event_count_max;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count_max;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count_active;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count_active_max;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 处理完事件后 是否退出循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_gotterm;</span><br><span class=\"line\">\t<span class=\"comment\">// 是否立即终止循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_break;</span><br><span class=\"line\">\t<span class=\"comment\">// 是否启动一个新的事件循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_continue;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 当前正在处理的活动事件队列的优先级</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_running_priority;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 标记事件循环是否已经启动, 防止重入</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> running_loop;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 活动事件队列数组. 索引值越小的队列优先级越高. 高优先级的活动事件队列中的事件处理器被优先处理</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evcallback_list</span> *<span class=\"title\">activequeues</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 活动事件队列数组的大小 说明有nactivequeues个不同优先级的活动事件队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nactivequeues;</span><br><span class=\"line\">\t<span class=\"comment\">/** A list of event_callbacks that should become active the next time</span></span><br><span class=\"line\"><span class=\"comment\">\t * we process events, but not this time. */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evcallback_list</span> <span class=\"title\">active_later_queue</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 共同超时逻辑</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 管理通用定时器队列 实体数量 总数</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">common_timeout_list</span> **<span class=\"title\">common_timeout_queues</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n_common_timeouts;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n_common_timeouts_allocated;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 文件描述符和IO事件之间的映射关系表</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_io_map</span> <span class=\"title\">io</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 信号值和信号事件之间的映射关系表</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_signal_map</span> <span class=\"title\">sigmap</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 时间堆</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">min_heap</span> <span class=\"title\">timeheap</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 管理系统时间的成员</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv_cache</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evutil_monotonic_timer</span> <span class=\"title\">monotonic_timer</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv_clock_diff</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">time_t</span> last_updated_clock_diff;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> EVENT__DISABLE_THREAD_SUPPORT</span></span><br><span class=\"line\">\t<span class=\"comment\">// 多线程支持</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 当前运行该event_base的事件循环的线程</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> th_owner_id;</span><br><span class=\"line\">\t<span class=\"comment\">// 独占锁</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *th_base_lock;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前事件循环正在执行哪个事件处理器的回调函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *current_event_cond;</span><br><span class=\"line\">\t<span class=\"comment\">// 等待的线程数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> current_event_waiters;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"comment\">// 正在处理的事件处理器的回调函数</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_callback</span> *<span class=\"title\">current_event</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>事件循环, libevent的动力, 即事件循环</p>\n<p>这次读了一下helloworld的 这一部分代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span><br><span class=\"line\">listener_cb(struct evconnlistener *listener, <span class=\"keyword\">evutil_socket_t</span> fd,</span><br><span class=\"line\">    struct sockaddr *sa, <span class=\"keyword\">int</span> socklen, <span class=\"keyword\">void</span> *user_data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_base</span> *<span class=\"title\">base</span> = <span class=\"title\">user_data</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bufferevent</span> *<span class=\"title\">bev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tbev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!bev) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"Error constructing bufferevent!\"</span>);</span><br><span class=\"line\">\t\tevent_base_loopbreak(base);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置新创建的bufferevent的 读写回调函数 启动写事件 禁用读事件</span></span><br><span class=\"line\">\tbufferevent_setcb(bev, <span class=\"literal\">NULL</span>, conn_writecb, conn_eventcb, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\tbufferevent_enable(bev, EV_WRITE);</span><br><span class=\"line\">\tbufferevent_disable(bev, EV_READ);</span><br><span class=\"line\"></span><br><span class=\"line\">\tbufferevent_write(bev, MESSAGE, <span class=\"built_in\">strlen</span>(MESSAGE));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bufferevent_socket_new 创建了读和写event 设置了真实的回调函数<code>bufferevent_writecb</code>等 然后<br>bufferevent_enable是真正的事件注册函数， 将上面生成的event注册进入eventbase<br><code>EV_WRITE</code>对应的epoll事件是<code>EPOLLOUT</code><br><code>bufferevent_write</code>将要写出的数据放入到缓冲区中。 一旦epollwait返回了 就去调用<code>bufferevent_writecb</code>将缓冲区<br>的内容写出， 然后同时调用用户设置的回调函数</p>\n<p>2020年3月7日20:26:02<br>这次又读了下 系统是怎么区分不同事件来调用回调函数的, 结果返现框架将系统的事件类型对应成自己的事件类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (what &amp; (EPOLLHUP|EPOLLERR)) &#123;</span><br><span class=\"line\">\tev = EV_READ | EV_WRITE;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (what &amp; EPOLLIN)</span><br><span class=\"line\">\t\tev |= EV_READ;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (what &amp; EPOLLOUT)</span><br><span class=\"line\">\t\tev |= EV_WRITE;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (what &amp; EPOLLRDHUP)</span><br><span class=\"line\">\t\tev |= EV_CLOSED;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后传入<code>evmap_io_active_</code>函数, 进而将ev保存到<code>ev_res</code>中然后直接作为参数 传给了回调函数</p>\n","site":{"data":{}},"excerpt":"","more":"<p>学习来源<br>&lt;Linux 高性能服务器编程&gt;</p>\n<h1 id=\"I-O框架库概述\"><a href=\"#I-O框架库概述\" class=\"headerlink\" title=\"I/O框架库概述\"></a>I/O框架库概述</h1><h2 id=\"Reactor模式\"><a href=\"#Reactor模式\" class=\"headerlink\" title=\"Reactor模式\"></a>Reactor模式</h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-1IO%E6%A1%86%E6%9E%B6%E7%BB%84%E7%BB%84%E4%BB%B6.png\" alt=\"\"><br>句柄(Handler)<br>由于统一了事件源, 一个事件一般跟一个句柄绑定在一起, 事件就绪之后 会通过句柄通知这一个事件.<br>在Linux中 I/O 事件对应的句柄-&gt;文件描述符, 信号事件-&gt;信号值</p>\n<p>事件多路分发器(EventDemultiplexer)<br>事件的到来是随机的, 异步的. 所以只能通过一个循环一直等待事件并进行处理 — 事件循环<br>一般通过IO复用实现 select poll epoll_wait</p>\n<p>事件处理器(EventHandle)<br>具体事件处理器(ConcreteEventHandler)<br>事件处理器执行事件对应的业务逻辑, 通常包含一个或多个handler_event回调函数, 这些回调函数在事件循环中被执行</p>\n<p>Reactor<br>handler_events: 执行事件循环 重复等待事件, 然后依次调用对应的事件处理器<br>register_handler: 向事件多路分发器中注册事件<br>remove_handler: 从中删除一个事件</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/%E5%9B%BE12-2%20IO%E6%A1%86%E6%9E%B6%E5%BA%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE.png\" alt=\"\"></p>\n<h2 id=\"Libevent源码分析\"><a href=\"#Libevent源码分析\" class=\"headerlink\" title=\"Libevent源码分析\"></a>Libevent源码分析</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/signal.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;event.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">signal_cb</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, short event, <span class=\"keyword\">void</span>* argc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    event_base* base = (event_base*)argc;</span><br><span class=\"line\">    timeval <span class=\"built_in\">delay</span> = &#123;<span class=\"number\">2</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Caught an interrupt signal\\n\"</span>);</span><br><span class=\"line\">    event_base_loopexit(base, &amp;<span class=\"built_in\">delay</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">timeout_cb</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, short event, <span class=\"keyword\">void</span>* argc)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"timeout\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 相当于创建一个Reactor实例</span></span><br><span class=\"line\">    event_base* base = event_init();</span><br><span class=\"line\">    </span><br><span class=\"line\">    event* signal_event = evsignal_new(base, SIGINT, signal_cb, base);</span><br><span class=\"line\">    event_add(signal_event, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    event* timeout_event = evtimer_new(base, timeout_cb, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    timeval tv&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    event_add(timeout_event, &amp;tv);</span><br><span class=\"line\">    </span><br><span class=\"line\">    event_base_dispatch(base);</span><br><span class=\"line\">    event_free(signal_event);</span><br><span class=\"line\">    event_free(timeout_event);</span><br><span class=\"line\">    event_base_free(base);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>创建一个事件处理器 然后为绑定上相应的回调函数.<br>然后把这个事件处理器注册到事件队列中中,</p>\n<p>然后事件多路分发器依靠循环一直等待事件的到来, 事件到来后通知相应的事件处理器<br>Reactor则管理这些</p>\n<p>首先要去了解下 <code>事件处理器</code> 对应的就是event这个结构体</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_callback</span> <span class=\"title\">ev_evcallback</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 事件处理器从属的 event_base</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_base</span> *<span class=\"title\">ev_base</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 信号值 或者 文件描述符</span></span><br><span class=\"line\">\t<span class=\"keyword\">evutil_socket_t</span> ev_fd;</span><br><span class=\"line\">\t<span class=\"comment\">// 定时器的超时时间</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">ev_timeout</span>;</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 仅用于定时事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 队列--指出在通用定时器中的位置</span></span><br><span class=\"line\">\t\tTAILQ_ENTRY(event) ev_next_with_common_timeout;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 时间堆--指出了在时间堆中的位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> min_heap_idx;</span><br><span class=\"line\">\t&#125; ev_timeout_pos;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">union</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 通过这个成员 将具有相同文件描述符的IO事件处理器串联起来</span></span><br><span class=\"line\">\t\t\tLIST_ENTRY (event) ev_io_next;</span><br><span class=\"line\">\t\t\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">ev_timeout</span>;</span></span><br><span class=\"line\">\t\t&#125; ev_io;</span><br><span class=\"line\">\t\t<span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\t\t\t<span class=\"comment\">// 相同信号的串联起来</span></span><br><span class=\"line\">\t\t\tLIST_ENTRY (event) ev_signal_next;</span><br><span class=\"line\">\t\t\tshort ev_ncalls;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/* Allows deletes in callback */</span></span><br><span class=\"line\">\t\t\tshort *ev_pncalls;</span><br><span class=\"line\">\t\t&#125; ev_signal;</span><br><span class=\"line\">\t&#125; ev_;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 事件类型, 可以通过位处理设置非互斥事件</span></span><br><span class=\"line\">\tshort ev_events;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前激活事件的类型, 说明被激活的原因</span></span><br><span class=\"line\">\tshort ev_res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>可以看到其中有很多的属性, 三种事件对应的不同的属性.</p>\n<p>这些属性的填充函数<br><code>evsignal_new``evtimer_new</code>是宏 统一调用<code>event_new</code><br><code>event_new</code>调用<code>event_assign</code>来进行主要的填充</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;@通过宏封装注册函数</span><br><span class=\"line\"></span><br><span class=\"line\">一个事件生成函数 经过宏的封装(可以自动填充某些此事件用不到的参数)可以更方便的对应不同事件的生成, 既统一了注册, 又方便用户调用</span><br></pre></td></tr></table></figure>\n<p>属性之一便是回调函数, 事件回调函数有自己的规定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;@统一事件回调函数</span><br><span class=\"line\"></span><br><span class=\"line\">void (*callback)(evutil_socket_t, short, void *)</span><br><span class=\"line\">这样能够统一回调函数的格式, 同时方便管理</span><br></pre></td></tr></table></figure>\n<p>事件处理器创建完毕, 该把事件处理器添加到事件注册队列. 样例代码中通过的<code>event_add</code>函数来实现将事件处理器添加到事件注册队列<br><code>event_add</code>实际由<code>event_add_nolock_</code>实现 所以接下来是<code>event_add_nolock_</code>函数的说明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;@事件处理器的分发实现</span><br><span class=\"line\">将传入的event按照不同类型的事件处理器 分别处理</span><br><span class=\"line\">(因为event_new已经填充了ev_events说明事件类型)</span><br><span class=\"line\"></span><br><span class=\"line\">IO事件 添加绑定</span><br><span class=\"line\">信号事件 绑定相应的信号</span><br><span class=\"line\">定时器 放入相关的的时间管理数据结构中</span><br></pre></td></tr></table></figure>\n<p>使用<code>event_queue_insert_inserted</code>进行注册<br>这里的代码2.1.11 与书上的差别较大, 少了多一半的功能, 也没有被抽成函数, 暂不知道对应的功能代码去了哪里<br>照书上来说<code>event_queue_insert_inserted</code>实现的是将事件处理器加入到<code>event_base</code>的某个事件队列中. 对于新添加的IO和信号事件处理器, 还需要让事件多路分发器来监听对应的事件, 然后建立相应的映射关系. 分别使用<code>evmap_io_add_</code>和<code>evmap_signal_add_</code>(相当于图中的<code>register_event</code>)建立映射. </p>\n<p><code>evmap_io_add_</code>中有一个结构体<code>event_io_map</code><br><code>event_io_map</code>会根据不同的平台最终对应不同的数据结构</p>\n<p><code>evmap_io_add_</code>函数<br>函数中用到的东西, 我目前吸收不了……. 总之是为将IO事件处理器加入到<code>event_base</code>的事件队列中实现的</p>\n<p><code>eventop</code>结构体 是<code>event_base</code>中封装IO复用机制的结构体, 提供了统一的接口</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为给定的event_base声明后端的结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventop</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 后端IO复用技术的名称</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 初始化 函数需要初始化所有要用的属性</span></span><br><span class=\"line\">\t<span class=\"comment\">// 返回的指针会被event_init存储在event_base.evbase</span></span><br><span class=\"line\">\t<span class=\"comment\">// 失败后返回NULL</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *(*init)(struct event_base *);</span><br><span class=\"line\">\t<span class=\"comment\">// 注册事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*add)(struct event_base *, <span class=\"keyword\">evutil_socket_t</span> fd, short old, short events, <span class=\"keyword\">void</span> *fdinfo);</span><br><span class=\"line\">\t<span class=\"comment\">// 删除事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*del)(struct event_base *, <span class=\"keyword\">evutil_socket_t</span> fd, short old, short events, <span class=\"keyword\">void</span> *fdinfo);</span><br><span class=\"line\">\t<span class=\"comment\">// 等待事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> (*dispatch)(struct event_base *, struct timeval *);</span><br><span class=\"line\">\t<span class=\"comment\">// 释放IO复用机制使用的资源</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> (*dealloc)(struct event_base *);</span><br><span class=\"line\">\t<span class=\"comment\">// 标记fork后是否需要重新初始化event_base的标志位</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> need_reinit;</span><br><span class=\"line\">\t<span class=\"comment\">// 用于设定io复用技术支持的一些特性</span></span><br><span class=\"line\">\t<span class=\"keyword\">enum</span> event_method_feature features;</span><br><span class=\"line\">\t<span class=\"comment\">// 额外内存的分配</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> fdinfo_len;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><code>event_base</code>是Libevent的Reactor. 超长结构体 删除了我不理解的部分</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_base</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 记录选择的I/O复用机制</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventop</span> *<span class=\"title\">evsel</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 指向IO复用机制真正存储的数据</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *evbase;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 事件变换队列 如果一个文件描述符上注册的事件被多次修改, 则可以使用缓冲避免重复的系统调用</span></span><br><span class=\"line\">\t<span class=\"comment\">// 比如epoll_ctl, 仅能用于时间复杂度O(1)的IO复用技术</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_changelist</span> <span class=\"title\">changelist</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 信号的后端处理机制</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">eventop</span> *<span class=\"title\">evsigsel</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 信号事件处理器使用的数据结构, 其中封装了socketpair创建的管道. 用于信号处理函数和</span></span><br><span class=\"line\">\t<span class=\"comment\">// 事件多路分发器之间的通信, 统一事件源的思路</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evsig_info</span> <span class=\"title\">sig</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 添加到event_base的虚拟(所有, 激活)事件数量, 虚拟(所有, 激活)事件最大数量</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> virtual_event_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> virtual_event_count_max;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count_max;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count_active;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_count_active_max;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 处理完事件后 是否退出循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_gotterm;</span><br><span class=\"line\">\t<span class=\"comment\">// 是否立即终止循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_break;</span><br><span class=\"line\">\t<span class=\"comment\">// 是否启动一个新的事件循环</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_continue;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 当前正在处理的活动事件队列的优先级</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> event_running_priority;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 标记事件循环是否已经启动, 防止重入</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> running_loop;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 活动事件队列数组. 索引值越小的队列优先级越高. 高优先级的活动事件队列中的事件处理器被优先处理</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evcallback_list</span> *<span class=\"title\">activequeues</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 活动事件队列数组的大小 说明有nactivequeues个不同优先级的活动事件队列</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> nactivequeues;</span><br><span class=\"line\">\t<span class=\"comment\">/** A list of event_callbacks that should become active the next time</span></span><br><span class=\"line\"><span class=\"comment\">\t * we process events, but not this time. */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evcallback_list</span> <span class=\"title\">active_later_queue</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 共同超时逻辑</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 管理通用定时器队列 实体数量 总数</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">common_timeout_list</span> **<span class=\"title\">common_timeout_queues</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n_common_timeouts;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n_common_timeouts_allocated;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 文件描述符和IO事件之间的映射关系表</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_io_map</span> <span class=\"title\">io</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 信号值和信号事件之间的映射关系表</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_signal_map</span> <span class=\"title\">sigmap</span>;</span></span><br><span class=\"line\">\t<span class=\"comment\">// 时间堆</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">min_heap</span> <span class=\"title\">timeheap</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 管理系统时间的成员</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv_cache</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">evutil_monotonic_timer</span> <span class=\"title\">monotonic_timer</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">tv_clock_diff</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">time_t</span> last_updated_clock_diff;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> EVENT__DISABLE_THREAD_SUPPORT</span></span><br><span class=\"line\">\t<span class=\"comment\">// 多线程支持</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 当前运行该event_base的事件循环的线程</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> th_owner_id;</span><br><span class=\"line\">\t<span class=\"comment\">// 独占锁</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *th_base_lock;</span><br><span class=\"line\">\t<span class=\"comment\">// 当前事件循环正在执行哪个事件处理器的回调函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span> *current_event_cond;</span><br><span class=\"line\">\t<span class=\"comment\">// 等待的线程数</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> current_event_waiters;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"comment\">// 正在处理的事件处理器的回调函数</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_callback</span> *<span class=\"title\">current_event</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>事件循环, libevent的动力, 即事件循环</p>\n<p>这次读了一下helloworld的 这一部分代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span><br><span class=\"line\">listener_cb(struct evconnlistener *listener, <span class=\"keyword\">evutil_socket_t</span> fd,</span><br><span class=\"line\">    struct sockaddr *sa, <span class=\"keyword\">int</span> socklen, <span class=\"keyword\">void</span> *user_data)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">event_base</span> *<span class=\"title\">base</span> = <span class=\"title\">user_data</span>;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bufferevent</span> *<span class=\"title\">bev</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tbev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!bev) &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"Error constructing bufferevent!\"</span>);</span><br><span class=\"line\">\t\tevent_base_loopbreak(base);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置新创建的bufferevent的 读写回调函数 启动写事件 禁用读事件</span></span><br><span class=\"line\">\tbufferevent_setcb(bev, <span class=\"literal\">NULL</span>, conn_writecb, conn_eventcb, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\tbufferevent_enable(bev, EV_WRITE);</span><br><span class=\"line\">\tbufferevent_disable(bev, EV_READ);</span><br><span class=\"line\"></span><br><span class=\"line\">\tbufferevent_write(bev, MESSAGE, <span class=\"built_in\">strlen</span>(MESSAGE));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bufferevent_socket_new 创建了读和写event 设置了真实的回调函数<code>bufferevent_writecb</code>等 然后<br>bufferevent_enable是真正的事件注册函数， 将上面生成的event注册进入eventbase<br><code>EV_WRITE</code>对应的epoll事件是<code>EPOLLOUT</code><br><code>bufferevent_write</code>将要写出的数据放入到缓冲区中。 一旦epollwait返回了 就去调用<code>bufferevent_writecb</code>将缓冲区<br>的内容写出， 然后同时调用用户设置的回调函数</p>\n<p>2020年3月7日20:26:02<br>这次又读了下 系统是怎么区分不同事件来调用回调函数的, 结果返现框架将系统的事件类型对应成自己的事件类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (what &amp; (EPOLLHUP|EPOLLERR)) &#123;</span><br><span class=\"line\">\tev = EV_READ | EV_WRITE;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (what &amp; EPOLLIN)</span><br><span class=\"line\">\t\tev |= EV_READ;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (what &amp; EPOLLOUT)</span><br><span class=\"line\">\t\tev |= EV_WRITE;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (what &amp; EPOLLRDHUP)</span><br><span class=\"line\">\t\tev |= EV_CLOSED;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后传入<code>evmap_io_active_</code>函数, 进而将ev保存到<code>ev_res</code>中然后直接作为参数 传给了回调函数</p>\n"},{"title":"Linux高性能服务器-初级部分","date":"2019-08-17T12:34:39.000Z","top":100,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg","_content":"开头选了这本书, 看到这本书是他人总结三大本后自己写的, 先求个理解大概.\n话说别人推荐的c++服务器咋都是c语言.....\n2019年8月17日20:37:53\n\n每学习一部分就写一个demo\n<!--more-->\n\n## 第五章Linux网络编程基础API\n\n\nsocket基础api位于 `sys/socket.h` 头文件中\nsocket最开始的含义是 一个IP地址和端口对. 唯一的表示了TCP通信的一段\n网络信息api `netdb.h`头文件中\n\n### 主机字节序和网络字节序\n字节序分为 `大端字节序`和`小端字节序`\n由于大多数PC采用小端字节序(高位存在高地址处), 所以小端字节序又称为主机字节序\n\n为了防止不同机器字节序不同导致的错乱问题. 规定传输的时候统一为 大端字节序(网络字节序).\n这样主机会根据自己的情况决定 - 是否转换接收到的数据的字节序\n\n\n### API\n\n**基础连接**\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93.jpg)\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88%E5%9C%B0%E5%9D%80%E6%97%8F.jpg)\n```c++\n// 主机序和网络字节序转换\n#include <netinet/in.h>\nunsigned long int htonl (unsigned long int hostlong); // host to network long\nunsigned short int htons (unsigned short int hostlong); // host to network short\n\nunsigned long int htonl (unsigned long int netlong);\nunsigned short int htons (unsigned short int netlong);\n\n// IP地址转换函数\n#include <arpa/inet.h>\n// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONE\nin_addr_t  inet_addr( const char* strptr);\n\n// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0\nint inet_aton( const char* cp, struct in_addr* inp);\n\n// 函数返回一个静态变量地址值, 所以多次调用会导致覆盖\nchar* inet_ntoa(struct in_addr in); \n\n// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族\n// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1\nint inet_pton(int af, const char * src, void* dst);\n// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)\nconst char* inet_ntop(int af, const void*  src, char* dst, socklen_t cnt);\n\n\n// 创建 命名 监听 socket\n# include <sys/types.h>\n# include <sys/socket.h>\n// domain指定使用那个协议族 PF_INET PF_INET6\n// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)\n// protocol设置为默认的0\n// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1\nint socket(int domain, int type, int protocol);\n\n// socket为socket文件描述符\n// my_addr 为地址信息\n// addrlen为socket地址长度\n// 成功返回0 失败返回 -1\nint bind(int socket, const struct sockaddr* my_addr, socklen_t addrlen);\n\n// backlog表示队列最大的长度\nint listen(int socket, int backlog);\n// 接受连接 失败返回-1 成功时返回socket\nint accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen)\n```\n客户端\n```c\n// 发起连接\n#include <sys/types.h>\n#include <sys/socket.h>\n// 第三个参数为 地址指定的长度\n// 成功返回0 失败返回-1\nint connect(int sockfd, const struct sockaddr * serv_addr, socklen_t addrlen);\n\n// 关闭连接\n#include <unistd.h>\n// 参数为保存的socket\n// 并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才能关闭(需要查阅)\nint close(int fd);\n\n// 立即关闭\n#include <sys/socket.h>\n// 第二个参数为可选值 \n//\tSHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃\n//\tSHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去\n//\tSHUT_RDWR 同时关闭读和写\n// 成功返回0 失败为-1 设置errno\nint shutdown(int sockfd, int howto)\n```\n**基础TCP**\n```c\n#include<sys/socket.h>\n#include<sys/types.h>\n\n// 读取sockfd的数据\n// buf 指定读缓冲区的位置\n// len 指定读缓冲区的大小\n// flags 参数较多\n// 成功的时候返回读取到的长度, 可能小于预期长度, 需要多次读取.   读取到0 通信对方已经关闭连接, 错误返回-1\nssize_t recv(int sockfd, void *buf, size_t len, int flags);\n// 发送\nssize_t send(int sockfd, const void *buf, size_t len, int flags);\n```\n\n| 选项名        | 含义                                                                                     | 可用于发送 | 可用于接收 |\n| ------------- | ---------------------------------------------------------------------------------------- | ---------- | ---------- |\n| MSG_CONFIRM   | 指示链路层协议持续监听, 直到得到答复.(仅能用于SOCK_DGRAM和SOCK_RAW类型的socket)          | Y          | N          |\n| MSG_DONTROUTE | 不查看路由表, 直接将数据发送给本地的局域网络的主机(代表发送者知道目标主机就在本地网络中) | Y          | N          |\n| MSG_DONTWAIT  | 非阻塞                                                                                   | Y          | Y          |\n| MSG_MORE      | 告知内核有更多的数据要发送, 等到数据写入缓冲区完毕后,一并发送.减少短小的报文提高传输效率 | Y          | N          |\n| MSG_WAITALL   | 读操作一直等待到读取到指定字节后才会返回                                                 | N          | Y          |\n| MSG_PEEK      | 看一下内缓存数据, 并不会影响数据                                                         | N          | Y          |\n| MSG_OOB       | 发送或接收紧急数据                                                                       | Y          | Y          |\n| MSG_NOSIGNAL  | 向读关闭的管道或者socket连接中写入数据不会触发SIGPIPE信号                                | Y          |        N    |\n\n**基础UDP**\n```c\n#include <sys/types.h>\n#include <sys/socket.h>\n// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.\n// 不过recvfrom和sendto 也可以用于 面向STREAM的连接, 这样可以省略发送和接收端的socket地址\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen);\nssize_t sendto(int sockfd, const void* buf, size_t len, ing flags, const struct sockaddr* dest_addr, socklen_t addrlen);\n\n```\n\n**通用读写函数**\n\n```c\n#inclued <sys/socket.h>\nssize_t recvmsg(int sockfd, struct msghdr* msg, int flags);\nssize_t sendmsg(int sockfd, struct msghdr* msg, int flags);\n\nstruct msghdr\n{\n/* socket address --- 指向socket地址结构变量, 对于TCP连接需要设置为NULL*/\n\tvoid* msg_name; \n\n\n\tsocklen_t msg_namelen;\n\t\n\t/* 分散的内存块 --- 对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由\n     * msg_iov指向的数组指定, 称为分散读(scatter read)  ---对于sendmsg而言, msg_iovlen块的分散内存中\n     * 的数据将一并发送称为集中写(gather write);\n\t*/\n\tstruct iovec* msg_iov;\n\tint msg_iovlen; /* 分散内存块的数量*/\n\tvoid* msg_control; /* 指向辅助数据的起始位置*/\n\tsocklen_t msg_controllen; /* 辅助数据的大小*/\n\tint msg_flags; /* 复制函数的flags参数, 并在调用过程中更新*/\n};\n\nstruct iovec\n{\n\tvoid* iov_base /* 内存起始地址*/\n\tsize_t iov_len /* 这块内存长度*/\n}\n```\n**其他Api**\n```c\n#include <sys/socket.h>\n// 用于判断 sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据, \n// 是的话返回1, 不是返回0\n// 这样就可以选择带MSG_OOB标志的recv调用来接收带外数据. \nint sockatmark(int sockfd);\n\n// getsockname 获取sockfd对应的本端socket地址, 存入address指定的内存中, 长度存入address_len中 成功返回0失败返回-1\n// getpeername 获取远端的信息, 同上\nint getsockname(int sockfd, struct sockaddr* address, socklen_t* address_len);\nint getpeername(int sockfd, struct sockaddr* address, socklen_t* address_len);\n\n/* 以下函数头文件均相同*/\n\n// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度\n// 成功时返回0 失败返回-1\nint getsockopt(int sockfd, int level, int option_name, void* option_value, \n\t\t\t\t\t\tsocklen_t restrict option_len);\nint setsockopt(int sockfd, int level, int option_name, void* option_value, \n\t\t\t\t\t\tsocklen_t restrict option_len);\n```\n\n| SO_REUSEADDR | 重用本地地址      | sock被设置此属性后, 即使sock在被bind()后处于TIME_WAIT状态, 此时与他绑定的socket地址依然能够立即重用来绑定新的sock        |\n| ------------ | ----------------- | ------------------------------------------------------------------------------------------------------------------------ |\n| SO_RCVBUF    | TCP接收缓冲区大小 | 最小值为256字节. 设置完后系统会自动加倍你所设定的值. 多出来的一倍将用用作空闲缓冲区处理拥塞                              |\n| SO_SNDBUF    | TCP发送缓冲区大小 | 最小值为2048字节                                                                                                         |\n| SO_RCVLOWAT  | 接收的低水位标记  | 默认为1字节, 当TCP接收缓冲区中可读数据的总数大于其低水位标记时, IO复用系统调用将通知应用程序可以从对应的socket上读取数据 |\n| SO_SNDLOWAT  | 发送的高水位标记  | 默认为1字节, 当TCP发送缓冲区中空闲空间大于低水位标记的时候可以写入数据                                                   |\n| SO_LINGER    |                   |                                                                                                                          |\n\n\n```c\nstruct linger\n{\n\tint l_onoff /* 开启非0, 关闭为0*/\n\tint l_linger; /* 滞留时间*/\n\t/*\n\t* 当onoff为0的时候此项不起作用, close调用默认行为关闭socket\n\t* 当onoff不为0 且linger为0, close将立即返回, TCP将丢弃发送缓冲区的残留数据, 同时发送一个复位报文段\n\t* 当onoff不为0 且linger大于0 . 当socket阻塞的时候close将会等待TCP模块发送完残留数据并得到确认后关 \n\t* 闭, 如果是处于非阻塞则立即关闭\n\t*/\n};\n```\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/socket%E9%80%89%E9%A1%B9.jpg)\n**网络信息API**\n```c\n#include <netdb.h>\n// 通过主机名查找ip\nstruct hostent* gethostbyname(const char* name);\n\n// 通过ip获取主机完整信息 \n// type为IP地址类型 AF_INET和AF_INET6\nstruct hostent* gethostbyaddr(const void* addr, size_t len, int type);\n\nstruct hostent\n{\n  char *h_name;\t\t\t/* Official name of host.  */\n  char **h_aliases;\t\t/* Alias list.  */\n  int h_addrtype;\t\t/* Host address type.  */\n  int h_length;\t\t\t/* Length of address.  */\n  char **h_addr_list;\t\t/* List of addresses from name server.  */\n}\n\nint main(int argc, char* argv[])\n{\n    if (argc != 2)\n    {\n        printf(\"非法输入\\n\");\n        exit(0);\n    }\n    char* name = argv[1];\n\n    struct hostent *hostptr{};\n\n    hostptr = gethostbyname(name);\n    if (hostptr == nullptr)\n    {\n        printf(\"输入存在错误 或无法获取\\n\");\n        exit(0);\n    }\n\n    printf(\"Official name of hostptr: %s\\n\", hostptr->h_name);\n\n    char **pptr;\n    char inet_addr[INET_ADDRSTRLEN];\n\n    printf(\"Alias list:\\n\");\n    for (pptr = hostptr->h_aliases; *pptr != nullptr; ++pptr)\n    {\n        printf(\"\\t%s\\n\", *pptr);\n    }\n\n    switch (hostptr->h_addrtype)\n    {\n        case AF_INET:\n        {\n            printf(\"List of addresses from name server:\\n\");\n            for (pptr = hostptr->h_addr_list; *pptr != nullptr; ++pptr)\n            {\n                printf(\"\\t%s\\n\",\n                        inet_ntop(hostptr->h_addrtype, *pptr, inet_addr, sizeof(inet_addr)));\n            }\n            break;\n        }\n        default:\n        {\n            printf(\"unknow address type\\n\");\n            exit(0);\n        }\n    }\n    return 0;\n}\n\n/*\n./run baidu.com\nOfficial name of hostptr: baidu.com\nAlias list:\nList of addresses from name server:\n\t39.156.69.79\n\t220.181.38.148\n*/\n```\n以下两个函数通过读取/etc/services文件 来获取服务信息 以下内容来自维基百科\n\nService文件是现代操作系统在etc目录下的一个配置文件，记录网络服务名对应的端口号与协议 其用途如下\n- 通过TCP/IP的API函数（声明在netdb.h中）直接查到网络服务名与端口号、使用协议的对应关系。如getservbyname(\"serve\",\"tcp\")获取端口号;getservbyport（htons（port），“tcp”）获取端口和协议上的服务名\n- 如果用户在这个文件中维护所有使用的网络服务名字、端口、协议，那么可以一目了然的获悉哪些端口号用于哪个服务，哪些端口号是空闲的\n```c\n#include <netdb.h>\n// 根据名称获取某个服务的完整信息\nstruct servent getservbyname(const char* name, const char* proto);\n\n// 根据端口号获取服务信息\nstruct servent getservbyport(int port, const char* proto);\n\nstruct servent\n{\n\tchar* s_name; /* 服务名称*/\n\tchar ** s_aliases; /* 服务的别名列表*/\n\tint s_port; /* 端口号*/\n\tchar* s_proto; /* 服务类型, 通常为TCP或UDP*/\n}\n```\n```c\n#include <netdb.h>\n// 内部使用的gethostbyname 和 getserverbyname\n// hostname 用于接收主机名, 也可以用来接收字符串表示的IP地址(点分十进制, 十六进制字符串)\n// service 用于接收服务名, 字符串表示的十进制端口号\n// hints参数 对getaddrinfo的输出进行更准确的控制, 可以设置为NULL, 允许反馈各种有用的结果\n// result 指向一个链表, 用于存储getaddrinfo的反馈结果\nint getaddrinfo(const char* hostname, const char* service, const struct addrinfo* hints, struct addrinfo** result)\n\nstruct addrinfo\n{\n\tint ai_flags;\n\tint ai_family;\n\tint ai_socktype; /* 服务类型, SOCK_STREAM或者SOCK_DGRAM*/\n\tint ai_protocol;\n\tsocklen_t ai_addrlen;\n\tchar* ai_canonname; /* 主机的别名*/\n\tstruct sockaddr* ai_addr; /* 指向socket地址*/\n\tstruct addrinfo* ai_next; /* 指向下一个结构体*/\n}\n\n// 需要手动的释放堆内存\nvoid freeaddrinfo(struct addrinfo* res);\n```\n![](https://ftp.bmp.ovh/imgs/2019/08/7ebedb14d8eedeac.png)\n\n```c\n#include <netdb.h>\n// host 存储返回的主机名\n// serv存储返回的服务名\n\nint getnameinfo(const struct sockaddr* sockaddr, socklen_t addrlen, char* host, socklen_t hostlen, char* serv\n\tsocklen_t servlen, int flags);\n\n```\n![](https://ftp.bmp.ovh/imgs/2019/08/bc7196e9a30d5152.png)\n\n测试\n使用\n```shell\ntelnet ip port #来连接服务器的此端口\nnetstat -nt | grep port #来查看此端口的监听\n```\n\n## 第六章高级IO函数\n\nLinux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件自然限制了他的使用频率\n*文件描述符*\n文件描述符在是一个非负整数。是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表。\nSTDOUT_FILENO(值为1)- 值为1的文件描述符为标准输出, 关闭STDOUT_FILENO后用dup即可返回最小可用值(目前为, 1) 这样输出就重定向到了调用dup的参数指向的文件\n\n### 创建文件描述符 - pipe dup dup2 splice select\n**pipe函数**\n这个函数可用于创建一个管道, 实现进程间的通信. \n\n```c\n// 函数定义\n// 参数文件描述符数组 fd[0] 读出 fd[1]写入 单向管道\n// 成功返回0, 并将一对打开的文件描述符填入其参数指向的数组\n// 失败返回-1 errno\n#include <unistd.h>\nint pipe(int fd[2]);\n```\n```c\n// 双向管道\n// 第一个参数为 协议PF_UNIX(书上是AF_UNIX)感觉这里指明协议使用PF更好一些\n#include <sys/types.h>\n#include <sys/socket.h>\nint socketpair(int domain, int type, int protocol, int fd[2]);\n```\n学习了后面的内容了解到了进程间通信, 回来补上一个例子\n```c\nint main()\n{\n    int fds[2];\n    socketpair(PF_UNIX, SOCK_STREAM, 0, fds);\n    int pid = fork();\n    if (pid == 0)\n    {\n        close(fds[0]);\n        char a[] = \"123\";\n        send(fds[1], a, strlen(a), 0);\n    }\n    else if (pid > 0)\n    {\n        close(fds[1]);\n        char b[20] {};\n        recv(fds[0], b, 20, 0);\n        printf(\"%s\", b);\n    }\n}\n```\n**dup和dup2函数**\n复制一个现有的文件描述符\n```c\n#include <unistd.h>\n// 返回的文件描述符总是取系统当前可用的最小整数值\nint dup(int oldfd);\n// 可以用newfd来制定新的文件描述符, 如果newfd已经被打开则先关闭\n// 如果newfd==oldfd 则不关闭newfd直接返回\nint dup2(int oldfd, int newfd);\n```\ndup函数创建一个新的文件描述符, 新的文件描述符和原有的file_descriptor共同指向相同的目标.\n回来补上例子, 这个例子由于关掉了`STDOUT_FILENO`dup最小的即为`STDOUT_FILENO`所以\n标准输出都到了这个文件之中\n```c\nint main()\n{\n    int filefd = open(\"/home/lsmg/1.txt\", O_WRONLY);\n    close(STDOUT_FILENO);\n    dup(filefd);\n    printf(\"123\\n\");\n    exit(0);\n}\n```\n\n### 读写数据 - readv writev mmap munmap\n**readv/writev**\n```c\n#include <sys/uio.h>\n// count 为 vector的长度, 即为有多少块内存\n// 成功时返回写入\\读取的长度 失败返回-1\nssize_t readv(int fd, const struct iovec* vector, int count);\nssize_t writev(int fd, const struct iovec* vector, int count);\n\nstruct iovec {\n\tvoid* iov_base /* 内存起始地址*/\n\tsize_t iov_len /* 这块内存长度*/\n}\n```\n回来补上一个使用例子, 这个例子将一个int的内存表示写入到了文件之中\n使用hexdump查看这个文件`0000000 86a0 0001`可以看到`186a0`即为100000\n```c\n// 2020年1月7日16:52:11\nint main()\n{\n    int file = open(\"/home/lsmg/1.txt\", O_WRONLY);\n    int temp = 100000;\n    iovec temp_iovec{};\n    temp_iovec.iov_base = &temp;\n    temp_iovec.iov_len = sizeof(temp);\n    writev(file, &temp_iovec, 1);\n}\n```\nsendfile函数\n```c\n#include <sys/sendfile.h>\n// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取\nssize_t sendfile(int out_fd, int in_fd, off_t* offset, size_t count);\n\nO_RDONLY只读模式\nO_WRONLY只写模式\nO_RDWR读写模式\nint open(file_name, flag);\n```\nstat结构体, 可用fstat生成, **简直就是文件的身份证**\n```c\n#include <sys/stat.h>\nstruct stat\n{\n    dev_t       st_dev;     /* ID of device containing file -文件所在设备的ID*/\n    ino_t       st_ino;     /* inode number -inode节点号*/\n    mode_t      st_mode;    /* protection -保护模式?*/\n    nlink_t     st_nlink;   /* number of hard links -链向此文件的连接数(硬连接)*/\n    uid_t       st_uid;     /* user ID of owner -user id*/\n    gid_t       st_gid;     /* group ID of owner - group id*/\n    dev_t       st_rdev;    /* device ID (if special file) -设备号，针对设备文件*/\n    off_t       st_size;    /* total size, in bytes -文件大小，字节为单位*/\n    blksize_t   st_blksize; /* blocksize for filesystem I/O -系统块的大小*/\n    blkcnt_t    st_blocks;  /* number of blocks allocated -文件所占块数*/\n    time_t      st_atime;   /* time of last access -最近存取时间*/\n    time_t      st_mtime;   /* time of last modification -最近修改时间*/\n    time_t      st_ctime;   /* time of last status change - */\n};\n```\n**身份证**生成函数\n```c\n// 第一个参数需要调用open生成文件描述符\n// 下面其他两个为文件全路径\nint fstat(int filedes, struct stat *buf);\n\n// 当路径指向为符号链接的时候, lstat为符号链接的信息. stat为符号链接指向文件信息\nint stat(const char *path, struct stat *buf);\nint lstat(const char *path, struct stat *buf);\n\n/*\n* ln -s source dist  建立软连接, 类似快捷方式, 也叫符号链接\n* ln source dist  建立硬链接, 同一个文件使用多个不同的别名, 指向同一个文件数据块, 只要硬链接不被完全\n* 删除就可以正常访问\n* 文件数据块 - 文件的真正数据是一个文件数据块, 打开的`文件`指向这个数据块, 就是说\n* `文件`本身就类似快捷方式, 指向文件存在的区域.\n*/\n```\n **mmap和munmap函数**\n\n`mmap`创建一块进程通讯共享的内存(可以将文件映射入其中), `munmap`释放这块内存\n```c\n#include <sys/mman.h>\n\n// start 内存起始位置, 如果为NULL则系统分配一个地址 length为长度\n// port参数 PROT_READ(可读) PROT_WRITE(可写) PROT_EXEC(可执行), PROT_NONE(不可访问)\n// flag参数 内存被修改后的行为\n// - MAP_SHARED 进程间共享内存, 对内存的修改反映到映射文件中\n// - MAP_PRIVATE 为调用进程私有, 对该内存段的修改不会反映到文件中\n// - MAP_ANONUMOUS 不是从文件映射而来, 内容被初始化为0, 最后两个参数被忽略\n// 成功返回区域指针, 失败返回 -1\nvoid* mmap(void* start, size_t length, int port, int flags, int fd, off_t offset);\n// 成功返回0 失败返回-1\nint munmap(void* start, size_t length);\n```\n**splice函数**\n用于在两个文件名描述符之间移动数据, 0拷贝操作\n```c\n#include <fcntl.h>\n// fd_in 为文件描述符, 如果为管道文件描述符则 off_in必须为NULL, 否则为读取开始偏移位置\n// len为指定移动的数据长度, flags参数控制数据如何移动.\n// - SPLICE_F_NONBLOCK 非阻塞splice操作, 但会受文件描述符自身的阻塞\n// - SPLICE_F_MORE 给内核一个提示, 后续的splice调用将读取更多的数据???????\nssize_t splice(int fd_in, loff_t* off_in, int fd_out, loff_t* off_out, size_t len, unsigned int flags);\n\n// 使用splice函数  实现echo服务器\nint main(int argc, char* argv[])\n{\n    if (argc <= 2)\n    {\n        printf(\"the parmerters is wrong\\n\");\n        exit(errno);\n    }\n    char *ip = argv[1];\n\n    int port = atoi(argv[2]);\n    printf(\"the port is %d the ip is %s\\n\", port, ip);\n\n    int sockfd = socket(PF_INET, SOCK_STREAM, 0);\n    assert(sockfd >= 0);\n\n    struct sockaddr_in address{};\n    address.sin_family = AF_INET;\n    address.sin_port = htons(port);\n    inet_pton(AF_INET, ip, &address.sin_addr);\n\n    int ret = bind(sockfd, (sockaddr*)&address, sizeof(address));\n    assert(ret != -1);\n\n    ret = listen(sockfd, 5);\n\n    int clientfd{};\n    sockaddr_in client_address{};\n    socklen_t client_addrlen = sizeof(client_address);\n\n    clientfd = accept(sockfd, (sockaddr*)&client_address, &client_addrlen);\n    if (clientfd < 0)\n    {\n        printf(\"accept error\\n\");\n    }\n    else\n    {\n        printf(\"a new connection from %s:%d success\\n\", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));\n        int fds[2];\n        pipe(fds);\n        ret = splice(clientfd, nullptr, fds[1], nullptr, 32768, SPLICE_F_MORE);\n        assert(ret != -1);\n\n        ret = splice(fds[0], nullptr, clientfd, nullptr, 32768, SPLICE_F_MORE);\n        assert(ret != -1);\n\n        close(clientfd);\n    }\n    close(sockfd);\n    exit(0);\n}\n```\n\n**select 函数**\nselect函数在第二个参数列表 可读的时候返回\n或者是等到了规定的时间返回\n\n返回之后 第二个参数指向fdset的集合 被修改为可读的fd列表\n这就需要每次返回后都更新 fdset集合\n\n返回后 此函数的返回值为可读的fd数量, 遍历fdset集合 同时使用FD_ISSET判断fdset[i] 是否在其中\n然后判断此fd是否为listenfd 如果是则接受新的连接 如果不是说明是已经接受的其他fd 判断是有数据可读\n还是此连接断开\n\n```c\n#include <fcntl.h> \n// maxfdp 最大数 FD_SETSIZE\n// struct fd_set 一个集合,可以存储多个文件描述符\n// - FD_ZERO(&fd_set) 清空 -FD_SET(fd, &fd_set) 放入fd FD_CLR(fd, &fd_set)从其中清除fd\n// - FD_ISSET(fd, &fd_set) 判断是否在其中\n// readfds  需要监视的文件描述符读变化, 其中的文件描述符可读的时候返回\n// writefds 需要监视的文件描述符写变化, 其中的文件描述符可写的时候返回\n// errorfds 错误\n// timeout 传入NULL为阻塞, 设置为0秒0微秒则变为非阻塞函数\n// 返回值 负值为错误 等待超时说明文件无变化返回0 有变化返回正值\nint select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout); \n\n#define exit_if(r, ...) \\\n{   \\\n    if (r)  \\\n    {   \\\n        printf(__VA_ARGS__);    \\\n        printf(\"errno no: %d, error msg is %s\", errno, strerror(errno));    \\\n        exit(1);    \\\n    }   \\\n}   \\\n\nint main(int argc, char* argv[])\n{\n    int keyboard_fd = open(\"/dev/tty\", O_RDONLY | O_NONBLOCK);\n    exit_if(keyboard_fd < 0, \"open keyboard fd error\\n\");\n    fd_set readfd;\n    char recv_buffer = 0;\n\n    while (true)\n    {\n        FD_ZERO(&readfd);\n        FD_SET(0, &readfd);\n\n        timeval timeout {5, 0};\n\n        int ret = select(keyboard_fd + 1, &readfd, nullptr, nullptr, &timeout);\n        exit_if(ret == -1, \"select error\\n\");\n        if (ret > 0)\n        {\n            if (FD_ISSET(keyboard_fd, &readfd))\n            {\n                recv_buffer = 0;\n                read(keyboard_fd, &recv_buffer, 1);\n                if ('\\n' == recv_buffer)\n                {\n                    continue;\n                }\n                if ('q' == recv_buffer)\n                {\n                    break;\n                }\n                printf(\"the input is %c\\n\", recv_buffer);\n            }\n\n        }\n        if (ret == 0)\n        {\n            printf(\"timeout\\n\");\n        }\n    }\n}\n```\n## 第七章Linux服务器程序规范\n\n- Linux程序服务器 一般以后台进程形式运行.  后台进程又称为守护进程(daemon). 他没有控制终端, 因而不会意外的接收到用户输入. 守护进程的父进程通常都是init进程(PID为1的进程)\n- Linux服务器程序有一套日志系统, 他至少能输出日志到文件. 日志这东西太重要了,排错对比全靠它.\n- Linux服务器程序一般以某个专门的非root身份运行. 比如mysqld有自己的账户mysql.\n- Linux服务器程序一般都有自己的配置文件, 而不是把所有配置都写死在代码里面, 方便后续的更改.\n- Linux服务器程序通常在启动的时候生成一个PID文件并存入/var/run 目录中, 以记录改后台进程的PID.\n- Linux服务器程序通常需要考虑系统资源和限制, 预测自己的承受能力\n\n### 日志\n\n```shell\nsudo service rsyslog restart // 启动守护进程\n```\n```c\n#include <syslog.h>\n// priority参数是所谓的设施值(记录日志信息来源, 默认为LOG_USER)与日志级别的按位或\n// - 0 LOG_EMERG  /* 系统不可用*/\n// - 1 LOG_ALERT   /* 报警需要立即采取行动*/\n// - 2 LOG_CRIT /* 非常严重的情况*/\n// - 3 LOG_ERR  /* 错误*/\n// - 4 LOG_WARNING /* 警告*/\n// - 5 LOG_NOTICE /* 通知*/\n// - 6 LOG_INFO /* 信息*/\n//  -7 LOG_DEBUG /* 调试*/\nvoid syslog(int priority, const char* message, .....);\n\n// ident 位于日志的时间后 通常为名字\n// logopt 对后续 syslog调用的行为进行配置\n// -  0x01 LOG_PID  /* 在日志信息中包含程序PID*/\n// -  0x02 LOG_CONS /* 如果信息不能记录到日志文件, 则打印到终端*/\n// -  0x04 LOG_ODELAY /* 延迟打开日志功能直到第一次调用syslog*/\n// -  0x08 LOG_NDELAY /* 不延迟打开日志功能*/\n// facility参数可以修改syslog函数中的默认设施值\nvoid openlog(const char* ident, int logopt, int facility);\n\n// maskpri 一共八位 0000-0000\n// 如果将最后一个0置为1 表示 记录0级别的日志\n// 如果将最后两个0都置为1 表示记录0和1级别的日志\n// 可以通过LOG_MASK() 宏设定 比如LOG_MASK(LOG_CRIT) 表示将倒数第三个0置为1, 表示只记录LOG_CRIT\n// 如果直接设置setlogmask(3); 3的二进制最后两个数均为1 则记录 0和1级别的日志\nint setlogmask(int maskpri);\n\n// 关闭日志功能\nvoid closelog();\n```\n\n### 用户信息, 切换用户\nUID - 真实用户ID\nEUID - 有效用户ID - 方便资源访问\nGID - 真实组ID\nEGID - 有效组ID\n```c\n#include <sys/types.h>\n#include <unistd.h>\n\nuid_t getuid();\nuid_t geteuid();\ngid_t getgid();\ngid_t getegid();\nint setuid(uid_t uid);\nint seteuid(uid_t euid);\nint setgid(gid_t gid);\nint setegid(gid_t gid);\n```\n\n可以通过 `setuid`和`setgid`切换用户 **root用户uid和gid均为0**\n\n### 进程间关系\nPGID - 进程组ID(Linux下每个进程隶属于一个进程组)\n\n#include <unistd.h>\npid_t getpgid(pid_t pid); 成功时返回pid所属的pgid 失败返回-1\nint setpgid(pid_t pid, pid_t pgid);\n\n**会话**\n一些有关联的进程组将形成一个会话\n略过\n\n**查看进程关系**\nps和less\n\n**资源限制**\n略\n**改变目录**\n略\n\n## 第八章高性能服务器程序框架\n\n**服务器模型-CS模型**\n\n**优点**\n- 实现起来简单\n**缺点**\n- 服务器是通信的中心, 访问过大的时候会导致响应过慢\n\n模式图\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%BE8-2%20TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)\n\n编写的demo 没有用到fork函数. 后续待完善\n\n**服务器框架 IO模型**\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png)\n\n这个模型大概能够理解, 自己也算是学了半年的Javaweb.\n\nsocket在创建的时候默认是阻塞的, 不过可以通过传`SOCK_NONBLOCK`参解决\n非阻塞调用都会立即返回 但可能事件没有发生(recv没有接收到信息), 没有发生和出错都会`返回-1` 所以需要通过`errno`来区分这些错误.\n**事件未发生**\naccept, send,recv errno被设置为 `EAGAIN(再来一次)`或`EWOULDBLOCK(期望阻塞)`\nconnect 被设置为 `EINPROGRESS(正在处理中)`\n\n需要在事件已经发生的情况下 去调用非阻塞IO, 才能提高性能\n\n常用IO复用函数 `select` `poll` `epoll_wait` 将在第九章后面说明\n信号将在第十章说明\n\n**两种高效的事件处理模式和并发模式**\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Reactor%E6%A8%A1%E5%BC%8F.png)\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Proactor%E6%A8%A1%E5%BC%8F.png)\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E7%94%A8%E5%90%8C%E6%AD%A5IO%E6%A8%A1%E6%8B%9F%E5%87%BA%E7%9A%84Proactor%E6%A8%A1%E5%BC%8F.png)\n\n程序分为计算密集型(CPU使用很多, IO资源使用很少)和IO密集型(反过来).\n前者使用并发编程反而会降低效率, 后者则会提升效率\n并发编程有多进程和多线程两种方式\n\n并发模式 - IO单元和多个逻辑单元之间协调完成任务的方法.\n服务器主要有两种并发模式\n- 半同步/半异步模式\n- 领导者/追随者模式\n\n**半同步/半异步模式**\n在IO模型中, 异步和同步的区分是内核向应用程序通知的是何种IO事件(就绪事件还是完成事件), 以及由谁来完成IO读写(应用程序还是内核)\n\n而在这里(并发模式) \n同步指的是完全按照代码序列的顺序执行 - 按照同步方式运行的线程称为同步线程\n异步需要系统事件(中断, 信号)来驱动 - 按照异步方式运行的线程称为异步线程\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5.png)\n\n服务器(需要较好的实时性且能同时处理多个客户请求) - 一般使用同步线程和异步线程来实现,即为半同步/半异步模式\n同步线程 - 处理客户逻辑, 处理请求队列中的对象\n异步线程 - 处理IO事件, 接收到客户请求后将其封装成请求对象并插入请求队列\n\n半同步/半异步模式 存在变体 `半同步/半反应堆模式`\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F.png)\n\n异步线程 - 主线程 - 负责监听所有socket上的事件\n\n**领导者/追随者模式**\n略\n\n**高效编程方法 - 有限状态机**\n```c\n// 状态独立的有限状态机\nSTATE_MACHINE(Package _pack) {\n\t\n\tPackageType _type = _pack.GetType();\n\tswitch(_type) {\n\t\tcase type_A:\n\t\t\txxxx;\n\t\t\tbreak;\n\t\tcase type_B:\n\t\t\txxxx;\n\t\t\tbreak;\n\t}\n}\n\n// 带状态转移的有限状态机\nSTATE_MACHINE() {\n\tState cur_State = type_A;\n\twhile(cur_State != type_C) {\n\t\n\t\tPackage _pack = getNewPackage();\n\t\tswitch(cur_State) {\n\t\t\t\n\t\t\tcase type_A:\n\t\t\t\tprocess_package_state_A(_pack);\n\t\t\t\tcur_State = type_B;\n\t\t\t\tbreak;\n\t\t\tcase type_B:\n\t\t\t\txxxx;\n\t\t\t\tcur_State = type_C;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n花了小一个小时 终于一个字母一个字母的抄完了那个5000多字的代码\n@2019年9月8日22:08:46@\n\n### 提高服务器性能的其他建议 池 数据复制 上下文切换和锁\n\n**池** - 用空间换取时间\n进程池和线程池\n\n**数据复制** - 高性能的服务器应该尽量避免不必要的复制\n\n**上下文切换和锁**\n减少`锁`的作用区域. 不应该创建太多的工作进程, 而是使用专门的业务逻辑线程.\n\n","source":"_posts/CPP-读书记录100-高性能服务器编程读书记录初级部分.md","raw":"---\ntitle: Linux高性能服务器-初级部分\ntags:\n  - null\ncategories:\n  - CPP\n  - 服务器编程-书籍记录\ndate: 2019-08-17 20:34:39\n\ntop: 100\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg\n---\n开头选了这本书, 看到这本书是他人总结三大本后自己写的, 先求个理解大概.\n话说别人推荐的c++服务器咋都是c语言.....\n2019年8月17日20:37:53\n\n每学习一部分就写一个demo\n<!--more-->\n\n## 第五章Linux网络编程基础API\n\n\nsocket基础api位于 `sys/socket.h` 头文件中\nsocket最开始的含义是 一个IP地址和端口对. 唯一的表示了TCP通信的一段\n网络信息api `netdb.h`头文件中\n\n### 主机字节序和网络字节序\n字节序分为 `大端字节序`和`小端字节序`\n由于大多数PC采用小端字节序(高位存在高地址处), 所以小端字节序又称为主机字节序\n\n为了防止不同机器字节序不同导致的错乱问题. 规定传输的时候统一为 大端字节序(网络字节序).\n这样主机会根据自己的情况决定 - 是否转换接收到的数据的字节序\n\n\n### API\n\n**基础连接**\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93.jpg)\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88%E5%9C%B0%E5%9D%80%E6%97%8F.jpg)\n```c++\n// 主机序和网络字节序转换\n#include <netinet/in.h>\nunsigned long int htonl (unsigned long int hostlong); // host to network long\nunsigned short int htons (unsigned short int hostlong); // host to network short\n\nunsigned long int htonl (unsigned long int netlong);\nunsigned short int htons (unsigned short int netlong);\n\n// IP地址转换函数\n#include <arpa/inet.h>\n// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONE\nin_addr_t  inet_addr( const char* strptr);\n\n// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0\nint inet_aton( const char* cp, struct in_addr* inp);\n\n// 函数返回一个静态变量地址值, 所以多次调用会导致覆盖\nchar* inet_ntoa(struct in_addr in); \n\n// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族\n// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1\nint inet_pton(int af, const char * src, void* dst);\n// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)\nconst char* inet_ntop(int af, const void*  src, char* dst, socklen_t cnt);\n\n\n// 创建 命名 监听 socket\n# include <sys/types.h>\n# include <sys/socket.h>\n// domain指定使用那个协议族 PF_INET PF_INET6\n// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)\n// protocol设置为默认的0\n// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1\nint socket(int domain, int type, int protocol);\n\n// socket为socket文件描述符\n// my_addr 为地址信息\n// addrlen为socket地址长度\n// 成功返回0 失败返回 -1\nint bind(int socket, const struct sockaddr* my_addr, socklen_t addrlen);\n\n// backlog表示队列最大的长度\nint listen(int socket, int backlog);\n// 接受连接 失败返回-1 成功时返回socket\nint accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen)\n```\n客户端\n```c\n// 发起连接\n#include <sys/types.h>\n#include <sys/socket.h>\n// 第三个参数为 地址指定的长度\n// 成功返回0 失败返回-1\nint connect(int sockfd, const struct sockaddr * serv_addr, socklen_t addrlen);\n\n// 关闭连接\n#include <unistd.h>\n// 参数为保存的socket\n// 并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才能关闭(需要查阅)\nint close(int fd);\n\n// 立即关闭\n#include <sys/socket.h>\n// 第二个参数为可选值 \n//\tSHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃\n//\tSHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去\n//\tSHUT_RDWR 同时关闭读和写\n// 成功返回0 失败为-1 设置errno\nint shutdown(int sockfd, int howto)\n```\n**基础TCP**\n```c\n#include<sys/socket.h>\n#include<sys/types.h>\n\n// 读取sockfd的数据\n// buf 指定读缓冲区的位置\n// len 指定读缓冲区的大小\n// flags 参数较多\n// 成功的时候返回读取到的长度, 可能小于预期长度, 需要多次读取.   读取到0 通信对方已经关闭连接, 错误返回-1\nssize_t recv(int sockfd, void *buf, size_t len, int flags);\n// 发送\nssize_t send(int sockfd, const void *buf, size_t len, int flags);\n```\n\n| 选项名        | 含义                                                                                     | 可用于发送 | 可用于接收 |\n| ------------- | ---------------------------------------------------------------------------------------- | ---------- | ---------- |\n| MSG_CONFIRM   | 指示链路层协议持续监听, 直到得到答复.(仅能用于SOCK_DGRAM和SOCK_RAW类型的socket)          | Y          | N          |\n| MSG_DONTROUTE | 不查看路由表, 直接将数据发送给本地的局域网络的主机(代表发送者知道目标主机就在本地网络中) | Y          | N          |\n| MSG_DONTWAIT  | 非阻塞                                                                                   | Y          | Y          |\n| MSG_MORE      | 告知内核有更多的数据要发送, 等到数据写入缓冲区完毕后,一并发送.减少短小的报文提高传输效率 | Y          | N          |\n| MSG_WAITALL   | 读操作一直等待到读取到指定字节后才会返回                                                 | N          | Y          |\n| MSG_PEEK      | 看一下内缓存数据, 并不会影响数据                                                         | N          | Y          |\n| MSG_OOB       | 发送或接收紧急数据                                                                       | Y          | Y          |\n| MSG_NOSIGNAL  | 向读关闭的管道或者socket连接中写入数据不会触发SIGPIPE信号                                | Y          |        N    |\n\n**基础UDP**\n```c\n#include <sys/types.h>\n#include <sys/socket.h>\n// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.\n// 不过recvfrom和sendto 也可以用于 面向STREAM的连接, 这样可以省略发送和接收端的socket地址\nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen);\nssize_t sendto(int sockfd, const void* buf, size_t len, ing flags, const struct sockaddr* dest_addr, socklen_t addrlen);\n\n```\n\n**通用读写函数**\n\n```c\n#inclued <sys/socket.h>\nssize_t recvmsg(int sockfd, struct msghdr* msg, int flags);\nssize_t sendmsg(int sockfd, struct msghdr* msg, int flags);\n\nstruct msghdr\n{\n/* socket address --- 指向socket地址结构变量, 对于TCP连接需要设置为NULL*/\n\tvoid* msg_name; \n\n\n\tsocklen_t msg_namelen;\n\t\n\t/* 分散的内存块 --- 对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由\n     * msg_iov指向的数组指定, 称为分散读(scatter read)  ---对于sendmsg而言, msg_iovlen块的分散内存中\n     * 的数据将一并发送称为集中写(gather write);\n\t*/\n\tstruct iovec* msg_iov;\n\tint msg_iovlen; /* 分散内存块的数量*/\n\tvoid* msg_control; /* 指向辅助数据的起始位置*/\n\tsocklen_t msg_controllen; /* 辅助数据的大小*/\n\tint msg_flags; /* 复制函数的flags参数, 并在调用过程中更新*/\n};\n\nstruct iovec\n{\n\tvoid* iov_base /* 内存起始地址*/\n\tsize_t iov_len /* 这块内存长度*/\n}\n```\n**其他Api**\n```c\n#include <sys/socket.h>\n// 用于判断 sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据, \n// 是的话返回1, 不是返回0\n// 这样就可以选择带MSG_OOB标志的recv调用来接收带外数据. \nint sockatmark(int sockfd);\n\n// getsockname 获取sockfd对应的本端socket地址, 存入address指定的内存中, 长度存入address_len中 成功返回0失败返回-1\n// getpeername 获取远端的信息, 同上\nint getsockname(int sockfd, struct sockaddr* address, socklen_t* address_len);\nint getpeername(int sockfd, struct sockaddr* address, socklen_t* address_len);\n\n/* 以下函数头文件均相同*/\n\n// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度\n// 成功时返回0 失败返回-1\nint getsockopt(int sockfd, int level, int option_name, void* option_value, \n\t\t\t\t\t\tsocklen_t restrict option_len);\nint setsockopt(int sockfd, int level, int option_name, void* option_value, \n\t\t\t\t\t\tsocklen_t restrict option_len);\n```\n\n| SO_REUSEADDR | 重用本地地址      | sock被设置此属性后, 即使sock在被bind()后处于TIME_WAIT状态, 此时与他绑定的socket地址依然能够立即重用来绑定新的sock        |\n| ------------ | ----------------- | ------------------------------------------------------------------------------------------------------------------------ |\n| SO_RCVBUF    | TCP接收缓冲区大小 | 最小值为256字节. 设置完后系统会自动加倍你所设定的值. 多出来的一倍将用用作空闲缓冲区处理拥塞                              |\n| SO_SNDBUF    | TCP发送缓冲区大小 | 最小值为2048字节                                                                                                         |\n| SO_RCVLOWAT  | 接收的低水位标记  | 默认为1字节, 当TCP接收缓冲区中可读数据的总数大于其低水位标记时, IO复用系统调用将通知应用程序可以从对应的socket上读取数据 |\n| SO_SNDLOWAT  | 发送的高水位标记  | 默认为1字节, 当TCP发送缓冲区中空闲空间大于低水位标记的时候可以写入数据                                                   |\n| SO_LINGER    |                   |                                                                                                                          |\n\n\n```c\nstruct linger\n{\n\tint l_onoff /* 开启非0, 关闭为0*/\n\tint l_linger; /* 滞留时间*/\n\t/*\n\t* 当onoff为0的时候此项不起作用, close调用默认行为关闭socket\n\t* 当onoff不为0 且linger为0, close将立即返回, TCP将丢弃发送缓冲区的残留数据, 同时发送一个复位报文段\n\t* 当onoff不为0 且linger大于0 . 当socket阻塞的时候close将会等待TCP模块发送完残留数据并得到确认后关 \n\t* 闭, 如果是处于非阻塞则立即关闭\n\t*/\n};\n```\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/socket%E9%80%89%E9%A1%B9.jpg)\n**网络信息API**\n```c\n#include <netdb.h>\n// 通过主机名查找ip\nstruct hostent* gethostbyname(const char* name);\n\n// 通过ip获取主机完整信息 \n// type为IP地址类型 AF_INET和AF_INET6\nstruct hostent* gethostbyaddr(const void* addr, size_t len, int type);\n\nstruct hostent\n{\n  char *h_name;\t\t\t/* Official name of host.  */\n  char **h_aliases;\t\t/* Alias list.  */\n  int h_addrtype;\t\t/* Host address type.  */\n  int h_length;\t\t\t/* Length of address.  */\n  char **h_addr_list;\t\t/* List of addresses from name server.  */\n}\n\nint main(int argc, char* argv[])\n{\n    if (argc != 2)\n    {\n        printf(\"非法输入\\n\");\n        exit(0);\n    }\n    char* name = argv[1];\n\n    struct hostent *hostptr{};\n\n    hostptr = gethostbyname(name);\n    if (hostptr == nullptr)\n    {\n        printf(\"输入存在错误 或无法获取\\n\");\n        exit(0);\n    }\n\n    printf(\"Official name of hostptr: %s\\n\", hostptr->h_name);\n\n    char **pptr;\n    char inet_addr[INET_ADDRSTRLEN];\n\n    printf(\"Alias list:\\n\");\n    for (pptr = hostptr->h_aliases; *pptr != nullptr; ++pptr)\n    {\n        printf(\"\\t%s\\n\", *pptr);\n    }\n\n    switch (hostptr->h_addrtype)\n    {\n        case AF_INET:\n        {\n            printf(\"List of addresses from name server:\\n\");\n            for (pptr = hostptr->h_addr_list; *pptr != nullptr; ++pptr)\n            {\n                printf(\"\\t%s\\n\",\n                        inet_ntop(hostptr->h_addrtype, *pptr, inet_addr, sizeof(inet_addr)));\n            }\n            break;\n        }\n        default:\n        {\n            printf(\"unknow address type\\n\");\n            exit(0);\n        }\n    }\n    return 0;\n}\n\n/*\n./run baidu.com\nOfficial name of hostptr: baidu.com\nAlias list:\nList of addresses from name server:\n\t39.156.69.79\n\t220.181.38.148\n*/\n```\n以下两个函数通过读取/etc/services文件 来获取服务信息 以下内容来自维基百科\n\nService文件是现代操作系统在etc目录下的一个配置文件，记录网络服务名对应的端口号与协议 其用途如下\n- 通过TCP/IP的API函数（声明在netdb.h中）直接查到网络服务名与端口号、使用协议的对应关系。如getservbyname(\"serve\",\"tcp\")获取端口号;getservbyport（htons（port），“tcp”）获取端口和协议上的服务名\n- 如果用户在这个文件中维护所有使用的网络服务名字、端口、协议，那么可以一目了然的获悉哪些端口号用于哪个服务，哪些端口号是空闲的\n```c\n#include <netdb.h>\n// 根据名称获取某个服务的完整信息\nstruct servent getservbyname(const char* name, const char* proto);\n\n// 根据端口号获取服务信息\nstruct servent getservbyport(int port, const char* proto);\n\nstruct servent\n{\n\tchar* s_name; /* 服务名称*/\n\tchar ** s_aliases; /* 服务的别名列表*/\n\tint s_port; /* 端口号*/\n\tchar* s_proto; /* 服务类型, 通常为TCP或UDP*/\n}\n```\n```c\n#include <netdb.h>\n// 内部使用的gethostbyname 和 getserverbyname\n// hostname 用于接收主机名, 也可以用来接收字符串表示的IP地址(点分十进制, 十六进制字符串)\n// service 用于接收服务名, 字符串表示的十进制端口号\n// hints参数 对getaddrinfo的输出进行更准确的控制, 可以设置为NULL, 允许反馈各种有用的结果\n// result 指向一个链表, 用于存储getaddrinfo的反馈结果\nint getaddrinfo(const char* hostname, const char* service, const struct addrinfo* hints, struct addrinfo** result)\n\nstruct addrinfo\n{\n\tint ai_flags;\n\tint ai_family;\n\tint ai_socktype; /* 服务类型, SOCK_STREAM或者SOCK_DGRAM*/\n\tint ai_protocol;\n\tsocklen_t ai_addrlen;\n\tchar* ai_canonname; /* 主机的别名*/\n\tstruct sockaddr* ai_addr; /* 指向socket地址*/\n\tstruct addrinfo* ai_next; /* 指向下一个结构体*/\n}\n\n// 需要手动的释放堆内存\nvoid freeaddrinfo(struct addrinfo* res);\n```\n![](https://ftp.bmp.ovh/imgs/2019/08/7ebedb14d8eedeac.png)\n\n```c\n#include <netdb.h>\n// host 存储返回的主机名\n// serv存储返回的服务名\n\nint getnameinfo(const struct sockaddr* sockaddr, socklen_t addrlen, char* host, socklen_t hostlen, char* serv\n\tsocklen_t servlen, int flags);\n\n```\n![](https://ftp.bmp.ovh/imgs/2019/08/bc7196e9a30d5152.png)\n\n测试\n使用\n```shell\ntelnet ip port #来连接服务器的此端口\nnetstat -nt | grep port #来查看此端口的监听\n```\n\n## 第六章高级IO函数\n\nLinux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件自然限制了他的使用频率\n*文件描述符*\n文件描述符在是一个非负整数。是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表。\nSTDOUT_FILENO(值为1)- 值为1的文件描述符为标准输出, 关闭STDOUT_FILENO后用dup即可返回最小可用值(目前为, 1) 这样输出就重定向到了调用dup的参数指向的文件\n\n### 创建文件描述符 - pipe dup dup2 splice select\n**pipe函数**\n这个函数可用于创建一个管道, 实现进程间的通信. \n\n```c\n// 函数定义\n// 参数文件描述符数组 fd[0] 读出 fd[1]写入 单向管道\n// 成功返回0, 并将一对打开的文件描述符填入其参数指向的数组\n// 失败返回-1 errno\n#include <unistd.h>\nint pipe(int fd[2]);\n```\n```c\n// 双向管道\n// 第一个参数为 协议PF_UNIX(书上是AF_UNIX)感觉这里指明协议使用PF更好一些\n#include <sys/types.h>\n#include <sys/socket.h>\nint socketpair(int domain, int type, int protocol, int fd[2]);\n```\n学习了后面的内容了解到了进程间通信, 回来补上一个例子\n```c\nint main()\n{\n    int fds[2];\n    socketpair(PF_UNIX, SOCK_STREAM, 0, fds);\n    int pid = fork();\n    if (pid == 0)\n    {\n        close(fds[0]);\n        char a[] = \"123\";\n        send(fds[1], a, strlen(a), 0);\n    }\n    else if (pid > 0)\n    {\n        close(fds[1]);\n        char b[20] {};\n        recv(fds[0], b, 20, 0);\n        printf(\"%s\", b);\n    }\n}\n```\n**dup和dup2函数**\n复制一个现有的文件描述符\n```c\n#include <unistd.h>\n// 返回的文件描述符总是取系统当前可用的最小整数值\nint dup(int oldfd);\n// 可以用newfd来制定新的文件描述符, 如果newfd已经被打开则先关闭\n// 如果newfd==oldfd 则不关闭newfd直接返回\nint dup2(int oldfd, int newfd);\n```\ndup函数创建一个新的文件描述符, 新的文件描述符和原有的file_descriptor共同指向相同的目标.\n回来补上例子, 这个例子由于关掉了`STDOUT_FILENO`dup最小的即为`STDOUT_FILENO`所以\n标准输出都到了这个文件之中\n```c\nint main()\n{\n    int filefd = open(\"/home/lsmg/1.txt\", O_WRONLY);\n    close(STDOUT_FILENO);\n    dup(filefd);\n    printf(\"123\\n\");\n    exit(0);\n}\n```\n\n### 读写数据 - readv writev mmap munmap\n**readv/writev**\n```c\n#include <sys/uio.h>\n// count 为 vector的长度, 即为有多少块内存\n// 成功时返回写入\\读取的长度 失败返回-1\nssize_t readv(int fd, const struct iovec* vector, int count);\nssize_t writev(int fd, const struct iovec* vector, int count);\n\nstruct iovec {\n\tvoid* iov_base /* 内存起始地址*/\n\tsize_t iov_len /* 这块内存长度*/\n}\n```\n回来补上一个使用例子, 这个例子将一个int的内存表示写入到了文件之中\n使用hexdump查看这个文件`0000000 86a0 0001`可以看到`186a0`即为100000\n```c\n// 2020年1月7日16:52:11\nint main()\n{\n    int file = open(\"/home/lsmg/1.txt\", O_WRONLY);\n    int temp = 100000;\n    iovec temp_iovec{};\n    temp_iovec.iov_base = &temp;\n    temp_iovec.iov_len = sizeof(temp);\n    writev(file, &temp_iovec, 1);\n}\n```\nsendfile函数\n```c\n#include <sys/sendfile.h>\n// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取\nssize_t sendfile(int out_fd, int in_fd, off_t* offset, size_t count);\n\nO_RDONLY只读模式\nO_WRONLY只写模式\nO_RDWR读写模式\nint open(file_name, flag);\n```\nstat结构体, 可用fstat生成, **简直就是文件的身份证**\n```c\n#include <sys/stat.h>\nstruct stat\n{\n    dev_t       st_dev;     /* ID of device containing file -文件所在设备的ID*/\n    ino_t       st_ino;     /* inode number -inode节点号*/\n    mode_t      st_mode;    /* protection -保护模式?*/\n    nlink_t     st_nlink;   /* number of hard links -链向此文件的连接数(硬连接)*/\n    uid_t       st_uid;     /* user ID of owner -user id*/\n    gid_t       st_gid;     /* group ID of owner - group id*/\n    dev_t       st_rdev;    /* device ID (if special file) -设备号，针对设备文件*/\n    off_t       st_size;    /* total size, in bytes -文件大小，字节为单位*/\n    blksize_t   st_blksize; /* blocksize for filesystem I/O -系统块的大小*/\n    blkcnt_t    st_blocks;  /* number of blocks allocated -文件所占块数*/\n    time_t      st_atime;   /* time of last access -最近存取时间*/\n    time_t      st_mtime;   /* time of last modification -最近修改时间*/\n    time_t      st_ctime;   /* time of last status change - */\n};\n```\n**身份证**生成函数\n```c\n// 第一个参数需要调用open生成文件描述符\n// 下面其他两个为文件全路径\nint fstat(int filedes, struct stat *buf);\n\n// 当路径指向为符号链接的时候, lstat为符号链接的信息. stat为符号链接指向文件信息\nint stat(const char *path, struct stat *buf);\nint lstat(const char *path, struct stat *buf);\n\n/*\n* ln -s source dist  建立软连接, 类似快捷方式, 也叫符号链接\n* ln source dist  建立硬链接, 同一个文件使用多个不同的别名, 指向同一个文件数据块, 只要硬链接不被完全\n* 删除就可以正常访问\n* 文件数据块 - 文件的真正数据是一个文件数据块, 打开的`文件`指向这个数据块, 就是说\n* `文件`本身就类似快捷方式, 指向文件存在的区域.\n*/\n```\n **mmap和munmap函数**\n\n`mmap`创建一块进程通讯共享的内存(可以将文件映射入其中), `munmap`释放这块内存\n```c\n#include <sys/mman.h>\n\n// start 内存起始位置, 如果为NULL则系统分配一个地址 length为长度\n// port参数 PROT_READ(可读) PROT_WRITE(可写) PROT_EXEC(可执行), PROT_NONE(不可访问)\n// flag参数 内存被修改后的行为\n// - MAP_SHARED 进程间共享内存, 对内存的修改反映到映射文件中\n// - MAP_PRIVATE 为调用进程私有, 对该内存段的修改不会反映到文件中\n// - MAP_ANONUMOUS 不是从文件映射而来, 内容被初始化为0, 最后两个参数被忽略\n// 成功返回区域指针, 失败返回 -1\nvoid* mmap(void* start, size_t length, int port, int flags, int fd, off_t offset);\n// 成功返回0 失败返回-1\nint munmap(void* start, size_t length);\n```\n**splice函数**\n用于在两个文件名描述符之间移动数据, 0拷贝操作\n```c\n#include <fcntl.h>\n// fd_in 为文件描述符, 如果为管道文件描述符则 off_in必须为NULL, 否则为读取开始偏移位置\n// len为指定移动的数据长度, flags参数控制数据如何移动.\n// - SPLICE_F_NONBLOCK 非阻塞splice操作, 但会受文件描述符自身的阻塞\n// - SPLICE_F_MORE 给内核一个提示, 后续的splice调用将读取更多的数据???????\nssize_t splice(int fd_in, loff_t* off_in, int fd_out, loff_t* off_out, size_t len, unsigned int flags);\n\n// 使用splice函数  实现echo服务器\nint main(int argc, char* argv[])\n{\n    if (argc <= 2)\n    {\n        printf(\"the parmerters is wrong\\n\");\n        exit(errno);\n    }\n    char *ip = argv[1];\n\n    int port = atoi(argv[2]);\n    printf(\"the port is %d the ip is %s\\n\", port, ip);\n\n    int sockfd = socket(PF_INET, SOCK_STREAM, 0);\n    assert(sockfd >= 0);\n\n    struct sockaddr_in address{};\n    address.sin_family = AF_INET;\n    address.sin_port = htons(port);\n    inet_pton(AF_INET, ip, &address.sin_addr);\n\n    int ret = bind(sockfd, (sockaddr*)&address, sizeof(address));\n    assert(ret != -1);\n\n    ret = listen(sockfd, 5);\n\n    int clientfd{};\n    sockaddr_in client_address{};\n    socklen_t client_addrlen = sizeof(client_address);\n\n    clientfd = accept(sockfd, (sockaddr*)&client_address, &client_addrlen);\n    if (clientfd < 0)\n    {\n        printf(\"accept error\\n\");\n    }\n    else\n    {\n        printf(\"a new connection from %s:%d success\\n\", inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));\n        int fds[2];\n        pipe(fds);\n        ret = splice(clientfd, nullptr, fds[1], nullptr, 32768, SPLICE_F_MORE);\n        assert(ret != -1);\n\n        ret = splice(fds[0], nullptr, clientfd, nullptr, 32768, SPLICE_F_MORE);\n        assert(ret != -1);\n\n        close(clientfd);\n    }\n    close(sockfd);\n    exit(0);\n}\n```\n\n**select 函数**\nselect函数在第二个参数列表 可读的时候返回\n或者是等到了规定的时间返回\n\n返回之后 第二个参数指向fdset的集合 被修改为可读的fd列表\n这就需要每次返回后都更新 fdset集合\n\n返回后 此函数的返回值为可读的fd数量, 遍历fdset集合 同时使用FD_ISSET判断fdset[i] 是否在其中\n然后判断此fd是否为listenfd 如果是则接受新的连接 如果不是说明是已经接受的其他fd 判断是有数据可读\n还是此连接断开\n\n```c\n#include <fcntl.h> \n// maxfdp 最大数 FD_SETSIZE\n// struct fd_set 一个集合,可以存储多个文件描述符\n// - FD_ZERO(&fd_set) 清空 -FD_SET(fd, &fd_set) 放入fd FD_CLR(fd, &fd_set)从其中清除fd\n// - FD_ISSET(fd, &fd_set) 判断是否在其中\n// readfds  需要监视的文件描述符读变化, 其中的文件描述符可读的时候返回\n// writefds 需要监视的文件描述符写变化, 其中的文件描述符可写的时候返回\n// errorfds 错误\n// timeout 传入NULL为阻塞, 设置为0秒0微秒则变为非阻塞函数\n// 返回值 负值为错误 等待超时说明文件无变化返回0 有变化返回正值\nint select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout); \n\n#define exit_if(r, ...) \\\n{   \\\n    if (r)  \\\n    {   \\\n        printf(__VA_ARGS__);    \\\n        printf(\"errno no: %d, error msg is %s\", errno, strerror(errno));    \\\n        exit(1);    \\\n    }   \\\n}   \\\n\nint main(int argc, char* argv[])\n{\n    int keyboard_fd = open(\"/dev/tty\", O_RDONLY | O_NONBLOCK);\n    exit_if(keyboard_fd < 0, \"open keyboard fd error\\n\");\n    fd_set readfd;\n    char recv_buffer = 0;\n\n    while (true)\n    {\n        FD_ZERO(&readfd);\n        FD_SET(0, &readfd);\n\n        timeval timeout {5, 0};\n\n        int ret = select(keyboard_fd + 1, &readfd, nullptr, nullptr, &timeout);\n        exit_if(ret == -1, \"select error\\n\");\n        if (ret > 0)\n        {\n            if (FD_ISSET(keyboard_fd, &readfd))\n            {\n                recv_buffer = 0;\n                read(keyboard_fd, &recv_buffer, 1);\n                if ('\\n' == recv_buffer)\n                {\n                    continue;\n                }\n                if ('q' == recv_buffer)\n                {\n                    break;\n                }\n                printf(\"the input is %c\\n\", recv_buffer);\n            }\n\n        }\n        if (ret == 0)\n        {\n            printf(\"timeout\\n\");\n        }\n    }\n}\n```\n## 第七章Linux服务器程序规范\n\n- Linux程序服务器 一般以后台进程形式运行.  后台进程又称为守护进程(daemon). 他没有控制终端, 因而不会意外的接收到用户输入. 守护进程的父进程通常都是init进程(PID为1的进程)\n- Linux服务器程序有一套日志系统, 他至少能输出日志到文件. 日志这东西太重要了,排错对比全靠它.\n- Linux服务器程序一般以某个专门的非root身份运行. 比如mysqld有自己的账户mysql.\n- Linux服务器程序一般都有自己的配置文件, 而不是把所有配置都写死在代码里面, 方便后续的更改.\n- Linux服务器程序通常在启动的时候生成一个PID文件并存入/var/run 目录中, 以记录改后台进程的PID.\n- Linux服务器程序通常需要考虑系统资源和限制, 预测自己的承受能力\n\n### 日志\n\n```shell\nsudo service rsyslog restart // 启动守护进程\n```\n```c\n#include <syslog.h>\n// priority参数是所谓的设施值(记录日志信息来源, 默认为LOG_USER)与日志级别的按位或\n// - 0 LOG_EMERG  /* 系统不可用*/\n// - 1 LOG_ALERT   /* 报警需要立即采取行动*/\n// - 2 LOG_CRIT /* 非常严重的情况*/\n// - 3 LOG_ERR  /* 错误*/\n// - 4 LOG_WARNING /* 警告*/\n// - 5 LOG_NOTICE /* 通知*/\n// - 6 LOG_INFO /* 信息*/\n//  -7 LOG_DEBUG /* 调试*/\nvoid syslog(int priority, const char* message, .....);\n\n// ident 位于日志的时间后 通常为名字\n// logopt 对后续 syslog调用的行为进行配置\n// -  0x01 LOG_PID  /* 在日志信息中包含程序PID*/\n// -  0x02 LOG_CONS /* 如果信息不能记录到日志文件, 则打印到终端*/\n// -  0x04 LOG_ODELAY /* 延迟打开日志功能直到第一次调用syslog*/\n// -  0x08 LOG_NDELAY /* 不延迟打开日志功能*/\n// facility参数可以修改syslog函数中的默认设施值\nvoid openlog(const char* ident, int logopt, int facility);\n\n// maskpri 一共八位 0000-0000\n// 如果将最后一个0置为1 表示 记录0级别的日志\n// 如果将最后两个0都置为1 表示记录0和1级别的日志\n// 可以通过LOG_MASK() 宏设定 比如LOG_MASK(LOG_CRIT) 表示将倒数第三个0置为1, 表示只记录LOG_CRIT\n// 如果直接设置setlogmask(3); 3的二进制最后两个数均为1 则记录 0和1级别的日志\nint setlogmask(int maskpri);\n\n// 关闭日志功能\nvoid closelog();\n```\n\n### 用户信息, 切换用户\nUID - 真实用户ID\nEUID - 有效用户ID - 方便资源访问\nGID - 真实组ID\nEGID - 有效组ID\n```c\n#include <sys/types.h>\n#include <unistd.h>\n\nuid_t getuid();\nuid_t geteuid();\ngid_t getgid();\ngid_t getegid();\nint setuid(uid_t uid);\nint seteuid(uid_t euid);\nint setgid(gid_t gid);\nint setegid(gid_t gid);\n```\n\n可以通过 `setuid`和`setgid`切换用户 **root用户uid和gid均为0**\n\n### 进程间关系\nPGID - 进程组ID(Linux下每个进程隶属于一个进程组)\n\n#include <unistd.h>\npid_t getpgid(pid_t pid); 成功时返回pid所属的pgid 失败返回-1\nint setpgid(pid_t pid, pid_t pgid);\n\n**会话**\n一些有关联的进程组将形成一个会话\n略过\n\n**查看进程关系**\nps和less\n\n**资源限制**\n略\n**改变目录**\n略\n\n## 第八章高性能服务器程序框架\n\n**服务器模型-CS模型**\n\n**优点**\n- 实现起来简单\n**缺点**\n- 服务器是通信的中心, 访问过大的时候会导致响应过慢\n\n模式图\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%BE8-2%20TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png)\n\n编写的demo 没有用到fork函数. 后续待完善\n\n**服务器框架 IO模型**\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png)\n\n这个模型大概能够理解, 自己也算是学了半年的Javaweb.\n\nsocket在创建的时候默认是阻塞的, 不过可以通过传`SOCK_NONBLOCK`参解决\n非阻塞调用都会立即返回 但可能事件没有发生(recv没有接收到信息), 没有发生和出错都会`返回-1` 所以需要通过`errno`来区分这些错误.\n**事件未发生**\naccept, send,recv errno被设置为 `EAGAIN(再来一次)`或`EWOULDBLOCK(期望阻塞)`\nconnect 被设置为 `EINPROGRESS(正在处理中)`\n\n需要在事件已经发生的情况下 去调用非阻塞IO, 才能提高性能\n\n常用IO复用函数 `select` `poll` `epoll_wait` 将在第九章后面说明\n信号将在第十章说明\n\n**两种高效的事件处理模式和并发模式**\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Reactor%E6%A8%A1%E5%BC%8F.png)\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Proactor%E6%A8%A1%E5%BC%8F.png)\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E7%94%A8%E5%90%8C%E6%AD%A5IO%E6%A8%A1%E6%8B%9F%E5%87%BA%E7%9A%84Proactor%E6%A8%A1%E5%BC%8F.png)\n\n程序分为计算密集型(CPU使用很多, IO资源使用很少)和IO密集型(反过来).\n前者使用并发编程反而会降低效率, 后者则会提升效率\n并发编程有多进程和多线程两种方式\n\n并发模式 - IO单元和多个逻辑单元之间协调完成任务的方法.\n服务器主要有两种并发模式\n- 半同步/半异步模式\n- 领导者/追随者模式\n\n**半同步/半异步模式**\n在IO模型中, 异步和同步的区分是内核向应用程序通知的是何种IO事件(就绪事件还是完成事件), 以及由谁来完成IO读写(应用程序还是内核)\n\n而在这里(并发模式) \n同步指的是完全按照代码序列的顺序执行 - 按照同步方式运行的线程称为同步线程\n异步需要系统事件(中断, 信号)来驱动 - 按照异步方式运行的线程称为异步线程\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5.png)\n\n服务器(需要较好的实时性且能同时处理多个客户请求) - 一般使用同步线程和异步线程来实现,即为半同步/半异步模式\n同步线程 - 处理客户逻辑, 处理请求队列中的对象\n异步线程 - 处理IO事件, 接收到客户请求后将其封装成请求对象并插入请求队列\n\n半同步/半异步模式 存在变体 `半同步/半反应堆模式`\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F.png)\n\n异步线程 - 主线程 - 负责监听所有socket上的事件\n\n**领导者/追随者模式**\n略\n\n**高效编程方法 - 有限状态机**\n```c\n// 状态独立的有限状态机\nSTATE_MACHINE(Package _pack) {\n\t\n\tPackageType _type = _pack.GetType();\n\tswitch(_type) {\n\t\tcase type_A:\n\t\t\txxxx;\n\t\t\tbreak;\n\t\tcase type_B:\n\t\t\txxxx;\n\t\t\tbreak;\n\t}\n}\n\n// 带状态转移的有限状态机\nSTATE_MACHINE() {\n\tState cur_State = type_A;\n\twhile(cur_State != type_C) {\n\t\n\t\tPackage _pack = getNewPackage();\n\t\tswitch(cur_State) {\n\t\t\t\n\t\t\tcase type_A:\n\t\t\t\tprocess_package_state_A(_pack);\n\t\t\t\tcur_State = type_B;\n\t\t\t\tbreak;\n\t\t\tcase type_B:\n\t\t\t\txxxx;\n\t\t\t\tcur_State = type_C;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n\n花了小一个小时 终于一个字母一个字母的抄完了那个5000多字的代码\n@2019年9月8日22:08:46@\n\n### 提高服务器性能的其他建议 池 数据复制 上下文切换和锁\n\n**池** - 用空间换取时间\n进程池和线程池\n\n**数据复制** - 高性能的服务器应该尽量避免不必要的复制\n\n**上下文切换和锁**\n减少`锁`的作用区域. 不应该创建太多的工作进程, 而是使用专门的业务逻辑线程.\n\n","slug":"CPP-读书记录100-高性能服务器编程读书记录初级部分","published":1,"updated":"2020-03-14T07:10:56.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucuy000w8cuo2kya8bag","content":"<p>开头选了这本书, 看到这本书是他人总结三大本后自己写的, 先求个理解大概.<br>话说别人推荐的c++服务器咋都是c语言…..<br>2019年8月17日20:37:53</p>\n<p>每学习一部分就写一个demo</p>\n<a id=\"more\"></a>\n\n<h2 id=\"第五章Linux网络编程基础API\"><a href=\"#第五章Linux网络编程基础API\" class=\"headerlink\" title=\"第五章Linux网络编程基础API\"></a>第五章Linux网络编程基础API</h2><p>socket基础api位于 <code>sys/socket.h</code> 头文件中<br>socket最开始的含义是 一个IP地址和端口对. 唯一的表示了TCP通信的一段<br>网络信息api <code>netdb.h</code>头文件中</p>\n<h3 id=\"主机字节序和网络字节序\"><a href=\"#主机字节序和网络字节序\" class=\"headerlink\" title=\"主机字节序和网络字节序\"></a>主机字节序和网络字节序</h3><p>字节序分为 <code>大端字节序</code>和<code>小端字节序</code><br>由于大多数PC采用小端字节序(高位存在高地址处), 所以小端字节序又称为主机字节序</p>\n<p>为了防止不同机器字节序不同导致的错乱问题. 规定传输的时候统一为 大端字节序(网络字节序).<br>这样主机会根据自己的情况决定 - 是否转换接收到的数据的字节序</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><p><strong>基础连接</strong><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93.jpg\" alt=\"\"><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88%E5%9C%B0%E5%9D%80%E6%97%8F.jpg\" alt=\"\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主机序和网络字节序转换</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> <span class=\"title\">htonl</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> hostlong)</span></span>; <span class=\"comment\">// host to network long</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> <span class=\"title\">htons</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> hostlong)</span></span>; <span class=\"comment\">// host to network short</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> <span class=\"title\">htonl</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> netlong)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> <span class=\"title\">htons</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> netlong)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IP地址转换函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONE</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">in_addr_t</span>  <span class=\"title\">inet_addr</span><span class=\"params\">( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* strptr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inet_aton</span><span class=\"params\">( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* cp, struct in_addr* inp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数返回一个静态变量地址值, 所以多次调用会导致覆盖</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">inet_ntoa</span><span class=\"params\">(struct in_addr in)</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族</span></span><br><span class=\"line\"><span class=\"comment\">// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inet_pton</span><span class=\"params\">(<span class=\"keyword\">int</span> af, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * src, <span class=\"keyword\">void</span>* dst)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">inet_ntop</span><span class=\"params\">(<span class=\"keyword\">int</span> af, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>*  src, <span class=\"keyword\">char</span>* dst, <span class=\"keyword\">socklen_t</span> cnt)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建 命名 监听 socket</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// domain指定使用那个协议族 PF_INET PF_INET6</span></span><br><span class=\"line\"><span class=\"comment\">// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)</span></span><br><span class=\"line\"><span class=\"comment\">// protocol设置为默认的0</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// socket为socket文件描述符</span></span><br><span class=\"line\"><span class=\"comment\">// my_addr 为地址信息</span></span><br><span class=\"line\"><span class=\"comment\">// addrlen为socket地址长度</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">int</span> socket, <span class=\"keyword\">const</span> struct sockaddr* my_addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// backlog表示队列最大的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"keyword\">int</span> socket, <span class=\"keyword\">int</span> backlog)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 接受连接 失败返回-1 成功时返回socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">accept</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr* addr, <span class=\"keyword\">socklen_t</span>* addrlen)</span></span></span><br></pre></td></tr></table></figure>\n<p>客户端</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发起连接</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 第三个参数为 地址指定的长度</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> struct sockaddr * serv_addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 参数为保存的socket</span></span><br><span class=\"line\"><span class=\"comment\">// 并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才能关闭(需要查阅)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">close</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 立即关闭</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数为可选值 </span></span><br><span class=\"line\"><span class=\"comment\">//\tSHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃</span></span><br><span class=\"line\"><span class=\"comment\">//\tSHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去</span></span><br><span class=\"line\"><span class=\"comment\">//\tSHUT_RDWR 同时关闭读和写</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败为-1 设置errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shutdown</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> howto)</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>基础TCP</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取sockfd的数据</span></span><br><span class=\"line\"><span class=\"comment\">// buf 指定读缓冲区的位置</span></span><br><span class=\"line\"><span class=\"comment\">// len 指定读缓冲区的大小</span></span><br><span class=\"line\"><span class=\"comment\">// flags 参数较多</span></span><br><span class=\"line\"><span class=\"comment\">// 成功的时候返回读取到的长度, 可能小于预期长度, 需要多次读取.   读取到0 通信对方已经关闭连接, 错误返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">recv</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 发送</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>选项名</th>\n<th>含义</th>\n<th>可用于发送</th>\n<th>可用于接收</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MSG_CONFIRM</td>\n<td>指示链路层协议持续监听, 直到得到答复.(仅能用于SOCK_DGRAM和SOCK_RAW类型的socket)</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>MSG_DONTROUTE</td>\n<td>不查看路由表, 直接将数据发送给本地的局域网络的主机(代表发送者知道目标主机就在本地网络中)</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>MSG_DONTWAIT</td>\n<td>非阻塞</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_MORE</td>\n<td>告知内核有更多的数据要发送, 等到数据写入缓冲区完毕后,一并发送.减少短小的报文提高传输效率</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>MSG_WAITALL</td>\n<td>读操作一直等待到读取到指定字节后才会返回</td>\n<td>N</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_PEEK</td>\n<td>看一下内缓存数据, 并不会影响数据</td>\n<td>N</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_OOB</td>\n<td>发送或接收紧急数据</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_NOSIGNAL</td>\n<td>向读关闭的管道或者socket连接中写入数据不会触发SIGPIPE信号</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n</tbody></table>\n<p><strong>基础UDP</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.</span></span><br><span class=\"line\"><span class=\"comment\">// 不过recvfrom和sendto 也可以用于 面向STREAM的连接, 这样可以省略发送和接收端的socket地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">recvfrom</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> flags, struct sockaddr* src_addr, <span class=\"keyword\">socklen_t</span>* addrlen)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">sendto</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* buf, <span class=\"keyword\">size_t</span> len, ing flags, <span class=\"keyword\">const</span> struct sockaddr* dest_addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>通用读写函数</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#inclued <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">recvmsg</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct msghdr* msg, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">sendmsg</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct msghdr* msg, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msghdr</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">/* socket address --- 指向socket地址结构变量, 对于TCP连接需要设置为NULL*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* msg_name; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">socklen_t</span> msg_namelen;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/* 分散的内存块 --- 对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由</span></span><br><span class=\"line\"><span class=\"comment\">     * msg_iov指向的数组指定, 称为分散读(scatter read)  ---对于sendmsg而言, msg_iovlen块的分散内存中</span></span><br><span class=\"line\"><span class=\"comment\">     * 的数据将一并发送称为集中写(gather write);</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span>* <span class=\"title\">msg_iov</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> msg_iovlen; <span class=\"comment\">/* 分散内存块的数量*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* msg_control; <span class=\"comment\">/* 指向辅助数据的起始位置*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">socklen_t</span> msg_controllen; <span class=\"comment\">/* 辅助数据的大小*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> msg_flags; <span class=\"comment\">/* 复制函数的flags参数, 并在调用过程中更新*/</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* iov_base <span class=\"comment\">/* 内存起始地址*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> iov_len <span class=\"comment\">/* 这块内存长度*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>其他Api</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 用于判断 sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据, </span></span><br><span class=\"line\"><span class=\"comment\">// 是的话返回1, 不是返回0</span></span><br><span class=\"line\"><span class=\"comment\">// 这样就可以选择带MSG_OOB标志的recv调用来接收带外数据. </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sockatmark</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// getsockname 获取sockfd对应的本端socket地址, 存入address指定的内存中, 长度存入address_len中 成功返回0失败返回-1</span></span><br><span class=\"line\"><span class=\"comment\">// getpeername 获取远端的信息, 同上</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getsockname</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr* address, <span class=\"keyword\">socklen_t</span>* address_len)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getpeername</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr* address, <span class=\"keyword\">socklen_t</span>* address_len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 以下函数头文件均相同*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度</span></span><br><span class=\"line\"><span class=\"comment\">// 成功时返回0 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> option_name, <span class=\"keyword\">void</span>* option_value, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t<span class=\"keyword\">socklen_t</span> <span class=\"keyword\">restrict</span> option_len)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> option_name, <span class=\"keyword\">void</span>* option_value, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t<span class=\"keyword\">socklen_t</span> <span class=\"keyword\">restrict</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>SO_REUSEADDR</th>\n<th>重用本地地址</th>\n<th>sock被设置此属性后, 即使sock在被bind()后处于TIME_WAIT状态, 此时与他绑定的socket地址依然能够立即重用来绑定新的sock</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SO_RCVBUF</td>\n<td>TCP接收缓冲区大小</td>\n<td>最小值为256字节. 设置完后系统会自动加倍你所设定的值. 多出来的一倍将用用作空闲缓冲区处理拥塞</td>\n</tr>\n<tr>\n<td>SO_SNDBUF</td>\n<td>TCP发送缓冲区大小</td>\n<td>最小值为2048字节</td>\n</tr>\n<tr>\n<td>SO_RCVLOWAT</td>\n<td>接收的低水位标记</td>\n<td>默认为1字节, 当TCP接收缓冲区中可读数据的总数大于其低水位标记时, IO复用系统调用将通知应用程序可以从对应的socket上读取数据</td>\n</tr>\n<tr>\n<td>SO_SNDLOWAT</td>\n<td>发送的高水位标记</td>\n<td>默认为1字节, 当TCP发送缓冲区中空闲空间大于低水位标记的时候可以写入数据</td>\n</tr>\n<tr>\n<td>SO_LINGER</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">linger</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l_onoff <span class=\"comment\">/* 开启非0, 关闭为0*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l_linger; <span class=\"comment\">/* 滞留时间*/</span></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t* 当onoff为0的时候此项不起作用, close调用默认行为关闭socket</span></span><br><span class=\"line\"><span class=\"comment\">\t* 当onoff不为0 且linger为0, close将立即返回, TCP将丢弃发送缓冲区的残留数据, 同时发送一个复位报文段</span></span><br><span class=\"line\"><span class=\"comment\">\t* 当onoff不为0 且linger大于0 . 当socket阻塞的时候close将会等待TCP模块发送完残留数据并得到确认后关 </span></span><br><span class=\"line\"><span class=\"comment\">\t* 闭, 如果是处于非阻塞则立即关闭</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/socket%E9%80%89%E9%A1%B9.jpg\" alt=\"\"><br><strong>网络信息API</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 通过主机名查找ip</span></span><br><span class=\"line\"><span class=\"function\">struct hostent* <span class=\"title\">gethostbyname</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过ip获取主机完整信息 </span></span><br><span class=\"line\"><span class=\"comment\">// type为IP地址类型 AF_INET和AF_INET6</span></span><br><span class=\"line\"><span class=\"function\">struct hostent* <span class=\"title\">gethostbyaddr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* addr, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *h_name;\t\t\t<span class=\"comment\">/* Official name of host.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> **h_aliases;\t\t<span class=\"comment\">/* Alias list.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> h_addrtype;\t\t<span class=\"comment\">/* Host address type.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> h_length;\t\t\t<span class=\"comment\">/* Length of address.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> **h_addr_list;\t\t<span class=\"comment\">/* List of addresses from name server.  */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"非法输入\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* name = argv[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span> *<span class=\"title\">hostptr</span>&#123;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    hostptr = gethostbyname(name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hostptr == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"输入存在错误 或无法获取\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Official name of hostptr: %s\\n\"</span>, hostptr-&gt;h_name);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span> **pptr;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> inet_addr[INET_ADDRSTRLEN];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Alias list:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (pptr = hostptr-&gt;h_aliases; *pptr != <span class=\"literal\">nullptr</span>; ++pptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\t%s\\n\"</span>, *pptr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (hostptr-&gt;h_addrtype)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AF_INET:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"List of addresses from name server:\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (pptr = hostptr-&gt;h_addr_list; *pptr != <span class=\"literal\">nullptr</span>; ++pptr)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\t%s\\n\"</span>,</span><br><span class=\"line\">                        inet_ntop(hostptr-&gt;h_addrtype, *pptr, inet_addr, <span class=\"keyword\">sizeof</span>(inet_addr)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"unknow address type\\n\"</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">./run baidu.com</span></span><br><span class=\"line\"><span class=\"comment\">Official name of hostptr: baidu.com</span></span><br><span class=\"line\"><span class=\"comment\">Alias list:</span></span><br><span class=\"line\"><span class=\"comment\">List of addresses from name server:</span></span><br><span class=\"line\"><span class=\"comment\">\t39.156.69.79</span></span><br><span class=\"line\"><span class=\"comment\">\t220.181.38.148</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>以下两个函数通过读取/etc/services文件 来获取服务信息 以下内容来自维基百科</p>\n<p>Service文件是现代操作系统在etc目录下的一个配置文件，记录网络服务名对应的端口号与协议 其用途如下</p>\n<ul>\n<li>通过TCP/IP的API函数（声明在netdb.h中）直接查到网络服务名与端口号、使用协议的对应关系。如getservbyname(“serve”,”tcp”)获取端口号;getservbyport（htons（port），“tcp”）获取端口和协议上的服务名</li>\n<li>如果用户在这个文件中维护所有使用的网络服务名字、端口、协议，那么可以一目了然的获悉哪些端口号用于哪个服务，哪些端口号是空闲的<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 根据名称获取某个服务的完整信息</span></span><br><span class=\"line\"><span class=\"function\">struct servent <span class=\"title\">getservbyname</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* proto)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据端口号获取服务信息</span></span><br><span class=\"line\"><span class=\"function\">struct servent <span class=\"title\">getservbyport</span><span class=\"params\">(<span class=\"keyword\">int</span> port, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* proto)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">servent</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* s_name; <span class=\"comment\">/* 服务名称*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ** s_aliases; <span class=\"comment\">/* 服务的别名列表*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> s_port; <span class=\"comment\">/* 端口号*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* s_proto; <span class=\"comment\">/* 服务类型, 通常为TCP或UDP*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 内部使用的gethostbyname 和 getserverbyname</span></span><br><span class=\"line\"><span class=\"comment\">// hostname 用于接收主机名, 也可以用来接收字符串表示的IP地址(点分十进制, 十六进制字符串)</span></span><br><span class=\"line\"><span class=\"comment\">// service 用于接收服务名, 字符串表示的十进制端口号</span></span><br><span class=\"line\"><span class=\"comment\">// hints参数 对getaddrinfo的输出进行更准确的控制, 可以设置为NULL, 允许反馈各种有用的结果</span></span><br><span class=\"line\"><span class=\"comment\">// result 指向一个链表, 用于存储getaddrinfo的反馈结果</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getaddrinfo</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* hostname, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* service, <span class=\"keyword\">const</span> struct addrinfo* hints, struct addrinfo** result)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">struct addrinfo</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_flags;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_family;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_socktype; <span class=\"comment\">/* 服务类型, SOCK_STREAM或者SOCK_DGRAM*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_protocol;</span><br><span class=\"line\">\t<span class=\"keyword\">socklen_t</span> ai_addrlen;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* ai_canonname; <span class=\"comment\">/* 主机的别名*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span>* <span class=\"title\">ai_addr</span>;</span> <span class=\"comment\">/* 指向socket地址*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">addrinfo</span>* <span class=\"title\">ai_next</span>;</span> <span class=\"comment\">/* 指向下一个结构体*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要手动的释放堆内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">freeaddrinfo</span><span class=\"params\">(struct addrinfo* res)</span></span>;</span><br></pre></td></tr></table></figure>\n<img src=\"https://ftp.bmp.ovh/imgs/2019/08/7ebedb14d8eedeac.png\" alt=\"\"></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// host 存储返回的主机名</span></span><br><span class=\"line\"><span class=\"comment\">// serv存储返回的服务名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getnameinfo</span><span class=\"params\">(<span class=\"keyword\">const</span> struct sockaddr* sockaddr, <span class=\"keyword\">socklen_t</span> addrlen, <span class=\"keyword\">char</span>* host, <span class=\"keyword\">socklen_t</span> hostlen, <span class=\"keyword\">char</span>* serv</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t<span class=\"keyword\">socklen_t</span> servlen, <span class=\"keyword\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ftp.bmp.ovh/imgs/2019/08/bc7196e9a30d5152.png\" alt=\"\"></p>\n<p>测试<br>使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet ip port #来连接服务器的此端口</span><br><span class=\"line\">netstat -nt | grep port #来查看此端口的监听</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第六章高级IO函数\"><a href=\"#第六章高级IO函数\" class=\"headerlink\" title=\"第六章高级IO函数\"></a>第六章高级IO函数</h2><p>Linux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件自然限制了他的使用频率<br><em>文件描述符</em><br>文件描述符在是一个非负整数。是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表。<br>STDOUT_FILENO(值为1)- 值为1的文件描述符为标准输出, 关闭STDOUT_FILENO后用dup即可返回最小可用值(目前为, 1) 这样输出就重定向到了调用dup的参数指向的文件</p>\n<h3 id=\"创建文件描述符-pipe-dup-dup2-splice-select\"><a href=\"#创建文件描述符-pipe-dup-dup2-splice-select\" class=\"headerlink\" title=\"创建文件描述符 - pipe dup dup2 splice select\"></a>创建文件描述符 - pipe dup dup2 splice select</h3><p><strong>pipe函数</strong><br>这个函数可用于创建一个管道, 实现进程间的通信. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数定义</span></span><br><span class=\"line\"><span class=\"comment\">// 参数文件描述符数组 fd[0] 读出 fd[1]写入 单向管道</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0, 并将一对打开的文件描述符填入其参数指向的数组</span></span><br><span class=\"line\"><span class=\"comment\">// 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe</span><span class=\"params\">(<span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 双向管道</span></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数为 协议PF_UNIX(书上是AF_UNIX)感觉这里指明协议使用PF更好一些</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socketpair</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol, <span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>\n<p>学习了后面的内容了解到了进程间通信, 回来补上一个例子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fds[<span class=\"number\">2</span>];</span><br><span class=\"line\">    socketpair(PF_UNIX, SOCK_STREAM, <span class=\"number\">0</span>, fds);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pid = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(fds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">char</span> a[] = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">        send(fds[<span class=\"number\">1</span>], a, <span class=\"built_in\">strlen</span>(a), <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(fds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">char</span> b[<span class=\"number\">20</span>] &#123;&#125;;</span><br><span class=\"line\">        recv(fds[<span class=\"number\">0</span>], b, <span class=\"number\">20</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>, b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>dup和dup2函数</strong><br>复制一个现有的文件描述符</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 返回的文件描述符总是取系统当前可用的最小整数值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup</span><span class=\"params\">(<span class=\"keyword\">int</span> oldfd)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 可以用newfd来制定新的文件描述符, 如果newfd已经被打开则先关闭</span></span><br><span class=\"line\"><span class=\"comment\">// 如果newfd==oldfd 则不关闭newfd直接返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup2</span><span class=\"params\">(<span class=\"keyword\">int</span> oldfd, <span class=\"keyword\">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>dup函数创建一个新的文件描述符, 新的文件描述符和原有的file_descriptor共同指向相同的目标.<br>回来补上例子, 这个例子由于关掉了<code>STDOUT_FILENO</code>dup最小的即为<code>STDOUT_FILENO</code>所以<br>标准输出都到了这个文件之中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> filefd = <span class=\"built_in\">open</span>(<span class=\"string\">\"/home/lsmg/1.txt\"</span>, O_WRONLY);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(STDOUT_FILENO);</span><br><span class=\"line\">    dup(filefd);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"123\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"读写数据-readv-writev-mmap-munmap\"><a href=\"#读写数据-readv-writev-mmap-munmap\" class=\"headerlink\" title=\"读写数据 - readv writev mmap munmap\"></a>读写数据 - readv writev mmap munmap</h3><p><strong>readv/writev</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/uio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// count 为 vector的长度, 即为有多少块内存</span></span><br><span class=\"line\"><span class=\"comment\">// 成功时返回写入\\读取的长度 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">readv</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> struct iovec* <span class=\"built_in\">vector</span>, <span class=\"keyword\">int</span> count)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">writev</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> struct iovec* <span class=\"built_in\">vector</span>, <span class=\"keyword\">int</span> count)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* iov_base <span class=\"comment\">/* 内存起始地址*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> iov_len <span class=\"comment\">/* 这块内存长度*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>回来补上一个使用例子, 这个例子将一个int的内存表示写入到了文件之中<br>使用hexdump查看这个文件<code>0000000 86a0 0001</code>可以看到<code>186a0</code>即为100000</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2020年1月7日16:52:11</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> file = <span class=\"built_in\">open</span>(<span class=\"string\">\"/home/lsmg/1.txt\"</span>, O_WRONLY);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = <span class=\"number\">100000</span>;</span><br><span class=\"line\">    iovec temp_iovec&#123;&#125;;</span><br><span class=\"line\">    temp_iovec.iov_base = &amp;temp;</span><br><span class=\"line\">    temp_iovec.iov_len = <span class=\"keyword\">sizeof</span>(temp);</span><br><span class=\"line\">    writev(file, &amp;temp_iovec, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>sendfile函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/sendfile.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">sendfile</span><span class=\"params\">(<span class=\"keyword\">int</span> out_fd, <span class=\"keyword\">int</span> in_fd, <span class=\"keyword\">off_t</span>* offset, <span class=\"keyword\">size_t</span> count)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">O_RDONLY只读模式</span><br><span class=\"line\">O_WRONLY只写模式</span><br><span class=\"line\">O_RDWR读写模式</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open</span><span class=\"params\">(file_name, flag)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>stat结构体, 可用fstat生成, <strong>简直就是文件的身份证</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stat</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">dev_t</span>       st_dev;     <span class=\"comment\">/* ID of device containing file -文件所在设备的ID*/</span></span><br><span class=\"line\">    <span class=\"keyword\">ino_t</span>       st_ino;     <span class=\"comment\">/* inode number -inode节点号*/</span></span><br><span class=\"line\">    <span class=\"keyword\">mode_t</span>      st_mode;    <span class=\"comment\">/* protection -保护模式?*/</span></span><br><span class=\"line\">    <span class=\"keyword\">nlink_t</span>     st_nlink;   <span class=\"comment\">/* number of hard links -链向此文件的连接数(硬连接)*/</span></span><br><span class=\"line\">    <span class=\"keyword\">uid_t</span>       st_uid;     <span class=\"comment\">/* user ID of owner -user id*/</span></span><br><span class=\"line\">    <span class=\"keyword\">gid_t</span>       st_gid;     <span class=\"comment\">/* group ID of owner - group id*/</span></span><br><span class=\"line\">    <span class=\"keyword\">dev_t</span>       st_rdev;    <span class=\"comment\">/* device ID (if special file) -设备号，针对设备文件*/</span></span><br><span class=\"line\">    <span class=\"keyword\">off_t</span>       st_size;    <span class=\"comment\">/* total size, in bytes -文件大小，字节为单位*/</span></span><br><span class=\"line\">    <span class=\"keyword\">blksize_t</span>   st_blksize; <span class=\"comment\">/* blocksize for filesystem I/O -系统块的大小*/</span></span><br><span class=\"line\">    <span class=\"keyword\">blkcnt_t</span>    st_blocks;  <span class=\"comment\">/* number of blocks allocated -文件所占块数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span>      st_atime;   <span class=\"comment\">/* time of last access -最近存取时间*/</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span>      st_mtime;   <span class=\"comment\">/* time of last modification -最近修改时间*/</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span>      st_ctime;   <span class=\"comment\">/* time of last status change - */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>身份证</strong>生成函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一个参数需要调用open生成文件描述符</span></span><br><span class=\"line\"><span class=\"comment\">// 下面其他两个为文件全路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fstat</span><span class=\"params\">(<span class=\"keyword\">int</span> filedes, struct stat *buf)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当路径指向为符号链接的时候, lstat为符号链接的信息. stat为符号链接指向文件信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stat</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, struct stat *buf)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lstat</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, struct stat *buf)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* ln -s source dist  建立软连接, 类似快捷方式, 也叫符号链接</span></span><br><span class=\"line\"><span class=\"comment\">* ln source dist  建立硬链接, 同一个文件使用多个不同的别名, 指向同一个文件数据块, 只要硬链接不被完全</span></span><br><span class=\"line\"><span class=\"comment\">* 删除就可以正常访问</span></span><br><span class=\"line\"><span class=\"comment\">* 文件数据块 - 文件的真正数据是一个文件数据块, 打开的`文件`指向这个数据块, 就是说</span></span><br><span class=\"line\"><span class=\"comment\">* `文件`本身就类似快捷方式, 指向文件存在的区域.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p> <strong>mmap和munmap函数</strong></p>\n<p><code>mmap</code>创建一块进程通讯共享的内存(可以将文件映射入其中), <code>munmap</code>释放这块内存</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/mman.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// start 内存起始位置, 如果为NULL则系统分配一个地址 length为长度</span></span><br><span class=\"line\"><span class=\"comment\">// port参数 PROT_READ(可读) PROT_WRITE(可写) PROT_EXEC(可执行), PROT_NONE(不可访问)</span></span><br><span class=\"line\"><span class=\"comment\">// flag参数 内存被修改后的行为</span></span><br><span class=\"line\"><span class=\"comment\">// - MAP_SHARED 进程间共享内存, 对内存的修改反映到映射文件中</span></span><br><span class=\"line\"><span class=\"comment\">// - MAP_PRIVATE 为调用进程私有, 对该内存段的修改不会反映到文件中</span></span><br><span class=\"line\"><span class=\"comment\">// - MAP_ANONUMOUS 不是从文件映射而来, 内容被初始化为0, 最后两个参数被忽略</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回区域指针, 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">mmap</span><span class=\"params\">(<span class=\"keyword\">void</span>* start, <span class=\"keyword\">size_t</span> length, <span class=\"keyword\">int</span> port, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">munmap</span><span class=\"params\">(<span class=\"keyword\">void</span>* start, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><strong>splice函数</strong><br>用于在两个文件名描述符之间移动数据, 0拷贝操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// fd_in 为文件描述符, 如果为管道文件描述符则 off_in必须为NULL, 否则为读取开始偏移位置</span></span><br><span class=\"line\"><span class=\"comment\">// len为指定移动的数据长度, flags参数控制数据如何移动.</span></span><br><span class=\"line\"><span class=\"comment\">// - SPLICE_F_NONBLOCK 非阻塞splice操作, 但会受文件描述符自身的阻塞</span></span><br><span class=\"line\"><span class=\"comment\">// - SPLICE_F_MORE 给内核一个提示, 后续的splice调用将读取更多的数据???????</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">splice</span><span class=\"params\">(<span class=\"keyword\">int</span> fd_in, <span class=\"keyword\">loff_t</span>* off_in, <span class=\"keyword\">int</span> fd_out, <span class=\"keyword\">loff_t</span>* off_out, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用splice函数  实现echo服务器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &lt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"the parmerters is wrong\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(errno);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ip = argv[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> port = atoi(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"the port is %d the ip is %s\\n\"</span>, port, ip);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(sockfd &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">address</span>&#123;</span>&#125;;</span><br><span class=\"line\">    address.sin_family = AF_INET;</span><br><span class=\"line\">    address.sin_port = htons(port);</span><br><span class=\"line\">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = bind(sockfd, (sockaddr*)&amp;address, <span class=\"keyword\">sizeof</span>(address));</span><br><span class=\"line\">    assert(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">listen</span>(sockfd, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> clientfd&#123;&#125;;</span><br><span class=\"line\">    sockaddr_in client_address&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">socklen_t</span> client_addrlen = <span class=\"keyword\">sizeof</span>(client_address);</span><br><span class=\"line\"></span><br><span class=\"line\">    clientfd = accept(sockfd, (sockaddr*)&amp;client_address, &amp;client_addrlen);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clientfd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"accept error\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"a new connection from %s:%d success\\n\"</span>, inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fds[<span class=\"number\">2</span>];</span><br><span class=\"line\">        pipe(fds);</span><br><span class=\"line\">        ret = splice(clientfd, <span class=\"literal\">nullptr</span>, fds[<span class=\"number\">1</span>], <span class=\"literal\">nullptr</span>, <span class=\"number\">32768</span>, SPLICE_F_MORE);</span><br><span class=\"line\">        assert(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = splice(fds[<span class=\"number\">0</span>], <span class=\"literal\">nullptr</span>, clientfd, <span class=\"literal\">nullptr</span>, <span class=\"number\">32768</span>, SPLICE_F_MORE);</span><br><span class=\"line\">        assert(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">close</span>(clientfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>select 函数</strong><br>select函数在第二个参数列表 可读的时候返回<br>或者是等到了规定的时间返回</p>\n<p>返回之后 第二个参数指向fdset的集合 被修改为可读的fd列表<br>这就需要每次返回后都更新 fdset集合</p>\n<p>返回后 此函数的返回值为可读的fd数量, 遍历fdset集合 同时使用FD_ISSET判断fdset[i] 是否在其中<br>然后判断此fd是否为listenfd 如果是则接受新的连接 如果不是说明是已经接受的其他fd 判断是有数据可读<br>还是此连接断开</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt; </span></span></span><br><span class=\"line\"><span class=\"comment\">// maxfdp 最大数 FD_SETSIZE</span></span><br><span class=\"line\"><span class=\"comment\">// struct fd_set 一个集合,可以存储多个文件描述符</span></span><br><span class=\"line\"><span class=\"comment\">// - FD_ZERO(&amp;fd_set) 清空 -FD_SET(fd, &amp;fd_set) 放入fd FD_CLR(fd, &amp;fd_set)从其中清除fd</span></span><br><span class=\"line\"><span class=\"comment\">// - FD_ISSET(fd, &amp;fd_set) 判断是否在其中</span></span><br><span class=\"line\"><span class=\"comment\">// readfds  需要监视的文件描述符读变化, 其中的文件描述符可读的时候返回</span></span><br><span class=\"line\"><span class=\"comment\">// writefds 需要监视的文件描述符写变化, 其中的文件描述符可写的时候返回</span></span><br><span class=\"line\"><span class=\"comment\">// errorfds 错误</span></span><br><span class=\"line\"><span class=\"comment\">// timeout 传入NULL为阻塞, 设置为0秒0微秒则变为非阻塞函数</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值 负值为错误 等待超时说明文件无变化返回0 有变化返回正值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">select</span><span class=\"params\">(<span class=\"keyword\">int</span> maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout)</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> exit_if(r, ...) \\</span></span><br><span class=\"line\">&#123;   \\</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r)  \\</span><br><span class=\"line\">    &#123;   \\</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(__VA_ARGS__);    \\</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"errno no: %d, error msg is %s\"</span>, errno, strerror(errno));    \\</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);    \\</span><br><span class=\"line\">    &#125;   \\</span><br><span class=\"line\">&#125;   \\</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> keyboard_fd = <span class=\"built_in\">open</span>(<span class=\"string\">\"/dev/tty\"</span>, O_RDONLY | O_NONBLOCK);</span><br><span class=\"line\">    exit_if(keyboard_fd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"open keyboard fd error\\n\"</span>);</span><br><span class=\"line\">    fd_set readfd;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> recv_buffer = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        FD_ZERO(&amp;readfd);</span><br><span class=\"line\">        FD_SET(<span class=\"number\">0</span>, &amp;readfd);</span><br><span class=\"line\"></span><br><span class=\"line\">        timeval timeout &#123;<span class=\"number\">5</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = select(keyboard_fd + <span class=\"number\">1</span>, &amp;readfd, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>, &amp;timeout);</span><br><span class=\"line\">        exit_if(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"select error\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (FD_ISSET(keyboard_fd, &amp;readfd))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                recv_buffer = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"built_in\">read</span>(keyboard_fd, &amp;recv_buffer, <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"string\">'\\n'</span> == recv_buffer)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"string\">'q'</span> == recv_buffer)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"the input is %c\\n\"</span>, recv_buffer);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"timeout\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第七章Linux服务器程序规范\"><a href=\"#第七章Linux服务器程序规范\" class=\"headerlink\" title=\"第七章Linux服务器程序规范\"></a>第七章Linux服务器程序规范</h2><ul>\n<li>Linux程序服务器 一般以后台进程形式运行.  后台进程又称为守护进程(daemon). 他没有控制终端, 因而不会意外的接收到用户输入. 守护进程的父进程通常都是init进程(PID为1的进程)</li>\n<li>Linux服务器程序有一套日志系统, 他至少能输出日志到文件. 日志这东西太重要了,排错对比全靠它.</li>\n<li>Linux服务器程序一般以某个专门的非root身份运行. 比如mysqld有自己的账户mysql.</li>\n<li>Linux服务器程序一般都有自己的配置文件, 而不是把所有配置都写死在代码里面, 方便后续的更改.</li>\n<li>Linux服务器程序通常在启动的时候生成一个PID文件并存入/var/run 目录中, 以记录改后台进程的PID.</li>\n<li>Linux服务器程序通常需要考虑系统资源和限制, 预测自己的承受能力</li>\n</ul>\n<h3 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service rsyslog restart // 启动守护进程</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;syslog.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// priority参数是所谓的设施值(记录日志信息来源, 默认为LOG_USER)与日志级别的按位或</span></span><br><span class=\"line\"><span class=\"comment\">// - 0 LOG_EMERG  /* 系统不可用*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 1 LOG_ALERT   /* 报警需要立即采取行动*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 2 LOG_CRIT /* 非常严重的情况*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 3 LOG_ERR  /* 错误*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 4 LOG_WARNING /* 警告*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 5 LOG_NOTICE /* 通知*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 6 LOG_INFO /* 信息*/</span></span><br><span class=\"line\"><span class=\"comment\">//  -7 LOG_DEBUG /* 调试*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">syslog</span><span class=\"params\">(<span class=\"keyword\">int</span> priority, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* message, .....)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ident 位于日志的时间后 通常为名字</span></span><br><span class=\"line\"><span class=\"comment\">// logopt 对后续 syslog调用的行为进行配置</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x01 LOG_PID  /* 在日志信息中包含程序PID*/</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x02 LOG_CONS /* 如果信息不能记录到日志文件, 则打印到终端*/</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x04 LOG_ODELAY /* 延迟打开日志功能直到第一次调用syslog*/</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x08 LOG_NDELAY /* 不延迟打开日志功能*/</span></span><br><span class=\"line\"><span class=\"comment\">// facility参数可以修改syslog函数中的默认设施值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">openlog</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* ident, <span class=\"keyword\">int</span> logopt, <span class=\"keyword\">int</span> facility)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// maskpri 一共八位 0000-0000</span></span><br><span class=\"line\"><span class=\"comment\">// 如果将最后一个0置为1 表示 记录0级别的日志</span></span><br><span class=\"line\"><span class=\"comment\">// 如果将最后两个0都置为1 表示记录0和1级别的日志</span></span><br><span class=\"line\"><span class=\"comment\">// 可以通过LOG_MASK() 宏设定 比如LOG_MASK(LOG_CRIT) 表示将倒数第三个0置为1, 表示只记录LOG_CRIT</span></span><br><span class=\"line\"><span class=\"comment\">// 如果直接设置setlogmask(3); 3的二进制最后两个数均为1 则记录 0和1级别的日志</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setlogmask</span><span class=\"params\">(<span class=\"keyword\">int</span> maskpri)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭日志功能</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">closelog</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用户信息-切换用户\"><a href=\"#用户信息-切换用户\" class=\"headerlink\" title=\"用户信息, 切换用户\"></a>用户信息, 切换用户</h3><p>UID - 真实用户ID<br>EUID - 有效用户ID - 方便资源访问<br>GID - 真实组ID<br>EGID - 有效组ID</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uid_t</span> <span class=\"title\">getuid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uid_t</span> <span class=\"title\">geteuid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">gid_t</span> <span class=\"title\">getgid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">gid_t</span> <span class=\"title\">getegid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setuid</span><span class=\"params\">(<span class=\"keyword\">uid_t</span> uid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">seteuid</span><span class=\"params\">(<span class=\"keyword\">uid_t</span> euid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setgid</span><span class=\"params\">(<span class=\"keyword\">gid_t</span> gid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setegid</span><span class=\"params\">(<span class=\"keyword\">gid_t</span> gid)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>可以通过 <code>setuid</code>和<code>setgid</code>切换用户 <strong>root用户uid和gid均为0</strong></p>\n<h3 id=\"进程间关系\"><a href=\"#进程间关系\" class=\"headerlink\" title=\"进程间关系\"></a>进程间关系</h3><p>PGID - 进程组ID(Linux下每个进程隶属于一个进程组)</p>\n<p>#include &lt;unistd.h&gt;<br>pid_t getpgid(pid_t pid); 成功时返回pid所属的pgid 失败返回-1<br>int setpgid(pid_t pid, pid_t pgid);</p>\n<p><strong>会话</strong><br>一些有关联的进程组将形成一个会话<br>略过</p>\n<p><strong>查看进程关系</strong><br>ps和less</p>\n<p><strong>资源限制</strong><br>略<br><strong>改变目录</strong><br>略</p>\n<h2 id=\"第八章高性能服务器程序框架\"><a href=\"#第八章高性能服务器程序框架\" class=\"headerlink\" title=\"第八章高性能服务器程序框架\"></a>第八章高性能服务器程序框架</h2><p><strong>服务器模型-CS模型</strong></p>\n<p><strong>优点</strong></p>\n<ul>\n<li>实现起来简单</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>服务器是通信的中心, 访问过大的时候会导致响应过慢</li>\n</ul>\n<p>模式图<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%BE8-2%20TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png\" alt=\"\"></p>\n<p>编写的demo 没有用到fork函数. 后续待完善</p>\n<p><strong>服务器框架 IO模型</strong></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png\" alt=\"\"></p>\n<p>这个模型大概能够理解, 自己也算是学了半年的Javaweb.</p>\n<p>socket在创建的时候默认是阻塞的, 不过可以通过传<code>SOCK_NONBLOCK</code>参解决<br>非阻塞调用都会立即返回 但可能事件没有发生(recv没有接收到信息), 没有发生和出错都会<code>返回-1</code> 所以需要通过<code>errno</code>来区分这些错误.<br><strong>事件未发生</strong><br>accept, send,recv errno被设置为 <code>EAGAIN(再来一次)</code>或<code>EWOULDBLOCK(期望阻塞)</code><br>connect 被设置为 <code>EINPROGRESS(正在处理中)</code></p>\n<p>需要在事件已经发生的情况下 去调用非阻塞IO, 才能提高性能</p>\n<p>常用IO复用函数 <code>select</code> <code>poll</code> <code>epoll_wait</code> 将在第九章后面说明<br>信号将在第十章说明</p>\n<p><strong>两种高效的事件处理模式和并发模式</strong><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Reactor%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Proactor%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E7%94%A8%E5%90%8C%E6%AD%A5IO%E6%A8%A1%E6%8B%9F%E5%87%BA%E7%9A%84Proactor%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p>程序分为计算密集型(CPU使用很多, IO资源使用很少)和IO密集型(反过来).<br>前者使用并发编程反而会降低效率, 后者则会提升效率<br>并发编程有多进程和多线程两种方式</p>\n<p>并发模式 - IO单元和多个逻辑单元之间协调完成任务的方法.<br>服务器主要有两种并发模式</p>\n<ul>\n<li>半同步/半异步模式</li>\n<li>领导者/追随者模式</li>\n</ul>\n<p><strong>半同步/半异步模式</strong><br>在IO模型中, 异步和同步的区分是内核向应用程序通知的是何种IO事件(就绪事件还是完成事件), 以及由谁来完成IO读写(应用程序还是内核)</p>\n<p>而在这里(并发模式)<br>同步指的是完全按照代码序列的顺序执行 - 按照同步方式运行的线程称为同步线程<br>异步需要系统事件(中断, 信号)来驱动 - 按照异步方式运行的线程称为异步线程<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5.png\" alt=\"\"></p>\n<p>服务器(需要较好的实时性且能同时处理多个客户请求) - 一般使用同步线程和异步线程来实现,即为半同步/半异步模式<br>同步线程 - 处理客户逻辑, 处理请求队列中的对象<br>异步线程 - 处理IO事件, 接收到客户请求后将其封装成请求对象并插入请求队列</p>\n<p>半同步/半异步模式 存在变体 <code>半同步/半反应堆模式</code><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p>异步线程 - 主线程 - 负责监听所有socket上的事件</p>\n<p><strong>领导者/追随者模式</strong><br>略</p>\n<p><strong>高效编程方法 - 有限状态机</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 状态独立的有限状态机</span></span><br><span class=\"line\">STATE_MACHINE(Package _pack) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPackageType _type = _pack.GetType();</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span>(_type) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> type_A:</span><br><span class=\"line\">\t\t\txxxx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> type_B:</span><br><span class=\"line\">\t\t\txxxx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 带状态转移的有限状态机</span></span><br><span class=\"line\">STATE_MACHINE() &#123;</span><br><span class=\"line\">\tState cur_State = type_A;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(cur_State != type_C) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tPackage _pack = getNewPackage();</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span>(cur_State) &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> type_A:</span><br><span class=\"line\">\t\t\t\tprocess_package_state_A(_pack);</span><br><span class=\"line\">\t\t\t\tcur_State = type_B;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> type_B:</span><br><span class=\"line\">\t\t\t\txxxx;</span><br><span class=\"line\">\t\t\t\tcur_State = type_C;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>花了小一个小时 终于一个字母一个字母的抄完了那个5000多字的代码<br>@2019年9月8日22:08:46@</p>\n<h3 id=\"提高服务器性能的其他建议-池-数据复制-上下文切换和锁\"><a href=\"#提高服务器性能的其他建议-池-数据复制-上下文切换和锁\" class=\"headerlink\" title=\"提高服务器性能的其他建议 池 数据复制 上下文切换和锁\"></a>提高服务器性能的其他建议 池 数据复制 上下文切换和锁</h3><p><strong>池</strong> - 用空间换取时间<br>进程池和线程池</p>\n<p><strong>数据复制</strong> - 高性能的服务器应该尽量避免不必要的复制</p>\n<p><strong>上下文切换和锁</strong><br>减少<code>锁</code>的作用区域. 不应该创建太多的工作进程, 而是使用专门的业务逻辑线程.</p>\n","site":{"data":{}},"excerpt":"<p>开头选了这本书, 看到这本书是他人总结三大本后自己写的, 先求个理解大概.<br>话说别人推荐的c++服务器咋都是c语言…..<br>2019年8月17日20:37:53</p>\n<p>每学习一部分就写一个demo</p>","more":"<h2 id=\"第五章Linux网络编程基础API\"><a href=\"#第五章Linux网络编程基础API\" class=\"headerlink\" title=\"第五章Linux网络编程基础API\"></a>第五章Linux网络编程基础API</h2><p>socket基础api位于 <code>sys/socket.h</code> 头文件中<br>socket最开始的含义是 一个IP地址和端口对. 唯一的表示了TCP通信的一段<br>网络信息api <code>netdb.h</code>头文件中</p>\n<h3 id=\"主机字节序和网络字节序\"><a href=\"#主机字节序和网络字节序\" class=\"headerlink\" title=\"主机字节序和网络字节序\"></a>主机字节序和网络字节序</h3><p>字节序分为 <code>大端字节序</code>和<code>小端字节序</code><br>由于大多数PC采用小端字节序(高位存在高地址处), 所以小端字节序又称为主机字节序</p>\n<p>为了防止不同机器字节序不同导致的错乱问题. 规定传输的时候统一为 大端字节序(网络字节序).<br>这样主机会根据自己的情况决定 - 是否转换接收到的数据的字节序</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><p><strong>基础连接</strong><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93.jpg\" alt=\"\"><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88%E5%9C%B0%E5%9D%80%E6%97%8F.jpg\" alt=\"\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 主机序和网络字节序转换</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netinet/in.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> <span class=\"title\">htonl</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> hostlong)</span></span>; <span class=\"comment\">// host to network long</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> <span class=\"title\">htons</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> hostlong)</span></span>; <span class=\"comment\">// host to network short</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> <span class=\"title\">htonl</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> netlong)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> <span class=\"title\">htons</span> <span class=\"params\">(<span class=\"keyword\">unsigned</span> short <span class=\"keyword\">int</span> netlong)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IP地址转换函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;arpa/inet.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONE</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">in_addr_t</span>  <span class=\"title\">inet_addr</span><span class=\"params\">( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* strptr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inet_aton</span><span class=\"params\">( <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* cp, struct in_addr* inp)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数返回一个静态变量地址值, 所以多次调用会导致覆盖</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">inet_ntoa</span><span class=\"params\">(struct in_addr in)</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族</span></span><br><span class=\"line\"><span class=\"comment\">// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inet_pton</span><span class=\"params\">(<span class=\"keyword\">int</span> af, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * src, <span class=\"keyword\">void</span>* dst)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"title\">inet_ntop</span><span class=\"params\">(<span class=\"keyword\">int</span> af, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>*  src, <span class=\"keyword\">char</span>* dst, <span class=\"keyword\">socklen_t</span> cnt)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建 命名 监听 socket</span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// domain指定使用那个协议族 PF_INET PF_INET6</span></span><br><span class=\"line\"><span class=\"comment\">// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)</span></span><br><span class=\"line\"><span class=\"comment\">// protocol设置为默认的0</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socket</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// socket为socket文件描述符</span></span><br><span class=\"line\"><span class=\"comment\">// my_addr 为地址信息</span></span><br><span class=\"line\"><span class=\"comment\">// addrlen为socket地址长度</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">bind</span><span class=\"params\">(<span class=\"keyword\">int</span> socket, <span class=\"keyword\">const</span> struct sockaddr* my_addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// backlog表示队列最大的长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">listen</span><span class=\"params\">(<span class=\"keyword\">int</span> socket, <span class=\"keyword\">int</span> backlog)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 接受连接 失败返回-1 成功时返回socket</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">accept</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr* addr, <span class=\"keyword\">socklen_t</span>* addrlen)</span></span></span><br></pre></td></tr></table></figure>\n<p>客户端</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 发起连接</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 第三个参数为 地址指定的长度</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">connect</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> struct sockaddr * serv_addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭连接</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 参数为保存的socket</span></span><br><span class=\"line\"><span class=\"comment\">// 并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才能关闭(需要查阅)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">close</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 立即关闭</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数为可选值 </span></span><br><span class=\"line\"><span class=\"comment\">//\tSHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃</span></span><br><span class=\"line\"><span class=\"comment\">//\tSHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去</span></span><br><span class=\"line\"><span class=\"comment\">//\tSHUT_RDWR 同时关闭读和写</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败为-1 设置errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shutdown</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> howto)</span></span></span><br></pre></td></tr></table></figure>\n<p><strong>基础TCP</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取sockfd的数据</span></span><br><span class=\"line\"><span class=\"comment\">// buf 指定读缓冲区的位置</span></span><br><span class=\"line\"><span class=\"comment\">// len 指定读缓冲区的大小</span></span><br><span class=\"line\"><span class=\"comment\">// flags 参数较多</span></span><br><span class=\"line\"><span class=\"comment\">// 成功的时候返回读取到的长度, 可能小于预期长度, 需要多次读取.   读取到0 通信对方已经关闭连接, 错误返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">recv</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 发送</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">send</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>选项名</th>\n<th>含义</th>\n<th>可用于发送</th>\n<th>可用于接收</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MSG_CONFIRM</td>\n<td>指示链路层协议持续监听, 直到得到答复.(仅能用于SOCK_DGRAM和SOCK_RAW类型的socket)</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>MSG_DONTROUTE</td>\n<td>不查看路由表, 直接将数据发送给本地的局域网络的主机(代表发送者知道目标主机就在本地网络中)</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>MSG_DONTWAIT</td>\n<td>非阻塞</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_MORE</td>\n<td>告知内核有更多的数据要发送, 等到数据写入缓冲区完毕后,一并发送.减少短小的报文提高传输效率</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n<tr>\n<td>MSG_WAITALL</td>\n<td>读操作一直等待到读取到指定字节后才会返回</td>\n<td>N</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_PEEK</td>\n<td>看一下内缓存数据, 并不会影响数据</td>\n<td>N</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_OOB</td>\n<td>发送或接收紧急数据</td>\n<td>Y</td>\n<td>Y</td>\n</tr>\n<tr>\n<td>MSG_NOSIGNAL</td>\n<td>向读关闭的管道或者socket连接中写入数据不会触发SIGPIPE信号</td>\n<td>Y</td>\n<td>N</td>\n</tr>\n</tbody></table>\n<p><strong>基础UDP</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.</span></span><br><span class=\"line\"><span class=\"comment\">// 不过recvfrom和sendto 也可以用于 面向STREAM的连接, 这样可以省略发送和接收端的socket地址</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">recvfrom</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> flags, struct sockaddr* src_addr, <span class=\"keyword\">socklen_t</span>* addrlen)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">sendto</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* buf, <span class=\"keyword\">size_t</span> len, ing flags, <span class=\"keyword\">const</span> struct sockaddr* dest_addr, <span class=\"keyword\">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>通用读写函数</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#inclued <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">recvmsg</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct msghdr* msg, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">sendmsg</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct msghdr* msg, <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">msghdr</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">/* socket address --- 指向socket地址结构变量, 对于TCP连接需要设置为NULL*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* msg_name; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">socklen_t</span> msg_namelen;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">/* 分散的内存块 --- 对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由</span></span><br><span class=\"line\"><span class=\"comment\">     * msg_iov指向的数组指定, 称为分散读(scatter read)  ---对于sendmsg而言, msg_iovlen块的分散内存中</span></span><br><span class=\"line\"><span class=\"comment\">     * 的数据将一并发送称为集中写(gather write);</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span>* <span class=\"title\">msg_iov</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> msg_iovlen; <span class=\"comment\">/* 分散内存块的数量*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* msg_control; <span class=\"comment\">/* 指向辅助数据的起始位置*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">socklen_t</span> msg_controllen; <span class=\"comment\">/* 辅助数据的大小*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> msg_flags; <span class=\"comment\">/* 复制函数的flags参数, 并在调用过程中更新*/</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* iov_base <span class=\"comment\">/* 内存起始地址*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> iov_len <span class=\"comment\">/* 这块内存长度*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>其他Api</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 用于判断 sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据, </span></span><br><span class=\"line\"><span class=\"comment\">// 是的话返回1, 不是返回0</span></span><br><span class=\"line\"><span class=\"comment\">// 这样就可以选择带MSG_OOB标志的recv调用来接收带外数据. </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sockatmark</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// getsockname 获取sockfd对应的本端socket地址, 存入address指定的内存中, 长度存入address_len中 成功返回0失败返回-1</span></span><br><span class=\"line\"><span class=\"comment\">// getpeername 获取远端的信息, 同上</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getsockname</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr* address, <span class=\"keyword\">socklen_t</span>* address_len)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getpeername</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, struct sockaddr* address, <span class=\"keyword\">socklen_t</span>* address_len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 以下函数头文件均相同*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度</span></span><br><span class=\"line\"><span class=\"comment\">// 成功时返回0 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> option_name, <span class=\"keyword\">void</span>* option_value, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t<span class=\"keyword\">socklen_t</span> <span class=\"keyword\">restrict</span> option_len)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setsockopt</span><span class=\"params\">(<span class=\"keyword\">int</span> sockfd, <span class=\"keyword\">int</span> level, <span class=\"keyword\">int</span> option_name, <span class=\"keyword\">void</span>* option_value, </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\t\t\t\t\t<span class=\"keyword\">socklen_t</span> <span class=\"keyword\">restrict</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>SO_REUSEADDR</th>\n<th>重用本地地址</th>\n<th>sock被设置此属性后, 即使sock在被bind()后处于TIME_WAIT状态, 此时与他绑定的socket地址依然能够立即重用来绑定新的sock</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SO_RCVBUF</td>\n<td>TCP接收缓冲区大小</td>\n<td>最小值为256字节. 设置完后系统会自动加倍你所设定的值. 多出来的一倍将用用作空闲缓冲区处理拥塞</td>\n</tr>\n<tr>\n<td>SO_SNDBUF</td>\n<td>TCP发送缓冲区大小</td>\n<td>最小值为2048字节</td>\n</tr>\n<tr>\n<td>SO_RCVLOWAT</td>\n<td>接收的低水位标记</td>\n<td>默认为1字节, 当TCP接收缓冲区中可读数据的总数大于其低水位标记时, IO复用系统调用将通知应用程序可以从对应的socket上读取数据</td>\n</tr>\n<tr>\n<td>SO_SNDLOWAT</td>\n<td>发送的高水位标记</td>\n<td>默认为1字节, 当TCP发送缓冲区中空闲空间大于低水位标记的时候可以写入数据</td>\n</tr>\n<tr>\n<td>SO_LINGER</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">linger</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l_onoff <span class=\"comment\">/* 开启非0, 关闭为0*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l_linger; <span class=\"comment\">/* 滞留时间*/</span></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t* 当onoff为0的时候此项不起作用, close调用默认行为关闭socket</span></span><br><span class=\"line\"><span class=\"comment\">\t* 当onoff不为0 且linger为0, close将立即返回, TCP将丢弃发送缓冲区的残留数据, 同时发送一个复位报文段</span></span><br><span class=\"line\"><span class=\"comment\">\t* 当onoff不为0 且linger大于0 . 当socket阻塞的时候close将会等待TCP模块发送完残留数据并得到确认后关 </span></span><br><span class=\"line\"><span class=\"comment\">\t* 闭, 如果是处于非阻塞则立即关闭</span></span><br><span class=\"line\"><span class=\"comment\">\t*/</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/socket%E9%80%89%E9%A1%B9.jpg\" alt=\"\"><br><strong>网络信息API</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 通过主机名查找ip</span></span><br><span class=\"line\"><span class=\"function\">struct hostent* <span class=\"title\">gethostbyname</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过ip获取主机完整信息 </span></span><br><span class=\"line\"><span class=\"comment\">// type为IP地址类型 AF_INET和AF_INET6</span></span><br><span class=\"line\"><span class=\"function\">struct hostent* <span class=\"title\">gethostbyaddr</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* addr, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> type)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *h_name;\t\t\t<span class=\"comment\">/* Official name of host.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> **h_aliases;\t\t<span class=\"comment\">/* Alias list.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> h_addrtype;\t\t<span class=\"comment\">/* Host address type.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> h_length;\t\t\t<span class=\"comment\">/* Length of address.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> **h_addr_list;\t\t<span class=\"comment\">/* List of addresses from name server.  */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"非法输入\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* name = argv[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">hostent</span> *<span class=\"title\">hostptr</span>&#123;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    hostptr = gethostbyname(name);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hostptr == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"输入存在错误 或无法获取\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Official name of hostptr: %s\\n\"</span>, hostptr-&gt;h_name);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span> **pptr;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> inet_addr[INET_ADDRSTRLEN];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Alias list:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (pptr = hostptr-&gt;h_aliases; *pptr != <span class=\"literal\">nullptr</span>; ++pptr)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\t%s\\n\"</span>, *pptr);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (hostptr-&gt;h_addrtype)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> AF_INET:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"List of addresses from name server:\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (pptr = hostptr-&gt;h_addr_list; *pptr != <span class=\"literal\">nullptr</span>; ++pptr)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\t%s\\n\"</span>,</span><br><span class=\"line\">                        inet_ntop(hostptr-&gt;h_addrtype, *pptr, inet_addr, <span class=\"keyword\">sizeof</span>(inet_addr)));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"unknow address type\\n\"</span>);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">./run baidu.com</span></span><br><span class=\"line\"><span class=\"comment\">Official name of hostptr: baidu.com</span></span><br><span class=\"line\"><span class=\"comment\">Alias list:</span></span><br><span class=\"line\"><span class=\"comment\">List of addresses from name server:</span></span><br><span class=\"line\"><span class=\"comment\">\t39.156.69.79</span></span><br><span class=\"line\"><span class=\"comment\">\t220.181.38.148</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>以下两个函数通过读取/etc/services文件 来获取服务信息 以下内容来自维基百科</p>\n<p>Service文件是现代操作系统在etc目录下的一个配置文件，记录网络服务名对应的端口号与协议 其用途如下</p>\n<ul>\n<li>通过TCP/IP的API函数（声明在netdb.h中）直接查到网络服务名与端口号、使用协议的对应关系。如getservbyname(“serve”,”tcp”)获取端口号;getservbyport（htons（port），“tcp”）获取端口和协议上的服务名</li>\n<li>如果用户在这个文件中维护所有使用的网络服务名字、端口、协议，那么可以一目了然的获悉哪些端口号用于哪个服务，哪些端口号是空闲的<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 根据名称获取某个服务的完整信息</span></span><br><span class=\"line\"><span class=\"function\">struct servent <span class=\"title\">getservbyname</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* name, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* proto)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据端口号获取服务信息</span></span><br><span class=\"line\"><span class=\"function\">struct servent <span class=\"title\">getservbyport</span><span class=\"params\">(<span class=\"keyword\">int</span> port, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* proto)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">servent</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* s_name; <span class=\"comment\">/* 服务名称*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> ** s_aliases; <span class=\"comment\">/* 服务的别名列表*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> s_port; <span class=\"comment\">/* 端口号*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* s_proto; <span class=\"comment\">/* 服务类型, 通常为TCP或UDP*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 内部使用的gethostbyname 和 getserverbyname</span></span><br><span class=\"line\"><span class=\"comment\">// hostname 用于接收主机名, 也可以用来接收字符串表示的IP地址(点分十进制, 十六进制字符串)</span></span><br><span class=\"line\"><span class=\"comment\">// service 用于接收服务名, 字符串表示的十进制端口号</span></span><br><span class=\"line\"><span class=\"comment\">// hints参数 对getaddrinfo的输出进行更准确的控制, 可以设置为NULL, 允许反馈各种有用的结果</span></span><br><span class=\"line\"><span class=\"comment\">// result 指向一个链表, 用于存储getaddrinfo的反馈结果</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getaddrinfo</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* hostname, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* service, <span class=\"keyword\">const</span> struct addrinfo* hints, struct addrinfo** result)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">struct addrinfo</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_flags;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_family;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_socktype; <span class=\"comment\">/* 服务类型, SOCK_STREAM或者SOCK_DGRAM*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ai_protocol;</span><br><span class=\"line\">\t<span class=\"keyword\">socklen_t</span> ai_addrlen;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* ai_canonname; <span class=\"comment\">/* 主机的别名*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr</span>* <span class=\"title\">ai_addr</span>;</span> <span class=\"comment\">/* 指向socket地址*/</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">addrinfo</span>* <span class=\"title\">ai_next</span>;</span> <span class=\"comment\">/* 指向下一个结构体*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要手动的释放堆内存</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">freeaddrinfo</span><span class=\"params\">(struct addrinfo* res)</span></span>;</span><br></pre></td></tr></table></figure>\n<img src=\"https://ftp.bmp.ovh/imgs/2019/08/7ebedb14d8eedeac.png\" alt=\"\"></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// host 存储返回的主机名</span></span><br><span class=\"line\"><span class=\"comment\">// serv存储返回的服务名</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getnameinfo</span><span class=\"params\">(<span class=\"keyword\">const</span> struct sockaddr* sockaddr, <span class=\"keyword\">socklen_t</span> addrlen, <span class=\"keyword\">char</span>* host, <span class=\"keyword\">socklen_t</span> hostlen, <span class=\"keyword\">char</span>* serv</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t<span class=\"keyword\">socklen_t</span> servlen, <span class=\"keyword\">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://ftp.bmp.ovh/imgs/2019/08/bc7196e9a30d5152.png\" alt=\"\"></p>\n<p>测试<br>使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet ip port #来连接服务器的此端口</span><br><span class=\"line\">netstat -nt | grep port #来查看此端口的监听</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第六章高级IO函数\"><a href=\"#第六章高级IO函数\" class=\"headerlink\" title=\"第六章高级IO函数\"></a>第六章高级IO函数</h2><p>Linux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件自然限制了他的使用频率<br><em>文件描述符</em><br>文件描述符在是一个非负整数。是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表。<br>STDOUT_FILENO(值为1)- 值为1的文件描述符为标准输出, 关闭STDOUT_FILENO后用dup即可返回最小可用值(目前为, 1) 这样输出就重定向到了调用dup的参数指向的文件</p>\n<h3 id=\"创建文件描述符-pipe-dup-dup2-splice-select\"><a href=\"#创建文件描述符-pipe-dup-dup2-splice-select\" class=\"headerlink\" title=\"创建文件描述符 - pipe dup dup2 splice select\"></a>创建文件描述符 - pipe dup dup2 splice select</h3><p><strong>pipe函数</strong><br>这个函数可用于创建一个管道, 实现进程间的通信. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函数定义</span></span><br><span class=\"line\"><span class=\"comment\">// 参数文件描述符数组 fd[0] 读出 fd[1]写入 单向管道</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0, 并将一对打开的文件描述符填入其参数指向的数组</span></span><br><span class=\"line\"><span class=\"comment\">// 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe</span><span class=\"params\">(<span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 双向管道</span></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数为 协议PF_UNIX(书上是AF_UNIX)感觉这里指明协议使用PF更好一些</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/socket.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">socketpair</span><span class=\"params\">(<span class=\"keyword\">int</span> domain, <span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span> protocol, <span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>\n<p>学习了后面的内容了解到了进程间通信, 回来补上一个例子</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fds[<span class=\"number\">2</span>];</span><br><span class=\"line\">    socketpair(PF_UNIX, SOCK_STREAM, <span class=\"number\">0</span>, fds);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> pid = fork();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(fds[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">char</span> a[] = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\">        send(fds[<span class=\"number\">1</span>], a, <span class=\"built_in\">strlen</span>(a), <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">close</span>(fds[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">char</span> b[<span class=\"number\">20</span>] &#123;&#125;;</span><br><span class=\"line\">        recv(fds[<span class=\"number\">0</span>], b, <span class=\"number\">20</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\"</span>, b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>dup和dup2函数</strong><br>复制一个现有的文件描述符</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 返回的文件描述符总是取系统当前可用的最小整数值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup</span><span class=\"params\">(<span class=\"keyword\">int</span> oldfd)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 可以用newfd来制定新的文件描述符, 如果newfd已经被打开则先关闭</span></span><br><span class=\"line\"><span class=\"comment\">// 如果newfd==oldfd 则不关闭newfd直接返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup2</span><span class=\"params\">(<span class=\"keyword\">int</span> oldfd, <span class=\"keyword\">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>dup函数创建一个新的文件描述符, 新的文件描述符和原有的file_descriptor共同指向相同的目标.<br>回来补上例子, 这个例子由于关掉了<code>STDOUT_FILENO</code>dup最小的即为<code>STDOUT_FILENO</code>所以<br>标准输出都到了这个文件之中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> filefd = <span class=\"built_in\">open</span>(<span class=\"string\">\"/home/lsmg/1.txt\"</span>, O_WRONLY);</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(STDOUT_FILENO);</span><br><span class=\"line\">    dup(filefd);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"123\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"读写数据-readv-writev-mmap-munmap\"><a href=\"#读写数据-readv-writev-mmap-munmap\" class=\"headerlink\" title=\"读写数据 - readv writev mmap munmap\"></a>读写数据 - readv writev mmap munmap</h3><p><strong>readv/writev</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/uio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// count 为 vector的长度, 即为有多少块内存</span></span><br><span class=\"line\"><span class=\"comment\">// 成功时返回写入\\读取的长度 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">readv</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> struct iovec* <span class=\"built_in\">vector</span>, <span class=\"keyword\">int</span> count)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">writev</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> struct iovec* <span class=\"built_in\">vector</span>, <span class=\"keyword\">int</span> count)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">iovec</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* iov_base <span class=\"comment\">/* 内存起始地址*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> iov_len <span class=\"comment\">/* 这块内存长度*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>回来补上一个使用例子, 这个例子将一个int的内存表示写入到了文件之中<br>使用hexdump查看这个文件<code>0000000 86a0 0001</code>可以看到<code>186a0</code>即为100000</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2020年1月7日16:52:11</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> file = <span class=\"built_in\">open</span>(<span class=\"string\">\"/home/lsmg/1.txt\"</span>, O_WRONLY);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp = <span class=\"number\">100000</span>;</span><br><span class=\"line\">    iovec temp_iovec&#123;&#125;;</span><br><span class=\"line\">    temp_iovec.iov_base = &amp;temp;</span><br><span class=\"line\">    temp_iovec.iov_len = <span class=\"keyword\">sizeof</span>(temp);</span><br><span class=\"line\">    writev(file, &amp;temp_iovec, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>sendfile函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/sendfile.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">sendfile</span><span class=\"params\">(<span class=\"keyword\">int</span> out_fd, <span class=\"keyword\">int</span> in_fd, <span class=\"keyword\">off_t</span>* offset, <span class=\"keyword\">size_t</span> count)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">O_RDONLY只读模式</span><br><span class=\"line\">O_WRONLY只写模式</span><br><span class=\"line\">O_RDWR读写模式</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open</span><span class=\"params\">(file_name, flag)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>stat结构体, 可用fstat生成, <strong>简直就是文件的身份证</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">stat</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">dev_t</span>       st_dev;     <span class=\"comment\">/* ID of device containing file -文件所在设备的ID*/</span></span><br><span class=\"line\">    <span class=\"keyword\">ino_t</span>       st_ino;     <span class=\"comment\">/* inode number -inode节点号*/</span></span><br><span class=\"line\">    <span class=\"keyword\">mode_t</span>      st_mode;    <span class=\"comment\">/* protection -保护模式?*/</span></span><br><span class=\"line\">    <span class=\"keyword\">nlink_t</span>     st_nlink;   <span class=\"comment\">/* number of hard links -链向此文件的连接数(硬连接)*/</span></span><br><span class=\"line\">    <span class=\"keyword\">uid_t</span>       st_uid;     <span class=\"comment\">/* user ID of owner -user id*/</span></span><br><span class=\"line\">    <span class=\"keyword\">gid_t</span>       st_gid;     <span class=\"comment\">/* group ID of owner - group id*/</span></span><br><span class=\"line\">    <span class=\"keyword\">dev_t</span>       st_rdev;    <span class=\"comment\">/* device ID (if special file) -设备号，针对设备文件*/</span></span><br><span class=\"line\">    <span class=\"keyword\">off_t</span>       st_size;    <span class=\"comment\">/* total size, in bytes -文件大小，字节为单位*/</span></span><br><span class=\"line\">    <span class=\"keyword\">blksize_t</span>   st_blksize; <span class=\"comment\">/* blocksize for filesystem I/O -系统块的大小*/</span></span><br><span class=\"line\">    <span class=\"keyword\">blkcnt_t</span>    st_blocks;  <span class=\"comment\">/* number of blocks allocated -文件所占块数*/</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span>      st_atime;   <span class=\"comment\">/* time of last access -最近存取时间*/</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span>      st_mtime;   <span class=\"comment\">/* time of last modification -最近修改时间*/</span></span><br><span class=\"line\">    <span class=\"keyword\">time_t</span>      st_ctime;   <span class=\"comment\">/* time of last status change - */</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><strong>身份证</strong>生成函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一个参数需要调用open生成文件描述符</span></span><br><span class=\"line\"><span class=\"comment\">// 下面其他两个为文件全路径</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fstat</span><span class=\"params\">(<span class=\"keyword\">int</span> filedes, struct stat *buf)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 当路径指向为符号链接的时候, lstat为符号链接的信息. stat为符号链接指向文件信息</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">stat</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, struct stat *buf)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lstat</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, struct stat *buf)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* ln -s source dist  建立软连接, 类似快捷方式, 也叫符号链接</span></span><br><span class=\"line\"><span class=\"comment\">* ln source dist  建立硬链接, 同一个文件使用多个不同的别名, 指向同一个文件数据块, 只要硬链接不被完全</span></span><br><span class=\"line\"><span class=\"comment\">* 删除就可以正常访问</span></span><br><span class=\"line\"><span class=\"comment\">* 文件数据块 - 文件的真正数据是一个文件数据块, 打开的`文件`指向这个数据块, 就是说</span></span><br><span class=\"line\"><span class=\"comment\">* `文件`本身就类似快捷方式, 指向文件存在的区域.</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p> <strong>mmap和munmap函数</strong></p>\n<p><code>mmap</code>创建一块进程通讯共享的内存(可以将文件映射入其中), <code>munmap</code>释放这块内存</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/mman.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// start 内存起始位置, 如果为NULL则系统分配一个地址 length为长度</span></span><br><span class=\"line\"><span class=\"comment\">// port参数 PROT_READ(可读) PROT_WRITE(可写) PROT_EXEC(可执行), PROT_NONE(不可访问)</span></span><br><span class=\"line\"><span class=\"comment\">// flag参数 内存被修改后的行为</span></span><br><span class=\"line\"><span class=\"comment\">// - MAP_SHARED 进程间共享内存, 对内存的修改反映到映射文件中</span></span><br><span class=\"line\"><span class=\"comment\">// - MAP_PRIVATE 为调用进程私有, 对该内存段的修改不会反映到文件中</span></span><br><span class=\"line\"><span class=\"comment\">// - MAP_ANONUMOUS 不是从文件映射而来, 内容被初始化为0, 最后两个参数被忽略</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回区域指针, 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">mmap</span><span class=\"params\">(<span class=\"keyword\">void</span>* start, <span class=\"keyword\">size_t</span> length, <span class=\"keyword\">int</span> port, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">munmap</span><span class=\"params\">(<span class=\"keyword\">void</span>* start, <span class=\"keyword\">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><strong>splice函数</strong><br>用于在两个文件名描述符之间移动数据, 0拷贝操作</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// fd_in 为文件描述符, 如果为管道文件描述符则 off_in必须为NULL, 否则为读取开始偏移位置</span></span><br><span class=\"line\"><span class=\"comment\">// len为指定移动的数据长度, flags参数控制数据如何移动.</span></span><br><span class=\"line\"><span class=\"comment\">// - SPLICE_F_NONBLOCK 非阻塞splice操作, 但会受文件描述符自身的阻塞</span></span><br><span class=\"line\"><span class=\"comment\">// - SPLICE_F_MORE 给内核一个提示, 后续的splice调用将读取更多的数据???????</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">splice</span><span class=\"params\">(<span class=\"keyword\">int</span> fd_in, <span class=\"keyword\">loff_t</span>* off_in, <span class=\"keyword\">int</span> fd_out, <span class=\"keyword\">loff_t</span>* off_out, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> flags)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用splice函数  实现echo服务器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (argc &lt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"the parmerters is wrong\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(errno);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ip = argv[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> port = atoi(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"the port is %d the ip is %s\\n\"</span>, port, ip);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    assert(sockfd &gt;= <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">address</span>&#123;</span>&#125;;</span><br><span class=\"line\">    address.sin_family = AF_INET;</span><br><span class=\"line\">    address.sin_port = htons(port);</span><br><span class=\"line\">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = bind(sockfd, (sockaddr*)&amp;address, <span class=\"keyword\">sizeof</span>(address));</span><br><span class=\"line\">    assert(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">listen</span>(sockfd, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> clientfd&#123;&#125;;</span><br><span class=\"line\">    sockaddr_in client_address&#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">socklen_t</span> client_addrlen = <span class=\"keyword\">sizeof</span>(client_address);</span><br><span class=\"line\"></span><br><span class=\"line\">    clientfd = accept(sockfd, (sockaddr*)&amp;client_address, &amp;client_addrlen);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (clientfd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"accept error\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"a new connection from %s:%d success\\n\"</span>, inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fds[<span class=\"number\">2</span>];</span><br><span class=\"line\">        pipe(fds);</span><br><span class=\"line\">        ret = splice(clientfd, <span class=\"literal\">nullptr</span>, fds[<span class=\"number\">1</span>], <span class=\"literal\">nullptr</span>, <span class=\"number\">32768</span>, SPLICE_F_MORE);</span><br><span class=\"line\">        assert(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        ret = splice(fds[<span class=\"number\">0</span>], <span class=\"literal\">nullptr</span>, clientfd, <span class=\"literal\">nullptr</span>, <span class=\"number\">32768</span>, SPLICE_F_MORE);</span><br><span class=\"line\">        assert(ret != <span class=\"number\">-1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">close</span>(clientfd);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">close</span>(sockfd);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>select 函数</strong><br>select函数在第二个参数列表 可读的时候返回<br>或者是等到了规定的时间返回</p>\n<p>返回之后 第二个参数指向fdset的集合 被修改为可读的fd列表<br>这就需要每次返回后都更新 fdset集合</p>\n<p>返回后 此函数的返回值为可读的fd数量, 遍历fdset集合 同时使用FD_ISSET判断fdset[i] 是否在其中<br>然后判断此fd是否为listenfd 如果是则接受新的连接 如果不是说明是已经接受的其他fd 判断是有数据可读<br>还是此连接断开</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt; </span></span></span><br><span class=\"line\"><span class=\"comment\">// maxfdp 最大数 FD_SETSIZE</span></span><br><span class=\"line\"><span class=\"comment\">// struct fd_set 一个集合,可以存储多个文件描述符</span></span><br><span class=\"line\"><span class=\"comment\">// - FD_ZERO(&amp;fd_set) 清空 -FD_SET(fd, &amp;fd_set) 放入fd FD_CLR(fd, &amp;fd_set)从其中清除fd</span></span><br><span class=\"line\"><span class=\"comment\">// - FD_ISSET(fd, &amp;fd_set) 判断是否在其中</span></span><br><span class=\"line\"><span class=\"comment\">// readfds  需要监视的文件描述符读变化, 其中的文件描述符可读的时候返回</span></span><br><span class=\"line\"><span class=\"comment\">// writefds 需要监视的文件描述符写变化, 其中的文件描述符可写的时候返回</span></span><br><span class=\"line\"><span class=\"comment\">// errorfds 错误</span></span><br><span class=\"line\"><span class=\"comment\">// timeout 传入NULL为阻塞, 设置为0秒0微秒则变为非阻塞函数</span></span><br><span class=\"line\"><span class=\"comment\">// 返回值 负值为错误 等待超时说明文件无变化返回0 有变化返回正值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">select</span><span class=\"params\">(<span class=\"keyword\">int</span> maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout)</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> exit_if(r, ...) \\</span></span><br><span class=\"line\">&#123;   \\</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r)  \\</span><br><span class=\"line\">    &#123;   \\</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(__VA_ARGS__);    \\</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"errno no: %d, error msg is %s\"</span>, errno, strerror(errno));    \\</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);    \\</span><br><span class=\"line\">    &#125;   \\</span><br><span class=\"line\">&#125;   \\</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> keyboard_fd = <span class=\"built_in\">open</span>(<span class=\"string\">\"/dev/tty\"</span>, O_RDONLY | O_NONBLOCK);</span><br><span class=\"line\">    exit_if(keyboard_fd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"open keyboard fd error\\n\"</span>);</span><br><span class=\"line\">    fd_set readfd;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> recv_buffer = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        FD_ZERO(&amp;readfd);</span><br><span class=\"line\">        FD_SET(<span class=\"number\">0</span>, &amp;readfd);</span><br><span class=\"line\"></span><br><span class=\"line\">        timeval timeout &#123;<span class=\"number\">5</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> ret = select(keyboard_fd + <span class=\"number\">1</span>, &amp;readfd, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>, &amp;timeout);</span><br><span class=\"line\">        exit_if(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"select error\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (FD_ISSET(keyboard_fd, &amp;readfd))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                recv_buffer = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"built_in\">read</span>(keyboard_fd, &amp;recv_buffer, <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"string\">'\\n'</span> == recv_buffer)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"string\">'q'</span> == recv_buffer)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"the input is %c\\n\"</span>, recv_buffer);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ret == <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"timeout\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第七章Linux服务器程序规范\"><a href=\"#第七章Linux服务器程序规范\" class=\"headerlink\" title=\"第七章Linux服务器程序规范\"></a>第七章Linux服务器程序规范</h2><ul>\n<li>Linux程序服务器 一般以后台进程形式运行.  后台进程又称为守护进程(daemon). 他没有控制终端, 因而不会意外的接收到用户输入. 守护进程的父进程通常都是init进程(PID为1的进程)</li>\n<li>Linux服务器程序有一套日志系统, 他至少能输出日志到文件. 日志这东西太重要了,排错对比全靠它.</li>\n<li>Linux服务器程序一般以某个专门的非root身份运行. 比如mysqld有自己的账户mysql.</li>\n<li>Linux服务器程序一般都有自己的配置文件, 而不是把所有配置都写死在代码里面, 方便后续的更改.</li>\n<li>Linux服务器程序通常在启动的时候生成一个PID文件并存入/var/run 目录中, 以记录改后台进程的PID.</li>\n<li>Linux服务器程序通常需要考虑系统资源和限制, 预测自己的承受能力</li>\n</ul>\n<h3 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h3><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo service rsyslog restart // 启动守护进程</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;syslog.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// priority参数是所谓的设施值(记录日志信息来源, 默认为LOG_USER)与日志级别的按位或</span></span><br><span class=\"line\"><span class=\"comment\">// - 0 LOG_EMERG  /* 系统不可用*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 1 LOG_ALERT   /* 报警需要立即采取行动*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 2 LOG_CRIT /* 非常严重的情况*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 3 LOG_ERR  /* 错误*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 4 LOG_WARNING /* 警告*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 5 LOG_NOTICE /* 通知*/</span></span><br><span class=\"line\"><span class=\"comment\">// - 6 LOG_INFO /* 信息*/</span></span><br><span class=\"line\"><span class=\"comment\">//  -7 LOG_DEBUG /* 调试*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">syslog</span><span class=\"params\">(<span class=\"keyword\">int</span> priority, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* message, .....)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ident 位于日志的时间后 通常为名字</span></span><br><span class=\"line\"><span class=\"comment\">// logopt 对后续 syslog调用的行为进行配置</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x01 LOG_PID  /* 在日志信息中包含程序PID*/</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x02 LOG_CONS /* 如果信息不能记录到日志文件, 则打印到终端*/</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x04 LOG_ODELAY /* 延迟打开日志功能直到第一次调用syslog*/</span></span><br><span class=\"line\"><span class=\"comment\">// -  0x08 LOG_NDELAY /* 不延迟打开日志功能*/</span></span><br><span class=\"line\"><span class=\"comment\">// facility参数可以修改syslog函数中的默认设施值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">openlog</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* ident, <span class=\"keyword\">int</span> logopt, <span class=\"keyword\">int</span> facility)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// maskpri 一共八位 0000-0000</span></span><br><span class=\"line\"><span class=\"comment\">// 如果将最后一个0置为1 表示 记录0级别的日志</span></span><br><span class=\"line\"><span class=\"comment\">// 如果将最后两个0都置为1 表示记录0和1级别的日志</span></span><br><span class=\"line\"><span class=\"comment\">// 可以通过LOG_MASK() 宏设定 比如LOG_MASK(LOG_CRIT) 表示将倒数第三个0置为1, 表示只记录LOG_CRIT</span></span><br><span class=\"line\"><span class=\"comment\">// 如果直接设置setlogmask(3); 3的二进制最后两个数均为1 则记录 0和1级别的日志</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setlogmask</span><span class=\"params\">(<span class=\"keyword\">int</span> maskpri)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭日志功能</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">closelog</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用户信息-切换用户\"><a href=\"#用户信息-切换用户\" class=\"headerlink\" title=\"用户信息, 切换用户\"></a>用户信息, 切换用户</h3><p>UID - 真实用户ID<br>EUID - 有效用户ID - 方便资源访问<br>GID - 真实组ID<br>EGID - 有效组ID</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uid_t</span> <span class=\"title\">getuid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uid_t</span> <span class=\"title\">geteuid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">gid_t</span> <span class=\"title\">getgid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">gid_t</span> <span class=\"title\">getegid</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setuid</span><span class=\"params\">(<span class=\"keyword\">uid_t</span> uid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">seteuid</span><span class=\"params\">(<span class=\"keyword\">uid_t</span> euid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setgid</span><span class=\"params\">(<span class=\"keyword\">gid_t</span> gid)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">setegid</span><span class=\"params\">(<span class=\"keyword\">gid_t</span> gid)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>可以通过 <code>setuid</code>和<code>setgid</code>切换用户 <strong>root用户uid和gid均为0</strong></p>\n<h3 id=\"进程间关系\"><a href=\"#进程间关系\" class=\"headerlink\" title=\"进程间关系\"></a>进程间关系</h3><p>PGID - 进程组ID(Linux下每个进程隶属于一个进程组)</p>\n<p>#include &lt;unistd.h&gt;<br>pid_t getpgid(pid_t pid); 成功时返回pid所属的pgid 失败返回-1<br>int setpgid(pid_t pid, pid_t pgid);</p>\n<p><strong>会话</strong><br>一些有关联的进程组将形成一个会话<br>略过</p>\n<p><strong>查看进程关系</strong><br>ps和less</p>\n<p><strong>资源限制</strong><br>略<br><strong>改变目录</strong><br>略</p>\n<h2 id=\"第八章高性能服务器程序框架\"><a href=\"#第八章高性能服务器程序框架\" class=\"headerlink\" title=\"第八章高性能服务器程序框架\"></a>第八章高性能服务器程序框架</h2><p><strong>服务器模型-CS模型</strong></p>\n<p><strong>优点</strong></p>\n<ul>\n<li>实现起来简单</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>服务器是通信的中心, 访问过大的时候会导致响应过慢</li>\n</ul>\n<p>模式图<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%BE8-2%20TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png\" alt=\"\"></p>\n<p>编写的demo 没有用到fork函数. 后续待完善</p>\n<p><strong>服务器框架 IO模型</strong></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png\" alt=\"\"></p>\n<p>这个模型大概能够理解, 自己也算是学了半年的Javaweb.</p>\n<p>socket在创建的时候默认是阻塞的, 不过可以通过传<code>SOCK_NONBLOCK</code>参解决<br>非阻塞调用都会立即返回 但可能事件没有发生(recv没有接收到信息), 没有发生和出错都会<code>返回-1</code> 所以需要通过<code>errno</code>来区分这些错误.<br><strong>事件未发生</strong><br>accept, send,recv errno被设置为 <code>EAGAIN(再来一次)</code>或<code>EWOULDBLOCK(期望阻塞)</code><br>connect 被设置为 <code>EINPROGRESS(正在处理中)</code></p>\n<p>需要在事件已经发生的情况下 去调用非阻塞IO, 才能提高性能</p>\n<p>常用IO复用函数 <code>select</code> <code>poll</code> <code>epoll_wait</code> 将在第九章后面说明<br>信号将在第十章说明</p>\n<p><strong>两种高效的事件处理模式和并发模式</strong><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Reactor%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/Proactor%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E7%94%A8%E5%90%8C%E6%AD%A5IO%E6%A8%A1%E6%8B%9F%E5%87%BA%E7%9A%84Proactor%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p>程序分为计算密集型(CPU使用很多, IO资源使用很少)和IO密集型(反过来).<br>前者使用并发编程反而会降低效率, 后者则会提升效率<br>并发编程有多进程和多线程两种方式</p>\n<p>并发模式 - IO单元和多个逻辑单元之间协调完成任务的方法.<br>服务器主要有两种并发模式</p>\n<ul>\n<li>半同步/半异步模式</li>\n<li>领导者/追随者模式</li>\n</ul>\n<p><strong>半同步/半异步模式</strong><br>在IO模型中, 异步和同步的区分是内核向应用程序通知的是何种IO事件(就绪事件还是完成事件), 以及由谁来完成IO读写(应用程序还是内核)</p>\n<p>而在这里(并发模式)<br>同步指的是完全按照代码序列的顺序执行 - 按照同步方式运行的线程称为同步线程<br>异步需要系统事件(中断, 信号)来驱动 - 按照异步方式运行的线程称为异步线程<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E5%92%8C%E5%90%8C%E6%AD%A5.png\" alt=\"\"></p>\n<p>服务器(需要较好的实时性且能同时处理多个客户请求) - 一般使用同步线程和异步线程来实现,即为半同步/半异步模式<br>同步线程 - 处理客户逻辑, 处理请求队列中的对象<br>异步线程 - 处理IO事件, 接收到客户请求后将其封装成请求对象并插入请求队列</p>\n<p>半同步/半异步模式 存在变体 <code>半同步/半反应堆模式</code><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F.png\" alt=\"\"></p>\n<p>异步线程 - 主线程 - 负责监听所有socket上的事件</p>\n<p><strong>领导者/追随者模式</strong><br>略</p>\n<p><strong>高效编程方法 - 有限状态机</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 状态独立的有限状态机</span></span><br><span class=\"line\">STATE_MACHINE(Package _pack) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tPackageType _type = _pack.GetType();</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span>(_type) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> type_A:</span><br><span class=\"line\">\t\t\txxxx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> type_B:</span><br><span class=\"line\">\t\t\txxxx;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 带状态转移的有限状态机</span></span><br><span class=\"line\">STATE_MACHINE() &#123;</span><br><span class=\"line\">\tState cur_State = type_A;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(cur_State != type_C) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t\tPackage _pack = getNewPackage();</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span>(cur_State) &#123;</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> type_A:</span><br><span class=\"line\">\t\t\t\tprocess_package_state_A(_pack);</span><br><span class=\"line\">\t\t\t\tcur_State = type_B;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> type_B:</span><br><span class=\"line\">\t\t\t\txxxx;</span><br><span class=\"line\">\t\t\t\tcur_State = type_C;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>花了小一个小时 终于一个字母一个字母的抄完了那个5000多字的代码<br>@2019年9月8日22:08:46@</p>\n<h3 id=\"提高服务器性能的其他建议-池-数据复制-上下文切换和锁\"><a href=\"#提高服务器性能的其他建议-池-数据复制-上下文切换和锁\" class=\"headerlink\" title=\"提高服务器性能的其他建议 池 数据复制 上下文切换和锁\"></a>提高服务器性能的其他建议 池 数据复制 上下文切换和锁</h3><p><strong>池</strong> - 用空间换取时间<br>进程池和线程池</p>\n<p><strong>数据复制</strong> - 高性能的服务器应该尽量避免不必要的复制</p>\n<p><strong>上下文切换和锁</strong><br>减少<code>锁</code>的作用区域. 不应该创建太多的工作进程, 而是使用专门的业务逻辑线程.</p>"},{"title":"Jsoncpp代码阅读","date":"2020-03-01T02:26:55.000Z","img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/Jsoncpp%E5%B0%81%E9%9D%A2.png","_content":"```c++\nJson::Value root;\nroot[\"action\"] = \"run\";\n```\n首先是 `[]运算符重载` , 统一不同的重载类型\n调用`resolveReference()`进行统一的添加`k`操作\n\n首先会进行 校验参数, 然后将key封装成一个对象CZString (封装过程为将传入指针保存到 CZString对象中的cstr_)\n封装完成后再保存`k v`的`map<CZString, Value>`中查找有无相同的CZString(key)有的话返回Value引用,\n没有则创建新的<CZStrng, 空Value>存入map并返回Value的引用\n\n然后是`=运算符重载`, \"run\"自动转换成Value对象\n转换过程中, 通过`duplicateAndPrefixStringValue()`将\"run\"进行了封装 \n`char* string_; // if allocated_, ptr to { unsigned, char[] }.`\n将长度封装到了一个char指针中, 有点类似自己设计tcp协议...\n\n`=运算符重载`函数将`[]运算符重载`返回的对象引用 中的相关值`swap()`成新的Value对象中的相关值\n\n到这里理解了在Jsoncpp中 一切都是Value 包括<K, V>键值对也是在Value对象中存储\n每一个<k, v>都可以作为一个Value对象, 这样既实现了复杂嵌套Json中 v为对象的情况 妙啊\n\n```c++\n// 每个Value对象中都维护一个union\nunion ValueHolder {\n    LargestInt int_;\n    LargestUInt uint_;\n    double real_;\n    bool bool_;\n    char* string_; // if allocated_, ptr to { unsigned, char[] }.\n\n    // 将所有的存贮着key的CZString保存起来\n\t//  typedef std::map<CZString, Value> ObjectValues; // std::map<CZString, Value> 键值对\n    ObjectValues* map_;\n  } value_;\n```\n\n下面的switch的这个type 会在很多地方被修改掉.\n起初 使用默认构造函数的value type是nullxxx\n然后调用`[]运算符重载`的时候会修改掉 type 为 objectValue\n\n```c++\n// 递归调用 进行处理\nvoid BuiltStyledStreamWriter::writeValue(Value const& value) {\n  switch (value.type()) {\n  case nullValue:\n    pushValue(nullSymbol_);\n    break;\n  case intValue:\n    pushValue(valueToString(value.asLargestInt()));\n    break;\n  case uintValue:\n    pushValue(valueToString(value.asLargestUInt()));\n    break;\n  case realValue:\n    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,\n                            precisionType_));\n    break;\n  case stringValue: {\n    // Is NULL is possible for value.string_? No.\n    char const* str;\n    char const* end;\n    bool ok = value.getString(&str, &end);\n    if (ok)\n      pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end - str),\n                                     emitUTF8_));\n    else\n      pushValue(\"\");\n    break;\n  }\n  case booleanValue:\n    pushValue(valueToString(value.asBool()));\n    break;\n  case arrayValue:\n    writeArrayValue(value);\n    break;\n  case objectValue: {\n    Value::Members members(value.getMemberNames());\n    if (members.empty())\n      pushValue(\"{}\");\n    else {\n      writeWithIndent(\"{\");\n      indent();\n      auto it = members.begin();\n      for (;;) {\n        String const& name = *it;\n        Value const& childValue = value[name];\n        writeCommentBeforeValue(childValue);\n        writeWithIndent(valueToQuotedStringN(\n            name.data(), static_cast<unsigned>(name.length()), emitUTF8_));\n\n        // :\n        *sout_ << colonSymbol_;\n        writeValue(childValue);\n        if (++it == members.end()) {\n          writeCommentAfterValueOnSameLine(childValue);\n          break;\n        }\n        *sout_ << \",\";\n        writeCommentAfterValueOnSameLine(childValue);\n      }\n      unindent();\n      writeWithIndent(\"}\");\n    }\n  } break;\n  }\n}\n```\n\n这次是根据下面的例子分析的\n```c++\nint main() {\n  Json::Value root;\n  Json::Value data;\n  constexpr bool shouldUseOldWay = false;\n\n  // 左侧返回Value的引用\n  root[\"action\"] = \"run\";\n  data[\"number\"] = 1;\n  root[\"data\"] = data;\n\n  if (shouldUseOldWay) {\n    Json::FastWriter writer;\n    const std::string json_file = writer.write(root);\n    std::cout << json_file << std::endl;\n  } else {\n    // 配置文件也是Value对象, 我用我自己.jpg\n    Json::StreamWriterBuilder builder;\n    const std::string json_file = Json::writeString(builder, root);\n    std::cout << json_file << std::endl;\n  }\n  return EXIT_SUCCESS;\n}\n```\n\n算是了解到了这个库的大概工作流程了. 能学到的部分 吃完午饭继续写.\n吃完饭试了试家里的显示器, 家里的显示器还是太老了...... 八年的显示器了 看得我眼花\n还是继续用笔记本吧\n\n1. 首先我很喜欢这种运算符重载的使用形式, 用起来非常的舒服, 需要重载两个运算符 `[]`和`=` 而且\n`=运算符`重载使用的swap交换需要的属性, 感觉不错\n(后来我看了EffectiveC++ 发现这是`=运算符处理自我赋值`太巧了)\n\n2. 针对需要加载配置文件的类 使用了工厂模式\n3. writeValue使用了递归处理.\n4. 统一处理, k v都是Value对象\n5. 将用户的string 拷贝到新的`char*`中 同时在开头增加了长度, 尾部补了0, 没有使用额外的变量去存储`char*`的长度\n不太清楚这样做有什么好处\n6. 常量全部用的 `static constexpr`修饰\n7. 恰当的对象嵌套\n\n\n----\n\n看完了从 Value到Json 接下来看看从Json到Value\n\n```c++\nint main() {\n  const std::string rawJson = R\"({\"Age\": 20, \"Name\": \"colin\"})\";\n  const auto rawJsonLength = static_cast<int>(rawJson.length());\n  constexpr bool shouldUseOldWay = false;\n  JSONCPP_STRING err;\n  Json::Value root;\n\n  if (shouldUseOldWay) {\n    Json::Reader reader;\n    reader.parse(rawJson, root);\n  } else {\n      // 默认构造函数 使用默认的配置\n    Json::CharReaderBuilder builder;\n\n    // 根据builder的配置生成CharReader类\n    const std::unique_ptr<Json::CharReader> reader(builder.newCharReader());\n    if (!reader->parse(rawJson.c_str(), rawJson.c_str() + rawJsonLength, &root,\n                       &err)) {\n      std::cout << \"error\" << std::endl;\n      return EXIT_FAILURE;\n    }\n  }\n  const std::string name = root[\"Name\"].asString();\n  const int age = root[\"Age\"].asInt();\n\n  std::cout << name << std::endl;\n  std::cout << age << std::endl;\n  return EXIT_SUCCESS;\n}\n```\n\n解析的关键在于`parse()`函数 传入字符串的首尾指针, 和一个Value引用\n进入函数后将传入的变量保存到了自己的成员变量中.\n\n慢慢发现 这个库将很多的默认类型 起了别名 可能是为了统一类型 类似UE4也是自己搞了一套\n\n主要是`OurReader`这个负责解析\n```c++\n// 使用了大量的using\nusing Char = char;\nusing Location = const Char*;\n```\n\n解析逻辑就是`parse()`调用`readValue()`\n`readValue()`负责 获取下一次数据类型type_ ->switch(type_) 根据分支决定是否递归再次调用`readValue`\n总算把逻辑看懂了, 代码依然认为很赞\n`readToken()`这个函数贯穿整个解析, 通过这个函数获取到下一次的数据是什么类型, 同时移动相关的状态指针\n`readToken()` 内部大量调用下面的函数 修改当前指针 同时返回字符, 然后switch这个字符判断下一次的数据类型\n比如遇到`{`就是一个对象的开始设置好type并返回 遇到`}`就是对象的结束.....\n```c++\n// 获取current_指向的字符 并自增\nOurReader::Char OurReader::getNextChar()\n{\n  if (current_ == end_)\n    return 0;\n  return *current_++;\n}\n```\n\n一般第一次调用type_会被设置为对象类型, 然后`readValue()`进入`case 对象分支`\n`case对象分支中`\n先进行了一次`readToken()`获取到了k的类型, 然后根据k类型分支 将k的值转换成对应的value\n之后又是一次`readToken()`判断是否存在`:`不存在就是错误\n在之后使用这个方法, 保存`k`的vallue获取`v`的value再次调用`readValue()`填充值 返回后继续走\n```c++\n// 这里保存了name 这个k 将name的 v放入了顶层\nValue& value = currentValue()[name];\nnodes_.push(&value);\nbool ok = readValue();\n```\n读取完`v`的value之后必定是`,`或者`}`又是一次判断 成功判断后一个`k v`就获取完毕了\n\n` using Nodes = std::stack<Value*>`\n后面解析的代码更加的妙不可言, 使用`Nodes nodes_{}`存储当前的value 实现函数之间的操作\n\n代码合理的组织\n比如`case 对象分支`必定是一个`k`一个`:`一个`v` 然后一个分隔符`,`或`}` 这些放入了一个函数\n\n然后获取到`k`之后使用`Value& value = currentValue()[name]`获取`v`\n\n最后依然是递归的使用","source":"_posts/CPP-源码学习-Jsoncpp代码阅读.md","raw":"---\ntitle: Jsoncpp代码阅读\ndate: 2020-03-01 10:26:55\ntags:\ncategories:\n - CPP\n - 源码学习\n \nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/Jsoncpp%E5%B0%81%E9%9D%A2.png\n---\n```c++\nJson::Value root;\nroot[\"action\"] = \"run\";\n```\n首先是 `[]运算符重载` , 统一不同的重载类型\n调用`resolveReference()`进行统一的添加`k`操作\n\n首先会进行 校验参数, 然后将key封装成一个对象CZString (封装过程为将传入指针保存到 CZString对象中的cstr_)\n封装完成后再保存`k v`的`map<CZString, Value>`中查找有无相同的CZString(key)有的话返回Value引用,\n没有则创建新的<CZStrng, 空Value>存入map并返回Value的引用\n\n然后是`=运算符重载`, \"run\"自动转换成Value对象\n转换过程中, 通过`duplicateAndPrefixStringValue()`将\"run\"进行了封装 \n`char* string_; // if allocated_, ptr to { unsigned, char[] }.`\n将长度封装到了一个char指针中, 有点类似自己设计tcp协议...\n\n`=运算符重载`函数将`[]运算符重载`返回的对象引用 中的相关值`swap()`成新的Value对象中的相关值\n\n到这里理解了在Jsoncpp中 一切都是Value 包括<K, V>键值对也是在Value对象中存储\n每一个<k, v>都可以作为一个Value对象, 这样既实现了复杂嵌套Json中 v为对象的情况 妙啊\n\n```c++\n// 每个Value对象中都维护一个union\nunion ValueHolder {\n    LargestInt int_;\n    LargestUInt uint_;\n    double real_;\n    bool bool_;\n    char* string_; // if allocated_, ptr to { unsigned, char[] }.\n\n    // 将所有的存贮着key的CZString保存起来\n\t//  typedef std::map<CZString, Value> ObjectValues; // std::map<CZString, Value> 键值对\n    ObjectValues* map_;\n  } value_;\n```\n\n下面的switch的这个type 会在很多地方被修改掉.\n起初 使用默认构造函数的value type是nullxxx\n然后调用`[]运算符重载`的时候会修改掉 type 为 objectValue\n\n```c++\n// 递归调用 进行处理\nvoid BuiltStyledStreamWriter::writeValue(Value const& value) {\n  switch (value.type()) {\n  case nullValue:\n    pushValue(nullSymbol_);\n    break;\n  case intValue:\n    pushValue(valueToString(value.asLargestInt()));\n    break;\n  case uintValue:\n    pushValue(valueToString(value.asLargestUInt()));\n    break;\n  case realValue:\n    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,\n                            precisionType_));\n    break;\n  case stringValue: {\n    // Is NULL is possible for value.string_? No.\n    char const* str;\n    char const* end;\n    bool ok = value.getString(&str, &end);\n    if (ok)\n      pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end - str),\n                                     emitUTF8_));\n    else\n      pushValue(\"\");\n    break;\n  }\n  case booleanValue:\n    pushValue(valueToString(value.asBool()));\n    break;\n  case arrayValue:\n    writeArrayValue(value);\n    break;\n  case objectValue: {\n    Value::Members members(value.getMemberNames());\n    if (members.empty())\n      pushValue(\"{}\");\n    else {\n      writeWithIndent(\"{\");\n      indent();\n      auto it = members.begin();\n      for (;;) {\n        String const& name = *it;\n        Value const& childValue = value[name];\n        writeCommentBeforeValue(childValue);\n        writeWithIndent(valueToQuotedStringN(\n            name.data(), static_cast<unsigned>(name.length()), emitUTF8_));\n\n        // :\n        *sout_ << colonSymbol_;\n        writeValue(childValue);\n        if (++it == members.end()) {\n          writeCommentAfterValueOnSameLine(childValue);\n          break;\n        }\n        *sout_ << \",\";\n        writeCommentAfterValueOnSameLine(childValue);\n      }\n      unindent();\n      writeWithIndent(\"}\");\n    }\n  } break;\n  }\n}\n```\n\n这次是根据下面的例子分析的\n```c++\nint main() {\n  Json::Value root;\n  Json::Value data;\n  constexpr bool shouldUseOldWay = false;\n\n  // 左侧返回Value的引用\n  root[\"action\"] = \"run\";\n  data[\"number\"] = 1;\n  root[\"data\"] = data;\n\n  if (shouldUseOldWay) {\n    Json::FastWriter writer;\n    const std::string json_file = writer.write(root);\n    std::cout << json_file << std::endl;\n  } else {\n    // 配置文件也是Value对象, 我用我自己.jpg\n    Json::StreamWriterBuilder builder;\n    const std::string json_file = Json::writeString(builder, root);\n    std::cout << json_file << std::endl;\n  }\n  return EXIT_SUCCESS;\n}\n```\n\n算是了解到了这个库的大概工作流程了. 能学到的部分 吃完午饭继续写.\n吃完饭试了试家里的显示器, 家里的显示器还是太老了...... 八年的显示器了 看得我眼花\n还是继续用笔记本吧\n\n1. 首先我很喜欢这种运算符重载的使用形式, 用起来非常的舒服, 需要重载两个运算符 `[]`和`=` 而且\n`=运算符`重载使用的swap交换需要的属性, 感觉不错\n(后来我看了EffectiveC++ 发现这是`=运算符处理自我赋值`太巧了)\n\n2. 针对需要加载配置文件的类 使用了工厂模式\n3. writeValue使用了递归处理.\n4. 统一处理, k v都是Value对象\n5. 将用户的string 拷贝到新的`char*`中 同时在开头增加了长度, 尾部补了0, 没有使用额外的变量去存储`char*`的长度\n不太清楚这样做有什么好处\n6. 常量全部用的 `static constexpr`修饰\n7. 恰当的对象嵌套\n\n\n----\n\n看完了从 Value到Json 接下来看看从Json到Value\n\n```c++\nint main() {\n  const std::string rawJson = R\"({\"Age\": 20, \"Name\": \"colin\"})\";\n  const auto rawJsonLength = static_cast<int>(rawJson.length());\n  constexpr bool shouldUseOldWay = false;\n  JSONCPP_STRING err;\n  Json::Value root;\n\n  if (shouldUseOldWay) {\n    Json::Reader reader;\n    reader.parse(rawJson, root);\n  } else {\n      // 默认构造函数 使用默认的配置\n    Json::CharReaderBuilder builder;\n\n    // 根据builder的配置生成CharReader类\n    const std::unique_ptr<Json::CharReader> reader(builder.newCharReader());\n    if (!reader->parse(rawJson.c_str(), rawJson.c_str() + rawJsonLength, &root,\n                       &err)) {\n      std::cout << \"error\" << std::endl;\n      return EXIT_FAILURE;\n    }\n  }\n  const std::string name = root[\"Name\"].asString();\n  const int age = root[\"Age\"].asInt();\n\n  std::cout << name << std::endl;\n  std::cout << age << std::endl;\n  return EXIT_SUCCESS;\n}\n```\n\n解析的关键在于`parse()`函数 传入字符串的首尾指针, 和一个Value引用\n进入函数后将传入的变量保存到了自己的成员变量中.\n\n慢慢发现 这个库将很多的默认类型 起了别名 可能是为了统一类型 类似UE4也是自己搞了一套\n\n主要是`OurReader`这个负责解析\n```c++\n// 使用了大量的using\nusing Char = char;\nusing Location = const Char*;\n```\n\n解析逻辑就是`parse()`调用`readValue()`\n`readValue()`负责 获取下一次数据类型type_ ->switch(type_) 根据分支决定是否递归再次调用`readValue`\n总算把逻辑看懂了, 代码依然认为很赞\n`readToken()`这个函数贯穿整个解析, 通过这个函数获取到下一次的数据是什么类型, 同时移动相关的状态指针\n`readToken()` 内部大量调用下面的函数 修改当前指针 同时返回字符, 然后switch这个字符判断下一次的数据类型\n比如遇到`{`就是一个对象的开始设置好type并返回 遇到`}`就是对象的结束.....\n```c++\n// 获取current_指向的字符 并自增\nOurReader::Char OurReader::getNextChar()\n{\n  if (current_ == end_)\n    return 0;\n  return *current_++;\n}\n```\n\n一般第一次调用type_会被设置为对象类型, 然后`readValue()`进入`case 对象分支`\n`case对象分支中`\n先进行了一次`readToken()`获取到了k的类型, 然后根据k类型分支 将k的值转换成对应的value\n之后又是一次`readToken()`判断是否存在`:`不存在就是错误\n在之后使用这个方法, 保存`k`的vallue获取`v`的value再次调用`readValue()`填充值 返回后继续走\n```c++\n// 这里保存了name 这个k 将name的 v放入了顶层\nValue& value = currentValue()[name];\nnodes_.push(&value);\nbool ok = readValue();\n```\n读取完`v`的value之后必定是`,`或者`}`又是一次判断 成功判断后一个`k v`就获取完毕了\n\n` using Nodes = std::stack<Value*>`\n后面解析的代码更加的妙不可言, 使用`Nodes nodes_{}`存储当前的value 实现函数之间的操作\n\n代码合理的组织\n比如`case 对象分支`必定是一个`k`一个`:`一个`v` 然后一个分隔符`,`或`}` 这些放入了一个函数\n\n然后获取到`k`之后使用`Value& value = currentValue()[name]`获取`v`\n\n最后依然是递归的使用","slug":"CPP-源码学习-Jsoncpp代码阅读","published":1,"updated":"2020-03-04T07:52:44.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucuz000z8cuof3dtaft2","content":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Json::Value root;</span><br><span class=\"line\">root[<span class=\"string\">\"action\"</span>] = <span class=\"string\">\"run\"</span>;</span><br></pre></td></tr></table></figure>\n<p>首先是 <code>[]运算符重载</code> , 统一不同的重载类型<br>调用<code>resolveReference()</code>进行统一的添加<code>k</code>操作</p>\n<p>首先会进行 校验参数, 然后将key封装成一个对象CZString (封装过程为将传入指针保存到 CZString对象中的cstr_)<br>封装完成后再保存<code>k v</code>的<code>map&lt;CZString, Value&gt;</code>中查找有无相同的CZString(key)有的话返回Value引用,<br>没有则创建新的&lt;CZStrng, 空Value&gt;存入map并返回Value的引用</p>\n<p>然后是<code>=运算符重载</code>, “run”自动转换成Value对象<br>转换过程中, 通过<code>duplicateAndPrefixStringValue()</code>将”run”进行了封装<br><code>char* string_; // if allocated_, ptr to { unsigned, char[] }.</code><br>将长度封装到了一个char指针中, 有点类似自己设计tcp协议…</p>\n<p><code>=运算符重载</code>函数将<code>[]运算符重载</code>返回的对象引用 中的相关值<code>swap()</code>成新的Value对象中的相关值</p>\n<p>到这里理解了在Jsoncpp中 一切都是Value 包括&lt;K, V&gt;键值对也是在Value对象中存储<br>每一个&lt;k, v&gt;都可以作为一个Value对象, 这样既实现了复杂嵌套Json中 v为对象的情况 妙啊</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每个Value对象中都维护一个union</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> ValueHolder &#123;</span><br><span class=\"line\">    LargestInt int_;</span><br><span class=\"line\">    LargestUInt uint_;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> real_;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> bool_;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* string_; <span class=\"comment\">// if allocated_, ptr to &#123; unsigned, char[] &#125;.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将所有的存贮着key的CZString保存起来</span></span><br><span class=\"line\">\t<span class=\"comment\">//  typedef std::map&lt;CZString, Value&gt; ObjectValues; // std::map&lt;CZString, Value&gt; 键值对</span></span><br><span class=\"line\">    ObjectValues* map_;</span><br><span class=\"line\">  &#125; value_;</span><br></pre></td></tr></table></figure>\n\n<p>下面的switch的这个type 会在很多地方被修改掉.<br>起初 使用默认构造函数的value type是nullxxx<br>然后调用<code>[]运算符重载</code>的时候会修改掉 type 为 objectValue</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 递归调用 进行处理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BuiltStyledStreamWriter::writeValue</span><span class=\"params\">(Value <span class=\"keyword\">const</span>&amp; value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (value.type()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> nullValue:</span><br><span class=\"line\">    pushValue(nullSymbol_);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> intValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asLargestInt()));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> uintValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asLargestUInt()));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> realValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,</span><br><span class=\"line\">                            precisionType_));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> stringValue: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Is NULL is possible for value.string_? No.</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>* str;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>* <span class=\"built_in\">end</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ok = value.getString(&amp;str, &amp;<span class=\"built_in\">end</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ok)</span><br><span class=\"line\">      pushValue(valueToQuotedStringN(str, <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">unsigned</span>&gt;(<span class=\"built_in\">end</span> - str),</span><br><span class=\"line\">                                     emitUTF8_));</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      pushValue(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> booleanValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asBool()));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> arrayValue:</span><br><span class=\"line\">    writeArrayValue(value);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> objectValue: &#123;</span><br><span class=\"line\">    <span class=\"function\">Value::Members <span class=\"title\">members</span><span class=\"params\">(value.getMemberNames())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (members.empty())</span><br><span class=\"line\">      pushValue(<span class=\"string\">\"&#123;&#125;\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      writeWithIndent(<span class=\"string\">\"&#123;\"</span>);</span><br><span class=\"line\">      indent();</span><br><span class=\"line\">      <span class=\"keyword\">auto</span> it = members.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> <span class=\"keyword\">const</span>&amp; name = *it;</span><br><span class=\"line\">        Value <span class=\"keyword\">const</span>&amp; childValue = value[name];</span><br><span class=\"line\">        writeCommentBeforeValue(childValue);</span><br><span class=\"line\">        writeWithIndent(valueToQuotedStringN(</span><br><span class=\"line\">            name.data(), <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">unsigned</span>&gt;(name.length()), emitUTF8_));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// :</span></span><br><span class=\"line\">        *sout_ &lt;&lt; colonSymbol_;</span><br><span class=\"line\">        writeValue(childValue);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++it == members.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">          writeCommentAfterValueOnSameLine(childValue);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        *sout_ &lt;&lt; <span class=\"string\">\",\"</span>;</span><br><span class=\"line\">        writeCommentAfterValueOnSameLine(childValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      unindent();</span><br><span class=\"line\">      writeWithIndent(<span class=\"string\">\"&#125;\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这次是根据下面的例子分析的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Json::Value root;</span><br><span class=\"line\">  Json::Value data;</span><br><span class=\"line\">  <span class=\"keyword\">constexpr</span> <span class=\"keyword\">bool</span> shouldUseOldWay = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 左侧返回Value的引用</span></span><br><span class=\"line\">  root[<span class=\"string\">\"action\"</span>] = <span class=\"string\">\"run\"</span>;</span><br><span class=\"line\">  data[<span class=\"string\">\"number\"</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  root[<span class=\"string\">\"data\"</span>] = data;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldUseOldWay) &#123;</span><br><span class=\"line\">    Json::FastWriter writer;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> json_file = writer.<span class=\"built_in\">write</span>(root);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; json_file &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 配置文件也是Value对象, 我用我自己.jpg</span></span><br><span class=\"line\">    Json::StreamWriterBuilder builder;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> json_file = Json::writeString(builder, root);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; json_file &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>算是了解到了这个库的大概工作流程了. 能学到的部分 吃完午饭继续写.<br>吃完饭试了试家里的显示器, 家里的显示器还是太老了…… 八年的显示器了 看得我眼花<br>还是继续用笔记本吧</p>\n<ol>\n<li><p>首先我很喜欢这种运算符重载的使用形式, 用起来非常的舒服, 需要重载两个运算符 <code>[]</code>和<code>=</code> 而且<br><code>=运算符</code>重载使用的swap交换需要的属性, 感觉不错<br>(后来我看了EffectiveC++ 发现这是<code>=运算符处理自我赋值</code>太巧了)</p>\n</li>\n<li><p>针对需要加载配置文件的类 使用了工厂模式</p>\n</li>\n<li><p>writeValue使用了递归处理.</p>\n</li>\n<li><p>统一处理, k v都是Value对象</p>\n</li>\n<li><p>将用户的string 拷贝到新的<code>char*</code>中 同时在开头增加了长度, 尾部补了0, 没有使用额外的变量去存储<code>char*</code>的长度<br>不太清楚这样做有什么好处</p>\n</li>\n<li><p>常量全部用的 <code>static constexpr</code>修饰</p>\n</li>\n<li><p>恰当的对象嵌套</p>\n</li>\n</ol>\n<hr>\n<p>看完了从 Value到Json 接下来看看从Json到Value</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> rawJson = <span class=\"string\">R\"(&#123;\"Age\": 20, \"Name\": \"colin\"&#125;)\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> rawJsonLength = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(rawJson.length());</span><br><span class=\"line\">  <span class=\"keyword\">constexpr</span> <span class=\"keyword\">bool</span> shouldUseOldWay = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  JSONCPP_STRING err;</span><br><span class=\"line\">  Json::Value root;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldUseOldWay) &#123;</span><br><span class=\"line\">    Json::Reader reader;</span><br><span class=\"line\">    reader.parse(rawJson, root);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 默认构造函数 使用默认的配置</span></span><br><span class=\"line\">    Json::CharReaderBuilder builder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据builder的配置生成CharReader类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Json::CharReader&gt; <span class=\"title\">reader</span><span class=\"params\">(builder.newCharReader())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!reader-&gt;parse(rawJson.c_str(), rawJson.c_str() + rawJsonLength, &amp;root,</span><br><span class=\"line\">                       &amp;err)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name = root[<span class=\"string\">\"Name\"</span>].asString();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> age = root[<span class=\"string\">\"Age\"</span>].asInt();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; age &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解析的关键在于<code>parse()</code>函数 传入字符串的首尾指针, 和一个Value引用<br>进入函数后将传入的变量保存到了自己的成员变量中.</p>\n<p>慢慢发现 这个库将很多的默认类型 起了别名 可能是为了统一类型 类似UE4也是自己搞了一套</p>\n<p>主要是<code>OurReader</code>这个负责解析</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用了大量的using</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> Char = <span class=\"keyword\">char</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Location = <span class=\"keyword\">const</span> Char*;</span><br></pre></td></tr></table></figure>\n\n<p>解析逻辑就是<code>parse()</code>调用<code>readValue()</code><br><code>readValue()</code>负责 获取下一次数据类型type_ -&gt;switch(type_) 根据分支决定是否递归再次调用<code>readValue</code><br>总算把逻辑看懂了, 代码依然认为很赞<br><code>readToken()</code>这个函数贯穿整个解析, 通过这个函数获取到下一次的数据是什么类型, 同时移动相关的状态指针<br><code>readToken()</code> 内部大量调用下面的函数 修改当前指针 同时返回字符, 然后switch这个字符判断下一次的数据类型<br>比如遇到<code>{</code>就是一个对象的开始设置好type并返回 遇到<code>}</code>就是对象的结束…..</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取current_指向的字符 并自增</span></span><br><span class=\"line\"><span class=\"function\">OurReader::Char <span class=\"title\">OurReader::getNextChar</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (current_ == end_)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *current_++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一般第一次调用type_会被设置为对象类型, 然后<code>readValue()</code>进入<code>case 对象分支</code><br><code>case对象分支中</code><br>先进行了一次<code>readToken()</code>获取到了k的类型, 然后根据k类型分支 将k的值转换成对应的value<br>之后又是一次<code>readToken()</code>判断是否存在<code>:</code>不存在就是错误<br>在之后使用这个方法, 保存<code>k</code>的vallue获取<code>v</code>的value再次调用<code>readValue()</code>填充值 返回后继续走</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里保存了name 这个k 将name的 v放入了顶层</span></span><br><span class=\"line\">Value&amp; value = currentValue()[name];</span><br><span class=\"line\">nodes_.push(&amp;value);</span><br><span class=\"line\"><span class=\"keyword\">bool</span> ok = readValue();</span><br></pre></td></tr></table></figure>\n<p>读取完<code>v</code>的value之后必定是<code>,</code>或者<code>}</code>又是一次判断 成功判断后一个<code>k v</code>就获取完毕了</p>\n<p><code>using Nodes = std::stack&lt;Value*&gt;</code><br>后面解析的代码更加的妙不可言, 使用<code>Nodes nodes_{}</code>存储当前的value 实现函数之间的操作</p>\n<p>代码合理的组织<br>比如<code>case 对象分支</code>必定是一个<code>k</code>一个<code>:</code>一个<code>v</code> 然后一个分隔符<code>,</code>或<code>}</code> 这些放入了一个函数</p>\n<p>然后获取到<code>k</code>之后使用<code>Value&amp; value = currentValue()[name]</code>获取<code>v</code></p>\n<p>最后依然是递归的使用</p>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Json::Value root;</span><br><span class=\"line\">root[<span class=\"string\">\"action\"</span>] = <span class=\"string\">\"run\"</span>;</span><br></pre></td></tr></table></figure>\n<p>首先是 <code>[]运算符重载</code> , 统一不同的重载类型<br>调用<code>resolveReference()</code>进行统一的添加<code>k</code>操作</p>\n<p>首先会进行 校验参数, 然后将key封装成一个对象CZString (封装过程为将传入指针保存到 CZString对象中的cstr_)<br>封装完成后再保存<code>k v</code>的<code>map&lt;CZString, Value&gt;</code>中查找有无相同的CZString(key)有的话返回Value引用,<br>没有则创建新的&lt;CZStrng, 空Value&gt;存入map并返回Value的引用</p>\n<p>然后是<code>=运算符重载</code>, “run”自动转换成Value对象<br>转换过程中, 通过<code>duplicateAndPrefixStringValue()</code>将”run”进行了封装<br><code>char* string_; // if allocated_, ptr to { unsigned, char[] }.</code><br>将长度封装到了一个char指针中, 有点类似自己设计tcp协议…</p>\n<p><code>=运算符重载</code>函数将<code>[]运算符重载</code>返回的对象引用 中的相关值<code>swap()</code>成新的Value对象中的相关值</p>\n<p>到这里理解了在Jsoncpp中 一切都是Value 包括&lt;K, V&gt;键值对也是在Value对象中存储<br>每一个&lt;k, v&gt;都可以作为一个Value对象, 这样既实现了复杂嵌套Json中 v为对象的情况 妙啊</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每个Value对象中都维护一个union</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> ValueHolder &#123;</span><br><span class=\"line\">    LargestInt int_;</span><br><span class=\"line\">    LargestUInt uint_;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> real_;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> bool_;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* string_; <span class=\"comment\">// if allocated_, ptr to &#123; unsigned, char[] &#125;.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将所有的存贮着key的CZString保存起来</span></span><br><span class=\"line\">\t<span class=\"comment\">//  typedef std::map&lt;CZString, Value&gt; ObjectValues; // std::map&lt;CZString, Value&gt; 键值对</span></span><br><span class=\"line\">    ObjectValues* map_;</span><br><span class=\"line\">  &#125; value_;</span><br></pre></td></tr></table></figure>\n\n<p>下面的switch的这个type 会在很多地方被修改掉.<br>起初 使用默认构造函数的value type是nullxxx<br>然后调用<code>[]运算符重载</code>的时候会修改掉 type 为 objectValue</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 递归调用 进行处理</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">BuiltStyledStreamWriter::writeValue</span><span class=\"params\">(Value <span class=\"keyword\">const</span>&amp; value)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (value.type()) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> nullValue:</span><br><span class=\"line\">    pushValue(nullSymbol_);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> intValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asLargestInt()));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> uintValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asLargestUInt()));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> realValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,</span><br><span class=\"line\">                            precisionType_));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> stringValue: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Is NULL is possible for value.string_? No.</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>* str;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> <span class=\"keyword\">const</span>* <span class=\"built_in\">end</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ok = value.getString(&amp;str, &amp;<span class=\"built_in\">end</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ok)</span><br><span class=\"line\">      pushValue(valueToQuotedStringN(str, <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">unsigned</span>&gt;(<span class=\"built_in\">end</span> - str),</span><br><span class=\"line\">                                     emitUTF8_));</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      pushValue(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> booleanValue:</span><br><span class=\"line\">    pushValue(valueToString(value.asBool()));</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> arrayValue:</span><br><span class=\"line\">    writeArrayValue(value);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> objectValue: &#123;</span><br><span class=\"line\">    <span class=\"function\">Value::Members <span class=\"title\">members</span><span class=\"params\">(value.getMemberNames())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (members.empty())</span><br><span class=\"line\">      pushValue(<span class=\"string\">\"&#123;&#125;\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      writeWithIndent(<span class=\"string\">\"&#123;\"</span>);</span><br><span class=\"line\">      indent();</span><br><span class=\"line\">      <span class=\"keyword\">auto</span> it = members.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> <span class=\"keyword\">const</span>&amp; name = *it;</span><br><span class=\"line\">        Value <span class=\"keyword\">const</span>&amp; childValue = value[name];</span><br><span class=\"line\">        writeCommentBeforeValue(childValue);</span><br><span class=\"line\">        writeWithIndent(valueToQuotedStringN(</span><br><span class=\"line\">            name.data(), <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">unsigned</span>&gt;(name.length()), emitUTF8_));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// :</span></span><br><span class=\"line\">        *sout_ &lt;&lt; colonSymbol_;</span><br><span class=\"line\">        writeValue(childValue);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (++it == members.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">          writeCommentAfterValueOnSameLine(childValue);</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        *sout_ &lt;&lt; <span class=\"string\">\",\"</span>;</span><br><span class=\"line\">        writeCommentAfterValueOnSameLine(childValue);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      unindent();</span><br><span class=\"line\">      writeWithIndent(<span class=\"string\">\"&#125;\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这次是根据下面的例子分析的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Json::Value root;</span><br><span class=\"line\">  Json::Value data;</span><br><span class=\"line\">  <span class=\"keyword\">constexpr</span> <span class=\"keyword\">bool</span> shouldUseOldWay = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 左侧返回Value的引用</span></span><br><span class=\"line\">  root[<span class=\"string\">\"action\"</span>] = <span class=\"string\">\"run\"</span>;</span><br><span class=\"line\">  data[<span class=\"string\">\"number\"</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  root[<span class=\"string\">\"data\"</span>] = data;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldUseOldWay) &#123;</span><br><span class=\"line\">    Json::FastWriter writer;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> json_file = writer.<span class=\"built_in\">write</span>(root);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; json_file &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 配置文件也是Value对象, 我用我自己.jpg</span></span><br><span class=\"line\">    Json::StreamWriterBuilder builder;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> json_file = Json::writeString(builder, root);</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; json_file &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>算是了解到了这个库的大概工作流程了. 能学到的部分 吃完午饭继续写.<br>吃完饭试了试家里的显示器, 家里的显示器还是太老了…… 八年的显示器了 看得我眼花<br>还是继续用笔记本吧</p>\n<ol>\n<li><p>首先我很喜欢这种运算符重载的使用形式, 用起来非常的舒服, 需要重载两个运算符 <code>[]</code>和<code>=</code> 而且<br><code>=运算符</code>重载使用的swap交换需要的属性, 感觉不错<br>(后来我看了EffectiveC++ 发现这是<code>=运算符处理自我赋值</code>太巧了)</p>\n</li>\n<li><p>针对需要加载配置文件的类 使用了工厂模式</p>\n</li>\n<li><p>writeValue使用了递归处理.</p>\n</li>\n<li><p>统一处理, k v都是Value对象</p>\n</li>\n<li><p>将用户的string 拷贝到新的<code>char*</code>中 同时在开头增加了长度, 尾部补了0, 没有使用额外的变量去存储<code>char*</code>的长度<br>不太清楚这样做有什么好处</p>\n</li>\n<li><p>常量全部用的 <code>static constexpr</code>修饰</p>\n</li>\n<li><p>恰当的对象嵌套</p>\n</li>\n</ol>\n<hr>\n<p>看完了从 Value到Json 接下来看看从Json到Value</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> rawJson = <span class=\"string\">R\"(&#123;\"Age\": 20, \"Name\": \"colin\"&#125;)\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> rawJsonLength = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(rawJson.length());</span><br><span class=\"line\">  <span class=\"keyword\">constexpr</span> <span class=\"keyword\">bool</span> shouldUseOldWay = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  JSONCPP_STRING err;</span><br><span class=\"line\">  Json::Value root;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (shouldUseOldWay) &#123;</span><br><span class=\"line\">    Json::Reader reader;</span><br><span class=\"line\">    reader.parse(rawJson, root);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 默认构造函数 使用默认的配置</span></span><br><span class=\"line\">    Json::CharReaderBuilder builder;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据builder的配置生成CharReader类</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;Json::CharReader&gt; <span class=\"title\">reader</span><span class=\"params\">(builder.newCharReader())</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!reader-&gt;parse(rawJson.c_str(), rawJson.c_str() + rawJsonLength, &amp;root,</span><br><span class=\"line\">                       &amp;err)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"error\"</span> &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EXIT_FAILURE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name = root[<span class=\"string\">\"Name\"</span>].asString();</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> age = root[<span class=\"string\">\"Age\"</span>].asInt();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; age &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> EXIT_SUCCESS;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解析的关键在于<code>parse()</code>函数 传入字符串的首尾指针, 和一个Value引用<br>进入函数后将传入的变量保存到了自己的成员变量中.</p>\n<p>慢慢发现 这个库将很多的默认类型 起了别名 可能是为了统一类型 类似UE4也是自己搞了一套</p>\n<p>主要是<code>OurReader</code>这个负责解析</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用了大量的using</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> Char = <span class=\"keyword\">char</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> Location = <span class=\"keyword\">const</span> Char*;</span><br></pre></td></tr></table></figure>\n\n<p>解析逻辑就是<code>parse()</code>调用<code>readValue()</code><br><code>readValue()</code>负责 获取下一次数据类型type_ -&gt;switch(type_) 根据分支决定是否递归再次调用<code>readValue</code><br>总算把逻辑看懂了, 代码依然认为很赞<br><code>readToken()</code>这个函数贯穿整个解析, 通过这个函数获取到下一次的数据是什么类型, 同时移动相关的状态指针<br><code>readToken()</code> 内部大量调用下面的函数 修改当前指针 同时返回字符, 然后switch这个字符判断下一次的数据类型<br>比如遇到<code>{</code>就是一个对象的开始设置好type并返回 遇到<code>}</code>就是对象的结束…..</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取current_指向的字符 并自增</span></span><br><span class=\"line\"><span class=\"function\">OurReader::Char <span class=\"title\">OurReader::getNextChar</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (current_ == end_)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *current_++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一般第一次调用type_会被设置为对象类型, 然后<code>readValue()</code>进入<code>case 对象分支</code><br><code>case对象分支中</code><br>先进行了一次<code>readToken()</code>获取到了k的类型, 然后根据k类型分支 将k的值转换成对应的value<br>之后又是一次<code>readToken()</code>判断是否存在<code>:</code>不存在就是错误<br>在之后使用这个方法, 保存<code>k</code>的vallue获取<code>v</code>的value再次调用<code>readValue()</code>填充值 返回后继续走</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里保存了name 这个k 将name的 v放入了顶层</span></span><br><span class=\"line\">Value&amp; value = currentValue()[name];</span><br><span class=\"line\">nodes_.push(&amp;value);</span><br><span class=\"line\"><span class=\"keyword\">bool</span> ok = readValue();</span><br></pre></td></tr></table></figure>\n<p>读取完<code>v</code>的value之后必定是<code>,</code>或者<code>}</code>又是一次判断 成功判断后一个<code>k v</code>就获取完毕了</p>\n<p><code>using Nodes = std::stack&lt;Value*&gt;</code><br>后面解析的代码更加的妙不可言, 使用<code>Nodes nodes_{}</code>存储当前的value 实现函数之间的操作</p>\n<p>代码合理的组织<br>比如<code>case 对象分支</code>必定是一个<code>k</code>一个<code>:</code>一个<code>v</code> 然后一个分隔符<code>,</code>或<code>}</code> 这些放入了一个函数</p>\n<p>然后获取到<code>k</code>之后使用<code>Value&amp; value = currentValue()[name]</code>获取<code>v</code></p>\n<p>最后依然是递归的使用</p>\n"},{"title":"C++Primer学习","date":"2019-08-16T11:13:22.000Z","top":80,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/C%2B%2BPrimer.png","_content":"\n# 基础知识\n## c++11 的{}初始方式\n```c++\n// c++11 的初始化方式, 有助于防范类型转换错误.\nint a1 = { 24 };\nint b1 = {}; // 默认为0\n\n// 没有 = 同样可以\nint a2 { 24 };\nint b2 {}; // 默认为0\n\nreturn 0;\n```\n\n无符号的变量在 超出范围的时候对应变化\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%9A%84%E9%87%8D%E7%BD%AE%E7%82%B9.jpg)\n\n\n## 转义字符表\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/c%2B%2B%E8%BD%AC%E4%B9%89.jpg)\n\n**char 在默认情况下, 既不是有符号. 也不是无符号.**\n```c++\nchar a; // 此时a可能是 signed char 也可能是 unsigned char 可能会在不同系统之前产生错误\n// 可以显式声明, 来确保不会出现此错误\nsigned char a;\nunsigned char a; \n```\n\n**输入**\n```c++\n\nchar name[10];\ncin.getline(name, 10); // 可以读取换行符, 但不保存\ncin.get(name, 10); // 不读取换行符, 可能导致get到换行符\n\n// 空行和超出长度问题 将在后面说明\n```\n运算符优先级\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=59a3e1017d3e6709aa0d4dad5aaef458/63d9f2d3572c11df57c9a205612762d0f703c2f8.jpg)\n\n**基础的数组**\n```c++\nint a[] = {1, 2, 3, 4};\n// 下方由于 new 只是返回一个地址所以用 int* 接收 \nint* b = new int[4];\ncout << a[0] << endl; // 1\ncout << *(a + 1) << endl;// 2\n```\n**对指针解引用**\n第一印象是 解除引用, 然而并不是\n```c++\n/*\n\"*\"的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。也就是说，解引用是返回内存地址中保存的值。\n比如int a=10; int *p=&a;\ncout<<*p<<endl; 输出a的值，就是解引用操作。\n*/\n```\n## c 风格字符串相关\n对字符数组的赋值, 不建议使用 = 赋值, 可能会导致内存覆盖\n建议使用 `strncpy(目标位置, 字符串, 长度)` 然后手动在目标字符数组最后一位写入`\\0`\n这样安全, 不过这是c风格的, 在c++中可以使用**string来代替字符数组**\n\n## 自动变量 静态存储 动态存储\n自动变量\n```c++\nchar * getInut() {\n\tchar temp[100]; // 局部变量(自动变量), 函数结束时自动释放 存入栈中\n\tcin >> temp;\n\tchar* pn = new char[strlen(temp) + 1];\n\tstrcpy(pn, temp);\n\n\treturn pn;\n}\n```\n动态存储 通过new 和 delete操作内存池(自由存储空间, 堆)\n\n## 宏 异常处理  函数相关\n| 定义 | 说明 |\n| ----- | ----- |\n| `__FILE__` | 存放文件名的字符串字面值 |\n| `__LINE__` | 存放当前行号的整形字面值 |\n| `__TIME__` | 存放文件编译时间的字符串字面量 |\n| `__DATE__` | 存放文件编译日期的字符串字面值 |\n| `__VA_ARGS__` | 用来接受函数参数中`...`, 类似printf函数, 这个宏只能在宏中使用 |\n\n**异常处理**\n代码可以使用throw来抛出异常\n*大部分*可以指定msg来初始化异常\nthrow exception_type(\"msg\")\n表中exception不能指定msg, 来初始化, 除此外表中其他都需要msg初始\n\n| 错误名称        | 对应原因                       |\n| ---------------- | ---------------------------------- |\n| exception        | 最常见的问题                       |\n| runtime_error    | 只有运行的时候才能查到错误         |\n| range_error      | 运行时错误: 超范围                 |\n| overflow_error   | 运行时错误: 上溢                   |\n| underflow_error  | 运行时错误: 下溢                   |\n| logic_error      | 程序逻辑错误                       |\n| domain_error     | 程序逻辑错误: 参数对应的结果不存在 |\n| invalid_argument | 程序逻辑错误: 无效参数             |\n| length_error     |                                    |\n| out_of_range     | 程序逻辑错误: 超范围               |\n\n**默认参数**\n函数可以设定默认参数.\n\n在调用设置有默认参数的函数时只能省略右边的带默认值参数\n如果一个参数设置了默认值, 则其右边的参数都需要设置默认值\n\n如果一个函数在头文件中已经声明了默认参数, 实现的时候不能更该已经设定的默认参数\n\n但可以将未设置默认参数的函数设置默认参数\n\n# 动态内存-自由空间(堆)\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png)\n\n## 动态内存与智能指针\n| 共同操作 | 描述 |\n| --- | --- |\n| shared_ptr\\<T\\> sp | 空智能指针, 指向类型为T的对象 |\n| unique_ptr\\<T\\> up | |\n| p | 将p作为一个条件判断 若p指向对象则为true |\n| \\*p | 解引用, 获得指向的对象 |\n| p->mem | 等价于 (\\*p).mem |\n| p.get() | 返回p中保存的指针, 若智能指针释放了对象, 这个函数返回的指针就成了垂悬指针|\n| swap(p, q) p.swap(q) | 交换p q中的指针|\n\n| shared_ptr 独有操作 | 描述 |\n| -- | --- |\n| make_shared\\<T\\>(args) | 返回一个shared_ptr 指向一个动态分配的T类型对象, 使用args初始化对象 |\n| shared_ptr\\<T\\> p (q) | p是shared_ptr的拷贝, 此操作会递增q中的计数器. q中的指针必须能转换为T* |\n| p = q | 两者均为shared_ptr 所保存的智能指针必须能相互转换, 此操作会递减p的引用计数, 增加q的引用计数, 当p的引用计数为0则其管理的原内存释放 |\n| p.unique() | return p.use_count() == 1 |\n\n**make_shared**\n最安全的分配和使用动态内存的方法\n```c++\n// p指向 \"pppppppppp\"的string\nshared_ptr<string> p = make_shared<string>(10, 'p');\n// 一般使用auto\nauto p = make_shared<string>(10, 'p');\n```\n**shared_ptr的拷贝和赋值**\n当进行拷贝或者赋值操作时候 shared_ptr都会记录有多少个其他的shared_ptr\n指向相同的对象\n引用计数增加的情况\n- 拷贝shared_ptr \n- 初始化其他shared_ptr指针\n- 作为参数传递给一个函数\n- 作为函数的返回值\n\n引用计数减少\n- 赋予新值\n- 被销毁(例如离开作用域)\n\n当引用计数为0的时候, 就会释放自己管理的对象\n```c++\nauto r = make_shared<int>(42);\nr = q; // 给r赋值, 令他指向另一个地址\n\t\t// q原来指向对象的引用计数 递增\n\t\t// r 原来指向对象的引用计数 递减\n\t\t// r的引用计数 为0 则自动释放\n```\n\n**使用动态内存的原因**\n- 程序不知道自己需要使用多少对象 容器类\n- 程序不知道所需对象的准确类型\n- 程序需要在多个对象间共享数据\n\n**程序需要在多个对象间共享数据**\n一般情况\n```c++\nvector<string> v1; // empty\n{ // 新的作用域\n\tvector<string> v2 = {\"a\", \"b\", \"c\"};\n\tv1 = v2;\n} // 离开作用域 v2被销毁\n// v1中有三个元素, 是原来三个元素的拷贝\n```\n\n下面是我们要实现的情况\n```c++\nvector<string> v1; // empty\n{ // 新的作用域\n\tvector<string> v2 = {\"a\", \"b\", \"c\"};\n\tv1 = v2; // v1 v2共享相同的元素\n} // 离开作用域 v2被销毁 但v2的元素不能被销毁\n// v1中有三个元素, 指向原来三个元素\n```\n\n创建一个类来管理这个vector, 但是不能直接保存在其中, 因为当这个类的对象销毁的时候内部的vector也就销毁\n所以需要保存在动态内存中\n\n所以使用shared_ptr来管理动态分配的vector, 当最后一个vector的使用者被销毁的时候才释放内存\n\n确定下这个类提供的操作\n- 修改元素的操作会进行校验 不合法则抛出异常\n- 默认构造函数\n- 接受单一的initiaizer_list\\<string>类型的参数. 这个参数可以接受一个初始器的花括号列表\n\n```c++\nclass StrBlob // 我还去查了下 Blob是二进制数据块...\n{\npublic:\n\ttypedef std::vector<std::string>::size_type size_type;\n\tStrBlob();\n\tStrBlob(std::initializer_list<std::string> il);\n\tsize_type size() const {return data_->size();}\n\tbool empty() const {return data_->empty();}\n\t// 增删\n\tvoid push_back(const std::string &t) {data_->push_back(t)}\n\tvoid pop_back();\n\t// 访问\n\tstd::string& front();\n\tstd::string& back();\n\nprivate:\n\tstd::shared_ptr<std::vector<std::string>> data_;\n\t// 如果data[i] 不合法, 抛出一个异常\n\tvoid check(size_type i, const std::string &msg) const;\n}\n\nStrBlob::StrBlob(): data_(make_shared<vector<string>>()) {}\nStrBlob::StrBlob(initializer_list<std::string> il):\ndata_(make_shared<vector<string>>(il)) {}\n\n// 下标检查\nvoid StrBlob::check(size_type i, const string &msg) const\n{\n\tif (i >= data_->size())\n\t{\n\t\tthrow out_of_range(msg);\n\t}\n}\n\nstring& StrBlob::front()\n{\n\tcheck(0, \"front on empty StrBlob\");\n\treturn data->front();\n}\nstring& StrBlob::back()\n{\n\tcheck(0, \"back on empty StrBlob\");\n\treturn data->back();\n}\nvoid StrBlob::pop_back()\n{\n\tcheck(0, \"pop_back on empty StrBlob\");\n\tdata->pop_back();\n}\n```\n\n**直接管理内存**\n了解到两个概念 一个`默认初始化`一个`值初始化`\n\n```c++\nint i, *pi1 = &i, *pi2 = nullptr;\ndouble *pd = new double(33), *pd2 = pd;\ndelete i; // 错误 i不是指针\ndelete pi1; // 未定义 pi1指向一个局部变量 具有潜在性危害\ndelete pd; // ok\ndelete pd2; // 未定义 内存已经被释放 具有潜在性危害\ndelete pi2; // 正确 释放空指针没有错误\n\nconst int *pci = new const int(1024);\ndelete pci // 正确 释放一个const对象\n```\ndelete之后指针就变成了`空悬指针` 需要将其置为`nullptr`\n\n\n**shared_ptr和new结合使用**\n\n```c++\n// 错误智能指针构造函数是explicit\n// 无法将内置指针隐式转换成一个智能指针, 必须使用直接初始化\nshared_ptr<int> p1 = new int(1024); \n\n// 正确  使用了直接初始化\nshared_ptr<int> p2(new int(1024));\n```\n\n定义和改变方式\n```c++\n// p管理内置指针q所指向的对象, q必须指向new分配的内存, 且能够转换为T*类型\nshared_ptr<T> p(q)\n\n// p从unique_ptr u那里接管了对象的所有权 将U置为空\nshared_ptr<T> p(u)\n\n// p 接管了内置指针q所指向的对象的所有权, q必须能转化为T* 类型\n// p将使用可调用对象d来代替delete\nshared_ptr<T> p(q, d)\n\n// p是shared_ptr p2的拷贝\n// p将用可调用对象d来代替delete\nshared_ptr<T> p(p2, d)\n\n// 若p是唯一指向其对象的shared_ptr, reset会释放此对象\n// 如果传递了可选的参数-内置指针q, 则会令p指向q 否则将p置为空\n// 如果还传递了d, 会调用d而不是delete来释放q\np.reset()\np.reset(q)\np.reset(q, d)\n```\n\n\n使用unique_ptr的时候要注意\n1. 不要再函数调用传参的括号中 使用临时变量 这样一旦函数调用完成就会被销毁\n```c++\nvoid process(shared_ptr<int> ptr)\n\nshared_ptr<int> p(new int(42 )) ; // 引用 = 1\nprocess(p); // 拷贝 会递增它的引用计数 ;在 process 中引用计数位为2\nint i = *p; // 正确 引用计数为1\n\nint *x(new int(1024)); // 危险 这是一个普通指针，不是一个智能指针\nprocess(x) ; // 错误 不能将 int* 转换为 一个 shared_ptr<int> \nprocess(shared_ptr<int> (x)); // 合法的，但内存会被释放! 因为临时对象会被销毁\nint j =*x //未定义的 是一个空悬指针!\n```\n2. 如果使用智能指针不要使用get函数初始化另一个智能指针或为其赋值\n因为一旦新生成的智能指针离开作用域或者被释放, 会影响到原来的智能指针\n```c++\nstd::shared_ptr<int> p = new int(8); // 不能将一个int* 赋值给shared_ptr<int>\n\nstd::shared_ptr<int> p1;\np1.reset(new int(8)); // 可以\n\nstd::shared_ptr<int> p2(new int(8)); // OK\n\n// 使用make_share来创建shared_ptr指针\nstd::shared_ptr<int> p3 = std::make_shared<int>(20);\nauto p4 = std::make_shared<int>(20);\n\n// make_share不能用来创建unique_ptr\nstd::unique_ptr<int> d;\nstd::unique_ptr<int> d1 (new int(8)); \n```\nunique_ptr不支持普通的赋值和拷贝操作, 因为unique_ptr要独占所指向的对象\n\n```c++\nstd::unique_ptr<int> d1 (new int(1)); \nstd::unique_ptr<int> d2 (new int(8)); \n\nd1.release(); // 释放原来所指向的对象\nd1.reset(d2.release()); // d2释放后由d1获取\n```\n\n**智能指针陷阱**\n1. 不使用相同的内置指针值初始化(或reset)多个智能指针\n2. 不使用delete get返回的指针\n3. 不使用get初始化或者reset另一个智能指针\n4. 如果你使用get返回指针, 当最后一个对应的智能指针销毁 这个指针就变成了垂悬指针\n5. 使用智能指针管理非new分配的内存, 需要传递一个删除器.\n\n**weak_ptr**\n不控制所指向对象生存周期, 指向一个shared_ptr管理的对象.\n\n| 表示 | 含义 |\n| --- | --- |\n| weak_ptr/<T> w | 空格weak_ptr可以指向类型为T的对象 |\n| weak_ptr/<T> w(sp) | 与shared_ptr sp智能指针指向相同的对象, 但引用计数不增加 |\n| w = p | p可以是shared_ptr或者weak_ptr, 赋值后w与p共享对象 |\n| w.reset() | |\n| w.use_count() | 与w共享对象的shared_ptr的数量 |\n| w.expire() | return w.use_count() == 0; |\n| w.lock() | 如果expire为true返回一个空的 sp 否则返回指向w对象的sp |\n\n```c++\nclass StrBlobPtr\n{\npublic:\n\tStrBlobPtr():curr(0) {}\n\tStrBlobPtr(StrBlob &a, size_t sz = 0):\n\t\twptr(a.data), curr(sz) {}\n\tstd::sting& deref() const;\n\tStrBlobPtr& incr(); // 前缀自增\n\nprivate:\n\tstd::shared_ptr<std::vector<std::string>>\n\t\tcheck(std::size_t, const std::string&) const;\n\tstd::weak_ptr<std::vector<std::string>> wptr;\n\tstd::size_t curr;\n}\n\nstd::shared_ptr<std::vector<std::string>>\n\tcheck(std::size_t i, const std::string &msg) const\n{\n\tauto ret = wptr.lock() // 判断vector是否还存在\n\tif (!ret)\n\t{\n\t\tthrow std::runtime_error(\"unbond StrBlobPtr\");\n\t}\n\tif (i >= ret->size())\n\t{\n\t\tthrow std::out_of_range(msg);\n\t}\n\treturn ret;\n}\n```\n由于weak_ptr不参与对应的shared_ptr的引用计数, vector可能已经被释放了\n释放后 lock将返回一个空指针\n\n\n\n\n# 模板与泛型编程\n\n`template <typename T>`\n\n编译器用推断出的模板参数来`实例化`一个特定版本的函数.\n不同的模板参数类型`实例化`出不同的函数 然后进行调用.\n\n**模板类型参数**\n\n如果有多个模板参数\n```c++\n// 错误\ntemplate <typename T, U>\n\n// 正确\ntemplate <typename T, typename U>\n\n// 正确\ntemplate <typename T, class U>\n```\n\n**非类型模板参数**\n\n```c++\ntemplate <unsigned N, unsigned M>\nint compare(const char (&p1)[N], const char (&p2)[M])\n{\n\treturn strcmp(p1, p2);\n}\n\ncompare(\"hi\", \"mmm\");\nint compare(const char (&p1)[3], const char (&p2)[4]) // 注意空字符\n```\n编译器会使用字面常量的大小来代替N和M, 从而实例化模板\n\n非类型参数可以使`整形`或者是一个指向对象或者函数类型的`指针`或者`(左值)引用`\n绑定到`非类型整数参数`的实参必须是一个常量表达式.\n绑定到`指针`或者`引用非类型模板参数`的实参必须具有静态的生存期\n\n静态内存用来保存`局部static对象`, `类static数据成员`和`定义于任何函数之外的变量`\n栈内存用来保存定义在函数内的非static对象.\n分配在静态内存和栈内存的由编译器自动创建和销毁\n\n堆 用来存储动态分配的对象\n\n\n编译器遇到一个模板类型定义的时候并不会生成代码, 而是实例化出一个特定版本的时候才会实例化\n","source":"_posts/CPP-读书记录80-CPPPrimer.md","raw":"---\ntitle: C++Primer学习\ntags:\n  - null\ncategories:\n  - CPP\n  - 服务器编程-书籍记录\ndate: 2019-08-16 19:13:22\ntop: 80\n\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/C%2B%2BPrimer.png\n---\n\n# 基础知识\n## c++11 的{}初始方式\n```c++\n// c++11 的初始化方式, 有助于防范类型转换错误.\nint a1 = { 24 };\nint b1 = {}; // 默认为0\n\n// 没有 = 同样可以\nint a2 { 24 };\nint b2 {}; // 默认为0\n\nreturn 0;\n```\n\n无符号的变量在 超出范围的时候对应变化\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%9A%84%E9%87%8D%E7%BD%AE%E7%82%B9.jpg)\n\n\n## 转义字符表\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/c%2B%2B%E8%BD%AC%E4%B9%89.jpg)\n\n**char 在默认情况下, 既不是有符号. 也不是无符号.**\n```c++\nchar a; // 此时a可能是 signed char 也可能是 unsigned char 可能会在不同系统之前产生错误\n// 可以显式声明, 来确保不会出现此错误\nsigned char a;\nunsigned char a; \n```\n\n**输入**\n```c++\n\nchar name[10];\ncin.getline(name, 10); // 可以读取换行符, 但不保存\ncin.get(name, 10); // 不读取换行符, 可能导致get到换行符\n\n// 空行和超出长度问题 将在后面说明\n```\n运算符优先级\n![](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=59a3e1017d3e6709aa0d4dad5aaef458/63d9f2d3572c11df57c9a205612762d0f703c2f8.jpg)\n\n**基础的数组**\n```c++\nint a[] = {1, 2, 3, 4};\n// 下方由于 new 只是返回一个地址所以用 int* 接收 \nint* b = new int[4];\ncout << a[0] << endl; // 1\ncout << *(a + 1) << endl;// 2\n```\n**对指针解引用**\n第一印象是 解除引用, 然而并不是\n```c++\n/*\n\"*\"的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。也就是说，解引用是返回内存地址中保存的值。\n比如int a=10; int *p=&a;\ncout<<*p<<endl; 输出a的值，就是解引用操作。\n*/\n```\n## c 风格字符串相关\n对字符数组的赋值, 不建议使用 = 赋值, 可能会导致内存覆盖\n建议使用 `strncpy(目标位置, 字符串, 长度)` 然后手动在目标字符数组最后一位写入`\\0`\n这样安全, 不过这是c风格的, 在c++中可以使用**string来代替字符数组**\n\n## 自动变量 静态存储 动态存储\n自动变量\n```c++\nchar * getInut() {\n\tchar temp[100]; // 局部变量(自动变量), 函数结束时自动释放 存入栈中\n\tcin >> temp;\n\tchar* pn = new char[strlen(temp) + 1];\n\tstrcpy(pn, temp);\n\n\treturn pn;\n}\n```\n动态存储 通过new 和 delete操作内存池(自由存储空间, 堆)\n\n## 宏 异常处理  函数相关\n| 定义 | 说明 |\n| ----- | ----- |\n| `__FILE__` | 存放文件名的字符串字面值 |\n| `__LINE__` | 存放当前行号的整形字面值 |\n| `__TIME__` | 存放文件编译时间的字符串字面量 |\n| `__DATE__` | 存放文件编译日期的字符串字面值 |\n| `__VA_ARGS__` | 用来接受函数参数中`...`, 类似printf函数, 这个宏只能在宏中使用 |\n\n**异常处理**\n代码可以使用throw来抛出异常\n*大部分*可以指定msg来初始化异常\nthrow exception_type(\"msg\")\n表中exception不能指定msg, 来初始化, 除此外表中其他都需要msg初始\n\n| 错误名称        | 对应原因                       |\n| ---------------- | ---------------------------------- |\n| exception        | 最常见的问题                       |\n| runtime_error    | 只有运行的时候才能查到错误         |\n| range_error      | 运行时错误: 超范围                 |\n| overflow_error   | 运行时错误: 上溢                   |\n| underflow_error  | 运行时错误: 下溢                   |\n| logic_error      | 程序逻辑错误                       |\n| domain_error     | 程序逻辑错误: 参数对应的结果不存在 |\n| invalid_argument | 程序逻辑错误: 无效参数             |\n| length_error     |                                    |\n| out_of_range     | 程序逻辑错误: 超范围               |\n\n**默认参数**\n函数可以设定默认参数.\n\n在调用设置有默认参数的函数时只能省略右边的带默认值参数\n如果一个参数设置了默认值, 则其右边的参数都需要设置默认值\n\n如果一个函数在头文件中已经声明了默认参数, 实现的时候不能更该已经设定的默认参数\n\n但可以将未设置默认参数的函数设置默认参数\n\n# 动态内存-自由空间(堆)\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png)\n\n## 动态内存与智能指针\n| 共同操作 | 描述 |\n| --- | --- |\n| shared_ptr\\<T\\> sp | 空智能指针, 指向类型为T的对象 |\n| unique_ptr\\<T\\> up | |\n| p | 将p作为一个条件判断 若p指向对象则为true |\n| \\*p | 解引用, 获得指向的对象 |\n| p->mem | 等价于 (\\*p).mem |\n| p.get() | 返回p中保存的指针, 若智能指针释放了对象, 这个函数返回的指针就成了垂悬指针|\n| swap(p, q) p.swap(q) | 交换p q中的指针|\n\n| shared_ptr 独有操作 | 描述 |\n| -- | --- |\n| make_shared\\<T\\>(args) | 返回一个shared_ptr 指向一个动态分配的T类型对象, 使用args初始化对象 |\n| shared_ptr\\<T\\> p (q) | p是shared_ptr的拷贝, 此操作会递增q中的计数器. q中的指针必须能转换为T* |\n| p = q | 两者均为shared_ptr 所保存的智能指针必须能相互转换, 此操作会递减p的引用计数, 增加q的引用计数, 当p的引用计数为0则其管理的原内存释放 |\n| p.unique() | return p.use_count() == 1 |\n\n**make_shared**\n最安全的分配和使用动态内存的方法\n```c++\n// p指向 \"pppppppppp\"的string\nshared_ptr<string> p = make_shared<string>(10, 'p');\n// 一般使用auto\nauto p = make_shared<string>(10, 'p');\n```\n**shared_ptr的拷贝和赋值**\n当进行拷贝或者赋值操作时候 shared_ptr都会记录有多少个其他的shared_ptr\n指向相同的对象\n引用计数增加的情况\n- 拷贝shared_ptr \n- 初始化其他shared_ptr指针\n- 作为参数传递给一个函数\n- 作为函数的返回值\n\n引用计数减少\n- 赋予新值\n- 被销毁(例如离开作用域)\n\n当引用计数为0的时候, 就会释放自己管理的对象\n```c++\nauto r = make_shared<int>(42);\nr = q; // 给r赋值, 令他指向另一个地址\n\t\t// q原来指向对象的引用计数 递增\n\t\t// r 原来指向对象的引用计数 递减\n\t\t// r的引用计数 为0 则自动释放\n```\n\n**使用动态内存的原因**\n- 程序不知道自己需要使用多少对象 容器类\n- 程序不知道所需对象的准确类型\n- 程序需要在多个对象间共享数据\n\n**程序需要在多个对象间共享数据**\n一般情况\n```c++\nvector<string> v1; // empty\n{ // 新的作用域\n\tvector<string> v2 = {\"a\", \"b\", \"c\"};\n\tv1 = v2;\n} // 离开作用域 v2被销毁\n// v1中有三个元素, 是原来三个元素的拷贝\n```\n\n下面是我们要实现的情况\n```c++\nvector<string> v1; // empty\n{ // 新的作用域\n\tvector<string> v2 = {\"a\", \"b\", \"c\"};\n\tv1 = v2; // v1 v2共享相同的元素\n} // 离开作用域 v2被销毁 但v2的元素不能被销毁\n// v1中有三个元素, 指向原来三个元素\n```\n\n创建一个类来管理这个vector, 但是不能直接保存在其中, 因为当这个类的对象销毁的时候内部的vector也就销毁\n所以需要保存在动态内存中\n\n所以使用shared_ptr来管理动态分配的vector, 当最后一个vector的使用者被销毁的时候才释放内存\n\n确定下这个类提供的操作\n- 修改元素的操作会进行校验 不合法则抛出异常\n- 默认构造函数\n- 接受单一的initiaizer_list\\<string>类型的参数. 这个参数可以接受一个初始器的花括号列表\n\n```c++\nclass StrBlob // 我还去查了下 Blob是二进制数据块...\n{\npublic:\n\ttypedef std::vector<std::string>::size_type size_type;\n\tStrBlob();\n\tStrBlob(std::initializer_list<std::string> il);\n\tsize_type size() const {return data_->size();}\n\tbool empty() const {return data_->empty();}\n\t// 增删\n\tvoid push_back(const std::string &t) {data_->push_back(t)}\n\tvoid pop_back();\n\t// 访问\n\tstd::string& front();\n\tstd::string& back();\n\nprivate:\n\tstd::shared_ptr<std::vector<std::string>> data_;\n\t// 如果data[i] 不合法, 抛出一个异常\n\tvoid check(size_type i, const std::string &msg) const;\n}\n\nStrBlob::StrBlob(): data_(make_shared<vector<string>>()) {}\nStrBlob::StrBlob(initializer_list<std::string> il):\ndata_(make_shared<vector<string>>(il)) {}\n\n// 下标检查\nvoid StrBlob::check(size_type i, const string &msg) const\n{\n\tif (i >= data_->size())\n\t{\n\t\tthrow out_of_range(msg);\n\t}\n}\n\nstring& StrBlob::front()\n{\n\tcheck(0, \"front on empty StrBlob\");\n\treturn data->front();\n}\nstring& StrBlob::back()\n{\n\tcheck(0, \"back on empty StrBlob\");\n\treturn data->back();\n}\nvoid StrBlob::pop_back()\n{\n\tcheck(0, \"pop_back on empty StrBlob\");\n\tdata->pop_back();\n}\n```\n\n**直接管理内存**\n了解到两个概念 一个`默认初始化`一个`值初始化`\n\n```c++\nint i, *pi1 = &i, *pi2 = nullptr;\ndouble *pd = new double(33), *pd2 = pd;\ndelete i; // 错误 i不是指针\ndelete pi1; // 未定义 pi1指向一个局部变量 具有潜在性危害\ndelete pd; // ok\ndelete pd2; // 未定义 内存已经被释放 具有潜在性危害\ndelete pi2; // 正确 释放空指针没有错误\n\nconst int *pci = new const int(1024);\ndelete pci // 正确 释放一个const对象\n```\ndelete之后指针就变成了`空悬指针` 需要将其置为`nullptr`\n\n\n**shared_ptr和new结合使用**\n\n```c++\n// 错误智能指针构造函数是explicit\n// 无法将内置指针隐式转换成一个智能指针, 必须使用直接初始化\nshared_ptr<int> p1 = new int(1024); \n\n// 正确  使用了直接初始化\nshared_ptr<int> p2(new int(1024));\n```\n\n定义和改变方式\n```c++\n// p管理内置指针q所指向的对象, q必须指向new分配的内存, 且能够转换为T*类型\nshared_ptr<T> p(q)\n\n// p从unique_ptr u那里接管了对象的所有权 将U置为空\nshared_ptr<T> p(u)\n\n// p 接管了内置指针q所指向的对象的所有权, q必须能转化为T* 类型\n// p将使用可调用对象d来代替delete\nshared_ptr<T> p(q, d)\n\n// p是shared_ptr p2的拷贝\n// p将用可调用对象d来代替delete\nshared_ptr<T> p(p2, d)\n\n// 若p是唯一指向其对象的shared_ptr, reset会释放此对象\n// 如果传递了可选的参数-内置指针q, 则会令p指向q 否则将p置为空\n// 如果还传递了d, 会调用d而不是delete来释放q\np.reset()\np.reset(q)\np.reset(q, d)\n```\n\n\n使用unique_ptr的时候要注意\n1. 不要再函数调用传参的括号中 使用临时变量 这样一旦函数调用完成就会被销毁\n```c++\nvoid process(shared_ptr<int> ptr)\n\nshared_ptr<int> p(new int(42 )) ; // 引用 = 1\nprocess(p); // 拷贝 会递增它的引用计数 ;在 process 中引用计数位为2\nint i = *p; // 正确 引用计数为1\n\nint *x(new int(1024)); // 危险 这是一个普通指针，不是一个智能指针\nprocess(x) ; // 错误 不能将 int* 转换为 一个 shared_ptr<int> \nprocess(shared_ptr<int> (x)); // 合法的，但内存会被释放! 因为临时对象会被销毁\nint j =*x //未定义的 是一个空悬指针!\n```\n2. 如果使用智能指针不要使用get函数初始化另一个智能指针或为其赋值\n因为一旦新生成的智能指针离开作用域或者被释放, 会影响到原来的智能指针\n```c++\nstd::shared_ptr<int> p = new int(8); // 不能将一个int* 赋值给shared_ptr<int>\n\nstd::shared_ptr<int> p1;\np1.reset(new int(8)); // 可以\n\nstd::shared_ptr<int> p2(new int(8)); // OK\n\n// 使用make_share来创建shared_ptr指针\nstd::shared_ptr<int> p3 = std::make_shared<int>(20);\nauto p4 = std::make_shared<int>(20);\n\n// make_share不能用来创建unique_ptr\nstd::unique_ptr<int> d;\nstd::unique_ptr<int> d1 (new int(8)); \n```\nunique_ptr不支持普通的赋值和拷贝操作, 因为unique_ptr要独占所指向的对象\n\n```c++\nstd::unique_ptr<int> d1 (new int(1)); \nstd::unique_ptr<int> d2 (new int(8)); \n\nd1.release(); // 释放原来所指向的对象\nd1.reset(d2.release()); // d2释放后由d1获取\n```\n\n**智能指针陷阱**\n1. 不使用相同的内置指针值初始化(或reset)多个智能指针\n2. 不使用delete get返回的指针\n3. 不使用get初始化或者reset另一个智能指针\n4. 如果你使用get返回指针, 当最后一个对应的智能指针销毁 这个指针就变成了垂悬指针\n5. 使用智能指针管理非new分配的内存, 需要传递一个删除器.\n\n**weak_ptr**\n不控制所指向对象生存周期, 指向一个shared_ptr管理的对象.\n\n| 表示 | 含义 |\n| --- | --- |\n| weak_ptr/<T> w | 空格weak_ptr可以指向类型为T的对象 |\n| weak_ptr/<T> w(sp) | 与shared_ptr sp智能指针指向相同的对象, 但引用计数不增加 |\n| w = p | p可以是shared_ptr或者weak_ptr, 赋值后w与p共享对象 |\n| w.reset() | |\n| w.use_count() | 与w共享对象的shared_ptr的数量 |\n| w.expire() | return w.use_count() == 0; |\n| w.lock() | 如果expire为true返回一个空的 sp 否则返回指向w对象的sp |\n\n```c++\nclass StrBlobPtr\n{\npublic:\n\tStrBlobPtr():curr(0) {}\n\tStrBlobPtr(StrBlob &a, size_t sz = 0):\n\t\twptr(a.data), curr(sz) {}\n\tstd::sting& deref() const;\n\tStrBlobPtr& incr(); // 前缀自增\n\nprivate:\n\tstd::shared_ptr<std::vector<std::string>>\n\t\tcheck(std::size_t, const std::string&) const;\n\tstd::weak_ptr<std::vector<std::string>> wptr;\n\tstd::size_t curr;\n}\n\nstd::shared_ptr<std::vector<std::string>>\n\tcheck(std::size_t i, const std::string &msg) const\n{\n\tauto ret = wptr.lock() // 判断vector是否还存在\n\tif (!ret)\n\t{\n\t\tthrow std::runtime_error(\"unbond StrBlobPtr\");\n\t}\n\tif (i >= ret->size())\n\t{\n\t\tthrow std::out_of_range(msg);\n\t}\n\treturn ret;\n}\n```\n由于weak_ptr不参与对应的shared_ptr的引用计数, vector可能已经被释放了\n释放后 lock将返回一个空指针\n\n\n\n\n# 模板与泛型编程\n\n`template <typename T>`\n\n编译器用推断出的模板参数来`实例化`一个特定版本的函数.\n不同的模板参数类型`实例化`出不同的函数 然后进行调用.\n\n**模板类型参数**\n\n如果有多个模板参数\n```c++\n// 错误\ntemplate <typename T, U>\n\n// 正确\ntemplate <typename T, typename U>\n\n// 正确\ntemplate <typename T, class U>\n```\n\n**非类型模板参数**\n\n```c++\ntemplate <unsigned N, unsigned M>\nint compare(const char (&p1)[N], const char (&p2)[M])\n{\n\treturn strcmp(p1, p2);\n}\n\ncompare(\"hi\", \"mmm\");\nint compare(const char (&p1)[3], const char (&p2)[4]) // 注意空字符\n```\n编译器会使用字面常量的大小来代替N和M, 从而实例化模板\n\n非类型参数可以使`整形`或者是一个指向对象或者函数类型的`指针`或者`(左值)引用`\n绑定到`非类型整数参数`的实参必须是一个常量表达式.\n绑定到`指针`或者`引用非类型模板参数`的实参必须具有静态的生存期\n\n静态内存用来保存`局部static对象`, `类static数据成员`和`定义于任何函数之外的变量`\n栈内存用来保存定义在函数内的非static对象.\n分配在静态内存和栈内存的由编译器自动创建和销毁\n\n堆 用来存储动态分配的对象\n\n\n编译器遇到一个模板类型定义的时候并不会生成代码, 而是实例化出一个特定版本的时候才会实例化\n","slug":"CPP-读书记录80-CPPPrimer","published":1,"updated":"2020-03-21T01:00:30.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucv000118cuofk1f02at","content":"<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><h2 id=\"c-11-的-初始方式\"><a href=\"#c-11-的-初始方式\" class=\"headerlink\" title=\"c++11 的{}初始方式\"></a>c++11 的{}初始方式</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// c++11 的初始化方式, 有助于防范类型转换错误.</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a1 = &#123; <span class=\"number\">24</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b1 = &#123;&#125;; <span class=\"comment\">// 默认为0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 没有 = 同样可以</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a2 &#123; <span class=\"number\">24</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b2 &#123;&#125;; <span class=\"comment\">// 默认为0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>无符号的变量在 超出范围的时候对应变化<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%9A%84%E9%87%8D%E7%BD%AE%E7%82%B9.jpg\" alt=\"\"></p>\n<h2 id=\"转义字符表\"><a href=\"#转义字符表\" class=\"headerlink\" title=\"转义字符表\"></a>转义字符表</h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/c%2B%2B%E8%BD%AC%E4%B9%89.jpg\" alt=\"\"></p>\n<p><strong>char 在默认情况下, 既不是有符号. 也不是无符号.</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a; <span class=\"comment\">// 此时a可能是 signed char 也可能是 unsigned char 可能会在不同系统之前产生错误</span></span><br><span class=\"line\"><span class=\"comment\">// 可以显式声明, 来确保不会出现此错误</span></span><br><span class=\"line\"><span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> a;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> a;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输入</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">cin</span>.getline(name, <span class=\"number\">10</span>); <span class=\"comment\">// 可以读取换行符, 但不保存</span></span><br><span class=\"line\"><span class=\"built_in\">cin</span>.<span class=\"built_in\">get</span>(name, <span class=\"number\">10</span>); <span class=\"comment\">// 不读取换行符, 可能导致get到换行符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 空行和超出长度问题 将在后面说明</span></span><br></pre></td></tr></table></figure>\n<p>运算符优先级<br><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=59a3e1017d3e6709aa0d4dad5aaef458/63d9f2d3572c11df57c9a205612762d0f703c2f8.jpg\" alt=\"\"></p>\n<p><strong>基础的数组</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 下方由于 new 只是返回一个地址所以用 int* 接收 </span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* b = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; a[<span class=\"number\">0</span>] &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; *(a + <span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p><strong>对指针解引用</strong><br>第一印象是 解除引用, 然而并不是</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\"*\"的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。也就是说，解引用是返回内存地址中保存的值。</span></span><br><span class=\"line\"><span class=\"comment\">比如int a=10; int *p=&amp;a;</span></span><br><span class=\"line\"><span class=\"comment\">cout&lt;&lt;*p&lt;&lt;endl; 输出a的值，就是解引用操作。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"c-风格字符串相关\"><a href=\"#c-风格字符串相关\" class=\"headerlink\" title=\"c 风格字符串相关\"></a>c 风格字符串相关</h2><p>对字符数组的赋值, 不建议使用 = 赋值, 可能会导致内存覆盖<br>建议使用 <code>strncpy(目标位置, 字符串, 长度)</code> 然后手动在目标字符数组最后一位写入<code>\\0</code><br>这样安全, 不过这是c风格的, 在c++中可以使用<strong>string来代替字符数组</strong></p>\n<h2 id=\"自动变量-静态存储-动态存储\"><a href=\"#自动变量-静态存储-动态存储\" class=\"headerlink\" title=\"自动变量 静态存储 动态存储\"></a>自动变量 静态存储 动态存储</h2><p>自动变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">getInut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> temp[<span class=\"number\">100</span>]; <span class=\"comment\">// 局部变量(自动变量), 函数结束时自动释放 存入栈中</span></span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; temp;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* pn = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(temp) + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(pn, temp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>动态存储 通过new 和 delete操作内存池(自由存储空间, 堆)</p>\n<h2 id=\"宏-异常处理-函数相关\"><a href=\"#宏-异常处理-函数相关\" class=\"headerlink\" title=\"宏 异常处理  函数相关\"></a>宏 异常处理  函数相关</h2><table>\n<thead>\n<tr>\n<th>定义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>__FILE__</code></td>\n<td>存放文件名的字符串字面值</td>\n</tr>\n<tr>\n<td><code>__LINE__</code></td>\n<td>存放当前行号的整形字面值</td>\n</tr>\n<tr>\n<td><code>__TIME__</code></td>\n<td>存放文件编译时间的字符串字面量</td>\n</tr>\n<tr>\n<td><code>__DATE__</code></td>\n<td>存放文件编译日期的字符串字面值</td>\n</tr>\n<tr>\n<td><code>__VA_ARGS__</code></td>\n<td>用来接受函数参数中<code>...</code>, 类似printf函数, 这个宏只能在宏中使用</td>\n</tr>\n</tbody></table>\n<p><strong>异常处理</strong><br>代码可以使用throw来抛出异常<br><em>大部分</em>可以指定msg来初始化异常<br>throw exception_type(“msg”)<br>表中exception不能指定msg, 来初始化, 除此外表中其他都需要msg初始</p>\n<table>\n<thead>\n<tr>\n<th>错误名称</th>\n<th>对应原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>exception</td>\n<td>最常见的问题</td>\n</tr>\n<tr>\n<td>runtime_error</td>\n<td>只有运行的时候才能查到错误</td>\n</tr>\n<tr>\n<td>range_error</td>\n<td>运行时错误: 超范围</td>\n</tr>\n<tr>\n<td>overflow_error</td>\n<td>运行时错误: 上溢</td>\n</tr>\n<tr>\n<td>underflow_error</td>\n<td>运行时错误: 下溢</td>\n</tr>\n<tr>\n<td>logic_error</td>\n<td>程序逻辑错误</td>\n</tr>\n<tr>\n<td>domain_error</td>\n<td>程序逻辑错误: 参数对应的结果不存在</td>\n</tr>\n<tr>\n<td>invalid_argument</td>\n<td>程序逻辑错误: 无效参数</td>\n</tr>\n<tr>\n<td>length_error</td>\n<td></td>\n</tr>\n<tr>\n<td>out_of_range</td>\n<td>程序逻辑错误: 超范围</td>\n</tr>\n</tbody></table>\n<p><strong>默认参数</strong><br>函数可以设定默认参数.</p>\n<p>在调用设置有默认参数的函数时只能省略右边的带默认值参数<br>如果一个参数设置了默认值, 则其右边的参数都需要设置默认值</p>\n<p>如果一个函数在头文件中已经声明了默认参数, 实现的时候不能更该已经设定的默认参数</p>\n<p>但可以将未设置默认参数的函数设置默认参数</p>\n<h1 id=\"动态内存-自由空间-堆\"><a href=\"#动态内存-自由空间-堆\" class=\"headerlink\" title=\"动态内存-自由空间(堆)\"></a>动态内存-自由空间(堆)</h1><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png\" alt=\"\"></p>\n<h2 id=\"动态内存与智能指针\"><a href=\"#动态内存与智能指针\" class=\"headerlink\" title=\"动态内存与智能指针\"></a>动态内存与智能指针</h2><table>\n<thead>\n<tr>\n<th>共同操作</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>shared_ptr&lt;T&gt; sp</td>\n<td>空智能指针, 指向类型为T的对象</td>\n</tr>\n<tr>\n<td>unique_ptr&lt;T&gt; up</td>\n<td></td>\n</tr>\n<tr>\n<td>p</td>\n<td>将p作为一个条件判断 若p指向对象则为true</td>\n</tr>\n<tr>\n<td>*p</td>\n<td>解引用, 获得指向的对象</td>\n</tr>\n<tr>\n<td>p-&gt;mem</td>\n<td>等价于 (*p).mem</td>\n</tr>\n<tr>\n<td>p.get()</td>\n<td>返回p中保存的指针, 若智能指针释放了对象, 这个函数返回的指针就成了垂悬指针</td>\n</tr>\n<tr>\n<td>swap(p, q) p.swap(q)</td>\n<td>交换p q中的指针</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>shared_ptr 独有操作</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>make_shared&lt;T&gt;(args)</td>\n<td>返回一个shared_ptr 指向一个动态分配的T类型对象, 使用args初始化对象</td>\n</tr>\n<tr>\n<td>shared_ptr&lt;T&gt; p (q)</td>\n<td>p是shared_ptr的拷贝, 此操作会递增q中的计数器. q中的指针必须能转换为T*</td>\n</tr>\n<tr>\n<td>p = q</td>\n<td>两者均为shared_ptr 所保存的智能指针必须能相互转换, 此操作会递减p的引用计数, 增加q的引用计数, 当p的引用计数为0则其管理的原内存释放</td>\n</tr>\n<tr>\n<td>p.unique()</td>\n<td>return p.use_count() == 1</td>\n</tr>\n</tbody></table>\n<p><strong>make_shared</strong><br>最安全的分配和使用动态内存的方法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p指向 \"pppppppppp\"的string</span></span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; p = make_shared&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"number\">10</span>, <span class=\"string\">'p'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 一般使用auto</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> p = make_shared&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"number\">10</span>, <span class=\"string\">'p'</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>shared_ptr的拷贝和赋值</strong><br>当进行拷贝或者赋值操作时候 shared_ptr都会记录有多少个其他的shared_ptr<br>指向相同的对象<br>引用计数增加的情况</p>\n<ul>\n<li>拷贝shared_ptr </li>\n<li>初始化其他shared_ptr指针</li>\n<li>作为参数传递给一个函数</li>\n<li>作为函数的返回值</li>\n</ul>\n<p>引用计数减少</p>\n<ul>\n<li>赋予新值</li>\n<li>被销毁(例如离开作用域)</li>\n</ul>\n<p>当引用计数为0的时候, 就会释放自己管理的对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> r = make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>);</span><br><span class=\"line\">r = q; <span class=\"comment\">// 给r赋值, 令他指向另一个地址</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// q原来指向对象的引用计数 递增</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// r 原来指向对象的引用计数 递减</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// r的引用计数 为0 则自动释放</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>使用动态内存的原因</strong></p>\n<ul>\n<li>程序不知道自己需要使用多少对象 容器类</li>\n<li>程序不知道所需对象的准确类型</li>\n<li>程序需要在多个对象间共享数据</li>\n</ul>\n<p><strong>程序需要在多个对象间共享数据</strong><br>一般情况</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v1; <span class=\"comment\">// empty</span></span><br><span class=\"line\">&#123; <span class=\"comment\">// 新的作用域</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v2 = &#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;;</span><br><span class=\"line\">\tv1 = v2;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 离开作用域 v2被销毁</span></span><br><span class=\"line\"><span class=\"comment\">// v1中有三个元素, 是原来三个元素的拷贝</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是我们要实现的情况</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v1; <span class=\"comment\">// empty</span></span><br><span class=\"line\">&#123; <span class=\"comment\">// 新的作用域</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v2 = &#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;;</span><br><span class=\"line\">\tv1 = v2; <span class=\"comment\">// v1 v2共享相同的元素</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 离开作用域 v2被销毁 但v2的元素不能被销毁</span></span><br><span class=\"line\"><span class=\"comment\">// v1中有三个元素, 指向原来三个元素</span></span><br></pre></td></tr></table></figure>\n\n<p>创建一个类来管理这个vector, 但是不能直接保存在其中, 因为当这个类的对象销毁的时候内部的vector也就销毁<br>所以需要保存在动态内存中</p>\n<p>所以使用shared_ptr来管理动态分配的vector, 当最后一个vector的使用者被销毁的时候才释放内存</p>\n<p>确定下这个类提供的操作</p>\n<ul>\n<li>修改元素的操作会进行校验 不合法则抛出异常</li>\n<li>默认构造函数</li>\n<li>接受单一的initiaizer_list&lt;string&gt;类型的参数. 这个参数可以接受一个初始器的花括号列表</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrBlob</span> // 我还去查了下 <span class=\"title\">Blob</span>是二进制数据块...</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt;::size_type size_type;</span><br><span class=\"line\">\tStrBlob();</span><br><span class=\"line\">\tStrBlob(<span class=\"built_in\">std</span>::<span class=\"built_in\">initializer_list</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; il);</span><br><span class=\"line\">\t<span class=\"function\">size_type <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> data_-&gt;<span class=\"built_in\">size</span>();&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> data_-&gt;empty();&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 增删</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;t)</span> </span>&#123;data_-&gt;push_back(t)&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 访问</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; <span class=\"title\">front</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; <span class=\"title\">back</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt;&gt; data_;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果data[i] 不合法, 抛出一个异常</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">(size_type i, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;msg)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">StrBlob::StrBlob(): data_(make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;()) &#123;&#125;</span><br><span class=\"line\">StrBlob::StrBlob(<span class=\"built_in\">initializer_list</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; il):</span><br><span class=\"line\">data_(make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;(il)) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下标检查</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StrBlob::check</span><span class=\"params\">(size_type i, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;msg)</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (i &gt;= data_-&gt;<span class=\"built_in\">size</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> out_of_range(msg);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">StrBlob::front</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcheck(<span class=\"number\">0</span>, <span class=\"string\">\"front on empty StrBlob\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> data-&gt;front();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">StrBlob::back</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcheck(<span class=\"number\">0</span>, <span class=\"string\">\"back on empty StrBlob\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> data-&gt;back();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StrBlob::pop_back</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcheck(<span class=\"number\">0</span>, <span class=\"string\">\"pop_back on empty StrBlob\"</span>);</span><br><span class=\"line\">\tdata-&gt;pop_back();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>直接管理内存</strong><br>了解到两个概念 一个<code>默认初始化</code>一个<code>值初始化</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i, *pi1 = &amp;i, *pi2 = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> *pd = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>(<span class=\"number\">33</span>), *pd2 = pd;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> i; <span class=\"comment\">// 错误 i不是指针</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pi1; <span class=\"comment\">// 未定义 pi1指向一个局部变量 具有潜在性危害</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pd; <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pd2; <span class=\"comment\">// 未定义 内存已经被释放 具有潜在性危害</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pi2; <span class=\"comment\">// 正确 释放空指针没有错误</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *pci = <span class=\"keyword\">new</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">delete</span> pci <span class=\"comment\">// 正确 释放一个const对象</span></span><br></pre></td></tr></table></figure>\n<p>delete之后指针就变成了<code>空悬指针</code> 需要将其置为<code>nullptr</code></p>\n<p><strong>shared_ptr和new结合使用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误智能指针构造函数是explicit</span></span><br><span class=\"line\"><span class=\"comment\">// 无法将内置指针隐式转换成一个智能指针, 必须使用直接初始化</span></span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确  使用了直接初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>))</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>定义和改变方式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p管理内置指针q所指向的对象, q必须指向new分配的内存, 且能够转换为T*类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(q)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p从unique_ptr u那里接管了对象的所有权 将U置为空</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p 接管了内置指针q所指向的对象的所有权, q必须能转化为T* 类型</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p将使用可调用对象d来代替delete</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(q, d)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p是shared_ptr p2的拷贝</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p将用可调用对象d来代替delete</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(p2, d)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 若p是唯一指向其对象的shared_ptr, reset会释放此对象</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 如果传递了可选的参数-内置指针q, 则会令p指向q 否则将p置为空</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 如果还传递了d, 会调用d而不是delete来释放q</span></span></span><br><span class=\"line\">p.reset()</span><br><span class=\"line\">p.reset(q)</span><br><span class=\"line\">p.reset(q, d)</span><br></pre></td></tr></table></figure>\n\n\n<p>使用unique_ptr的时候要注意</p>\n<ol>\n<li>不要再函数调用传参的括号中 使用临时变量 这样一旦函数调用完成就会被销毁<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; ptr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">42</span> ))</span> </span>; <span class=\"comment\">// 引用 = 1</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(p); <span class=\"comment\">// 拷贝 会递增它的引用计数 ;在 process 中引用计数位为2</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = *p; <span class=\"comment\">// 正确 引用计数为1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">x</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>))</span></span>; <span class=\"comment\">// 危险 这是一个普通指针，不是一个智能指针</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(x) ; <span class=\"comment\">// 错误 不能将 int* 转换为 一个 shared_ptr&lt;int&gt; </span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; (x)); <span class=\"comment\">// 合法的，但内存会被释放! 因为临时对象会被销毁</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> j =*x <span class=\"comment\">//未定义的 是一个空悬指针!</span></span><br></pre></td></tr></table></figure></li>\n<li>如果使用智能指针不要使用get函数初始化另一个智能指针或为其赋值<br>因为一旦新生成的智能指针离开作用域或者被释放, 会影响到原来的智能指针<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>); <span class=\"comment\">// 不能将一个int* 赋值给shared_ptr&lt;int&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p1;</span><br><span class=\"line\">p1.reset(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>)); <span class=\"comment\">// 可以</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>))</span></span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用make_share来创建shared_ptr指针</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p3 = <span class=\"built_in\">std</span>::make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">auto</span> p4 = <span class=\"built_in\">std</span>::make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// make_share不能用来创建unique_ptr</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; d;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">d1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>))</span></span>;</span><br></pre></td></tr></table></figure>\nunique_ptr不支持普通的赋值和拷贝操作, 因为unique_ptr要独占所指向的对象</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">d1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1</span>))</span></span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">d2</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>))</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\">d1.<span class=\"built_in\">release</span>(); <span class=\"comment\">// 释放原来所指向的对象</span></span><br><span class=\"line\">d1.reset(d2.<span class=\"built_in\">release</span>()); <span class=\"comment\">// d2释放后由d1获取</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>智能指针陷阱</strong></p>\n<ol>\n<li>不使用相同的内置指针值初始化(或reset)多个智能指针</li>\n<li>不使用delete get返回的指针</li>\n<li>不使用get初始化或者reset另一个智能指针</li>\n<li>如果你使用get返回指针, 当最后一个对应的智能指针销毁 这个指针就变成了垂悬指针</li>\n<li>使用智能指针管理非new分配的内存, 需要传递一个删除器.</li>\n</ol>\n<p><strong>weak_ptr</strong><br>不控制所指向对象生存周期, 指向一个shared_ptr管理的对象.</p>\n<table>\n<thead>\n<tr>\n<th>表示</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>weak_ptr/<T> w</td>\n<td>空格weak_ptr可以指向类型为T的对象</td>\n</tr>\n<tr>\n<td>weak_ptr/<T> w(sp)</td>\n<td>与shared_ptr sp智能指针指向相同的对象, 但引用计数不增加</td>\n</tr>\n<tr>\n<td>w = p</td>\n<td>p可以是shared_ptr或者weak_ptr, 赋值后w与p共享对象</td>\n</tr>\n<tr>\n<td>w.reset()</td>\n<td></td>\n</tr>\n<tr>\n<td>w.use_count()</td>\n<td>与w共享对象的shared_ptr的数量</td>\n</tr>\n<tr>\n<td>w.expire()</td>\n<td>return w.use_count() == 0;</td>\n</tr>\n<tr>\n<td>w.lock()</td>\n<td>如果expire为true返回一个空的 sp 否则返回指向w对象的sp</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrBlobPtr</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tStrBlobPtr():curr(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\tStrBlobPtr(StrBlob &amp;a, <span class=\"keyword\">size_t</span> sz = <span class=\"number\">0</span>):</span><br><span class=\"line\">\t\twptr(a.data), curr(sz) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">std</span>::sting&amp; <span class=\"title\">deref</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">StrBlobPtr&amp; <span class=\"title\">incr</span><span class=\"params\">()</span></span>; <span class=\"comment\">// 前缀自增</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt;&gt;</span><br><span class=\"line\">\t\tcheck(<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span>, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp;) <span class=\"keyword\">const</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::weak_ptr&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt;&gt; wptr;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> curr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt;&gt;</span><br><span class=\"line\">\tcheck(<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> i, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;msg) <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> ret = wptr.lock() <span class=\"comment\">// 判断vector是否还存在</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::runtime_error(<span class=\"string\">\"unbond StrBlobPtr\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (i &gt;= ret-&gt;<span class=\"built_in\">size</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::out_of_range(msg);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于weak_ptr不参与对应的shared_ptr的引用计数, vector可能已经被释放了<br>释放后 lock将返回一个空指针</p>\n<h1 id=\"模板与泛型编程\"><a href=\"#模板与泛型编程\" class=\"headerlink\" title=\"模板与泛型编程\"></a>模板与泛型编程</h1><p><code>template &lt;typename T&gt;</code></p>\n<p>编译器用推断出的模板参数来<code>实例化</code>一个特定版本的函数.<br>不同的模板参数类型<code>实例化</code>出不同的函数 然后进行调用.</p>\n<p><strong>模板类型参数</strong></p>\n<p>如果有多个模板参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, U&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">U</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>非类型模板参数</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">unsigned</span> N, <span class=\"keyword\">unsigned</span> M&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p1)[N], <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p2)[M])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>(p1, p2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">compare(<span class=\"string\">\"hi\"</span>, <span class=\"string\">\"mmm\"</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p1)[<span class=\"number\">3</span>], <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p2)[<span class=\"number\">4</span>])</span> <span class=\"comment\">// 注意空字符</span></span></span><br></pre></td></tr></table></figure>\n<p>编译器会使用字面常量的大小来代替N和M, 从而实例化模板</p>\n<p>非类型参数可以使<code>整形</code>或者是一个指向对象或者函数类型的<code>指针</code>或者<code>(左值)引用</code><br>绑定到<code>非类型整数参数</code>的实参必须是一个常量表达式.<br>绑定到<code>指针</code>或者<code>引用非类型模板参数</code>的实参必须具有静态的生存期</p>\n<p>静态内存用来保存<code>局部static对象</code>, <code>类static数据成员</code>和<code>定义于任何函数之外的变量</code><br>栈内存用来保存定义在函数内的非static对象.<br>分配在静态内存和栈内存的由编译器自动创建和销毁</p>\n<p>堆 用来存储动态分配的对象</p>\n<p>编译器遇到一个模板类型定义的时候并不会生成代码, 而是实例化出一个特定版本的时候才会实例化</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><h2 id=\"c-11-的-初始方式\"><a href=\"#c-11-的-初始方式\" class=\"headerlink\" title=\"c++11 的{}初始方式\"></a>c++11 的{}初始方式</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// c++11 的初始化方式, 有助于防范类型转换错误.</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a1 = &#123; <span class=\"number\">24</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b1 = &#123;&#125;; <span class=\"comment\">// 默认为0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 没有 = 同样可以</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a2 &#123; <span class=\"number\">24</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> b2 &#123;&#125;; <span class=\"comment\">// 默认为0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<p>无符号的变量在 超出范围的时候对应变化<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E7%9A%84%E9%87%8D%E7%BD%AE%E7%82%B9.jpg\" alt=\"\"></p>\n<h2 id=\"转义字符表\"><a href=\"#转义字符表\" class=\"headerlink\" title=\"转义字符表\"></a>转义字符表</h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/c%2B%2B%E8%BD%AC%E4%B9%89.jpg\" alt=\"\"></p>\n<p><strong>char 在默认情况下, 既不是有符号. 也不是无符号.</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a; <span class=\"comment\">// 此时a可能是 signed char 也可能是 unsigned char 可能会在不同系统之前产生错误</span></span><br><span class=\"line\"><span class=\"comment\">// 可以显式声明, 来确保不会出现此错误</span></span><br><span class=\"line\"><span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> a;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> a;</span><br></pre></td></tr></table></figure>\n\n<p><strong>输入</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> name[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"built_in\">cin</span>.getline(name, <span class=\"number\">10</span>); <span class=\"comment\">// 可以读取换行符, 但不保存</span></span><br><span class=\"line\"><span class=\"built_in\">cin</span>.<span class=\"built_in\">get</span>(name, <span class=\"number\">10</span>); <span class=\"comment\">// 不读取换行符, 可能导致get到换行符</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 空行和超出长度问题 将在后面说明</span></span><br></pre></td></tr></table></figure>\n<p>运算符优先级<br><img src=\"https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=59a3e1017d3e6709aa0d4dad5aaef458/63d9f2d3572c11df57c9a205612762d0f703c2f8.jpg\" alt=\"\"></p>\n<p><strong>基础的数组</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a[] = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 下方由于 new 只是返回一个地址所以用 int* 接收 </span></span><br><span class=\"line\"><span class=\"keyword\">int</span>* b = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; a[<span class=\"number\">0</span>] &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">cout</span> &lt;&lt; *(a + <span class=\"number\">1</span>) &lt;&lt; <span class=\"built_in\">endl</span>;<span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p><strong>对指针解引用</strong><br>第一印象是 解除引用, 然而并不是</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\"*\"的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。也就是说，解引用是返回内存地址中保存的值。</span></span><br><span class=\"line\"><span class=\"comment\">比如int a=10; int *p=&amp;a;</span></span><br><span class=\"line\"><span class=\"comment\">cout&lt;&lt;*p&lt;&lt;endl; 输出a的值，就是解引用操作。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"c-风格字符串相关\"><a href=\"#c-风格字符串相关\" class=\"headerlink\" title=\"c 风格字符串相关\"></a>c 风格字符串相关</h2><p>对字符数组的赋值, 不建议使用 = 赋值, 可能会导致内存覆盖<br>建议使用 <code>strncpy(目标位置, 字符串, 长度)</code> 然后手动在目标字符数组最后一位写入<code>\\0</code><br>这样安全, 不过这是c风格的, 在c++中可以使用<strong>string来代替字符数组</strong></p>\n<h2 id=\"自动变量-静态存储-动态存储\"><a href=\"#自动变量-静态存储-动态存储\" class=\"headerlink\" title=\"自动变量 静态存储 动态存储\"></a>自动变量 静态存储 动态存储</h2><p>自动变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> * <span class=\"title\">getInut</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span> temp[<span class=\"number\">100</span>]; <span class=\"comment\">// 局部变量(自动变量), 函数结束时自动释放 存入栈中</span></span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; temp;</span><br><span class=\"line\">\t<span class=\"keyword\">char</span>* pn = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"built_in\">strlen</span>(temp) + <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">strcpy</span>(pn, temp);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> pn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>动态存储 通过new 和 delete操作内存池(自由存储空间, 堆)</p>\n<h2 id=\"宏-异常处理-函数相关\"><a href=\"#宏-异常处理-函数相关\" class=\"headerlink\" title=\"宏 异常处理  函数相关\"></a>宏 异常处理  函数相关</h2><table>\n<thead>\n<tr>\n<th>定义</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>__FILE__</code></td>\n<td>存放文件名的字符串字面值</td>\n</tr>\n<tr>\n<td><code>__LINE__</code></td>\n<td>存放当前行号的整形字面值</td>\n</tr>\n<tr>\n<td><code>__TIME__</code></td>\n<td>存放文件编译时间的字符串字面量</td>\n</tr>\n<tr>\n<td><code>__DATE__</code></td>\n<td>存放文件编译日期的字符串字面值</td>\n</tr>\n<tr>\n<td><code>__VA_ARGS__</code></td>\n<td>用来接受函数参数中<code>...</code>, 类似printf函数, 这个宏只能在宏中使用</td>\n</tr>\n</tbody></table>\n<p><strong>异常处理</strong><br>代码可以使用throw来抛出异常<br><em>大部分</em>可以指定msg来初始化异常<br>throw exception_type(“msg”)<br>表中exception不能指定msg, 来初始化, 除此外表中其他都需要msg初始</p>\n<table>\n<thead>\n<tr>\n<th>错误名称</th>\n<th>对应原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>exception</td>\n<td>最常见的问题</td>\n</tr>\n<tr>\n<td>runtime_error</td>\n<td>只有运行的时候才能查到错误</td>\n</tr>\n<tr>\n<td>range_error</td>\n<td>运行时错误: 超范围</td>\n</tr>\n<tr>\n<td>overflow_error</td>\n<td>运行时错误: 上溢</td>\n</tr>\n<tr>\n<td>underflow_error</td>\n<td>运行时错误: 下溢</td>\n</tr>\n<tr>\n<td>logic_error</td>\n<td>程序逻辑错误</td>\n</tr>\n<tr>\n<td>domain_error</td>\n<td>程序逻辑错误: 参数对应的结果不存在</td>\n</tr>\n<tr>\n<td>invalid_argument</td>\n<td>程序逻辑错误: 无效参数</td>\n</tr>\n<tr>\n<td>length_error</td>\n<td></td>\n</tr>\n<tr>\n<td>out_of_range</td>\n<td>程序逻辑错误: 超范围</td>\n</tr>\n</tbody></table>\n<p><strong>默认参数</strong><br>函数可以设定默认参数.</p>\n<p>在调用设置有默认参数的函数时只能省略右边的带默认值参数<br>如果一个参数设置了默认值, 则其右边的参数都需要设置默认值</p>\n<p>如果一个函数在头文件中已经声明了默认参数, 实现的时候不能更该已经设定的默认参数</p>\n<p>但可以将未设置默认参数的函数设置默认参数</p>\n<h1 id=\"动态内存-自由空间-堆\"><a href=\"#动态内存-自由空间-堆\" class=\"headerlink\" title=\"动态内存-自由空间(堆)\"></a>动态内存-自由空间(堆)</h1><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/C%2B%2B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.png\" alt=\"\"></p>\n<h2 id=\"动态内存与智能指针\"><a href=\"#动态内存与智能指针\" class=\"headerlink\" title=\"动态内存与智能指针\"></a>动态内存与智能指针</h2><table>\n<thead>\n<tr>\n<th>共同操作</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>shared_ptr&lt;T&gt; sp</td>\n<td>空智能指针, 指向类型为T的对象</td>\n</tr>\n<tr>\n<td>unique_ptr&lt;T&gt; up</td>\n<td></td>\n</tr>\n<tr>\n<td>p</td>\n<td>将p作为一个条件判断 若p指向对象则为true</td>\n</tr>\n<tr>\n<td>*p</td>\n<td>解引用, 获得指向的对象</td>\n</tr>\n<tr>\n<td>p-&gt;mem</td>\n<td>等价于 (*p).mem</td>\n</tr>\n<tr>\n<td>p.get()</td>\n<td>返回p中保存的指针, 若智能指针释放了对象, 这个函数返回的指针就成了垂悬指针</td>\n</tr>\n<tr>\n<td>swap(p, q) p.swap(q)</td>\n<td>交换p q中的指针</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>shared_ptr 独有操作</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>make_shared&lt;T&gt;(args)</td>\n<td>返回一个shared_ptr 指向一个动态分配的T类型对象, 使用args初始化对象</td>\n</tr>\n<tr>\n<td>shared_ptr&lt;T&gt; p (q)</td>\n<td>p是shared_ptr的拷贝, 此操作会递增q中的计数器. q中的指针必须能转换为T*</td>\n</tr>\n<tr>\n<td>p = q</td>\n<td>两者均为shared_ptr 所保存的智能指针必须能相互转换, 此操作会递减p的引用计数, 增加q的引用计数, 当p的引用计数为0则其管理的原内存释放</td>\n</tr>\n<tr>\n<td>p.unique()</td>\n<td>return p.use_count() == 1</td>\n</tr>\n</tbody></table>\n<p><strong>make_shared</strong><br>最安全的分配和使用动态内存的方法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p指向 \"pppppppppp\"的string</span></span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">string</span>&gt; p = make_shared&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"number\">10</span>, <span class=\"string\">'p'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 一般使用auto</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> p = make_shared&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"number\">10</span>, <span class=\"string\">'p'</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>shared_ptr的拷贝和赋值</strong><br>当进行拷贝或者赋值操作时候 shared_ptr都会记录有多少个其他的shared_ptr<br>指向相同的对象<br>引用计数增加的情况</p>\n<ul>\n<li>拷贝shared_ptr </li>\n<li>初始化其他shared_ptr指针</li>\n<li>作为参数传递给一个函数</li>\n<li>作为函数的返回值</li>\n</ul>\n<p>引用计数减少</p>\n<ul>\n<li>赋予新值</li>\n<li>被销毁(例如离开作用域)</li>\n</ul>\n<p>当引用计数为0的时候, 就会释放自己管理的对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> r = make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">42</span>);</span><br><span class=\"line\">r = q; <span class=\"comment\">// 给r赋值, 令他指向另一个地址</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// q原来指向对象的引用计数 递增</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// r 原来指向对象的引用计数 递减</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// r的引用计数 为0 则自动释放</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>使用动态内存的原因</strong></p>\n<ul>\n<li>程序不知道自己需要使用多少对象 容器类</li>\n<li>程序不知道所需对象的准确类型</li>\n<li>程序需要在多个对象间共享数据</li>\n</ul>\n<p><strong>程序需要在多个对象间共享数据</strong><br>一般情况</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v1; <span class=\"comment\">// empty</span></span><br><span class=\"line\">&#123; <span class=\"comment\">// 新的作用域</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v2 = &#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;;</span><br><span class=\"line\">\tv1 = v2;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 离开作用域 v2被销毁</span></span><br><span class=\"line\"><span class=\"comment\">// v1中有三个元素, 是原来三个元素的拷贝</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是我们要实现的情况</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v1; <span class=\"comment\">// empty</span></span><br><span class=\"line\">&#123; <span class=\"comment\">// 新的作用域</span></span><br><span class=\"line\">\t<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; v2 = &#123;<span class=\"string\">\"a\"</span>, <span class=\"string\">\"b\"</span>, <span class=\"string\">\"c\"</span>&#125;;</span><br><span class=\"line\">\tv1 = v2; <span class=\"comment\">// v1 v2共享相同的元素</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 离开作用域 v2被销毁 但v2的元素不能被销毁</span></span><br><span class=\"line\"><span class=\"comment\">// v1中有三个元素, 指向原来三个元素</span></span><br></pre></td></tr></table></figure>\n\n<p>创建一个类来管理这个vector, 但是不能直接保存在其中, 因为当这个类的对象销毁的时候内部的vector也就销毁<br>所以需要保存在动态内存中</p>\n<p>所以使用shared_ptr来管理动态分配的vector, 当最后一个vector的使用者被销毁的时候才释放内存</p>\n<p>确定下这个类提供的操作</p>\n<ul>\n<li>修改元素的操作会进行校验 不合法则抛出异常</li>\n<li>默认构造函数</li>\n<li>接受单一的initiaizer_list&lt;string&gt;类型的参数. 这个参数可以接受一个初始器的花括号列表</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrBlob</span> // 我还去查了下 <span class=\"title\">Blob</span>是二进制数据块...</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">typedef</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt;::size_type size_type;</span><br><span class=\"line\">\tStrBlob();</span><br><span class=\"line\">\tStrBlob(<span class=\"built_in\">std</span>::<span class=\"built_in\">initializer_list</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; il);</span><br><span class=\"line\">\t<span class=\"function\">size_type <span class=\"title\">size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> data_-&gt;<span class=\"built_in\">size</span>();&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> data_-&gt;empty();&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 增删</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">push_back</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;t)</span> </span>&#123;data_-&gt;push_back(t)&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pop_back</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 访问</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; <span class=\"title\">front</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp; <span class=\"title\">back</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt;&gt; data_;</span><br><span class=\"line\">\t<span class=\"comment\">// 如果data[i] 不合法, 抛出一个异常</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">(size_type i, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;msg)</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">StrBlob::StrBlob(): data_(make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;()) &#123;&#125;</span><br><span class=\"line\">StrBlob::StrBlob(<span class=\"built_in\">initializer_list</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; il):</span><br><span class=\"line\">data_(make_shared&lt;<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt;&gt;(il)) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下标检查</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StrBlob::check</span><span class=\"params\">(size_type i, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp;msg)</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (i &gt;= data_-&gt;<span class=\"built_in\">size</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> out_of_range(msg);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">StrBlob::front</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcheck(<span class=\"number\">0</span>, <span class=\"string\">\"front on empty StrBlob\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> data-&gt;front();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span>&amp; <span class=\"title\">StrBlob::back</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcheck(<span class=\"number\">0</span>, <span class=\"string\">\"back on empty StrBlob\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> data-&gt;back();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">StrBlob::pop_back</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcheck(<span class=\"number\">0</span>, <span class=\"string\">\"pop_back on empty StrBlob\"</span>);</span><br><span class=\"line\">\tdata-&gt;pop_back();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>直接管理内存</strong><br>了解到两个概念 一个<code>默认初始化</code>一个<code>值初始化</code></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i, *pi1 = &amp;i, *pi2 = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> *pd = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>(<span class=\"number\">33</span>), *pd2 = pd;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> i; <span class=\"comment\">// 错误 i不是指针</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pi1; <span class=\"comment\">// 未定义 pi1指向一个局部变量 具有潜在性危害</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pd; <span class=\"comment\">// ok</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pd2; <span class=\"comment\">// 未定义 内存已经被释放 具有潜在性危害</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> pi2; <span class=\"comment\">// 正确 释放空指针没有错误</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *pci = <span class=\"keyword\">new</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">delete</span> pci <span class=\"comment\">// 正确 释放一个const对象</span></span><br></pre></td></tr></table></figure>\n<p>delete之后指针就变成了<code>空悬指针</code> 需要将其置为<code>nullptr</code></p>\n<p><strong>shared_ptr和new结合使用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误智能指针构造函数是explicit</span></span><br><span class=\"line\"><span class=\"comment\">// 无法将内置指针隐式转换成一个智能指针, 必须使用直接初始化</span></span><br><span class=\"line\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p1 = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确  使用了直接初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>))</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>定义和改变方式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p管理内置指针q所指向的对象, q必须指向new分配的内存, 且能够转换为T*类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(q)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p从unique_ptr u那里接管了对象的所有权 将U置为空</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(u)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p 接管了内置指针q所指向的对象的所有权, q必须能转化为T* 类型</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p将使用可调用对象d来代替delete</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(q, d)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p是shared_ptr p2的拷贝</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// p将用可调用对象d来代替delete</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;T&gt; <span class=\"title\">p</span><span class=\"params\">(p2, d)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 若p是唯一指向其对象的shared_ptr, reset会释放此对象</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 如果传递了可选的参数-内置指针q, 则会令p指向q 否则将p置为空</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 如果还传递了d, 会调用d而不是delete来释放q</span></span></span><br><span class=\"line\">p.reset()</span><br><span class=\"line\">p.reset(q)</span><br><span class=\"line\">p.reset(q, d)</span><br></pre></td></tr></table></figure>\n\n\n<p>使用unique_ptr的时候要注意</p>\n<ol>\n<li>不要再函数调用传参的括号中 使用临时变量 这样一旦函数调用完成就会被销毁<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; ptr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">42</span> ))</span> </span>; <span class=\"comment\">// 引用 = 1</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(p); <span class=\"comment\">// 拷贝 会递增它的引用计数 ;在 process 中引用计数位为2</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = *p; <span class=\"comment\">// 正确 引用计数为1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> *<span class=\"title\">x</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1024</span>))</span></span>; <span class=\"comment\">// 危险 这是一个普通指针，不是一个智能指针</span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(x) ; <span class=\"comment\">// 错误 不能将 int* 转换为 一个 shared_ptr&lt;int&gt; </span></span><br><span class=\"line\"><span class=\"built_in\">process</span>(<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; (x)); <span class=\"comment\">// 合法的，但内存会被释放! 因为临时对象会被销毁</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> j =*x <span class=\"comment\">//未定义的 是一个空悬指针!</span></span><br></pre></td></tr></table></figure></li>\n<li>如果使用智能指针不要使用get函数初始化另一个智能指针或为其赋值<br>因为一旦新生成的智能指针离开作用域或者被释放, 会影响到原来的智能指针<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>); <span class=\"comment\">// 不能将一个int* 赋值给shared_ptr&lt;int&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p1;</span><br><span class=\"line\">p1.reset(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>)); <span class=\"comment\">// 可以</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>))</span></span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用make_share来创建shared_ptr指针</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; p3 = <span class=\"built_in\">std</span>::make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">auto</span> p4 = <span class=\"built_in\">std</span>::make_shared&lt;<span class=\"keyword\">int</span>&gt;(<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// make_share不能用来创建unique_ptr</span></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; d;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">d1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>))</span></span>;</span><br></pre></td></tr></table></figure>\nunique_ptr不支持普通的赋值和拷贝操作, 因为unique_ptr要独占所指向的对象</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">d1</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">1</span>))</span></span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"built_in\">unique_ptr</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">d2</span> <span class=\"params\">(<span class=\"keyword\">new</span> <span class=\"keyword\">int</span>(<span class=\"number\">8</span>))</span></span>; </span><br><span class=\"line\"></span><br><span class=\"line\">d1.<span class=\"built_in\">release</span>(); <span class=\"comment\">// 释放原来所指向的对象</span></span><br><span class=\"line\">d1.reset(d2.<span class=\"built_in\">release</span>()); <span class=\"comment\">// d2释放后由d1获取</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>智能指针陷阱</strong></p>\n<ol>\n<li>不使用相同的内置指针值初始化(或reset)多个智能指针</li>\n<li>不使用delete get返回的指针</li>\n<li>不使用get初始化或者reset另一个智能指针</li>\n<li>如果你使用get返回指针, 当最后一个对应的智能指针销毁 这个指针就变成了垂悬指针</li>\n<li>使用智能指针管理非new分配的内存, 需要传递一个删除器.</li>\n</ol>\n<p><strong>weak_ptr</strong><br>不控制所指向对象生存周期, 指向一个shared_ptr管理的对象.</p>\n<table>\n<thead>\n<tr>\n<th>表示</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>weak_ptr/<T> w</td>\n<td>空格weak_ptr可以指向类型为T的对象</td>\n</tr>\n<tr>\n<td>weak_ptr/<T> w(sp)</td>\n<td>与shared_ptr sp智能指针指向相同的对象, 但引用计数不增加</td>\n</tr>\n<tr>\n<td>w = p</td>\n<td>p可以是shared_ptr或者weak_ptr, 赋值后w与p共享对象</td>\n</tr>\n<tr>\n<td>w.reset()</td>\n<td></td>\n</tr>\n<tr>\n<td>w.use_count()</td>\n<td>与w共享对象的shared_ptr的数量</td>\n</tr>\n<tr>\n<td>w.expire()</td>\n<td>return w.use_count() == 0;</td>\n</tr>\n<tr>\n<td>w.lock()</td>\n<td>如果expire为true返回一个空的 sp 否则返回指向w对象的sp</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StrBlobPtr</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tStrBlobPtr():curr(<span class=\"number\">0</span>) &#123;&#125;</span><br><span class=\"line\">\tStrBlobPtr(StrBlob &amp;a, <span class=\"keyword\">size_t</span> sz = <span class=\"number\">0</span>):</span><br><span class=\"line\">\t\twptr(a.data), curr(sz) &#123;&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">std</span>::sting&amp; <span class=\"title\">deref</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">\t<span class=\"function\">StrBlobPtr&amp; <span class=\"title\">incr</span><span class=\"params\">()</span></span>; <span class=\"comment\">// 前缀自增</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt;&gt;</span><br><span class=\"line\">\t\tcheck(<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span>, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&amp;) <span class=\"keyword\">const</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::weak_ptr&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt;&gt; wptr;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> curr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">shared_ptr</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt;&gt;</span><br><span class=\"line\">\tcheck(<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> i, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;msg) <span class=\"keyword\">const</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> ret = wptr.lock() <span class=\"comment\">// 判断vector是否还存在</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ret)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::runtime_error(<span class=\"string\">\"unbond StrBlobPtr\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (i &gt;= ret-&gt;<span class=\"built_in\">size</span>())</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"built_in\">std</span>::out_of_range(msg);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于weak_ptr不参与对应的shared_ptr的引用计数, vector可能已经被释放了<br>释放后 lock将返回一个空指针</p>\n<h1 id=\"模板与泛型编程\"><a href=\"#模板与泛型编程\" class=\"headerlink\" title=\"模板与泛型编程\"></a>模板与泛型编程</h1><p><code>template &lt;typename T&gt;</code></p>\n<p>编译器用推断出的模板参数来<code>实例化</code>一个特定版本的函数.<br>不同的模板参数类型<code>实例化</code>出不同的函数 然后进行调用.</p>\n<p><strong>模板类型参数</strong></p>\n<p>如果有多个模板参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, U&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> U&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">U</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>非类型模板参数</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">unsigned</span> N, <span class=\"keyword\">unsigned</span> M&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p1)[N], <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p2)[M])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">strcmp</span>(p1, p2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">compare(<span class=\"string\">\"hi\"</span>, <span class=\"string\">\"mmm\"</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p1)[<span class=\"number\">3</span>], <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> (&amp;p2)[<span class=\"number\">4</span>])</span> <span class=\"comment\">// 注意空字符</span></span></span><br></pre></td></tr></table></figure>\n<p>编译器会使用字面常量的大小来代替N和M, 从而实例化模板</p>\n<p>非类型参数可以使<code>整形</code>或者是一个指向对象或者函数类型的<code>指针</code>或者<code>(左值)引用</code><br>绑定到<code>非类型整数参数</code>的实参必须是一个常量表达式.<br>绑定到<code>指针</code>或者<code>引用非类型模板参数</code>的实参必须具有静态的生存期</p>\n<p>静态内存用来保存<code>局部static对象</code>, <code>类static数据成员</code>和<code>定义于任何函数之外的变量</code><br>栈内存用来保存定义在函数内的非static对象.<br>分配在静态内存和栈内存的由编译器自动创建和销毁</p>\n<p>堆 用来存储动态分配的对象</p>\n<p>编译器遇到一个模板类型定义的时候并不会生成代码, 而是实例化出一个特定版本的时候才会实例化</p>\n"},{"title":"UNP卷二读书记录","date":"2020-03-15T03:16:20.000Z","top":115,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/UNP%E5%8D%B7%E4%BA%8C%E5%B0%81%E9%9D%A2.png","_content":"\n# 消息传递\n## 管道和有名管道FIFO\n\n**popen pclose**\n```c++\n#include <stdio.h>\n// 成功返回文件指针, 出错为NULL\nFILE* popen(const char *command, const char *type);\nFILE* fp = popen(command, \"r\");\n\n// 成功为shell终止状态, 出错则为 -1\nint pclose(FILE *stream);\npclose(fp);\n```\npopen创建一个管道并启动另外一个进程 创建者要么从管道读出标准输入, 要么将标准输出写到管道\n返回的文件指针作用\n通过type参数控制\ntype = \"r\" 创建者 通过文件指针读入command命令产生的标准输出\ntype = \"w\" 创建者 通过文件指针为command命令提供标准输入\n\npclose 关闭这个标准IO流\n\n\n**FIFO 先进先出(first in, first out)**\n\n又称为有名管道(named pipe) 单向(半双工)数据流, 每个FIFO都有一个路径名与之对应. \n从而允许无亲缘关系的进程访问同一个FIFO\n\n```c++\n#include <sys/types.h>\n#include <sys/stat.h>\n\n// 成功返回 0 失败返回 -1\nint mkfifo(const char *pathname, mode_t mode);\n\nconst char FIFO1 = \"/tmp/fifo.1\";\nmkfifo(FIFO1, 0666);\n\n// 创建之后需要打开来进行读或者写 可以使用open也可以使用其他标准IO打开函数\nint writefd = open(FIFO1, O_WRONLY, 0); /* 在父进程中打开 父进程写 */\nint readfd = open(FIFO1, O_RDONLY, 0); /* 在子进程中打开 子进程读 */\n\n// 只有调用unlink才能从文件系统删除文件名字\nunlink(FIFO1);\n```\nmkfifo 隐含已经指定 O_CREAT | O_EXCL\n要么不存在创建一个新的, 要么返回 errno=EEXIST(所指定名字的FIFO已经存在)\n\n如果想要打开已经存在的FIFO可以使用open函数.\n可以判断 如果返回-1 并且errno=EEXIST 就调用open函数打开\n\n\n```c++\n// 子进程\nreadfd = open(FIFO1, O_RDONLY, 0);\nwritefd = open(FIFO2, O_WRONLY, 0);\n\n// 父进程\nwritefd = open(FIFO1, O_WRONLY, 0);\nreadfd = open(FIFO2, O_RDONLY, 0);\n\n// 父进程 这样会阻塞\nreadfd = open(FIFO2, O_RDONLY, 0);\nwritefd = open(FIFO1, O_WRONLY, 0);\n```\n如果调换父进程的两行代码 程序就会进入死锁\n因为如果当前没有任何进程`打开某个FIFO来写`, 打开这个`FIFO来读`的进程将会`阻塞`\n\n\n当对一个管道或者FIFO的最终close发生的时候, 该管道或FIFO中的任何残余数据都将被丢弃\n\n\n即使在A主机上能够访问到B主机的目录, 即使不同主机上的两个进程都能够通过NFS打开同一个FIFO\n他们之间也不能通过FIFO从一个进程到另一个进程发送数据\n\n拒绝服务型攻击Dos\n如果是单进程可能会让服务器处于阻塞状态, 多进程也可能会由于一个恶意客户发送大量独立请求\n导致服务器子进程数达到上限, 使得后续的fork失败\n\n\n**其他**\n从字节流中获取完整的单个信息\n- 带特殊终止序列\n许多UNIX应用使用换行分割 因特尔应用程序使用回车符加上一个换行符\n- 显式长度\n将长度增加在请求中\n- 每次连接一个记录\n应用通过关闭对端连接指示一个记录结束. HTTP1.0使用的这一技术\n\n标准IO函数fdopen可以将标准IO流与pipe返回的文件描述符相关联'\n\n\n**限制**\n系统加在管道和FIFO的唯一限制是\n- OPEN_MAX\n一个进程在任意时刻打开的最大描述符数量 >=16\n- PIPE_BUF\n可以原子性的写入一个管道或FIFO的最大数据量 >= 512\n\n\n**习题练习**\n1. 父进程终止的时候, 如果子进程的fd[1]仍处于打开状态, 则子进程对fd[0]的read 不会返回文件结束符,\n因为fd[1]虽然在父进程中关闭了, 但是在子进程中依然打开. 如果关闭子进程fd[1], 则父进程一旦关闭, \n他的所有文件描述符即关闭, 子进程对fd[0]的read就会返回0.(想到了自己写的服务器, 客户端断开连接就会read出一个0长度的内容)\n2. 从 不存在即创建, 存在->打开 变成 存在->打开, 不存在即创建. 可能会在open打开失败后 创建fifo之前\n被其他进程抢先创建fifo, 导致本进程的mkfifo调用失败\n3. 出错信息写到了标准错误输出\n5. 可以把第一个open调用设置成非阻塞, 但是为了避免readline返回错误, 标志必须在readline之前去除\n6. 死锁\n7. 读进程关闭管道或者FIFO后给写进程一个信号(往关闭的管道写会产生SIGPIPE信号),\n写进程关闭管道或者FIFO后将文件结束符发送给读进程(读进程读到长度为0的文件结束符)\n\n\n## POSIX消息队列\n\n**mqueue创建和删除**\n```c++\n#include <mqueue.h>\n\n// oflag O_RDONLY O_WRONLY O_RDWR 可以加上O_CREAT和O_EXCL或者O_NONBLOCK\n// 创建一个新队列的时候(制定了O_CREAT且消息队列不存在)后两个参数都需要\n// 权限位 和 指定某些属性 nullptr则使用默认属性\n\n// 成功返回消息队列 fd 失败 -1\nmqd_t mq_open(const char *name, int oflag,\n /*mode_t mode, struct mq_attr *attr*/);\n```\n注意\n消息队列文件描述符不必是(而且很可能不是)像文件描述符或者socket文件描述符那样的短整数\n\n```c++\n// 关闭消息队列 引用计数 -1\nint mq_close(mqd_t mqdes);\n```\n类似close函数, 调用进程可以不再使用该文件描述符, 但是其消息队列并不会从系统中删除\n\n当一个进程终止的时候, 所有打开着的消息队列都将关闭, 就像自动调用了mq_close\n\n\n如果要从系统中删除`mq_open`第一个参数`name` 必须调用下面的函数\n```c++\n// 引用计数 -1\nint mq_unlink(const char *name);\n```\n\n每个消息队列有一个保存着当前打开描述符数的引用计数器\n\n当消息队列的引用计数仍大于0时, 其name就能删除\n但是队列的析构会在`引用计数为0`的时候自动析构.\n\n\n第一个demo敲完之后 一直是errno=13.\n在`man mq_overview`\n```\nOn Linux, message queues are created in a virtual filesystem.   (Other  implementa‐\ntions may also provide such a feature, but the details are likely to differ.)  This\nfilesystem can be mounted (by the superuser) using the following commands:\n\n# mkdir /dev/mqueue\n# mount -t mqueue none /dev/mqueue\n\nThe sticky bit is automatically enabled on the mount directory.\n```\n而且 name参数的格式是`/somename` 这个是相对挂载目录的\n\n\n**属性设置**\n```c++\nstruct mq_attr\n{\n    long mq_flags; /* 0, O_NONBLOCK */\n    long mq_maxmsg; /* max number */\n    long mq_msgsize; /* max size of a msg in bytes */\n    long mq_curmsgs; /* number of message currently on queue */\n}\n\nint mq_getattr(mqd_t mqdes, struct mq_attr *attr);\n\n// set 的时候 只有mq_attr中的mq_flags起作用 设置取消O_NONBLOCK\n// 最大消息数和最大字节数 只能在创建队列的时候设置\n// 队列中房钱消息数 只能获取不能设置\n// 第三个参数 不为nullptr则返回之前的属性\nint mq_setattr(mqd_t mqdes, const struct mq_attr *attr, struct mq_attr *oattr);\n```\n\n**发送接收信息**\n```c++\n// prio 优先级 必须 <= MQ_PRIO_MAX\nint mq_send(mqd_t mqdes, const char *ptr, size_t len, unsigned int prio);\n\n// len 必须 >= mq_attr.mq_msgsize 如果小于则 errno = EMSGSIZE\nssize_t mq_receive(mqd_t mqdes, const char *ptr, size_t len, unsigned int *priop);\n```\n如果不使用优先级 发送的时候可以将 mq_send的 prio 设置为0\n接受的时候 mq_receive priop 设置为 nullptr\n\n\n**消息队列的限制**\n- mq_maxmsg 队列中最大消息数\n- mq_msgsize单个消息的最大字节\n- MQ_OPEN_MAX 一个进程同时打开消息队列的最大数目\n- MQ_PRIO_MAX 最大优先级+1\n\n**异步事件通知**\n- 产生信号\n- 创建一个线程执行一个指定的函数\n\n```c++\n// 为指定队列建立或者删除异步事件通知.\n\n// 成功返回 0 失败返回 -1\nint mq_notify(mqd_t mqdes, struct sigevent *nofification);\n\nstruct sigval\n{\n    int sival_int;\n    void *sival_ptr;\n}\n\nstruct sigevent\n{\n    int sigev_notify; // SIGEV_NONE SIGEV_SIGNAL SIGEV_THREAD\n    int sigev_signo; // signal number if SIGEV_SIGNAL\n    union sigval sigev_value; // passed to signal handler pr thread\n    // 下面两个用于 SIGEV_THREAD\n    void (*sigev_notify_function)(union sigval);\n    pthread_attr_t *sigev_notify_attributes;\n}\n```\n1. 如果 notification != nullptr\n当前进程希望 在有一个消息 到达所指定的 先前为空的队列 时得到通知\n我们说 该进程被注册为接收该队列的通知\n\n2. 如果 notification == nullptr\n如果 该进程被注册为 接受所指定队列通知 则取消它\n\n3. 任何时刻只有一个进程可以被注册为 接收某个队列的通知\n4. 当一个消息到达某个空队列, 而且已经注册, 那么只有当\n没有因为调用mq_reveive导致的阻塞 的时候才会发出通知\n5. 通知发出后 注册立即被撤销.. 需要重新注册???\n\nUnix信号产生后会复位成默认行为.\n信号处理程序通常第一个调用signal函数, 用于重新建立处理程序\n这时会产生一个空窗时期(信号产生 与 当前进程重建信号处理程序之间)\n空窗时期再次产生同一信号 可能终止当前进程\n\n初看起来, mq_notify可能也有这个问题.\n不过在消息队列`为空前` `通知不会再次产生`\n所以不要在`读出消息后`重新注册\n而应该在`读出消息前`重新注册\n\n\n`volatile sig_atomic_t mqflag = 0;`\nsig_atomic_t 即使缺少信号所做的异步中断，亦能作为原子实体访问的整数类型。\nvolatile 标记可能会随时改变","source":"_posts/CPP-读书记录115-UNP卷二.md","raw":"---\ntitle: UNP卷二读书记录\ndate: 2020-03-15 11:16:20\ntags:\ncategories:\n - CPP\n - 服务器编程-书籍记录\ntop: 115\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/UNP%E5%8D%B7%E4%BA%8C%E5%B0%81%E9%9D%A2.png\n---\n\n# 消息传递\n## 管道和有名管道FIFO\n\n**popen pclose**\n```c++\n#include <stdio.h>\n// 成功返回文件指针, 出错为NULL\nFILE* popen(const char *command, const char *type);\nFILE* fp = popen(command, \"r\");\n\n// 成功为shell终止状态, 出错则为 -1\nint pclose(FILE *stream);\npclose(fp);\n```\npopen创建一个管道并启动另外一个进程 创建者要么从管道读出标准输入, 要么将标准输出写到管道\n返回的文件指针作用\n通过type参数控制\ntype = \"r\" 创建者 通过文件指针读入command命令产生的标准输出\ntype = \"w\" 创建者 通过文件指针为command命令提供标准输入\n\npclose 关闭这个标准IO流\n\n\n**FIFO 先进先出(first in, first out)**\n\n又称为有名管道(named pipe) 单向(半双工)数据流, 每个FIFO都有一个路径名与之对应. \n从而允许无亲缘关系的进程访问同一个FIFO\n\n```c++\n#include <sys/types.h>\n#include <sys/stat.h>\n\n// 成功返回 0 失败返回 -1\nint mkfifo(const char *pathname, mode_t mode);\n\nconst char FIFO1 = \"/tmp/fifo.1\";\nmkfifo(FIFO1, 0666);\n\n// 创建之后需要打开来进行读或者写 可以使用open也可以使用其他标准IO打开函数\nint writefd = open(FIFO1, O_WRONLY, 0); /* 在父进程中打开 父进程写 */\nint readfd = open(FIFO1, O_RDONLY, 0); /* 在子进程中打开 子进程读 */\n\n// 只有调用unlink才能从文件系统删除文件名字\nunlink(FIFO1);\n```\nmkfifo 隐含已经指定 O_CREAT | O_EXCL\n要么不存在创建一个新的, 要么返回 errno=EEXIST(所指定名字的FIFO已经存在)\n\n如果想要打开已经存在的FIFO可以使用open函数.\n可以判断 如果返回-1 并且errno=EEXIST 就调用open函数打开\n\n\n```c++\n// 子进程\nreadfd = open(FIFO1, O_RDONLY, 0);\nwritefd = open(FIFO2, O_WRONLY, 0);\n\n// 父进程\nwritefd = open(FIFO1, O_WRONLY, 0);\nreadfd = open(FIFO2, O_RDONLY, 0);\n\n// 父进程 这样会阻塞\nreadfd = open(FIFO2, O_RDONLY, 0);\nwritefd = open(FIFO1, O_WRONLY, 0);\n```\n如果调换父进程的两行代码 程序就会进入死锁\n因为如果当前没有任何进程`打开某个FIFO来写`, 打开这个`FIFO来读`的进程将会`阻塞`\n\n\n当对一个管道或者FIFO的最终close发生的时候, 该管道或FIFO中的任何残余数据都将被丢弃\n\n\n即使在A主机上能够访问到B主机的目录, 即使不同主机上的两个进程都能够通过NFS打开同一个FIFO\n他们之间也不能通过FIFO从一个进程到另一个进程发送数据\n\n拒绝服务型攻击Dos\n如果是单进程可能会让服务器处于阻塞状态, 多进程也可能会由于一个恶意客户发送大量独立请求\n导致服务器子进程数达到上限, 使得后续的fork失败\n\n\n**其他**\n从字节流中获取完整的单个信息\n- 带特殊终止序列\n许多UNIX应用使用换行分割 因特尔应用程序使用回车符加上一个换行符\n- 显式长度\n将长度增加在请求中\n- 每次连接一个记录\n应用通过关闭对端连接指示一个记录结束. HTTP1.0使用的这一技术\n\n标准IO函数fdopen可以将标准IO流与pipe返回的文件描述符相关联'\n\n\n**限制**\n系统加在管道和FIFO的唯一限制是\n- OPEN_MAX\n一个进程在任意时刻打开的最大描述符数量 >=16\n- PIPE_BUF\n可以原子性的写入一个管道或FIFO的最大数据量 >= 512\n\n\n**习题练习**\n1. 父进程终止的时候, 如果子进程的fd[1]仍处于打开状态, 则子进程对fd[0]的read 不会返回文件结束符,\n因为fd[1]虽然在父进程中关闭了, 但是在子进程中依然打开. 如果关闭子进程fd[1], 则父进程一旦关闭, \n他的所有文件描述符即关闭, 子进程对fd[0]的read就会返回0.(想到了自己写的服务器, 客户端断开连接就会read出一个0长度的内容)\n2. 从 不存在即创建, 存在->打开 变成 存在->打开, 不存在即创建. 可能会在open打开失败后 创建fifo之前\n被其他进程抢先创建fifo, 导致本进程的mkfifo调用失败\n3. 出错信息写到了标准错误输出\n5. 可以把第一个open调用设置成非阻塞, 但是为了避免readline返回错误, 标志必须在readline之前去除\n6. 死锁\n7. 读进程关闭管道或者FIFO后给写进程一个信号(往关闭的管道写会产生SIGPIPE信号),\n写进程关闭管道或者FIFO后将文件结束符发送给读进程(读进程读到长度为0的文件结束符)\n\n\n## POSIX消息队列\n\n**mqueue创建和删除**\n```c++\n#include <mqueue.h>\n\n// oflag O_RDONLY O_WRONLY O_RDWR 可以加上O_CREAT和O_EXCL或者O_NONBLOCK\n// 创建一个新队列的时候(制定了O_CREAT且消息队列不存在)后两个参数都需要\n// 权限位 和 指定某些属性 nullptr则使用默认属性\n\n// 成功返回消息队列 fd 失败 -1\nmqd_t mq_open(const char *name, int oflag,\n /*mode_t mode, struct mq_attr *attr*/);\n```\n注意\n消息队列文件描述符不必是(而且很可能不是)像文件描述符或者socket文件描述符那样的短整数\n\n```c++\n// 关闭消息队列 引用计数 -1\nint mq_close(mqd_t mqdes);\n```\n类似close函数, 调用进程可以不再使用该文件描述符, 但是其消息队列并不会从系统中删除\n\n当一个进程终止的时候, 所有打开着的消息队列都将关闭, 就像自动调用了mq_close\n\n\n如果要从系统中删除`mq_open`第一个参数`name` 必须调用下面的函数\n```c++\n// 引用计数 -1\nint mq_unlink(const char *name);\n```\n\n每个消息队列有一个保存着当前打开描述符数的引用计数器\n\n当消息队列的引用计数仍大于0时, 其name就能删除\n但是队列的析构会在`引用计数为0`的时候自动析构.\n\n\n第一个demo敲完之后 一直是errno=13.\n在`man mq_overview`\n```\nOn Linux, message queues are created in a virtual filesystem.   (Other  implementa‐\ntions may also provide such a feature, but the details are likely to differ.)  This\nfilesystem can be mounted (by the superuser) using the following commands:\n\n# mkdir /dev/mqueue\n# mount -t mqueue none /dev/mqueue\n\nThe sticky bit is automatically enabled on the mount directory.\n```\n而且 name参数的格式是`/somename` 这个是相对挂载目录的\n\n\n**属性设置**\n```c++\nstruct mq_attr\n{\n    long mq_flags; /* 0, O_NONBLOCK */\n    long mq_maxmsg; /* max number */\n    long mq_msgsize; /* max size of a msg in bytes */\n    long mq_curmsgs; /* number of message currently on queue */\n}\n\nint mq_getattr(mqd_t mqdes, struct mq_attr *attr);\n\n// set 的时候 只有mq_attr中的mq_flags起作用 设置取消O_NONBLOCK\n// 最大消息数和最大字节数 只能在创建队列的时候设置\n// 队列中房钱消息数 只能获取不能设置\n// 第三个参数 不为nullptr则返回之前的属性\nint mq_setattr(mqd_t mqdes, const struct mq_attr *attr, struct mq_attr *oattr);\n```\n\n**发送接收信息**\n```c++\n// prio 优先级 必须 <= MQ_PRIO_MAX\nint mq_send(mqd_t mqdes, const char *ptr, size_t len, unsigned int prio);\n\n// len 必须 >= mq_attr.mq_msgsize 如果小于则 errno = EMSGSIZE\nssize_t mq_receive(mqd_t mqdes, const char *ptr, size_t len, unsigned int *priop);\n```\n如果不使用优先级 发送的时候可以将 mq_send的 prio 设置为0\n接受的时候 mq_receive priop 设置为 nullptr\n\n\n**消息队列的限制**\n- mq_maxmsg 队列中最大消息数\n- mq_msgsize单个消息的最大字节\n- MQ_OPEN_MAX 一个进程同时打开消息队列的最大数目\n- MQ_PRIO_MAX 最大优先级+1\n\n**异步事件通知**\n- 产生信号\n- 创建一个线程执行一个指定的函数\n\n```c++\n// 为指定队列建立或者删除异步事件通知.\n\n// 成功返回 0 失败返回 -1\nint mq_notify(mqd_t mqdes, struct sigevent *nofification);\n\nstruct sigval\n{\n    int sival_int;\n    void *sival_ptr;\n}\n\nstruct sigevent\n{\n    int sigev_notify; // SIGEV_NONE SIGEV_SIGNAL SIGEV_THREAD\n    int sigev_signo; // signal number if SIGEV_SIGNAL\n    union sigval sigev_value; // passed to signal handler pr thread\n    // 下面两个用于 SIGEV_THREAD\n    void (*sigev_notify_function)(union sigval);\n    pthread_attr_t *sigev_notify_attributes;\n}\n```\n1. 如果 notification != nullptr\n当前进程希望 在有一个消息 到达所指定的 先前为空的队列 时得到通知\n我们说 该进程被注册为接收该队列的通知\n\n2. 如果 notification == nullptr\n如果 该进程被注册为 接受所指定队列通知 则取消它\n\n3. 任何时刻只有一个进程可以被注册为 接收某个队列的通知\n4. 当一个消息到达某个空队列, 而且已经注册, 那么只有当\n没有因为调用mq_reveive导致的阻塞 的时候才会发出通知\n5. 通知发出后 注册立即被撤销.. 需要重新注册???\n\nUnix信号产生后会复位成默认行为.\n信号处理程序通常第一个调用signal函数, 用于重新建立处理程序\n这时会产生一个空窗时期(信号产生 与 当前进程重建信号处理程序之间)\n空窗时期再次产生同一信号 可能终止当前进程\n\n初看起来, mq_notify可能也有这个问题.\n不过在消息队列`为空前` `通知不会再次产生`\n所以不要在`读出消息后`重新注册\n而应该在`读出消息前`重新注册\n\n\n`volatile sig_atomic_t mqflag = 0;`\nsig_atomic_t 即使缺少信号所做的异步中断，亦能作为原子实体访问的整数类型。\nvolatile 标记可能会随时改变","slug":"CPP-读书记录115-UNP卷二","published":1,"updated":"2020-03-20T15:19:49.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucv100148cuohr5m0z61","content":"<h1 id=\"消息传递\"><a href=\"#消息传递\" class=\"headerlink\" title=\"消息传递\"></a>消息传递</h1><h2 id=\"管道和有名管道FIFO\"><a href=\"#管道和有名管道FIFO\" class=\"headerlink\" title=\"管道和有名管道FIFO\"></a>管道和有名管道FIFO</h2><p><strong>popen pclose</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回文件指针, 出错为NULL</span></span><br><span class=\"line\"><span class=\"function\">FILE* <span class=\"title\">popen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *command, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *type)</span></span>;</span><br><span class=\"line\">FILE* fp = popen(command, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功为shell终止状态, 出错则为 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pclose</span><span class=\"params\">(FILE *stream)</span></span>;</span><br><span class=\"line\">pclose(fp);</span><br></pre></td></tr></table></figure>\n<p>popen创建一个管道并启动另外一个进程 创建者要么从管道读出标准输入, 要么将标准输出写到管道<br>返回的文件指针作用<br>通过type参数控制<br>type = “r” 创建者 通过文件指针读入command命令产生的标准输出<br>type = “w” 创建者 通过文件指针为command命令提供标准输入</p>\n<p>pclose 关闭这个标准IO流</p>\n<p><strong>FIFO 先进先出(first in, first out)</strong></p>\n<p>又称为有名管道(named pipe) 单向(半双工)数据流, 每个FIFO都有一个路径名与之对应.<br>从而允许无亲缘关系的进程访问同一个FIFO</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功返回 0 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mkfifo</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">mode_t</span> mode)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> FIFO1 = <span class=\"string\">\"/tmp/fifo.1\"</span>;</span><br><span class=\"line\">mkfifo(FIFO1, <span class=\"number\">0666</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建之后需要打开来进行读或者写 可以使用open也可以使用其他标准IO打开函数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> writefd = <span class=\"built_in\">open</span>(FIFO1, O_WRONLY, <span class=\"number\">0</span>); <span class=\"comment\">/* 在父进程中打开 父进程写 */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> readfd = <span class=\"built_in\">open</span>(FIFO1, O_RDONLY, <span class=\"number\">0</span>); <span class=\"comment\">/* 在子进程中打开 子进程读 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只有调用unlink才能从文件系统删除文件名字</span></span><br><span class=\"line\">unlink(FIFO1);</span><br></pre></td></tr></table></figure>\n<p>mkfifo 隐含已经指定 O_CREAT | O_EXCL<br>要么不存在创建一个新的, 要么返回 errno=EEXIST(所指定名字的FIFO已经存在)</p>\n<p>如果想要打开已经存在的FIFO可以使用open函数.<br>可以判断 如果返回-1 并且errno=EEXIST 就调用open函数打开</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 子进程</span></span><br><span class=\"line\">readfd = <span class=\"built_in\">open</span>(FIFO1, O_RDONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\">writefd = <span class=\"built_in\">open</span>(FIFO2, O_WRONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父进程</span></span><br><span class=\"line\">writefd = <span class=\"built_in\">open</span>(FIFO1, O_WRONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\">readfd = <span class=\"built_in\">open</span>(FIFO2, O_RDONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父进程 这样会阻塞</span></span><br><span class=\"line\">readfd = <span class=\"built_in\">open</span>(FIFO2, O_RDONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\">writefd = <span class=\"built_in\">open</span>(FIFO1, O_WRONLY, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>如果调换父进程的两行代码 程序就会进入死锁<br>因为如果当前没有任何进程<code>打开某个FIFO来写</code>, 打开这个<code>FIFO来读</code>的进程将会<code>阻塞</code></p>\n<p>当对一个管道或者FIFO的最终close发生的时候, 该管道或FIFO中的任何残余数据都将被丢弃</p>\n<p>即使在A主机上能够访问到B主机的目录, 即使不同主机上的两个进程都能够通过NFS打开同一个FIFO<br>他们之间也不能通过FIFO从一个进程到另一个进程发送数据</p>\n<p>拒绝服务型攻击Dos<br>如果是单进程可能会让服务器处于阻塞状态, 多进程也可能会由于一个恶意客户发送大量独立请求<br>导致服务器子进程数达到上限, 使得后续的fork失败</p>\n<p><strong>其他</strong><br>从字节流中获取完整的单个信息</p>\n<ul>\n<li>带特殊终止序列<br>许多UNIX应用使用换行分割 因特尔应用程序使用回车符加上一个换行符</li>\n<li>显式长度<br>将长度增加在请求中</li>\n<li>每次连接一个记录<br>应用通过关闭对端连接指示一个记录结束. HTTP1.0使用的这一技术</li>\n</ul>\n<p>标准IO函数fdopen可以将标准IO流与pipe返回的文件描述符相关联’</p>\n<p><strong>限制</strong><br>系统加在管道和FIFO的唯一限制是</p>\n<ul>\n<li>OPEN_MAX<br>一个进程在任意时刻打开的最大描述符数量 &gt;=16</li>\n<li>PIPE_BUF<br>可以原子性的写入一个管道或FIFO的最大数据量 &gt;= 512</li>\n</ul>\n<p><strong>习题练习</strong></p>\n<ol>\n<li>父进程终止的时候, 如果子进程的fd[1]仍处于打开状态, 则子进程对fd[0]的read 不会返回文件结束符,<br>因为fd[1]虽然在父进程中关闭了, 但是在子进程中依然打开. 如果关闭子进程fd[1], 则父进程一旦关闭,<br>他的所有文件描述符即关闭, 子进程对fd[0]的read就会返回0.(想到了自己写的服务器, 客户端断开连接就会read出一个0长度的内容)</li>\n<li>从 不存在即创建, 存在-&gt;打开 变成 存在-&gt;打开, 不存在即创建. 可能会在open打开失败后 创建fifo之前<br>被其他进程抢先创建fifo, 导致本进程的mkfifo调用失败</li>\n<li>出错信息写到了标准错误输出</li>\n<li>可以把第一个open调用设置成非阻塞, 但是为了避免readline返回错误, 标志必须在readline之前去除</li>\n<li>死锁</li>\n<li>读进程关闭管道或者FIFO后给写进程一个信号(往关闭的管道写会产生SIGPIPE信号),<br>写进程关闭管道或者FIFO后将文件结束符发送给读进程(读进程读到长度为0的文件结束符)</li>\n</ol>\n<h2 id=\"POSIX消息队列\"><a href=\"#POSIX消息队列\" class=\"headerlink\" title=\"POSIX消息队列\"></a>POSIX消息队列</h2><p><strong>mqueue创建和删除</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mqueue.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// oflag O_RDONLY O_WRONLY O_RDWR 可以加上O_CREAT和O_EXCL或者O_NONBLOCK</span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个新队列的时候(制定了O_CREAT且消息队列不存在)后两个参数都需要</span></span><br><span class=\"line\"><span class=\"comment\">// 权限位 和 指定某些属性 nullptr则使用默认属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功返回消息队列 fd 失败 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">mqd_t</span> <span class=\"title\">mq_open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">int</span> oflag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"> <span class=\"comment\">/*mode_t mode, struct mq_attr *attr*/</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>注意<br>消息队列文件描述符不必是(而且很可能不是)像文件描述符或者socket文件描述符那样的短整数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关闭消息队列 引用计数 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_close</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>类似close函数, 调用进程可以不再使用该文件描述符, 但是其消息队列并不会从系统中删除</p>\n<p>当一个进程终止的时候, 所有打开着的消息队列都将关闭, 就像自动调用了mq_close</p>\n<p>如果要从系统中删除<code>mq_open</code>第一个参数<code>name</code> 必须调用下面的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引用计数 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_unlink</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>每个消息队列有一个保存着当前打开描述符数的引用计数器</p>\n<p>当消息队列的引用计数仍大于0时, 其name就能删除<br>但是队列的析构会在<code>引用计数为0</code>的时候自动析构.</p>\n<p>第一个demo敲完之后 一直是errno=13.<br>在<code>man mq_overview</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">On Linux, message queues are created in a virtual filesystem.   (Other  implementa‐</span><br><span class=\"line\">tions may also provide such a feature, but the details are likely to differ.)  This</span><br><span class=\"line\">filesystem can be mounted (by the superuser) using the following commands:</span><br><span class=\"line\"></span><br><span class=\"line\"># mkdir &#x2F;dev&#x2F;mqueue</span><br><span class=\"line\"># mount -t mqueue none &#x2F;dev&#x2F;mqueue</span><br><span class=\"line\"></span><br><span class=\"line\">The sticky bit is automatically enabled on the mount directory.</span><br></pre></td></tr></table></figure>\n<p>而且 name参数的格式是<code>/somename</code> 这个是相对挂载目录的</p>\n<p><strong>属性设置</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mq_attr</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_flags; <span class=\"comment\">/* 0, O_NONBLOCK */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_maxmsg; <span class=\"comment\">/* max number */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_msgsize; <span class=\"comment\">/* max size of a msg in bytes */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_curmsgs; <span class=\"comment\">/* number of message currently on queue */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_getattr</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, struct mq_attr *attr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// set 的时候 只有mq_attr中的mq_flags起作用 设置取消O_NONBLOCK</span></span><br><span class=\"line\"><span class=\"comment\">// 最大消息数和最大字节数 只能在创建队列的时候设置</span></span><br><span class=\"line\"><span class=\"comment\">// 队列中房钱消息数 只能获取不能设置</span></span><br><span class=\"line\"><span class=\"comment\">// 第三个参数 不为nullptr则返回之前的属性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_setattr</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, <span class=\"keyword\">const</span> struct mq_attr *attr, struct mq_attr *oattr)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>发送接收信息</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// prio 优先级 必须 &lt;= MQ_PRIO_MAX</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_send</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *ptr, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> prio)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// len 必须 &gt;= mq_attr.mq_msgsize 如果小于则 errno = EMSGSIZE</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">mq_receive</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *ptr, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *priop)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>如果不使用优先级 发送的时候可以将 mq_send的 prio 设置为0<br>接受的时候 mq_receive priop 设置为 nullptr</p>\n<p><strong>消息队列的限制</strong></p>\n<ul>\n<li>mq_maxmsg 队列中最大消息数</li>\n<li>mq_msgsize单个消息的最大字节</li>\n<li>MQ_OPEN_MAX 一个进程同时打开消息队列的最大数目</li>\n<li>MQ_PRIO_MAX 最大优先级+1</li>\n</ul>\n<p><strong>异步事件通知</strong></p>\n<ul>\n<li>产生信号</li>\n<li>创建一个线程执行一个指定的函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为指定队列建立或者删除异步事件通知.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功返回 0 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_notify</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, struct sigevent *nofification)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigval</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sival_int;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *sival_ptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigevent</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sigev_notify; <span class=\"comment\">// SIGEV_NONE SIGEV_SIGNAL SIGEV_THREAD</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sigev_signo; <span class=\"comment\">// signal number if SIGEV_SIGNAL</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> sigval sigev_value; <span class=\"comment\">// passed to signal handler pr thread</span></span><br><span class=\"line\">    <span class=\"comment\">// 下面两个用于 SIGEV_THREAD</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*sigev_notify_function)(<span class=\"keyword\">union</span> sigval);</span><br><span class=\"line\">    <span class=\"keyword\">pthread_attr_t</span> *sigev_notify_attributes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>如果 notification != nullptr<br>当前进程希望 在有一个消息 到达所指定的 先前为空的队列 时得到通知<br>我们说 该进程被注册为接收该队列的通知</p>\n</li>\n<li><p>如果 notification == nullptr<br>如果 该进程被注册为 接受所指定队列通知 则取消它</p>\n</li>\n<li><p>任何时刻只有一个进程可以被注册为 接收某个队列的通知</p>\n</li>\n<li><p>当一个消息到达某个空队列, 而且已经注册, 那么只有当<br>没有因为调用mq_reveive导致的阻塞 的时候才会发出通知</p>\n</li>\n<li><p>通知发出后 注册立即被撤销.. 需要重新注册???</p>\n</li>\n</ol>\n<p>Unix信号产生后会复位成默认行为.<br>信号处理程序通常第一个调用signal函数, 用于重新建立处理程序<br>这时会产生一个空窗时期(信号产生 与 当前进程重建信号处理程序之间)<br>空窗时期再次产生同一信号 可能终止当前进程</p>\n<p>初看起来, mq_notify可能也有这个问题.<br>不过在消息队列<code>为空前</code> <code>通知不会再次产生</code><br>所以不要在<code>读出消息后</code>重新注册<br>而应该在<code>读出消息前</code>重新注册</p>\n<p><code>volatile sig_atomic_t mqflag = 0;</code><br>sig_atomic_t 即使缺少信号所做的异步中断，亦能作为原子实体访问的整数类型。<br>volatile 标记可能会随时改变</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"消息传递\"><a href=\"#消息传递\" class=\"headerlink\" title=\"消息传递\"></a>消息传递</h1><h2 id=\"管道和有名管道FIFO\"><a href=\"#管道和有名管道FIFO\" class=\"headerlink\" title=\"管道和有名管道FIFO\"></a>管道和有名管道FIFO</h2><p><strong>popen pclose</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回文件指针, 出错为NULL</span></span><br><span class=\"line\"><span class=\"function\">FILE* <span class=\"title\">popen</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *command, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *type)</span></span>;</span><br><span class=\"line\">FILE* fp = popen(command, <span class=\"string\">\"r\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功为shell终止状态, 出错则为 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pclose</span><span class=\"params\">(FILE *stream)</span></span>;</span><br><span class=\"line\">pclose(fp);</span><br></pre></td></tr></table></figure>\n<p>popen创建一个管道并启动另外一个进程 创建者要么从管道读出标准输入, 要么将标准输出写到管道<br>返回的文件指针作用<br>通过type参数控制<br>type = “r” 创建者 通过文件指针读入command命令产生的标准输出<br>type = “w” 创建者 通过文件指针为command命令提供标准输入</p>\n<p>pclose 关闭这个标准IO流</p>\n<p><strong>FIFO 先进先出(first in, first out)</strong></p>\n<p>又称为有名管道(named pipe) 单向(半双工)数据流, 每个FIFO都有一个路径名与之对应.<br>从而允许无亲缘关系的进程访问同一个FIFO</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功返回 0 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mkfifo</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pathname, <span class=\"keyword\">mode_t</span> mode)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> FIFO1 = <span class=\"string\">\"/tmp/fifo.1\"</span>;</span><br><span class=\"line\">mkfifo(FIFO1, <span class=\"number\">0666</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建之后需要打开来进行读或者写 可以使用open也可以使用其他标准IO打开函数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> writefd = <span class=\"built_in\">open</span>(FIFO1, O_WRONLY, <span class=\"number\">0</span>); <span class=\"comment\">/* 在父进程中打开 父进程写 */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> readfd = <span class=\"built_in\">open</span>(FIFO1, O_RDONLY, <span class=\"number\">0</span>); <span class=\"comment\">/* 在子进程中打开 子进程读 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只有调用unlink才能从文件系统删除文件名字</span></span><br><span class=\"line\">unlink(FIFO1);</span><br></pre></td></tr></table></figure>\n<p>mkfifo 隐含已经指定 O_CREAT | O_EXCL<br>要么不存在创建一个新的, 要么返回 errno=EEXIST(所指定名字的FIFO已经存在)</p>\n<p>如果想要打开已经存在的FIFO可以使用open函数.<br>可以判断 如果返回-1 并且errno=EEXIST 就调用open函数打开</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 子进程</span></span><br><span class=\"line\">readfd = <span class=\"built_in\">open</span>(FIFO1, O_RDONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\">writefd = <span class=\"built_in\">open</span>(FIFO2, O_WRONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父进程</span></span><br><span class=\"line\">writefd = <span class=\"built_in\">open</span>(FIFO1, O_WRONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\">readfd = <span class=\"built_in\">open</span>(FIFO2, O_RDONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 父进程 这样会阻塞</span></span><br><span class=\"line\">readfd = <span class=\"built_in\">open</span>(FIFO2, O_RDONLY, <span class=\"number\">0</span>);</span><br><span class=\"line\">writefd = <span class=\"built_in\">open</span>(FIFO1, O_WRONLY, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>如果调换父进程的两行代码 程序就会进入死锁<br>因为如果当前没有任何进程<code>打开某个FIFO来写</code>, 打开这个<code>FIFO来读</code>的进程将会<code>阻塞</code></p>\n<p>当对一个管道或者FIFO的最终close发生的时候, 该管道或FIFO中的任何残余数据都将被丢弃</p>\n<p>即使在A主机上能够访问到B主机的目录, 即使不同主机上的两个进程都能够通过NFS打开同一个FIFO<br>他们之间也不能通过FIFO从一个进程到另一个进程发送数据</p>\n<p>拒绝服务型攻击Dos<br>如果是单进程可能会让服务器处于阻塞状态, 多进程也可能会由于一个恶意客户发送大量独立请求<br>导致服务器子进程数达到上限, 使得后续的fork失败</p>\n<p><strong>其他</strong><br>从字节流中获取完整的单个信息</p>\n<ul>\n<li>带特殊终止序列<br>许多UNIX应用使用换行分割 因特尔应用程序使用回车符加上一个换行符</li>\n<li>显式长度<br>将长度增加在请求中</li>\n<li>每次连接一个记录<br>应用通过关闭对端连接指示一个记录结束. HTTP1.0使用的这一技术</li>\n</ul>\n<p>标准IO函数fdopen可以将标准IO流与pipe返回的文件描述符相关联’</p>\n<p><strong>限制</strong><br>系统加在管道和FIFO的唯一限制是</p>\n<ul>\n<li>OPEN_MAX<br>一个进程在任意时刻打开的最大描述符数量 &gt;=16</li>\n<li>PIPE_BUF<br>可以原子性的写入一个管道或FIFO的最大数据量 &gt;= 512</li>\n</ul>\n<p><strong>习题练习</strong></p>\n<ol>\n<li>父进程终止的时候, 如果子进程的fd[1]仍处于打开状态, 则子进程对fd[0]的read 不会返回文件结束符,<br>因为fd[1]虽然在父进程中关闭了, 但是在子进程中依然打开. 如果关闭子进程fd[1], 则父进程一旦关闭,<br>他的所有文件描述符即关闭, 子进程对fd[0]的read就会返回0.(想到了自己写的服务器, 客户端断开连接就会read出一个0长度的内容)</li>\n<li>从 不存在即创建, 存在-&gt;打开 变成 存在-&gt;打开, 不存在即创建. 可能会在open打开失败后 创建fifo之前<br>被其他进程抢先创建fifo, 导致本进程的mkfifo调用失败</li>\n<li>出错信息写到了标准错误输出</li>\n<li>可以把第一个open调用设置成非阻塞, 但是为了避免readline返回错误, 标志必须在readline之前去除</li>\n<li>死锁</li>\n<li>读进程关闭管道或者FIFO后给写进程一个信号(往关闭的管道写会产生SIGPIPE信号),<br>写进程关闭管道或者FIFO后将文件结束符发送给读进程(读进程读到长度为0的文件结束符)</li>\n</ol>\n<h2 id=\"POSIX消息队列\"><a href=\"#POSIX消息队列\" class=\"headerlink\" title=\"POSIX消息队列\"></a>POSIX消息队列</h2><p><strong>mqueue创建和删除</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mqueue.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// oflag O_RDONLY O_WRONLY O_RDWR 可以加上O_CREAT和O_EXCL或者O_NONBLOCK</span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个新队列的时候(制定了O_CREAT且消息队列不存在)后两个参数都需要</span></span><br><span class=\"line\"><span class=\"comment\">// 权限位 和 指定某些属性 nullptr则使用默认属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功返回消息队列 fd 失败 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">mqd_t</span> <span class=\"title\">mq_open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name, <span class=\"keyword\">int</span> oflag,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"> <span class=\"comment\">/*mode_t mode, struct mq_attr *attr*/</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>注意<br>消息队列文件描述符不必是(而且很可能不是)像文件描述符或者socket文件描述符那样的短整数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 关闭消息队列 引用计数 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_close</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>类似close函数, 调用进程可以不再使用该文件描述符, 但是其消息队列并不会从系统中删除</p>\n<p>当一个进程终止的时候, 所有打开着的消息队列都将关闭, 就像自动调用了mq_close</p>\n<p>如果要从系统中删除<code>mq_open</code>第一个参数<code>name</code> 必须调用下面的函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引用计数 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_unlink</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>每个消息队列有一个保存着当前打开描述符数的引用计数器</p>\n<p>当消息队列的引用计数仍大于0时, 其name就能删除<br>但是队列的析构会在<code>引用计数为0</code>的时候自动析构.</p>\n<p>第一个demo敲完之后 一直是errno=13.<br>在<code>man mq_overview</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">On Linux, message queues are created in a virtual filesystem.   (Other  implementa‐</span><br><span class=\"line\">tions may also provide such a feature, but the details are likely to differ.)  This</span><br><span class=\"line\">filesystem can be mounted (by the superuser) using the following commands:</span><br><span class=\"line\"></span><br><span class=\"line\"># mkdir &#x2F;dev&#x2F;mqueue</span><br><span class=\"line\"># mount -t mqueue none &#x2F;dev&#x2F;mqueue</span><br><span class=\"line\"></span><br><span class=\"line\">The sticky bit is automatically enabled on the mount directory.</span><br></pre></td></tr></table></figure>\n<p>而且 name参数的格式是<code>/somename</code> 这个是相对挂载目录的</p>\n<p><strong>属性设置</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">mq_attr</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_flags; <span class=\"comment\">/* 0, O_NONBLOCK */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_maxmsg; <span class=\"comment\">/* max number */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_msgsize; <span class=\"comment\">/* max size of a msg in bytes */</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> mq_curmsgs; <span class=\"comment\">/* number of message currently on queue */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_getattr</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, struct mq_attr *attr)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// set 的时候 只有mq_attr中的mq_flags起作用 设置取消O_NONBLOCK</span></span><br><span class=\"line\"><span class=\"comment\">// 最大消息数和最大字节数 只能在创建队列的时候设置</span></span><br><span class=\"line\"><span class=\"comment\">// 队列中房钱消息数 只能获取不能设置</span></span><br><span class=\"line\"><span class=\"comment\">// 第三个参数 不为nullptr则返回之前的属性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_setattr</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, <span class=\"keyword\">const</span> struct mq_attr *attr, struct mq_attr *oattr)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>发送接收信息</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// prio 优先级 必须 &lt;= MQ_PRIO_MAX</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_send</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *ptr, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> prio)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// len 必须 &gt;= mq_attr.mq_msgsize 如果小于则 errno = EMSGSIZE</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">mq_receive</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *ptr, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> *priop)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>如果不使用优先级 发送的时候可以将 mq_send的 prio 设置为0<br>接受的时候 mq_receive priop 设置为 nullptr</p>\n<p><strong>消息队列的限制</strong></p>\n<ul>\n<li>mq_maxmsg 队列中最大消息数</li>\n<li>mq_msgsize单个消息的最大字节</li>\n<li>MQ_OPEN_MAX 一个进程同时打开消息队列的最大数目</li>\n<li>MQ_PRIO_MAX 最大优先级+1</li>\n</ul>\n<p><strong>异步事件通知</strong></p>\n<ul>\n<li>产生信号</li>\n<li>创建一个线程执行一个指定的函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为指定队列建立或者删除异步事件通知.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成功返回 0 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">mq_notify</span><span class=\"params\">(<span class=\"keyword\">mqd_t</span> mqdes, struct sigevent *nofification)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigval</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sival_int;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *sival_ptr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigevent</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sigev_notify; <span class=\"comment\">// SIGEV_NONE SIGEV_SIGNAL SIGEV_THREAD</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sigev_signo; <span class=\"comment\">// signal number if SIGEV_SIGNAL</span></span><br><span class=\"line\">    <span class=\"keyword\">union</span> sigval sigev_value; <span class=\"comment\">// passed to signal handler pr thread</span></span><br><span class=\"line\">    <span class=\"comment\">// 下面两个用于 SIGEV_THREAD</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*sigev_notify_function)(<span class=\"keyword\">union</span> sigval);</span><br><span class=\"line\">    <span class=\"keyword\">pthread_attr_t</span> *sigev_notify_attributes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>如果 notification != nullptr<br>当前进程希望 在有一个消息 到达所指定的 先前为空的队列 时得到通知<br>我们说 该进程被注册为接收该队列的通知</p>\n</li>\n<li><p>如果 notification == nullptr<br>如果 该进程被注册为 接受所指定队列通知 则取消它</p>\n</li>\n<li><p>任何时刻只有一个进程可以被注册为 接收某个队列的通知</p>\n</li>\n<li><p>当一个消息到达某个空队列, 而且已经注册, 那么只有当<br>没有因为调用mq_reveive导致的阻塞 的时候才会发出通知</p>\n</li>\n<li><p>通知发出后 注册立即被撤销.. 需要重新注册???</p>\n</li>\n</ol>\n<p>Unix信号产生后会复位成默认行为.<br>信号处理程序通常第一个调用signal函数, 用于重新建立处理程序<br>这时会产生一个空窗时期(信号产生 与 当前进程重建信号处理程序之间)<br>空窗时期再次产生同一信号 可能终止当前进程</p>\n<p>初看起来, mq_notify可能也有这个问题.<br>不过在消息队列<code>为空前</code> <code>通知不会再次产生</code><br>所以不要在<code>读出消息后</code>重新注册<br>而应该在<code>读出消息前</code>重新注册</p>\n<p><code>volatile sig_atomic_t mqflag = 0;</code><br>sig_atomic_t 即使缺少信号所做的异步中断，亦能作为原子实体访问的整数类型。<br>volatile 标记可能会随时改变</p>\n"},{"title":"Linux高性能服务器-高级部分","date":"2019-08-18T12:34:39.000Z","top":101,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg","_content":"# 第九章 I/O复用\n\nI/O复用使得程序能同时监听多个文件描述符.\n- 客户端程序需要同时处理多个socket 非阻塞connect技术\n- 客户端程序同时处理用户输入和网络连接 聊天室程序\n- TCP服务器要同时处理监听socket和连接socket\n- 同时处理TCP和UDP请求 - 回射服务器\n- 同时监听多个端口, 或者处理多种服务 - xinetd服务器\n\n常用手段`select`, `poll`, `epoll`\n\n## select\n```c++\n#include <sys/select.h>\n// nfds - 被监听的文件描述符总数\n// 后面三个分别指向 可读, 可写, 异常等事件对应的文件描述符集合\n// timeval select超时时间 如果传递0 则为非阻塞, 设置为NULL则为阻塞\n// 成功返回就绪(可读, 可写, 异常)文件描述符的总数, 没有则返回0 失败返回-1\nint select (int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout);\n\n//操作fd_set的宏\nFD_ZERO(fd_set* fdset);\nFD_SET(int fd, fd_set* fdset);\nFD_CLR(int fd, fd_set* fdset);\nFD_ISSET(int fd, fd_set* fdset);\n// 设置 timeval 超时时间\nstruct timeval\n{\n\tlong tv_sec; // 秒\n\tlong tv_usec; // 微秒\n}\n```\n**select**\n\n文件描述符就绪条件\n- socket内核接收缓存区中的字节数大于或等于 其低水位标记\n- socket通信的对方关闭连接, 对socket的读操作返回0\n- 监听socket上有新的连接请求\n- socket上有未处理的错误, 可以使用getsockopt来读取和清除错误\n- socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记\n- socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号\n- socket使用非阻塞connect 连接成功或失败后\n## poll\n**poll**\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B1.png)\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B2.png)\n\n```c++\n#include <poll.h>\n// fds 结构体类型数组 指定我们感兴趣的文件描述符上发生的可读可写和异常事件\\\n// nfds 遍历结合大小 左闭右开\n// timeout 单位为毫秒 -1 为阻塞 0 为立即返回\nint poll(struct pollfd* fds, nfds_t nfds, int timeout);\n\nstruct pollfd\n{\n\tint fd;\n\tshort events;  //注册的事件, 告知poll监听fd上的哪些事件\n\tshort revents; // 实际发生的事件\n}\n```\n```c++\n#define exit_if(r, ...) \\\n{   \\\n    if (r)  \\\n    {   \\\n        printf(__VA_ARGS__);    \\\n        printf(\"errno no: %d, error msg is %s\", errno, strerror(errno));    \\\n        exit(1);    \\\n    }   \\\n}   \\\n\nstruct client_info\n{\n    char *ip_;\n    int port_;\n};\n\nint main(int argc, char* argv[])\n{\n    int port = 8001;\n    char ip[] = \"127.0.0.1\";\n\n    struct sockaddr_in address;\n    address.sin_port = htons(port);\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = htons(INADDR_ANY);\n\n    int listenfd = socket(PF_INET, SOCK_STREAM, 0);\n    exit_if(listenfd < 0, \"socket error\\n\");\n\n    int ret = bind(listenfd, (struct sockaddr*)&address, sizeof(address));\n    exit_if(ret == -1, \"bind error\\n\");\n\n    ret = listen(listenfd, 5);\n    exit_if(ret == -1, \"listen error\\n\");\n\n    constexpr int MAX_CLIENTS = 1024;\n    struct pollfd polls[MAX_CLIENTS] = {};\n    struct client_info clientsinfo[MAX_CLIENTS] = {};\n\n    polls[3].fd = listenfd;\n    polls[3].events = POLLIN | POLLRDHUP;\n\n\n    while (true)\n    {\n        ret = poll(polls, MAX_CLIENTS + 1, -1);\n        exit_if(ret == -1, \"poll error\\n\");\n\n        for (int i = 3; i <= MAX_CLIENTS; ++i)\n        {\n            int fd = polls[i].fd;\n\n            if (polls[i].revents & POLLRDHUP)\n            {\n                polls[i].events = 0;\n                printf(\"close fd-%d from %s:%d\\n\", fd, clientsinfo[fd].ip_, clientsinfo[fd].port_);\n            }\n\n            if (polls[i].revents & POLLIN)\n            {\n                if (fd == listenfd)\n                {\n                    struct sockaddr_in client_address;\n                    socklen_t client_addresslen = sizeof(client_address);\n\n                    int clientfd = accept(listenfd, (struct sockaddr*)&client_address,\n                            &client_addresslen);\n\n                    struct client_info *clientinfo = &clientsinfo[clientfd];\n\n                    clientinfo->ip_ = inet_ntoa(client_address.sin_addr);\n                    clientinfo->port_ = ntohs(client_address.sin_port);\n\n                    exit_if(clientfd < 0, \"accpet error, from %s:%d\\n\", clientinfo->ip_,\n                            clientinfo->port_);\n                    printf(\"accept from %s:%d\\n\", clientinfo->ip_, clientinfo->port_);\n\n                    polls[clientfd].fd = clientfd;\n                    polls[clientfd].events = POLLIN | POLLRDHUP;\n                }\n                else\n                {\n                    char buffer[1024];\n                    memset(buffer, '\\0', sizeof(buffer));\n\n                    ret = read(fd, buffer, 1024);\n                    if(ret == 0)\n                    {\n                        close(fd);\n                    }\n                    else\n                    {\n                        printf(\"recv from %s:%d:\\n%s\\n\", clientsinfo[fd].ip_,\n                               clientsinfo[fd].port_, buffer);\n                    }\n                }\n            }\n        }\n    }\n}\n```\n## epoll\n**epoll**\n\nepoll是Linux特有的I/O复用函数, 实现上与select,poll有很大的差异\n- epoll使用一组函数完成任务\n- epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中\n- epoll无需每次调用都传入文件描述符集或事件集.\n\n有特定的文件描述符创建函数, 来标识这个事件表`epoll_create()`\n`epoll_ctl()` 用来操作这个内核事件表\n`epoll_wait()` 为主要函数 成功返回就绪的文件描述符个数 失败返回-1\n如果`epoll_wait()`函数检测到事件,就将所有就绪的事件从内核事件表(由第一个参数, epoll_create返回的结果) 中复制到第二个参数event指向的数组中, 这个数组只用于输出`epoll_wait`检测到的就绪事件.\n\n*event不同于select和poll的数组参数 既用于传入用户注册的事件, 又用于输出内核检测到的就绪事件, 提高了效率*\n\n```c++\n// 索引poll返回的就绪文件描述符\nint ret = poll(fds, MAX_EVENT_NUMBER - 1);\n// 遍历\nfor(int i = 0; i < MAX_EVENT_NUMBER; ++i) {\n\tif(fds[i].revents & POLLIN) {\n\t\tint sockfd = fds[i].fd;\n\t}\n}\n\n// 索引epoll返回的就绪文件描述符\nint ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER,  -1);\nfor(int i = 0; i < ret; i++) {\n\tint sockfd = events[i].data.fd;\n\t// sockfd 一定就绪 ?????\n}\n```\n\n**LT和ET模式**\nLT(电平触发, 默认的工作模式)\nLT模式下的epoll相当于一个效率较高的poll\nepoll_wait将会一只通知一个事件知道这个事件被处理\n\nET(边沿触发, epoll的高效工作模式)模式\n当向epoll内核事件表中注册一个文件描述符上的EPOLLET事件的时候, epoll将用ET模式来操作这个\n文件描述符\nepoll_wait只会通知一次, 不论这个事件有没有完成\n\nET模式\n```\n-> 123456789-123456789-123456789\nevent trigger once\nget 9bytes of content: 123456789\nget 9bytes of content: -12345678\nget 9bytes of content: 9-1234567\nget 4bytes of content: 89\nread later\n```\nLT模式\n```\n-> 123456789-123456789-123456789\nevent trigger once\nget 9bytes of contents: 123456789\nevent trigger once\nget 9bytes of contents: -12345678\nevent trigger once\nget 9bytes of contents: 9-1234567\nevent trigger once\nget 4bytes of contents: 89\n```\nET模式有任务到来就必须做完, 因为后续将不会继续通知这个事件, 所以ET是epoll的高效工作模式\nLT模式只要事件没被处理就会一直通知\n\n```c++\n#include <epoll.h>\n// size 参数只是给内核一个提示, 事件表需要多大\n// 函数返回其他所有epoll系统调用的第一个参数, 来指定要访问的内核事件表\nint epoll_create(int size);\n\n// epfd 为 epoll_create的返回值\n// op为操作类型\n// - EPOLL_CTL_ADD 向事件表中注册fd上的事件\n// - EPOLL_CTL_MOD 修改fd上的注册事件\n// - EPOLL_CTL_DEL 删除fd上的注册事件\n// fd 为要操作的文件描述符\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);\n\nstruct epoll_event\n{\n\t_uint32_t events; // epoll事件\n\tepoll_data_t data; // 用户数据 是一个联合体\n}\n\ntypedef union epoll_data\n{\n\tvoid* ptr; // ptr fd 不能同时使用\n\tint fd;\n\tuint32_t u32;\n\tuint64_t u64;\n}epoll_data_t\n\n// maxevents监听事件数 必须大于0\n// timeout 为-1 表示阻塞\n// 成功返回就绪的文件描述符个数 失败返回-1\nint epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);\n```\n\n## 三种IO复用的比较\n`select`以及`poll`和`epoll`\n相同\n- 都能同时监听多个文件描述符, 都将等待timeout参数指定的超时时间, 直到一个或多个文件描述符上有事件发生.\n- 返回值为就绪的文件描述符数量, 返回0则表示没有事件发生\n- ![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%B8%89%E7%A7%8DIO%E5%A4%8D%E7%94%A8%E6%AF%94%E8%BE%83.png)\n\n## I/O 复用的高级应用, 非阻塞connect\n\nconnect出错的时候会返回一个errno值 EINPROGRESS - 表示对非阻塞socket调用connect, 连接又没有立即建立的时候, 这时可以调用select和poll函数来监听这个连接失败的socket上的可写事件.\n\n当函数返回的时候, 可以用getsockopt来读取错误码, 并清楚该socket上的错误. 错误码为0表示成功\n\n\n# 第十章信号\n\n## Api\n发送信号Api\n```c++\n#include <sys/types.h>\n#include <signal.h>\n\n// pid > 0 发送给PID为pid标识的进程\n//  0 发送给本进程组的其他进程\n// -1 发送给进程以外的所有进程, 但发送者需要有对目标进程发送信号的权限\n// < -1 发送给组ID为 -pid 的进程组中的所有成员\n\n// 出错信息 EINVAL 无效信号, EPERM 该进程没有权限给任何一个目标进程 ESRCH 目标进程(组) 不存在\nint kill(pid_t pid, int sig);\n```\n接收信号Api\n```c++\n#include <signal.h>\ntypedef void(*_sighandler_t) (int);\n\n#include <bits/signum.h> // 此头文件中有所有的linux可用信号\n// 忽略目标信号\n#define SIG_DFL ((_sighandler_t) 0)\n// 使用信号的默认处理方式\n#define SIG_IGN ((_sighandler_t) 1)\n```\n常用信号\n```\nSIGHUP 控制终端挂起\nSIGPIPE 往读端被关闭的管道或者socket连接中写数据\nSIGURG socket连接上收到紧急数据\nSIGALRM 由alarm或setitimer设置的实时闹钟超时引起\nSIGCHLD 子进程状态变化\n```\n信号函数\n```c++\n// 为一个信号设置处理函数\n#include <signal.h>\n// _handler 指定sig的处理函数\n_sighandler_t signal(int sig, __sighandler_t _handler)\n\n\nint sigaction(int sig, struct sigaction* act, struct sigaction* oact)\n```\n## 概述\n\n信号是用户, 系统, 或者进程发送给目标进程的信息, 以通知目标进程某个状态的改变或者系统异常.\n产生条件\n- 对于前台进程\n用户可以通过输入特殊的终端字符来给它发送信号, CTRL+C 通常为一个中断信号 `SIGINT`\n- 系统异常\n浮点异常和非法内存段的访问\n- 系统状态变化\n由alarm定时器到期将引起`SIGALRM`信号\n- 运行kill命令或调用kill函数\n\n*服务器必须处理(至少忽略) 一些常见的信号, 以免异常终止*\n\n中断系统调用?\n\n# 第十一章定时器\n## socket选项`SO_RCVTIMEO` 和 `SO_SNDTIMEO`\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/SO_RCVTIMEO%E5%92%8CSO_SNDTIMEO%E9%80%89%E9%A1%B9%E7%9A%84%E4%BD%9C%E7%94%A8.png)\n\n使用示例, 通过设置对应的SO_SNDTIMEO 得到超时后的路线\n```c++\nint timeout_connect(const char* ip, const int port, const int sec)\n{\n    struct sockaddr_in address{};\n    address.sin_family = AF_INET;\n    address.sin_port = htons(port);\n    address.sin_addr.s_addr = inet_addr(ip);\n\n    int sockfd = socket(PF_INET, SOCK_STREAM, 0);\n    exit_if(sockfd < 0, \"socket error\\n\");\n\n    struct timeval timeout{};\n    timeout.tv_sec = sec;\n    timeout.tv_usec = 0;\n    socklen_t timeout_len = sizeof(timeout);\n\n    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, timeout_len);\n\n    int ret = connect(sockfd, (struct sockaddr*)&address, sizeof(address));\n    if (ret == -1)\n    {\n\t\t// 当 errno为EINPROGRESS 说明 等待了 10S后依然无法连接成功 实现了定时器\n        if (errno == EINPROGRESS)\n        {\n            printf(\"connecting timeout, process timeout logic\\n\");\n            return -1;\n        }\n        printf(\"error occur when connecting to server\\n\");\n        return -1;\n    }\n    return sockfd;\n}\n\nint main(int argc, char* argv[])\n{\n    exit_if(argc <= 2, \"wrong number of parameters\\n\")\n    const char* ip = argv[1];\n    const int port = atoi(argv[2]);\n\n    int sockfd = timeout_connect(ip, port, 10);\n    if (sockfd < 0)\n    {\n        return 1;\n    }\n    return 0;\n}\n```\n\n## SIGALRM信号-基于升序链表的定时器\n由alarm和setitimer函数设定的实时闹钟一旦超时, 将会触发SIGALRM信号, 用信号处理函数处理定时任务\n 相关的代码放在了github上 代码还是很多的就不放上来了[连接](https://github.com/rjd67441/Notes-HighPerformanceLinuxServerProgramming/tree/master/12.%20%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%9511-2%E5%92%8C11-3%E5%8F%8A11-4%20%E9%93%BE%E8%A1%A8%E5%AE%9A%E6%97%B6%E5%99%A8%2C%20%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5)\n\n总结放在了 日记的博客上 链接后面再甩出来\n## IO复用系统调用的超时参数\n\n## 高性能定时器\n## # 时间轮\n## # 时间堆\n\n# 第十二章高性能IO框架库\n另出一篇博客","source":"_posts/CPP-读书记录101-高性能服务器编程读书记录高级部分.md","raw":"---\ntitle: Linux高性能服务器-高级部分\ntags:\n  - null\ncategories:\n  - CPP\n  - 服务器编程-书籍记录\ndate: 2019-08-18 20:34:39\n\ntop: 101\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg\n---\n# 第九章 I/O复用\n\nI/O复用使得程序能同时监听多个文件描述符.\n- 客户端程序需要同时处理多个socket 非阻塞connect技术\n- 客户端程序同时处理用户输入和网络连接 聊天室程序\n- TCP服务器要同时处理监听socket和连接socket\n- 同时处理TCP和UDP请求 - 回射服务器\n- 同时监听多个端口, 或者处理多种服务 - xinetd服务器\n\n常用手段`select`, `poll`, `epoll`\n\n## select\n```c++\n#include <sys/select.h>\n// nfds - 被监听的文件描述符总数\n// 后面三个分别指向 可读, 可写, 异常等事件对应的文件描述符集合\n// timeval select超时时间 如果传递0 则为非阻塞, 设置为NULL则为阻塞\n// 成功返回就绪(可读, 可写, 异常)文件描述符的总数, 没有则返回0 失败返回-1\nint select (int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout);\n\n//操作fd_set的宏\nFD_ZERO(fd_set* fdset);\nFD_SET(int fd, fd_set* fdset);\nFD_CLR(int fd, fd_set* fdset);\nFD_ISSET(int fd, fd_set* fdset);\n// 设置 timeval 超时时间\nstruct timeval\n{\n\tlong tv_sec; // 秒\n\tlong tv_usec; // 微秒\n}\n```\n**select**\n\n文件描述符就绪条件\n- socket内核接收缓存区中的字节数大于或等于 其低水位标记\n- socket通信的对方关闭连接, 对socket的读操作返回0\n- 监听socket上有新的连接请求\n- socket上有未处理的错误, 可以使用getsockopt来读取和清除错误\n- socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记\n- socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号\n- socket使用非阻塞connect 连接成功或失败后\n## poll\n**poll**\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B1.png)\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B2.png)\n\n```c++\n#include <poll.h>\n// fds 结构体类型数组 指定我们感兴趣的文件描述符上发生的可读可写和异常事件\\\n// nfds 遍历结合大小 左闭右开\n// timeout 单位为毫秒 -1 为阻塞 0 为立即返回\nint poll(struct pollfd* fds, nfds_t nfds, int timeout);\n\nstruct pollfd\n{\n\tint fd;\n\tshort events;  //注册的事件, 告知poll监听fd上的哪些事件\n\tshort revents; // 实际发生的事件\n}\n```\n```c++\n#define exit_if(r, ...) \\\n{   \\\n    if (r)  \\\n    {   \\\n        printf(__VA_ARGS__);    \\\n        printf(\"errno no: %d, error msg is %s\", errno, strerror(errno));    \\\n        exit(1);    \\\n    }   \\\n}   \\\n\nstruct client_info\n{\n    char *ip_;\n    int port_;\n};\n\nint main(int argc, char* argv[])\n{\n    int port = 8001;\n    char ip[] = \"127.0.0.1\";\n\n    struct sockaddr_in address;\n    address.sin_port = htons(port);\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = htons(INADDR_ANY);\n\n    int listenfd = socket(PF_INET, SOCK_STREAM, 0);\n    exit_if(listenfd < 0, \"socket error\\n\");\n\n    int ret = bind(listenfd, (struct sockaddr*)&address, sizeof(address));\n    exit_if(ret == -1, \"bind error\\n\");\n\n    ret = listen(listenfd, 5);\n    exit_if(ret == -1, \"listen error\\n\");\n\n    constexpr int MAX_CLIENTS = 1024;\n    struct pollfd polls[MAX_CLIENTS] = {};\n    struct client_info clientsinfo[MAX_CLIENTS] = {};\n\n    polls[3].fd = listenfd;\n    polls[3].events = POLLIN | POLLRDHUP;\n\n\n    while (true)\n    {\n        ret = poll(polls, MAX_CLIENTS + 1, -1);\n        exit_if(ret == -1, \"poll error\\n\");\n\n        for (int i = 3; i <= MAX_CLIENTS; ++i)\n        {\n            int fd = polls[i].fd;\n\n            if (polls[i].revents & POLLRDHUP)\n            {\n                polls[i].events = 0;\n                printf(\"close fd-%d from %s:%d\\n\", fd, clientsinfo[fd].ip_, clientsinfo[fd].port_);\n            }\n\n            if (polls[i].revents & POLLIN)\n            {\n                if (fd == listenfd)\n                {\n                    struct sockaddr_in client_address;\n                    socklen_t client_addresslen = sizeof(client_address);\n\n                    int clientfd = accept(listenfd, (struct sockaddr*)&client_address,\n                            &client_addresslen);\n\n                    struct client_info *clientinfo = &clientsinfo[clientfd];\n\n                    clientinfo->ip_ = inet_ntoa(client_address.sin_addr);\n                    clientinfo->port_ = ntohs(client_address.sin_port);\n\n                    exit_if(clientfd < 0, \"accpet error, from %s:%d\\n\", clientinfo->ip_,\n                            clientinfo->port_);\n                    printf(\"accept from %s:%d\\n\", clientinfo->ip_, clientinfo->port_);\n\n                    polls[clientfd].fd = clientfd;\n                    polls[clientfd].events = POLLIN | POLLRDHUP;\n                }\n                else\n                {\n                    char buffer[1024];\n                    memset(buffer, '\\0', sizeof(buffer));\n\n                    ret = read(fd, buffer, 1024);\n                    if(ret == 0)\n                    {\n                        close(fd);\n                    }\n                    else\n                    {\n                        printf(\"recv from %s:%d:\\n%s\\n\", clientsinfo[fd].ip_,\n                               clientsinfo[fd].port_, buffer);\n                    }\n                }\n            }\n        }\n    }\n}\n```\n## epoll\n**epoll**\n\nepoll是Linux特有的I/O复用函数, 实现上与select,poll有很大的差异\n- epoll使用一组函数完成任务\n- epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中\n- epoll无需每次调用都传入文件描述符集或事件集.\n\n有特定的文件描述符创建函数, 来标识这个事件表`epoll_create()`\n`epoll_ctl()` 用来操作这个内核事件表\n`epoll_wait()` 为主要函数 成功返回就绪的文件描述符个数 失败返回-1\n如果`epoll_wait()`函数检测到事件,就将所有就绪的事件从内核事件表(由第一个参数, epoll_create返回的结果) 中复制到第二个参数event指向的数组中, 这个数组只用于输出`epoll_wait`检测到的就绪事件.\n\n*event不同于select和poll的数组参数 既用于传入用户注册的事件, 又用于输出内核检测到的就绪事件, 提高了效率*\n\n```c++\n// 索引poll返回的就绪文件描述符\nint ret = poll(fds, MAX_EVENT_NUMBER - 1);\n// 遍历\nfor(int i = 0; i < MAX_EVENT_NUMBER; ++i) {\n\tif(fds[i].revents & POLLIN) {\n\t\tint sockfd = fds[i].fd;\n\t}\n}\n\n// 索引epoll返回的就绪文件描述符\nint ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER,  -1);\nfor(int i = 0; i < ret; i++) {\n\tint sockfd = events[i].data.fd;\n\t// sockfd 一定就绪 ?????\n}\n```\n\n**LT和ET模式**\nLT(电平触发, 默认的工作模式)\nLT模式下的epoll相当于一个效率较高的poll\nepoll_wait将会一只通知一个事件知道这个事件被处理\n\nET(边沿触发, epoll的高效工作模式)模式\n当向epoll内核事件表中注册一个文件描述符上的EPOLLET事件的时候, epoll将用ET模式来操作这个\n文件描述符\nepoll_wait只会通知一次, 不论这个事件有没有完成\n\nET模式\n```\n-> 123456789-123456789-123456789\nevent trigger once\nget 9bytes of content: 123456789\nget 9bytes of content: -12345678\nget 9bytes of content: 9-1234567\nget 4bytes of content: 89\nread later\n```\nLT模式\n```\n-> 123456789-123456789-123456789\nevent trigger once\nget 9bytes of contents: 123456789\nevent trigger once\nget 9bytes of contents: -12345678\nevent trigger once\nget 9bytes of contents: 9-1234567\nevent trigger once\nget 4bytes of contents: 89\n```\nET模式有任务到来就必须做完, 因为后续将不会继续通知这个事件, 所以ET是epoll的高效工作模式\nLT模式只要事件没被处理就会一直通知\n\n```c++\n#include <epoll.h>\n// size 参数只是给内核一个提示, 事件表需要多大\n// 函数返回其他所有epoll系统调用的第一个参数, 来指定要访问的内核事件表\nint epoll_create(int size);\n\n// epfd 为 epoll_create的返回值\n// op为操作类型\n// - EPOLL_CTL_ADD 向事件表中注册fd上的事件\n// - EPOLL_CTL_MOD 修改fd上的注册事件\n// - EPOLL_CTL_DEL 删除fd上的注册事件\n// fd 为要操作的文件描述符\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);\n\nstruct epoll_event\n{\n\t_uint32_t events; // epoll事件\n\tepoll_data_t data; // 用户数据 是一个联合体\n}\n\ntypedef union epoll_data\n{\n\tvoid* ptr; // ptr fd 不能同时使用\n\tint fd;\n\tuint32_t u32;\n\tuint64_t u64;\n}epoll_data_t\n\n// maxevents监听事件数 必须大于0\n// timeout 为-1 表示阻塞\n// 成功返回就绪的文件描述符个数 失败返回-1\nint epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout);\n```\n\n## 三种IO复用的比较\n`select`以及`poll`和`epoll`\n相同\n- 都能同时监听多个文件描述符, 都将等待timeout参数指定的超时时间, 直到一个或多个文件描述符上有事件发生.\n- 返回值为就绪的文件描述符数量, 返回0则表示没有事件发生\n- ![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%B8%89%E7%A7%8DIO%E5%A4%8D%E7%94%A8%E6%AF%94%E8%BE%83.png)\n\n## I/O 复用的高级应用, 非阻塞connect\n\nconnect出错的时候会返回一个errno值 EINPROGRESS - 表示对非阻塞socket调用connect, 连接又没有立即建立的时候, 这时可以调用select和poll函数来监听这个连接失败的socket上的可写事件.\n\n当函数返回的时候, 可以用getsockopt来读取错误码, 并清楚该socket上的错误. 错误码为0表示成功\n\n\n# 第十章信号\n\n## Api\n发送信号Api\n```c++\n#include <sys/types.h>\n#include <signal.h>\n\n// pid > 0 发送给PID为pid标识的进程\n//  0 发送给本进程组的其他进程\n// -1 发送给进程以外的所有进程, 但发送者需要有对目标进程发送信号的权限\n// < -1 发送给组ID为 -pid 的进程组中的所有成员\n\n// 出错信息 EINVAL 无效信号, EPERM 该进程没有权限给任何一个目标进程 ESRCH 目标进程(组) 不存在\nint kill(pid_t pid, int sig);\n```\n接收信号Api\n```c++\n#include <signal.h>\ntypedef void(*_sighandler_t) (int);\n\n#include <bits/signum.h> // 此头文件中有所有的linux可用信号\n// 忽略目标信号\n#define SIG_DFL ((_sighandler_t) 0)\n// 使用信号的默认处理方式\n#define SIG_IGN ((_sighandler_t) 1)\n```\n常用信号\n```\nSIGHUP 控制终端挂起\nSIGPIPE 往读端被关闭的管道或者socket连接中写数据\nSIGURG socket连接上收到紧急数据\nSIGALRM 由alarm或setitimer设置的实时闹钟超时引起\nSIGCHLD 子进程状态变化\n```\n信号函数\n```c++\n// 为一个信号设置处理函数\n#include <signal.h>\n// _handler 指定sig的处理函数\n_sighandler_t signal(int sig, __sighandler_t _handler)\n\n\nint sigaction(int sig, struct sigaction* act, struct sigaction* oact)\n```\n## 概述\n\n信号是用户, 系统, 或者进程发送给目标进程的信息, 以通知目标进程某个状态的改变或者系统异常.\n产生条件\n- 对于前台进程\n用户可以通过输入特殊的终端字符来给它发送信号, CTRL+C 通常为一个中断信号 `SIGINT`\n- 系统异常\n浮点异常和非法内存段的访问\n- 系统状态变化\n由alarm定时器到期将引起`SIGALRM`信号\n- 运行kill命令或调用kill函数\n\n*服务器必须处理(至少忽略) 一些常见的信号, 以免异常终止*\n\n中断系统调用?\n\n# 第十一章定时器\n## socket选项`SO_RCVTIMEO` 和 `SO_SNDTIMEO`\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/SO_RCVTIMEO%E5%92%8CSO_SNDTIMEO%E9%80%89%E9%A1%B9%E7%9A%84%E4%BD%9C%E7%94%A8.png)\n\n使用示例, 通过设置对应的SO_SNDTIMEO 得到超时后的路线\n```c++\nint timeout_connect(const char* ip, const int port, const int sec)\n{\n    struct sockaddr_in address{};\n    address.sin_family = AF_INET;\n    address.sin_port = htons(port);\n    address.sin_addr.s_addr = inet_addr(ip);\n\n    int sockfd = socket(PF_INET, SOCK_STREAM, 0);\n    exit_if(sockfd < 0, \"socket error\\n\");\n\n    struct timeval timeout{};\n    timeout.tv_sec = sec;\n    timeout.tv_usec = 0;\n    socklen_t timeout_len = sizeof(timeout);\n\n    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &timeout, timeout_len);\n\n    int ret = connect(sockfd, (struct sockaddr*)&address, sizeof(address));\n    if (ret == -1)\n    {\n\t\t// 当 errno为EINPROGRESS 说明 等待了 10S后依然无法连接成功 实现了定时器\n        if (errno == EINPROGRESS)\n        {\n            printf(\"connecting timeout, process timeout logic\\n\");\n            return -1;\n        }\n        printf(\"error occur when connecting to server\\n\");\n        return -1;\n    }\n    return sockfd;\n}\n\nint main(int argc, char* argv[])\n{\n    exit_if(argc <= 2, \"wrong number of parameters\\n\")\n    const char* ip = argv[1];\n    const int port = atoi(argv[2]);\n\n    int sockfd = timeout_connect(ip, port, 10);\n    if (sockfd < 0)\n    {\n        return 1;\n    }\n    return 0;\n}\n```\n\n## SIGALRM信号-基于升序链表的定时器\n由alarm和setitimer函数设定的实时闹钟一旦超时, 将会触发SIGALRM信号, 用信号处理函数处理定时任务\n 相关的代码放在了github上 代码还是很多的就不放上来了[连接](https://github.com/rjd67441/Notes-HighPerformanceLinuxServerProgramming/tree/master/12.%20%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%9511-2%E5%92%8C11-3%E5%8F%8A11-4%20%E9%93%BE%E8%A1%A8%E5%AE%9A%E6%97%B6%E5%99%A8%2C%20%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5)\n\n总结放在了 日记的博客上 链接后面再甩出来\n## IO复用系统调用的超时参数\n\n## 高性能定时器\n## # 时间轮\n## # 时间堆\n\n# 第十二章高性能IO框架库\n另出一篇博客","slug":"CPP-读书记录101-高性能服务器编程读书记录高级部分","published":1,"updated":"2020-03-14T07:11:01.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucv200168cuo6flwhfqk","content":"<h1 id=\"第九章-I-O复用\"><a href=\"#第九章-I-O复用\" class=\"headerlink\" title=\"第九章 I/O复用\"></a>第九章 I/O复用</h1><p>I/O复用使得程序能同时监听多个文件描述符.</p>\n<ul>\n<li>客户端程序需要同时处理多个socket 非阻塞connect技术</li>\n<li>客户端程序同时处理用户输入和网络连接 聊天室程序</li>\n<li>TCP服务器要同时处理监听socket和连接socket</li>\n<li>同时处理TCP和UDP请求 - 回射服务器</li>\n<li>同时监听多个端口, 或者处理多种服务 - xinetd服务器</li>\n</ul>\n<p>常用手段<code>select</code>, <code>poll</code>, <code>epoll</code></p>\n<h2 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/select.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// nfds - 被监听的文件描述符总数</span></span><br><span class=\"line\"><span class=\"comment\">// 后面三个分别指向 可读, 可写, 异常等事件对应的文件描述符集合</span></span><br><span class=\"line\"><span class=\"comment\">// timeval select超时时间 如果传递0 则为非阻塞, 设置为NULL则为阻塞</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回就绪(可读, 可写, 异常)文件描述符的总数, 没有则返回0 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">select</span> <span class=\"params\">(<span class=\"keyword\">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作fd_set的宏</span></span><br><span class=\"line\">FD_ZERO(fd_set* fdset);</span><br><span class=\"line\">FD_SET(<span class=\"keyword\">int</span> fd, fd_set* fdset);</span><br><span class=\"line\">FD_CLR(<span class=\"keyword\">int</span> fd, fd_set* fdset);</span><br><span class=\"line\">FD_ISSET(<span class=\"keyword\">int</span> fd, fd_set* fdset);</span><br><span class=\"line\"><span class=\"comment\">// 设置 timeval 超时时间</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> tv_sec; <span class=\"comment\">// 秒</span></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> tv_usec; <span class=\"comment\">// 微秒</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>select</strong></p>\n<p>文件描述符就绪条件</p>\n<ul>\n<li>socket内核接收缓存区中的字节数大于或等于 其低水位标记</li>\n<li>socket通信的对方关闭连接, 对socket的读操作返回0</li>\n<li>监听socket上有新的连接请求</li>\n<li>socket上有未处理的错误, 可以使用getsockopt来读取和清除错误</li>\n<li>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记</li>\n<li>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</li>\n<li>socket使用非阻塞connect 连接成功或失败后<h2 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h2></li>\n</ul>\n<p><strong>poll</strong><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B1.png\" alt=\"\"><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B2.png\" alt=\"\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;poll.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// fds 结构体类型数组 指定我们感兴趣的文件描述符上发生的可读可写和异常事件\\</span></span><br><span class=\"line\"><span class=\"comment\">// nfds 遍历结合大小 左闭右开</span></span><br><span class=\"line\"><span class=\"comment\">// timeout 单位为毫秒 -1 为阻塞 0 为立即返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">poll</span><span class=\"params\">(struct pollfd* fds, <span class=\"keyword\">nfds_t</span> nfds, <span class=\"keyword\">int</span> timeout)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pollfd</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">\tshort events;  <span class=\"comment\">//注册的事件, 告知poll监听fd上的哪些事件</span></span><br><span class=\"line\">\tshort revents; <span class=\"comment\">// 实际发生的事件</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> exit_if(r, ...) \\</span></span><br><span class=\"line\">&#123;   \\</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r)  \\</span><br><span class=\"line\">    &#123;   \\</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(__VA_ARGS__);    \\</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"errno no: %d, error msg is %s\"</span>, errno, strerror(errno));    \\</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);    \\</span><br><span class=\"line\">    &#125;   \\</span><br><span class=\"line\">&#125;   \\</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">client_info</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ip_;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> port_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> port = <span class=\"number\">8001</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ip[] = <span class=\"string\">\"127.0.0.1\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">address</span>;</span></span><br><span class=\"line\">    address.sin_port = htons(port);</span><br><span class=\"line\">    address.sin_family = AF_INET;</span><br><span class=\"line\">    address.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    exit_if(listenfd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"socket error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = bind(listenfd, (struct sockaddr*)&amp;address, <span class=\"keyword\">sizeof</span>(address));</span><br><span class=\"line\">    exit_if(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"bind error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">listen</span>(listenfd, <span class=\"number\">5</span>);</span><br><span class=\"line\">    exit_if(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"listen error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> MAX_CLIENTS = <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pollfd</span> <span class=\"title\">polls</span>[<span class=\"title\">MAX_CLIENTS</span>] = &#123;</span>&#125;;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">client_info</span> <span class=\"title\">clientsinfo</span>[<span class=\"title\">MAX_CLIENTS</span>] = &#123;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    polls[<span class=\"number\">3</span>].fd = listenfd;</span><br><span class=\"line\">    polls[<span class=\"number\">3</span>].events = POLLIN | POLLRDHUP;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ret = poll(polls, MAX_CLIENTS + <span class=\"number\">1</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">        exit_if(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"poll error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt;= MAX_CLIENTS; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> fd = polls[i].fd;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (polls[i].revents &amp; POLLRDHUP)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                polls[i].events = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"close fd-%d from %s:%d\\n\"</span>, fd, clientsinfo[fd].ip_, clientsinfo[fd].port_);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (polls[i].revents &amp; POLLIN)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (fd == listenfd)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">client_address</span>;</span></span><br><span class=\"line\">                    <span class=\"keyword\">socklen_t</span> client_addresslen = <span class=\"keyword\">sizeof</span>(client_address);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> clientfd = accept(listenfd, (struct sockaddr*)&amp;client_address,</span><br><span class=\"line\">                            &amp;client_addresslen);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">client_info</span> *<span class=\"title\">clientinfo</span> = &amp;<span class=\"title\">clientsinfo</span>[<span class=\"title\">clientfd</span>];</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    clientinfo-&gt;ip_ = inet_ntoa(client_address.sin_addr);</span><br><span class=\"line\">                    clientinfo-&gt;port_ = ntohs(client_address.sin_port);</span><br><span class=\"line\"></span><br><span class=\"line\">                    exit_if(clientfd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"accpet error, from %s:%d\\n\"</span>, clientinfo-&gt;ip_,</span><br><span class=\"line\">                            clientinfo-&gt;port_);</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"accept from %s:%d\\n\"</span>, clientinfo-&gt;ip_, clientinfo-&gt;port_);</span><br><span class=\"line\"></span><br><span class=\"line\">                    polls[clientfd].fd = clientfd;</span><br><span class=\"line\">                    polls[clientfd].events = POLLIN | POLLRDHUP;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">char</span> <span class=\"built_in\">buffer</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">                    <span class=\"built_in\">memset</span>(<span class=\"built_in\">buffer</span>, <span class=\"string\">'\\0'</span>, <span class=\"keyword\">sizeof</span>(<span class=\"built_in\">buffer</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">                    ret = <span class=\"built_in\">read</span>(fd, <span class=\"built_in\">buffer</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(ret == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">\"recv from %s:%d:\\n%s\\n\"</span>, clientsinfo[fd].ip_,</span><br><span class=\"line\">                               clientsinfo[fd].port_, <span class=\"built_in\">buffer</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h2><p><strong>epoll</strong></p>\n<p>epoll是Linux特有的I/O复用函数, 实现上与select,poll有很大的差异</p>\n<ul>\n<li>epoll使用一组函数完成任务</li>\n<li>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中</li>\n<li>epoll无需每次调用都传入文件描述符集或事件集.</li>\n</ul>\n<p>有特定的文件描述符创建函数, 来标识这个事件表<code>epoll_create()</code><br><code>epoll_ctl()</code> 用来操作这个内核事件表<br><code>epoll_wait()</code> 为主要函数 成功返回就绪的文件描述符个数 失败返回-1<br>如果<code>epoll_wait()</code>函数检测到事件,就将所有就绪的事件从内核事件表(由第一个参数, epoll_create返回的结果) 中复制到第二个参数event指向的数组中, 这个数组只用于输出<code>epoll_wait</code>检测到的就绪事件.</p>\n<p><em>event不同于select和poll的数组参数 既用于传入用户注册的事件, 又用于输出内核检测到的就绪事件, 提高了效率</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 索引poll返回的就绪文件描述符</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = poll(fds, MAX_EVENT_NUMBER - <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sockfd = fds[i].fd;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 索引epoll返回的就绪文件描述符</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER,  <span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ret; i++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sockfd = events[i].data.fd;</span><br><span class=\"line\">\t<span class=\"comment\">// sockfd 一定就绪 ?????</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>LT和ET模式</strong><br>LT(电平触发, 默认的工作模式)<br>LT模式下的epoll相当于一个效率较高的poll<br>epoll_wait将会一只通知一个事件知道这个事件被处理</p>\n<p>ET(边沿触发, epoll的高效工作模式)模式<br>当向epoll内核事件表中注册一个文件描述符上的EPOLLET事件的时候, epoll将用ET模式来操作这个<br>文件描述符<br>epoll_wait只会通知一次, 不论这个事件有没有完成</p>\n<p>ET模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; 123456789-123456789-123456789</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of content: 123456789</span><br><span class=\"line\">get 9bytes of content: -12345678</span><br><span class=\"line\">get 9bytes of content: 9-1234567</span><br><span class=\"line\">get 4bytes of content: 89</span><br><span class=\"line\">read later</span><br></pre></td></tr></table></figure>\n<p>LT模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; 123456789-123456789-123456789</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of contents: 123456789</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of contents: -12345678</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of contents: 9-1234567</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 4bytes of contents: 89</span><br></pre></td></tr></table></figure>\n<p>ET模式有任务到来就必须做完, 因为后续将不会继续通知这个事件, 所以ET是epoll的高效工作模式<br>LT模式只要事件没被处理就会一直通知</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;epoll.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// size 参数只是给内核一个提示, 事件表需要多大</span></span><br><span class=\"line\"><span class=\"comment\">// 函数返回其他所有epoll系统调用的第一个参数, 来指定要访问的内核事件表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_create</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">size</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// epfd 为 epoll_create的返回值</span></span><br><span class=\"line\"><span class=\"comment\">// op为操作类型</span></span><br><span class=\"line\"><span class=\"comment\">// - EPOLL_CTL_ADD 向事件表中注册fd上的事件</span></span><br><span class=\"line\"><span class=\"comment\">// - EPOLL_CTL_MOD 修改fd上的注册事件</span></span><br><span class=\"line\"><span class=\"comment\">// - EPOLL_CTL_DEL 删除fd上的注册事件</span></span><br><span class=\"line\"><span class=\"comment\">// fd 为要操作的文件描述符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_ctl</span><span class=\"params\">(<span class=\"keyword\">int</span> epfd, <span class=\"keyword\">int</span> op, <span class=\"keyword\">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">_uint32_t</span> events; <span class=\"comment\">// epoll事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">epoll_data_t</span> data; <span class=\"comment\">// 用户数据 是一个联合体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> epoll_data</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* ptr; <span class=\"comment\">// ptr fd 不能同时使用</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> u32;</span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">&#125;<span class=\"keyword\">epoll_data_t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// maxevents监听事件数 必须大于0</span></span><br><span class=\"line\"><span class=\"comment\">// timeout 为-1 表示阻塞</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回就绪的文件描述符个数 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_wait</span><span class=\"params\">(<span class=\"keyword\">int</span> epfd, struct epoll_event* events, <span class=\"keyword\">int</span> maxevents, <span class=\"keyword\">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三种IO复用的比较\"><a href=\"#三种IO复用的比较\" class=\"headerlink\" title=\"三种IO复用的比较\"></a>三种IO复用的比较</h2><p><code>select</code>以及<code>poll</code>和<code>epoll</code><br>相同</p>\n<ul>\n<li>都能同时监听多个文件描述符, 都将等待timeout参数指定的超时时间, 直到一个或多个文件描述符上有事件发生.</li>\n<li>返回值为就绪的文件描述符数量, 返回0则表示没有事件发生</li>\n<li><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%B8%89%E7%A7%8DIO%E5%A4%8D%E7%94%A8%E6%AF%94%E8%BE%83.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"I-O-复用的高级应用-非阻塞connect\"><a href=\"#I-O-复用的高级应用-非阻塞connect\" class=\"headerlink\" title=\"I/O 复用的高级应用, 非阻塞connect\"></a>I/O 复用的高级应用, 非阻塞connect</h2><p>connect出错的时候会返回一个errno值 EINPROGRESS - 表示对非阻塞socket调用connect, 连接又没有立即建立的时候, 这时可以调用select和poll函数来监听这个连接失败的socket上的可写事件.</p>\n<p>当函数返回的时候, 可以用getsockopt来读取错误码, 并清楚该socket上的错误. 错误码为0表示成功</p>\n<h1 id=\"第十章信号\"><a href=\"#第十章信号\" class=\"headerlink\" title=\"第十章信号\"></a>第十章信号</h1><h2 id=\"Api\"><a href=\"#Api\" class=\"headerlink\" title=\"Api\"></a>Api</h2><p>发送信号Api</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pid &gt; 0 发送给PID为pid标识的进程</span></span><br><span class=\"line\"><span class=\"comment\">//  0 发送给本进程组的其他进程</span></span><br><span class=\"line\"><span class=\"comment\">// -1 发送给进程以外的所有进程, 但发送者需要有对目标进程发送信号的权限</span></span><br><span class=\"line\"><span class=\"comment\">// &lt; -1 发送给组ID为 -pid 的进程组中的所有成员</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出错信息 EINVAL 无效信号, EPERM 该进程没有权限给任何一个目标进程 ESRCH 目标进程(组) 不存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kill</span><span class=\"params\">(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>接收信号Api</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(*<span class=\"keyword\">_sighandler_t</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/signum.h&gt; // 此头文件中有所有的linux可用信号</span></span></span><br><span class=\"line\"><span class=\"comment\">// 忽略目标信号</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIG_DFL ((_sighandler_t) 0)</span></span><br><span class=\"line\"><span class=\"comment\">// 使用信号的默认处理方式</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIG_IGN ((_sighandler_t) 1)</span></span><br></pre></td></tr></table></figure>\n<p>常用信号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SIGHUP 控制终端挂起</span><br><span class=\"line\">SIGPIPE 往读端被关闭的管道或者socket连接中写数据</span><br><span class=\"line\">SIGURG socket连接上收到紧急数据</span><br><span class=\"line\">SIGALRM 由alarm或setitimer设置的实时闹钟超时引起</span><br><span class=\"line\">SIGCHLD 子进程状态变化</span><br></pre></td></tr></table></figure>\n<p>信号函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为一个信号设置处理函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// _handler 指定sig的处理函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">_sighandler_t</span> <span class=\"title\">signal</span><span class=\"params\">(<span class=\"keyword\">int</span> sig, <span class=\"keyword\">__sighandler_t</span> _handler)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sigaction</span><span class=\"params\">(<span class=\"keyword\">int</span> sig, struct sigaction* act, struct sigaction* oact)</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>信号是用户, 系统, 或者进程发送给目标进程的信息, 以通知目标进程某个状态的改变或者系统异常.<br>产生条件</p>\n<ul>\n<li>对于前台进程<br>用户可以通过输入特殊的终端字符来给它发送信号, CTRL+C 通常为一个中断信号 <code>SIGINT</code></li>\n<li>系统异常<br>浮点异常和非法内存段的访问</li>\n<li>系统状态变化<br>由alarm定时器到期将引起<code>SIGALRM</code>信号</li>\n<li>运行kill命令或调用kill函数</li>\n</ul>\n<p><em>服务器必须处理(至少忽略) 一些常见的信号, 以免异常终止</em></p>\n<p>中断系统调用?</p>\n<h1 id=\"第十一章定时器\"><a href=\"#第十一章定时器\" class=\"headerlink\" title=\"第十一章定时器\"></a>第十一章定时器</h1><h2 id=\"socket选项SO-RCVTIMEO-和-SO-SNDTIMEO\"><a href=\"#socket选项SO-RCVTIMEO-和-SO-SNDTIMEO\" class=\"headerlink\" title=\"socket选项SO_RCVTIMEO 和 SO_SNDTIMEO\"></a>socket选项<code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code></h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/SO_RCVTIMEO%E5%92%8CSO_SNDTIMEO%E9%80%89%E9%A1%B9%E7%9A%84%E4%BD%9C%E7%94%A8.png\" alt=\"\"></p>\n<p>使用示例, 通过设置对应的SO_SNDTIMEO 得到超时后的路线</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">timeout_connect</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* ip, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> port, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> sec)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">address</span>&#123;</span>&#125;;</span><br><span class=\"line\">    address.sin_family = AF_INET;</span><br><span class=\"line\">    address.sin_port = htons(port);</span><br><span class=\"line\">    address.sin_addr.s_addr = inet_addr(ip);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    exit_if(sockfd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"socket error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">timeout</span>&#123;</span>&#125;;</span><br><span class=\"line\">    timeout.tv_sec = sec;</span><br><span class=\"line\">    timeout.tv_usec = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">socklen_t</span> timeout_len = <span class=\"keyword\">sizeof</span>(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, timeout_len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"built_in\">connect</span>(sockfd, (struct sockaddr*)&amp;address, <span class=\"keyword\">sizeof</span>(address));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当 errno为EINPROGRESS 说明 等待了 10S后依然无法连接成功 实现了定时器</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINPROGRESS)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"connecting timeout, process timeout logic\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"error occur when connecting to server\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sockfd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    exit_if(argc &lt;= <span class=\"number\">2</span>, <span class=\"string\">\"wrong number of parameters\\n\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* ip = argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> port = atoi(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd = timeout_connect(ip, port, <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sockfd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SIGALRM信号-基于升序链表的定时器\"><a href=\"#SIGALRM信号-基于升序链表的定时器\" class=\"headerlink\" title=\"SIGALRM信号-基于升序链表的定时器\"></a>SIGALRM信号-基于升序链表的定时器</h2><p>由alarm和setitimer函数设定的实时闹钟一旦超时, 将会触发SIGALRM信号, 用信号处理函数处理定时任务<br> 相关的代码放在了github上 代码还是很多的就不放上来了<a href=\"https://github.com/rjd67441/Notes-HighPerformanceLinuxServerProgramming/tree/master/12.%20%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%9511-2%E5%92%8C11-3%E5%8F%8A11-4%20%E9%93%BE%E8%A1%A8%E5%AE%9A%E6%97%B6%E5%99%A8%2C%20%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5\" target=\"_blank\" rel=\"noopener\">连接</a></p>\n<p>总结放在了 日记的博客上 链接后面再甩出来</p>\n<h2 id=\"IO复用系统调用的超时参数\"><a href=\"#IO复用系统调用的超时参数\" class=\"headerlink\" title=\"IO复用系统调用的超时参数\"></a>IO复用系统调用的超时参数</h2><h2 id=\"高性能定时器\"><a href=\"#高性能定时器\" class=\"headerlink\" title=\"高性能定时器\"></a>高性能定时器</h2><h2 id=\"时间轮\"><a href=\"#时间轮\" class=\"headerlink\" title=\"# 时间轮\"></a># 时间轮</h2><h2 id=\"时间堆\"><a href=\"#时间堆\" class=\"headerlink\" title=\"# 时间堆\"></a># 时间堆</h2><h1 id=\"第十二章高性能IO框架库\"><a href=\"#第十二章高性能IO框架库\" class=\"headerlink\" title=\"第十二章高性能IO框架库\"></a>第十二章高性能IO框架库</h1><p>另出一篇博客</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第九章-I-O复用\"><a href=\"#第九章-I-O复用\" class=\"headerlink\" title=\"第九章 I/O复用\"></a>第九章 I/O复用</h1><p>I/O复用使得程序能同时监听多个文件描述符.</p>\n<ul>\n<li>客户端程序需要同时处理多个socket 非阻塞connect技术</li>\n<li>客户端程序同时处理用户输入和网络连接 聊天室程序</li>\n<li>TCP服务器要同时处理监听socket和连接socket</li>\n<li>同时处理TCP和UDP请求 - 回射服务器</li>\n<li>同时监听多个端口, 或者处理多种服务 - xinetd服务器</li>\n</ul>\n<p>常用手段<code>select</code>, <code>poll</code>, <code>epoll</code></p>\n<h2 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/select.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// nfds - 被监听的文件描述符总数</span></span><br><span class=\"line\"><span class=\"comment\">// 后面三个分别指向 可读, 可写, 异常等事件对应的文件描述符集合</span></span><br><span class=\"line\"><span class=\"comment\">// timeval select超时时间 如果传递0 则为非阻塞, 设置为NULL则为阻塞</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回就绪(可读, 可写, 异常)文件描述符的总数, 没有则返回0 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">select</span> <span class=\"params\">(<span class=\"keyword\">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作fd_set的宏</span></span><br><span class=\"line\">FD_ZERO(fd_set* fdset);</span><br><span class=\"line\">FD_SET(<span class=\"keyword\">int</span> fd, fd_set* fdset);</span><br><span class=\"line\">FD_CLR(<span class=\"keyword\">int</span> fd, fd_set* fdset);</span><br><span class=\"line\">FD_ISSET(<span class=\"keyword\">int</span> fd, fd_set* fdset);</span><br><span class=\"line\"><span class=\"comment\">// 设置 timeval 超时时间</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> tv_sec; <span class=\"comment\">// 秒</span></span><br><span class=\"line\">\t<span class=\"keyword\">long</span> tv_usec; <span class=\"comment\">// 微秒</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>select</strong></p>\n<p>文件描述符就绪条件</p>\n<ul>\n<li>socket内核接收缓存区中的字节数大于或等于 其低水位标记</li>\n<li>socket通信的对方关闭连接, 对socket的读操作返回0</li>\n<li>监听socket上有新的连接请求</li>\n<li>socket上有未处理的错误, 可以使用getsockopt来读取和清除错误</li>\n<li>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记</li>\n<li>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</li>\n<li>socket使用非阻塞connect 连接成功或失败后<h2 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h2></li>\n</ul>\n<p><strong>poll</strong><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B1.png\" alt=\"\"><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B2.png\" alt=\"\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;poll.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// fds 结构体类型数组 指定我们感兴趣的文件描述符上发生的可读可写和异常事件\\</span></span><br><span class=\"line\"><span class=\"comment\">// nfds 遍历结合大小 左闭右开</span></span><br><span class=\"line\"><span class=\"comment\">// timeout 单位为毫秒 -1 为阻塞 0 为立即返回</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">poll</span><span class=\"params\">(struct pollfd* fds, <span class=\"keyword\">nfds_t</span> nfds, <span class=\"keyword\">int</span> timeout)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pollfd</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">\tshort events;  <span class=\"comment\">//注册的事件, 告知poll监听fd上的哪些事件</span></span><br><span class=\"line\">\tshort revents; <span class=\"comment\">// 实际发生的事件</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> exit_if(r, ...) \\</span></span><br><span class=\"line\">&#123;   \\</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r)  \\</span><br><span class=\"line\">    &#123;   \\</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(__VA_ARGS__);    \\</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"errno no: %d, error msg is %s\"</span>, errno, strerror(errno));    \\</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);    \\</span><br><span class=\"line\">    &#125;   \\</span><br><span class=\"line\">&#125;   \\</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">client_info</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ip_;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> port_;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> port = <span class=\"number\">8001</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ip[] = <span class=\"string\">\"127.0.0.1\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">address</span>;</span></span><br><span class=\"line\">    address.sin_port = htons(port);</span><br><span class=\"line\">    address.sin_family = AF_INET;</span><br><span class=\"line\">    address.sin_addr.s_addr = htons(INADDR_ANY);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    exit_if(listenfd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"socket error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = bind(listenfd, (struct sockaddr*)&amp;address, <span class=\"keyword\">sizeof</span>(address));</span><br><span class=\"line\">    exit_if(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"bind error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    ret = <span class=\"built_in\">listen</span>(listenfd, <span class=\"number\">5</span>);</span><br><span class=\"line\">    exit_if(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"listen error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">constexpr</span> <span class=\"keyword\">int</span> MAX_CLIENTS = <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">pollfd</span> <span class=\"title\">polls</span>[<span class=\"title\">MAX_CLIENTS</span>] = &#123;</span>&#125;;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">client_info</span> <span class=\"title\">clientsinfo</span>[<span class=\"title\">MAX_CLIENTS</span>] = &#123;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    polls[<span class=\"number\">3</span>].fd = listenfd;</span><br><span class=\"line\">    polls[<span class=\"number\">3</span>].events = POLLIN | POLLRDHUP;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ret = poll(polls, MAX_CLIENTS + <span class=\"number\">1</span>, <span class=\"number\">-1</span>);</span><br><span class=\"line\">        exit_if(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"poll error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">3</span>; i &lt;= MAX_CLIENTS; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> fd = polls[i].fd;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (polls[i].revents &amp; POLLRDHUP)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                polls[i].events = <span class=\"number\">0</span>;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"close fd-%d from %s:%d\\n\"</span>, fd, clientsinfo[fd].ip_, clientsinfo[fd].port_);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (polls[i].revents &amp; POLLIN)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (fd == listenfd)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">client_address</span>;</span></span><br><span class=\"line\">                    <span class=\"keyword\">socklen_t</span> client_addresslen = <span class=\"keyword\">sizeof</span>(client_address);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">int</span> clientfd = accept(listenfd, (struct sockaddr*)&amp;client_address,</span><br><span class=\"line\">                            &amp;client_addresslen);</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">client_info</span> *<span class=\"title\">clientinfo</span> = &amp;<span class=\"title\">clientsinfo</span>[<span class=\"title\">clientfd</span>];</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    clientinfo-&gt;ip_ = inet_ntoa(client_address.sin_addr);</span><br><span class=\"line\">                    clientinfo-&gt;port_ = ntohs(client_address.sin_port);</span><br><span class=\"line\"></span><br><span class=\"line\">                    exit_if(clientfd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"accpet error, from %s:%d\\n\"</span>, clientinfo-&gt;ip_,</span><br><span class=\"line\">                            clientinfo-&gt;port_);</span><br><span class=\"line\">                    <span class=\"built_in\">printf</span>(<span class=\"string\">\"accept from %s:%d\\n\"</span>, clientinfo-&gt;ip_, clientinfo-&gt;port_);</span><br><span class=\"line\"></span><br><span class=\"line\">                    polls[clientfd].fd = clientfd;</span><br><span class=\"line\">                    polls[clientfd].events = POLLIN | POLLRDHUP;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">char</span> <span class=\"built_in\">buffer</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">                    <span class=\"built_in\">memset</span>(<span class=\"built_in\">buffer</span>, <span class=\"string\">'\\0'</span>, <span class=\"keyword\">sizeof</span>(<span class=\"built_in\">buffer</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">                    ret = <span class=\"built_in\">read</span>(fd, <span class=\"built_in\">buffer</span>, <span class=\"number\">1024</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(ret == <span class=\"number\">0</span>)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">printf</span>(<span class=\"string\">\"recv from %s:%d:\\n%s\\n\"</span>, clientsinfo[fd].ip_,</span><br><span class=\"line\">                               clientsinfo[fd].port_, <span class=\"built_in\">buffer</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h2><p><strong>epoll</strong></p>\n<p>epoll是Linux特有的I/O复用函数, 实现上与select,poll有很大的差异</p>\n<ul>\n<li>epoll使用一组函数完成任务</li>\n<li>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中</li>\n<li>epoll无需每次调用都传入文件描述符集或事件集.</li>\n</ul>\n<p>有特定的文件描述符创建函数, 来标识这个事件表<code>epoll_create()</code><br><code>epoll_ctl()</code> 用来操作这个内核事件表<br><code>epoll_wait()</code> 为主要函数 成功返回就绪的文件描述符个数 失败返回-1<br>如果<code>epoll_wait()</code>函数检测到事件,就将所有就绪的事件从内核事件表(由第一个参数, epoll_create返回的结果) 中复制到第二个参数event指向的数组中, 这个数组只用于输出<code>epoll_wait</code>检测到的就绪事件.</p>\n<p><em>event不同于select和poll的数组参数 既用于传入用户注册的事件, 又用于输出内核检测到的就绪事件, 提高了效率</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 索引poll返回的就绪文件描述符</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = poll(fds, MAX_EVENT_NUMBER - <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sockfd = fds[i].fd;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 索引epoll返回的就绪文件描述符</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER,  <span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ret; i++) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sockfd = events[i].data.fd;</span><br><span class=\"line\">\t<span class=\"comment\">// sockfd 一定就绪 ?????</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>LT和ET模式</strong><br>LT(电平触发, 默认的工作模式)<br>LT模式下的epoll相当于一个效率较高的poll<br>epoll_wait将会一只通知一个事件知道这个事件被处理</p>\n<p>ET(边沿触发, epoll的高效工作模式)模式<br>当向epoll内核事件表中注册一个文件描述符上的EPOLLET事件的时候, epoll将用ET模式来操作这个<br>文件描述符<br>epoll_wait只会通知一次, 不论这个事件有没有完成</p>\n<p>ET模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; 123456789-123456789-123456789</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of content: 123456789</span><br><span class=\"line\">get 9bytes of content: -12345678</span><br><span class=\"line\">get 9bytes of content: 9-1234567</span><br><span class=\"line\">get 4bytes of content: 89</span><br><span class=\"line\">read later</span><br></pre></td></tr></table></figure>\n<p>LT模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-&gt; 123456789-123456789-123456789</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of contents: 123456789</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of contents: -12345678</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 9bytes of contents: 9-1234567</span><br><span class=\"line\">event trigger once</span><br><span class=\"line\">get 4bytes of contents: 89</span><br></pre></td></tr></table></figure>\n<p>ET模式有任务到来就必须做完, 因为后续将不会继续通知这个事件, 所以ET是epoll的高效工作模式<br>LT模式只要事件没被处理就会一直通知</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;epoll.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// size 参数只是给内核一个提示, 事件表需要多大</span></span><br><span class=\"line\"><span class=\"comment\">// 函数返回其他所有epoll系统调用的第一个参数, 来指定要访问的内核事件表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_create</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">size</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// epfd 为 epoll_create的返回值</span></span><br><span class=\"line\"><span class=\"comment\">// op为操作类型</span></span><br><span class=\"line\"><span class=\"comment\">// - EPOLL_CTL_ADD 向事件表中注册fd上的事件</span></span><br><span class=\"line\"><span class=\"comment\">// - EPOLL_CTL_MOD 修改fd上的注册事件</span></span><br><span class=\"line\"><span class=\"comment\">// - EPOLL_CTL_DEL 删除fd上的注册事件</span></span><br><span class=\"line\"><span class=\"comment\">// fd 为要操作的文件描述符</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_ctl</span><span class=\"params\">(<span class=\"keyword\">int</span> epfd, <span class=\"keyword\">int</span> op, <span class=\"keyword\">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">_uint32_t</span> events; <span class=\"comment\">// epoll事件</span></span><br><span class=\"line\">\t<span class=\"keyword\">epoll_data_t</span> data; <span class=\"comment\">// 用户数据 是一个联合体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> epoll_data</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">void</span>* ptr; <span class=\"comment\">// ptr fd 不能同时使用</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">\t<span class=\"keyword\">uint32_t</span> u32;</span><br><span class=\"line\">\t<span class=\"keyword\">uint64_t</span> u64;</span><br><span class=\"line\">&#125;<span class=\"keyword\">epoll_data_t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// maxevents监听事件数 必须大于0</span></span><br><span class=\"line\"><span class=\"comment\">// timeout 为-1 表示阻塞</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回就绪的文件描述符个数 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">epoll_wait</span><span class=\"params\">(<span class=\"keyword\">int</span> epfd, struct epoll_event* events, <span class=\"keyword\">int</span> maxevents, <span class=\"keyword\">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三种IO复用的比较\"><a href=\"#三种IO复用的比较\" class=\"headerlink\" title=\"三种IO复用的比较\"></a>三种IO复用的比较</h2><p><code>select</code>以及<code>poll</code>和<code>epoll</code><br>相同</p>\n<ul>\n<li>都能同时监听多个文件描述符, 都将等待timeout参数指定的超时时间, 直到一个或多个文件描述符上有事件发生.</li>\n<li>返回值为就绪的文件描述符数量, 返回0则表示没有事件发生</li>\n<li><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%B8%89%E7%A7%8DIO%E5%A4%8D%E7%94%A8%E6%AF%94%E8%BE%83.png\" alt=\"\"></li>\n</ul>\n<h2 id=\"I-O-复用的高级应用-非阻塞connect\"><a href=\"#I-O-复用的高级应用-非阻塞connect\" class=\"headerlink\" title=\"I/O 复用的高级应用, 非阻塞connect\"></a>I/O 复用的高级应用, 非阻塞connect</h2><p>connect出错的时候会返回一个errno值 EINPROGRESS - 表示对非阻塞socket调用connect, 连接又没有立即建立的时候, 这时可以调用select和poll函数来监听这个连接失败的socket上的可写事件.</p>\n<p>当函数返回的时候, 可以用getsockopt来读取错误码, 并清楚该socket上的错误. 错误码为0表示成功</p>\n<h1 id=\"第十章信号\"><a href=\"#第十章信号\" class=\"headerlink\" title=\"第十章信号\"></a>第十章信号</h1><h2 id=\"Api\"><a href=\"#Api\" class=\"headerlink\" title=\"Api\"></a>Api</h2><p>发送信号Api</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pid &gt; 0 发送给PID为pid标识的进程</span></span><br><span class=\"line\"><span class=\"comment\">//  0 发送给本进程组的其他进程</span></span><br><span class=\"line\"><span class=\"comment\">// -1 发送给进程以外的所有进程, 但发送者需要有对目标进程发送信号的权限</span></span><br><span class=\"line\"><span class=\"comment\">// &lt; -1 发送给组ID为 -pid 的进程组中的所有成员</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出错信息 EINVAL 无效信号, EPERM 该进程没有权限给任何一个目标进程 ESRCH 目标进程(组) 不存在</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kill</span><span class=\"params\">(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>接收信号Api</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">void</span><span class=\"params\">(*<span class=\"keyword\">_sighandler_t</span>)</span> <span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/signum.h&gt; // 此头文件中有所有的linux可用信号</span></span></span><br><span class=\"line\"><span class=\"comment\">// 忽略目标信号</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIG_DFL ((_sighandler_t) 0)</span></span><br><span class=\"line\"><span class=\"comment\">// 使用信号的默认处理方式</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SIG_IGN ((_sighandler_t) 1)</span></span><br></pre></td></tr></table></figure>\n<p>常用信号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SIGHUP 控制终端挂起</span><br><span class=\"line\">SIGPIPE 往读端被关闭的管道或者socket连接中写数据</span><br><span class=\"line\">SIGURG socket连接上收到紧急数据</span><br><span class=\"line\">SIGALRM 由alarm或setitimer设置的实时闹钟超时引起</span><br><span class=\"line\">SIGCHLD 子进程状态变化</span><br></pre></td></tr></table></figure>\n<p>信号函数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为一个信号设置处理函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;signal.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// _handler 指定sig的处理函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">_sighandler_t</span> <span class=\"title\">signal</span><span class=\"params\">(<span class=\"keyword\">int</span> sig, <span class=\"keyword\">__sighandler_t</span> _handler)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sigaction</span><span class=\"params\">(<span class=\"keyword\">int</span> sig, struct sigaction* act, struct sigaction* oact)</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>信号是用户, 系统, 或者进程发送给目标进程的信息, 以通知目标进程某个状态的改变或者系统异常.<br>产生条件</p>\n<ul>\n<li>对于前台进程<br>用户可以通过输入特殊的终端字符来给它发送信号, CTRL+C 通常为一个中断信号 <code>SIGINT</code></li>\n<li>系统异常<br>浮点异常和非法内存段的访问</li>\n<li>系统状态变化<br>由alarm定时器到期将引起<code>SIGALRM</code>信号</li>\n<li>运行kill命令或调用kill函数</li>\n</ul>\n<p><em>服务器必须处理(至少忽略) 一些常见的信号, 以免异常终止</em></p>\n<p>中断系统调用?</p>\n<h1 id=\"第十一章定时器\"><a href=\"#第十一章定时器\" class=\"headerlink\" title=\"第十一章定时器\"></a>第十一章定时器</h1><h2 id=\"socket选项SO-RCVTIMEO-和-SO-SNDTIMEO\"><a href=\"#socket选项SO-RCVTIMEO-和-SO-SNDTIMEO\" class=\"headerlink\" title=\"socket选项SO_RCVTIMEO 和 SO_SNDTIMEO\"></a>socket选项<code>SO_RCVTIMEO</code> 和 <code>SO_SNDTIMEO</code></h2><p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/SO_RCVTIMEO%E5%92%8CSO_SNDTIMEO%E9%80%89%E9%A1%B9%E7%9A%84%E4%BD%9C%E7%94%A8.png\" alt=\"\"></p>\n<p>使用示例, 通过设置对应的SO_SNDTIMEO 得到超时后的路线</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">timeout_connect</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* ip, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> port, <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> sec)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sockaddr_in</span> <span class=\"title\">address</span>&#123;</span>&#125;;</span><br><span class=\"line\">    address.sin_family = AF_INET;</span><br><span class=\"line\">    address.sin_port = htons(port);</span><br><span class=\"line\">    address.sin_addr.s_addr = inet_addr(ip);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class=\"number\">0</span>);</span><br><span class=\"line\">    exit_if(sockfd &lt; <span class=\"number\">0</span>, <span class=\"string\">\"socket error\\n\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timeval</span> <span class=\"title\">timeout</span>&#123;</span>&#125;;</span><br><span class=\"line\">    timeout.tv_sec = sec;</span><br><span class=\"line\">    timeout.tv_usec = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">socklen_t</span> timeout_len = <span class=\"keyword\">sizeof</span>(timeout);</span><br><span class=\"line\"></span><br><span class=\"line\">    setsockopt(sockfd, SOL_SOCKET, SO_SNDTIMEO, &amp;timeout, timeout_len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> ret = <span class=\"built_in\">connect</span>(sockfd, (struct sockaddr*)&amp;address, <span class=\"keyword\">sizeof</span>(address));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ret == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 当 errno为EINPROGRESS 说明 等待了 10S后依然无法连接成功 实现了定时器</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (errno == EINPROGRESS)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"connecting timeout, process timeout logic\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"error occur when connecting to server\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sockfd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>* argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    exit_if(argc &lt;= <span class=\"number\">2</span>, <span class=\"string\">\"wrong number of parameters\\n\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* ip = argv[<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> port = atoi(argv[<span class=\"number\">2</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> sockfd = timeout_connect(ip, port, <span class=\"number\">10</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sockfd &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SIGALRM信号-基于升序链表的定时器\"><a href=\"#SIGALRM信号-基于升序链表的定时器\" class=\"headerlink\" title=\"SIGALRM信号-基于升序链表的定时器\"></a>SIGALRM信号-基于升序链表的定时器</h2><p>由alarm和setitimer函数设定的实时闹钟一旦超时, 将会触发SIGALRM信号, 用信号处理函数处理定时任务<br> 相关的代码放在了github上 代码还是很多的就不放上来了<a href=\"https://github.com/rjd67441/Notes-HighPerformanceLinuxServerProgramming/tree/master/12.%20%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%9511-2%E5%92%8C11-3%E5%8F%8A11-4%20%E9%93%BE%E8%A1%A8%E5%AE%9A%E6%97%B6%E5%99%A8%2C%20%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5\" target=\"_blank\" rel=\"noopener\">连接</a></p>\n<p>总结放在了 日记的博客上 链接后面再甩出来</p>\n<h2 id=\"IO复用系统调用的超时参数\"><a href=\"#IO复用系统调用的超时参数\" class=\"headerlink\" title=\"IO复用系统调用的超时参数\"></a>IO复用系统调用的超时参数</h2><h2 id=\"高性能定时器\"><a href=\"#高性能定时器\" class=\"headerlink\" title=\"高性能定时器\"></a>高性能定时器</h2><h2 id=\"时间轮\"><a href=\"#时间轮\" class=\"headerlink\" title=\"# 时间轮\"></a># 时间轮</h2><h2 id=\"时间堆\"><a href=\"#时间堆\" class=\"headerlink\" title=\"# 时间堆\"></a># 时间堆</h2><h1 id=\"第十二章高性能IO框架库\"><a href=\"#第十二章高性能IO框架库\" class=\"headerlink\" title=\"第十二章高性能IO框架库\"></a>第十二章高性能IO框架库</h1><p>另出一篇博客</p>\n"},{"title":"Effective读书记录","date":"2020-02-26T13:43:46.000Z","top":110,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Effective%20C%2B%2B/%E5%B0%81%E9%9D%A2.jpg","_content":"\n# 让自己习惯C++\n## 条款02 尽量用const, enum, inline 替换#define\n前言 我目前自己做的框架中大量用了#define.... 因为用enum涉及到转换才能到int. 来学习下这条\n\n**使用 const 常量来替换 #define**\n谨防机号表出错, 特殊情况下 还能减少字量\n\n#define无法限定作用域, 这点我已经感受到了\n\n定义C风格常量字符串\nconst char* const NAME = \"lsmg\"; 防止指向和指向内容改变\n定义C++风格常量字符串\nconst std::string NAME = \"lsmg\";\n\nclass专属常量, 使用如下方式. 可以限定作用域\n```c++\nclass Game\n{\nprivate:\n\tstatic const int MAX_ROOM = 10000; // 常量声明式 - 常量且只有一份\n\tGameroom* rooms[MAX_ROOM];\n}\n```\n如果要获取class专属常量的地址, 或者需要定义式. 则需要在`实现文件`而非`头文件`, 如下声明\n`const int Game::MAX_ROOM` - 未给定初值\n由于class常量已经在声明时获得初值, 所以不用在给定初值\n\n这里我发现一件事情, 这本书 不能只读一遍, 最少两边完整的\n前面就已经开始使用后面的条款了, 先着重本条款, 跨条款的等第二遍\n\n\n## 条款03 尽可能使用const\n**总结**\n- 将某些东西声明为const可帮助编译器探测到错误用法\nconst可以用作在任何作用域内的对象, 函数参数, 函数返回类型, 成员函数本体\n\n\n```c++\nchar greeting[] = \"Hello\";\nchar *p = greeting;\n// const 在 * 左边 被指物是常量 在右边自己是常量 两边都是常量\nconst char *p = greeting; // 指针指向可以变, 指向的值不能变\nchar* const p = greeting; // 指针指向不可以变, 指向的值可以变\nconst char* const p = greeting; // 都不可以变\n```\n**const 参数, 可你帮你检查 == 被写成=的情况**\n这本书看来挺有意思的2333333\n\n**const 函数, 这里看不太懂 没有原来如此的感觉**\n\n## 条款04 确定对象使用前已经被初始化\n**总结**\n- 为内置型对象进行手工初始化.\n- 构造函数对号食用成员初值列, 不要在构造函数中赋值. 初值列次数应该与声明次序相同\n- 为了免除 跨编译单元的初始化次数问题, 用`local static`对象替换`non-local static`对象\n\n永远在使用对象前, 进行初始化.\n在构造函数中, 对所有值进行初始化\n构造函数使用`成员初始列`进行`初始化操作`而非`赋值操作`\n\n\n**减少default构造函数不必要的调用**\n```c++\nClass A\n{\npublic:\n\tA(const std::string &name, const std::list<Gameroom> &room_list);\nprivate:\n\tstd::string name_;\n\tstd::list<Gameroom> room_list_;\n\tint roomnum_;\n}\n\nA::A(const std::string &name, const std::list<Gameroom> &room_list)\n{\n\tname_ = name; // 这些都是赋值 不是初始化\n\troom_list_ = room_list;\n\troomnum_ = 0;\n}\n// C++规定 对象的 成员变量  初始化动作  发生在  进入构造函数本体  之前\n// name_  room_list_  两个在构造函数中被赋值, 而初始化在进入构造函数之前\n// ---发生在这些成员的default构造函数被调用的时候, (发生在进入构造函数前)\n// ---roomnum_例外 int属于内置类型\n\n```\n上面的初始化方式, 浪费了default的构造函数 所以推荐使用下面的形式\n```c++\nA::A(const std::string &name, const std::list<Gameroom> &room_list)\n\t:name_(name), room_list_(room_list), roomnum_(0)\n{\n}\n```\n虽然最终结果相同, 但没有浪费default构造函数. 前两个调用的copy构造函数.\n\n**还可以使用成员初值列 来default构造一个成员变量.**\n```c++\nA::A()\n\t:name_(), room_list_(), roomnum_(0)\n{ // 前两个全部调用的default构造函数\n}\n```\n\n**const reference 内置类型(初始化与赋值等成本) 一定成员初始值列**\n\n**初始值列总是使用 声明次序进行初始化, 而非写的顺序, 所以最好按声明次序列出**\n\n**不同编译单元内定义之 non-local static对象 的初始化 次序**\nstatic对象: 虚构函数会在main() 结束时被自动调用\nlocal static对象: 函数内的static对象\nnon-local对象: 其他static对象\n\n编译单元: 产出单一目标文件的那些源码, 基本是单一源码文件和他包含的头文件\n\n```c++\n// filesystem.h\nclass FileSystem\n{\npublic:\n\tstd::size_t GetNum() const;\n}\nextern FIieSystem tfs;\n\n// directory.h\nclass Directory\n{\npublic:\n\tDirectory(params);\t\n}\nDirectory::Directory(params)\n{\n\tstd::size_t num = tfs.GetNum(); // 使用tfs对象\n}\n\n// main.cpp\nDirectory temp_dir(params);\n```\n只有当 tfs在temp_dir初始化之前被初始化 才能得到正确的结果. 否则会调用未初始化的对象\n\n但是这个次序无法保证\n因为C++ 对这种情况没有明确定义\n\n如何解决这个问题呢??\n将每个`non-local static`对象搬到自己的专属函数内(该对象在此函数内被声明为static)\n函数返回一个reference对象他所包含的对象\n用户调用这个函数而不是直接调用对象\n\n解决的原因呢?\nC++ 保证函数内的`local static`对象 会在`函数被调用期间`, `首次遇到该对象的定义式`被初始化\n\n```c++\n// filesystem.h\nclass FileSystem\n{\npublic:\n\tstd::size_t GetNum() const;\n}\nFileSystem& tfs()\n{\n\tstatic FileSystem fs;\n\treturn fs;\n}\n\n// directory.h\nclass Directory\n{\npublic:\n\tDirectory(params);\t\n}\nDirectory::Directory(params)\n{\n\tstd::size_t num = tfs().GetNum(); // 使用tfs对象\n}\nDirectory& temp_dir()\n{\n\tstatic Directory td;\n\treturn td;\n}\n```\n# 构造析构赋值运算\n## 条款0506 了解C++默认编写并调用哪些函数 并适当拒绝\n\n**夹带如下私货-public-inline**\n- 一个构造函数(如果你没有任何构造函数)\n- 一个拷贝构造函数\n- 一个析构函数\n- 一个拷贝\n\n拷贝构造函数和拷贝运算符 自动生成的只是单纯的将来源对象的每一个`non-static`成员变量\n拷贝到目标对象\n\n**遇到const 和 引用成员 默认的拷贝无法工作, 编译器会发出警告**\n\n**将不需要的成员函数声明为private, 并且不实现**\n\n## 条款07 为多态基类声明virtual析构函数\n返回指向子类的 父类型指针.\n如果delete这个指针, 在父类析构函数不是virtual的情况下, 很可能会导致\n父类的成分被销毁, 然而子类多出来的部分不被销毁. 造成局部销毁!!\n\n**防止局部销毁很简单, 将父类的析构函数声明为virtual**\n\n**任何class 只要带有virtual函数 几乎确定应该有一个virtual析构函数**\n\n**无端的声明virtual函数是错误的**\n如果class不含virtual函数, 通常表示这个class 不是想做为父类, 这时如果将其析构函数声明为virual\n是一个馊主意.............\n\n*class类的大小 = 成员变量占据大小 + vptr(vitual table pointer)指针大小(4~8 字节)*\n\n每一个带有virtual函数的class都有对应的vtbl\n\n当对象调用某一vitual函数的时候, 实际调用的函数取决于\nvptr(vitual table pointer)指针指向的vtbl(vitual table)\n\n无端的使用virtual函数 会导致占用空间的增大\n\n## 条款08 别让异常逃离析构函数\n\n**总结**\n- 析构函数绝对不要抛出异常, 如果被析构函数调用的函数可能抛出异常, 析构函数应该捕获所有异常\n然后吞下它们, 或者结束程序\n- 如果客户需要对某个操作函数运行期间抛出的异常做出反应, class应该提供一个普通函数(而非在析构函数中)\n执行操作\n\n**析构函数不要抛出异常**\n```c++\nclass Widget\n{\n\t...\n\t~Widget() {...}\n}\n\nvoid Foo()\n{\n\tstd::vector<Widget> v;\n}\n```\n当 `v`被销毁的时候, Widget的析构函数第一次抛出异常C++还能接受?\n第二次就会造成不明确行为\n\n## 条款09: 绝不在构造函数和析构过程中调用virtual函数\n**总结**\n- 在构造和析构期间不要调用virtual函数, 因为这类调用从不下降到`子类`\n\n```c++\nclass Transaction\n{\npublic:\n\tTransaction();\n\tvirtual void LogTransaction() const = 0;\n\t...\n}\nTransaction::Transaction()\n{\n\t...\n\tLogTransaction();\n}\n\nclass BuyTransaction: public Transaction\n{\npublic:\n\tvirtual void LogTransaction() const;\n\t...\n}\n\nclass SellTransaction: public Transaction\n{\npublic:\n\tvirtual void LogTransaction() const;\n\t...\n}\n\nBuyTransaction b;\n```\nBuyTransaction的构造函数会被调用, 但是父类的构造函数会更显被调用.\n然后父类构造函数调用`LogTransaction()`的版本是`父类`的版本!!! 不是子类的版本\n\n析构函数也是同样的道理, 当`子类`的析构函数执行后, `子类`中的属性值就成为未定义状态\n进入`父类`后对象就成为一个`父类`对象\n\n本例子中既然无法实现使用`virtual`函数从`父类`向下调用, 可以再构造期间, 将\n`子类`必要的构造信息向上传给`父类`的构造函数\n\n## 条款10: 另operator= 返回一个reference to *this\n\n注意这只是一个协议, 并无强制性. 如果不遵守代码依然可以通过编译, 然而这份 协议被所有内置类型\n和标准程序库提供的类型共同遵守.\n因此除非你有一个标新立异的好理由, 不然还是随众吧\n\n## 条款11: 在operator= 中处理\"自我赋值\"\n**总结**\n- 确保当对象自我赋值时operator=有良好的的行为. 其中技术包括比较\"来源对象\"\n和\"目标对象\"的地址, 精心周到的语句顺序, 以及copy-and-swap\n- 确认任何函数如果操作一个以上的对象, 而其中多个对象是同一个对象的时候, 进行仍未正确\n\n\n**自我赋值是什么**\n\n```c++\nclass Widget {...};\nWidget w;\n\nw=w; // 什么这个看起来不可能, 那下面呢?\n\na[i] = a[j]; // 这个怎么样?  潜在的自我赋值\n*px = *py // 这个呢? 潜在的自我赋值\n```\n**会出现的问题**\n```c++\nclass Gameroom{....};\nclass Game\n{\n\t...\nprivate:\n\tGameroom* room_;\n}\n\n// operator=的实现代码\nGame& Game::operator=(const Game& ths)\n{\n\tdelete room_;\n\troom_ = new Gameroom(*ths.room_);\n\treturn *this;\n}\n```\n上面的代码 如果 this和ths指向同一个对象就会造成 `room_`构造失败\n因为被`delete`的`room_`就是要传入的\n\n如何解决这个问题呢?\n*比较来源对象 整同测试*\n```c++\nGame& Game::operator=(const Game& ths)\n{\n\tif (this == &ths)\n\t{\n\t\treturn *this;\n\t}\n\tdelete room_;\n\troom_ = new Gameroom(*ths.room_);\n\treturn *this;\n}\n```\n但是如果 `new Gameroom(*ths.room_)`错误, 导致room_指向不安全的内存\n使用下面的代码, 可以导出异常安全, 以及自我赋值\n```c++\nGame& Game::operator=(const Game& ths)\n{\n\tGameroom* p_room = room_;\n\troom_ = new Gameroom(*ths.room_);\n\tdelete p_room;\n\tretutn *this;\n}\n```\n现在如果`new Gameroom`抛出异常, room_还可以保持原状.\n同时也能处理自我赋值\n\n*copy and swap*\n这一段描述我看完之后, 突然想到了上午看的Jsoncpp里面的代码!!!!! 就有这个\n下面的代码更加高效 但是牺牲了清晰性\n```c++\nclass Game\n{\n\tvoid swap(Game& rhs);\n}\nGame& Game::operator=(const Game& ths)\n{\n\tGame temp(this);\n\tswap(temp);\n\treturn *this;\n}\n```\n## 条款12: 复制对象时勿忘其每一个成分\n\n\n# 设计与声明\n\n## 条款19: 设计class犹如设计type\n\n如何设计高效的classes呢?\n- 新class的对象该如何被创建和销毁? 这会影响到构造析构函数内存分配释放函数\n- 对象的初始化和对象的赋值有什么样的差别? 决定构造函数和赋值运算符的行为.\n搞清初始化和赋值\n- 注意class对象被值传递 拷贝构造函数会被调用用来生成临时对象\n- 什么是新class的合法值? `setter`函数需要进行的范围检查\n- 你的新class需要配合某个继承图系吗? // TODO\n- 你的新class需要什么样的转换? 如果需要类型转换需要在class中编写`类型转换函数`\n- 什么样的操作运算符和函数对此class而言是合理的? 决定你为class声明哪些函数(条款 23 24 46)\n- 将需要驳回的标准函数设置为private\n- 你的新type有多么一般化? 或许应该定义一整个class家族. 也许模板能帮你\n\n","source":"_posts/CPP-读书记录110-Effective读书记录.md","raw":"---\ntitle: Effective读书记录\ndate: 2020-02-26 21:43:46\ntags:\ncategories:\n - CPP\n - 服务器编程-书籍记录\ntop: 110\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/Effective%20C%2B%2B/%E5%B0%81%E9%9D%A2.jpg\n---\n\n# 让自己习惯C++\n## 条款02 尽量用const, enum, inline 替换#define\n前言 我目前自己做的框架中大量用了#define.... 因为用enum涉及到转换才能到int. 来学习下这条\n\n**使用 const 常量来替换 #define**\n谨防机号表出错, 特殊情况下 还能减少字量\n\n#define无法限定作用域, 这点我已经感受到了\n\n定义C风格常量字符串\nconst char* const NAME = \"lsmg\"; 防止指向和指向内容改变\n定义C++风格常量字符串\nconst std::string NAME = \"lsmg\";\n\nclass专属常量, 使用如下方式. 可以限定作用域\n```c++\nclass Game\n{\nprivate:\n\tstatic const int MAX_ROOM = 10000; // 常量声明式 - 常量且只有一份\n\tGameroom* rooms[MAX_ROOM];\n}\n```\n如果要获取class专属常量的地址, 或者需要定义式. 则需要在`实现文件`而非`头文件`, 如下声明\n`const int Game::MAX_ROOM` - 未给定初值\n由于class常量已经在声明时获得初值, 所以不用在给定初值\n\n这里我发现一件事情, 这本书 不能只读一遍, 最少两边完整的\n前面就已经开始使用后面的条款了, 先着重本条款, 跨条款的等第二遍\n\n\n## 条款03 尽可能使用const\n**总结**\n- 将某些东西声明为const可帮助编译器探测到错误用法\nconst可以用作在任何作用域内的对象, 函数参数, 函数返回类型, 成员函数本体\n\n\n```c++\nchar greeting[] = \"Hello\";\nchar *p = greeting;\n// const 在 * 左边 被指物是常量 在右边自己是常量 两边都是常量\nconst char *p = greeting; // 指针指向可以变, 指向的值不能变\nchar* const p = greeting; // 指针指向不可以变, 指向的值可以变\nconst char* const p = greeting; // 都不可以变\n```\n**const 参数, 可你帮你检查 == 被写成=的情况**\n这本书看来挺有意思的2333333\n\n**const 函数, 这里看不太懂 没有原来如此的感觉**\n\n## 条款04 确定对象使用前已经被初始化\n**总结**\n- 为内置型对象进行手工初始化.\n- 构造函数对号食用成员初值列, 不要在构造函数中赋值. 初值列次数应该与声明次序相同\n- 为了免除 跨编译单元的初始化次数问题, 用`local static`对象替换`non-local static`对象\n\n永远在使用对象前, 进行初始化.\n在构造函数中, 对所有值进行初始化\n构造函数使用`成员初始列`进行`初始化操作`而非`赋值操作`\n\n\n**减少default构造函数不必要的调用**\n```c++\nClass A\n{\npublic:\n\tA(const std::string &name, const std::list<Gameroom> &room_list);\nprivate:\n\tstd::string name_;\n\tstd::list<Gameroom> room_list_;\n\tint roomnum_;\n}\n\nA::A(const std::string &name, const std::list<Gameroom> &room_list)\n{\n\tname_ = name; // 这些都是赋值 不是初始化\n\troom_list_ = room_list;\n\troomnum_ = 0;\n}\n// C++规定 对象的 成员变量  初始化动作  发生在  进入构造函数本体  之前\n// name_  room_list_  两个在构造函数中被赋值, 而初始化在进入构造函数之前\n// ---发生在这些成员的default构造函数被调用的时候, (发生在进入构造函数前)\n// ---roomnum_例外 int属于内置类型\n\n```\n上面的初始化方式, 浪费了default的构造函数 所以推荐使用下面的形式\n```c++\nA::A(const std::string &name, const std::list<Gameroom> &room_list)\n\t:name_(name), room_list_(room_list), roomnum_(0)\n{\n}\n```\n虽然最终结果相同, 但没有浪费default构造函数. 前两个调用的copy构造函数.\n\n**还可以使用成员初值列 来default构造一个成员变量.**\n```c++\nA::A()\n\t:name_(), room_list_(), roomnum_(0)\n{ // 前两个全部调用的default构造函数\n}\n```\n\n**const reference 内置类型(初始化与赋值等成本) 一定成员初始值列**\n\n**初始值列总是使用 声明次序进行初始化, 而非写的顺序, 所以最好按声明次序列出**\n\n**不同编译单元内定义之 non-local static对象 的初始化 次序**\nstatic对象: 虚构函数会在main() 结束时被自动调用\nlocal static对象: 函数内的static对象\nnon-local对象: 其他static对象\n\n编译单元: 产出单一目标文件的那些源码, 基本是单一源码文件和他包含的头文件\n\n```c++\n// filesystem.h\nclass FileSystem\n{\npublic:\n\tstd::size_t GetNum() const;\n}\nextern FIieSystem tfs;\n\n// directory.h\nclass Directory\n{\npublic:\n\tDirectory(params);\t\n}\nDirectory::Directory(params)\n{\n\tstd::size_t num = tfs.GetNum(); // 使用tfs对象\n}\n\n// main.cpp\nDirectory temp_dir(params);\n```\n只有当 tfs在temp_dir初始化之前被初始化 才能得到正确的结果. 否则会调用未初始化的对象\n\n但是这个次序无法保证\n因为C++ 对这种情况没有明确定义\n\n如何解决这个问题呢??\n将每个`non-local static`对象搬到自己的专属函数内(该对象在此函数内被声明为static)\n函数返回一个reference对象他所包含的对象\n用户调用这个函数而不是直接调用对象\n\n解决的原因呢?\nC++ 保证函数内的`local static`对象 会在`函数被调用期间`, `首次遇到该对象的定义式`被初始化\n\n```c++\n// filesystem.h\nclass FileSystem\n{\npublic:\n\tstd::size_t GetNum() const;\n}\nFileSystem& tfs()\n{\n\tstatic FileSystem fs;\n\treturn fs;\n}\n\n// directory.h\nclass Directory\n{\npublic:\n\tDirectory(params);\t\n}\nDirectory::Directory(params)\n{\n\tstd::size_t num = tfs().GetNum(); // 使用tfs对象\n}\nDirectory& temp_dir()\n{\n\tstatic Directory td;\n\treturn td;\n}\n```\n# 构造析构赋值运算\n## 条款0506 了解C++默认编写并调用哪些函数 并适当拒绝\n\n**夹带如下私货-public-inline**\n- 一个构造函数(如果你没有任何构造函数)\n- 一个拷贝构造函数\n- 一个析构函数\n- 一个拷贝\n\n拷贝构造函数和拷贝运算符 自动生成的只是单纯的将来源对象的每一个`non-static`成员变量\n拷贝到目标对象\n\n**遇到const 和 引用成员 默认的拷贝无法工作, 编译器会发出警告**\n\n**将不需要的成员函数声明为private, 并且不实现**\n\n## 条款07 为多态基类声明virtual析构函数\n返回指向子类的 父类型指针.\n如果delete这个指针, 在父类析构函数不是virtual的情况下, 很可能会导致\n父类的成分被销毁, 然而子类多出来的部分不被销毁. 造成局部销毁!!\n\n**防止局部销毁很简单, 将父类的析构函数声明为virtual**\n\n**任何class 只要带有virtual函数 几乎确定应该有一个virtual析构函数**\n\n**无端的声明virtual函数是错误的**\n如果class不含virtual函数, 通常表示这个class 不是想做为父类, 这时如果将其析构函数声明为virual\n是一个馊主意.............\n\n*class类的大小 = 成员变量占据大小 + vptr(vitual table pointer)指针大小(4~8 字节)*\n\n每一个带有virtual函数的class都有对应的vtbl\n\n当对象调用某一vitual函数的时候, 实际调用的函数取决于\nvptr(vitual table pointer)指针指向的vtbl(vitual table)\n\n无端的使用virtual函数 会导致占用空间的增大\n\n## 条款08 别让异常逃离析构函数\n\n**总结**\n- 析构函数绝对不要抛出异常, 如果被析构函数调用的函数可能抛出异常, 析构函数应该捕获所有异常\n然后吞下它们, 或者结束程序\n- 如果客户需要对某个操作函数运行期间抛出的异常做出反应, class应该提供一个普通函数(而非在析构函数中)\n执行操作\n\n**析构函数不要抛出异常**\n```c++\nclass Widget\n{\n\t...\n\t~Widget() {...}\n}\n\nvoid Foo()\n{\n\tstd::vector<Widget> v;\n}\n```\n当 `v`被销毁的时候, Widget的析构函数第一次抛出异常C++还能接受?\n第二次就会造成不明确行为\n\n## 条款09: 绝不在构造函数和析构过程中调用virtual函数\n**总结**\n- 在构造和析构期间不要调用virtual函数, 因为这类调用从不下降到`子类`\n\n```c++\nclass Transaction\n{\npublic:\n\tTransaction();\n\tvirtual void LogTransaction() const = 0;\n\t...\n}\nTransaction::Transaction()\n{\n\t...\n\tLogTransaction();\n}\n\nclass BuyTransaction: public Transaction\n{\npublic:\n\tvirtual void LogTransaction() const;\n\t...\n}\n\nclass SellTransaction: public Transaction\n{\npublic:\n\tvirtual void LogTransaction() const;\n\t...\n}\n\nBuyTransaction b;\n```\nBuyTransaction的构造函数会被调用, 但是父类的构造函数会更显被调用.\n然后父类构造函数调用`LogTransaction()`的版本是`父类`的版本!!! 不是子类的版本\n\n析构函数也是同样的道理, 当`子类`的析构函数执行后, `子类`中的属性值就成为未定义状态\n进入`父类`后对象就成为一个`父类`对象\n\n本例子中既然无法实现使用`virtual`函数从`父类`向下调用, 可以再构造期间, 将\n`子类`必要的构造信息向上传给`父类`的构造函数\n\n## 条款10: 另operator= 返回一个reference to *this\n\n注意这只是一个协议, 并无强制性. 如果不遵守代码依然可以通过编译, 然而这份 协议被所有内置类型\n和标准程序库提供的类型共同遵守.\n因此除非你有一个标新立异的好理由, 不然还是随众吧\n\n## 条款11: 在operator= 中处理\"自我赋值\"\n**总结**\n- 确保当对象自我赋值时operator=有良好的的行为. 其中技术包括比较\"来源对象\"\n和\"目标对象\"的地址, 精心周到的语句顺序, 以及copy-and-swap\n- 确认任何函数如果操作一个以上的对象, 而其中多个对象是同一个对象的时候, 进行仍未正确\n\n\n**自我赋值是什么**\n\n```c++\nclass Widget {...};\nWidget w;\n\nw=w; // 什么这个看起来不可能, 那下面呢?\n\na[i] = a[j]; // 这个怎么样?  潜在的自我赋值\n*px = *py // 这个呢? 潜在的自我赋值\n```\n**会出现的问题**\n```c++\nclass Gameroom{....};\nclass Game\n{\n\t...\nprivate:\n\tGameroom* room_;\n}\n\n// operator=的实现代码\nGame& Game::operator=(const Game& ths)\n{\n\tdelete room_;\n\troom_ = new Gameroom(*ths.room_);\n\treturn *this;\n}\n```\n上面的代码 如果 this和ths指向同一个对象就会造成 `room_`构造失败\n因为被`delete`的`room_`就是要传入的\n\n如何解决这个问题呢?\n*比较来源对象 整同测试*\n```c++\nGame& Game::operator=(const Game& ths)\n{\n\tif (this == &ths)\n\t{\n\t\treturn *this;\n\t}\n\tdelete room_;\n\troom_ = new Gameroom(*ths.room_);\n\treturn *this;\n}\n```\n但是如果 `new Gameroom(*ths.room_)`错误, 导致room_指向不安全的内存\n使用下面的代码, 可以导出异常安全, 以及自我赋值\n```c++\nGame& Game::operator=(const Game& ths)\n{\n\tGameroom* p_room = room_;\n\troom_ = new Gameroom(*ths.room_);\n\tdelete p_room;\n\tretutn *this;\n}\n```\n现在如果`new Gameroom`抛出异常, room_还可以保持原状.\n同时也能处理自我赋值\n\n*copy and swap*\n这一段描述我看完之后, 突然想到了上午看的Jsoncpp里面的代码!!!!! 就有这个\n下面的代码更加高效 但是牺牲了清晰性\n```c++\nclass Game\n{\n\tvoid swap(Game& rhs);\n}\nGame& Game::operator=(const Game& ths)\n{\n\tGame temp(this);\n\tswap(temp);\n\treturn *this;\n}\n```\n## 条款12: 复制对象时勿忘其每一个成分\n\n\n# 设计与声明\n\n## 条款19: 设计class犹如设计type\n\n如何设计高效的classes呢?\n- 新class的对象该如何被创建和销毁? 这会影响到构造析构函数内存分配释放函数\n- 对象的初始化和对象的赋值有什么样的差别? 决定构造函数和赋值运算符的行为.\n搞清初始化和赋值\n- 注意class对象被值传递 拷贝构造函数会被调用用来生成临时对象\n- 什么是新class的合法值? `setter`函数需要进行的范围检查\n- 你的新class需要配合某个继承图系吗? // TODO\n- 你的新class需要什么样的转换? 如果需要类型转换需要在class中编写`类型转换函数`\n- 什么样的操作运算符和函数对此class而言是合理的? 决定你为class声明哪些函数(条款 23 24 46)\n- 将需要驳回的标准函数设置为private\n- 你的新type有多么一般化? 或许应该定义一整个class家族. 也许模板能帮你\n\n","slug":"CPP-读书记录110-Effective读书记录","published":1,"updated":"2020-03-06T14:15:24.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucv400198cuofwqt72c2","content":"<h1 id=\"让自己习惯C\"><a href=\"#让自己习惯C\" class=\"headerlink\" title=\"让自己习惯C++\"></a>让自己习惯C++</h1><h2 id=\"条款02-尽量用const-enum-inline-替换-define\"><a href=\"#条款02-尽量用const-enum-inline-替换-define\" class=\"headerlink\" title=\"条款02 尽量用const, enum, inline 替换#define\"></a>条款02 尽量用const, enum, inline 替换#define</h2><p>前言 我目前自己做的框架中大量用了#define…. 因为用enum涉及到转换才能到int. 来学习下这条</p>\n<p><strong>使用 const 常量来替换 #define</strong><br>谨防机号表出错, 特殊情况下 还能减少字量</p>\n<p>#define无法限定作用域, 这点我已经感受到了</p>\n<p>定义C风格常量字符串<br>const char* const NAME = “lsmg”; 防止指向和指向内容改变<br>定义C++风格常量字符串<br>const std::string NAME = “lsmg”;</p>\n<p>class专属常量, 使用如下方式. 可以限定作用域</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Game</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_ROOM = <span class=\"number\">10000</span>; <span class=\"comment\">// 常量声明式 - 常量且只有一份</span></span><br><span class=\"line\">\tGameroom* rooms[MAX_ROOM];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要获取class专属常量的地址, 或者需要定义式. 则需要在<code>实现文件</code>而非<code>头文件</code>, 如下声明<br><code>const int Game::MAX_ROOM</code> - 未给定初值<br>由于class常量已经在声明时获得初值, 所以不用在给定初值</p>\n<p>这里我发现一件事情, 这本书 不能只读一遍, 最少两边完整的<br>前面就已经开始使用后面的条款了, 先着重本条款, 跨条款的等第二遍</p>\n<h2 id=\"条款03-尽可能使用const\"><a href=\"#条款03-尽可能使用const\" class=\"headerlink\" title=\"条款03 尽可能使用const\"></a>条款03 尽可能使用const</h2><p><strong>总结</strong></p>\n<ul>\n<li>将某些东西声明为const可帮助编译器探测到错误用法<br>const可以用作在任何作用域内的对象, 函数参数, 函数返回类型, 成员函数本体</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> greeting[] = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *p = greeting;</span><br><span class=\"line\"><span class=\"comment\">// const 在 * 左边 被指物是常量 在右边自己是常量 两边都是常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *p = greeting; <span class=\"comment\">// 指针指向可以变, 指向的值不能变</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> p = greeting; <span class=\"comment\">// 指针指向不可以变, 指向的值可以变</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> p = greeting; <span class=\"comment\">// 都不可以变</span></span><br></pre></td></tr></table></figure>\n<p><strong>const 参数, 可你帮你检查 == 被写成=的情况</strong><br>这本书看来挺有意思的2333333</p>\n<p><strong>const 函数, 这里看不太懂 没有原来如此的感觉</strong></p>\n<h2 id=\"条款04-确定对象使用前已经被初始化\"><a href=\"#条款04-确定对象使用前已经被初始化\" class=\"headerlink\" title=\"条款04 确定对象使用前已经被初始化\"></a>条款04 确定对象使用前已经被初始化</h2><p><strong>总结</strong></p>\n<ul>\n<li>为内置型对象进行手工初始化.</li>\n<li>构造函数对号食用成员初值列, 不要在构造函数中赋值. 初值列次数应该与声明次序相同</li>\n<li>为了免除 跨编译单元的初始化次数问题, 用<code>local static</code>对象替换<code>non-local static</code>对象</li>\n</ul>\n<p>永远在使用对象前, 进行初始化.<br>在构造函数中, 对所有值进行初始化<br>构造函数使用<code>成员初始列</code>进行<code>初始化操作</code>而非<code>赋值操作</code></p>\n<p><strong>减少default构造函数不必要的调用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tA(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; &amp;room_list);</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name_;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; room_list_;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> roomnum_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A::A(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tname_ = name; <span class=\"comment\">// 这些都是赋值 不是初始化</span></span><br><span class=\"line\">\troom_list_ = room_list;</span><br><span class=\"line\">\troomnum_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// C++规定 对象的 成员变量  初始化动作  发生在  进入构造函数本体  之前</span></span><br><span class=\"line\"><span class=\"comment\">// name_  room_list_  两个在构造函数中被赋值, 而初始化在进入构造函数之前</span></span><br><span class=\"line\"><span class=\"comment\">// ---发生在这些成员的default构造函数被调用的时候, (发生在进入构造函数前)</span></span><br><span class=\"line\"><span class=\"comment\">// ---roomnum_例外 int属于内置类型</span></span><br></pre></td></tr></table></figure>\n<p>上面的初始化方式, 浪费了default的构造函数 所以推荐使用下面的形式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A::A(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class=\"line\">\t:name_(name), room_list_(room_list), roomnum_(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然最终结果相同, 但没有浪费default构造函数. 前两个调用的copy构造函数.</p>\n<p><strong>还可以使用成员初值列 来default构造一个成员变量.</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A::A()</span><br><span class=\"line\">\t:name_(), room_list_(), roomnum_(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123; <span class=\"comment\">// 前两个全部调用的default构造函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>const reference 内置类型(初始化与赋值等成本) 一定成员初始值列</strong></p>\n<p><strong>初始值列总是使用 声明次序进行初始化, 而非写的顺序, 所以最好按声明次序列出</strong></p>\n<p><strong>不同编译单元内定义之 non-local static对象 的初始化 次序</strong><br>static对象: 虚构函数会在main() 结束时被自动调用<br>local static对象: 函数内的static对象<br>non-local对象: 其他static对象</p>\n<p>编译单元: 产出单一目标文件的那些源码, 基本是单一源码文件和他包含的头文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// filesystem.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileSystem</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> <span class=\"title\">GetNum</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> FIieSystem tfs;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// directory.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Directory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDirectory(params);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Directory::Directory(params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> num = tfs.GetNum(); <span class=\"comment\">// 使用tfs对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"function\">Directory <span class=\"title\">temp_dir</span><span class=\"params\">(params)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>只有当 tfs在temp_dir初始化之前被初始化 才能得到正确的结果. 否则会调用未初始化的对象</p>\n<p>但是这个次序无法保证<br>因为C++ 对这种情况没有明确定义</p>\n<p>如何解决这个问题呢??<br>将每个<code>non-local static</code>对象搬到自己的专属函数内(该对象在此函数内被声明为static)<br>函数返回一个reference对象他所包含的对象<br>用户调用这个函数而不是直接调用对象</p>\n<p>解决的原因呢?<br>C++ 保证函数内的<code>local static</code>对象 会在<code>函数被调用期间</code>, <code>首次遇到该对象的定义式</code>被初始化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// filesystem.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileSystem</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> <span class=\"title\">GetNum</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">FileSystem</span>&amp; <span class=\"title\">tfs</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"built_in\">FileSystem</span> fs;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// directory.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Directory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDirectory(params);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Directory::Directory(params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> num = tfs().GetNum(); <span class=\"comment\">// 使用tfs对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">Directory&amp; <span class=\"title\">temp_dir</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> Directory td;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> td;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"构造析构赋值运算\"><a href=\"#构造析构赋值运算\" class=\"headerlink\" title=\"构造析构赋值运算\"></a>构造析构赋值运算</h1><h2 id=\"条款0506-了解C-默认编写并调用哪些函数-并适当拒绝\"><a href=\"#条款0506-了解C-默认编写并调用哪些函数-并适当拒绝\" class=\"headerlink\" title=\"条款0506 了解C++默认编写并调用哪些函数 并适当拒绝\"></a>条款0506 了解C++默认编写并调用哪些函数 并适当拒绝</h2><p><strong>夹带如下私货-public-inline</strong></p>\n<ul>\n<li>一个构造函数(如果你没有任何构造函数)</li>\n<li>一个拷贝构造函数</li>\n<li>一个析构函数</li>\n<li>一个拷贝</li>\n</ul>\n<p>拷贝构造函数和拷贝运算符 自动生成的只是单纯的将来源对象的每一个<code>non-static</code>成员变量<br>拷贝到目标对象</p>\n<p><strong>遇到const 和 引用成员 默认的拷贝无法工作, 编译器会发出警告</strong></p>\n<p><strong>将不需要的成员函数声明为private, 并且不实现</strong></p>\n<h2 id=\"条款07-为多态基类声明virtual析构函数\"><a href=\"#条款07-为多态基类声明virtual析构函数\" class=\"headerlink\" title=\"条款07 为多态基类声明virtual析构函数\"></a>条款07 为多态基类声明virtual析构函数</h2><p>返回指向子类的 父类型指针.<br>如果delete这个指针, 在父类析构函数不是virtual的情况下, 很可能会导致<br>父类的成分被销毁, 然而子类多出来的部分不被销毁. 造成局部销毁!!</p>\n<p><strong>防止局部销毁很简单, 将父类的析构函数声明为virtual</strong></p>\n<p><strong>任何class 只要带有virtual函数 几乎确定应该有一个virtual析构函数</strong></p>\n<p><strong>无端的声明virtual函数是错误的</strong><br>如果class不含virtual函数, 通常表示这个class 不是想做为父类, 这时如果将其析构函数声明为virual<br>是一个馊主意………….</p>\n<p><em>class类的大小 = 成员变量占据大小 + vptr(vitual table pointer)指针大小(4~8 字节)</em></p>\n<p>每一个带有virtual函数的class都有对应的vtbl</p>\n<p>当对象调用某一vitual函数的时候, 实际调用的函数取决于<br>vptr(vitual table pointer)指针指向的vtbl(vitual table)</p>\n<p>无端的使用virtual函数 会导致占用空间的增大</p>\n<h2 id=\"条款08-别让异常逃离析构函数\"><a href=\"#条款08-别让异常逃离析构函数\" class=\"headerlink\" title=\"条款08 别让异常逃离析构函数\"></a>条款08 别让异常逃离析构函数</h2><p><strong>总结</strong></p>\n<ul>\n<li>析构函数绝对不要抛出异常, 如果被析构函数调用的函数可能抛出异常, 析构函数应该捕获所有异常<br>然后吞下它们, 或者结束程序</li>\n<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应, class应该提供一个普通函数(而非在析构函数中)<br>执行操作</li>\n</ul>\n<p><strong>析构函数不要抛出异常</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t~Widget() &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Widget&gt; v;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 <code>v</code>被销毁的时候, Widget的析构函数第一次抛出异常C++还能接受?<br>第二次就会造成不明确行为</p>\n<h2 id=\"条款09-绝不在构造函数和析构过程中调用virtual函数\"><a href=\"#条款09-绝不在构造函数和析构过程中调用virtual函数\" class=\"headerlink\" title=\"条款09: 绝不在构造函数和析构过程中调用virtual函数\"></a>条款09: 绝不在构造函数和析构过程中调用virtual函数</h2><p><strong>总结</strong></p>\n<ul>\n<li>在构造和析构期间不要调用virtual函数, 因为这类调用从不下降到<code>子类</code></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transaction</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tTransaction();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">LogTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Transaction::Transaction()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tLogTransaction();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuyTransaction</span>:</span> <span class=\"keyword\">public</span> Transaction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">LogTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SellTransaction</span>:</span> <span class=\"keyword\">public</span> Transaction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">LogTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BuyTransaction b;</span><br></pre></td></tr></table></figure>\n<p>BuyTransaction的构造函数会被调用, 但是父类的构造函数会更显被调用.<br>然后父类构造函数调用<code>LogTransaction()</code>的版本是<code>父类</code>的版本!!! 不是子类的版本</p>\n<p>析构函数也是同样的道理, 当<code>子类</code>的析构函数执行后, <code>子类</code>中的属性值就成为未定义状态<br>进入<code>父类</code>后对象就成为一个<code>父类</code>对象</p>\n<p>本例子中既然无法实现使用<code>virtual</code>函数从<code>父类</code>向下调用, 可以再构造期间, 将<br><code>子类</code>必要的构造信息向上传给<code>父类</code>的构造函数</p>\n<h2 id=\"条款10-另operator-返回一个reference-to-this\"><a href=\"#条款10-另operator-返回一个reference-to-this\" class=\"headerlink\" title=\"条款10: 另operator= 返回一个reference to *this\"></a>条款10: 另operator= 返回一个reference to *this</h2><p>注意这只是一个协议, 并无强制性. 如果不遵守代码依然可以通过编译, 然而这份 协议被所有内置类型<br>和标准程序库提供的类型共同遵守.<br>因此除非你有一个标新立异的好理由, 不然还是随众吧</p>\n<h2 id=\"条款11-在operator-中处理”自我赋值”\"><a href=\"#条款11-在operator-中处理”自我赋值”\" class=\"headerlink\" title=\"条款11: 在operator= 中处理”自我赋值”\"></a>条款11: 在operator= 中处理”自我赋值”</h2><p><strong>总结</strong></p>\n<ul>\n<li>确保当对象自我赋值时operator=有良好的的行为. 其中技术包括比较”来源对象”<br>和”目标对象”的地址, 精心周到的语句顺序, 以及copy-and-swap</li>\n<li>确认任何函数如果操作一个以上的对象, 而其中多个对象是同一个对象的时候, 进行仍未正确</li>\n</ul>\n<p><strong>自我赋值是什么</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> &#123;</span>...&#125;;</span><br><span class=\"line\">Widget w;</span><br><span class=\"line\"></span><br><span class=\"line\">w=w; <span class=\"comment\">// 什么这个看起来不可能, 那下面呢?</span></span><br><span class=\"line\"></span><br><span class=\"line\">a[i] = a[j]; <span class=\"comment\">// 这个怎么样?  潜在的自我赋值</span></span><br><span class=\"line\">*px = *py <span class=\"comment\">// 这个呢? 潜在的自我赋值</span></span><br></pre></td></tr></table></figure>\n<p><strong>会出现的问题</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Gameroom</span>&#123;</span>....&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Game</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tGameroom* room_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// operator=的实现代码</span></span><br><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> room_;</span><br><span class=\"line\">\troom_ = <span class=\"keyword\">new</span> Gameroom(*ths.room_);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码 如果 this和ths指向同一个对象就会造成 <code>room_</code>构造失败<br>因为被<code>delete</code>的<code>room_</code>就是要传入的</p>\n<p>如何解决这个问题呢?<br><em>比较来源对象 整同测试</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;ths)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> room_;</span><br><span class=\"line\">\troom_ = <span class=\"keyword\">new</span> Gameroom(*ths.room_);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是如果 <code>new Gameroom(*ths.room_)</code>错误, 导致room_指向不安全的内存<br>使用下面的代码, 可以导出异常安全, 以及自我赋值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tGameroom* p_room = room_;</span><br><span class=\"line\">\troom_ = <span class=\"keyword\">new</span> Gameroom(*ths.room_);</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> p_room;</span><br><span class=\"line\">\tretutn *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在如果<code>new Gameroom</code>抛出异常, room_还可以保持原状.<br>同时也能处理自我赋值</p>\n<p><em>copy and swap</em><br>这一段描述我看完之后, 突然想到了上午看的Jsoncpp里面的代码!!!!! 就有这个<br>下面的代码更加高效 但是牺牲了清晰性</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Game</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(Game&amp; rhs)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tGame temp(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\tswap(temp);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"条款12-复制对象时勿忘其每一个成分\"><a href=\"#条款12-复制对象时勿忘其每一个成分\" class=\"headerlink\" title=\"条款12: 复制对象时勿忘其每一个成分\"></a>条款12: 复制对象时勿忘其每一个成分</h2><h1 id=\"设计与声明\"><a href=\"#设计与声明\" class=\"headerlink\" title=\"设计与声明\"></a>设计与声明</h1><h2 id=\"条款19-设计class犹如设计type\"><a href=\"#条款19-设计class犹如设计type\" class=\"headerlink\" title=\"条款19: 设计class犹如设计type\"></a>条款19: 设计class犹如设计type</h2><p>如何设计高效的classes呢?</p>\n<ul>\n<li>新class的对象该如何被创建和销毁? 这会影响到构造析构函数内存分配释放函数</li>\n<li>对象的初始化和对象的赋值有什么样的差别? 决定构造函数和赋值运算符的行为.<br>搞清初始化和赋值</li>\n<li>注意class对象被值传递 拷贝构造函数会被调用用来生成临时对象</li>\n<li>什么是新class的合法值? <code>setter</code>函数需要进行的范围检查</li>\n<li>你的新class需要配合某个继承图系吗? // TODO</li>\n<li>你的新class需要什么样的转换? 如果需要类型转换需要在class中编写<code>类型转换函数</code></li>\n<li>什么样的操作运算符和函数对此class而言是合理的? 决定你为class声明哪些函数(条款 23 24 46)</li>\n<li>将需要驳回的标准函数设置为private</li>\n<li>你的新type有多么一般化? 或许应该定义一整个class家族. 也许模板能帮你</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"让自己习惯C\"><a href=\"#让自己习惯C\" class=\"headerlink\" title=\"让自己习惯C++\"></a>让自己习惯C++</h1><h2 id=\"条款02-尽量用const-enum-inline-替换-define\"><a href=\"#条款02-尽量用const-enum-inline-替换-define\" class=\"headerlink\" title=\"条款02 尽量用const, enum, inline 替换#define\"></a>条款02 尽量用const, enum, inline 替换#define</h2><p>前言 我目前自己做的框架中大量用了#define…. 因为用enum涉及到转换才能到int. 来学习下这条</p>\n<p><strong>使用 const 常量来替换 #define</strong><br>谨防机号表出错, 特殊情况下 还能减少字量</p>\n<p>#define无法限定作用域, 这点我已经感受到了</p>\n<p>定义C风格常量字符串<br>const char* const NAME = “lsmg”; 防止指向和指向内容改变<br>定义C++风格常量字符串<br>const std::string NAME = “lsmg”;</p>\n<p>class专属常量, 使用如下方式. 可以限定作用域</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Game</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX_ROOM = <span class=\"number\">10000</span>; <span class=\"comment\">// 常量声明式 - 常量且只有一份</span></span><br><span class=\"line\">\tGameroom* rooms[MAX_ROOM];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果要获取class专属常量的地址, 或者需要定义式. 则需要在<code>实现文件</code>而非<code>头文件</code>, 如下声明<br><code>const int Game::MAX_ROOM</code> - 未给定初值<br>由于class常量已经在声明时获得初值, 所以不用在给定初值</p>\n<p>这里我发现一件事情, 这本书 不能只读一遍, 最少两边完整的<br>前面就已经开始使用后面的条款了, 先着重本条款, 跨条款的等第二遍</p>\n<h2 id=\"条款03-尽可能使用const\"><a href=\"#条款03-尽可能使用const\" class=\"headerlink\" title=\"条款03 尽可能使用const\"></a>条款03 尽可能使用const</h2><p><strong>总结</strong></p>\n<ul>\n<li>将某些东西声明为const可帮助编译器探测到错误用法<br>const可以用作在任何作用域内的对象, 函数参数, 函数返回类型, 成员函数本体</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> greeting[] = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *p = greeting;</span><br><span class=\"line\"><span class=\"comment\">// const 在 * 左边 被指物是常量 在右边自己是常量 两边都是常量</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *p = greeting; <span class=\"comment\">// 指针指向可以变, 指向的值不能变</span></span><br><span class=\"line\"><span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> p = greeting; <span class=\"comment\">// 指针指向不可以变, 指向的值可以变</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> p = greeting; <span class=\"comment\">// 都不可以变</span></span><br></pre></td></tr></table></figure>\n<p><strong>const 参数, 可你帮你检查 == 被写成=的情况</strong><br>这本书看来挺有意思的2333333</p>\n<p><strong>const 函数, 这里看不太懂 没有原来如此的感觉</strong></p>\n<h2 id=\"条款04-确定对象使用前已经被初始化\"><a href=\"#条款04-确定对象使用前已经被初始化\" class=\"headerlink\" title=\"条款04 确定对象使用前已经被初始化\"></a>条款04 确定对象使用前已经被初始化</h2><p><strong>总结</strong></p>\n<ul>\n<li>为内置型对象进行手工初始化.</li>\n<li>构造函数对号食用成员初值列, 不要在构造函数中赋值. 初值列次数应该与声明次序相同</li>\n<li>为了免除 跨编译单元的初始化次数问题, 用<code>local static</code>对象替换<code>non-local static</code>对象</li>\n</ul>\n<p>永远在使用对象前, 进行初始化.<br>在构造函数中, 对所有值进行初始化<br>构造函数使用<code>成员初始列</code>进行<code>初始化操作</code>而非<code>赋值操作</code></p>\n<p><strong>减少default构造函数不必要的调用</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class A</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tA(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; &amp;room_list);</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name_;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; room_list_;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> roomnum_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">A::A(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tname_ = name; <span class=\"comment\">// 这些都是赋值 不是初始化</span></span><br><span class=\"line\">\troom_list_ = room_list;</span><br><span class=\"line\">\troomnum_ = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// C++规定 对象的 成员变量  初始化动作  发生在  进入构造函数本体  之前</span></span><br><span class=\"line\"><span class=\"comment\">// name_  room_list_  两个在构造函数中被赋值, 而初始化在进入构造函数之前</span></span><br><span class=\"line\"><span class=\"comment\">// ---发生在这些成员的default构造函数被调用的时候, (发生在进入构造函数前)</span></span><br><span class=\"line\"><span class=\"comment\">// ---roomnum_例外 int属于内置类型</span></span><br></pre></td></tr></table></figure>\n<p>上面的初始化方式, 浪费了default的构造函数 所以推荐使用下面的形式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A::A(<span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> &amp;name, <span class=\"keyword\">const</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">list</span>&lt;Gameroom&gt; &amp;room_list)</span><br><span class=\"line\">\t:name_(name), room_list_(room_list), roomnum_(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>虽然最终结果相同, 但没有浪费default构造函数. 前两个调用的copy构造函数.</p>\n<p><strong>还可以使用成员初值列 来default构造一个成员变量.</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A::A()</span><br><span class=\"line\">\t:name_(), room_list_(), roomnum_(<span class=\"number\">0</span>)</span><br><span class=\"line\">&#123; <span class=\"comment\">// 前两个全部调用的default构造函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>const reference 内置类型(初始化与赋值等成本) 一定成员初始值列</strong></p>\n<p><strong>初始值列总是使用 声明次序进行初始化, 而非写的顺序, 所以最好按声明次序列出</strong></p>\n<p><strong>不同编译单元内定义之 non-local static对象 的初始化 次序</strong><br>static对象: 虚构函数会在main() 结束时被自动调用<br>local static对象: 函数内的static对象<br>non-local对象: 其他static对象</p>\n<p>编译单元: 产出单一目标文件的那些源码, 基本是单一源码文件和他包含的头文件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// filesystem.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileSystem</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> <span class=\"title\">GetNum</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> FIieSystem tfs;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// directory.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Directory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDirectory(params);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Directory::Directory(params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> num = tfs.GetNum(); <span class=\"comment\">// 使用tfs对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"function\">Directory <span class=\"title\">temp_dir</span><span class=\"params\">(params)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>只有当 tfs在temp_dir初始化之前被初始化 才能得到正确的结果. 否则会调用未初始化的对象</p>\n<p>但是这个次序无法保证<br>因为C++ 对这种情况没有明确定义</p>\n<p>如何解决这个问题呢??<br>将每个<code>non-local static</code>对象搬到自己的专属函数内(该对象在此函数内被声明为static)<br>函数返回一个reference对象他所包含的对象<br>用户调用这个函数而不是直接调用对象</p>\n<p>解决的原因呢?<br>C++ 保证函数内的<code>local static</code>对象 会在<code>函数被调用期间</code>, <code>首次遇到该对象的定义式</code>被初始化</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// filesystem.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileSystem</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> <span class=\"title\">GetNum</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">FileSystem</span>&amp; <span class=\"title\">tfs</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"built_in\">FileSystem</span> fs;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> fs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// directory.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Directory</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tDirectory(params);\t</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Directory::Directory(params)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"keyword\">size_t</span> num = tfs().GetNum(); <span class=\"comment\">// 使用tfs对象</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\">Directory&amp; <span class=\"title\">temp_dir</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> Directory td;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> td;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"构造析构赋值运算\"><a href=\"#构造析构赋值运算\" class=\"headerlink\" title=\"构造析构赋值运算\"></a>构造析构赋值运算</h1><h2 id=\"条款0506-了解C-默认编写并调用哪些函数-并适当拒绝\"><a href=\"#条款0506-了解C-默认编写并调用哪些函数-并适当拒绝\" class=\"headerlink\" title=\"条款0506 了解C++默认编写并调用哪些函数 并适当拒绝\"></a>条款0506 了解C++默认编写并调用哪些函数 并适当拒绝</h2><p><strong>夹带如下私货-public-inline</strong></p>\n<ul>\n<li>一个构造函数(如果你没有任何构造函数)</li>\n<li>一个拷贝构造函数</li>\n<li>一个析构函数</li>\n<li>一个拷贝</li>\n</ul>\n<p>拷贝构造函数和拷贝运算符 自动生成的只是单纯的将来源对象的每一个<code>non-static</code>成员变量<br>拷贝到目标对象</p>\n<p><strong>遇到const 和 引用成员 默认的拷贝无法工作, 编译器会发出警告</strong></p>\n<p><strong>将不需要的成员函数声明为private, 并且不实现</strong></p>\n<h2 id=\"条款07-为多态基类声明virtual析构函数\"><a href=\"#条款07-为多态基类声明virtual析构函数\" class=\"headerlink\" title=\"条款07 为多态基类声明virtual析构函数\"></a>条款07 为多态基类声明virtual析构函数</h2><p>返回指向子类的 父类型指针.<br>如果delete这个指针, 在父类析构函数不是virtual的情况下, 很可能会导致<br>父类的成分被销毁, 然而子类多出来的部分不被销毁. 造成局部销毁!!</p>\n<p><strong>防止局部销毁很简单, 将父类的析构函数声明为virtual</strong></p>\n<p><strong>任何class 只要带有virtual函数 几乎确定应该有一个virtual析构函数</strong></p>\n<p><strong>无端的声明virtual函数是错误的</strong><br>如果class不含virtual函数, 通常表示这个class 不是想做为父类, 这时如果将其析构函数声明为virual<br>是一个馊主意………….</p>\n<p><em>class类的大小 = 成员变量占据大小 + vptr(vitual table pointer)指针大小(4~8 字节)</em></p>\n<p>每一个带有virtual函数的class都有对应的vtbl</p>\n<p>当对象调用某一vitual函数的时候, 实际调用的函数取决于<br>vptr(vitual table pointer)指针指向的vtbl(vitual table)</p>\n<p>无端的使用virtual函数 会导致占用空间的增大</p>\n<h2 id=\"条款08-别让异常逃离析构函数\"><a href=\"#条款08-别让异常逃离析构函数\" class=\"headerlink\" title=\"条款08 别让异常逃离析构函数\"></a>条款08 别让异常逃离析构函数</h2><p><strong>总结</strong></p>\n<ul>\n<li>析构函数绝对不要抛出异常, 如果被析构函数调用的函数可能抛出异常, 析构函数应该捕获所有异常<br>然后吞下它们, 或者结束程序</li>\n<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应, class应该提供一个普通函数(而非在析构函数中)<br>执行操作</li>\n</ul>\n<p><strong>析构函数不要抛出异常</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t~Widget() &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;Widget&gt; v;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 <code>v</code>被销毁的时候, Widget的析构函数第一次抛出异常C++还能接受?<br>第二次就会造成不明确行为</p>\n<h2 id=\"条款09-绝不在构造函数和析构过程中调用virtual函数\"><a href=\"#条款09-绝不在构造函数和析构过程中调用virtual函数\" class=\"headerlink\" title=\"条款09: 绝不在构造函数和析构过程中调用virtual函数\"></a>条款09: 绝不在构造函数和析构过程中调用virtual函数</h2><p><strong>总结</strong></p>\n<ul>\n<li>在构造和析构期间不要调用virtual函数, 因为这类调用从不下降到<code>子类</code></li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transaction</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tTransaction();</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">LogTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Transaction::Transaction()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\tLogTransaction();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BuyTransaction</span>:</span> <span class=\"keyword\">public</span> Transaction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">LogTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SellTransaction</span>:</span> <span class=\"keyword\">public</span> Transaction</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">LogTransaction</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">\t...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">BuyTransaction b;</span><br></pre></td></tr></table></figure>\n<p>BuyTransaction的构造函数会被调用, 但是父类的构造函数会更显被调用.<br>然后父类构造函数调用<code>LogTransaction()</code>的版本是<code>父类</code>的版本!!! 不是子类的版本</p>\n<p>析构函数也是同样的道理, 当<code>子类</code>的析构函数执行后, <code>子类</code>中的属性值就成为未定义状态<br>进入<code>父类</code>后对象就成为一个<code>父类</code>对象</p>\n<p>本例子中既然无法实现使用<code>virtual</code>函数从<code>父类</code>向下调用, 可以再构造期间, 将<br><code>子类</code>必要的构造信息向上传给<code>父类</code>的构造函数</p>\n<h2 id=\"条款10-另operator-返回一个reference-to-this\"><a href=\"#条款10-另operator-返回一个reference-to-this\" class=\"headerlink\" title=\"条款10: 另operator= 返回一个reference to *this\"></a>条款10: 另operator= 返回一个reference to *this</h2><p>注意这只是一个协议, 并无强制性. 如果不遵守代码依然可以通过编译, 然而这份 协议被所有内置类型<br>和标准程序库提供的类型共同遵守.<br>因此除非你有一个标新立异的好理由, 不然还是随众吧</p>\n<h2 id=\"条款11-在operator-中处理”自我赋值”\"><a href=\"#条款11-在operator-中处理”自我赋值”\" class=\"headerlink\" title=\"条款11: 在operator= 中处理”自我赋值”\"></a>条款11: 在operator= 中处理”自我赋值”</h2><p><strong>总结</strong></p>\n<ul>\n<li>确保当对象自我赋值时operator=有良好的的行为. 其中技术包括比较”来源对象”<br>和”目标对象”的地址, 精心周到的语句顺序, 以及copy-and-swap</li>\n<li>确认任何函数如果操作一个以上的对象, 而其中多个对象是同一个对象的时候, 进行仍未正确</li>\n</ul>\n<p><strong>自我赋值是什么</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> &#123;</span>...&#125;;</span><br><span class=\"line\">Widget w;</span><br><span class=\"line\"></span><br><span class=\"line\">w=w; <span class=\"comment\">// 什么这个看起来不可能, 那下面呢?</span></span><br><span class=\"line\"></span><br><span class=\"line\">a[i] = a[j]; <span class=\"comment\">// 这个怎么样?  潜在的自我赋值</span></span><br><span class=\"line\">*px = *py <span class=\"comment\">// 这个呢? 潜在的自我赋值</span></span><br></pre></td></tr></table></figure>\n<p><strong>会出现的问题</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Gameroom</span>&#123;</span>....&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Game</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t...</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">\tGameroom* room_;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// operator=的实现代码</span></span><br><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> room_;</span><br><span class=\"line\">\troom_ = <span class=\"keyword\">new</span> Gameroom(*ths.room_);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的代码 如果 this和ths指向同一个对象就会造成 <code>room_</code>构造失败<br>因为被<code>delete</code>的<code>room_</code>就是要传入的</p>\n<p>如何解决这个问题呢?<br><em>比较来源对象 整同测试</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == &amp;ths)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> room_;</span><br><span class=\"line\">\troom_ = <span class=\"keyword\">new</span> Gameroom(*ths.room_);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是如果 <code>new Gameroom(*ths.room_)</code>错误, 导致room_指向不安全的内存<br>使用下面的代码, 可以导出异常安全, 以及自我赋值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tGameroom* p_room = room_;</span><br><span class=\"line\">\troom_ = <span class=\"keyword\">new</span> Gameroom(*ths.room_);</span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> p_room;</span><br><span class=\"line\">\tretutn *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在如果<code>new Gameroom</code>抛出异常, room_还可以保持原状.<br>同时也能处理自我赋值</p>\n<p><em>copy and swap</em><br>这一段描述我看完之后, 突然想到了上午看的Jsoncpp里面的代码!!!!! 就有这个<br>下面的代码更加高效 但是牺牲了清晰性</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Game</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(Game&amp; rhs)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Game&amp; Game::<span class=\"keyword\">operator</span>=(<span class=\"keyword\">const</span> Game&amp; ths)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tGame temp(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\tswap(temp);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"条款12-复制对象时勿忘其每一个成分\"><a href=\"#条款12-复制对象时勿忘其每一个成分\" class=\"headerlink\" title=\"条款12: 复制对象时勿忘其每一个成分\"></a>条款12: 复制对象时勿忘其每一个成分</h2><h1 id=\"设计与声明\"><a href=\"#设计与声明\" class=\"headerlink\" title=\"设计与声明\"></a>设计与声明</h1><h2 id=\"条款19-设计class犹如设计type\"><a href=\"#条款19-设计class犹如设计type\" class=\"headerlink\" title=\"条款19: 设计class犹如设计type\"></a>条款19: 设计class犹如设计type</h2><p>如何设计高效的classes呢?</p>\n<ul>\n<li>新class的对象该如何被创建和销毁? 这会影响到构造析构函数内存分配释放函数</li>\n<li>对象的初始化和对象的赋值有什么样的差别? 决定构造函数和赋值运算符的行为.<br>搞清初始化和赋值</li>\n<li>注意class对象被值传递 拷贝构造函数会被调用用来生成临时对象</li>\n<li>什么是新class的合法值? <code>setter</code>函数需要进行的范围检查</li>\n<li>你的新class需要配合某个继承图系吗? // TODO</li>\n<li>你的新class需要什么样的转换? 如果需要类型转换需要在class中编写<code>类型转换函数</code></li>\n<li>什么样的操作运算符和函数对此class而言是合理的? 决定你为class声明哪些函数(条款 23 24 46)</li>\n<li>将需要驳回的标准函数设置为private</li>\n<li>你的新type有多么一般化? 或许应该定义一整个class家族. 也许模板能帮你</li>\n</ul>\n"},{"title":"Linux高性能服务器-进程线程","date":"2020-02-25T14:34:39.000Z","top":102,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg","_content":"# 第十三章多进程编程\n\n## exec系列系统调用\n```c++\n#include <unistd.h>\n// 声明这个是外部函数或外部变量\nextern char** environ;\n\n// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻\n// arg-接受可变参数 和 argv用于向新的程序传递参数数组\n// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量\n// exec函数是不返回的, 除非出错\n// 如果未报错则源程序被新的程序完全替换\n\nint execl(const char* path, const char* arg, ...);\nint execlp(const char* file, const char* arg, ...);\nint execle(const char* path, const char* arg, ..., char* const envp[])\nint execv(const char* path, char* const argv[]);\nint execvp(const char* file, char* const argv[]);\nint execve(const char* path, char* const argv[], char* const envp[]);\n```\n## fork系统调用-进程的创建\n```c++\n#include <sys/types.h>\n#include <unistd.h>\n// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0\n// 次返回值用于区分是父进程还是子进程\n// 失败返回-1\npid_t fork(viod);\n```\nfork系统调用\nfork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项\n新的进程表项有很多的属性和原进程相同\n- 堆指针\n- 栈指针\n- 标志寄存器的值\n- 子进程代码与父进程完全相同\n- 同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)父进程的数据(堆数据, 栈数据, 静态数据)\n- 创建子进程后, *父进程打开的文件描述符默认在子进程中也是打开的* `文件描述符的引用计数`, `父进程的用户根目录, 当前工作目录等变量的引用计数` 均加1\n\n也存在不同的项目\n- 该进程的PPID(标识父进程)被设置成原进程的PID,  \n- `信号位图被清除`(原进程设置的信号处理函数对新进程无效)\n\n\n(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)\n\n\nThe child process is an exact duplicate of the parent process except\nfor the following points:\n*  The child has its own unique process ID, and this PID does not\n\tmatch the ID of any existing process group (setpgid(2)) or\n\tsession. 子进程拥有自己唯一的进程ID, 不与其他相同\n\n*  The child's parent process ID is the same as the parent's process\n\tID. 子进程的父进程ID PPID 与父进程ID PID相同\n\n*  The child does not inherit its parent's memory locks (mlock(2),\n\tmlockall(2)). 子进程不继承父进程的内存锁(保证一部分内存处于内存中, 而不是sawp分区)\n\n*  Process resource utilizations (getrusage(2)) and CPU time counters\n\t(times(2)) are reset to zero in the child.\n\t进程资源使用和CPU时间计数器在子进程中重置为0\n\n*  The child's set of pending signals is initially empty\n\t(sigpending(2)). 信号位图被初始化为空 原信号处理函数对子进程无效 需重新设置\n\n*  The child does not inherit semaphore adjustments from its parent\n\t(semop(2)). 不会继承semadj\n\n*  The child does not inherit process-associated record locks from\n\tits parent (fcntl(2)).  (On the other hand, it does inherit\n\tfcntl(2) open file description locks and flock(2) locks from its\n\tparent.)\n\n*  The child does not inherit timers from its parent (setitimer(2),\n\talarm(2), timer_create(2)). 不会继承定时器\n\n*  The child does not inherit outstanding asynchronous I/O operations\n\tfrom its parent (aio_read(3), aio_write(3)), nor does it inherit\n\tany asynchronous I/O contexts from its parent (see io_setup(2)).\n\n\n\n\n## 处理僵尸进程-进程的管理\n```c++\n#include <sys/types.h>\n#include <sys/wait.h>\n// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.\npid_t wait(int* stat_loc);\n\n// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)\n// options函数取值WNOHANG-waitpid立即返回\n// 如果目标子进程正常退出, 则返回子进程的pid\n// 如果还没有结束或意外终止, 则立即返回0\n// 调用失败返回-1\npid_t waitpid(pid_t pid, int* stat_loc, int options);\n\nWIFEXITED(stat_val); // 子进程正常结束, 返回一个非0\nWEXITSTATUS(stat_val); // 如果WIFEXITED 非0, 它返回子进程的退出码\nWIFSIGNALED(stat_val);// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值\nWTERMSIG(stat_val);// 如果WIFSIGNALED非0 返回一个信号值\nWIFSTOPPED(stat_val);// 如果子进程意外终止, 它返回一个非0值\nWSTOPSIG(stat_val);// 如果WIFSTOPED非0, 它返回一个信号值\n```\n\n对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询\n- 在`子进程结束运行之后, 父进程读取其退出状态前`, 我们称该子进程处于`僵尸态`\n- 另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) `父进程结束运行之后, 子进程退出之前`, 处于`僵尸态`\n\n以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.\n\nwaitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.\nSIGCHLD信号- 子进程结束后将会给父进程发送此信号\n```c++\nstatic void handle_child(int sig)\n{\n\tpid_t pid;\n\tint stat;\n\twhile ((pid = waitpid(-1, &stat, WNOHANG)) > 0)\n\t{\n\t\t// 善后处理emmmm\n\t}\n}\n```\n\n## 信号量-进程的锁\n*信号量原语*\n只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.\n假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为\n- P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行\n- V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png)\n\n**总结PV使用方法**\n\n使用`semget`获取到唯一的标识.\n使用`semctl`的`SETVAL`传入初始化val的`sem_un`联合体.来初始化val\n调用`semop` 传入唯一标识, `sem_op=-1`执行P(锁)操作`sem_op=1`执行V(开锁)操作\n开关锁通过当`sem_op=-1,semval=0 `\n且未指定`IPC_NOWAIT`\n等待`semval`被`sem_op=1`改为`semval=1`\n\n**创建信号量**\n```c++\n// semeget 系统调用\n// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集\n// key 参数是一个键值, 用来标识一个全局唯一的信号量级,可以在不同进程中获取\n// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0. 一般都是为1\n// sem_flags指定一组标志, 来控制权限\n// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错\n// - IPC_CREAT | IPC_EXCL来创建一组唯一信号量集 如果已经存在则会返回错误 errno = EEXIST\n// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1\nint semget(key_t key, int num_sems, int sem_flags);\n\nint sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT);\n```\n\n**初始化**\n```c++\n// semctl 系统调用\n// sem_id 参数是由semget返回的信号量集标识符\n// sen_num指定被操作的信号量在信号集中的编号\n// command指定命令, 可以追加命令所需的参数, 不过有推荐格式\n// 成功返回对应command的参数, 失败返回-1 errno\nint semctl(int sem_id, int sem_num, int command, ...);\n\n// 第四个参数 竟然需要手动声明...\nunion semun\n{\n\tint              val;    /* Value for SETVAL */\n\tstruct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */\n\tunsigned short  *array;  /* Array for GETALL, SETALL */\n\tstruct seminfo  *__buf;  /* Buffer for IPC_INFO\n\t\t\t\t\t\t\t\t(Linux-specific) */\n};\n// 初始化信号量\nunion semun sem_union;\nsem_union.val = 1;\n// 这里可以直接第三个参数传入1(val)\nif (semctl(sem_id, 0, SETVAL, sem_union) == -1)\n{\n\texit(0);\n}\n\n// 删除信号量\nunion semun sem_union{};\nif (semctl(sem_id, 0, IPC_RMID, sem_union) == -1)\n{\n\texit(EXIT_FAILURE);\n}\n```\n---\n与semop信号量关联的一些重要的内核变量\n```c++\nunsigned short semval; // 信号量的值\nunsigned short semzcnt; // 等待信号量值变为0的进程数量\nunsigned short semncnt// 等待信号量值增加的进程数量\npid_t sempid; // 最后一次执行semop操作的进程ID\n```\n操作信号量, 实际上就是对上面的内核变量操作\n\n```c++\n// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.\n// sem_ops 参数指向一个sembuf结构体类型的数组\n// num_sem_ops 说明操作数组中哪个信号量\n// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行\nint semop(int sem_id, struct sembuf* sem_ops, size_t num_sem_ops);\n\n// sem_op < 0 期望获得信号量\n// semval-=abs(sem_op),要求调用进程对被操作信号量集有写权限\n// 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量\n\n// 如果semval < abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN\n// 如果没有指定 则 阻塞进程等待信号量可用, 且 semzcnt +=1, 等到下面三种情况唤醒\n// 1 发生semval >= abs(sem_op), semzcnt-=1, semval-=abs(sem_op). 在SEM_UNDO设置时更新semadj\n// 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)\n// 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)\nbool P(int sem_id)\n{\n    struct sembuf sem_b;\n    sem_b.sem_num = 0; // 信号量编号 第几个信号量 一般都是第0个\n    sem_b.sem_op = -1; // P\n\t// IPC_NOWAIT 无论信号量操作是否成功, 都立即返回\n\t// SEM_UNDO当进程退出的时候, 取消正在进行的semop操作 PV操作系统更新进程的semadj变量\n    sem_b.sem_flg = SEM_UNDO;\n    return semop(sem_id, &sem_b, 1) != -1;\n}\n\n\n// sem_op > 0 \n// semval+=sem_op , 要求调用进程对被操作的信号量集有写权限\n// 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)\nbool V(int sem_id)\n{\n    struct sembuf sem_b;\n    sem_b.sem_num = 0;\n    sem_b.sem_op = 1; // V\n    sem_b.sem_flg = SEM_UNDO;\n    return semop(sem_id, &sem_b, 1) != -1;\n}\n\n\n// -- sem_op = 0\n// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限\n// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0\n// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN\n// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生\n// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1\n// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM\n// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1\n\n```\n\nsemget成功时返回一个与之关联的内核结构体semid_ds\n```c++\nstruct semid_ds\n{\n\tstruct ipc_perm sem_perm;\n\tunsigned long int sem_nsems; // 被设置为num_sems\n\ttime_t sem_otime; // 被设置为0\n\ttime_t sem_ctime; // 被设置为当前的系统时间\n}\n// 用来描述权限\nstruct ipc_perm\n{\n\tuid_t uid; // 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID\n\tgid_t gid; // 所有者的有效组ID, 被semget设置为调用进程的有效用户ID\n\tuid_t cuid; // 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID\n\tgid_t cgid; // 创建者的有效组ID, 被semget设置为调用进程的有效用户ID\n\tmode_t mode;// 访问权限, 背着只为sem_flags参数的最低9位.\n}\n```\n\n## 共享内存-进程间通信\n**最高效的IPC(进程间通信)机制**\n需要自己同步进程对其的访问, 否则会产生竞态条件\n\n```c++\n// key\n// 与semget相同 标识一段全局唯一的共享内存\n// size 内存区域大小 单位字节\n// shmflg\n// IPC_CREAT 存不存在都创建新的共享内存\n// IPC_CREAT | IPC_EXCL 不存在则创建 存在则报错\n// SHM_HUGETLB 系统将使用\"大页面\"来为共享内存分配空间\n// SHM_NORESERVE 不为共享内存保留swap空间, 如果物理内存不足\n// -在执行写操作的时候将会触发`SIGSEGV`信号\n// -成功返回唯一标识, 失败返回-1 errno\nint shmget(key_t key, size_t size, int shmflg)\n```\n\n```c++\n// shm_id \n// shmget返回的唯一标识\n// shm_addr \n// 关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响\n// 如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强\n// 如果 shm_addr 非空,且没有`SHM_RND`标志 则关联到指定的地址处\n// 如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写*\n// shmflg\n// SHM_RDONLY 设置后内存内容变成只读, 不设置则为读写模式\n// SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联\n// SHM_EXEC 有执行权限\n// 成功返回关联到的地址, 失败返回 (void*)-1 errno\nvoid* shmat(int shm_id, const void* shm_addr, int shmflg)\n\n// 将共享内存关联到进程的地址空间 调用成功之后, 修改shmid_ds的部分内容\n// -shm_nattach +1\n// -更新 shm_lpid\n// -shm_atime设置为当前时间\n```\n\n\n```c++\n// 将共享内存从进程地址空间中分离\n// 成功后\n// -shm_nattach -1\n// -更新 shm_lpid和shm_dtime设置为当前时间\n// 成功返回0 失败返回-1 errno\nint shmdt(const void* shm_addr)\n```\n\n```c++\nint shm_ctl(int shm_id, int command, struct shmid_ds* buf)\n```\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/shmctl.png)\n\n----\n\nshmget 同时会创建对应的`shmid_ds`结构体\n```c++\nstruct shmid_ds\n{\n\tstruct ipc_perm shm_per; // 权限相关\n\tsize_t shm_segsz; // 共享内存大小 单位字节\tsize\n\t__time_t shm_atime; // 对这段内存最后一次调用semat的时间 0\n\t__time_t shm_dtime; // 对这段内存最后一次调用semdt的时间 0\n\t__time_t shm_ctime; // 对这段内存最后一次调用semctl的时间 当前时间\n\t__pid_t shm_cpid; // 创建者PID\n\t__pid_t lpid; // 最后一次执行shmat或shmdt的进程PID\n\tshmatt_t shm_nattach // 关联到此共享内存空间的进程数量\n}\n```\n\n**共享内存的POSIX方法**\n```c++\nint shmfd = shm_open(\"/shm_name\", O_CREAT | O_RDWR, 0666);\nERROR_IF(shmfd == -1, \"shm open\");\n\nint ret = ftruncate(shmfd, BUFFER_SIZE);\nERROR_IF(ret == -1, \"ftruncate\");\n\nshare_mem = (char*)mmap(nullptr, BUFFER_SIZE,\n\t\tPROT_READ | PROT_WRITE, MAP_SHARED, shmfd, 0);\nERROR_IF(share_mem == MAP_FAILED, \"share_mem\");\nclose(shmfd);\n\n// 取消关联\nmunmap((void*)share_mem, BUFFER_SIZE);\n```\n\n## 进程通信-管道\n\n管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证\n父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].\n\n可以用两个管道来实现双向传输数据, 也可以用`socketpair`来创建管道\n\n## 消息队列\n消息队列是两个进程之间传递二进制块数据的一种简单有效的方式.\n每个数据块都有自己的类型, 接收方可以根据类型有选择的接收数据\n\n```c++\n#include <sys/msg.h>\n// 与semget 相同, 成功返回标识符\n// msgflg的设置和作用域setget相同\nint msgget(key_t key, int msgflg);\n```\n\n```c++\n// msg_ptr参数指向一个准备发送的消息, 消息必须按如下定义\n// msg_sz 指的是mtext的长度!!!\n// msgflg通常仅支持IPC_NOWAIT 以非阻塞形式发送数据\nint msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);\n默认如果消息队列已满, 则会阻塞. 如果设置了 IPC_NOTWAIT\n就立即返回 设置errno=EAGIN\n\n系统自带这个结构体 不过mtext长度是1...\nstruct msgbuf\n{\n\tlong mtype; /* 消息类型 正整数*/\n\tchar mtext[512]; /* 消息数据*/\n}\n```\n\n```c++\n// msgtype = 0 读取消息队列第一个消息\n// msgtype > 0 读取消息队列第一个类型是msgtype的消息 除非标志了MSG_EXCEPT\n// msgtype < 0 读取第一个 类型值 < abs(msgtype)的消息\n\n// IPC_NOWAIT 如果消息队列没有消息, 则msgrcv立即返回并设置errno=ENOMSG\n// MSG_EXCEPT 如果msgtype大于0, 则接收第一个非 msgtype 的数据\n// MSG_NOERROR 消息部分长度超过msg_sz 则将它截断\nint msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);\n处于阻塞状态 当消息队列被移除(errno=EIDRM)或者程序接受到信号(errno=EINTR) 都会中断阻塞状态\n```\n\n```c++\nint msgctl(int msqid, int command, struct msqid_ds *buf);\n\nIPC_STAT 复制消息队列关联的数据结构\nIPC_SET 将buf中的部分成员更新到目标的内核数据\nIPC_RMID 立即移除消息队列, 唤醒所有等待读消息和写消息的进程\nIPC_INFO 获取系统消息队列资源配置信息\n\nMSG_INFO 返回已经分配的消息队列所占用资源信息\nMSG_STAT msgqid不再是标识符, 而是内核消息队列的数组索引\n```\n\n\n## 在进程间传递文件描述符\n\n## IPC命令-查看进程间通信的全局唯一key\n\n# 第十四章 多线程编程\n根据运行环境和调度者身份, 线程可以分为两种\n内核线程\n运行在内核空间, 由内核来调度.\n用户线程\n运行在用空间, 由线程库来调用\n\n当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.\n\n线程有三种实现方式\n- 完全在用户空间实现-无需内核支持\n\t创建和调度线程无需内核干预, 速度很快.\n\t不占用额外的内核资源, 对系统影响较小\n\t但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的\n- 完全由内核调度\n\t创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理\n\t优缺点正好与上一个相反\n- 双层调度\n\t结合了前两个的优点\n\t不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势\n\n## 进程的创建和终止\n```c++\n#include <bits/pthreadtypes.h>\ntypedef unsigned long int pthread_t;\n\n#include <pthread.h>\nint pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine)(void*), void* arg);\n// 成功返回0 失败返回错误码\n// thread 用来唯一的标识一个新线程\n// attr用来设置新县城的属性 传递NULL表示默认线程属性\n// start_routine 指定新线程运行的函数\n// arg指定函数的参数\n```\n```c++\nvoid pthread_exit(void* retval);\n用来保证线程安全干净的退出, 线程函数最好结束时调用.\n通过`retval`参数向线程的回收者传递其退出信息\n执行后不会返回到调用者, 而且永远不会失败\n\nint pthread_join(pthread_t thread, void** retval)\n可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.\n成功时返回0, 失败返回错误码\n等待其他线程结束\nthread 线程标识符\nretval 目标线程的退出返回信息\n\n错误码如下\n`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用\n`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程\n`ESRCH`目标线程不存在\n\nint pthread_cancel(pthread_t thread)\n异常终止一个线程, 即为取消线程\n成功返回0, 失败返回错误码\n\n接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.\n一下两个函数成功返回0 失败返回错误码\n```\n\n```c++\n// 启动线程取消\nint pthread_setcancelstart(int state, int* oldstate)\n第一个参数\nPTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态\nPTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求指导\n这个线程允许被取消\n第二个参数 返回之前设定的状态\n\n// 设置线程取消类型\nint pthread_setcanceltype(int type, int* oldtype)\n第一个参数\nPTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消\nPTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 知道调用了下面几个所谓的取消点函数\n最好使用`pthread_testcancel`函数设置取消点\n设置取消类型(如何取消)\n第二个参数\n原来的取消类型\n```\n\n## POSIX信号量-进程的同步\n多线程也必须考虑线程同步的问题.\n虽然`pthread_join`可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求\n比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.\n\n以下函数成功返回0 失败返回-1 errno\n`int sem_init(sem_t* sem, int pshared, unsigned int value)`\n用于初始化一个未命名的信号量.\n如果`pshared`为0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享\n`value`指定参数的初始值\n*初始化已经存在的信号量会导致无法预期的结果*\n\n`int sem_destory(sem_t* sem)`\n销毁信号量, 释放其占用的系统资源\n*销毁正被其他线程等待的信号量, 将会导致无法预期的结果*\n\n`int sem_wait(sem_t* sem)`\n以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞, 知道信号量具有非0值\n\n`int sem_trywait(sem_t* sem)`\n跟上面的函数相同不过不会阻塞. 信号量不为0 则 -1, 为0 则返回-1 errno\n\n`int sem_post(sem_t sem)`\n原子操作将信号量的值 +1","source":"_posts/CPP-读书记录102-高性能服务器编程读书记录进程线程部分.md","raw":"---\ntitle: Linux高性能服务器-进程线程\ntags:\n  - null\ncategories:\n  - CPP\n  - 服务器编程-书籍记录\ndate: 2020-02-25 22:34:39\n\ntop: 102\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg\n---\n# 第十三章多进程编程\n\n## exec系列系统调用\n```c++\n#include <unistd.h>\n// 声明这个是外部函数或外部变量\nextern char** environ;\n\n// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻\n// arg-接受可变参数 和 argv用于向新的程序传递参数数组\n// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量\n// exec函数是不返回的, 除非出错\n// 如果未报错则源程序被新的程序完全替换\n\nint execl(const char* path, const char* arg, ...);\nint execlp(const char* file, const char* arg, ...);\nint execle(const char* path, const char* arg, ..., char* const envp[])\nint execv(const char* path, char* const argv[]);\nint execvp(const char* file, char* const argv[]);\nint execve(const char* path, char* const argv[], char* const envp[]);\n```\n## fork系统调用-进程的创建\n```c++\n#include <sys/types.h>\n#include <unistd.h>\n// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0\n// 次返回值用于区分是父进程还是子进程\n// 失败返回-1\npid_t fork(viod);\n```\nfork系统调用\nfork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项\n新的进程表项有很多的属性和原进程相同\n- 堆指针\n- 栈指针\n- 标志寄存器的值\n- 子进程代码与父进程完全相同\n- 同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)父进程的数据(堆数据, 栈数据, 静态数据)\n- 创建子进程后, *父进程打开的文件描述符默认在子进程中也是打开的* `文件描述符的引用计数`, `父进程的用户根目录, 当前工作目录等变量的引用计数` 均加1\n\n也存在不同的项目\n- 该进程的PPID(标识父进程)被设置成原进程的PID,  \n- `信号位图被清除`(原进程设置的信号处理函数对新进程无效)\n\n\n(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)\n\n\nThe child process is an exact duplicate of the parent process except\nfor the following points:\n*  The child has its own unique process ID, and this PID does not\n\tmatch the ID of any existing process group (setpgid(2)) or\n\tsession. 子进程拥有自己唯一的进程ID, 不与其他相同\n\n*  The child's parent process ID is the same as the parent's process\n\tID. 子进程的父进程ID PPID 与父进程ID PID相同\n\n*  The child does not inherit its parent's memory locks (mlock(2),\n\tmlockall(2)). 子进程不继承父进程的内存锁(保证一部分内存处于内存中, 而不是sawp分区)\n\n*  Process resource utilizations (getrusage(2)) and CPU time counters\n\t(times(2)) are reset to zero in the child.\n\t进程资源使用和CPU时间计数器在子进程中重置为0\n\n*  The child's set of pending signals is initially empty\n\t(sigpending(2)). 信号位图被初始化为空 原信号处理函数对子进程无效 需重新设置\n\n*  The child does not inherit semaphore adjustments from its parent\n\t(semop(2)). 不会继承semadj\n\n*  The child does not inherit process-associated record locks from\n\tits parent (fcntl(2)).  (On the other hand, it does inherit\n\tfcntl(2) open file description locks and flock(2) locks from its\n\tparent.)\n\n*  The child does not inherit timers from its parent (setitimer(2),\n\talarm(2), timer_create(2)). 不会继承定时器\n\n*  The child does not inherit outstanding asynchronous I/O operations\n\tfrom its parent (aio_read(3), aio_write(3)), nor does it inherit\n\tany asynchronous I/O contexts from its parent (see io_setup(2)).\n\n\n\n\n## 处理僵尸进程-进程的管理\n```c++\n#include <sys/types.h>\n#include <sys/wait.h>\n// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.\npid_t wait(int* stat_loc);\n\n// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)\n// options函数取值WNOHANG-waitpid立即返回\n// 如果目标子进程正常退出, 则返回子进程的pid\n// 如果还没有结束或意外终止, 则立即返回0\n// 调用失败返回-1\npid_t waitpid(pid_t pid, int* stat_loc, int options);\n\nWIFEXITED(stat_val); // 子进程正常结束, 返回一个非0\nWEXITSTATUS(stat_val); // 如果WIFEXITED 非0, 它返回子进程的退出码\nWIFSIGNALED(stat_val);// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值\nWTERMSIG(stat_val);// 如果WIFSIGNALED非0 返回一个信号值\nWIFSTOPPED(stat_val);// 如果子进程意外终止, 它返回一个非0值\nWSTOPSIG(stat_val);// 如果WIFSTOPED非0, 它返回一个信号值\n```\n\n对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询\n- 在`子进程结束运行之后, 父进程读取其退出状态前`, 我们称该子进程处于`僵尸态`\n- 另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) `父进程结束运行之后, 子进程退出之前`, 处于`僵尸态`\n\n以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.\n\nwaitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.\nSIGCHLD信号- 子进程结束后将会给父进程发送此信号\n```c++\nstatic void handle_child(int sig)\n{\n\tpid_t pid;\n\tint stat;\n\twhile ((pid = waitpid(-1, &stat, WNOHANG)) > 0)\n\t{\n\t\t// 善后处理emmmm\n\t}\n}\n```\n\n## 信号量-进程的锁\n*信号量原语*\n只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.\n假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为\n- P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行\n- V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png)\n\n**总结PV使用方法**\n\n使用`semget`获取到唯一的标识.\n使用`semctl`的`SETVAL`传入初始化val的`sem_un`联合体.来初始化val\n调用`semop` 传入唯一标识, `sem_op=-1`执行P(锁)操作`sem_op=1`执行V(开锁)操作\n开关锁通过当`sem_op=-1,semval=0 `\n且未指定`IPC_NOWAIT`\n等待`semval`被`sem_op=1`改为`semval=1`\n\n**创建信号量**\n```c++\n// semeget 系统调用\n// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集\n// key 参数是一个键值, 用来标识一个全局唯一的信号量级,可以在不同进程中获取\n// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0. 一般都是为1\n// sem_flags指定一组标志, 来控制权限\n// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错\n// - IPC_CREAT | IPC_EXCL来创建一组唯一信号量集 如果已经存在则会返回错误 errno = EEXIST\n// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1\nint semget(key_t key, int num_sems, int sem_flags);\n\nint sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT);\n```\n\n**初始化**\n```c++\n// semctl 系统调用\n// sem_id 参数是由semget返回的信号量集标识符\n// sen_num指定被操作的信号量在信号集中的编号\n// command指定命令, 可以追加命令所需的参数, 不过有推荐格式\n// 成功返回对应command的参数, 失败返回-1 errno\nint semctl(int sem_id, int sem_num, int command, ...);\n\n// 第四个参数 竟然需要手动声明...\nunion semun\n{\n\tint              val;    /* Value for SETVAL */\n\tstruct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */\n\tunsigned short  *array;  /* Array for GETALL, SETALL */\n\tstruct seminfo  *__buf;  /* Buffer for IPC_INFO\n\t\t\t\t\t\t\t\t(Linux-specific) */\n};\n// 初始化信号量\nunion semun sem_union;\nsem_union.val = 1;\n// 这里可以直接第三个参数传入1(val)\nif (semctl(sem_id, 0, SETVAL, sem_union) == -1)\n{\n\texit(0);\n}\n\n// 删除信号量\nunion semun sem_union{};\nif (semctl(sem_id, 0, IPC_RMID, sem_union) == -1)\n{\n\texit(EXIT_FAILURE);\n}\n```\n---\n与semop信号量关联的一些重要的内核变量\n```c++\nunsigned short semval; // 信号量的值\nunsigned short semzcnt; // 等待信号量值变为0的进程数量\nunsigned short semncnt// 等待信号量值增加的进程数量\npid_t sempid; // 最后一次执行semop操作的进程ID\n```\n操作信号量, 实际上就是对上面的内核变量操作\n\n```c++\n// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.\n// sem_ops 参数指向一个sembuf结构体类型的数组\n// num_sem_ops 说明操作数组中哪个信号量\n// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行\nint semop(int sem_id, struct sembuf* sem_ops, size_t num_sem_ops);\n\n// sem_op < 0 期望获得信号量\n// semval-=abs(sem_op),要求调用进程对被操作信号量集有写权限\n// 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量\n\n// 如果semval < abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN\n// 如果没有指定 则 阻塞进程等待信号量可用, 且 semzcnt +=1, 等到下面三种情况唤醒\n// 1 发生semval >= abs(sem_op), semzcnt-=1, semval-=abs(sem_op). 在SEM_UNDO设置时更新semadj\n// 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)\n// 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)\nbool P(int sem_id)\n{\n    struct sembuf sem_b;\n    sem_b.sem_num = 0; // 信号量编号 第几个信号量 一般都是第0个\n    sem_b.sem_op = -1; // P\n\t// IPC_NOWAIT 无论信号量操作是否成功, 都立即返回\n\t// SEM_UNDO当进程退出的时候, 取消正在进行的semop操作 PV操作系统更新进程的semadj变量\n    sem_b.sem_flg = SEM_UNDO;\n    return semop(sem_id, &sem_b, 1) != -1;\n}\n\n\n// sem_op > 0 \n// semval+=sem_op , 要求调用进程对被操作的信号量集有写权限\n// 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)\nbool V(int sem_id)\n{\n    struct sembuf sem_b;\n    sem_b.sem_num = 0;\n    sem_b.sem_op = 1; // V\n    sem_b.sem_flg = SEM_UNDO;\n    return semop(sem_id, &sem_b, 1) != -1;\n}\n\n\n// -- sem_op = 0\n// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限\n// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0\n// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN\n// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生\n// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1\n// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM\n// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1\n\n```\n\nsemget成功时返回一个与之关联的内核结构体semid_ds\n```c++\nstruct semid_ds\n{\n\tstruct ipc_perm sem_perm;\n\tunsigned long int sem_nsems; // 被设置为num_sems\n\ttime_t sem_otime; // 被设置为0\n\ttime_t sem_ctime; // 被设置为当前的系统时间\n}\n// 用来描述权限\nstruct ipc_perm\n{\n\tuid_t uid; // 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID\n\tgid_t gid; // 所有者的有效组ID, 被semget设置为调用进程的有效用户ID\n\tuid_t cuid; // 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID\n\tgid_t cgid; // 创建者的有效组ID, 被semget设置为调用进程的有效用户ID\n\tmode_t mode;// 访问权限, 背着只为sem_flags参数的最低9位.\n}\n```\n\n## 共享内存-进程间通信\n**最高效的IPC(进程间通信)机制**\n需要自己同步进程对其的访问, 否则会产生竞态条件\n\n```c++\n// key\n// 与semget相同 标识一段全局唯一的共享内存\n// size 内存区域大小 单位字节\n// shmflg\n// IPC_CREAT 存不存在都创建新的共享内存\n// IPC_CREAT | IPC_EXCL 不存在则创建 存在则报错\n// SHM_HUGETLB 系统将使用\"大页面\"来为共享内存分配空间\n// SHM_NORESERVE 不为共享内存保留swap空间, 如果物理内存不足\n// -在执行写操作的时候将会触发`SIGSEGV`信号\n// -成功返回唯一标识, 失败返回-1 errno\nint shmget(key_t key, size_t size, int shmflg)\n```\n\n```c++\n// shm_id \n// shmget返回的唯一标识\n// shm_addr \n// 关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响\n// 如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强\n// 如果 shm_addr 非空,且没有`SHM_RND`标志 则关联到指定的地址处\n// 如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写*\n// shmflg\n// SHM_RDONLY 设置后内存内容变成只读, 不设置则为读写模式\n// SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联\n// SHM_EXEC 有执行权限\n// 成功返回关联到的地址, 失败返回 (void*)-1 errno\nvoid* shmat(int shm_id, const void* shm_addr, int shmflg)\n\n// 将共享内存关联到进程的地址空间 调用成功之后, 修改shmid_ds的部分内容\n// -shm_nattach +1\n// -更新 shm_lpid\n// -shm_atime设置为当前时间\n```\n\n\n```c++\n// 将共享内存从进程地址空间中分离\n// 成功后\n// -shm_nattach -1\n// -更新 shm_lpid和shm_dtime设置为当前时间\n// 成功返回0 失败返回-1 errno\nint shmdt(const void* shm_addr)\n```\n\n```c++\nint shm_ctl(int shm_id, int command, struct shmid_ds* buf)\n```\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/shmctl.png)\n\n----\n\nshmget 同时会创建对应的`shmid_ds`结构体\n```c++\nstruct shmid_ds\n{\n\tstruct ipc_perm shm_per; // 权限相关\n\tsize_t shm_segsz; // 共享内存大小 单位字节\tsize\n\t__time_t shm_atime; // 对这段内存最后一次调用semat的时间 0\n\t__time_t shm_dtime; // 对这段内存最后一次调用semdt的时间 0\n\t__time_t shm_ctime; // 对这段内存最后一次调用semctl的时间 当前时间\n\t__pid_t shm_cpid; // 创建者PID\n\t__pid_t lpid; // 最后一次执行shmat或shmdt的进程PID\n\tshmatt_t shm_nattach // 关联到此共享内存空间的进程数量\n}\n```\n\n**共享内存的POSIX方法**\n```c++\nint shmfd = shm_open(\"/shm_name\", O_CREAT | O_RDWR, 0666);\nERROR_IF(shmfd == -1, \"shm open\");\n\nint ret = ftruncate(shmfd, BUFFER_SIZE);\nERROR_IF(ret == -1, \"ftruncate\");\n\nshare_mem = (char*)mmap(nullptr, BUFFER_SIZE,\n\t\tPROT_READ | PROT_WRITE, MAP_SHARED, shmfd, 0);\nERROR_IF(share_mem == MAP_FAILED, \"share_mem\");\nclose(shmfd);\n\n// 取消关联\nmunmap((void*)share_mem, BUFFER_SIZE);\n```\n\n## 进程通信-管道\n\n管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证\n父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].\n\n可以用两个管道来实现双向传输数据, 也可以用`socketpair`来创建管道\n\n## 消息队列\n消息队列是两个进程之间传递二进制块数据的一种简单有效的方式.\n每个数据块都有自己的类型, 接收方可以根据类型有选择的接收数据\n\n```c++\n#include <sys/msg.h>\n// 与semget 相同, 成功返回标识符\n// msgflg的设置和作用域setget相同\nint msgget(key_t key, int msgflg);\n```\n\n```c++\n// msg_ptr参数指向一个准备发送的消息, 消息必须按如下定义\n// msg_sz 指的是mtext的长度!!!\n// msgflg通常仅支持IPC_NOWAIT 以非阻塞形式发送数据\nint msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);\n默认如果消息队列已满, 则会阻塞. 如果设置了 IPC_NOTWAIT\n就立即返回 设置errno=EAGIN\n\n系统自带这个结构体 不过mtext长度是1...\nstruct msgbuf\n{\n\tlong mtype; /* 消息类型 正整数*/\n\tchar mtext[512]; /* 消息数据*/\n}\n```\n\n```c++\n// msgtype = 0 读取消息队列第一个消息\n// msgtype > 0 读取消息队列第一个类型是msgtype的消息 除非标志了MSG_EXCEPT\n// msgtype < 0 读取第一个 类型值 < abs(msgtype)的消息\n\n// IPC_NOWAIT 如果消息队列没有消息, 则msgrcv立即返回并设置errno=ENOMSG\n// MSG_EXCEPT 如果msgtype大于0, 则接收第一个非 msgtype 的数据\n// MSG_NOERROR 消息部分长度超过msg_sz 则将它截断\nint msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);\n处于阻塞状态 当消息队列被移除(errno=EIDRM)或者程序接受到信号(errno=EINTR) 都会中断阻塞状态\n```\n\n```c++\nint msgctl(int msqid, int command, struct msqid_ds *buf);\n\nIPC_STAT 复制消息队列关联的数据结构\nIPC_SET 将buf中的部分成员更新到目标的内核数据\nIPC_RMID 立即移除消息队列, 唤醒所有等待读消息和写消息的进程\nIPC_INFO 获取系统消息队列资源配置信息\n\nMSG_INFO 返回已经分配的消息队列所占用资源信息\nMSG_STAT msgqid不再是标识符, 而是内核消息队列的数组索引\n```\n\n\n## 在进程间传递文件描述符\n\n## IPC命令-查看进程间通信的全局唯一key\n\n# 第十四章 多线程编程\n根据运行环境和调度者身份, 线程可以分为两种\n内核线程\n运行在内核空间, 由内核来调度.\n用户线程\n运行在用空间, 由线程库来调用\n\n当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.\n\n线程有三种实现方式\n- 完全在用户空间实现-无需内核支持\n\t创建和调度线程无需内核干预, 速度很快.\n\t不占用额外的内核资源, 对系统影响较小\n\t但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的\n- 完全由内核调度\n\t创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理\n\t优缺点正好与上一个相反\n- 双层调度\n\t结合了前两个的优点\n\t不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势\n\n## 进程的创建和终止\n```c++\n#include <bits/pthreadtypes.h>\ntypedef unsigned long int pthread_t;\n\n#include <pthread.h>\nint pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine)(void*), void* arg);\n// 成功返回0 失败返回错误码\n// thread 用来唯一的标识一个新线程\n// attr用来设置新县城的属性 传递NULL表示默认线程属性\n// start_routine 指定新线程运行的函数\n// arg指定函数的参数\n```\n```c++\nvoid pthread_exit(void* retval);\n用来保证线程安全干净的退出, 线程函数最好结束时调用.\n通过`retval`参数向线程的回收者传递其退出信息\n执行后不会返回到调用者, 而且永远不会失败\n\nint pthread_join(pthread_t thread, void** retval)\n可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.\n成功时返回0, 失败返回错误码\n等待其他线程结束\nthread 线程标识符\nretval 目标线程的退出返回信息\n\n错误码如下\n`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用\n`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程\n`ESRCH`目标线程不存在\n\nint pthread_cancel(pthread_t thread)\n异常终止一个线程, 即为取消线程\n成功返回0, 失败返回错误码\n\n接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.\n一下两个函数成功返回0 失败返回错误码\n```\n\n```c++\n// 启动线程取消\nint pthread_setcancelstart(int state, int* oldstate)\n第一个参数\nPTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态\nPTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求指导\n这个线程允许被取消\n第二个参数 返回之前设定的状态\n\n// 设置线程取消类型\nint pthread_setcanceltype(int type, int* oldtype)\n第一个参数\nPTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消\nPTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 知道调用了下面几个所谓的取消点函数\n最好使用`pthread_testcancel`函数设置取消点\n设置取消类型(如何取消)\n第二个参数\n原来的取消类型\n```\n\n## POSIX信号量-进程的同步\n多线程也必须考虑线程同步的问题.\n虽然`pthread_join`可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求\n比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.\n\n以下函数成功返回0 失败返回-1 errno\n`int sem_init(sem_t* sem, int pshared, unsigned int value)`\n用于初始化一个未命名的信号量.\n如果`pshared`为0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享\n`value`指定参数的初始值\n*初始化已经存在的信号量会导致无法预期的结果*\n\n`int sem_destory(sem_t* sem)`\n销毁信号量, 释放其占用的系统资源\n*销毁正被其他线程等待的信号量, 将会导致无法预期的结果*\n\n`int sem_wait(sem_t* sem)`\n以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞, 知道信号量具有非0值\n\n`int sem_trywait(sem_t* sem)`\n跟上面的函数相同不过不会阻塞. 信号量不为0 则 -1, 为0 则返回-1 errno\n\n`int sem_post(sem_t sem)`\n原子操作将信号量的值 +1","slug":"CPP-读书记录102-高性能服务器编程读书记录进程线程部分","published":1,"updated":"2020-03-15T01:43:24.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucv4001b8cuo5p365m1y","content":"<h1 id=\"第十三章多进程编程\"><a href=\"#第十三章多进程编程\" class=\"headerlink\" title=\"第十三章多进程编程\"></a>第十三章多进程编程</h1><h2 id=\"exec系列系统调用\"><a href=\"#exec系列系统调用\" class=\"headerlink\" title=\"exec系列系统调用\"></a>exec系列系统调用</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 声明这个是外部函数或外部变量</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">char</span>** environ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻</span></span><br><span class=\"line\"><span class=\"comment\">// arg-接受可变参数 和 argv用于向新的程序传递参数数组</span></span><br><span class=\"line\"><span class=\"comment\">// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量</span></span><br><span class=\"line\"><span class=\"comment\">// exec函数是不返回的, 除非出错</span></span><br><span class=\"line\"><span class=\"comment\">// 如果未报错则源程序被新的程序完全替换</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execl</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* arg, ...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execlp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* file, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* arg, ...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execle</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* arg, ..., <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> envp[])</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execv</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execvp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* file, <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execve</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> argv[], <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"fork系统调用-进程的创建\"><a href=\"#fork系统调用-进程的创建\" class=\"headerlink\" title=\"fork系统调用-进程的创建\"></a>fork系统调用-进程的创建</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0</span></span><br><span class=\"line\"><span class=\"comment\">// 次返回值用于区分是父进程还是子进程</span></span><br><span class=\"line\"><span class=\"comment\">// 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">fork</span><span class=\"params\">(viod)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>fork系统调用<br>fork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项<br>新的进程表项有很多的属性和原进程相同</p>\n<ul>\n<li>堆指针</li>\n<li>栈指针</li>\n<li>标志寄存器的值</li>\n<li>子进程代码与父进程完全相同</li>\n<li>同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)父进程的数据(堆数据, 栈数据, 静态数据)</li>\n<li>创建子进程后, <em>父进程打开的文件描述符默认在子进程中也是打开的</em> <code>文件描述符的引用计数</code>, <code>父进程的用户根目录, 当前工作目录等变量的引用计数</code> 均加1</li>\n</ul>\n<p>也存在不同的项目</p>\n<ul>\n<li>该进程的PPID(标识父进程)被设置成原进程的PID,  </li>\n<li><code>信号位图被清除</code>(原进程设置的信号处理函数对新进程无效)</li>\n</ul>\n<p>(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)</p>\n<p>The child process is an exact duplicate of the parent process except<br>for the following points:</p>\n<ul>\n<li><p>The child has its own unique process ID, and this PID does not<br> match the ID of any existing process group (setpgid(2)) or<br> session. 子进程拥有自己唯一的进程ID, 不与其他相同</p>\n</li>\n<li><p>The child’s parent process ID is the same as the parent’s process<br> ID. 子进程的父进程ID PPID 与父进程ID PID相同</p>\n</li>\n<li><p>The child does not inherit its parent’s memory locks (mlock(2),<br> mlockall(2)). 子进程不继承父进程的内存锁(保证一部分内存处于内存中, 而不是sawp分区)</p>\n</li>\n<li><p>Process resource utilizations (getrusage(2)) and CPU time counters<br> (times(2)) are reset to zero in the child.<br> 进程资源使用和CPU时间计数器在子进程中重置为0</p>\n</li>\n<li><p>The child’s set of pending signals is initially empty<br> (sigpending(2)). 信号位图被初始化为空 原信号处理函数对子进程无效 需重新设置</p>\n</li>\n<li><p>The child does not inherit semaphore adjustments from its parent<br> (semop(2)). 不会继承semadj</p>\n</li>\n<li><p>The child does not inherit process-associated record locks from<br> its parent (fcntl(2)).  (On the other hand, it does inherit<br> fcntl(2) open file description locks and flock(2) locks from its<br> parent.)</p>\n</li>\n<li><p>The child does not inherit timers from its parent (setitimer(2),<br> alarm(2), timer_create(2)). 不会继承定时器</p>\n</li>\n<li><p>The child does not inherit outstanding asynchronous I/O operations<br> from its parent (aio_read(3), aio_write(3)), nor does it inherit<br> any asynchronous I/O contexts from its parent (see io_setup(2)).</p>\n</li>\n</ul>\n<h2 id=\"处理僵尸进程-进程的管理\"><a href=\"#处理僵尸进程-进程的管理\" class=\"headerlink\" title=\"处理僵尸进程-进程的管理\"></a>处理僵尸进程-进程的管理</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">wait</span><span class=\"params\">(<span class=\"keyword\">int</span>* stat_loc)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)</span></span><br><span class=\"line\"><span class=\"comment\">// options函数取值WNOHANG-waitpid立即返回</span></span><br><span class=\"line\"><span class=\"comment\">// 如果目标子进程正常退出, 则返回子进程的pid</span></span><br><span class=\"line\"><span class=\"comment\">// 如果还没有结束或意外终止, 则立即返回0</span></span><br><span class=\"line\"><span class=\"comment\">// 调用失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">waitpid</span><span class=\"params\">(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span>* stat_loc, <span class=\"keyword\">int</span> options)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">WIFEXITED(stat_val); <span class=\"comment\">// 子进程正常结束, 返回一个非0</span></span><br><span class=\"line\">WEXITSTATUS(stat_val); <span class=\"comment\">// 如果WIFEXITED 非0, 它返回子进程的退出码</span></span><br><span class=\"line\">WIFSIGNALED(stat_val);<span class=\"comment\">// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值</span></span><br><span class=\"line\">WTERMSIG(stat_val);<span class=\"comment\">// 如果WIFSIGNALED非0 返回一个信号值</span></span><br><span class=\"line\">WIFSTOPPED(stat_val);<span class=\"comment\">// 如果子进程意外终止, 它返回一个非0值</span></span><br><span class=\"line\">WSTOPSIG(stat_val);<span class=\"comment\">// 如果WIFSTOPED非0, 它返回一个信号值</span></span><br></pre></td></tr></table></figure>\n\n<p>对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询</p>\n<ul>\n<li>在<code>子进程结束运行之后, 父进程读取其退出状态前</code>, 我们称该子进程处于<code>僵尸态</code></li>\n<li>另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) <code>父进程结束运行之后, 子进程退出之前</code>, 处于<code>僵尸态</code></li>\n</ul>\n<p>以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.</p>\n<p>waitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.<br>SIGCHLD信号- 子进程结束后将会给父进程发送此信号</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handle_child</span><span class=\"params\">(<span class=\"keyword\">int</span> sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pid_t</span> pid;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stat;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((pid = waitpid(<span class=\"number\">-1</span>, &amp;stat, WNOHANG)) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 善后处理emmmm</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"信号量-进程的锁\"><a href=\"#信号量-进程的锁\" class=\"headerlink\" title=\"信号量-进程的锁\"></a>信号量-进程的锁</h2><p><em>信号量原语</em><br>只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.<br>假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为</p>\n<ul>\n<li>P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行</li>\n<li>V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png\" alt=\"\"></li>\n</ul>\n<p><strong>总结PV使用方法</strong></p>\n<p>使用<code>semget</code>获取到唯一的标识.<br>使用<code>semctl</code>的<code>SETVAL</code>传入初始化val的<code>sem_un</code>联合体.来初始化val<br>调用<code>semop</code> 传入唯一标识, <code>sem_op=-1</code>执行P(锁)操作<code>sem_op=1</code>执行V(开锁)操作<br>开关锁通过当<code>sem_op=-1,semval=0</code><br>且未指定<code>IPC_NOWAIT</code><br>等待<code>semval</code>被<code>sem_op=1</code>改为<code>semval=1</code></p>\n<p><strong>创建信号量</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// semeget 系统调用</span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集</span></span><br><span class=\"line\"><span class=\"comment\">// key 参数是一个键值, 用来标识一个全局唯一的信号量级,可以在不同进程中获取</span></span><br><span class=\"line\"><span class=\"comment\">// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0. 一般都是为1</span></span><br><span class=\"line\"><span class=\"comment\">// sem_flags指定一组标志, 来控制权限</span></span><br><span class=\"line\"><span class=\"comment\">// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错</span></span><br><span class=\"line\"><span class=\"comment\">// - IPC_CREAT | IPC_EXCL来创建一组唯一信号量集 如果已经存在则会返回错误 errno = EEXIST</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">int</span> num_sems, <span class=\"keyword\">int</span> sem_flags)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> sem_id = semget((<span class=\"keyword\">key_t</span>)<span class=\"number\">1234</span>, <span class=\"number\">1</span>, <span class=\"number\">0666</span> | IPC_CREAT);</span><br></pre></td></tr></table></figure>\n\n<p><strong>初始化</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// semctl 系统调用</span></span><br><span class=\"line\"><span class=\"comment\">// sem_id 参数是由semget返回的信号量集标识符</span></span><br><span class=\"line\"><span class=\"comment\">// sen_num指定被操作的信号量在信号集中的编号</span></span><br><span class=\"line\"><span class=\"comment\">// command指定命令, 可以追加命令所需的参数, 不过有推荐格式</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回对应command的参数, 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semctl</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id, <span class=\"keyword\">int</span> sem_num, <span class=\"keyword\">int</span> command, ...)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第四个参数 竟然需要手动声明...</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> semun</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>              val;    <span class=\"comment\">/* Value for SETVAL */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">semid_ds</span> *<span class=\"title\">buf</span>;</span>    <span class=\"comment\">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> short  *<span class=\"built_in\">array</span>;  <span class=\"comment\">/* Array for GETALL, SETALL */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">seminfo</span>  *__<span class=\"title\">buf</span>;</span>  <span class=\"comment\">/* Buffer for IPC_INFO</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t(Linux-specific) */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 初始化信号量</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> semun sem_union;</span><br><span class=\"line\">sem_union.val = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这里可以直接第三个参数传入1(val)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (semctl(sem_id, <span class=\"number\">0</span>, SETVAL, sem_union) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除信号量</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> semun sem_union&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (semctl(sem_id, <span class=\"number\">0</span>, IPC_RMID, sem_union) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>与semop信号量关联的一些重要的内核变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> short semval; <span class=\"comment\">// 信号量的值</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> short semzcnt; <span class=\"comment\">// 等待信号量值变为0的进程数量</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> short semncnt<span class=\"comment\">// 等待信号量值增加的进程数量</span></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> sempid; <span class=\"comment\">// 最后一次执行semop操作的进程ID</span></span><br></pre></td></tr></table></figure>\n<p>操作信号量, 实际上就是对上面的内核变量操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.</span></span><br><span class=\"line\"><span class=\"comment\">// sem_ops 参数指向一个sembuf结构体类型的数组</span></span><br><span class=\"line\"><span class=\"comment\">// num_sem_ops 说明操作数组中哪个信号量</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semop</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id, struct sembuf* sem_ops, <span class=\"keyword\">size_t</span> num_sem_ops)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sem_op &lt; 0 期望获得信号量</span></span><br><span class=\"line\"><span class=\"comment\">// semval-=abs(sem_op),要求调用进程对被操作信号量集有写权限</span></span><br><span class=\"line\"><span class=\"comment\">// 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果semval &lt; abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN</span></span><br><span class=\"line\"><span class=\"comment\">// 如果没有指定 则 阻塞进程等待信号量可用, 且 semzcnt +=1, 等到下面三种情况唤醒</span></span><br><span class=\"line\"><span class=\"comment\">// 1 发生semval &gt;= abs(sem_op), semzcnt-=1, semval-=abs(sem_op). 在SEM_UNDO设置时更新semadj</span></span><br><span class=\"line\"><span class=\"comment\">// 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)</span></span><br><span class=\"line\"><span class=\"comment\">// 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">P</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sembuf</span> <span class=\"title\">sem_b</span>;</span></span><br><span class=\"line\">    sem_b.sem_num = <span class=\"number\">0</span>; <span class=\"comment\">// 信号量编号 第几个信号量 一般都是第0个</span></span><br><span class=\"line\">    sem_b.sem_op = <span class=\"number\">-1</span>; <span class=\"comment\">// P</span></span><br><span class=\"line\">\t<span class=\"comment\">// IPC_NOWAIT 无论信号量操作是否成功, 都立即返回</span></span><br><span class=\"line\">\t<span class=\"comment\">// SEM_UNDO当进程退出的时候, 取消正在进行的semop操作 PV操作系统更新进程的semadj变量</span></span><br><span class=\"line\">    sem_b.sem_flg = SEM_UNDO;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> semop(sem_id, &amp;sem_b, <span class=\"number\">1</span>) != <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sem_op &gt; 0 </span></span><br><span class=\"line\"><span class=\"comment\">// semval+=sem_op , 要求调用进程对被操作的信号量集有写权限</span></span><br><span class=\"line\"><span class=\"comment\">// 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">V</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sembuf</span> <span class=\"title\">sem_b</span>;</span></span><br><span class=\"line\">    sem_b.sem_num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    sem_b.sem_op = <span class=\"number\">1</span>; <span class=\"comment\">// V</span></span><br><span class=\"line\">    sem_b.sem_flg = SEM_UNDO;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> semop(sem_id, &amp;sem_b, <span class=\"number\">1</span>) != <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- sem_op = 0</span></span><br><span class=\"line\"><span class=\"comment\">// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限</span></span><br><span class=\"line\"><span class=\"comment\">// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0</span></span><br><span class=\"line\"><span class=\"comment\">// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN</span></span><br><span class=\"line\"><span class=\"comment\">// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生</span></span><br><span class=\"line\"><span class=\"comment\">// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1</span></span><br><span class=\"line\"><span class=\"comment\">// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM</span></span><br><span class=\"line\"><span class=\"comment\">// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1</span></span><br></pre></td></tr></table></figure>\n\n<p>semget成功时返回一个与之关联的内核结构体semid_ds</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">semid_ds</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">sem_perm</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> sem_nsems; <span class=\"comment\">// 被设置为num_sems</span></span><br><span class=\"line\">\t<span class=\"keyword\">time_t</span> sem_otime; <span class=\"comment\">// 被设置为0</span></span><br><span class=\"line\">\t<span class=\"keyword\">time_t</span> sem_ctime; <span class=\"comment\">// 被设置为当前的系统时间</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 用来描述权限</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">uid_t</span> uid; <span class=\"comment\">// 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">gid_t</span> gid; <span class=\"comment\">// 所有者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">uid_t</span> cuid; <span class=\"comment\">// 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">gid_t</span> cgid; <span class=\"comment\">// 创建者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">mode_t</span> mode;<span class=\"comment\">// 访问权限, 背着只为sem_flags参数的最低9位.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"共享内存-进程间通信\"><a href=\"#共享内存-进程间通信\" class=\"headerlink\" title=\"共享内存-进程间通信\"></a>共享内存-进程间通信</h2><p><strong>最高效的IPC(进程间通信)机制</strong><br>需要自己同步进程对其的访问, 否则会产生竞态条件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// key</span></span><br><span class=\"line\"><span class=\"comment\">// 与semget相同 标识一段全局唯一的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">// size 内存区域大小 单位字节</span></span><br><span class=\"line\"><span class=\"comment\">// shmflg</span></span><br><span class=\"line\"><span class=\"comment\">// IPC_CREAT 存不存在都创建新的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">// IPC_CREAT | IPC_EXCL 不存在则创建 存在则报错</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_HUGETLB 系统将使用\"大页面\"来为共享内存分配空间</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_NORESERVE 不为共享内存保留swap空间, 如果物理内存不足</span></span><br><span class=\"line\"><span class=\"comment\">// -在执行写操作的时候将会触发`SIGSEGV`信号</span></span><br><span class=\"line\"><span class=\"comment\">// -成功返回唯一标识, 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">size_t</span> <span class=\"built_in\">size</span>, <span class=\"keyword\">int</span> shmflg)</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// shm_id </span></span><br><span class=\"line\"><span class=\"comment\">// shmget返回的唯一标识</span></span><br><span class=\"line\"><span class=\"comment\">// shm_addr </span></span><br><span class=\"line\"><span class=\"comment\">// 关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响</span></span><br><span class=\"line\"><span class=\"comment\">// 如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 shm_addr 非空,且没有`SHM_RND`标志 则关联到指定的地址处</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写*</span></span><br><span class=\"line\"><span class=\"comment\">// shmflg</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_RDONLY 设置后内存内容变成只读, 不设置则为读写模式</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_EXEC 有执行权限</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回关联到的地址, 失败返回 (void*)-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">shmat</span><span class=\"params\">(<span class=\"keyword\">int</span> shm_id, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* shm_addr, <span class=\"keyword\">int</span> shmflg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 将共享内存关联到进程的地址空间 调用成功之后, 修改shmid_ds的部分内容</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -shm_nattach +1</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -更新 shm_lpid</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -shm_atime设置为当前时间</span></span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将共享内存从进程地址空间中分离</span></span><br><span class=\"line\"><span class=\"comment\">// 成功后</span></span><br><span class=\"line\"><span class=\"comment\">// -shm_nattach -1</span></span><br><span class=\"line\"><span class=\"comment\">// -更新 shm_lpid和shm_dtime设置为当前时间</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmdt</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* shm_addr)</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shm_ctl</span><span class=\"params\">(<span class=\"keyword\">int</span> shm_id, <span class=\"keyword\">int</span> command, struct shmid_ds* buf)</span></span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/shmctl.png\" alt=\"\"></p>\n<hr>\n<p>shmget 同时会创建对应的<code>shmid_ds</code>结构体</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">shmid_ds</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">shm_per</span>;</span> <span class=\"comment\">// 权限相关</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> shm_segsz; <span class=\"comment\">// 共享内存大小 单位字节\tsize</span></span><br><span class=\"line\">\t<span class=\"keyword\">__time_t</span> shm_atime; <span class=\"comment\">// 对这段内存最后一次调用semat的时间 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">__time_t</span> shm_dtime; <span class=\"comment\">// 对这段内存最后一次调用semdt的时间 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">__time_t</span> shm_ctime; <span class=\"comment\">// 对这段内存最后一次调用semctl的时间 当前时间</span></span><br><span class=\"line\">\t<span class=\"keyword\">__pid_t</span> shm_cpid; <span class=\"comment\">// 创建者PID</span></span><br><span class=\"line\">\t<span class=\"keyword\">__pid_t</span> lpid; <span class=\"comment\">// 最后一次执行shmat或shmdt的进程PID</span></span><br><span class=\"line\">\t<span class=\"keyword\">shmatt_t</span> shm_nattach <span class=\"comment\">// 关联到此共享内存空间的进程数量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>共享内存的POSIX方法</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> shmfd = shm_open(<span class=\"string\">\"/shm_name\"</span>, O_CREAT | O_RDWR, <span class=\"number\">0666</span>);</span><br><span class=\"line\">ERROR_IF(shmfd == <span class=\"number\">-1</span>, <span class=\"string\">\"shm open\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = ftruncate(shmfd, BUFFER_SIZE);</span><br><span class=\"line\">ERROR_IF(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"ftruncate\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">share_mem = (<span class=\"keyword\">char</span>*)mmap(<span class=\"literal\">nullptr</span>, BUFFER_SIZE,</span><br><span class=\"line\">\t\tPROT_READ | PROT_WRITE, MAP_SHARED, shmfd, <span class=\"number\">0</span>);</span><br><span class=\"line\">ERROR_IF(share_mem == MAP_FAILED, <span class=\"string\">\"share_mem\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">close</span>(shmfd);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消关联</span></span><br><span class=\"line\">munmap((<span class=\"keyword\">void</span>*)share_mem, BUFFER_SIZE);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进程通信-管道\"><a href=\"#进程通信-管道\" class=\"headerlink\" title=\"进程通信-管道\"></a>进程通信-管道</h2><p>管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证<br>父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].</p>\n<p>可以用两个管道来实现双向传输数据, 也可以用<code>socketpair</code>来创建管道</p>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><p>消息队列是两个进程之间传递二进制块数据的一种简单有效的方式.<br>每个数据块都有自己的类型, 接收方可以根据类型有选择的接收数据</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/msg.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 与semget 相同, 成功返回标识符</span></span><br><span class=\"line\"><span class=\"comment\">// msgflg的设置和作用域setget相同</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// msg_ptr参数指向一个准备发送的消息, 消息必须按如下定义</span></span><br><span class=\"line\"><span class=\"comment\">// msg_sz 指的是mtext的长度!!!</span></span><br><span class=\"line\"><span class=\"comment\">// msgflg通常仅支持IPC_NOWAIT 以非阻塞形式发送数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgsnd</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *msg_ptr, <span class=\"keyword\">size_t</span> msg_sz, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br><span class=\"line\">默认如果消息队列已满, 则会阻塞. 如果设置了 IPC_NOTWAIT</span><br><span class=\"line\">就立即返回 设置errno=EAGIN</span><br><span class=\"line\"></span><br><span class=\"line\">系统自带这个结构体 不过mtext长度是<span class=\"number\">1.</span>..</span><br><span class=\"line\">struct msgbuf</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> mtype; <span class=\"comment\">/* 消息类型 正整数*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> mtext[<span class=\"number\">512</span>]; <span class=\"comment\">/* 消息数据*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// msgtype = 0 读取消息队列第一个消息</span></span><br><span class=\"line\"><span class=\"comment\">// msgtype &gt; 0 读取消息队列第一个类型是msgtype的消息 除非标志了MSG_EXCEPT</span></span><br><span class=\"line\"><span class=\"comment\">// msgtype &lt; 0 读取第一个 类型值 &lt; abs(msgtype)的消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IPC_NOWAIT 如果消息队列没有消息, 则msgrcv立即返回并设置errno=ENOMSG</span></span><br><span class=\"line\"><span class=\"comment\">// MSG_EXCEPT 如果msgtype大于0, 则接收第一个非 msgtype 的数据</span></span><br><span class=\"line\"><span class=\"comment\">// MSG_NOERROR 消息部分长度超过msg_sz 则将它截断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgrcv</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">void</span> *msg_ptr, <span class=\"keyword\">size_t</span> msg_sz, <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> msgtype, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br><span class=\"line\">处于阻塞状态 当消息队列被移除(errno=EIDRM)或者程序接受到信号(errno=EINTR) 都会中断阻塞状态</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgctl</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">int</span> command, struct msqid_ds *buf)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">IPC_STAT 复制消息队列关联的数据结构</span><br><span class=\"line\">IPC_SET 将buf中的部分成员更新到目标的内核数据</span><br><span class=\"line\">IPC_RMID 立即移除消息队列, 唤醒所有等待读消息和写消息的进程</span><br><span class=\"line\">IPC_INFO 获取系统消息队列资源配置信息</span><br><span class=\"line\"></span><br><span class=\"line\">MSG_INFO 返回已经分配的消息队列所占用资源信息</span><br><span class=\"line\">MSG_STAT msgqid不再是标识符, 而是内核消息队列的数组索引</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"在进程间传递文件描述符\"><a href=\"#在进程间传递文件描述符\" class=\"headerlink\" title=\"在进程间传递文件描述符\"></a>在进程间传递文件描述符</h2><h2 id=\"IPC命令-查看进程间通信的全局唯一key\"><a href=\"#IPC命令-查看进程间通信的全局唯一key\" class=\"headerlink\" title=\"IPC命令-查看进程间通信的全局唯一key\"></a>IPC命令-查看进程间通信的全局唯一key</h2><h1 id=\"第十四章-多线程编程\"><a href=\"#第十四章-多线程编程\" class=\"headerlink\" title=\"第十四章 多线程编程\"></a>第十四章 多线程编程</h1><p>根据运行环境和调度者身份, 线程可以分为两种<br>内核线程<br>运行在内核空间, 由内核来调度.<br>用户线程<br>运行在用空间, 由线程库来调用</p>\n<p>当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.</p>\n<p>线程有三种实现方式</p>\n<ul>\n<li>完全在用户空间实现-无需内核支持<br>  创建和调度线程无需内核干预, 速度很快.<br>  不占用额外的内核资源, 对系统影响较小<br>  但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的</li>\n<li>完全由内核调度<br>  创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理<br>  优缺点正好与上一个相反</li>\n<li>双层调度<br>  结合了前两个的优点<br>  不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势</li>\n</ul>\n<h2 id=\"进程的创建和终止\"><a href=\"#进程的创建和终止\" class=\"headerlink\" title=\"进程的创建和终止\"></a>进程的创建和终止</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/pthreadtypes.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> <span class=\"keyword\">pthread_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_create</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span>* thread, <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_attr_t</span>* attr, <span class=\"keyword\">void</span>* (*start_routine)(<span class=\"keyword\">void</span>*), <span class=\"keyword\">void</span>* arg)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回错误码</span></span><br><span class=\"line\"><span class=\"comment\">// thread 用来唯一的标识一个新线程</span></span><br><span class=\"line\"><span class=\"comment\">// attr用来设置新县城的属性 传递NULL表示默认线程属性</span></span><br><span class=\"line\"><span class=\"comment\">// start_routine 指定新线程运行的函数</span></span><br><span class=\"line\"><span class=\"comment\">// arg指定函数的参数</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>* retval)</span></span>;</span><br><span class=\"line\">用来保证线程安全干净的退出, 线程函数最好结束时调用.</span><br><span class=\"line\">通过`retval`参数向线程的回收者传递其退出信息</span><br><span class=\"line\">执行后不会返回到调用者, 而且永远不会失败</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_join</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread, <span class=\"keyword\">void</span>** retval)</span></span></span><br><span class=\"line\">可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.</span><br><span class=\"line\">成功时返回<span class=\"number\">0</span>, 失败返回错误码</span><br><span class=\"line\">等待其他线程结束</span><br><span class=\"line\">thread 线程标识符</span><br><span class=\"line\">retval 目标线程的退出返回信息</span><br><span class=\"line\"></span><br><span class=\"line\">错误码如下</span><br><span class=\"line\">`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用</span><br><span class=\"line\">`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程</span><br><span class=\"line\">`ESRCH`目标线程不存在</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cancel</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread)</span></span></span><br><span class=\"line\">异常终止一个线程, 即为取消线程</span><br><span class=\"line\">成功返回<span class=\"number\">0</span>, 失败返回错误码</span><br><span class=\"line\"></span><br><span class=\"line\">接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.</span><br><span class=\"line\">一下两个函数成功返回<span class=\"number\">0</span> 失败返回错误码</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 启动线程取消</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_setcancelstart</span><span class=\"params\">(<span class=\"keyword\">int</span> state, <span class=\"keyword\">int</span>* oldstate)</span></span></span><br><span class=\"line\">第一个参数</span><br><span class=\"line\">PTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态</span><br><span class=\"line\">PTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求指导</span><br><span class=\"line\">这个线程允许被取消</span><br><span class=\"line\">第二个参数 返回之前设定的状态</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置线程取消类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_setcanceltype</span><span class=\"params\">(<span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span>* oldtype)</span></span></span><br><span class=\"line\">第一个参数</span><br><span class=\"line\">PTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消</span><br><span class=\"line\">PTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 知道调用了下面几个所谓的取消点函数</span><br><span class=\"line\">最好使用`pthread_testcancel`函数设置取消点</span><br><span class=\"line\">设置取消类型(如何取消)</span><br><span class=\"line\">第二个参数</span><br><span class=\"line\">原来的取消类型</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"POSIX信号量-进程的同步\"><a href=\"#POSIX信号量-进程的同步\" class=\"headerlink\" title=\"POSIX信号量-进程的同步\"></a>POSIX信号量-进程的同步</h2><p>多线程也必须考虑线程同步的问题.<br>虽然<code>pthread_join</code>可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求<br>比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.</p>\n<p>以下函数成功返回0 失败返回-1 errno<br><code>int sem_init(sem_t* sem, int pshared, unsigned int value)</code><br>用于初始化一个未命名的信号量.<br>如果<code>pshared</code>为0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享<br><code>value</code>指定参数的初始值<br><em>初始化已经存在的信号量会导致无法预期的结果</em></p>\n<p><code>int sem_destory(sem_t* sem)</code><br>销毁信号量, 释放其占用的系统资源<br><em>销毁正被其他线程等待的信号量, 将会导致无法预期的结果</em></p>\n<p><code>int sem_wait(sem_t* sem)</code><br>以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞, 知道信号量具有非0值</p>\n<p><code>int sem_trywait(sem_t* sem)</code><br>跟上面的函数相同不过不会阻塞. 信号量不为0 则 -1, 为0 则返回-1 errno</p>\n<p><code>int sem_post(sem_t sem)</code><br>原子操作将信号量的值 +1</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第十三章多进程编程\"><a href=\"#第十三章多进程编程\" class=\"headerlink\" title=\"第十三章多进程编程\"></a>第十三章多进程编程</h1><h2 id=\"exec系列系统调用\"><a href=\"#exec系列系统调用\" class=\"headerlink\" title=\"exec系列系统调用\"></a>exec系列系统调用</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 声明这个是外部函数或外部变量</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">char</span>** environ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻</span></span><br><span class=\"line\"><span class=\"comment\">// arg-接受可变参数 和 argv用于向新的程序传递参数数组</span></span><br><span class=\"line\"><span class=\"comment\">// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量</span></span><br><span class=\"line\"><span class=\"comment\">// exec函数是不返回的, 除非出错</span></span><br><span class=\"line\"><span class=\"comment\">// 如果未报错则源程序被新的程序完全替换</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execl</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* arg, ...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execlp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* file, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* arg, ...)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execle</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* arg, ..., <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> envp[])</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execv</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execvp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* file, <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> argv[])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">execve</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> argv[], <span class=\"keyword\">char</span>* <span class=\"keyword\">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"fork系统调用-进程的创建\"><a href=\"#fork系统调用-进程的创建\" class=\"headerlink\" title=\"fork系统调用-进程的创建\"></a>fork系统调用-进程的创建</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0</span></span><br><span class=\"line\"><span class=\"comment\">// 次返回值用于区分是父进程还是子进程</span></span><br><span class=\"line\"><span class=\"comment\">// 失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">fork</span><span class=\"params\">(viod)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>fork系统调用<br>fork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项<br>新的进程表项有很多的属性和原进程相同</p>\n<ul>\n<li>堆指针</li>\n<li>栈指针</li>\n<li>标志寄存器的值</li>\n<li>子进程代码与父进程完全相同</li>\n<li>同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)父进程的数据(堆数据, 栈数据, 静态数据)</li>\n<li>创建子进程后, <em>父进程打开的文件描述符默认在子进程中也是打开的</em> <code>文件描述符的引用计数</code>, <code>父进程的用户根目录, 当前工作目录等变量的引用计数</code> 均加1</li>\n</ul>\n<p>也存在不同的项目</p>\n<ul>\n<li>该进程的PPID(标识父进程)被设置成原进程的PID,  </li>\n<li><code>信号位图被清除</code>(原进程设置的信号处理函数对新进程无效)</li>\n</ul>\n<p>(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)</p>\n<p>The child process is an exact duplicate of the parent process except<br>for the following points:</p>\n<ul>\n<li><p>The child has its own unique process ID, and this PID does not<br> match the ID of any existing process group (setpgid(2)) or<br> session. 子进程拥有自己唯一的进程ID, 不与其他相同</p>\n</li>\n<li><p>The child’s parent process ID is the same as the parent’s process<br> ID. 子进程的父进程ID PPID 与父进程ID PID相同</p>\n</li>\n<li><p>The child does not inherit its parent’s memory locks (mlock(2),<br> mlockall(2)). 子进程不继承父进程的内存锁(保证一部分内存处于内存中, 而不是sawp分区)</p>\n</li>\n<li><p>Process resource utilizations (getrusage(2)) and CPU time counters<br> (times(2)) are reset to zero in the child.<br> 进程资源使用和CPU时间计数器在子进程中重置为0</p>\n</li>\n<li><p>The child’s set of pending signals is initially empty<br> (sigpending(2)). 信号位图被初始化为空 原信号处理函数对子进程无效 需重新设置</p>\n</li>\n<li><p>The child does not inherit semaphore adjustments from its parent<br> (semop(2)). 不会继承semadj</p>\n</li>\n<li><p>The child does not inherit process-associated record locks from<br> its parent (fcntl(2)).  (On the other hand, it does inherit<br> fcntl(2) open file description locks and flock(2) locks from its<br> parent.)</p>\n</li>\n<li><p>The child does not inherit timers from its parent (setitimer(2),<br> alarm(2), timer_create(2)). 不会继承定时器</p>\n</li>\n<li><p>The child does not inherit outstanding asynchronous I/O operations<br> from its parent (aio_read(3), aio_write(3)), nor does it inherit<br> any asynchronous I/O contexts from its parent (see io_setup(2)).</p>\n</li>\n</ul>\n<h2 id=\"处理僵尸进程-进程的管理\"><a href=\"#处理僵尸进程-进程的管理\" class=\"headerlink\" title=\"处理僵尸进程-进程的管理\"></a>处理僵尸进程-进程的管理</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">wait</span><span class=\"params\">(<span class=\"keyword\">int</span>* stat_loc)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)</span></span><br><span class=\"line\"><span class=\"comment\">// options函数取值WNOHANG-waitpid立即返回</span></span><br><span class=\"line\"><span class=\"comment\">// 如果目标子进程正常退出, 则返回子进程的pid</span></span><br><span class=\"line\"><span class=\"comment\">// 如果还没有结束或意外终止, 则立即返回0</span></span><br><span class=\"line\"><span class=\"comment\">// 调用失败返回-1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pid_t</span> <span class=\"title\">waitpid</span><span class=\"params\">(<span class=\"keyword\">pid_t</span> pid, <span class=\"keyword\">int</span>* stat_loc, <span class=\"keyword\">int</span> options)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">WIFEXITED(stat_val); <span class=\"comment\">// 子进程正常结束, 返回一个非0</span></span><br><span class=\"line\">WEXITSTATUS(stat_val); <span class=\"comment\">// 如果WIFEXITED 非0, 它返回子进程的退出码</span></span><br><span class=\"line\">WIFSIGNALED(stat_val);<span class=\"comment\">// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值</span></span><br><span class=\"line\">WTERMSIG(stat_val);<span class=\"comment\">// 如果WIFSIGNALED非0 返回一个信号值</span></span><br><span class=\"line\">WIFSTOPPED(stat_val);<span class=\"comment\">// 如果子进程意外终止, 它返回一个非0值</span></span><br><span class=\"line\">WSTOPSIG(stat_val);<span class=\"comment\">// 如果WIFSTOPED非0, 它返回一个信号值</span></span><br></pre></td></tr></table></figure>\n\n<p>对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询</p>\n<ul>\n<li>在<code>子进程结束运行之后, 父进程读取其退出状态前</code>, 我们称该子进程处于<code>僵尸态</code></li>\n<li>另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) <code>父进程结束运行之后, 子进程退出之前</code>, 处于<code>僵尸态</code></li>\n</ul>\n<p>以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.</p>\n<p>waitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.<br>SIGCHLD信号- 子进程结束后将会给父进程发送此信号</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">handle_child</span><span class=\"params\">(<span class=\"keyword\">int</span> sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">pid_t</span> pid;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stat;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> ((pid = waitpid(<span class=\"number\">-1</span>, &amp;stat, WNOHANG)) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 善后处理emmmm</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"信号量-进程的锁\"><a href=\"#信号量-进程的锁\" class=\"headerlink\" title=\"信号量-进程的锁\"></a>信号量-进程的锁</h2><p><em>信号量原语</em><br>只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.<br>假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为</p>\n<ul>\n<li>P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行</li>\n<li>V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png\" alt=\"\"></li>\n</ul>\n<p><strong>总结PV使用方法</strong></p>\n<p>使用<code>semget</code>获取到唯一的标识.<br>使用<code>semctl</code>的<code>SETVAL</code>传入初始化val的<code>sem_un</code>联合体.来初始化val<br>调用<code>semop</code> 传入唯一标识, <code>sem_op=-1</code>执行P(锁)操作<code>sem_op=1</code>执行V(开锁)操作<br>开关锁通过当<code>sem_op=-1,semval=0</code><br>且未指定<code>IPC_NOWAIT</code><br>等待<code>semval</code>被<code>sem_op=1</code>改为<code>semval=1</code></p>\n<p><strong>创建信号量</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// semeget 系统调用</span></span><br><span class=\"line\"><span class=\"comment\">// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集</span></span><br><span class=\"line\"><span class=\"comment\">// key 参数是一个键值, 用来标识一个全局唯一的信号量级,可以在不同进程中获取</span></span><br><span class=\"line\"><span class=\"comment\">// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0. 一般都是为1</span></span><br><span class=\"line\"><span class=\"comment\">// sem_flags指定一组标志, 来控制权限</span></span><br><span class=\"line\"><span class=\"comment\">// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错</span></span><br><span class=\"line\"><span class=\"comment\">// - IPC_CREAT | IPC_EXCL来创建一组唯一信号量集 如果已经存在则会返回错误 errno = EEXIST</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">int</span> num_sems, <span class=\"keyword\">int</span> sem_flags)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> sem_id = semget((<span class=\"keyword\">key_t</span>)<span class=\"number\">1234</span>, <span class=\"number\">1</span>, <span class=\"number\">0666</span> | IPC_CREAT);</span><br></pre></td></tr></table></figure>\n\n<p><strong>初始化</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// semctl 系统调用</span></span><br><span class=\"line\"><span class=\"comment\">// sem_id 参数是由semget返回的信号量集标识符</span></span><br><span class=\"line\"><span class=\"comment\">// sen_num指定被操作的信号量在信号集中的编号</span></span><br><span class=\"line\"><span class=\"comment\">// command指定命令, 可以追加命令所需的参数, 不过有推荐格式</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回对应command的参数, 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semctl</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id, <span class=\"keyword\">int</span> sem_num, <span class=\"keyword\">int</span> command, ...)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第四个参数 竟然需要手动声明...</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> semun</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span>              val;    <span class=\"comment\">/* Value for SETVAL */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">semid_ds</span> *<span class=\"title\">buf</span>;</span>    <span class=\"comment\">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> short  *<span class=\"built_in\">array</span>;  <span class=\"comment\">/* Array for GETALL, SETALL */</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">seminfo</span>  *__<span class=\"title\">buf</span>;</span>  <span class=\"comment\">/* Buffer for IPC_INFO</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\t\t\t\t(Linux-specific) */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 初始化信号量</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> semun sem_union;</span><br><span class=\"line\">sem_union.val = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 这里可以直接第三个参数传入1(val)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (semctl(sem_id, <span class=\"number\">0</span>, SETVAL, sem_union) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除信号量</span></span><br><span class=\"line\"><span class=\"keyword\">union</span> semun sem_union&#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (semctl(sem_id, <span class=\"number\">0</span>, IPC_RMID, sem_union) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(EXIT_FAILURE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<p>与semop信号量关联的一些重要的内核变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> short semval; <span class=\"comment\">// 信号量的值</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> short semzcnt; <span class=\"comment\">// 等待信号量值变为0的进程数量</span></span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> short semncnt<span class=\"comment\">// 等待信号量值增加的进程数量</span></span><br><span class=\"line\"><span class=\"keyword\">pid_t</span> sempid; <span class=\"comment\">// 最后一次执行semop操作的进程ID</span></span><br></pre></td></tr></table></figure>\n<p>操作信号量, 实际上就是对上面的内核变量操作</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.</span></span><br><span class=\"line\"><span class=\"comment\">// sem_ops 参数指向一个sembuf结构体类型的数组</span></span><br><span class=\"line\"><span class=\"comment\">// num_sem_ops 说明操作数组中哪个信号量</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">semop</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id, struct sembuf* sem_ops, <span class=\"keyword\">size_t</span> num_sem_ops)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sem_op &lt; 0 期望获得信号量</span></span><br><span class=\"line\"><span class=\"comment\">// semval-=abs(sem_op),要求调用进程对被操作信号量集有写权限</span></span><br><span class=\"line\"><span class=\"comment\">// 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果semval &lt; abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN</span></span><br><span class=\"line\"><span class=\"comment\">// 如果没有指定 则 阻塞进程等待信号量可用, 且 semzcnt +=1, 等到下面三种情况唤醒</span></span><br><span class=\"line\"><span class=\"comment\">// 1 发生semval &gt;= abs(sem_op), semzcnt-=1, semval-=abs(sem_op). 在SEM_UNDO设置时更新semadj</span></span><br><span class=\"line\"><span class=\"comment\">// 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)</span></span><br><span class=\"line\"><span class=\"comment\">// 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">P</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sembuf</span> <span class=\"title\">sem_b</span>;</span></span><br><span class=\"line\">    sem_b.sem_num = <span class=\"number\">0</span>; <span class=\"comment\">// 信号量编号 第几个信号量 一般都是第0个</span></span><br><span class=\"line\">    sem_b.sem_op = <span class=\"number\">-1</span>; <span class=\"comment\">// P</span></span><br><span class=\"line\">\t<span class=\"comment\">// IPC_NOWAIT 无论信号量操作是否成功, 都立即返回</span></span><br><span class=\"line\">\t<span class=\"comment\">// SEM_UNDO当进程退出的时候, 取消正在进行的semop操作 PV操作系统更新进程的semadj变量</span></span><br><span class=\"line\">    sem_b.sem_flg = SEM_UNDO;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> semop(sem_id, &amp;sem_b, <span class=\"number\">1</span>) != <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// sem_op &gt; 0 </span></span><br><span class=\"line\"><span class=\"comment\">// semval+=sem_op , 要求调用进程对被操作的信号量集有写权限</span></span><br><span class=\"line\"><span class=\"comment\">// 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">V</span><span class=\"params\">(<span class=\"keyword\">int</span> sem_id)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sembuf</span> <span class=\"title\">sem_b</span>;</span></span><br><span class=\"line\">    sem_b.sem_num = <span class=\"number\">0</span>;</span><br><span class=\"line\">    sem_b.sem_op = <span class=\"number\">1</span>; <span class=\"comment\">// V</span></span><br><span class=\"line\">    sem_b.sem_flg = SEM_UNDO;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> semop(sem_id, &amp;sem_b, <span class=\"number\">1</span>) != <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// -- sem_op = 0</span></span><br><span class=\"line\"><span class=\"comment\">// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限</span></span><br><span class=\"line\"><span class=\"comment\">// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0</span></span><br><span class=\"line\"><span class=\"comment\">// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN</span></span><br><span class=\"line\"><span class=\"comment\">// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生</span></span><br><span class=\"line\"><span class=\"comment\">// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1</span></span><br><span class=\"line\"><span class=\"comment\">// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM</span></span><br><span class=\"line\"><span class=\"comment\">// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1</span></span><br></pre></td></tr></table></figure>\n\n<p>semget成功时返回一个与之关联的内核结构体semid_ds</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">semid_ds</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">sem_perm</span>;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> sem_nsems; <span class=\"comment\">// 被设置为num_sems</span></span><br><span class=\"line\">\t<span class=\"keyword\">time_t</span> sem_otime; <span class=\"comment\">// 被设置为0</span></span><br><span class=\"line\">\t<span class=\"keyword\">time_t</span> sem_ctime; <span class=\"comment\">// 被设置为当前的系统时间</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 用来描述权限</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">uid_t</span> uid; <span class=\"comment\">// 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">gid_t</span> gid; <span class=\"comment\">// 所有者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">uid_t</span> cuid; <span class=\"comment\">// 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">gid_t</span> cgid; <span class=\"comment\">// 创建者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">mode_t</span> mode;<span class=\"comment\">// 访问权限, 背着只为sem_flags参数的最低9位.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"共享内存-进程间通信\"><a href=\"#共享内存-进程间通信\" class=\"headerlink\" title=\"共享内存-进程间通信\"></a>共享内存-进程间通信</h2><p><strong>最高效的IPC(进程间通信)机制</strong><br>需要自己同步进程对其的访问, 否则会产生竞态条件</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// key</span></span><br><span class=\"line\"><span class=\"comment\">// 与semget相同 标识一段全局唯一的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">// size 内存区域大小 单位字节</span></span><br><span class=\"line\"><span class=\"comment\">// shmflg</span></span><br><span class=\"line\"><span class=\"comment\">// IPC_CREAT 存不存在都创建新的共享内存</span></span><br><span class=\"line\"><span class=\"comment\">// IPC_CREAT | IPC_EXCL 不存在则创建 存在则报错</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_HUGETLB 系统将使用\"大页面\"来为共享内存分配空间</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_NORESERVE 不为共享内存保留swap空间, 如果物理内存不足</span></span><br><span class=\"line\"><span class=\"comment\">// -在执行写操作的时候将会触发`SIGSEGV`信号</span></span><br><span class=\"line\"><span class=\"comment\">// -成功返回唯一标识, 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">size_t</span> <span class=\"built_in\">size</span>, <span class=\"keyword\">int</span> shmflg)</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// shm_id </span></span><br><span class=\"line\"><span class=\"comment\">// shmget返回的唯一标识</span></span><br><span class=\"line\"><span class=\"comment\">// shm_addr </span></span><br><span class=\"line\"><span class=\"comment\">// 关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响</span></span><br><span class=\"line\"><span class=\"comment\">// 如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 shm_addr 非空,且没有`SHM_RND`标志 则关联到指定的地址处</span></span><br><span class=\"line\"><span class=\"comment\">// 如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写*</span></span><br><span class=\"line\"><span class=\"comment\">// shmflg</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_RDONLY 设置后内存内容变成只读, 不设置则为读写模式</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联</span></span><br><span class=\"line\"><span class=\"comment\">// SHM_EXEC 有执行权限</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回关联到的地址, 失败返回 (void*)-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">shmat</span><span class=\"params\">(<span class=\"keyword\">int</span> shm_id, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* shm_addr, <span class=\"keyword\">int</span> shmflg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// 将共享内存关联到进程的地址空间 调用成功之后, 修改shmid_ds的部分内容</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -shm_nattach +1</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -更新 shm_lpid</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">// -shm_atime设置为当前时间</span></span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将共享内存从进程地址空间中分离</span></span><br><span class=\"line\"><span class=\"comment\">// 成功后</span></span><br><span class=\"line\"><span class=\"comment\">// -shm_nattach -1</span></span><br><span class=\"line\"><span class=\"comment\">// -更新 shm_lpid和shm_dtime设置为当前时间</span></span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回-1 errno</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shmdt</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* shm_addr)</span></span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">shm_ctl</span><span class=\"params\">(<span class=\"keyword\">int</span> shm_id, <span class=\"keyword\">int</span> command, struct shmid_ds* buf)</span></span></span><br></pre></td></tr></table></figure>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/shmctl.png\" alt=\"\"></p>\n<hr>\n<p>shmget 同时会创建对应的<code>shmid_ds</code>结构体</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">shmid_ds</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ipc_perm</span> <span class=\"title\">shm_per</span>;</span> <span class=\"comment\">// 权限相关</span></span><br><span class=\"line\">\t<span class=\"keyword\">size_t</span> shm_segsz; <span class=\"comment\">// 共享内存大小 单位字节\tsize</span></span><br><span class=\"line\">\t<span class=\"keyword\">__time_t</span> shm_atime; <span class=\"comment\">// 对这段内存最后一次调用semat的时间 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">__time_t</span> shm_dtime; <span class=\"comment\">// 对这段内存最后一次调用semdt的时间 0</span></span><br><span class=\"line\">\t<span class=\"keyword\">__time_t</span> shm_ctime; <span class=\"comment\">// 对这段内存最后一次调用semctl的时间 当前时间</span></span><br><span class=\"line\">\t<span class=\"keyword\">__pid_t</span> shm_cpid; <span class=\"comment\">// 创建者PID</span></span><br><span class=\"line\">\t<span class=\"keyword\">__pid_t</span> lpid; <span class=\"comment\">// 最后一次执行shmat或shmdt的进程PID</span></span><br><span class=\"line\">\t<span class=\"keyword\">shmatt_t</span> shm_nattach <span class=\"comment\">// 关联到此共享内存空间的进程数量</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>共享内存的POSIX方法</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> shmfd = shm_open(<span class=\"string\">\"/shm_name\"</span>, O_CREAT | O_RDWR, <span class=\"number\">0666</span>);</span><br><span class=\"line\">ERROR_IF(shmfd == <span class=\"number\">-1</span>, <span class=\"string\">\"shm open\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> ret = ftruncate(shmfd, BUFFER_SIZE);</span><br><span class=\"line\">ERROR_IF(ret == <span class=\"number\">-1</span>, <span class=\"string\">\"ftruncate\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">share_mem = (<span class=\"keyword\">char</span>*)mmap(<span class=\"literal\">nullptr</span>, BUFFER_SIZE,</span><br><span class=\"line\">\t\tPROT_READ | PROT_WRITE, MAP_SHARED, shmfd, <span class=\"number\">0</span>);</span><br><span class=\"line\">ERROR_IF(share_mem == MAP_FAILED, <span class=\"string\">\"share_mem\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">close</span>(shmfd);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 取消关联</span></span><br><span class=\"line\">munmap((<span class=\"keyword\">void</span>*)share_mem, BUFFER_SIZE);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"进程通信-管道\"><a href=\"#进程通信-管道\" class=\"headerlink\" title=\"进程通信-管道\"></a>进程通信-管道</h2><p>管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证<br>父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].</p>\n<p>可以用两个管道来实现双向传输数据, 也可以用<code>socketpair</code>来创建管道</p>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><p>消息队列是两个进程之间传递二进制块数据的一种简单有效的方式.<br>每个数据块都有自己的类型, 接收方可以根据类型有选择的接收数据</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/msg.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 与semget 相同, 成功返回标识符</span></span><br><span class=\"line\"><span class=\"comment\">// msgflg的设置和作用域setget相同</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgget</span><span class=\"params\">(<span class=\"keyword\">key_t</span> key, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// msg_ptr参数指向一个准备发送的消息, 消息必须按如下定义</span></span><br><span class=\"line\"><span class=\"comment\">// msg_sz 指的是mtext的长度!!!</span></span><br><span class=\"line\"><span class=\"comment\">// msgflg通常仅支持IPC_NOWAIT 以非阻塞形式发送数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgsnd</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *msg_ptr, <span class=\"keyword\">size_t</span> msg_sz, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br><span class=\"line\">默认如果消息队列已满, 则会阻塞. 如果设置了 IPC_NOTWAIT</span><br><span class=\"line\">就立即返回 设置errno=EAGIN</span><br><span class=\"line\"></span><br><span class=\"line\">系统自带这个结构体 不过mtext长度是<span class=\"number\">1.</span>..</span><br><span class=\"line\">struct msgbuf</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">long</span> mtype; <span class=\"comment\">/* 消息类型 正整数*/</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> mtext[<span class=\"number\">512</span>]; <span class=\"comment\">/* 消息数据*/</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// msgtype = 0 读取消息队列第一个消息</span></span><br><span class=\"line\"><span class=\"comment\">// msgtype &gt; 0 读取消息队列第一个类型是msgtype的消息 除非标志了MSG_EXCEPT</span></span><br><span class=\"line\"><span class=\"comment\">// msgtype &lt; 0 读取第一个 类型值 &lt; abs(msgtype)的消息</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// IPC_NOWAIT 如果消息队列没有消息, 则msgrcv立即返回并设置errno=ENOMSG</span></span><br><span class=\"line\"><span class=\"comment\">// MSG_EXCEPT 如果msgtype大于0, 则接收第一个非 msgtype 的数据</span></span><br><span class=\"line\"><span class=\"comment\">// MSG_NOERROR 消息部分长度超过msg_sz 则将它截断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgrcv</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">void</span> *msg_ptr, <span class=\"keyword\">size_t</span> msg_sz, <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> msgtype, <span class=\"keyword\">int</span> msgflg)</span></span>;</span><br><span class=\"line\">处于阻塞状态 当消息队列被移除(errno=EIDRM)或者程序接受到信号(errno=EINTR) 都会中断阻塞状态</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">msgctl</span><span class=\"params\">(<span class=\"keyword\">int</span> msqid, <span class=\"keyword\">int</span> command, struct msqid_ds *buf)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">IPC_STAT 复制消息队列关联的数据结构</span><br><span class=\"line\">IPC_SET 将buf中的部分成员更新到目标的内核数据</span><br><span class=\"line\">IPC_RMID 立即移除消息队列, 唤醒所有等待读消息和写消息的进程</span><br><span class=\"line\">IPC_INFO 获取系统消息队列资源配置信息</span><br><span class=\"line\"></span><br><span class=\"line\">MSG_INFO 返回已经分配的消息队列所占用资源信息</span><br><span class=\"line\">MSG_STAT msgqid不再是标识符, 而是内核消息队列的数组索引</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"在进程间传递文件描述符\"><a href=\"#在进程间传递文件描述符\" class=\"headerlink\" title=\"在进程间传递文件描述符\"></a>在进程间传递文件描述符</h2><h2 id=\"IPC命令-查看进程间通信的全局唯一key\"><a href=\"#IPC命令-查看进程间通信的全局唯一key\" class=\"headerlink\" title=\"IPC命令-查看进程间通信的全局唯一key\"></a>IPC命令-查看进程间通信的全局唯一key</h2><h1 id=\"第十四章-多线程编程\"><a href=\"#第十四章-多线程编程\" class=\"headerlink\" title=\"第十四章 多线程编程\"></a>第十四章 多线程编程</h1><p>根据运行环境和调度者身份, 线程可以分为两种<br>内核线程<br>运行在内核空间, 由内核来调度.<br>用户线程<br>运行在用空间, 由线程库来调用</p>\n<p>当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.</p>\n<p>线程有三种实现方式</p>\n<ul>\n<li>完全在用户空间实现-无需内核支持<br>  创建和调度线程无需内核干预, 速度很快.<br>  不占用额外的内核资源, 对系统影响较小<br>  但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的</li>\n<li>完全由内核调度<br>  创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理<br>  优缺点正好与上一个相反</li>\n<li>双层调度<br>  结合了前两个的优点<br>  不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势</li>\n</ul>\n<h2 id=\"进程的创建和终止\"><a href=\"#进程的创建和终止\" class=\"headerlink\" title=\"进程的创建和终止\"></a>进程的创建和终止</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/pthreadtypes.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">int</span> <span class=\"keyword\">pthread_t</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_create</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span>* thread, <span class=\"keyword\">const</span> <span class=\"keyword\">pthread_attr_t</span>* attr, <span class=\"keyword\">void</span>* (*start_routine)(<span class=\"keyword\">void</span>*), <span class=\"keyword\">void</span>* arg)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 成功返回0 失败返回错误码</span></span><br><span class=\"line\"><span class=\"comment\">// thread 用来唯一的标识一个新线程</span></span><br><span class=\"line\"><span class=\"comment\">// attr用来设置新县城的属性 传递NULL表示默认线程属性</span></span><br><span class=\"line\"><span class=\"comment\">// start_routine 指定新线程运行的函数</span></span><br><span class=\"line\"><span class=\"comment\">// arg指定函数的参数</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pthread_exit</span><span class=\"params\">(<span class=\"keyword\">void</span>* retval)</span></span>;</span><br><span class=\"line\">用来保证线程安全干净的退出, 线程函数最好结束时调用.</span><br><span class=\"line\">通过`retval`参数向线程的回收者传递其退出信息</span><br><span class=\"line\">执行后不会返回到调用者, 而且永远不会失败</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_join</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread, <span class=\"keyword\">void</span>** retval)</span></span></span><br><span class=\"line\">可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.</span><br><span class=\"line\">成功时返回<span class=\"number\">0</span>, 失败返回错误码</span><br><span class=\"line\">等待其他线程结束</span><br><span class=\"line\">thread 线程标识符</span><br><span class=\"line\">retval 目标线程的退出返回信息</span><br><span class=\"line\"></span><br><span class=\"line\">错误码如下</span><br><span class=\"line\">`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用</span><br><span class=\"line\">`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程</span><br><span class=\"line\">`ESRCH`目标线程不存在</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_cancel</span><span class=\"params\">(<span class=\"keyword\">pthread_t</span> thread)</span></span></span><br><span class=\"line\">异常终止一个线程, 即为取消线程</span><br><span class=\"line\">成功返回<span class=\"number\">0</span>, 失败返回错误码</span><br><span class=\"line\"></span><br><span class=\"line\">接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.</span><br><span class=\"line\">一下两个函数成功返回<span class=\"number\">0</span> 失败返回错误码</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 启动线程取消</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_setcancelstart</span><span class=\"params\">(<span class=\"keyword\">int</span> state, <span class=\"keyword\">int</span>* oldstate)</span></span></span><br><span class=\"line\">第一个参数</span><br><span class=\"line\">PTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态</span><br><span class=\"line\">PTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求指导</span><br><span class=\"line\">这个线程允许被取消</span><br><span class=\"line\">第二个参数 返回之前设定的状态</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置线程取消类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_setcanceltype</span><span class=\"params\">(<span class=\"keyword\">int</span> type, <span class=\"keyword\">int</span>* oldtype)</span></span></span><br><span class=\"line\">第一个参数</span><br><span class=\"line\">PTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消</span><br><span class=\"line\">PTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 知道调用了下面几个所谓的取消点函数</span><br><span class=\"line\">最好使用`pthread_testcancel`函数设置取消点</span><br><span class=\"line\">设置取消类型(如何取消)</span><br><span class=\"line\">第二个参数</span><br><span class=\"line\">原来的取消类型</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"POSIX信号量-进程的同步\"><a href=\"#POSIX信号量-进程的同步\" class=\"headerlink\" title=\"POSIX信号量-进程的同步\"></a>POSIX信号量-进程的同步</h2><p>多线程也必须考虑线程同步的问题.<br>虽然<code>pthread_join</code>可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求<br>比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.</p>\n<p>以下函数成功返回0 失败返回-1 errno<br><code>int sem_init(sem_t* sem, int pshared, unsigned int value)</code><br>用于初始化一个未命名的信号量.<br>如果<code>pshared</code>为0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享<br><code>value</code>指定参数的初始值<br><em>初始化已经存在的信号量会导致无法预期的结果</em></p>\n<p><code>int sem_destory(sem_t* sem)</code><br>销毁信号量, 释放其占用的系统资源<br><em>销毁正被其他线程等待的信号量, 将会导致无法预期的结果</em></p>\n<p><code>int sem_wait(sem_t* sem)</code><br>以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞, 知道信号量具有非0值</p>\n<p><code>int sem_trywait(sem_t* sem)</code><br>跟上面的函数相同不过不会阻塞. 信号量不为0 则 -1, 为0 则返回-1 errno</p>\n<p><code>int sem_post(sem_t sem)</code><br>原子操作将信号量的值 +1</p>\n"},{"title":"Linux高性能服务器-理论部分","date":"2020-03-06T14:53:00.000Z","top":99,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg","_content":"距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.\n半年后开始准备补上这四章\n\n# 第一章 TCP/IP协议族\n## TCP/IP协议族体系结构和主要协议\n协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg)\n\n![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=3a1768f4c6fc1e17e9b284632bf99d66/0dd7912397dda144d48ab350bbb7d0a20df48655.jpg)\n\n同样七层是osi参考模型, 简化后得到四层\n不同层次之间, 通过接口互相交流, 这样方便了各层次的修改\n\n**应用层**\n负责处理应用程序的逻辑\n\n**表示层**\n定义了数据的格式及加密\n\n**会话层**\n它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的\n\n**传输层**\n为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.\n此层存在两大协议TCP协议和UDP协议\nTCP协议(Transmission Control Protocol 传输控制协议)\n- 为应用层提供`可靠的, 面向连接, 基于流的服务`\n- 通过`超时重传`和`数据确认`等确保数据正常送达.\n- TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器\nUPD协议(User Datagram Protocol 用户数据报协议)\n- 为应用层提供`不可靠的, 无连接的, 基于数据报的服务`\n- 一般需要自己处理`数据确认`和`超时重传`的问题\n- 通信两者不存储状态, 每次发送都需要指定地址信息. `有自己的长度`\n\n**网络层**\n实现了数据包的选路和转发.  只有数据包到不了目标地址, 就`下一跳`(hop by hop), 选择最近的.\n*IP协议(Internet Protocol)* 以及 *ICMP协议(Internet Control Message Protocol)* \n后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)\n\n**数据链路层**\n实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.\n存在两个协议 *ARP协议(Address Resolve Protocol, 地址解析协议)*. 还有*RARP(Reverse ~, 逆地址解析协议)*.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议*ARP欺骗, 可能与这个有关, 目前不去学习*\n\n**封装**\n上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.\n被TCP封装的数据成为 `TCP报文段`\n- 内核部分发送成功后删除数据\n\n被UDP封装的数据成为 `UDP数据报`\n- 发送后即删除\n\n再经IP封装后成为`IP数据报`\n最后经过数据链路层封装后为 `帧`\n\n以太网最大数据帧1518字节 抛去14头部 帧尾4校验\nMTU: 帧的最大传输单元 一般为1500字节\nMSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头-20TCP头 还有额外的40字节可选部分\n\n**ARP**\nARP协议能实现任意网络层地址到任意物理地址的转换\n\n# 第二章 IP协议详解\nIP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一\nIP协议为上层协议提供无状态, 无连接, 不可靠的服务\n\nIP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制\n\n当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png)\n\n\n路由机制\n\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png)\n\n\n给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤\n- 查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步\n- 查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到....... 否则下一步\n- 选择默认路由项, 通常意味着下一跳路由是网关\n\n\n# 第三章 TCP协议详解\n\nTcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.\n\nUDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断\n\nISN-初始序号值\n32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移\n32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答\n\nACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为`确认报文段`\nPSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间\nRST标志: 要求对方重新建立连接 携带......`复位报文段`\nSYN标志: 标志请求建立一个连接 携带......`同步报文段`\nFIN标志: 通知对方本端连接要关闭了, 携带..`结束报文段`\n\n16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据\n16位校验和: `可靠传输的重要保障`发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验`TCP头部`和`数据部分`\n\n\n**TCP连接的建立和关闭**\n\n```s\n# 三次握手\n# 客户端发送请求连接 ISN=seq + 0 = 3683340920\n# mss 最大数据载量1460\nIP 192.168.80.1.7467 > ubuntu.8000: \nFlags [S], seq 3683340920, win 64240, \noptions [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0\n\n# 同意客户端连接\n# ack = 客户端发送 seq + 1\n# 同时发送服务端的seq\nIP ubuntu.8000 > 192.168.80.1.7467: \nFlags [S.], seq 938535101, ack 3683340921, win 64240, \noptions [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0\n\n# 虽然这个报文段没有字节 但由于是同步报文段 需要占用一个序号值\n# 这里是tcpdump的处理 ack显示相对值 即 3683340921 - 3683340920 = 1\nIP 192.168.80.1.7467 > ubuntu.8000: \nFlags [.], ack 938535102, win 4106, length 0\n\n\n# 包含FIN标志 说明要求结束连接 也需要占用一个序号值\nIP 192.168.80.1.7467 > ubuntu.8000: \nFlags [F.], seq 1, ack 1, win 4106, length 0\n\n# 服务端确认关闭连接\nIP ubuntu.8000 > 192.168.80.1.7467: \nFlags [.], ack 2, win 502, length 0\n\n# 服务端发送关闭连接\nIP ubuntu.8000 > 192.168.80.1.7467: \nFlags [F.], seq 1, ack 2, win 4105, length 0\n\n# 客户端确认\nIP 192.168.80.1.7467 > ubuntu.8000: \nFlags [.], ack 2, win 503, length 0\n```","source":"_posts/CPP-读书记录99-高性能服务器编程读书记录理论部分.md","raw":"---\ntitle: Linux高性能服务器-理论部分\ntags:\n  - null\ncategories:\n  - CPP\n  - 服务器编程-书籍记录\ndate: 2020-03-06 22:53:00\ntop: 99\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg\n---\n距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.\n半年后开始准备补上这四章\n\n# 第一章 TCP/IP协议族\n## TCP/IP协议族体系结构和主要协议\n协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg)\n\n![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=3a1768f4c6fc1e17e9b284632bf99d66/0dd7912397dda144d48ab350bbb7d0a20df48655.jpg)\n\n同样七层是osi参考模型, 简化后得到四层\n不同层次之间, 通过接口互相交流, 这样方便了各层次的修改\n\n**应用层**\n负责处理应用程序的逻辑\n\n**表示层**\n定义了数据的格式及加密\n\n**会话层**\n它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的\n\n**传输层**\n为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.\n此层存在两大协议TCP协议和UDP协议\nTCP协议(Transmission Control Protocol 传输控制协议)\n- 为应用层提供`可靠的, 面向连接, 基于流的服务`\n- 通过`超时重传`和`数据确认`等确保数据正常送达.\n- TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器\nUPD协议(User Datagram Protocol 用户数据报协议)\n- 为应用层提供`不可靠的, 无连接的, 基于数据报的服务`\n- 一般需要自己处理`数据确认`和`超时重传`的问题\n- 通信两者不存储状态, 每次发送都需要指定地址信息. `有自己的长度`\n\n**网络层**\n实现了数据包的选路和转发.  只有数据包到不了目标地址, 就`下一跳`(hop by hop), 选择最近的.\n*IP协议(Internet Protocol)* 以及 *ICMP协议(Internet Control Message Protocol)* \n后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)\n\n**数据链路层**\n实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.\n存在两个协议 *ARP协议(Address Resolve Protocol, 地址解析协议)*. 还有*RARP(Reverse ~, 逆地址解析协议)*.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议*ARP欺骗, 可能与这个有关, 目前不去学习*\n\n**封装**\n上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.\n被TCP封装的数据成为 `TCP报文段`\n- 内核部分发送成功后删除数据\n\n被UDP封装的数据成为 `UDP数据报`\n- 发送后即删除\n\n再经IP封装后成为`IP数据报`\n最后经过数据链路层封装后为 `帧`\n\n以太网最大数据帧1518字节 抛去14头部 帧尾4校验\nMTU: 帧的最大传输单元 一般为1500字节\nMSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头-20TCP头 还有额外的40字节可选部分\n\n**ARP**\nARP协议能实现任意网络层地址到任意物理地址的转换\n\n# 第二章 IP协议详解\nIP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一\nIP协议为上层协议提供无状态, 无连接, 不可靠的服务\n\nIP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制\n\n当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png)\n\n\n路由机制\n\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png)\n\n\n给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤\n- 查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步\n- 查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到....... 否则下一步\n- 选择默认路由项, 通常意味着下一跳路由是网关\n\n\n# 第三章 TCP协议详解\n\nTcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.\n\nUDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断\n\nISN-初始序号值\n32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移\n32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答\n\nACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为`确认报文段`\nPSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间\nRST标志: 要求对方重新建立连接 携带......`复位报文段`\nSYN标志: 标志请求建立一个连接 携带......`同步报文段`\nFIN标志: 通知对方本端连接要关闭了, 携带..`结束报文段`\n\n16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据\n16位校验和: `可靠传输的重要保障`发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验`TCP头部`和`数据部分`\n\n\n**TCP连接的建立和关闭**\n\n```s\n# 三次握手\n# 客户端发送请求连接 ISN=seq + 0 = 3683340920\n# mss 最大数据载量1460\nIP 192.168.80.1.7467 > ubuntu.8000: \nFlags [S], seq 3683340920, win 64240, \noptions [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0\n\n# 同意客户端连接\n# ack = 客户端发送 seq + 1\n# 同时发送服务端的seq\nIP ubuntu.8000 > 192.168.80.1.7467: \nFlags [S.], seq 938535101, ack 3683340921, win 64240, \noptions [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0\n\n# 虽然这个报文段没有字节 但由于是同步报文段 需要占用一个序号值\n# 这里是tcpdump的处理 ack显示相对值 即 3683340921 - 3683340920 = 1\nIP 192.168.80.1.7467 > ubuntu.8000: \nFlags [.], ack 938535102, win 4106, length 0\n\n\n# 包含FIN标志 说明要求结束连接 也需要占用一个序号值\nIP 192.168.80.1.7467 > ubuntu.8000: \nFlags [F.], seq 1, ack 1, win 4106, length 0\n\n# 服务端确认关闭连接\nIP ubuntu.8000 > 192.168.80.1.7467: \nFlags [.], ack 2, win 502, length 0\n\n# 服务端发送关闭连接\nIP ubuntu.8000 > 192.168.80.1.7467: \nFlags [F.], seq 1, ack 2, win 4105, length 0\n\n# 客户端确认\nIP 192.168.80.1.7467 > ubuntu.8000: \nFlags [.], ack 2, win 503, length 0\n```","slug":"CPP-读书记录99-高性能服务器编程读书记录理论部分","published":1,"updated":"2020-03-17T12:09:12.437Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucv5001d8cuohltv7tl6","content":"<p>距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.<br>半年后开始准备补上这四章</p>\n<h1 id=\"第一章-TCP-IP协议族\"><a href=\"#第一章-TCP-IP协议族\" class=\"headerlink\" title=\"第一章 TCP/IP协议族\"></a>第一章 TCP/IP协议族</h1><h2 id=\"TCP-IP协议族体系结构和主要协议\"><a href=\"#TCP-IP协议族体系结构和主要协议\" class=\"headerlink\" title=\"TCP/IP协议族体系结构和主要协议\"></a>TCP/IP协议族体系结构和主要协议</h2><p>协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg\" alt=\"\"></p>\n<p><img src=\"https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=3a1768f4c6fc1e17e9b284632bf99d66/0dd7912397dda144d48ab350bbb7d0a20df48655.jpg\" alt=\"\"></p>\n<p>同样七层是osi参考模型, 简化后得到四层<br>不同层次之间, 通过接口互相交流, 这样方便了各层次的修改</p>\n<p><strong>应用层</strong><br>负责处理应用程序的逻辑</p>\n<p><strong>表示层</strong><br>定义了数据的格式及加密</p>\n<p><strong>会话层</strong><br>它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的</p>\n<p><strong>传输层</strong><br>为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.<br>此层存在两大协议TCP协议和UDP协议<br>TCP协议(Transmission Control Protocol 传输控制协议)</p>\n<ul>\n<li>为应用层提供<code>可靠的, 面向连接, 基于流的服务</code></li>\n<li>通过<code>超时重传</code>和<code>数据确认</code>等确保数据正常送达.</li>\n<li>TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器<br>UPD协议(User Datagram Protocol 用户数据报协议)</li>\n<li>为应用层提供<code>不可靠的, 无连接的, 基于数据报的服务</code></li>\n<li>一般需要自己处理<code>数据确认</code>和<code>超时重传</code>的问题</li>\n<li>通信两者不存储状态, 每次发送都需要指定地址信息. <code>有自己的长度</code></li>\n</ul>\n<p><strong>网络层</strong><br>实现了数据包的选路和转发.  只有数据包到不了目标地址, 就<code>下一跳</code>(hop by hop), 选择最近的.<br><em>IP协议(Internet Protocol)</em> 以及 <em>ICMP协议(Internet Control Message Protocol)</em><br>后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)</p>\n<p><strong>数据链路层</strong><br>实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.<br>存在两个协议 <em>ARP协议(Address Resolve Protocol, 地址解析协议)</em>. 还有<em>RARP(Reverse ~, 逆地址解析协议)</em>.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议<em>ARP欺骗, 可能与这个有关, 目前不去学习</em></p>\n<p><strong>封装</strong><br>上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.<br>被TCP封装的数据成为 <code>TCP报文段</code></p>\n<ul>\n<li>内核部分发送成功后删除数据</li>\n</ul>\n<p>被UDP封装的数据成为 <code>UDP数据报</code></p>\n<ul>\n<li>发送后即删除</li>\n</ul>\n<p>再经IP封装后成为<code>IP数据报</code><br>最后经过数据链路层封装后为 <code>帧</code></p>\n<p>以太网最大数据帧1518字节 抛去14头部 帧尾4校验<br>MTU: 帧的最大传输单元 一般为1500字节<br>MSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头-20TCP头 还有额外的40字节可选部分</p>\n<p><strong>ARP</strong><br>ARP协议能实现任意网络层地址到任意物理地址的转换</p>\n<h1 id=\"第二章-IP协议详解\"><a href=\"#第二章-IP协议详解\" class=\"headerlink\" title=\"第二章 IP协议详解\"></a>第二章 IP协议详解</h1><p>IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一<br>IP协议为上层协议提供无状态, 无连接, 不可靠的服务</p>\n<p>IP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制</p>\n<p>当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png\" alt=\"\"></p>\n<p>路由机制</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png\" alt=\"\"></p>\n<p>给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤</p>\n<ul>\n<li>查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步</li>\n<li>查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到……. 否则下一步</li>\n<li>选择默认路由项, 通常意味着下一跳路由是网关</li>\n</ul>\n<h1 id=\"第三章-TCP协议详解\"><a href=\"#第三章-TCP协议详解\" class=\"headerlink\" title=\"第三章 TCP协议详解\"></a>第三章 TCP协议详解</h1><p>Tcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.</p>\n<p>UDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断</p>\n<p>ISN-初始序号值<br>32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移<br>32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答</p>\n<p>ACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为<code>确认报文段</code><br>PSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间<br>RST标志: 要求对方重新建立连接 携带……<code>复位报文段</code><br>SYN标志: 标志请求建立一个连接 携带……<code>同步报文段</code><br>FIN标志: 通知对方本端连接要关闭了, 携带..<code>结束报文段</code></p>\n<p>16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据<br>16位校验和: <code>可靠传输的重要保障</code>发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验<code>TCP头部</code>和<code>数据部分</code></p>\n<p><strong>TCP连接的建立和关闭</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 三次握手</span><br><span class=\"line\"># 客户端发送请求连接 ISN&#x3D;seq + 0 &#x3D; 3683340920</span><br><span class=\"line\"># mss 最大数据载量1460</span><br><span class=\"line\">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class=\"line\">Flags [S], seq 3683340920, win 64240, </span><br><span class=\"line\">options [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 同意客户端连接</span><br><span class=\"line\"># ack &#x3D; 客户端发送 seq + 1</span><br><span class=\"line\"># 同时发送服务端的seq</span><br><span class=\"line\">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class=\"line\">Flags [S.], seq 938535101, ack 3683340921, win 64240, </span><br><span class=\"line\">options [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 虽然这个报文段没有字节 但由于是同步报文段 需要占用一个序号值</span><br><span class=\"line\"># 这里是tcpdump的处理 ack显示相对值 即 3683340921 - 3683340920 &#x3D; 1</span><br><span class=\"line\">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class=\"line\">Flags [.], ack 938535102, win 4106, length 0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 包含FIN标志 说明要求结束连接 也需要占用一个序号值</span><br><span class=\"line\">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class=\"line\">Flags [F.], seq 1, ack 1, win 4106, length 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 服务端确认关闭连接</span><br><span class=\"line\">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class=\"line\">Flags [.], ack 2, win 502, length 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 服务端发送关闭连接</span><br><span class=\"line\">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class=\"line\">Flags [F.], seq 1, ack 2, win 4105, length 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 客户端确认</span><br><span class=\"line\">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class=\"line\">Flags [.], ack 2, win 503, length 0</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.<br>半年后开始准备补上这四章</p>\n<h1 id=\"第一章-TCP-IP协议族\"><a href=\"#第一章-TCP-IP协议族\" class=\"headerlink\" title=\"第一章 TCP/IP协议族\"></a>第一章 TCP/IP协议族</h1><h2 id=\"TCP-IP协议族体系结构和主要协议\"><a href=\"#TCP-IP协议族体系结构和主要协议\" class=\"headerlink\" title=\"TCP/IP协议族体系结构和主要协议\"></a>TCP/IP协议族体系结构和主要协议</h2><p>协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg\" alt=\"\"></p>\n<p><img src=\"https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=3a1768f4c6fc1e17e9b284632bf99d66/0dd7912397dda144d48ab350bbb7d0a20df48655.jpg\" alt=\"\"></p>\n<p>同样七层是osi参考模型, 简化后得到四层<br>不同层次之间, 通过接口互相交流, 这样方便了各层次的修改</p>\n<p><strong>应用层</strong><br>负责处理应用程序的逻辑</p>\n<p><strong>表示层</strong><br>定义了数据的格式及加密</p>\n<p><strong>会话层</strong><br>它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的</p>\n<p><strong>传输层</strong><br>为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.<br>此层存在两大协议TCP协议和UDP协议<br>TCP协议(Transmission Control Protocol 传输控制协议)</p>\n<ul>\n<li>为应用层提供<code>可靠的, 面向连接, 基于流的服务</code></li>\n<li>通过<code>超时重传</code>和<code>数据确认</code>等确保数据正常送达.</li>\n<li>TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器<br>UPD协议(User Datagram Protocol 用户数据报协议)</li>\n<li>为应用层提供<code>不可靠的, 无连接的, 基于数据报的服务</code></li>\n<li>一般需要自己处理<code>数据确认</code>和<code>超时重传</code>的问题</li>\n<li>通信两者不存储状态, 每次发送都需要指定地址信息. <code>有自己的长度</code></li>\n</ul>\n<p><strong>网络层</strong><br>实现了数据包的选路和转发.  只有数据包到不了目标地址, 就<code>下一跳</code>(hop by hop), 选择最近的.<br><em>IP协议(Internet Protocol)</em> 以及 <em>ICMP协议(Internet Control Message Protocol)</em><br>后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)</p>\n<p><strong>数据链路层</strong><br>实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.<br>存在两个协议 <em>ARP协议(Address Resolve Protocol, 地址解析协议)</em>. 还有<em>RARP(Reverse ~, 逆地址解析协议)</em>.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议<em>ARP欺骗, 可能与这个有关, 目前不去学习</em></p>\n<p><strong>封装</strong><br>上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.<br>被TCP封装的数据成为 <code>TCP报文段</code></p>\n<ul>\n<li>内核部分发送成功后删除数据</li>\n</ul>\n<p>被UDP封装的数据成为 <code>UDP数据报</code></p>\n<ul>\n<li>发送后即删除</li>\n</ul>\n<p>再经IP封装后成为<code>IP数据报</code><br>最后经过数据链路层封装后为 <code>帧</code></p>\n<p>以太网最大数据帧1518字节 抛去14头部 帧尾4校验<br>MTU: 帧的最大传输单元 一般为1500字节<br>MSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头-20TCP头 还有额外的40字节可选部分</p>\n<p><strong>ARP</strong><br>ARP协议能实现任意网络层地址到任意物理地址的转换</p>\n<h1 id=\"第二章-IP协议详解\"><a href=\"#第二章-IP协议详解\" class=\"headerlink\" title=\"第二章 IP协议详解\"></a>第二章 IP协议详解</h1><p>IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一<br>IP协议为上层协议提供无状态, 无连接, 不可靠的服务</p>\n<p>IP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制</p>\n<p>当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png\" alt=\"\"></p>\n<p>路由机制</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png\" alt=\"\"></p>\n<p>给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤</p>\n<ul>\n<li>查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步</li>\n<li>查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到……. 否则下一步</li>\n<li>选择默认路由项, 通常意味着下一跳路由是网关</li>\n</ul>\n<h1 id=\"第三章-TCP协议详解\"><a href=\"#第三章-TCP协议详解\" class=\"headerlink\" title=\"第三章 TCP协议详解\"></a>第三章 TCP协议详解</h1><p>Tcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.</p>\n<p>UDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断</p>\n<p>ISN-初始序号值<br>32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移<br>32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答</p>\n<p>ACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为<code>确认报文段</code><br>PSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间<br>RST标志: 要求对方重新建立连接 携带……<code>复位报文段</code><br>SYN标志: 标志请求建立一个连接 携带……<code>同步报文段</code><br>FIN标志: 通知对方本端连接要关闭了, 携带..<code>结束报文段</code></p>\n<p>16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据<br>16位校验和: <code>可靠传输的重要保障</code>发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验<code>TCP头部</code>和<code>数据部分</code></p>\n<p><strong>TCP连接的建立和关闭</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 三次握手</span><br><span class=\"line\"># 客户端发送请求连接 ISN&#x3D;seq + 0 &#x3D; 3683340920</span><br><span class=\"line\"># mss 最大数据载量1460</span><br><span class=\"line\">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class=\"line\">Flags [S], seq 3683340920, win 64240, </span><br><span class=\"line\">options [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 同意客户端连接</span><br><span class=\"line\"># ack &#x3D; 客户端发送 seq + 1</span><br><span class=\"line\"># 同时发送服务端的seq</span><br><span class=\"line\">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class=\"line\">Flags [S.], seq 938535101, ack 3683340921, win 64240, </span><br><span class=\"line\">options [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 虽然这个报文段没有字节 但由于是同步报文段 需要占用一个序号值</span><br><span class=\"line\"># 这里是tcpdump的处理 ack显示相对值 即 3683340921 - 3683340920 &#x3D; 1</span><br><span class=\"line\">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class=\"line\">Flags [.], ack 938535102, win 4106, length 0</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># 包含FIN标志 说明要求结束连接 也需要占用一个序号值</span><br><span class=\"line\">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class=\"line\">Flags [F.], seq 1, ack 1, win 4106, length 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 服务端确认关闭连接</span><br><span class=\"line\">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class=\"line\">Flags [.], ack 2, win 502, length 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 服务端发送关闭连接</span><br><span class=\"line\">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class=\"line\">Flags [F.], seq 1, ack 2, win 4105, length 0</span><br><span class=\"line\"></span><br><span class=\"line\"># 客户端确认</span><br><span class=\"line\">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class=\"line\">Flags [.], ack 2, win 503, length 0</span><br></pre></td></tr></table></figure>"},{"title":"commit规范","date":"2020-02-22T04:22:02.000Z","_content":"# commit 规范\n[阮一峰 Commit message 和 Change log 编写指南](https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n\nAngular 规范.\n每个commit message 包括三分部\nHeader Body 和 Footer\n```\n<type>(<scope>): <subject> // 必须\n// 空一行\n<body> // 非必须\n// 空一行\n<footer> //非必须\n```\n**Header**\n1. type 必需 - 说明commit的类别, 只允许下面七个标识\n\n- feat：新功能（feature）\n- fix：修补bug\n- docs：文档（documentation）\n- style： 格式（不影响代码运行的变动）\n- refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n- test：增加测试\n- chore：构建过程或辅助工具的变动\n\n2. scope 非必需 - 用于说明 commit影响的范围\n比如登录、注册、充值逻辑等等，视项目不同而不同。\n\n3. subject 必需 - commit 目的的简短描述 \n- 不超过50字符 \n- 第一人称现在时动词开头\n- 首字母小写\n- 句尾不加句号\n\n**Body**\n本次commit的详细描述, 可以分成多行\n\n**Footer**\n只用于两种情况 目前用不动 不摘了","source":"_posts/Git-commit规范.md","raw":"---\ntitle: commit规范\ndate: 2020-02-22 12:22:02\ncategories: \n- 必备技能\n- Git操作\ntags:\n- Git操作\n---\n# commit 规范\n[阮一峰 Commit message 和 Change log 编写指南](https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n\nAngular 规范.\n每个commit message 包括三分部\nHeader Body 和 Footer\n```\n<type>(<scope>): <subject> // 必须\n// 空一行\n<body> // 非必须\n// 空一行\n<footer> //非必须\n```\n**Header**\n1. type 必需 - 说明commit的类别, 只允许下面七个标识\n\n- feat：新功能（feature）\n- fix：修补bug\n- docs：文档（documentation）\n- style： 格式（不影响代码运行的变动）\n- refactor：重构（即不是新增功能，也不是修改bug的代码变动）\n- test：增加测试\n- chore：构建过程或辅助工具的变动\n\n2. scope 非必需 - 用于说明 commit影响的范围\n比如登录、注册、充值逻辑等等，视项目不同而不同。\n\n3. subject 必需 - commit 目的的简短描述 \n- 不超过50字符 \n- 第一人称现在时动词开头\n- 首字母小写\n- 句尾不加句号\n\n**Body**\n本次commit的详细描述, 可以分成多行\n\n**Footer**\n只用于两种情况 目前用不动 不摘了","slug":"Git-commit规范","published":1,"updated":"2020-03-07T12:51:06.525Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucv6001g8cuofgtqhs9i","content":"<h1 id=\"commit-规范\"><a href=\"#commit-规范\" class=\"headerlink\" title=\"commit 规范\"></a>commit 规范</h1><p><a href=\"https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"noopener\">阮一峰 Commit message 和 Change log 编写指南</a></p>\n<p>Angular 规范.<br>每个commit message 包括三分部<br>Header Body 和 Footer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; &#x2F;&#x2F; 必须</span><br><span class=\"line\">&#x2F;&#x2F; 空一行</span><br><span class=\"line\">&lt;body&gt; &#x2F;&#x2F; 非必须</span><br><span class=\"line\">&#x2F;&#x2F; 空一行</span><br><span class=\"line\">&lt;footer&gt; &#x2F;&#x2F;非必须</span><br></pre></td></tr></table></figure>\n<p><strong>Header</strong></p>\n<ol>\n<li>type 必需 - 说明commit的类别, 只允许下面七个标识</li>\n</ol>\n<ul>\n<li>feat：新功能（feature）</li>\n<li>fix：修补bug</li>\n<li>docs：文档（documentation）</li>\n<li>style： 格式（不影响代码运行的变动）</li>\n<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>\n<li>test：增加测试</li>\n<li>chore：构建过程或辅助工具的变动</li>\n</ul>\n<ol start=\"2\">\n<li><p>scope 非必需 - 用于说明 commit影响的范围<br>比如登录、注册、充值逻辑等等，视项目不同而不同。</p>\n</li>\n<li><p>subject 必需 - commit 目的的简短描述 </p>\n</li>\n</ol>\n<ul>\n<li>不超过50字符 </li>\n<li>第一人称现在时动词开头</li>\n<li>首字母小写</li>\n<li>句尾不加句号</li>\n</ul>\n<p><strong>Body</strong><br>本次commit的详细描述, 可以分成多行</p>\n<p><strong>Footer</strong><br>只用于两种情况 目前用不动 不摘了</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"commit-规范\"><a href=\"#commit-规范\" class=\"headerlink\" title=\"commit 规范\"></a>commit 规范</h1><p><a href=\"https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"noopener\">阮一峰 Commit message 和 Change log 编写指南</a></p>\n<p>Angular 规范.<br>每个commit message 包括三分部<br>Header Body 和 Footer</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; &#x2F;&#x2F; 必须</span><br><span class=\"line\">&#x2F;&#x2F; 空一行</span><br><span class=\"line\">&lt;body&gt; &#x2F;&#x2F; 非必须</span><br><span class=\"line\">&#x2F;&#x2F; 空一行</span><br><span class=\"line\">&lt;footer&gt; &#x2F;&#x2F;非必须</span><br></pre></td></tr></table></figure>\n<p><strong>Header</strong></p>\n<ol>\n<li>type 必需 - 说明commit的类别, 只允许下面七个标识</li>\n</ol>\n<ul>\n<li>feat：新功能（feature）</li>\n<li>fix：修补bug</li>\n<li>docs：文档（documentation）</li>\n<li>style： 格式（不影响代码运行的变动）</li>\n<li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li>\n<li>test：增加测试</li>\n<li>chore：构建过程或辅助工具的变动</li>\n</ul>\n<ol start=\"2\">\n<li><p>scope 非必需 - 用于说明 commit影响的范围<br>比如登录、注册、充值逻辑等等，视项目不同而不同。</p>\n</li>\n<li><p>subject 必需 - commit 目的的简短描述 </p>\n</li>\n</ol>\n<ul>\n<li>不超过50字符 </li>\n<li>第一人称现在时动词开头</li>\n<li>首字母小写</li>\n<li>句尾不加句号</li>\n</ul>\n<p><strong>Body</strong><br>本次commit的详细描述, 可以分成多行</p>\n<p><strong>Footer</strong><br>只用于两种情况 目前用不动 不摘了</p>\n"},{"title":"Git的基础使用","date":"2020-02-07T10:24:42.000Z","_content":"# 命令总结\n```\n# -t Specifies the type of key to create.  The possible values are\n#“dsa”, “ecdsa”, “ed25519”, or “rsa”.\n# -C 生成注释 ...所以后面的邮箱就是个注释????\nssh-keygen -t rsa -C \"youremail@example.com\"\n\ngit init\ngit add <file>\ngit commit -m <message>\ngit remote add origin  # origin 意为远程库的名字, git的默认叫法\n\ngit status\ngit diff\ngit log\ngit log --pretty=oneline # 简单显示\n\n# 注意reset是恢复到上一个版本 即为你上一次commit版本或者pull最近的一次\ngit checkout --<filename> # 恢复工作区, 可用于恢复修改和恢复勿删文件\ngit reset HEAD <file> # 恢复暂存区\ngit reset HEAD^ # 恢复版本库\ngit reset --hard <hash版本号 即为log中的一串英文字母, 只需要前几个字母即可>\ngit reflog # 所有版本日志\n\ngit rm 从版本库中删除文件\n\ngit push -u origin master # 带上 -u 以后提交就不需要加入origin master, 类似记忆功能\n\n`git checkout -b dev` #相当于一下两条命令\n`git branch dev` # 分支创建\n`git checkout dev` # 分支切换\n`git branch -d dev` # 分支删除\n`git branch` # 查看当前所有分支\n`git merge dev` # 将制定的dev分支合并到当前的分支\n```\n\n # 基本概念\n首先把Git的三个区说明一下吧 自己后来慢慢感觉这些理论还是很重要的\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/Git%E4%B8%89%E5%A4%A7%E5%88%86%E5%8C%BA.png)\n工作区\n顾名思义, 你当前在IDE直接修改的代码全部都是位于工作区的代码\n暂存区\n暂时存取的区域, 你每次使用add提交的文件全部在这个区域中, 这些文件等待你的commit\n版本库\n这里存放的是若干个版本, 你每次的commit就是将暂存区的文件作为一个版本提交到版本库, 同时相应的文件被提交后 暂存区的文件被清除\n\n# 基础的操作\n**你的第一次提交**\n```\ngit init\ngit add <file>\ngit commit -m <message>\n```\n`git init `\n在你命令所执行的文件夹生成版本库\n`git add <file>`\n将指定文件从工作区添加到暂存区\n如果`<file>`用 `.` 代替则为所有相对上一次commit修改过的文件\n`git commit -m <message>`\n提交暂存区的文件到版本库中成为一个版本 message为这个版本(提交)的描述\n\n**好了你已经成功完成了一次提交, 继续去写代码了**\n好你又写完了一堆代码 这时你想知道你工作区的状态是啥-你修改了哪些文件\n```\n$git status\n-------提示如下-----------\n位于分支 master\n尚未暂存以备提交的变更：\n  （使用 \"git add <文件>...\" 更新要提交的内容）\n  （使用 \"git checkout -- <文件>...\" 丢弃工作区的改动）\n\n\t修改：     test.txt\n\n修改尚未加入提交（使用 \"git add\" 和/或 \"git commit -a\"）\n```\n`git status`告诉你 你修改了test.txt文件, 但是你想知道你怎么修改了这些文件, 做了什么改动\n这时候就需要`git diff`\n```\n$git diff\n-------提示如下-----------\ndiff --git a/test.txt b/test.txt\nindex 0858ae8..8c14912 100644\n--- a/test.txt\n+++ b/test.txt\n@@ -1,3 +1,4 @@\n 111111111111111\n 222222222222222\n 333333333333333\n+444444444444444\n```\n**现在你知道你进行了什么修改, 又进行了一次提交**\n```\nlsmg@ubuntu:~/temp$ git status\n位于分支 master\n尚未暂存以备提交的变更：\n  （使用 \"git add <文件>...\" 更新要提交的内容）\n  （使用 \"git checkout -- <文件>...\" 丢弃工作区的改动）\n\t修改：     test.txt\n修改尚未加入提交（使用 \"git add\" 和/或 \"git commit -a\"）\nlsmg@ubuntu:~/temp$ git add test.txt \nlsmg@ubuntu:~/temp$ git status\n位于分支 master\n要提交的变更：\n  （使用 \"git reset HEAD <文件>...\" 以取消暂存）\n\t修改：     test.txt\nlsmg@ubuntu:~/temp$ git commit -m \"ver 0.02\"\n[master ee4400f] ver 0.02\n 1 file changed, 1 insertion(+)\nlsmg@ubuntu:~/temp$ git status\n位于分支 master\n无文件要提交，干净的工作区\n```\n\n# 时光穿梭机\n**在commit之间切换**\nGit还可以在不同commit间切换, 当然你必须知道进行过哪些commit, 你不能自己都记在脑子里吧, 所以也存在相关的命令`git log`来查看你的commit记录\n```\nlsmg@ubuntu:~/temp$ git log\ncommit ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -> master)\nAuthor: ***********\nDate:   Sat Dec 7 21:06:42 2019 -0800\n    ver 0.02\n\ncommit 603260e28ac0cc8fb8e4243120eb00bca83585d2\nAuthor: ***********\nDate:   Sat Dec 7 20:57:58 2019 -0800\n    ver 0.01\n\nlsmg@ubuntu:~/temp$ git log --pretty=oneline # 简洁显示\nee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -> master) ver 0.02\n603260e28ac0cc8fb8e4243120eb00bca83585d2 ver 0.01\n```\n上面的`HEAD`代表当前版本, 上一个版本为`HEAD^`, 上上一个版本为`HEAD^^`如此类推\n回到前N个版本`HEAD~N`\n`git reset --hard HEAD^` 回到上一个版本.\n这时你当前版本将会丢失, 使用`git log`也不会查看到原来的版本信息\n这时使用`git reflog`来查看你的所有版本日志\n```\nlsmg@ubuntu:~/temp$ git reset --hard 603260e28ac0cc8fb8e4243120eb00bca83585d2\nHEAD 现在位于 603260e ver 0.01\nlsmg@ubuntu:~/temp$ git log\ncommit 603260e28ac0cc8fb8e4243120eb00bca83585d2 (HEAD -> master)\nAuthor: rjd67441 <rjd67441@hotmail.com>\nDate:   Sat Dec 7 20:57:58 2019 -0800\n\n    ver 0.01\nlsmg@ubuntu:~/temp$ git reflog \n603260e (HEAD -> master) HEAD@{0}: reset: moving to 603260e28ac0cc8fb8e4243120eb00bca83585d2\nee4400f HEAD@{1}: commit: ver 0.02\n603260e (HEAD -> master) HEAD@{2}: commit (initial): ver 0.01\nlsmg@ubuntu:~/temp$ git reset --hard ee4400f\nHEAD 现在位于 ee4400f ver 0.02\n```\n\n**撤销修改**\n工作区中的撤销\n`git checkout -- <filename>`\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n暂存区中的撤销\n`git reset HEAD <file>`\n版本库的撤销\n`git reset HEAD^` 乖乖回退一次\n\n**删除文件**\n删除本地文件后\n确实需要从版本库中删除\n`git rm`删除然后`git commit`提交即可\n误删除需要使用`git chechout -- <filename>`来恢复","source":"_posts/Git-基础操作.md","raw":"---\ntitle: Git的基础使用\ndate: 2020-02-07 18:24:42\ncategories: \n- 必备技能\n- Git操作\ntags:\n- Git操作\n---\n# 命令总结\n```\n# -t Specifies the type of key to create.  The possible values are\n#“dsa”, “ecdsa”, “ed25519”, or “rsa”.\n# -C 生成注释 ...所以后面的邮箱就是个注释????\nssh-keygen -t rsa -C \"youremail@example.com\"\n\ngit init\ngit add <file>\ngit commit -m <message>\ngit remote add origin  # origin 意为远程库的名字, git的默认叫法\n\ngit status\ngit diff\ngit log\ngit log --pretty=oneline # 简单显示\n\n# 注意reset是恢复到上一个版本 即为你上一次commit版本或者pull最近的一次\ngit checkout --<filename> # 恢复工作区, 可用于恢复修改和恢复勿删文件\ngit reset HEAD <file> # 恢复暂存区\ngit reset HEAD^ # 恢复版本库\ngit reset --hard <hash版本号 即为log中的一串英文字母, 只需要前几个字母即可>\ngit reflog # 所有版本日志\n\ngit rm 从版本库中删除文件\n\ngit push -u origin master # 带上 -u 以后提交就不需要加入origin master, 类似记忆功能\n\n`git checkout -b dev` #相当于一下两条命令\n`git branch dev` # 分支创建\n`git checkout dev` # 分支切换\n`git branch -d dev` # 分支删除\n`git branch` # 查看当前所有分支\n`git merge dev` # 将制定的dev分支合并到当前的分支\n```\n\n # 基本概念\n首先把Git的三个区说明一下吧 自己后来慢慢感觉这些理论还是很重要的\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/Git%E4%B8%89%E5%A4%A7%E5%88%86%E5%8C%BA.png)\n工作区\n顾名思义, 你当前在IDE直接修改的代码全部都是位于工作区的代码\n暂存区\n暂时存取的区域, 你每次使用add提交的文件全部在这个区域中, 这些文件等待你的commit\n版本库\n这里存放的是若干个版本, 你每次的commit就是将暂存区的文件作为一个版本提交到版本库, 同时相应的文件被提交后 暂存区的文件被清除\n\n# 基础的操作\n**你的第一次提交**\n```\ngit init\ngit add <file>\ngit commit -m <message>\n```\n`git init `\n在你命令所执行的文件夹生成版本库\n`git add <file>`\n将指定文件从工作区添加到暂存区\n如果`<file>`用 `.` 代替则为所有相对上一次commit修改过的文件\n`git commit -m <message>`\n提交暂存区的文件到版本库中成为一个版本 message为这个版本(提交)的描述\n\n**好了你已经成功完成了一次提交, 继续去写代码了**\n好你又写完了一堆代码 这时你想知道你工作区的状态是啥-你修改了哪些文件\n```\n$git status\n-------提示如下-----------\n位于分支 master\n尚未暂存以备提交的变更：\n  （使用 \"git add <文件>...\" 更新要提交的内容）\n  （使用 \"git checkout -- <文件>...\" 丢弃工作区的改动）\n\n\t修改：     test.txt\n\n修改尚未加入提交（使用 \"git add\" 和/或 \"git commit -a\"）\n```\n`git status`告诉你 你修改了test.txt文件, 但是你想知道你怎么修改了这些文件, 做了什么改动\n这时候就需要`git diff`\n```\n$git diff\n-------提示如下-----------\ndiff --git a/test.txt b/test.txt\nindex 0858ae8..8c14912 100644\n--- a/test.txt\n+++ b/test.txt\n@@ -1,3 +1,4 @@\n 111111111111111\n 222222222222222\n 333333333333333\n+444444444444444\n```\n**现在你知道你进行了什么修改, 又进行了一次提交**\n```\nlsmg@ubuntu:~/temp$ git status\n位于分支 master\n尚未暂存以备提交的变更：\n  （使用 \"git add <文件>...\" 更新要提交的内容）\n  （使用 \"git checkout -- <文件>...\" 丢弃工作区的改动）\n\t修改：     test.txt\n修改尚未加入提交（使用 \"git add\" 和/或 \"git commit -a\"）\nlsmg@ubuntu:~/temp$ git add test.txt \nlsmg@ubuntu:~/temp$ git status\n位于分支 master\n要提交的变更：\n  （使用 \"git reset HEAD <文件>...\" 以取消暂存）\n\t修改：     test.txt\nlsmg@ubuntu:~/temp$ git commit -m \"ver 0.02\"\n[master ee4400f] ver 0.02\n 1 file changed, 1 insertion(+)\nlsmg@ubuntu:~/temp$ git status\n位于分支 master\n无文件要提交，干净的工作区\n```\n\n# 时光穿梭机\n**在commit之间切换**\nGit还可以在不同commit间切换, 当然你必须知道进行过哪些commit, 你不能自己都记在脑子里吧, 所以也存在相关的命令`git log`来查看你的commit记录\n```\nlsmg@ubuntu:~/temp$ git log\ncommit ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -> master)\nAuthor: ***********\nDate:   Sat Dec 7 21:06:42 2019 -0800\n    ver 0.02\n\ncommit 603260e28ac0cc8fb8e4243120eb00bca83585d2\nAuthor: ***********\nDate:   Sat Dec 7 20:57:58 2019 -0800\n    ver 0.01\n\nlsmg@ubuntu:~/temp$ git log --pretty=oneline # 简洁显示\nee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -> master) ver 0.02\n603260e28ac0cc8fb8e4243120eb00bca83585d2 ver 0.01\n```\n上面的`HEAD`代表当前版本, 上一个版本为`HEAD^`, 上上一个版本为`HEAD^^`如此类推\n回到前N个版本`HEAD~N`\n`git reset --hard HEAD^` 回到上一个版本.\n这时你当前版本将会丢失, 使用`git log`也不会查看到原来的版本信息\n这时使用`git reflog`来查看你的所有版本日志\n```\nlsmg@ubuntu:~/temp$ git reset --hard 603260e28ac0cc8fb8e4243120eb00bca83585d2\nHEAD 现在位于 603260e ver 0.01\nlsmg@ubuntu:~/temp$ git log\ncommit 603260e28ac0cc8fb8e4243120eb00bca83585d2 (HEAD -> master)\nAuthor: rjd67441 <rjd67441@hotmail.com>\nDate:   Sat Dec 7 20:57:58 2019 -0800\n\n    ver 0.01\nlsmg@ubuntu:~/temp$ git reflog \n603260e (HEAD -> master) HEAD@{0}: reset: moving to 603260e28ac0cc8fb8e4243120eb00bca83585d2\nee4400f HEAD@{1}: commit: ver 0.02\n603260e (HEAD -> master) HEAD@{2}: commit (initial): ver 0.01\nlsmg@ubuntu:~/temp$ git reset --hard ee4400f\nHEAD 现在位于 ee4400f ver 0.02\n```\n\n**撤销修改**\n工作区中的撤销\n`git checkout -- <filename>`\n一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；\n一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\n暂存区中的撤销\n`git reset HEAD <file>`\n版本库的撤销\n`git reset HEAD^` 乖乖回退一次\n\n**删除文件**\n删除本地文件后\n确实需要从版本库中删除\n`git rm`删除然后`git commit`提交即可\n误删除需要使用`git chechout -- <filename>`来恢复","slug":"Git-基础操作","published":1,"updated":"2020-03-07T12:50:48.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucv7001h8cuobf6fao1y","content":"<h1 id=\"命令总结\"><a href=\"#命令总结\" class=\"headerlink\" title=\"命令总结\"></a>命令总结</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -t Specifies the type of key to create.  The possible values are</span><br><span class=\"line\">#“dsa”, “ecdsa”, “ed25519”, or “rsa”.</span><br><span class=\"line\"># -C 生成注释 ...所以后面的邮箱就是个注释????</span><br><span class=\"line\">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">git init</span><br><span class=\"line\">git add &lt;file&gt;</span><br><span class=\"line\">git commit -m &lt;message&gt;</span><br><span class=\"line\">git remote add origin  # origin 意为远程库的名字, git的默认叫法</span><br><span class=\"line\"></span><br><span class=\"line\">git status</span><br><span class=\"line\">git diff</span><br><span class=\"line\">git log</span><br><span class=\"line\">git log --pretty&#x3D;oneline # 简单显示</span><br><span class=\"line\"></span><br><span class=\"line\"># 注意reset是恢复到上一个版本 即为你上一次commit版本或者pull最近的一次</span><br><span class=\"line\">git checkout --&lt;filename&gt; # 恢复工作区, 可用于恢复修改和恢复勿删文件</span><br><span class=\"line\">git reset HEAD &lt;file&gt; # 恢复暂存区</span><br><span class=\"line\">git reset HEAD^ # 恢复版本库</span><br><span class=\"line\">git reset --hard &lt;hash版本号 即为log中的一串英文字母, 只需要前几个字母即可&gt;</span><br><span class=\"line\">git reflog # 所有版本日志</span><br><span class=\"line\"></span><br><span class=\"line\">git rm 从版本库中删除文件</span><br><span class=\"line\"></span><br><span class=\"line\">git push -u origin master # 带上 -u 以后提交就不需要加入origin master, 类似记忆功能</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;git checkout -b dev&#96; #相当于一下两条命令</span><br><span class=\"line\">&#96;git branch dev&#96; # 分支创建</span><br><span class=\"line\">&#96;git checkout dev&#96; # 分支切换</span><br><span class=\"line\">&#96;git branch -d dev&#96; # 分支删除</span><br><span class=\"line\">&#96;git branch&#96; # 查看当前所有分支</span><br><span class=\"line\">&#96;git merge dev&#96; # 将制定的dev分支合并到当前的分支</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>首先把Git的三个区说明一下吧 自己后来慢慢感觉这些理论还是很重要的<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/Git%E4%B8%89%E5%A4%A7%E5%88%86%E5%8C%BA.png\" alt=\"\"><br>工作区<br>顾名思义, 你当前在IDE直接修改的代码全部都是位于工作区的代码<br>暂存区<br>暂时存取的区域, 你每次使用add提交的文件全部在这个区域中, 这些文件等待你的commit<br>版本库<br>这里存放的是若干个版本, 你每次的commit就是将暂存区的文件作为一个版本提交到版本库, 同时相应的文件被提交后 暂存区的文件被清除</p>\n<h1 id=\"基础的操作\"><a href=\"#基础的操作\" class=\"headerlink\" title=\"基础的操作\"></a>基础的操作</h1><p><strong>你的第一次提交</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git add &lt;file&gt;</span><br><span class=\"line\">git commit -m &lt;message&gt;</span><br></pre></td></tr></table></figure>\n<p><code>git init</code><br>在你命令所执行的文件夹生成版本库<br><code>git add &lt;file&gt;</code><br>将指定文件从工作区添加到暂存区<br>如果<code>&lt;file&gt;</code>用 <code>.</code> 代替则为所有相对上一次commit修改过的文件<br><code>git commit -m &lt;message&gt;</code><br>提交暂存区的文件到版本库中成为一个版本 message为这个版本(提交)的描述</p>\n<p><strong>好了你已经成功完成了一次提交, 继续去写代码了</strong><br>好你又写完了一堆代码 这时你想知道你工作区的状态是啥-你修改了哪些文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git status</span><br><span class=\"line\">-------提示如下-----------</span><br><span class=\"line\">位于分支 master</span><br><span class=\"line\">尚未暂存以备提交的变更：</span><br><span class=\"line\">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class=\"line\">  （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class=\"line\"></span><br><span class=\"line\">\t修改：     test.txt</span><br><span class=\"line\"></span><br><span class=\"line\">修改尚未加入提交（使用 &quot;git add&quot; 和&#x2F;或 &quot;git commit -a&quot;）</span><br></pre></td></tr></table></figure>\n<p><code>git status</code>告诉你 你修改了test.txt文件, 但是你想知道你怎么修改了这些文件, 做了什么改动<br>这时候就需要<code>git diff</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git diff</span><br><span class=\"line\">-------提示如下-----------</span><br><span class=\"line\">diff --git a&#x2F;test.txt b&#x2F;test.txt</span><br><span class=\"line\">index 0858ae8..8c14912 100644</span><br><span class=\"line\">--- a&#x2F;test.txt</span><br><span class=\"line\">+++ b&#x2F;test.txt</span><br><span class=\"line\">@@ -1,3 +1,4 @@</span><br><span class=\"line\"> 111111111111111</span><br><span class=\"line\"> 222222222222222</span><br><span class=\"line\"> 333333333333333</span><br><span class=\"line\">+444444444444444</span><br></pre></td></tr></table></figure>\n<p><strong>现在你知道你进行了什么修改, 又进行了一次提交</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class=\"line\">位于分支 master</span><br><span class=\"line\">尚未暂存以备提交的变更：</span><br><span class=\"line\">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class=\"line\">  （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class=\"line\">\t修改：     test.txt</span><br><span class=\"line\">修改尚未加入提交（使用 &quot;git add&quot; 和&#x2F;或 &quot;git commit -a&quot;）</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git add test.txt </span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class=\"line\">位于分支 master</span><br><span class=\"line\">要提交的变更：</span><br><span class=\"line\">  （使用 &quot;git reset HEAD &lt;文件&gt;...&quot; 以取消暂存）</span><br><span class=\"line\">\t修改：     test.txt</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git commit -m &quot;ver 0.02&quot;</span><br><span class=\"line\">[master ee4400f] ver 0.02</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class=\"line\">位于分支 master</span><br><span class=\"line\">无文件要提交，干净的工作区</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"时光穿梭机\"><a href=\"#时光穿梭机\" class=\"headerlink\" title=\"时光穿梭机\"></a>时光穿梭机</h1><p><strong>在commit之间切换</strong><br>Git还可以在不同commit间切换, 当然你必须知道进行过哪些commit, 你不能自己都记在脑子里吧, 所以也存在相关的命令<code>git log</code>来查看你的commit记录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git log</span><br><span class=\"line\">commit ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master)</span><br><span class=\"line\">Author: ***********</span><br><span class=\"line\">Date:   Sat Dec 7 21:06:42 2019 -0800</span><br><span class=\"line\">    ver 0.02</span><br><span class=\"line\"></span><br><span class=\"line\">commit 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class=\"line\">Author: ***********</span><br><span class=\"line\">Date:   Sat Dec 7 20:57:58 2019 -0800</span><br><span class=\"line\">    ver 0.01</span><br><span class=\"line\"></span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git log --pretty&#x3D;oneline # 简洁显示</span><br><span class=\"line\">ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master) ver 0.02</span><br><span class=\"line\">603260e28ac0cc8fb8e4243120eb00bca83585d2 ver 0.01</span><br></pre></td></tr></table></figure>\n<p>上面的<code>HEAD</code>代表当前版本, 上一个版本为<code>HEAD^</code>, 上上一个版本为<code>HEAD^^</code>如此类推<br>回到前N个版本<code>HEAD~N</code><br><code>git reset --hard HEAD^</code> 回到上一个版本.<br>这时你当前版本将会丢失, 使用<code>git log</code>也不会查看到原来的版本信息<br>这时使用<code>git reflog</code>来查看你的所有版本日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git reset --hard 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class=\"line\">HEAD 现在位于 603260e ver 0.01</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git log</span><br><span class=\"line\">commit 603260e28ac0cc8fb8e4243120eb00bca83585d2 (HEAD -&gt; master)</span><br><span class=\"line\">Author: rjd67441 &lt;rjd67441@hotmail.com&gt;</span><br><span class=\"line\">Date:   Sat Dec 7 20:57:58 2019 -0800</span><br><span class=\"line\"></span><br><span class=\"line\">    ver 0.01</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git reflog </span><br><span class=\"line\">603260e (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class=\"line\">ee4400f HEAD@&#123;1&#125;: commit: ver 0.02</span><br><span class=\"line\">603260e (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): ver 0.01</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git reset --hard ee4400f</span><br><span class=\"line\">HEAD 现在位于 ee4400f ver 0.02</span><br></pre></td></tr></table></figure>\n\n<p><strong>撤销修改</strong><br>工作区中的撤销<br><code>git checkout -- &lt;filename&gt;</code><br>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。<br>暂存区中的撤销<br><code>git reset HEAD &lt;file&gt;</code><br>版本库的撤销<br><code>git reset HEAD^</code> 乖乖回退一次</p>\n<p><strong>删除文件</strong><br>删除本地文件后<br>确实需要从版本库中删除<br><code>git rm</code>删除然后<code>git commit</code>提交即可<br>误删除需要使用<code>git chechout -- &lt;filename&gt;</code>来恢复</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"命令总结\"><a href=\"#命令总结\" class=\"headerlink\" title=\"命令总结\"></a>命令总结</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># -t Specifies the type of key to create.  The possible values are</span><br><span class=\"line\">#“dsa”, “ecdsa”, “ed25519”, or “rsa”.</span><br><span class=\"line\"># -C 生成注释 ...所以后面的邮箱就是个注释????</span><br><span class=\"line\">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">git init</span><br><span class=\"line\">git add &lt;file&gt;</span><br><span class=\"line\">git commit -m &lt;message&gt;</span><br><span class=\"line\">git remote add origin  # origin 意为远程库的名字, git的默认叫法</span><br><span class=\"line\"></span><br><span class=\"line\">git status</span><br><span class=\"line\">git diff</span><br><span class=\"line\">git log</span><br><span class=\"line\">git log --pretty&#x3D;oneline # 简单显示</span><br><span class=\"line\"></span><br><span class=\"line\"># 注意reset是恢复到上一个版本 即为你上一次commit版本或者pull最近的一次</span><br><span class=\"line\">git checkout --&lt;filename&gt; # 恢复工作区, 可用于恢复修改和恢复勿删文件</span><br><span class=\"line\">git reset HEAD &lt;file&gt; # 恢复暂存区</span><br><span class=\"line\">git reset HEAD^ # 恢复版本库</span><br><span class=\"line\">git reset --hard &lt;hash版本号 即为log中的一串英文字母, 只需要前几个字母即可&gt;</span><br><span class=\"line\">git reflog # 所有版本日志</span><br><span class=\"line\"></span><br><span class=\"line\">git rm 从版本库中删除文件</span><br><span class=\"line\"></span><br><span class=\"line\">git push -u origin master # 带上 -u 以后提交就不需要加入origin master, 类似记忆功能</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;git checkout -b dev&#96; #相当于一下两条命令</span><br><span class=\"line\">&#96;git branch dev&#96; # 分支创建</span><br><span class=\"line\">&#96;git checkout dev&#96; # 分支切换</span><br><span class=\"line\">&#96;git branch -d dev&#96; # 分支删除</span><br><span class=\"line\">&#96;git branch&#96; # 查看当前所有分支</span><br><span class=\"line\">&#96;git merge dev&#96; # 将制定的dev分支合并到当前的分支</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>首先把Git的三个区说明一下吧 自己后来慢慢感觉这些理论还是很重要的<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/Git%E4%B8%89%E5%A4%A7%E5%88%86%E5%8C%BA.png\" alt=\"\"><br>工作区<br>顾名思义, 你当前在IDE直接修改的代码全部都是位于工作区的代码<br>暂存区<br>暂时存取的区域, 你每次使用add提交的文件全部在这个区域中, 这些文件等待你的commit<br>版本库<br>这里存放的是若干个版本, 你每次的commit就是将暂存区的文件作为一个版本提交到版本库, 同时相应的文件被提交后 暂存区的文件被清除</p>\n<h1 id=\"基础的操作\"><a href=\"#基础的操作\" class=\"headerlink\" title=\"基础的操作\"></a>基础的操作</h1><p><strong>你的第一次提交</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git add &lt;file&gt;</span><br><span class=\"line\">git commit -m &lt;message&gt;</span><br></pre></td></tr></table></figure>\n<p><code>git init</code><br>在你命令所执行的文件夹生成版本库<br><code>git add &lt;file&gt;</code><br>将指定文件从工作区添加到暂存区<br>如果<code>&lt;file&gt;</code>用 <code>.</code> 代替则为所有相对上一次commit修改过的文件<br><code>git commit -m &lt;message&gt;</code><br>提交暂存区的文件到版本库中成为一个版本 message为这个版本(提交)的描述</p>\n<p><strong>好了你已经成功完成了一次提交, 继续去写代码了</strong><br>好你又写完了一堆代码 这时你想知道你工作区的状态是啥-你修改了哪些文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git status</span><br><span class=\"line\">-------提示如下-----------</span><br><span class=\"line\">位于分支 master</span><br><span class=\"line\">尚未暂存以备提交的变更：</span><br><span class=\"line\">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class=\"line\">  （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class=\"line\"></span><br><span class=\"line\">\t修改：     test.txt</span><br><span class=\"line\"></span><br><span class=\"line\">修改尚未加入提交（使用 &quot;git add&quot; 和&#x2F;或 &quot;git commit -a&quot;）</span><br></pre></td></tr></table></figure>\n<p><code>git status</code>告诉你 你修改了test.txt文件, 但是你想知道你怎么修改了这些文件, 做了什么改动<br>这时候就需要<code>git diff</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$git diff</span><br><span class=\"line\">-------提示如下-----------</span><br><span class=\"line\">diff --git a&#x2F;test.txt b&#x2F;test.txt</span><br><span class=\"line\">index 0858ae8..8c14912 100644</span><br><span class=\"line\">--- a&#x2F;test.txt</span><br><span class=\"line\">+++ b&#x2F;test.txt</span><br><span class=\"line\">@@ -1,3 +1,4 @@</span><br><span class=\"line\"> 111111111111111</span><br><span class=\"line\"> 222222222222222</span><br><span class=\"line\"> 333333333333333</span><br><span class=\"line\">+444444444444444</span><br></pre></td></tr></table></figure>\n<p><strong>现在你知道你进行了什么修改, 又进行了一次提交</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class=\"line\">位于分支 master</span><br><span class=\"line\">尚未暂存以备提交的变更：</span><br><span class=\"line\">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class=\"line\">  （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class=\"line\">\t修改：     test.txt</span><br><span class=\"line\">修改尚未加入提交（使用 &quot;git add&quot; 和&#x2F;或 &quot;git commit -a&quot;）</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git add test.txt </span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class=\"line\">位于分支 master</span><br><span class=\"line\">要提交的变更：</span><br><span class=\"line\">  （使用 &quot;git reset HEAD &lt;文件&gt;...&quot; 以取消暂存）</span><br><span class=\"line\">\t修改：     test.txt</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git commit -m &quot;ver 0.02&quot;</span><br><span class=\"line\">[master ee4400f] ver 0.02</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git status</span><br><span class=\"line\">位于分支 master</span><br><span class=\"line\">无文件要提交，干净的工作区</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"时光穿梭机\"><a href=\"#时光穿梭机\" class=\"headerlink\" title=\"时光穿梭机\"></a>时光穿梭机</h1><p><strong>在commit之间切换</strong><br>Git还可以在不同commit间切换, 当然你必须知道进行过哪些commit, 你不能自己都记在脑子里吧, 所以也存在相关的命令<code>git log</code>来查看你的commit记录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git log</span><br><span class=\"line\">commit ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master)</span><br><span class=\"line\">Author: ***********</span><br><span class=\"line\">Date:   Sat Dec 7 21:06:42 2019 -0800</span><br><span class=\"line\">    ver 0.02</span><br><span class=\"line\"></span><br><span class=\"line\">commit 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class=\"line\">Author: ***********</span><br><span class=\"line\">Date:   Sat Dec 7 20:57:58 2019 -0800</span><br><span class=\"line\">    ver 0.01</span><br><span class=\"line\"></span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git log --pretty&#x3D;oneline # 简洁显示</span><br><span class=\"line\">ee4400fc2b5694282b866b701f7c21655149e5a2 (HEAD -&gt; master) ver 0.02</span><br><span class=\"line\">603260e28ac0cc8fb8e4243120eb00bca83585d2 ver 0.01</span><br></pre></td></tr></table></figure>\n<p>上面的<code>HEAD</code>代表当前版本, 上一个版本为<code>HEAD^</code>, 上上一个版本为<code>HEAD^^</code>如此类推<br>回到前N个版本<code>HEAD~N</code><br><code>git reset --hard HEAD^</code> 回到上一个版本.<br>这时你当前版本将会丢失, 使用<code>git log</code>也不会查看到原来的版本信息<br>这时使用<code>git reflog</code>来查看你的所有版本日志</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git reset --hard 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class=\"line\">HEAD 现在位于 603260e ver 0.01</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git log</span><br><span class=\"line\">commit 603260e28ac0cc8fb8e4243120eb00bca83585d2 (HEAD -&gt; master)</span><br><span class=\"line\">Author: rjd67441 &lt;rjd67441@hotmail.com&gt;</span><br><span class=\"line\">Date:   Sat Dec 7 20:57:58 2019 -0800</span><br><span class=\"line\"></span><br><span class=\"line\">    ver 0.01</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git reflog </span><br><span class=\"line\">603260e (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 603260e28ac0cc8fb8e4243120eb00bca83585d2</span><br><span class=\"line\">ee4400f HEAD@&#123;1&#125;: commit: ver 0.02</span><br><span class=\"line\">603260e (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): ver 0.01</span><br><span class=\"line\">lsmg@ubuntu:~&#x2F;temp$ git reset --hard ee4400f</span><br><span class=\"line\">HEAD 现在位于 ee4400f ver 0.02</span><br></pre></td></tr></table></figure>\n\n<p><strong>撤销修改</strong><br>工作区中的撤销<br><code>git checkout -- &lt;filename&gt;</code><br>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。<br>总之，就是让这个文件回到最近一次git commit或git add时的状态。<br>暂存区中的撤销<br><code>git reset HEAD &lt;file&gt;</code><br>版本库的撤销<br><code>git reset HEAD^</code> 乖乖回退一次</p>\n<p><strong>删除文件</strong><br>删除本地文件后<br>确实需要从版本库中删除<br><code>git rm</code>删除然后<code>git commit</code>提交即可<br>误删除需要使用<code>git chechout -- &lt;filename&gt;</code>来恢复</p>\n"},{"title":"UE4TCP数据传输","date":"2020-03-08T08:38:28.000Z","img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/UE4/Ue4Log.png","_content":"\n记录一下UE4 Tcp传输数据的客户端代码\n方便日后使用\n\n# 头文件\n#include \"Networking.h\"\n\n// 添加 Networking 和 Sockets\nPublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", \"Networking\", \"Sockets\"});\n\n# 用到的数据结构\n```c++\nUENUM(BlueprintType)\nenum class FMsgType:uint8\n{\n\tEROOM_ENTER,\n\tEROOM_EXIT,\n\tEPLAYER_READY,\n\tEPLAYER_CANCEL_READY,\n\tEGAME_START,\n\tEROOM_PLAY_DATA,\n\tEGAME_OVER\n};\n\nUENUM(BlueprintType)\nenum class FMsgVersion :uint8\n{\n\tVERSION0 = 0,\n\tVERSION1 = 1\n};\n\nUSTRUCT(BlueprintType)\nstruct FProtoHead\n{\n\tGENERATED_BODY()\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\tFMsgType MsgType;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n    FMsgVersion MsgVer;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n    int32 BodyLen;\n};\n\nUSTRUCT(BlueprintType)\nstruct FProtoBody\n{\n\tGENERATED_BODY()\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n    bool Result;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n    int32 MsgId;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n    TArray<int32> DataArray;\n};\n\nUSTRUCT(BlueprintType)\nstruct FProtoMsg\n{\n\tGENERATED_BODY()\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n    FProtoHead Header;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n    FProtoBody Body;\n};\n```\n\n# socket管理\n```c++\n// h\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\nbool CreateSocket(const FString IPStr, int32 Port);\n\nFIPv4Address Ip;\nFSocket* ClientFd;\n\n// cpp\nbool AGameNetwork::CreateSocket(const FString IPStr, int32 Port)\n{\n    // 将字符串ip转换为点分十进制ip\n    FIPv4Address::Parse(IPStr, Ip);\n\n    // 将十进制ip 转化成网络地址\n    TSharedPtr<FInternetAddr> addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateInternetAddr();\n    addr->SetIp(Ip.Value);\n    addr->SetPort(Port);\n\n    // 创建TCP Socket 文件描述符\n    ClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateSocket(NAME_Stream, TEXT(\"TCP SOCKET\"), false);\n\n    if (ClientFd->Connect(*addr))\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n```\n\n# 数据发送和接收\n\n```c++\n// h\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\nbool SendMsg(FProtoMsg Msg);\n\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\nbool RecvMsg();\n\n// cpp\nbool AGameNetwork::SendMsg(FProtoMsg Msg)\n{\n\tint Len;\n\tint Send;\n\tuint8* data;\n\tdata = Encode(Msg, &Len);\n\t\n\tif (ClientFd->Send(data, Len, Send))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nbool AGameNetwork::RecvMsg()\n{\n\tif (ClientFd != nullptr)\n\t{\n\t\tuint8 Buffer[1024]{};\n\t\tuint32 Size = 0;\n\t\tint32 Read = 0;\n\t\twhile (ClientFd->HasPendingData(Size))\n\t\t{\n\t\t\tClientFd->Recv(Buffer, 1024, Read);\n\t\t\treturn Decode(Buffer, Read);\n\t\t}\n\t}\n\treturn false;\n}\n```\n\n# 数据序列化\n```c++\n// h\nuint8* Encode(FProtoMsg Msg, int32* Len);\nconst static int HEADER_SIZE = 6;\n\n// cpp\nuint8* AGameNetwork::Encode(FProtoMsg Msg, int32* Len)\n{\n\tMsg.Header.BodyLen = Msg.Body.DataArray.Num() * Msg.Body.DataArray.GetTypeSize() + 5;\n\n\t*Len = Msg.Header.BodyLen + HEADER_SIZE;\n\t// HEADER\n\tauto data = new uint8_t[*Len];\n    auto pdata = data;\n\tmemset(data, 0, *Len);\n\n\t*pdata = (uint8)Msg.Header.MsgType;\n\tpdata++;\n\n\t*pdata = (uint8)Msg.Header.MsgVer;\n\tpdata++;\n\n\t*(uint32_t*)pdata = Msg.Header.BodyLen;\n\tpdata += 4;\n\n\t// BODY\n\tpdata++;\n\t*(uint32_t*)pdata = Msg.Body.MsgId;\n\tpdata += 4;\n\t\n\tmemcpy(pdata, Msg.Body.DataArray.GetData(), Msg.Header.BodyLen - 5);\n\n\treturn data;\n}\n```\n\n# 数据反序列化\n```c++\n// h\nbool Decode(uint8* data, int32 len);\nbool ParseHeader(uint8** r_data, int32* reserved_len, int32* parse_len);\nbool ParseBody(uint8** r_data, int32* reserved_len, int32* parse_len);\n\nenum class ParseStatus\n{\n    PARSE_INIT,\n    PARSE_HEAD,\n    PARSE_BODY\n};\n\nTArray<uint8> ReservedData;\nFProtoMsg* CurrentMsg;\nParseStatus ParseStatus = ParseStatus::PARSE_INIT;\nTArray<FProtoMsg> MsgArray;\n\n\n// cpp\nbool AGameNetwork::Decode(uint8* data, int32 len)\n{\n\t// 防止沾包 直接将受到的数据全部按顺序存储\n\tfor (int32 i = 0; i < len; ++i)\n\t{\n\t\tReservedData.Push(data[i]);\n\t}\n\n\tint32 r_len = ReservedData.Num();\n\tuint8* r_data = ReservedData.GetData();\n\tint32 parse_len = 0;\n\n\twhile (r_len > 0)\n\t{\n\t\tswitch (ParseStatus)\n\t\t{\n\t\tcase ParseStatus::PARSE_INIT:\n\t\t\tCurrentMsg = new FProtoMsg();\n\t\t\tParseStatus = ParseStatus::PARSE_HEAD;\n\n\t\tcase ParseStatus::PARSE_HEAD:\n\t\t\tif (!ParseHeader(&r_data, &r_len, &parse_len))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\tcase ParseStatus::PARSE_BODY:\n\t\t\tif (!ParseBody(&r_data, &r_len, &parse_len))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (CurrentMsg != nullptr)\n\t\t\t{\n\t\t\t\tMsgArray.Push(*CurrentMsg);\n\t\t\t}\n\t\t\tCurrentMsg = nullptr;\n\t\t}\n\t}\n\tfor (int32 i = 0; i < parse_len; ++i)\n\t{\n\t\tReservedData.Pop();\n\t}\n\treturn true;\n}\n\nbool AGameNetwork::ParseHeader(uint8** r_data, int32* reserved_len, int32* parse_len)\n{\n\tif (*reserved_len < HEADER_SIZE)\n\t{\n\t\treturn false;\n\t}\n\n\tuint8* data = *r_data;\n\n\tCurrentMsg->Header.MsgType = StaticCast<FMsgType>(*data);\n\tdata++;\n\n\tCurrentMsg->Header.MsgVer = StaticCast<FMsgVersion>(*data);\n\tdata++;\n\n\tCurrentMsg->Header.BodyLen = *(uint32*)data;\n\n\t*reserved_len -= HEADER_SIZE;\n\t*parse_len += HEADER_SIZE;\n\t*r_data += HEADER_SIZE;\n\n\tParseStatus = ParseStatus::PARSE_BODY;\n\treturn true;\n}\n\nbool AGameNetwork::ParseBody(uint8** r_data, int32* reserved_len, int32* parse_len)\n{\n\tif (*reserved_len < CurrentMsg->Header.BodyLen)\n\t{\n\t\treturn false;\n\t}\n\n\tuint8* data = *r_data;\n\t// current_msg->body = data;\n\tCurrentMsg->Body.Result = (*data) == 1;\n\tdata++;\n\tCurrentMsg->Body.MsgId = *(int32*)data;\n\tdata += 4;\n\tfor (int i = 0; i < ((CurrentMsg->Header.BodyLen - 5) / sizeof(int32)); ++i)\n\t{\n\t\tCurrentMsg->Body.DataArray.Add(*(int32*)data);\n\t\tdata += 4;\n\t}\n\n\n\t*reserved_len -= CurrentMsg->Header.BodyLen;\n\t*parse_len += CurrentMsg->Header.BodyLen;\n\t*r_data += CurrentMsg->Header.BodyLen;\n\n\tParseStatus = ParseStatus::PARSE_INIT;\n\treturn true;\n}\n```\n\n# 数据获取\n```c++\n// h\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n    bool IsEmpty();\n\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n    FProtoMsg Front();\n\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n    void Pop();\n\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n    TArray<FProtoMsg> PopBackAllMsg();\n\n\n// cpp\nbool AGameNetwork::IsEmpty()\n{\n\treturn MsgArray.Num() == 0;\n}\n\nFProtoMsg AGameNetwork::Front()\n{\n\treturn MsgArray.Top();\n}\n\nvoid AGameNetwork::Pop()\n{\n\t// MsgArray.Pop();\n}\n\nTArray<FProtoMsg> AGameNetwork::PopBackAllMsg()\n{\n\tTArray<FProtoMsg> MsgArrayTemp = MsgArray;\n\tMsgArray.Empty();\n\treturn MsgArrayTemp;\n}\n```\n\n# 完整代码-继承自GameStateBase\n```c++\n// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameStateBase.h\"\n#include \"Networking.h\"\n#include \"GameNetwork.generated.h\"\n\n\nUENUM(BlueprintType)\nenum class FMsgType:uint8\n{\n\tEROOM_ENTER,\n\tEROOM_EXIT,\n\tEPLAYER_READY,\n\tEPLAYER_CANCEL_READY,\n\tEGAME_START,\n\tEROOM_PLAY_DATA,\n\tEGAME_OVER\n};\n\nUENUM(BlueprintType)\nenum class FMsgVersion :uint8\n{\n\tVERSION0 = 0,\n\tVERSION1 = 1\n};\n\nUSTRUCT(BlueprintType)\nstruct FProtoHead\n{\n\tGENERATED_BODY()\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\tFMsgType MsgType;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\t\tFMsgVersion MsgVer;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\t\tint32 BodyLen;\n};\n\nUSTRUCT(BlueprintType)\nstruct FProtoBody\n{\n\tGENERATED_BODY()\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\t\tbool Result;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\t\tint32 MsgId;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\t\tTArray<int32> DataArray;\n};\n\nUSTRUCT(BlueprintType)\nstruct FProtoMsg\n{\n\tGENERATED_BODY()\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\t\tFProtoHead Header;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\t\tFProtoBody Body;\n\n};\n\nUCLASS()\nclass PACMAN_API AGameNetwork : public AGameStateBase\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n\t\tbool CreateSocket(const FString IPStr, int32 Port);\n\n\tUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n\t\tbool SendMsg(FProtoMsg Msg);\n\n\tUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n\t\tbool RecvMsg();\n\n\tUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n\t\tbool IsEmpty();\n\n\tUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n\t\tFProtoMsg Front();\n\n\tUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n\t\tvoid Pop();\n\n\tUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n\t\tTArray<FProtoMsg> PopBackAllMsg();\n\n\tFIPv4Address Ip;\n\n\tFSocket* ClientFd;\n\npublic:\n\n\n\tenum class ParseStatus\n\t{\n\t\tPARSE_INIT,\n\t\tPARSE_HEAD,\n\t\tPARSE_BODY\n\t};\n\n\tbool Decode(uint8* data, int32 len);\n\n\tuint8* Encode(FProtoMsg Msg, int32* Len);\n\n\tconst static int HEADER_SIZE = 6;\n\n\tTArray<uint8> ReservedData;\n\n\tFProtoMsg* CurrentMsg;\n\n\tParseStatus ParseStatus = ParseStatus::PARSE_INIT;\n\n\tTArray<FProtoMsg> MsgArray;\n\n\tbool ParseHeader(uint8** r_data, int32* reserved_len, int32* parse_len);\n\n\tbool ParseBody(uint8** r_data, int32* reserved_len, int32* parse_len);\n};\n```\n\n```c++\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"GameNetwork.h\"\n\nbool AGameNetwork::CreateSocket(const FString IPStr, int32 Port)\n{\n\t// 将字符串ip转换为点分十进制ip\n\tFIPv4Address::Parse(IPStr, Ip);\n\n\t// 将十进制ip 转化成网络地址\n\tTSharedPtr<FInternetAddr> addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateInternetAddr();\n\taddr->SetIp(Ip.Value);\n\taddr->SetPort(Port);\n\n\t// 创建TCP Socket 文件描述符\n\tClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateSocket(NAME_Stream, TEXT(\"TCP SOCKET\"), false);\n\n\n\tif (ClientFd->Connect(*addr))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nbool AGameNetwork::SendMsg(FProtoMsg Msg)\n{\n\tint Len;\n\tint Send;\n\tuint8* data;\n\tdata = Encode(Msg, &Len);\n\t\n\tif (ClientFd->Send(data, Len, Send))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nbool AGameNetwork::RecvMsg()\n{\n\tif (ClientFd != nullptr)\n\t{\n\t\tuint8 Buffer[1024]{};\n\t\tuint32 Size = 0;\n\t\tint32 Read = 0;\n\t\twhile (ClientFd->HasPendingData(Size))\n\t\t{\n\t\t\tClientFd->Recv(Buffer, 1024, Read);\n\t\t\treturn Decode(Buffer, Read);\n\t\t}\n\t}\n\treturn false;\n}\n\nbool AGameNetwork::Decode(uint8* data, int32 len)\n{\n\t// 防止沾包 直接将受到的数据全部按顺序存储\n\tfor (int32 i = 0; i < len; ++i)\n\t{\n\t\tReservedData.Push(data[i]);\n\t}\n\n\tint32 r_len = ReservedData.Num();\n\tuint8* r_data = ReservedData.GetData();\n\tint32 parse_len = 0;\n\n\twhile (r_len > 0)\n\t{\n\t\tswitch (ParseStatus)\n\t\t{\n\t\tcase ParseStatus::PARSE_INIT:\n\t\t\tCurrentMsg = new FProtoMsg();\n\t\t\tParseStatus = ParseStatus::PARSE_HEAD;\n\n\t\tcase ParseStatus::PARSE_HEAD:\n\t\t\tif (!ParseHeader(&r_data, &r_len, &parse_len))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\tcase ParseStatus::PARSE_BODY:\n\t\t\tif (!ParseBody(&r_data, &r_len, &parse_len))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (CurrentMsg != nullptr)\n\t\t\t{\n\t\t\t\tMsgArray.Push(*CurrentMsg);\n\t\t\t}\n\t\t\tCurrentMsg = nullptr;\n\t\t}\n\t}\n\tfor (int32 i = 0; i < parse_len; ++i)\n\t{\n\t\tReservedData.Pop();\n\t}\n\treturn true;\n}\n\nuint8* AGameNetwork::Encode(FProtoMsg Msg, int32* Len)\n{\n\tMsg.Header.BodyLen = Msg.Body.DataArray.Num() * Msg.Body.DataArray.GetTypeSize() + 5;\n\n\t*Len = Msg.Header.BodyLen + HEADER_SIZE;\n\t// HEADER\n\tauto* data = new uint8_t[*Len];\n\tmemset(data, 0, *Len);\n\n\t*data = (uint8)Msg.Header.MsgType;\n\tdata++;\n\n\t*data = (uint8)Msg.Header.MsgVer;\n\tdata++;\n\n\t*(uint32_t*)data = Msg.Header.BodyLen;\n\tdata += 4;\n\n\t// BODY\n\tdata++;\n\t*(uint32_t*)data = Msg.Body.MsgId;\n\tdata += 4;\n\t\n\tmemcpy(data, Msg.Body.DataArray.GetData(), Msg.Header.BodyLen - 5);\n\n\t// 回退增加的部分\n\treturn data - HEADER_SIZE - 5;\n}\n\nbool AGameNetwork::ParseHeader(uint8** r_data, int32* reserved_len, int32* parse_len)\n{\n\tif (*reserved_len < HEADER_SIZE)\n\t{\n\t\treturn false;\n\t}\n\n\tuint8* data = *r_data;\n\n\tCurrentMsg->Header.MsgType = StaticCast<FMsgType>(*data);\n\tdata++;\n\n\tCurrentMsg->Header.MsgVer = StaticCast<FMsgVersion>(*data);\n\tdata++;\n\n\tCurrentMsg->Header.BodyLen = *(uint32*)data;\n\n\t*reserved_len -= HEADER_SIZE;\n\t*parse_len += HEADER_SIZE;\n\t*r_data += HEADER_SIZE;\n\n\tParseStatus = ParseStatus::PARSE_BODY;\n\treturn true;\n}\n\nbool AGameNetwork::ParseBody(uint8** r_data, int32* reserved_len, int32* parse_len)\n{\n\tif (*reserved_len < CurrentMsg->Header.BodyLen)\n\t{\n\t\treturn false;\n\t}\n\n\tuint8* data = *r_data;\n\t// current_msg->body = data;\n\tCurrentMsg->Body.Result = (*data) == 1;\n\tdata++;\n\tCurrentMsg->Body.MsgId = *(int32*)data;\n\tdata += 4;\n\tfor (int i = 0; i < ((CurrentMsg->Header.BodyLen - 5) / sizeof(int32)); ++i)\n\t{\n\t\tCurrentMsg->Body.DataArray.Add(*(int32*)data);\n\t\tdata += 4;\n\t}\n\n\n\t*reserved_len -= CurrentMsg->Header.BodyLen;\n\t*parse_len += CurrentMsg->Header.BodyLen;\n\t*r_data += CurrentMsg->Header.BodyLen;\n\n\tParseStatus = ParseStatus::PARSE_INIT;\n\treturn true;\n}\n\nbool AGameNetwork::IsEmpty()\n{\n\treturn MsgArray.Num() == 0;\n}\n\nFProtoMsg AGameNetwork::Front()\n{\n\treturn MsgArray.Top();\n}\n\nvoid AGameNetwork::Pop()\n{\n\t// MsgArray.Pop();\n}\n\nTArray<FProtoMsg> AGameNetwork::PopBackAllMsg()\n{\n\tTArray<FProtoMsg> MsgArrayTemp = MsgArray;\n\tMsgArray.Empty();\n\treturn MsgArrayTemp;\n}\n```","source":"_posts/UE4-网络-数据传输.md","raw":"---\ntitle: UE4TCP数据传输\ndate: 2020-03-08 16:38:28\ntags:\ncategories:\n - UE4\n - 网络\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/UE4/Ue4Log.png\n---\n\n记录一下UE4 Tcp传输数据的客户端代码\n方便日后使用\n\n# 头文件\n#include \"Networking.h\"\n\n// 添加 Networking 和 Sockets\nPublicDependencyModuleNames.AddRange(new string[] { \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", \"Networking\", \"Sockets\"});\n\n# 用到的数据结构\n```c++\nUENUM(BlueprintType)\nenum class FMsgType:uint8\n{\n\tEROOM_ENTER,\n\tEROOM_EXIT,\n\tEPLAYER_READY,\n\tEPLAYER_CANCEL_READY,\n\tEGAME_START,\n\tEROOM_PLAY_DATA,\n\tEGAME_OVER\n};\n\nUENUM(BlueprintType)\nenum class FMsgVersion :uint8\n{\n\tVERSION0 = 0,\n\tVERSION1 = 1\n};\n\nUSTRUCT(BlueprintType)\nstruct FProtoHead\n{\n\tGENERATED_BODY()\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\tFMsgType MsgType;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n    FMsgVersion MsgVer;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n    int32 BodyLen;\n};\n\nUSTRUCT(BlueprintType)\nstruct FProtoBody\n{\n\tGENERATED_BODY()\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n    bool Result;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n    int32 MsgId;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n    TArray<int32> DataArray;\n};\n\nUSTRUCT(BlueprintType)\nstruct FProtoMsg\n{\n\tGENERATED_BODY()\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n    FProtoHead Header;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n    FProtoBody Body;\n};\n```\n\n# socket管理\n```c++\n// h\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\nbool CreateSocket(const FString IPStr, int32 Port);\n\nFIPv4Address Ip;\nFSocket* ClientFd;\n\n// cpp\nbool AGameNetwork::CreateSocket(const FString IPStr, int32 Port)\n{\n    // 将字符串ip转换为点分十进制ip\n    FIPv4Address::Parse(IPStr, Ip);\n\n    // 将十进制ip 转化成网络地址\n    TSharedPtr<FInternetAddr> addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateInternetAddr();\n    addr->SetIp(Ip.Value);\n    addr->SetPort(Port);\n\n    // 创建TCP Socket 文件描述符\n    ClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateSocket(NAME_Stream, TEXT(\"TCP SOCKET\"), false);\n\n    if (ClientFd->Connect(*addr))\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n```\n\n# 数据发送和接收\n\n```c++\n// h\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\nbool SendMsg(FProtoMsg Msg);\n\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\nbool RecvMsg();\n\n// cpp\nbool AGameNetwork::SendMsg(FProtoMsg Msg)\n{\n\tint Len;\n\tint Send;\n\tuint8* data;\n\tdata = Encode(Msg, &Len);\n\t\n\tif (ClientFd->Send(data, Len, Send))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nbool AGameNetwork::RecvMsg()\n{\n\tif (ClientFd != nullptr)\n\t{\n\t\tuint8 Buffer[1024]{};\n\t\tuint32 Size = 0;\n\t\tint32 Read = 0;\n\t\twhile (ClientFd->HasPendingData(Size))\n\t\t{\n\t\t\tClientFd->Recv(Buffer, 1024, Read);\n\t\t\treturn Decode(Buffer, Read);\n\t\t}\n\t}\n\treturn false;\n}\n```\n\n# 数据序列化\n```c++\n// h\nuint8* Encode(FProtoMsg Msg, int32* Len);\nconst static int HEADER_SIZE = 6;\n\n// cpp\nuint8* AGameNetwork::Encode(FProtoMsg Msg, int32* Len)\n{\n\tMsg.Header.BodyLen = Msg.Body.DataArray.Num() * Msg.Body.DataArray.GetTypeSize() + 5;\n\n\t*Len = Msg.Header.BodyLen + HEADER_SIZE;\n\t// HEADER\n\tauto data = new uint8_t[*Len];\n    auto pdata = data;\n\tmemset(data, 0, *Len);\n\n\t*pdata = (uint8)Msg.Header.MsgType;\n\tpdata++;\n\n\t*pdata = (uint8)Msg.Header.MsgVer;\n\tpdata++;\n\n\t*(uint32_t*)pdata = Msg.Header.BodyLen;\n\tpdata += 4;\n\n\t// BODY\n\tpdata++;\n\t*(uint32_t*)pdata = Msg.Body.MsgId;\n\tpdata += 4;\n\t\n\tmemcpy(pdata, Msg.Body.DataArray.GetData(), Msg.Header.BodyLen - 5);\n\n\treturn data;\n}\n```\n\n# 数据反序列化\n```c++\n// h\nbool Decode(uint8* data, int32 len);\nbool ParseHeader(uint8** r_data, int32* reserved_len, int32* parse_len);\nbool ParseBody(uint8** r_data, int32* reserved_len, int32* parse_len);\n\nenum class ParseStatus\n{\n    PARSE_INIT,\n    PARSE_HEAD,\n    PARSE_BODY\n};\n\nTArray<uint8> ReservedData;\nFProtoMsg* CurrentMsg;\nParseStatus ParseStatus = ParseStatus::PARSE_INIT;\nTArray<FProtoMsg> MsgArray;\n\n\n// cpp\nbool AGameNetwork::Decode(uint8* data, int32 len)\n{\n\t// 防止沾包 直接将受到的数据全部按顺序存储\n\tfor (int32 i = 0; i < len; ++i)\n\t{\n\t\tReservedData.Push(data[i]);\n\t}\n\n\tint32 r_len = ReservedData.Num();\n\tuint8* r_data = ReservedData.GetData();\n\tint32 parse_len = 0;\n\n\twhile (r_len > 0)\n\t{\n\t\tswitch (ParseStatus)\n\t\t{\n\t\tcase ParseStatus::PARSE_INIT:\n\t\t\tCurrentMsg = new FProtoMsg();\n\t\t\tParseStatus = ParseStatus::PARSE_HEAD;\n\n\t\tcase ParseStatus::PARSE_HEAD:\n\t\t\tif (!ParseHeader(&r_data, &r_len, &parse_len))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\tcase ParseStatus::PARSE_BODY:\n\t\t\tif (!ParseBody(&r_data, &r_len, &parse_len))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (CurrentMsg != nullptr)\n\t\t\t{\n\t\t\t\tMsgArray.Push(*CurrentMsg);\n\t\t\t}\n\t\t\tCurrentMsg = nullptr;\n\t\t}\n\t}\n\tfor (int32 i = 0; i < parse_len; ++i)\n\t{\n\t\tReservedData.Pop();\n\t}\n\treturn true;\n}\n\nbool AGameNetwork::ParseHeader(uint8** r_data, int32* reserved_len, int32* parse_len)\n{\n\tif (*reserved_len < HEADER_SIZE)\n\t{\n\t\treturn false;\n\t}\n\n\tuint8* data = *r_data;\n\n\tCurrentMsg->Header.MsgType = StaticCast<FMsgType>(*data);\n\tdata++;\n\n\tCurrentMsg->Header.MsgVer = StaticCast<FMsgVersion>(*data);\n\tdata++;\n\n\tCurrentMsg->Header.BodyLen = *(uint32*)data;\n\n\t*reserved_len -= HEADER_SIZE;\n\t*parse_len += HEADER_SIZE;\n\t*r_data += HEADER_SIZE;\n\n\tParseStatus = ParseStatus::PARSE_BODY;\n\treturn true;\n}\n\nbool AGameNetwork::ParseBody(uint8** r_data, int32* reserved_len, int32* parse_len)\n{\n\tif (*reserved_len < CurrentMsg->Header.BodyLen)\n\t{\n\t\treturn false;\n\t}\n\n\tuint8* data = *r_data;\n\t// current_msg->body = data;\n\tCurrentMsg->Body.Result = (*data) == 1;\n\tdata++;\n\tCurrentMsg->Body.MsgId = *(int32*)data;\n\tdata += 4;\n\tfor (int i = 0; i < ((CurrentMsg->Header.BodyLen - 5) / sizeof(int32)); ++i)\n\t{\n\t\tCurrentMsg->Body.DataArray.Add(*(int32*)data);\n\t\tdata += 4;\n\t}\n\n\n\t*reserved_len -= CurrentMsg->Header.BodyLen;\n\t*parse_len += CurrentMsg->Header.BodyLen;\n\t*r_data += CurrentMsg->Header.BodyLen;\n\n\tParseStatus = ParseStatus::PARSE_INIT;\n\treturn true;\n}\n```\n\n# 数据获取\n```c++\n// h\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n    bool IsEmpty();\n\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n    FProtoMsg Front();\n\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n    void Pop();\n\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n    TArray<FProtoMsg> PopBackAllMsg();\n\n\n// cpp\nbool AGameNetwork::IsEmpty()\n{\n\treturn MsgArray.Num() == 0;\n}\n\nFProtoMsg AGameNetwork::Front()\n{\n\treturn MsgArray.Top();\n}\n\nvoid AGameNetwork::Pop()\n{\n\t// MsgArray.Pop();\n}\n\nTArray<FProtoMsg> AGameNetwork::PopBackAllMsg()\n{\n\tTArray<FProtoMsg> MsgArrayTemp = MsgArray;\n\tMsgArray.Empty();\n\treturn MsgArrayTemp;\n}\n```\n\n# 完整代码-继承自GameStateBase\n```c++\n// Fill out your copyright notice in the Description page of Project Settings.\n\n#pragma once\n\n#include \"CoreMinimal.h\"\n#include \"GameFramework/GameStateBase.h\"\n#include \"Networking.h\"\n#include \"GameNetwork.generated.h\"\n\n\nUENUM(BlueprintType)\nenum class FMsgType:uint8\n{\n\tEROOM_ENTER,\n\tEROOM_EXIT,\n\tEPLAYER_READY,\n\tEPLAYER_CANCEL_READY,\n\tEGAME_START,\n\tEROOM_PLAY_DATA,\n\tEGAME_OVER\n};\n\nUENUM(BlueprintType)\nenum class FMsgVersion :uint8\n{\n\tVERSION0 = 0,\n\tVERSION1 = 1\n};\n\nUSTRUCT(BlueprintType)\nstruct FProtoHead\n{\n\tGENERATED_BODY()\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\tFMsgType MsgType;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\t\tFMsgVersion MsgVer;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\t\tint32 BodyLen;\n};\n\nUSTRUCT(BlueprintType)\nstruct FProtoBody\n{\n\tGENERATED_BODY()\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\t\tbool Result;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\t\tint32 MsgId;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\t\tTArray<int32> DataArray;\n};\n\nUSTRUCT(BlueprintType)\nstruct FProtoMsg\n{\n\tGENERATED_BODY()\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\t\tFProtoHead Header;\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Mantra\")\n\t\tFProtoBody Body;\n\n};\n\nUCLASS()\nclass PACMAN_API AGameNetwork : public AGameStateBase\n{\n\tGENERATED_BODY()\n\t\npublic:\n\tUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n\t\tbool CreateSocket(const FString IPStr, int32 Port);\n\n\tUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n\t\tbool SendMsg(FProtoMsg Msg);\n\n\tUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n\t\tbool RecvMsg();\n\n\tUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n\t\tbool IsEmpty();\n\n\tUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n\t\tFProtoMsg Front();\n\n\tUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n\t\tvoid Pop();\n\n\tUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\n\t\tTArray<FProtoMsg> PopBackAllMsg();\n\n\tFIPv4Address Ip;\n\n\tFSocket* ClientFd;\n\npublic:\n\n\n\tenum class ParseStatus\n\t{\n\t\tPARSE_INIT,\n\t\tPARSE_HEAD,\n\t\tPARSE_BODY\n\t};\n\n\tbool Decode(uint8* data, int32 len);\n\n\tuint8* Encode(FProtoMsg Msg, int32* Len);\n\n\tconst static int HEADER_SIZE = 6;\n\n\tTArray<uint8> ReservedData;\n\n\tFProtoMsg* CurrentMsg;\n\n\tParseStatus ParseStatus = ParseStatus::PARSE_INIT;\n\n\tTArray<FProtoMsg> MsgArray;\n\n\tbool ParseHeader(uint8** r_data, int32* reserved_len, int32* parse_len);\n\n\tbool ParseBody(uint8** r_data, int32* reserved_len, int32* parse_len);\n};\n```\n\n```c++\n// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"GameNetwork.h\"\n\nbool AGameNetwork::CreateSocket(const FString IPStr, int32 Port)\n{\n\t// 将字符串ip转换为点分十进制ip\n\tFIPv4Address::Parse(IPStr, Ip);\n\n\t// 将十进制ip 转化成网络地址\n\tTSharedPtr<FInternetAddr> addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateInternetAddr();\n\taddr->SetIp(Ip.Value);\n\taddr->SetPort(Port);\n\n\t// 创建TCP Socket 文件描述符\n\tClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateSocket(NAME_Stream, TEXT(\"TCP SOCKET\"), false);\n\n\n\tif (ClientFd->Connect(*addr))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nbool AGameNetwork::SendMsg(FProtoMsg Msg)\n{\n\tint Len;\n\tint Send;\n\tuint8* data;\n\tdata = Encode(Msg, &Len);\n\t\n\tif (ClientFd->Send(data, Len, Send))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nbool AGameNetwork::RecvMsg()\n{\n\tif (ClientFd != nullptr)\n\t{\n\t\tuint8 Buffer[1024]{};\n\t\tuint32 Size = 0;\n\t\tint32 Read = 0;\n\t\twhile (ClientFd->HasPendingData(Size))\n\t\t{\n\t\t\tClientFd->Recv(Buffer, 1024, Read);\n\t\t\treturn Decode(Buffer, Read);\n\t\t}\n\t}\n\treturn false;\n}\n\nbool AGameNetwork::Decode(uint8* data, int32 len)\n{\n\t// 防止沾包 直接将受到的数据全部按顺序存储\n\tfor (int32 i = 0; i < len; ++i)\n\t{\n\t\tReservedData.Push(data[i]);\n\t}\n\n\tint32 r_len = ReservedData.Num();\n\tuint8* r_data = ReservedData.GetData();\n\tint32 parse_len = 0;\n\n\twhile (r_len > 0)\n\t{\n\t\tswitch (ParseStatus)\n\t\t{\n\t\tcase ParseStatus::PARSE_INIT:\n\t\t\tCurrentMsg = new FProtoMsg();\n\t\t\tParseStatus = ParseStatus::PARSE_HEAD;\n\n\t\tcase ParseStatus::PARSE_HEAD:\n\t\t\tif (!ParseHeader(&r_data, &r_len, &parse_len))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\tcase ParseStatus::PARSE_BODY:\n\t\t\tif (!ParseBody(&r_data, &r_len, &parse_len))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (CurrentMsg != nullptr)\n\t\t\t{\n\t\t\t\tMsgArray.Push(*CurrentMsg);\n\t\t\t}\n\t\t\tCurrentMsg = nullptr;\n\t\t}\n\t}\n\tfor (int32 i = 0; i < parse_len; ++i)\n\t{\n\t\tReservedData.Pop();\n\t}\n\treturn true;\n}\n\nuint8* AGameNetwork::Encode(FProtoMsg Msg, int32* Len)\n{\n\tMsg.Header.BodyLen = Msg.Body.DataArray.Num() * Msg.Body.DataArray.GetTypeSize() + 5;\n\n\t*Len = Msg.Header.BodyLen + HEADER_SIZE;\n\t// HEADER\n\tauto* data = new uint8_t[*Len];\n\tmemset(data, 0, *Len);\n\n\t*data = (uint8)Msg.Header.MsgType;\n\tdata++;\n\n\t*data = (uint8)Msg.Header.MsgVer;\n\tdata++;\n\n\t*(uint32_t*)data = Msg.Header.BodyLen;\n\tdata += 4;\n\n\t// BODY\n\tdata++;\n\t*(uint32_t*)data = Msg.Body.MsgId;\n\tdata += 4;\n\t\n\tmemcpy(data, Msg.Body.DataArray.GetData(), Msg.Header.BodyLen - 5);\n\n\t// 回退增加的部分\n\treturn data - HEADER_SIZE - 5;\n}\n\nbool AGameNetwork::ParseHeader(uint8** r_data, int32* reserved_len, int32* parse_len)\n{\n\tif (*reserved_len < HEADER_SIZE)\n\t{\n\t\treturn false;\n\t}\n\n\tuint8* data = *r_data;\n\n\tCurrentMsg->Header.MsgType = StaticCast<FMsgType>(*data);\n\tdata++;\n\n\tCurrentMsg->Header.MsgVer = StaticCast<FMsgVersion>(*data);\n\tdata++;\n\n\tCurrentMsg->Header.BodyLen = *(uint32*)data;\n\n\t*reserved_len -= HEADER_SIZE;\n\t*parse_len += HEADER_SIZE;\n\t*r_data += HEADER_SIZE;\n\n\tParseStatus = ParseStatus::PARSE_BODY;\n\treturn true;\n}\n\nbool AGameNetwork::ParseBody(uint8** r_data, int32* reserved_len, int32* parse_len)\n{\n\tif (*reserved_len < CurrentMsg->Header.BodyLen)\n\t{\n\t\treturn false;\n\t}\n\n\tuint8* data = *r_data;\n\t// current_msg->body = data;\n\tCurrentMsg->Body.Result = (*data) == 1;\n\tdata++;\n\tCurrentMsg->Body.MsgId = *(int32*)data;\n\tdata += 4;\n\tfor (int i = 0; i < ((CurrentMsg->Header.BodyLen - 5) / sizeof(int32)); ++i)\n\t{\n\t\tCurrentMsg->Body.DataArray.Add(*(int32*)data);\n\t\tdata += 4;\n\t}\n\n\n\t*reserved_len -= CurrentMsg->Header.BodyLen;\n\t*parse_len += CurrentMsg->Header.BodyLen;\n\t*r_data += CurrentMsg->Header.BodyLen;\n\n\tParseStatus = ParseStatus::PARSE_INIT;\n\treturn true;\n}\n\nbool AGameNetwork::IsEmpty()\n{\n\treturn MsgArray.Num() == 0;\n}\n\nFProtoMsg AGameNetwork::Front()\n{\n\treturn MsgArray.Top();\n}\n\nvoid AGameNetwork::Pop()\n{\n\t// MsgArray.Pop();\n}\n\nTArray<FProtoMsg> AGameNetwork::PopBackAllMsg()\n{\n\tTArray<FProtoMsg> MsgArrayTemp = MsgArray;\n\tMsgArray.Empty();\n\treturn MsgArrayTemp;\n}\n```","slug":"UE4-网络-数据传输","published":1,"updated":"2020-03-09T13:36:52.520Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucva001l8cuo3as7688r","content":"<p>记录一下UE4 Tcp传输数据的客户端代码<br>方便日后使用</p>\n<h1 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h1><p>#include “Networking.h”</p>\n<p>// 添加 Networking 和 Sockets<br>PublicDependencyModuleNames.AddRange(new string[] { “Core”, “CoreUObject”, “Engine”, “InputCore”, “Networking”, “Sockets”});</p>\n<h1 id=\"用到的数据结构\"><a href=\"#用到的数据结构\" class=\"headerlink\" title=\"用到的数据结构\"></a>用到的数据结构</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UENUM(BlueprintType)</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FMsgType</span>:</span>uint8</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tEROOM_ENTER,</span><br><span class=\"line\">\tEROOM_EXIT,</span><br><span class=\"line\">\tEPLAYER_READY,</span><br><span class=\"line\">\tEPLAYER_CANCEL_READY,</span><br><span class=\"line\">\tEGAME_START,</span><br><span class=\"line\">\tEROOM_PLAY_DATA,</span><br><span class=\"line\">\tEGAME_OVER</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">UENUM(BlueprintType)</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FMsgVersion</span> :</span>uint8</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVERSION0 = <span class=\"number\">0</span>,</span><br><span class=\"line\">\tVERSION1 = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">USTRUCT(BlueprintType)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FProtoHead</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tGENERATED_BODY()</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\tFMsgType MsgType;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">    FMsgVersion MsgVer;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">    int32 BodyLen;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">USTRUCT(BlueprintType)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FProtoBody</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tGENERATED_BODY()</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> Result;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">    int32 MsgId;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">    TArray&lt;int32&gt; DataArray;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">USTRUCT(BlueprintType)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FProtoMsg</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tGENERATED_BODY()</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">    FProtoHead Header;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">    FProtoBody Body;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"socket管理\"><a href=\"#socket管理\" class=\"headerlink\" title=\"socket管理\"></a>socket管理</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// h</span></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">CreateSocket</span><span class=\"params\">(<span class=\"keyword\">const</span> FString IPStr, int32 Port)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">FIPv4Address Ip;</span><br><span class=\"line\">FSocket* ClientFd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::CreateSocket</span><span class=\"params\">(<span class=\"keyword\">const</span> FString IPStr, int32 Port)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将字符串ip转换为点分十进制ip</span></span><br><span class=\"line\">    FIPv4Address::Parse(IPStr, Ip);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将十进制ip 转化成网络地址</span></span><br><span class=\"line\">    TSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();</span><br><span class=\"line\">    addr-&gt;SetIp(Ip.Value);</span><br><span class=\"line\">    addr-&gt;SetPort(Port);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建TCP Socket 文件描述符</span></span><br><span class=\"line\">    ClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class=\"string\">\"TCP SOCKET\"</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ClientFd-&gt;Connect(*addr))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数据发送和接收\"><a href=\"#数据发送和接收\" class=\"headerlink\" title=\"数据发送和接收\"></a>数据发送和接收</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// h</span></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SendMsg</span><span class=\"params\">(FProtoMsg Msg)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">RecvMsg</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::SendMsg</span><span class=\"params\">(FProtoMsg Msg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Len;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Send;</span><br><span class=\"line\">\tuint8* data;</span><br><span class=\"line\">\tdata = Encode(Msg, &amp;Len);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ClientFd-&gt;Send(data, Len, Send))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::RecvMsg</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ClientFd != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tuint8 Buffer[<span class=\"number\">1024</span>]&#123;&#125;;</span><br><span class=\"line\">\t\tuint32 Size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tint32 Read = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (ClientFd-&gt;HasPendingData(Size))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tClientFd-&gt;Recv(Buffer, <span class=\"number\">1024</span>, Read);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Decode(Buffer, Read);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数据序列化\"><a href=\"#数据序列化\" class=\"headerlink\" title=\"数据序列化\"></a>数据序列化</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// h</span></span><br><span class=\"line\"><span class=\"function\">uint8* <span class=\"title\">Encode</span><span class=\"params\">(FProtoMsg Msg, int32* Len)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> HEADER_SIZE = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cpp</span></span><br><span class=\"line\"><span class=\"function\">uint8* <span class=\"title\">AGameNetwork::Encode</span><span class=\"params\">(FProtoMsg Msg, int32* Len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tMsg.Header.BodyLen = Msg.Body.DataArray.Num() * Msg.Body.DataArray.GetTypeSize() + <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*Len = Msg.Header.BodyLen + HEADER_SIZE;</span><br><span class=\"line\">\t<span class=\"comment\">// HEADER</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> data = <span class=\"keyword\">new</span> <span class=\"keyword\">uint8_t</span>[*Len];</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> pdata = data;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, *Len);</span><br><span class=\"line\"></span><br><span class=\"line\">\t*pdata = (uint8)Msg.Header.MsgType;</span><br><span class=\"line\">\tpdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*pdata = (uint8)Msg.Header.MsgVer;</span><br><span class=\"line\">\tpdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*(<span class=\"keyword\">uint32_t</span>*)pdata = Msg.Header.BodyLen;</span><br><span class=\"line\">\tpdata += <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// BODY</span></span><br><span class=\"line\">\tpdata++;</span><br><span class=\"line\">\t*(<span class=\"keyword\">uint32_t</span>*)pdata = Msg.Body.MsgId;</span><br><span class=\"line\">\tpdata += <span class=\"number\">4</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(pdata, Msg.Body.DataArray.GetData(), Msg.Header.BodyLen - <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数据反序列化\"><a href=\"#数据反序列化\" class=\"headerlink\" title=\"数据反序列化\"></a>数据反序列化</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Decode</span><span class=\"params\">(uint8* data, int32 len)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ParseHeader</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ParseBody</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParseStatus</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    PARSE_INIT,</span><br><span class=\"line\">    PARSE_HEAD,</span><br><span class=\"line\">    PARSE_BODY</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">TArray&lt;uint8&gt; ReservedData;</span><br><span class=\"line\">FProtoMsg* CurrentMsg;</span><br><span class=\"line\">ParseStatus ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class=\"line\">TArray&lt;FProtoMsg&gt; MsgArray;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::Decode</span><span class=\"params\">(uint8* data, int32 len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 防止沾包 直接将受到的数据全部按顺序存储</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int32 i = <span class=\"number\">0</span>; i &lt; len; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tReservedData.Push(data[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tint32 r_len = ReservedData.Num();</span><br><span class=\"line\">\tuint8* r_data = ReservedData.GetData();</span><br><span class=\"line\">\tint32 parse_len = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (r_len &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (ParseStatus)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> ParseStatus::PARSE_INIT:</span><br><span class=\"line\">\t\t\tCurrentMsg = <span class=\"keyword\">new</span> FProtoMsg();</span><br><span class=\"line\">\t\t\tParseStatus = ParseStatus::PARSE_HEAD;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> ParseStatus::PARSE_HEAD:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!ParseHeader(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> ParseStatus::PARSE_BODY:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!ParseBody(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (CurrentMsg != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tMsgArray.Push(*CurrentMsg);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tCurrentMsg = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int32 i = <span class=\"number\">0</span>; i &lt; parse_len; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tReservedData.Pop();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::ParseHeader</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*reserved_len &lt; HEADER_SIZE)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuint8* data = *r_data;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCurrentMsg-&gt;Header.MsgType = StaticCast&lt;FMsgType&gt;(*data);</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCurrentMsg-&gt;Header.MsgVer = StaticCast&lt;FMsgVersion&gt;(*data);</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCurrentMsg-&gt;Header.BodyLen = *(uint32*)data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*reserved_len -= HEADER_SIZE;</span><br><span class=\"line\">\t*parse_len += HEADER_SIZE;</span><br><span class=\"line\">\t*r_data += HEADER_SIZE;</span><br><span class=\"line\"></span><br><span class=\"line\">\tParseStatus = ParseStatus::PARSE_BODY;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::ParseBody</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*reserved_len &lt; CurrentMsg-&gt;Header.BodyLen)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuint8* data = *r_data;</span><br><span class=\"line\">\t<span class=\"comment\">// current_msg-&gt;body = data;</span></span><br><span class=\"line\">\tCurrentMsg-&gt;Body.Result = (*data) == <span class=\"number\">1</span>;</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\">\tCurrentMsg-&gt;Body.MsgId = *(int32*)data;</span><br><span class=\"line\">\tdata += <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ((CurrentMsg-&gt;Header.BodyLen - <span class=\"number\">5</span>) / <span class=\"keyword\">sizeof</span>(int32)); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tCurrentMsg-&gt;Body.DataArray.Add(*(int32*)data);</span><br><span class=\"line\">\t\tdata += <span class=\"number\">4</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t*reserved_len -= CurrentMsg-&gt;Header.BodyLen;</span><br><span class=\"line\">\t*parse_len += CurrentMsg-&gt;Header.BodyLen;</span><br><span class=\"line\">\t*r_data += CurrentMsg-&gt;Header.BodyLen;</span><br><span class=\"line\"></span><br><span class=\"line\">\tParseStatus = ParseStatus::PARSE_INIT;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数据获取\"><a href=\"#数据获取\" class=\"headerlink\" title=\"数据获取\"></a>数据获取</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// h</span></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">    <span class=\"function\">FProtoMsg <span class=\"title\">Front</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">    <span class=\"function\">TArray&lt;FProtoMsg&gt; <span class=\"title\">PopBackAllMsg</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::IsEmpty</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MsgArray.Num() == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">FProtoMsg <span class=\"title\">AGameNetwork::Front</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MsgArray.Top();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AGameNetwork::Pop</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// MsgArray.Pop();</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TArray&lt;FProtoMsg&gt; <span class=\"title\">AGameNetwork::PopBackAllMsg</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tTArray&lt;FProtoMsg&gt; MsgArrayTemp = MsgArray;</span><br><span class=\"line\">\tMsgArray.Empty();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MsgArrayTemp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"完整代码-继承自GameStateBase\"><a href=\"#完整代码-继承自GameStateBase\" class=\"headerlink\" title=\"完整代码-继承自GameStateBase\"></a>完整代码-继承自GameStateBase</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"CoreMinimal.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"GameFramework/GameStateBase.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Networking.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"GameNetwork.generated.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">UENUM(BlueprintType)</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FMsgType</span>:</span>uint8</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tEROOM_ENTER,</span><br><span class=\"line\">\tEROOM_EXIT,</span><br><span class=\"line\">\tEPLAYER_READY,</span><br><span class=\"line\">\tEPLAYER_CANCEL_READY,</span><br><span class=\"line\">\tEGAME_START,</span><br><span class=\"line\">\tEROOM_PLAY_DATA,</span><br><span class=\"line\">\tEGAME_OVER</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">UENUM(BlueprintType)</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FMsgVersion</span> :</span>uint8</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVERSION0 = <span class=\"number\">0</span>,</span><br><span class=\"line\">\tVERSION1 = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">USTRUCT(BlueprintType)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FProtoHead</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tGENERATED_BODY()</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\tFMsgType MsgType;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\t\tFMsgVersion MsgVer;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\t\tint32 BodyLen;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">USTRUCT(BlueprintType)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FProtoBody</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tGENERATED_BODY()</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">bool</span> Result;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\t\tint32 MsgId;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\t\tTArray&lt;int32&gt; DataArray;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">USTRUCT(BlueprintType)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FProtoMsg</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tGENERATED_BODY()</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\t\tFProtoHead Header;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\t\tFProtoBody Body;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">UCLASS()</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PACMAN_API</span> <span class=\"title\">AGameNetwork</span> :</span> <span class=\"keyword\">public</span> AGameStateBase</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tGENERATED_BODY()</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tUFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">CreateSocket</span><span class=\"params\">(<span class=\"keyword\">const</span> FString IPStr, int32 Port)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SendMsg</span><span class=\"params\">(FProtoMsg Msg)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">RecvMsg</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">\t\t<span class=\"function\">FProtoMsg <span class=\"title\">Front</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">\t\t<span class=\"function\">TArray&lt;FProtoMsg&gt; <span class=\"title\">PopBackAllMsg</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFIPv4Address Ip;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFSocket* ClientFd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParseStatus</span></span></span><br><span class=\"line\"><span class=\"class\">\t&#123;</span></span><br><span class=\"line\">\t\tPARSE_INIT,</span><br><span class=\"line\">\t\tPARSE_HEAD,</span><br><span class=\"line\">\t\tPARSE_BODY</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Decode</span><span class=\"params\">(uint8* data, int32 len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">uint8* <span class=\"title\">Encode</span><span class=\"params\">(FProtoMsg Msg, int32* Len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> HEADER_SIZE = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTArray&lt;uint8&gt; ReservedData;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFProtoMsg* CurrentMsg;</span><br><span class=\"line\"></span><br><span class=\"line\">\tParseStatus ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTArray&lt;FProtoMsg&gt; MsgArray;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ParseHeader</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ParseBody</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"GameNetwork.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::CreateSocket</span><span class=\"params\">(<span class=\"keyword\">const</span> FString IPStr, int32 Port)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将字符串ip转换为点分十进制ip</span></span><br><span class=\"line\">\tFIPv4Address::Parse(IPStr, Ip);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 将十进制ip 转化成网络地址</span></span><br><span class=\"line\">\tTSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();</span><br><span class=\"line\">\taddr-&gt;SetIp(Ip.Value);</span><br><span class=\"line\">\taddr-&gt;SetPort(Port);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建TCP Socket 文件描述符</span></span><br><span class=\"line\">\tClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class=\"string\">\"TCP SOCKET\"</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ClientFd-&gt;Connect(*addr))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::SendMsg</span><span class=\"params\">(FProtoMsg Msg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Len;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Send;</span><br><span class=\"line\">\tuint8* data;</span><br><span class=\"line\">\tdata = Encode(Msg, &amp;Len);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ClientFd-&gt;Send(data, Len, Send))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::RecvMsg</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ClientFd != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tuint8 Buffer[<span class=\"number\">1024</span>]&#123;&#125;;</span><br><span class=\"line\">\t\tuint32 Size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tint32 Read = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (ClientFd-&gt;HasPendingData(Size))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tClientFd-&gt;Recv(Buffer, <span class=\"number\">1024</span>, Read);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Decode(Buffer, Read);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::Decode</span><span class=\"params\">(uint8* data, int32 len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 防止沾包 直接将受到的数据全部按顺序存储</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int32 i = <span class=\"number\">0</span>; i &lt; len; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tReservedData.Push(data[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tint32 r_len = ReservedData.Num();</span><br><span class=\"line\">\tuint8* r_data = ReservedData.GetData();</span><br><span class=\"line\">\tint32 parse_len = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (r_len &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (ParseStatus)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> ParseStatus::PARSE_INIT:</span><br><span class=\"line\">\t\t\tCurrentMsg = <span class=\"keyword\">new</span> FProtoMsg();</span><br><span class=\"line\">\t\t\tParseStatus = ParseStatus::PARSE_HEAD;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> ParseStatus::PARSE_HEAD:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!ParseHeader(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> ParseStatus::PARSE_BODY:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!ParseBody(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (CurrentMsg != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tMsgArray.Push(*CurrentMsg);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tCurrentMsg = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int32 i = <span class=\"number\">0</span>; i &lt; parse_len; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tReservedData.Pop();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">uint8* <span class=\"title\">AGameNetwork::Encode</span><span class=\"params\">(FProtoMsg Msg, int32* Len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tMsg.Header.BodyLen = Msg.Body.DataArray.Num() * Msg.Body.DataArray.GetTypeSize() + <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*Len = Msg.Header.BodyLen + HEADER_SIZE;</span><br><span class=\"line\">\t<span class=\"comment\">// HEADER</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span>* data = <span class=\"keyword\">new</span> <span class=\"keyword\">uint8_t</span>[*Len];</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, *Len);</span><br><span class=\"line\"></span><br><span class=\"line\">\t*data = (uint8)Msg.Header.MsgType;</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*data = (uint8)Msg.Header.MsgVer;</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*(<span class=\"keyword\">uint32_t</span>*)data = Msg.Header.BodyLen;</span><br><span class=\"line\">\tdata += <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// BODY</span></span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\">\t*(<span class=\"keyword\">uint32_t</span>*)data = Msg.Body.MsgId;</span><br><span class=\"line\">\tdata += <span class=\"number\">4</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(data, Msg.Body.DataArray.GetData(), Msg.Header.BodyLen - <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 回退增加的部分</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> data - HEADER_SIZE - <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::ParseHeader</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*reserved_len &lt; HEADER_SIZE)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuint8* data = *r_data;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCurrentMsg-&gt;Header.MsgType = StaticCast&lt;FMsgType&gt;(*data);</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCurrentMsg-&gt;Header.MsgVer = StaticCast&lt;FMsgVersion&gt;(*data);</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCurrentMsg-&gt;Header.BodyLen = *(uint32*)data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*reserved_len -= HEADER_SIZE;</span><br><span class=\"line\">\t*parse_len += HEADER_SIZE;</span><br><span class=\"line\">\t*r_data += HEADER_SIZE;</span><br><span class=\"line\"></span><br><span class=\"line\">\tParseStatus = ParseStatus::PARSE_BODY;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::ParseBody</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*reserved_len &lt; CurrentMsg-&gt;Header.BodyLen)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuint8* data = *r_data;</span><br><span class=\"line\">\t<span class=\"comment\">// current_msg-&gt;body = data;</span></span><br><span class=\"line\">\tCurrentMsg-&gt;Body.Result = (*data) == <span class=\"number\">1</span>;</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\">\tCurrentMsg-&gt;Body.MsgId = *(int32*)data;</span><br><span class=\"line\">\tdata += <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ((CurrentMsg-&gt;Header.BodyLen - <span class=\"number\">5</span>) / <span class=\"keyword\">sizeof</span>(int32)); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tCurrentMsg-&gt;Body.DataArray.Add(*(int32*)data);</span><br><span class=\"line\">\t\tdata += <span class=\"number\">4</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t*reserved_len -= CurrentMsg-&gt;Header.BodyLen;</span><br><span class=\"line\">\t*parse_len += CurrentMsg-&gt;Header.BodyLen;</span><br><span class=\"line\">\t*r_data += CurrentMsg-&gt;Header.BodyLen;</span><br><span class=\"line\"></span><br><span class=\"line\">\tParseStatus = ParseStatus::PARSE_INIT;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::IsEmpty</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MsgArray.Num() == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">FProtoMsg <span class=\"title\">AGameNetwork::Front</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MsgArray.Top();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AGameNetwork::Pop</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// MsgArray.Pop();</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TArray&lt;FProtoMsg&gt; <span class=\"title\">AGameNetwork::PopBackAllMsg</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tTArray&lt;FProtoMsg&gt; MsgArrayTemp = MsgArray;</span><br><span class=\"line\">\tMsgArray.Empty();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MsgArrayTemp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>记录一下UE4 Tcp传输数据的客户端代码<br>方便日后使用</p>\n<h1 id=\"头文件\"><a href=\"#头文件\" class=\"headerlink\" title=\"头文件\"></a>头文件</h1><p>#include “Networking.h”</p>\n<p>// 添加 Networking 和 Sockets<br>PublicDependencyModuleNames.AddRange(new string[] { “Core”, “CoreUObject”, “Engine”, “InputCore”, “Networking”, “Sockets”});</p>\n<h1 id=\"用到的数据结构\"><a href=\"#用到的数据结构\" class=\"headerlink\" title=\"用到的数据结构\"></a>用到的数据结构</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UENUM(BlueprintType)</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FMsgType</span>:</span>uint8</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tEROOM_ENTER,</span><br><span class=\"line\">\tEROOM_EXIT,</span><br><span class=\"line\">\tEPLAYER_READY,</span><br><span class=\"line\">\tEPLAYER_CANCEL_READY,</span><br><span class=\"line\">\tEGAME_START,</span><br><span class=\"line\">\tEROOM_PLAY_DATA,</span><br><span class=\"line\">\tEGAME_OVER</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">UENUM(BlueprintType)</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FMsgVersion</span> :</span>uint8</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVERSION0 = <span class=\"number\">0</span>,</span><br><span class=\"line\">\tVERSION1 = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">USTRUCT(BlueprintType)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FProtoHead</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tGENERATED_BODY()</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\tFMsgType MsgType;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">    FMsgVersion MsgVer;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">    int32 BodyLen;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">USTRUCT(BlueprintType)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FProtoBody</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tGENERATED_BODY()</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> Result;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">    int32 MsgId;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">    TArray&lt;int32&gt; DataArray;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">USTRUCT(BlueprintType)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FProtoMsg</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tGENERATED_BODY()</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">    FProtoHead Header;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">    FProtoBody Body;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"socket管理\"><a href=\"#socket管理\" class=\"headerlink\" title=\"socket管理\"></a>socket管理</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// h</span></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">CreateSocket</span><span class=\"params\">(<span class=\"keyword\">const</span> FString IPStr, int32 Port)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">FIPv4Address Ip;</span><br><span class=\"line\">FSocket* ClientFd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::CreateSocket</span><span class=\"params\">(<span class=\"keyword\">const</span> FString IPStr, int32 Port)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将字符串ip转换为点分十进制ip</span></span><br><span class=\"line\">    FIPv4Address::Parse(IPStr, Ip);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将十进制ip 转化成网络地址</span></span><br><span class=\"line\">    TSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();</span><br><span class=\"line\">    addr-&gt;SetIp(Ip.Value);</span><br><span class=\"line\">    addr-&gt;SetPort(Port);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建TCP Socket 文件描述符</span></span><br><span class=\"line\">    ClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class=\"string\">\"TCP SOCKET\"</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ClientFd-&gt;Connect(*addr))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数据发送和接收\"><a href=\"#数据发送和接收\" class=\"headerlink\" title=\"数据发送和接收\"></a>数据发送和接收</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// h</span></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SendMsg</span><span class=\"params\">(FProtoMsg Msg)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">RecvMsg</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::SendMsg</span><span class=\"params\">(FProtoMsg Msg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Len;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Send;</span><br><span class=\"line\">\tuint8* data;</span><br><span class=\"line\">\tdata = Encode(Msg, &amp;Len);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ClientFd-&gt;Send(data, Len, Send))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::RecvMsg</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ClientFd != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tuint8 Buffer[<span class=\"number\">1024</span>]&#123;&#125;;</span><br><span class=\"line\">\t\tuint32 Size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tint32 Read = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (ClientFd-&gt;HasPendingData(Size))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tClientFd-&gt;Recv(Buffer, <span class=\"number\">1024</span>, Read);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Decode(Buffer, Read);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数据序列化\"><a href=\"#数据序列化\" class=\"headerlink\" title=\"数据序列化\"></a>数据序列化</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// h</span></span><br><span class=\"line\"><span class=\"function\">uint8* <span class=\"title\">Encode</span><span class=\"params\">(FProtoMsg Msg, int32* Len)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> HEADER_SIZE = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cpp</span></span><br><span class=\"line\"><span class=\"function\">uint8* <span class=\"title\">AGameNetwork::Encode</span><span class=\"params\">(FProtoMsg Msg, int32* Len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tMsg.Header.BodyLen = Msg.Body.DataArray.Num() * Msg.Body.DataArray.GetTypeSize() + <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*Len = Msg.Header.BodyLen + HEADER_SIZE;</span><br><span class=\"line\">\t<span class=\"comment\">// HEADER</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> data = <span class=\"keyword\">new</span> <span class=\"keyword\">uint8_t</span>[*Len];</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> pdata = data;</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, *Len);</span><br><span class=\"line\"></span><br><span class=\"line\">\t*pdata = (uint8)Msg.Header.MsgType;</span><br><span class=\"line\">\tpdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*pdata = (uint8)Msg.Header.MsgVer;</span><br><span class=\"line\">\tpdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*(<span class=\"keyword\">uint32_t</span>*)pdata = Msg.Header.BodyLen;</span><br><span class=\"line\">\tpdata += <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// BODY</span></span><br><span class=\"line\">\tpdata++;</span><br><span class=\"line\">\t*(<span class=\"keyword\">uint32_t</span>*)pdata = Msg.Body.MsgId;</span><br><span class=\"line\">\tpdata += <span class=\"number\">4</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(pdata, Msg.Body.DataArray.GetData(), Msg.Header.BodyLen - <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数据反序列化\"><a href=\"#数据反序列化\" class=\"headerlink\" title=\"数据反序列化\"></a>数据反序列化</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// h</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Decode</span><span class=\"params\">(uint8* data, int32 len)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ParseHeader</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ParseBody</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParseStatus</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    PARSE_INIT,</span><br><span class=\"line\">    PARSE_HEAD,</span><br><span class=\"line\">    PARSE_BODY</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">TArray&lt;uint8&gt; ReservedData;</span><br><span class=\"line\">FProtoMsg* CurrentMsg;</span><br><span class=\"line\">ParseStatus ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class=\"line\">TArray&lt;FProtoMsg&gt; MsgArray;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::Decode</span><span class=\"params\">(uint8* data, int32 len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 防止沾包 直接将受到的数据全部按顺序存储</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int32 i = <span class=\"number\">0</span>; i &lt; len; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tReservedData.Push(data[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tint32 r_len = ReservedData.Num();</span><br><span class=\"line\">\tuint8* r_data = ReservedData.GetData();</span><br><span class=\"line\">\tint32 parse_len = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (r_len &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (ParseStatus)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> ParseStatus::PARSE_INIT:</span><br><span class=\"line\">\t\t\tCurrentMsg = <span class=\"keyword\">new</span> FProtoMsg();</span><br><span class=\"line\">\t\t\tParseStatus = ParseStatus::PARSE_HEAD;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> ParseStatus::PARSE_HEAD:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!ParseHeader(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> ParseStatus::PARSE_BODY:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!ParseBody(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (CurrentMsg != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tMsgArray.Push(*CurrentMsg);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tCurrentMsg = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int32 i = <span class=\"number\">0</span>; i &lt; parse_len; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tReservedData.Pop();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::ParseHeader</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*reserved_len &lt; HEADER_SIZE)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuint8* data = *r_data;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCurrentMsg-&gt;Header.MsgType = StaticCast&lt;FMsgType&gt;(*data);</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCurrentMsg-&gt;Header.MsgVer = StaticCast&lt;FMsgVersion&gt;(*data);</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCurrentMsg-&gt;Header.BodyLen = *(uint32*)data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*reserved_len -= HEADER_SIZE;</span><br><span class=\"line\">\t*parse_len += HEADER_SIZE;</span><br><span class=\"line\">\t*r_data += HEADER_SIZE;</span><br><span class=\"line\"></span><br><span class=\"line\">\tParseStatus = ParseStatus::PARSE_BODY;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::ParseBody</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*reserved_len &lt; CurrentMsg-&gt;Header.BodyLen)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuint8* data = *r_data;</span><br><span class=\"line\">\t<span class=\"comment\">// current_msg-&gt;body = data;</span></span><br><span class=\"line\">\tCurrentMsg-&gt;Body.Result = (*data) == <span class=\"number\">1</span>;</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\">\tCurrentMsg-&gt;Body.MsgId = *(int32*)data;</span><br><span class=\"line\">\tdata += <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ((CurrentMsg-&gt;Header.BodyLen - <span class=\"number\">5</span>) / <span class=\"keyword\">sizeof</span>(int32)); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tCurrentMsg-&gt;Body.DataArray.Add(*(int32*)data);</span><br><span class=\"line\">\t\tdata += <span class=\"number\">4</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t*reserved_len -= CurrentMsg-&gt;Header.BodyLen;</span><br><span class=\"line\">\t*parse_len += CurrentMsg-&gt;Header.BodyLen;</span><br><span class=\"line\">\t*r_data += CurrentMsg-&gt;Header.BodyLen;</span><br><span class=\"line\"></span><br><span class=\"line\">\tParseStatus = ParseStatus::PARSE_INIT;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"数据获取\"><a href=\"#数据获取\" class=\"headerlink\" title=\"数据获取\"></a>数据获取</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// h</span></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">    <span class=\"function\">FProtoMsg <span class=\"title\">Front</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">    <span class=\"function\">TArray&lt;FProtoMsg&gt; <span class=\"title\">PopBackAllMsg</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::IsEmpty</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MsgArray.Num() == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">FProtoMsg <span class=\"title\">AGameNetwork::Front</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MsgArray.Top();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AGameNetwork::Pop</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// MsgArray.Pop();</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TArray&lt;FProtoMsg&gt; <span class=\"title\">AGameNetwork::PopBackAllMsg</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tTArray&lt;FProtoMsg&gt; MsgArrayTemp = MsgArray;</span><br><span class=\"line\">\tMsgArray.Empty();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MsgArrayTemp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"完整代码-继承自GameStateBase\"><a href=\"#完整代码-继承自GameStateBase\" class=\"headerlink\" title=\"完整代码-继承自GameStateBase\"></a>完整代码-继承自GameStateBase</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> once</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"CoreMinimal.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"GameFramework/GameStateBase.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"Networking.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"GameNetwork.generated.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">UENUM(BlueprintType)</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FMsgType</span>:</span>uint8</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tEROOM_ENTER,</span><br><span class=\"line\">\tEROOM_EXIT,</span><br><span class=\"line\">\tEPLAYER_READY,</span><br><span class=\"line\">\tEPLAYER_CANCEL_READY,</span><br><span class=\"line\">\tEGAME_START,</span><br><span class=\"line\">\tEROOM_PLAY_DATA,</span><br><span class=\"line\">\tEGAME_OVER</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">UENUM(BlueprintType)</span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FMsgVersion</span> :</span>uint8</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tVERSION0 = <span class=\"number\">0</span>,</span><br><span class=\"line\">\tVERSION1 = <span class=\"number\">1</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">USTRUCT(BlueprintType)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FProtoHead</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tGENERATED_BODY()</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\tFMsgType MsgType;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\t\tFMsgVersion MsgVer;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\t\tint32 BodyLen;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">USTRUCT(BlueprintType)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FProtoBody</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tGENERATED_BODY()</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">bool</span> Result;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\t\tint32 MsgId;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\t\tTArray&lt;int32&gt; DataArray;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">USTRUCT(BlueprintType)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">FProtoMsg</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tGENERATED_BODY()</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\t\tFProtoHead Header;</span><br><span class=\"line\">\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = <span class=\"string\">\"Mantra\"</span>)</span><br><span class=\"line\">\t\tFProtoBody Body;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">UCLASS()</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PACMAN_API</span> <span class=\"title\">AGameNetwork</span> :</span> <span class=\"keyword\">public</span> AGameStateBase</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tGENERATED_BODY()</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\tUFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">CreateSocket</span><span class=\"params\">(<span class=\"keyword\">const</span> FString IPStr, int32 Port)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SendMsg</span><span class=\"params\">(FProtoMsg Msg)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">RecvMsg</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">\t\t<span class=\"function\">FProtoMsg <span class=\"title\">Front</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Pop</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tUFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\">\t\t<span class=\"function\">TArray&lt;FProtoMsg&gt; <span class=\"title\">PopBackAllMsg</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFIPv4Address Ip;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFSocket* ClientFd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">enum</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParseStatus</span></span></span><br><span class=\"line\"><span class=\"class\">\t&#123;</span></span><br><span class=\"line\">\t\tPARSE_INIT,</span><br><span class=\"line\">\t\tPARSE_HEAD,</span><br><span class=\"line\">\t\tPARSE_BODY</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Decode</span><span class=\"params\">(uint8* data, int32 len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\">uint8* <span class=\"title\">Encode</span><span class=\"params\">(FProtoMsg Msg, int32* Len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> HEADER_SIZE = <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTArray&lt;uint8&gt; ReservedData;</span><br><span class=\"line\"></span><br><span class=\"line\">\tFProtoMsg* CurrentMsg;</span><br><span class=\"line\"></span><br><span class=\"line\">\tParseStatus ParseStatus = ParseStatus::PARSE_INIT;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTArray&lt;FProtoMsg&gt; MsgArray;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ParseHeader</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ParseBody</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fill out your copyright notice in the Description page of Project Settings.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"GameNetwork.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::CreateSocket</span><span class=\"params\">(<span class=\"keyword\">const</span> FString IPStr, int32 Port)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将字符串ip转换为点分十进制ip</span></span><br><span class=\"line\">\tFIPv4Address::Parse(IPStr, Ip);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 将十进制ip 转化成网络地址</span></span><br><span class=\"line\">\tTSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();</span><br><span class=\"line\">\taddr-&gt;SetIp(Ip.Value);</span><br><span class=\"line\">\taddr-&gt;SetPort(Port);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建TCP Socket 文件描述符</span></span><br><span class=\"line\">\tClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class=\"string\">\"TCP SOCKET\"</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ClientFd-&gt;Connect(*addr))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::SendMsg</span><span class=\"params\">(FProtoMsg Msg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Len;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> Send;</span><br><span class=\"line\">\tuint8* data;</span><br><span class=\"line\">\tdata = Encode(Msg, &amp;Len);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ClientFd-&gt;Send(data, Len, Send))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::RecvMsg</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ClientFd != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tuint8 Buffer[<span class=\"number\">1024</span>]&#123;&#125;;</span><br><span class=\"line\">\t\tuint32 Size = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tint32 Read = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (ClientFd-&gt;HasPendingData(Size))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tClientFd-&gt;Recv(Buffer, <span class=\"number\">1024</span>, Read);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> Decode(Buffer, Read);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::Decode</span><span class=\"params\">(uint8* data, int32 len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 防止沾包 直接将受到的数据全部按顺序存储</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int32 i = <span class=\"number\">0</span>; i &lt; len; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tReservedData.Push(data[i]);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tint32 r_len = ReservedData.Num();</span><br><span class=\"line\">\tuint8* r_data = ReservedData.GetData();</span><br><span class=\"line\">\tint32 parse_len = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (r_len &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span> (ParseStatus)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> ParseStatus::PARSE_INIT:</span><br><span class=\"line\">\t\t\tCurrentMsg = <span class=\"keyword\">new</span> FProtoMsg();</span><br><span class=\"line\">\t\t\tParseStatus = ParseStatus::PARSE_HEAD;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> ParseStatus::PARSE_HEAD:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!ParseHeader(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> ParseStatus::PARSE_BODY:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (!ParseBody(&amp;r_data, &amp;r_len, &amp;parse_len))</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (CurrentMsg != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\tMsgArray.Push(*CurrentMsg);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tCurrentMsg = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (int32 i = <span class=\"number\">0</span>; i &lt; parse_len; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tReservedData.Pop();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">uint8* <span class=\"title\">AGameNetwork::Encode</span><span class=\"params\">(FProtoMsg Msg, int32* Len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tMsg.Header.BodyLen = Msg.Body.DataArray.Num() * Msg.Body.DataArray.GetTypeSize() + <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*Len = Msg.Header.BodyLen + HEADER_SIZE;</span><br><span class=\"line\">\t<span class=\"comment\">// HEADER</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span>* data = <span class=\"keyword\">new</span> <span class=\"keyword\">uint8_t</span>[*Len];</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(data, <span class=\"number\">0</span>, *Len);</span><br><span class=\"line\"></span><br><span class=\"line\">\t*data = (uint8)Msg.Header.MsgType;</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*data = (uint8)Msg.Header.MsgVer;</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*(<span class=\"keyword\">uint32_t</span>*)data = Msg.Header.BodyLen;</span><br><span class=\"line\">\tdata += <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// BODY</span></span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\">\t*(<span class=\"keyword\">uint32_t</span>*)data = Msg.Body.MsgId;</span><br><span class=\"line\">\tdata += <span class=\"number\">4</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span>(data, Msg.Body.DataArray.GetData(), Msg.Header.BodyLen - <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 回退增加的部分</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> data - HEADER_SIZE - <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::ParseHeader</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*reserved_len &lt; HEADER_SIZE)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuint8* data = *r_data;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCurrentMsg-&gt;Header.MsgType = StaticCast&lt;FMsgType&gt;(*data);</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCurrentMsg-&gt;Header.MsgVer = StaticCast&lt;FMsgVersion&gt;(*data);</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\"></span><br><span class=\"line\">\tCurrentMsg-&gt;Header.BodyLen = *(uint32*)data;</span><br><span class=\"line\"></span><br><span class=\"line\">\t*reserved_len -= HEADER_SIZE;</span><br><span class=\"line\">\t*parse_len += HEADER_SIZE;</span><br><span class=\"line\">\t*r_data += HEADER_SIZE;</span><br><span class=\"line\"></span><br><span class=\"line\">\tParseStatus = ParseStatus::PARSE_BODY;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::ParseBody</span><span class=\"params\">(uint8** r_data, int32* reserved_len, int32* parse_len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (*reserved_len &lt; CurrentMsg-&gt;Header.BodyLen)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tuint8* data = *r_data;</span><br><span class=\"line\">\t<span class=\"comment\">// current_msg-&gt;body = data;</span></span><br><span class=\"line\">\tCurrentMsg-&gt;Body.Result = (*data) == <span class=\"number\">1</span>;</span><br><span class=\"line\">\tdata++;</span><br><span class=\"line\">\tCurrentMsg-&gt;Body.MsgId = *(int32*)data;</span><br><span class=\"line\">\tdata += <span class=\"number\">4</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; ((CurrentMsg-&gt;Header.BodyLen - <span class=\"number\">5</span>) / <span class=\"keyword\">sizeof</span>(int32)); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tCurrentMsg-&gt;Body.DataArray.Add(*(int32*)data);</span><br><span class=\"line\">\t\tdata += <span class=\"number\">4</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t*reserved_len -= CurrentMsg-&gt;Header.BodyLen;</span><br><span class=\"line\">\t*parse_len += CurrentMsg-&gt;Header.BodyLen;</span><br><span class=\"line\">\t*r_data += CurrentMsg-&gt;Header.BodyLen;</span><br><span class=\"line\"></span><br><span class=\"line\">\tParseStatus = ParseStatus::PARSE_INIT;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">AGameNetwork::IsEmpty</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MsgArray.Num() == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">FProtoMsg <span class=\"title\">AGameNetwork::Front</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MsgArray.Top();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">AGameNetwork::Pop</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// MsgArray.Pop();</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">TArray&lt;FProtoMsg&gt; <span class=\"title\">AGameNetwork::PopBackAllMsg</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tTArray&lt;FProtoMsg&gt; MsgArrayTemp = MsgArray;</span><br><span class=\"line\">\tMsgArray.Empty();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> MsgArrayTemp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"操作系统点带面","date":"2020-03-03T10:41:28.000Z","_content":"","source":"_posts/学习记录-操作系统点带面.md","raw":"---\ntitle: 操作系统点带面\ndate: 2020-03-03 18:41:28\ntags:\ncategories:\n - 学习记录\n---","slug":"学习记录-操作系统点带面","published":1,"updated":"2020-03-14T10:41:26.689Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvb001n8cuo0vz77kmc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分支管理和实际应用","date":"2020-03-06T11:34:25.000Z","_content":"\n2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄... 来更新下\n\n# 分支管理\n`git checkout -b dev`相当于一下两条命令\n`git branch dev` 分支创建\n`git checkout dev` 分支切换\n\n`git branch -d dev` 分支删除\n\n`git branch` 查看当前所有分支\n\n`git merge dev` 将制定的dev分支合并到当前的分支\n\n**冲突解决**\n`git merge dev` 将制定的dev分支合并到当前的分支\n```\n1 111111111111111\n2 222222222222222\n3 333333333333333\n4 444444444444444\n5 <<<<<<< HEAD  # 我在master分支下添加了6666666 并提交\n6 6666666\n7 =======\n8 7777777\n9 >>>>>>> deb # 我在deb分支下添加了7777777 并提交\n```\n最后需要我手动修改这个文件为自己需要的内容 然后提交即可\n  \n**分支管理**\n通常Git会使用`Fast forward`模式 这样删除分支后会丢失分支的信息\n可以再merge的时候加入`--no-ff`这样就能解决问题\n`git merge --no-ff -m \"merge with no-ff\" dev`\n由于禁用`Fast forward`后\n会生成新的commit所以需要加入` -m \"merge with no-ff\"`\n\ngit stash 可以储存当前的工作区 继续其他的工作\ngit stash list 查看储存的工作区列表\ngit stash apply stash@{0} 恢复指定的储存\ngit stash pop 恢复并drop最近的存储 慎用这个 建议使用上边的\n```\n$ cat test.txt # stash前\n111111\n$ vim test.txt \n$ cat test.txt # 进行了修改\n111111\n222222\n333333\n$ git status\n位于分支 master\n\t修改：     test.txt\n$ git stash # stash\n保存工作目录和索引状态 WIP on master: 854b710 1\n$ cat test.txt \n111111\n$ git status\n位于分支 master\n无文件要提交，干净的工作区\n$ git stash pop\n位于分支 master\n\t修改：     test.txt\n$ cat test.txt \n111111\n222222\n333333\n```\n  \n# 实际工作中分支的应用\n[主要参考](https://zhuanlan.zhihu.com/p/38772378)\n**主分支**\n- **master**: 这个分支最稳定, 相当于放的可发布版本\n- **develop**: 开发分支, 平行于master分支, 负责合并各种`用于开发子功能`的分支\n\n**支持分支**:解决某个问题, 结束后合并回`master`或`develop`分支\n- **feature**功能分支, 用于开发一个个子功能, 来自`develop`合并到`develop`去\n- **release**:发布分支, 用于修改版本号等小修改, 来自`develop`分支合并到`master`分支\n- **hotfixes**:紧急修复bug分支, 从`master`创建, 合并回`develop`分支和`master`分支\n![](https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg)\n\n\n[Git 分支管理规范](https://juejin.im/post/5d82e1f3e51d4561d044cd88#heading-14)\n\n[Git 基础 - 打标签](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE)\n\n**develop分支完成了操作, 准备发布新的版本**\n```shell\n# 从 develop 分支上创建 release 分支:\n# 命名规则如下 release-事件-版本\ngit checkout –b release-20190919-v1.0.0 develop\n\n# 修复完release的bug后再次提交修改:\ngit checkout release-20190919-v1.0.0\n# 提交本地修改, 如果没有修改bug 可以跳过\ngit add .\ngit commit –m “提交日志”\n# 推送 release 分支\ngit push origin release-20190919-v1.0.0\n\n# 发布新版本\n# 合并 release 分支到 master 分支:\ngit checkout master\ngit merge --no-ff release-20190919-v1.0.0\n# 合并 release 分支到 develop 分支:\ngit checkout develop\ngit merge --no-ff release-20190919-v1.0.0\n# 在 master 分支上创建标签:\ngit tag tag-20190919-v1.0.0\n# 删除本地 release 分支:\ngit branch –d release-20190919-v1.0.0\n# 删除远程 release 分支:\ngit push origin :release-20190919-v1.0.0\n```\n\n新版本完成之后\n```shell\n# 推送master分支\ngit push origin master\n\n# 注意上边打的tag需要手动提交 默认push不会提交tag\ngit push origin [tag name]\n# 也可以给push增加参数\ngit push origin --tags\n```\n\n# 本地和远程分支和tag的删除\n```shell\n# 本地\ngit tag -d xxx\ngit branch -d xxx\n\n# 远程\ngit push origin :refs/tags/xxx\ngit push origin :xxx\n```","source":"_posts/Git-分支管理和实际应用.md","raw":"---\ntitle: 分支管理和实际应用\ndate: 2020-03-06 19:34:25\ncategories: \n- 必备技能\n- Git操作\ntags:\n- Git操作\n---\n\n2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄... 来更新下\n\n# 分支管理\n`git checkout -b dev`相当于一下两条命令\n`git branch dev` 分支创建\n`git checkout dev` 分支切换\n\n`git branch -d dev` 分支删除\n\n`git branch` 查看当前所有分支\n\n`git merge dev` 将制定的dev分支合并到当前的分支\n\n**冲突解决**\n`git merge dev` 将制定的dev分支合并到当前的分支\n```\n1 111111111111111\n2 222222222222222\n3 333333333333333\n4 444444444444444\n5 <<<<<<< HEAD  # 我在master分支下添加了6666666 并提交\n6 6666666\n7 =======\n8 7777777\n9 >>>>>>> deb # 我在deb分支下添加了7777777 并提交\n```\n最后需要我手动修改这个文件为自己需要的内容 然后提交即可\n  \n**分支管理**\n通常Git会使用`Fast forward`模式 这样删除分支后会丢失分支的信息\n可以再merge的时候加入`--no-ff`这样就能解决问题\n`git merge --no-ff -m \"merge with no-ff\" dev`\n由于禁用`Fast forward`后\n会生成新的commit所以需要加入` -m \"merge with no-ff\"`\n\ngit stash 可以储存当前的工作区 继续其他的工作\ngit stash list 查看储存的工作区列表\ngit stash apply stash@{0} 恢复指定的储存\ngit stash pop 恢复并drop最近的存储 慎用这个 建议使用上边的\n```\n$ cat test.txt # stash前\n111111\n$ vim test.txt \n$ cat test.txt # 进行了修改\n111111\n222222\n333333\n$ git status\n位于分支 master\n\t修改：     test.txt\n$ git stash # stash\n保存工作目录和索引状态 WIP on master: 854b710 1\n$ cat test.txt \n111111\n$ git status\n位于分支 master\n无文件要提交，干净的工作区\n$ git stash pop\n位于分支 master\n\t修改：     test.txt\n$ cat test.txt \n111111\n222222\n333333\n```\n  \n# 实际工作中分支的应用\n[主要参考](https://zhuanlan.zhihu.com/p/38772378)\n**主分支**\n- **master**: 这个分支最稳定, 相当于放的可发布版本\n- **develop**: 开发分支, 平行于master分支, 负责合并各种`用于开发子功能`的分支\n\n**支持分支**:解决某个问题, 结束后合并回`master`或`develop`分支\n- **feature**功能分支, 用于开发一个个子功能, 来自`develop`合并到`develop`去\n- **release**:发布分支, 用于修改版本号等小修改, 来自`develop`分支合并到`master`分支\n- **hotfixes**:紧急修复bug分支, 从`master`创建, 合并回`develop`分支和`master`分支\n![](https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg)\n\n\n[Git 分支管理规范](https://juejin.im/post/5d82e1f3e51d4561d044cd88#heading-14)\n\n[Git 基础 - 打标签](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE)\n\n**develop分支完成了操作, 准备发布新的版本**\n```shell\n# 从 develop 分支上创建 release 分支:\n# 命名规则如下 release-事件-版本\ngit checkout –b release-20190919-v1.0.0 develop\n\n# 修复完release的bug后再次提交修改:\ngit checkout release-20190919-v1.0.0\n# 提交本地修改, 如果没有修改bug 可以跳过\ngit add .\ngit commit –m “提交日志”\n# 推送 release 分支\ngit push origin release-20190919-v1.0.0\n\n# 发布新版本\n# 合并 release 分支到 master 分支:\ngit checkout master\ngit merge --no-ff release-20190919-v1.0.0\n# 合并 release 分支到 develop 分支:\ngit checkout develop\ngit merge --no-ff release-20190919-v1.0.0\n# 在 master 分支上创建标签:\ngit tag tag-20190919-v1.0.0\n# 删除本地 release 分支:\ngit branch –d release-20190919-v1.0.0\n# 删除远程 release 分支:\ngit push origin :release-20190919-v1.0.0\n```\n\n新版本完成之后\n```shell\n# 推送master分支\ngit push origin master\n\n# 注意上边打的tag需要手动提交 默认push不会提交tag\ngit push origin [tag name]\n# 也可以给push增加参数\ngit push origin --tags\n```\n\n# 本地和远程分支和tag的删除\n```shell\n# 本地\ngit tag -d xxx\ngit branch -d xxx\n\n# 远程\ngit push origin :refs/tags/xxx\ngit push origin :xxx\n```","slug":"Git-分支管理和实际应用","published":1,"updated":"2020-03-12T07:48:44.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvc001q8cuocnno52bu","content":"<p>2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄… 来更新下</p>\n<h1 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h1><p><code>git checkout -b dev</code>相当于一下两条命令<br><code>git branch dev</code> 分支创建<br><code>git checkout dev</code> 分支切换</p>\n<p><code>git branch -d dev</code> 分支删除</p>\n<p><code>git branch</code> 查看当前所有分支</p>\n<p><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p>\n<p><strong>冲突解决</strong><br><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 111111111111111</span><br><span class=\"line\">2 222222222222222</span><br><span class=\"line\">3 333333333333333</span><br><span class=\"line\">4 444444444444444</span><br><span class=\"line\">5 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  # 我在master分支下添加了6666666 并提交</span><br><span class=\"line\">6 6666666</span><br><span class=\"line\">7 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">8 7777777</span><br><span class=\"line\">9 &gt;&gt;&gt;&gt;&gt;&gt;&gt; deb # 我在deb分支下添加了7777777 并提交</span><br></pre></td></tr></table></figure>\n<p>最后需要我手动修改这个文件为自己需要的内容 然后提交即可</p>\n<p><strong>分支管理</strong><br>通常Git会使用<code>Fast forward</code>模式 这样删除分支后会丢失分支的信息<br>可以再merge的时候加入<code>--no-ff</code>这样就能解决问题<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>由于禁用<code>Fast forward</code>后<br>会生成新的commit所以需要加入<code>-m &quot;merge with no-ff&quot;</code></p>\n<p>git stash 可以储存当前的工作区 继续其他的工作<br>git stash list 查看储存的工作区列表<br>git stash apply stash@{0} 恢复指定的储存<br>git stash pop 恢复并drop最近的存储 慎用这个 建议使用上边的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat test.txt # stash前</span><br><span class=\"line\">111111</span><br><span class=\"line\">$ vim test.txt </span><br><span class=\"line\">$ cat test.txt # 进行了修改</span><br><span class=\"line\">111111</span><br><span class=\"line\">222222</span><br><span class=\"line\">333333</span><br><span class=\"line\">$ git status</span><br><span class=\"line\">位于分支 master</span><br><span class=\"line\">\t修改：     test.txt</span><br><span class=\"line\">$ git stash # stash</span><br><span class=\"line\">保存工作目录和索引状态 WIP on master: 854b710 1</span><br><span class=\"line\">$ cat test.txt </span><br><span class=\"line\">111111</span><br><span class=\"line\">$ git status</span><br><span class=\"line\">位于分支 master</span><br><span class=\"line\">无文件要提交，干净的工作区</span><br><span class=\"line\">$ git stash pop</span><br><span class=\"line\">位于分支 master</span><br><span class=\"line\">\t修改：     test.txt</span><br><span class=\"line\">$ cat test.txt </span><br><span class=\"line\">111111</span><br><span class=\"line\">222222</span><br><span class=\"line\">333333</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"实际工作中分支的应用\"><a href=\"#实际工作中分支的应用\" class=\"headerlink\" title=\"实际工作中分支的应用\"></a>实际工作中分支的应用</h1><p><a href=\"https://zhuanlan.zhihu.com/p/38772378\" target=\"_blank\" rel=\"noopener\">主要参考</a><br><strong>主分支</strong></p>\n<ul>\n<li><strong>master</strong>: 这个分支最稳定, 相当于放的可发布版本</li>\n<li><strong>develop</strong>: 开发分支, 平行于master分支, 负责合并各种<code>用于开发子功能</code>的分支</li>\n</ul>\n<p><strong>支持分支</strong>:解决某个问题, 结束后合并回<code>master</code>或<code>develop</code>分支</p>\n<ul>\n<li><strong>feature</strong>功能分支, 用于开发一个个子功能, 来自<code>develop</code>合并到<code>develop</code>去</li>\n<li><strong>release</strong>:发布分支, 用于修改版本号等小修改, 来自<code>develop</code>分支合并到<code>master</code>分支</li>\n<li><strong>hotfixes</strong>:紧急修复bug分支, 从<code>master</code>创建, 合并回<code>develop</code>分支和<code>master</code>分支<br><img src=\"https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg\" alt=\"\"></li>\n</ul>\n<p><a href=\"https://juejin.im/post/5d82e1f3e51d4561d044cd88#heading-14\" target=\"_blank\" rel=\"noopener\">Git 分支管理规范</a></p>\n<p><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE\" target=\"_blank\" rel=\"noopener\">Git 基础 - 打标签</a></p>\n<p><strong>develop分支完成了操作, 准备发布新的版本</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 从 develop 分支上创建 release 分支:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 命名规则如下 release-事件-版本</span></span><br><span class=\"line\">git checkout –b release-20190919-v1.0.0 develop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 修复完release的bug后再次提交修改:</span></span><br><span class=\"line\">git checkout release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 提交本地修改, 如果没有修改bug 可以跳过</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit –m “提交日志”</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 推送 release 分支</span></span><br><span class=\"line\">git push origin release-20190919-v1.0.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 发布新版本</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 合并 release 分支到 master 分支:</span></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge --no-ff release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 合并 release 分支到 develop 分支:</span></span><br><span class=\"line\">git checkout develop</span><br><span class=\"line\">git merge --no-ff release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在 master 分支上创建标签:</span></span><br><span class=\"line\">git tag tag-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 删除本地 release 分支:</span></span><br><span class=\"line\">git branch –d release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 删除远程 release 分支:</span></span><br><span class=\"line\">git push origin :release-20190919-v1.0.0</span><br></pre></td></tr></table></figure>\n\n<p>新版本完成之后</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 推送master分支</span></span><br><span class=\"line\">git push origin master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意上边打的tag需要手动提交 默认push不会提交tag</span></span><br><span class=\"line\">git push origin [tag name]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 也可以给push增加参数</span></span><br><span class=\"line\">git push origin --tags</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"本地和远程分支和tag的删除\"><a href=\"#本地和远程分支和tag的删除\" class=\"headerlink\" title=\"本地和远程分支和tag的删除\"></a>本地和远程分支和tag的删除</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 本地</span></span><br><span class=\"line\">git tag -d xxx</span><br><span class=\"line\">git branch -d xxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 远程</span></span><br><span class=\"line\">git push origin :refs/tags/xxx</span><br><span class=\"line\">git push origin :xxx</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>2020年3月12日15:42:41 更新 实操了一次hotfix 惊心动魄… 来更新下</p>\n<h1 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h1><p><code>git checkout -b dev</code>相当于一下两条命令<br><code>git branch dev</code> 分支创建<br><code>git checkout dev</code> 分支切换</p>\n<p><code>git branch -d dev</code> 分支删除</p>\n<p><code>git branch</code> 查看当前所有分支</p>\n<p><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p>\n<p><strong>冲突解决</strong><br><code>git merge dev</code> 将制定的dev分支合并到当前的分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 111111111111111</span><br><span class=\"line\">2 222222222222222</span><br><span class=\"line\">3 333333333333333</span><br><span class=\"line\">4 444444444444444</span><br><span class=\"line\">5 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD  # 我在master分支下添加了6666666 并提交</span><br><span class=\"line\">6 6666666</span><br><span class=\"line\">7 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">8 7777777</span><br><span class=\"line\">9 &gt;&gt;&gt;&gt;&gt;&gt;&gt; deb # 我在deb分支下添加了7777777 并提交</span><br></pre></td></tr></table></figure>\n<p>最后需要我手动修改这个文件为自己需要的内容 然后提交即可</p>\n<p><strong>分支管理</strong><br>通常Git会使用<code>Fast forward</code>模式 这样删除分支后会丢失分支的信息<br>可以再merge的时候加入<code>--no-ff</code>这样就能解决问题<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>由于禁用<code>Fast forward</code>后<br>会生成新的commit所以需要加入<code>-m &quot;merge with no-ff&quot;</code></p>\n<p>git stash 可以储存当前的工作区 继续其他的工作<br>git stash list 查看储存的工作区列表<br>git stash apply stash@{0} 恢复指定的储存<br>git stash pop 恢复并drop最近的存储 慎用这个 建议使用上边的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cat test.txt # stash前</span><br><span class=\"line\">111111</span><br><span class=\"line\">$ vim test.txt </span><br><span class=\"line\">$ cat test.txt # 进行了修改</span><br><span class=\"line\">111111</span><br><span class=\"line\">222222</span><br><span class=\"line\">333333</span><br><span class=\"line\">$ git status</span><br><span class=\"line\">位于分支 master</span><br><span class=\"line\">\t修改：     test.txt</span><br><span class=\"line\">$ git stash # stash</span><br><span class=\"line\">保存工作目录和索引状态 WIP on master: 854b710 1</span><br><span class=\"line\">$ cat test.txt </span><br><span class=\"line\">111111</span><br><span class=\"line\">$ git status</span><br><span class=\"line\">位于分支 master</span><br><span class=\"line\">无文件要提交，干净的工作区</span><br><span class=\"line\">$ git stash pop</span><br><span class=\"line\">位于分支 master</span><br><span class=\"line\">\t修改：     test.txt</span><br><span class=\"line\">$ cat test.txt </span><br><span class=\"line\">111111</span><br><span class=\"line\">222222</span><br><span class=\"line\">333333</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"实际工作中分支的应用\"><a href=\"#实际工作中分支的应用\" class=\"headerlink\" title=\"实际工作中分支的应用\"></a>实际工作中分支的应用</h1><p><a href=\"https://zhuanlan.zhihu.com/p/38772378\" target=\"_blank\" rel=\"noopener\">主要参考</a><br><strong>主分支</strong></p>\n<ul>\n<li><strong>master</strong>: 这个分支最稳定, 相当于放的可发布版本</li>\n<li><strong>develop</strong>: 开发分支, 平行于master分支, 负责合并各种<code>用于开发子功能</code>的分支</li>\n</ul>\n<p><strong>支持分支</strong>:解决某个问题, 结束后合并回<code>master</code>或<code>develop</code>分支</p>\n<ul>\n<li><strong>feature</strong>功能分支, 用于开发一个个子功能, 来自<code>develop</code>合并到<code>develop</code>去</li>\n<li><strong>release</strong>:发布分支, 用于修改版本号等小修改, 来自<code>develop</code>分支合并到<code>master</code>分支</li>\n<li><strong>hotfixes</strong>:紧急修复bug分支, 从<code>master</code>创建, 合并回<code>develop</code>分支和<code>master</code>分支<br><img src=\"https://pic4.zhimg.com/80/v2-aef704a4c112eaaf5e8637587ee17df3_hd.jpg\" alt=\"\"></li>\n</ul>\n<p><a href=\"https://juejin.im/post/5d82e1f3e51d4561d044cd88#heading-14\" target=\"_blank\" rel=\"noopener\">Git 分支管理规范</a></p>\n<p><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE\" target=\"_blank\" rel=\"noopener\">Git 基础 - 打标签</a></p>\n<p><strong>develop分支完成了操作, 准备发布新的版本</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 从 develop 分支上创建 release 分支:</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 命名规则如下 release-事件-版本</span></span><br><span class=\"line\">git checkout –b release-20190919-v1.0.0 develop</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 修复完release的bug后再次提交修改:</span></span><br><span class=\"line\">git checkout release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 提交本地修改, 如果没有修改bug 可以跳过</span></span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit –m “提交日志”</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 推送 release 分支</span></span><br><span class=\"line\">git push origin release-20190919-v1.0.0</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 发布新版本</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 合并 release 分支到 master 分支:</span></span><br><span class=\"line\">git checkout master</span><br><span class=\"line\">git merge --no-ff release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 合并 release 分支到 develop 分支:</span></span><br><span class=\"line\">git checkout develop</span><br><span class=\"line\">git merge --no-ff release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 在 master 分支上创建标签:</span></span><br><span class=\"line\">git tag tag-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 删除本地 release 分支:</span></span><br><span class=\"line\">git branch –d release-20190919-v1.0.0</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 删除远程 release 分支:</span></span><br><span class=\"line\">git push origin :release-20190919-v1.0.0</span><br></pre></td></tr></table></figure>\n\n<p>新版本完成之后</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 推送master分支</span></span><br><span class=\"line\">git push origin master</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 注意上边打的tag需要手动提交 默认push不会提交tag</span></span><br><span class=\"line\">git push origin [tag name]</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 也可以给push增加参数</span></span><br><span class=\"line\">git push origin --tags</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"本地和远程分支和tag的删除\"><a href=\"#本地和远程分支和tag的删除\" class=\"headerlink\" title=\"本地和远程分支和tag的删除\"></a>本地和远程分支和tag的删除</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 本地</span></span><br><span class=\"line\">git tag -d xxx</span><br><span class=\"line\">git branch -d xxx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 远程</span></span><br><span class=\"line\">git push origin :refs/tags/xxx</span><br><span class=\"line\">git push origin :xxx</span><br></pre></td></tr></table></figure>"},{"title":"暑假学习记录与总结","date":"2019-07-13T04:13:22.000Z","_content":"<div class=\"alert-red\">では、ゲームを始(はじ)めましょう</div>\n\n自己与研究生无缘了, 不过嘛, 是好是坏我也不知道, 现在也只能多学点技术, 去工作了, 这个暑假很重要, 所以将会每天记录下.\n\n[在线图床](https://imgurl.org/)\n[设计模式主要学习](https://blog.csdn.net/lovelion/article/details/17517213)\n设计模式次要补充 -- head first java 设计模式\n\n<!--more-->\n## 总结\n\n![](暑假学习记录与总结/4.png)\n总结一下这个暑假都干了什么, 马上就要开学了.\n七月十三日到七月十九日, 这是第一周了.这一周伴随着到处参观, 收货很少了. 那时我还在主用Java, 主要的是学习了一些设计模式, 这一周的时间对我学习C++ 帮助也是有的. 暑假学习设计模式也是出于换语言的考虑. \n第一天(七月十三日)可以说是看的最多的了解了什么是耦合和解耦, 一些简单的设计模式(简单工厂, 工厂方法, 抽象工厂, 单例模式). \n第二天(七月十四日) 开始初步试验大创项目的实现, 当时遇到一个BUG, 我需要返回一个东西, 但我还是需要返回后将他删除, 首先就是将他”复制了一份”, 然后删除, 却发现返回去的都是空的,了解到了Java如何进行深拷贝.\n七月十六日看了下Java编程思想的多态部分, 然后主要时间修改网络助手的开机启动设置, 这样开机启动设置就没有问题了.\n七月十七日收拾家伙, 休息了休息准备回家, 结果虽然我确认了好几次自己有没有带全家伙, 鼠标笔记本都带上了,\n七月十八日到达北京去我姐那里暂住了, 结果发现我…..光带回了一个鼠标, 鼠标的接收器还在USB分线器上(吐血) 然后开始了一个开源项目的阅读. 云收藏(SpringBoot框架). 发现了自己没有看懂的东西(Stirng ...), 就去了解下JDK从5-8每次更新加入的内容,了解到那个叫做可变参数需要搭配增强for循环使用\n七月十九日-七月二十日我终于实现了自己理想….怎么说呢北方最大的漫展依然没有我想象的大, 等我有机会既定要去一次南方\n\n七月二十一日到七月二十七日写了个后端练手(一个失物招领) . 使用了丝袜哥写Api文档, SpringJpa作为持久层? 这几天放松了玩了几天游戏可惜了.\n七月二十八日总结两个小项目比较靠近项目的地方, 统一返回类型, 预定义数据, SpringJpa.\n.学习了 接口 内部类 持有对象. 通过查看源码解决了一个Bug,\n七月二十九日到八月二日 编写二手交易后台.\n\n想去了解下大数据相关内容\n八月三日到八月九日 看了下关于大数据的内容, 并不是很感兴趣.\n八月十日到八月十五日 主要是写算法题目, 然后寻找自己是佛要从事游戏服务器编程\n八月十六日到八月二十四日 上午复习高数, 下午看C++\n@2019年8月24日18:21:07@\n\n\n## 大纲\n设计模式不求多, 但求会用, 极大概率调整设计模式的学习.\n此外需要刷一些常用的算法\n\n```\n7.13-7.19\n<复用类, 多态>\n---六个创建型模式\n- 简单工厂模式\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n- 原型模式(略过)\n- 建造者模式(略过)\n7.20-7.26\n<接口, 内部类, 持有对象>\n---七个结构型模式\n- 适配器模式\n- 桥接模式\n- 组合模式\n- 外观模式\n7.27-8.02\n<类型信息, 泛型>\n- 装饰模式\n- 享元模式(略过)\n- 代理模式\n8.03-8.09\n<数组, 容器深入研究>\n---十一个行为型模式\n- 职责链模式\n- 命令模式\n- 解释器模式(略过)\n- 迭代器模式\n- 中介者模式(略过)\n- 备忘录模式(略过)\n- 观察者模式\n8.10-8.16\n<IO, 枚举类型>\n- 状态模式\n- 策略模式\n- 模板方法模式\n- 访问者模(略过)\n8.17-8.23\n<注解, 并发>\n\n```\n# では、ゲームを始(はじ)めましょう\n## 7.13-7.19\n```\n7.13-7.19\n<复用类, 多态>\n---六个创建型模式\n- 简单工厂模式\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n```\n### 7月13日\n\n```\n- 简单工厂模式\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n```\n\n2019年7月13日12:21:17\n上午参观参观参观...... 重置了下, 这个暑期表格.今天开始第一天的打卡.下午还有参观, 然后就可以开始学了\n\n下午有b站血族直播\n下午看了一个项目, 自己不会的还是太多,,,,,, 给了源码都看不太懂.\n还是先继续看几个设计模式吧, 设计模式目前想的是, 了解大概, 等到时用到了再去详细学习\n\n#### 耦合与解耦\n耦合: 两个或两个以上的体系之间互相结合, 互相影响, 产生的一个联合起来解决问题的体系.\n这种体系, 不利于修改, 修改一个体系可能会影响到另一个体系, 使得另一个体系需要做出修改.\n解耦: 将体系之间的联系降到最低, 各司其职, 修改本身的时候, 不需要去动其他的体系\n\n#### 简单工厂模式\n简单工厂模式不属于GoF 23种设计模式\n通过设计一个父类(产品类), 由他派生出多个子类(具体产品类), 通过一个工厂类, 提供给工厂类生产方法不同的参数, 由工厂类return相应的子类, 由父类接受.\n\n解决问题: 通过工厂类, 只需要记住参数, 就可以产生相应的子类,\n存在问题: 不符合开闭原则, 每次产生新的产品, 都需要去修改相应的工厂生产方法.\n\n#### 工厂方法模式\n与简单工厂有些相似之处: 均存在一个产品父类和多个产品子类.\n不同之处在于 工厂方法模式, 设置了工厂父类, 通过派生出不同的工厂子类来return相应的子类.\n\n解决问题: 解决了简单工厂模式的开闭原则, 每次产生新的产品, 只需要派生一个相应的子类即可\n存在问题: 系统中由于新产品的产生, 类的个数将会成对增加, 会有更多的类需要处理\n\n#### 抽象工厂模式\n抽象工厂模式解决了工厂方法模式某些情况下 导致的类成对增加情况\n一个抽象工厂里包含了这个\"工厂\"的所有产品--这对应了一个产品族\n可以派生出多个工厂来实现多品牌产品--形成了一个等级结构\n![引用自上文博客](https://img-blog.csdn.net/20130713162941328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n#### 单例模式\n这个模式理解起来很容易, 但是效果却十分的不错, 之前用过一次所以详细写一下.\n**饿汉式单例模式**\n饿汉式单例模式 无延迟加载 不需要解决多线程问题\n```java\n/**\n * @ClassName singletonpattern.Connect\n * @Description\n * 饿汉式单例模式 无延迟加载 不需要解决多线程问题\n * Author lsmg\n * Date 2019/5/21 13:25\n * @Version 1.0\n **/\npublic class Connect {\n    private static final Connect instance = new Connect();\n\n    private Connect(){\n\n    }\n\n    public static Connect getInstance(){\n        return instance;\n    }\n}\n```\n**懒汉式单例模式**\n```java\npackage singletonpattern;\n懒汉式单例模式 实现了延迟加载,但需要解决多线程问题\n/**\n * @ClassName singletonpattern.Connect1_2\n * @Description TODO\n * 懒汉式单例模式 实现了延迟加载,但需要解决多线程问题\n * Author lsmg\n * Date 2019/5/21 13:30\n * @Version 1.0\n **/\npublic class Connect1_2 {\n    private static Connect1_2  connect1_2;\n\n    private Connect1_2(){}\n\n    //这种方式会造成多线程访问的时候实例化多个对象\n//    public  static singletonpattern.Connect1_2 getInstance(){\n//        if(connect1_2 == null){\n//            connect1_2 = new singletonpattern.Connect1_2();\n//        }\n//\n//        return connect1_2;\n//    }\n\n    //这种方式虽然确保了只有一个线程进入, 但是降低了多线程的性能\n//    public synchronized static singletonpattern.Connect1_2 getInstance(){\n//        if(connect1_2 == null){\n//            connect1_2 = new singletonpattern.Connect1_2();\n//        }\n//\n//        return connect1_2;\n//    }\n\n\n    //这种方式需要在private \"volatile\" static singletonpattern.Connect1_2 connect1_2 这样同样降低效率\n//    public synchronized static singletonpattern.Connect1_2 getInstance(){\n//        if(connect1_2 == null){\n//\n//            synchronized (singletonpattern.Connect1_2.class){\n//                if(connect1_2 == null){\n//                    connect1_2 = new singletonpattern.Connect1_2();\n//                }\n//            }\n//\n//        }\n//\n//        return connect1_2;\n//    }\n```\n**使用IoDH方法结合二者优点**\n由于静态单例对象没有作为Singleton的成员变量直接初始化, 当调用`getInstance()`方法的时候, 会加载内部类HolderClass, 其中的static 由Java虚拟机保证线程安全性, 这样就结合了`饿汉式单例模式的线程安全`和`懒汉式单例模式的延迟加载`\n\n```java\n//Initialization on Demand Holder\nclass Singleton {\n\tprivate Singleton() {\n\t}\n\t\n\tprivate static class HolderClass {\n            private final static Singleton instance = new Singleton();\n\t}\n\t\n\tpublic static Singleton getInstance() {\n\t    return HolderClass.instance;\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t    Singleton s1, s2; \n        s1 = Singleton.getInstance();\n\t    s2 = Singleton.getInstance();\n\t    System.out.println(s1==s2);\n\t}\n}\n```\n@2019年7月13日19:07:46 设计模式暂时到这里, 去写写代码吧@\n\n### 7月14日\n```\n复用类看了一部分, 目前还差final部分\n```\n@2019年7月14日09:43:46@\n\n下午看了看大创项目的实现, 选择了高德地图api. 中午的时候太困了 搞得我没有仔细看\n目前决定采用[动态延展路径](https://lbs.amap.com/api/amap-ui/demos/amap-ui-pathsimplifier/expand-path)  解决问题, path由ajax 异步获取更新.\n#### 小插曲-Java List深浅拷贝\n```java\n@Service(\"droneStatusService\")\npublic class DroneStatusServiceImpl implements DroneStatusService {\n\n    private Logger logger = LoggerFactory.getLogger(DroneStatusServiceImpl.class);\n\n    private List<DroneStatus> droneStatusList = new ArrayList<>();\n/**删除其他代码**/\n    @Override\n    public List<DroneStatus> listDroneStatus() {\n        List<DroneStatus> theDroneStatusList = droneStatusList;\n\t\tdroneStatusList.clear(); /**这样导致了我的return list一直为空**/\n        logger.info(\"清除一次信息list共\"+theDroneStatusList.size()+\"条\");\n\n        return theDroneStatusList;\n    }\n}\n```\n第一印象这样写, 排查方法就是想到了关于Java引用的部分.\n对于list的拷贝 `遍历循环复制`和`List的构造方法`和`list.addAll()`以及`System.arraycopy()` 这些全部是`浅复制`他们指向了同一片内存区域\n\n深复制的实现方法另实体类 实现Cloneable接口 重写clone方法\n```java\n@Override\npublic Object clone() {\n\tEntity entity = null;\n\ttry {\n\t\tentity = (Entity)  super.clone();\n\t} catch (CloneNotSupportedException e) {\n\t\te.printStackTrace();\n\t}\n\treturn entity;\n}\n```\n\n然后我写了一个工具类\n```java\npublic static List<Entity> deepCopy(List<Entity> originList) {\n\tList<Entity> entityList = new ArrayList<>();\n\tfor(Entity entity : originList) {\n\t\tentityList.add((Entity) entity.clone());\n\t}\n\n\treturn entityList;\n}\n```\n通过这个工具类实现深复制\n\t\n `IDEA CTRL+ALT+T`收获这个快捷键\n![](https://i.bmp.ovh/imgs/2019/07/9fe10225fe9a52a5.png)\n@2019年7月14日17:47:23@\n\n大创先告一段落了, 等和他们对接吧, 基本功能显示路径已经做好了.\n@2019年7月14日20:29:30@\n复用类看完了\n@2019年7月14日21:14:12@\n\n### 7月15日\n把GGO通关了, 游戏就告一段落了.\n\n### 7月16日\n```\n多态\n```\n把编程思想-多态看一下吧\n\n多态这里怎么说呢, 重要的是思想吧, 自己没用过太多, 都是一些框架需要\n@2019年7月16日08:42:35@\n\n把书里的内容过了一遍, 怎么感觉不是很实用. 但是也说了一些小问题. 继承这种东西, 自己代码里都没有用太多.\n@2019年7月16日09:25:47@\n\n改了一部分BUG, 小软件的开机启动设置修改了下, 貌似可以了.\n@2019年7月16日17:39:40@\n\n### 7月17日\n上午收拾了下,  下午的话休息了休息, 晚上去吃了顿好的, 收拾回家的东西\n\n### 7月18日\n上午坐了一上午的车, 下午到了北京, 然后把电脑的内存条换上了(现在是16G的内存了, 够用了). **难受的是, 光带了鼠标没有带鼠标的接收器!!!!!!!(我以为插件可以代替接收器, 结果插线也得要接收器... 算了吧)**\n\n#### 下午继续看了一部分 云收藏的源码看到了这个下面一个函数\n```java\npublic static void main(String[] args) {\n\tSystem.out.println(getMessage(\"1\", \"2\", \"3\", \"4\"));\n}\n\npublic static String getMessage(String template, String... keys) {\n\tint count = 0;\n\tStringBuilder templateBuilder = new StringBuilder(template);\n\tfor (String key : keys) {\n\t\ttemplateBuilder.append(key);\n\t}\n\ttemplate = templateBuilder.toString();\n\treturn template;\n}\n```\n重点不是函数的功能, 而是`String...`这不是写错了. 我去网上查了下, 这样这个函数就可以接受多个参数了\n`getMessage(\"template\", \"a\", \"b\", \"c\")` 接受参数后用 增强for循环以此取出就好\n\n`是从Java 5开始，Java语言对方法参数支持一种新写法，叫可变长度参数列表`\n\n正好在这里去搜集下每次Java更新, 所提供的新特性\n\n#### JDK5 新特性\n\n#自动装箱与拆箱\n```Java\nInteger a = new Integer(10); \n//这个问题不大\nInteger b = 100; //这里就把一个int自动转成了 integer类型(自动装箱)\n//这里用到了 Integer的 valueOf()方法 实现的自动装箱\nb += 100; //b = b + 100; 用intValue()来自动拆箱\n//实现方式 b = Integer.valueOf(b.intValue() + 200); \n```\n\n#枚举类型\n```Java\nswitch \n// switch可以 switch枚举类型\n```\n\n#静态导入\n```Java\nimport static java.lang.Math.pow; \n//静态导入的必须是静态方法\nSystem.out.println(Math.pow(2, 3)); //未使用静态导入\nSystem.out.println(pow(2, 3)); //使用静态导入\n```\n\n#可变参数\n```Java\n//可以在方法参数的类型中 加入三个`...`, 这样在方法体内可以使用for的增强循环来获得传入的多个参数.\npublic static void main(String[] args) {\n\tSystem.out.println(getMessage(\"1\", \"2\", \"3\", \"4\"));\n}\n\npublic static String getMessage(String template, String... keys) {\n\tint count = 0;\n\tStringBuilder templateBuilder = new StringBuilder(template);\n\tfor (String key : keys) {\n\t\ttemplateBuilder.append(key);\n\t}\n\ttemplate = templateBuilder.toString();\n\treturn template;\n}\n```\n\n#增强for循环\n#泛型 (Generic Type)\n#内省\n\n\n#### JDK6 新特性\n\n#Desktop类和SystemTray类\n第一个`Desktop`类\n可以用来打开系统默认浏览器浏览指定的URL\n打开系统默认邮件客户端给指定的邮箱发邮件\n用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件)\n用系统默认的打印机打印文档\n第二个`SystemTray`类\n可以用来在系统托盘区创建一个托盘程序.\nJava的UI方面就不写太多了\n\n@2019年7月18日20:47:07@\n\n#### Springboot配置文件\n在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式\n其中{profile}对应你的环境标识\n\n下面列举三个文件\n`application-dev.properties`：开发环境\n`application-test.properties`：测试环境\n`application-prod.properties`：生产环境\n至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。\n`spring.profiles.active=dev`\n\n### 7月19日\n今天的话在北京待了一天, 去看了看北方最大的漫展IDO, 怎么说呢比我想象的要小一点, 不过比徐州那个好太多了. 以后有机会的话就去南方了.\n\n## 7.20-7.26\n```\n<接口, 内部类, 持有对象>\n---七个结构型模式\n- 适配器模式\n- 桥接模式\n- 组合模式\n- 外观模式\n```\n\n### 7月20日\n今天还是胳膊有些疼, 昨天拿的东西不少, 背的也不少.走的路也不少.....\n@2019年7月20日19:39:08@\n\n现在来看一些东西吧. 上个寒假在家里留了一本Java编程思想.\n\n### 7月21日\n写了个新的小项目, 正好来练练手. 新项目单独列出一篇博客.\n\n### 7月22日\n在家里午觉睡不着我凑, 改下小项目的问题.\n@去看一下设计模式吧@\n\n#### 适配器模式\n这个设计模式怎么说呢, 挺简单的.\n就是 新建一个适配器类Adapter  引用一个需要适配的类Adaptee 这个类实现客户端的接口Target\n\n这样客户端直接调用接口 相关转换工作在接口中完成.\n\n## 7.27-8.02\n\n```\n<类型信息, 泛型>\n- 装饰模式\n- 享元模式(略过)\n- 代理模式\n```\n\n### 7月28日\n从7.23-7.25 写了个小项目, 失物招领的后端. \n总的来说有 \n#### 统一反应类型\n将所有的返回结果, 写在一个类中\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951.png)\n\n预先定义的异常信息, 则使用了enum\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952.png)\n\n封装反回数据, 使用Object\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953.png)\n\n这样处理后就可以\n```java\nreturn new ResponseData(ExceptionMsg.DEL_FAILED);\n\nreturn new ResponseData(ExceptionMsg.DEL_FAILED);\n\nreturn  new ResponseData(ExceptionMsg.SUCCESS, lostAndFoundInfo);\n```\n\n来统一返回类型\n\n#### Spring Jpa的方便\n\n配置完毕后, 去编写相应的实体类\n```yml\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/lostandfound?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8&useSSL=true\nspring.datasource.username=root\nspring.datasource.password=root\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\nspring.jpa.properties.hibernate.hbm2ddl.auto=update\n\n# create：只要每次加载 Hibernate 时就都会删除上一次生成的表，然后根据 model 类再重新来生成新表. \n# create-drop：每次加载 Hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭，表就自动删除。\n# update：最常用的属性，第一次加载 Hibernate 时根据 model 类会自动建立起表的结构（前提是先建立# # 好数据库），以后加载 Hibernate 时根据 model 类自动更新表结构，即使表结构改变了，但表中的行仍然存在，不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。\n#validate ：每次加载 Hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n        \n```\n```java\n@Entity //这里可以通过value属性指定表名, 如果不指定则为类名\npublic class User {\n\n    @Id\n    @GeneratedValue //默认情况下会创建新表来存储id位置, 如果指定 strategy= GenerationType.IDENTITY 则会在一张表中存储位置id\n    private Long id;\n    @Column(nullable = false， unique = true)\n    private String userName;\n    @Column(nullable = false)\n    private String passWord;\n    @Column(nullable = false， unique = true)\n    private String email;\n    @Column(nullable = true， unique = true)\n    private String nickName;\n    @Column(nullable = false)\n    private String regTime;\n    //省略 getter settet 方法、构造方法  在这里getter setter 影响 Controller 的 return的内容. 有get方法才会在json中含有该项, 如果不想让该项出现在json中 则不需要写对应的get方法\n}\n```\n\n最后编写实体类对应的repository接口 继承 JpaRepository<model, Long>\n\n就可使用自带的一些方法.\n\n#### 去继续学习吧\n\n<接口, 内部类, 持有对象>\n\n重写Readable导致的bug.\n再Main方法里产生随机单词, 导致异常`BufferOverflowException` , 首先思考的是每次调用`read()`方法应该会传入一个新的`CharBuffer`吧(实际并不是, 后面说)\n\n\n```java\n// Main.java\npublic static void main(String[] args) {\n\n\tScanner scanner = new Scanner(new RandomWords(100000));\n\n\twhile (scanner.hasNext()) {\n\t\tSystem.out.println(scanner.next());\n\t}\n}\n\n// RandomWords.java\npublic class RandomWords implements Readable {\n\n\tprivate static Random random = new Random(100);\n\n\tprivate static final char[] CAPITALS =\n\t\t\t\"ABCDEFGHIGKLMNOPQRSTUVWXYZ\".toCharArray();\n\n\tprivate static final char[] LOWERS =\n\t\t\t\"abcdefghigklmnopqrstuvwxyz\".toCharArray();\n\t\n\n\tprivate int count;\n\n\tpublic RandomWords(int count) {\n\t\tthis.count = count;\n\t}\n\n\t@Override\n\tpublic int read(CharBuffer cb) throws IOException {\n\t\tif(count-- == 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);\n\n\t\tint maxCount = 4;\n\n\t\tfor (int i = 0; i < maxCount; i++) {\n\t\t\tcb.append(LOWERS[random.nextInt(LOWERS.length)]);\n\n\t\t\t//System.out.println(cb.limit() + \" - \" + cb.position());\n\t\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);\n\n\t\t}\n\n\t\tcb.append(\" \");\n\t\treturn 10;\n\t}\n}\n```\n\n来到报错位置, 这一段是CharBuffer源码里的部分, 发现是由于position >= limit导致的异常, 然后查找得到这两个值得获取方法position()和limit();\n```java\nfinal int nextPutIndex() {                          // package-private\n\tif (position >= limit)\n\t\tthrow new BufferOverflowException();\n\treturn position++;\n}\n```\n在RandomWords.java代码加入 `System.out.println(cb.limit() + \" - \" + cb.position());` 位置见上文注释代码\n\n经过打印发现\n```\nAyAvFkNuM\n1024 - 1002\n1024 - 1004\n1024 - 1006\n1024 - 1008\nRcEsZqFwO\n1024 - 1012\n1024 - 1014\n1024 - 1016\n1024 - 1018\nHxEsXaStX\n1024 - 1022\n1024 - 1024\n```\nposition属性并没有随着每次调用read() 方法重置, 所以每次调用read()方法传入的是同一个 `CharBuffer`. 回到Scanner源码\n```java\n//Scanner.java\n\n//通过查找找到调用read()方法的地方\n\nprivate void readInput() {\n        if (buf.limit() == buf.capacity())\n            makeSpace();\n\n        // Prepare to receive data\n        int p = buf.position();\n        buf.position(buf.limit());\n        buf.limit(buf.capacity());\n\n        int n = 0;\n        try { //这里调用了source.read()  source就是构造方法传入的在RandomWords对象\n            n = source.read(buf);\n        } catch (IOException ioe) {\n            lastException = ioe;\n            n = -1;\n        }\n\n        if (n == -1) {\n            sourceClosed = true;\n            needInput = false;\n        }\n\n        if (n > 0)\n            needInput = false;\n\n        // Restore current position and limit for reading\n        buf.limit(buf.position());\n        buf.position(p);\n    }\n```\n\n发现其传入了`buf`参数, 查找`buf`来到\n```java\nprivate Scanner(Readable source, Pattern pattern) {\n\tassert source != null : \"source should not be null\";\n\tassert pattern != null : \"pattern should not be null\";\n\tthis.source = source;\n\tdelimPattern = pattern;\n\tbuf = CharBuffer.allocate(BUFFER_SIZE);\n\tbuf.limit(0);\n\tmatcher = delimPattern.matcher(buf);\n\tmatcher.useTransparentBounds(true);\n\tmatcher.useAnchoringBounds(false);\n\tuseLocale(Locale.getDefault(Locale.Category.FORMAT));\n}\n```\n发现是这个构造方法 对buf进行的赋值, 而\t`Scanner(Readable source)`这个构造方法也只是调用的上一个构造方法.\n\n所以问题解决了, 由于我是在一开始就实例化了一个`Scanner对象`. 导致传入`read()`方法的`buf`都是同一个 才导致的上文报错.\n\n@2019年7月28日19:18:23@\n\n囫囵吞枣的看完了接口\n看了一部分内部类. 感觉很没有实感..\n联系的太少了, 对他所说的没有感到`原来如此`\n\n### 7月29日-8月2日\n\n又写了一个二手交易的后台, 马上今天是八月二号, 这个假期也过了小一半了. \n\n最近也看了看大数据相关的, 等这几天多看看关于大数据的, 也许我会选大数据专业emmm\n@2019年8月2日20:22:20@\n去看看ElasticSearch吧, 二手交易还差一个搜索\n\n\n设置ip地址\n关闭防火墙\n关闭保护\n删除映射管理文件\n关机-->克隆四台电脑\n@2019年8月2日23:42:36@\n\n\n## 8.3-8.9\n\n### 8月3日\n\n大数据相关的删掉了, 移动到了单独的一篇博客\n\n### 8月4日\n\n大数据相关的删掉了, 移动到了单独的一篇博客\n\n### 8月8日\n\n继续学习大数据相关内容, 刷了一道算法题.待会看看Java IO流\n\n*暑期计划就到此了, 自己对于将来从事什么, 还是有些迷茫, 还是多去刷刷算法题目, 找找自己的路再走吧*","source":"_posts/学习记录-大一暑假.md","raw":"---\ntitle: 暑假学习记录与总结\ntags:\ncategories:\n  - 学习记录\ndate: 2019-07-13 12:13:22\n---\n<div class=\"alert-red\">では、ゲームを始(はじ)めましょう</div>\n\n自己与研究生无缘了, 不过嘛, 是好是坏我也不知道, 现在也只能多学点技术, 去工作了, 这个暑假很重要, 所以将会每天记录下.\n\n[在线图床](https://imgurl.org/)\n[设计模式主要学习](https://blog.csdn.net/lovelion/article/details/17517213)\n设计模式次要补充 -- head first java 设计模式\n\n<!--more-->\n## 总结\n\n![](暑假学习记录与总结/4.png)\n总结一下这个暑假都干了什么, 马上就要开学了.\n七月十三日到七月十九日, 这是第一周了.这一周伴随着到处参观, 收货很少了. 那时我还在主用Java, 主要的是学习了一些设计模式, 这一周的时间对我学习C++ 帮助也是有的. 暑假学习设计模式也是出于换语言的考虑. \n第一天(七月十三日)可以说是看的最多的了解了什么是耦合和解耦, 一些简单的设计模式(简单工厂, 工厂方法, 抽象工厂, 单例模式). \n第二天(七月十四日) 开始初步试验大创项目的实现, 当时遇到一个BUG, 我需要返回一个东西, 但我还是需要返回后将他删除, 首先就是将他”复制了一份”, 然后删除, 却发现返回去的都是空的,了解到了Java如何进行深拷贝.\n七月十六日看了下Java编程思想的多态部分, 然后主要时间修改网络助手的开机启动设置, 这样开机启动设置就没有问题了.\n七月十七日收拾家伙, 休息了休息准备回家, 结果虽然我确认了好几次自己有没有带全家伙, 鼠标笔记本都带上了,\n七月十八日到达北京去我姐那里暂住了, 结果发现我…..光带回了一个鼠标, 鼠标的接收器还在USB分线器上(吐血) 然后开始了一个开源项目的阅读. 云收藏(SpringBoot框架). 发现了自己没有看懂的东西(Stirng ...), 就去了解下JDK从5-8每次更新加入的内容,了解到那个叫做可变参数需要搭配增强for循环使用\n七月十九日-七月二十日我终于实现了自己理想….怎么说呢北方最大的漫展依然没有我想象的大, 等我有机会既定要去一次南方\n\n七月二十一日到七月二十七日写了个后端练手(一个失物招领) . 使用了丝袜哥写Api文档, SpringJpa作为持久层? 这几天放松了玩了几天游戏可惜了.\n七月二十八日总结两个小项目比较靠近项目的地方, 统一返回类型, 预定义数据, SpringJpa.\n.学习了 接口 内部类 持有对象. 通过查看源码解决了一个Bug,\n七月二十九日到八月二日 编写二手交易后台.\n\n想去了解下大数据相关内容\n八月三日到八月九日 看了下关于大数据的内容, 并不是很感兴趣.\n八月十日到八月十五日 主要是写算法题目, 然后寻找自己是佛要从事游戏服务器编程\n八月十六日到八月二十四日 上午复习高数, 下午看C++\n@2019年8月24日18:21:07@\n\n\n## 大纲\n设计模式不求多, 但求会用, 极大概率调整设计模式的学习.\n此外需要刷一些常用的算法\n\n```\n7.13-7.19\n<复用类, 多态>\n---六个创建型模式\n- 简单工厂模式\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n- 原型模式(略过)\n- 建造者模式(略过)\n7.20-7.26\n<接口, 内部类, 持有对象>\n---七个结构型模式\n- 适配器模式\n- 桥接模式\n- 组合模式\n- 外观模式\n7.27-8.02\n<类型信息, 泛型>\n- 装饰模式\n- 享元模式(略过)\n- 代理模式\n8.03-8.09\n<数组, 容器深入研究>\n---十一个行为型模式\n- 职责链模式\n- 命令模式\n- 解释器模式(略过)\n- 迭代器模式\n- 中介者模式(略过)\n- 备忘录模式(略过)\n- 观察者模式\n8.10-8.16\n<IO, 枚举类型>\n- 状态模式\n- 策略模式\n- 模板方法模式\n- 访问者模(略过)\n8.17-8.23\n<注解, 并发>\n\n```\n# では、ゲームを始(はじ)めましょう\n## 7.13-7.19\n```\n7.13-7.19\n<复用类, 多态>\n---六个创建型模式\n- 简单工厂模式\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n```\n### 7月13日\n\n```\n- 简单工厂模式\n- 工厂方法模式\n- 抽象工厂模式\n- 单例模式\n```\n\n2019年7月13日12:21:17\n上午参观参观参观...... 重置了下, 这个暑期表格.今天开始第一天的打卡.下午还有参观, 然后就可以开始学了\n\n下午有b站血族直播\n下午看了一个项目, 自己不会的还是太多,,,,,, 给了源码都看不太懂.\n还是先继续看几个设计模式吧, 设计模式目前想的是, 了解大概, 等到时用到了再去详细学习\n\n#### 耦合与解耦\n耦合: 两个或两个以上的体系之间互相结合, 互相影响, 产生的一个联合起来解决问题的体系.\n这种体系, 不利于修改, 修改一个体系可能会影响到另一个体系, 使得另一个体系需要做出修改.\n解耦: 将体系之间的联系降到最低, 各司其职, 修改本身的时候, 不需要去动其他的体系\n\n#### 简单工厂模式\n简单工厂模式不属于GoF 23种设计模式\n通过设计一个父类(产品类), 由他派生出多个子类(具体产品类), 通过一个工厂类, 提供给工厂类生产方法不同的参数, 由工厂类return相应的子类, 由父类接受.\n\n解决问题: 通过工厂类, 只需要记住参数, 就可以产生相应的子类,\n存在问题: 不符合开闭原则, 每次产生新的产品, 都需要去修改相应的工厂生产方法.\n\n#### 工厂方法模式\n与简单工厂有些相似之处: 均存在一个产品父类和多个产品子类.\n不同之处在于 工厂方法模式, 设置了工厂父类, 通过派生出不同的工厂子类来return相应的子类.\n\n解决问题: 解决了简单工厂模式的开闭原则, 每次产生新的产品, 只需要派生一个相应的子类即可\n存在问题: 系统中由于新产品的产生, 类的个数将会成对增加, 会有更多的类需要处理\n\n#### 抽象工厂模式\n抽象工厂模式解决了工厂方法模式某些情况下 导致的类成对增加情况\n一个抽象工厂里包含了这个\"工厂\"的所有产品--这对应了一个产品族\n可以派生出多个工厂来实现多品牌产品--形成了一个等级结构\n![引用自上文博客](https://img-blog.csdn.net/20130713162941328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n#### 单例模式\n这个模式理解起来很容易, 但是效果却十分的不错, 之前用过一次所以详细写一下.\n**饿汉式单例模式**\n饿汉式单例模式 无延迟加载 不需要解决多线程问题\n```java\n/**\n * @ClassName singletonpattern.Connect\n * @Description\n * 饿汉式单例模式 无延迟加载 不需要解决多线程问题\n * Author lsmg\n * Date 2019/5/21 13:25\n * @Version 1.0\n **/\npublic class Connect {\n    private static final Connect instance = new Connect();\n\n    private Connect(){\n\n    }\n\n    public static Connect getInstance(){\n        return instance;\n    }\n}\n```\n**懒汉式单例模式**\n```java\npackage singletonpattern;\n懒汉式单例模式 实现了延迟加载,但需要解决多线程问题\n/**\n * @ClassName singletonpattern.Connect1_2\n * @Description TODO\n * 懒汉式单例模式 实现了延迟加载,但需要解决多线程问题\n * Author lsmg\n * Date 2019/5/21 13:30\n * @Version 1.0\n **/\npublic class Connect1_2 {\n    private static Connect1_2  connect1_2;\n\n    private Connect1_2(){}\n\n    //这种方式会造成多线程访问的时候实例化多个对象\n//    public  static singletonpattern.Connect1_2 getInstance(){\n//        if(connect1_2 == null){\n//            connect1_2 = new singletonpattern.Connect1_2();\n//        }\n//\n//        return connect1_2;\n//    }\n\n    //这种方式虽然确保了只有一个线程进入, 但是降低了多线程的性能\n//    public synchronized static singletonpattern.Connect1_2 getInstance(){\n//        if(connect1_2 == null){\n//            connect1_2 = new singletonpattern.Connect1_2();\n//        }\n//\n//        return connect1_2;\n//    }\n\n\n    //这种方式需要在private \"volatile\" static singletonpattern.Connect1_2 connect1_2 这样同样降低效率\n//    public synchronized static singletonpattern.Connect1_2 getInstance(){\n//        if(connect1_2 == null){\n//\n//            synchronized (singletonpattern.Connect1_2.class){\n//                if(connect1_2 == null){\n//                    connect1_2 = new singletonpattern.Connect1_2();\n//                }\n//            }\n//\n//        }\n//\n//        return connect1_2;\n//    }\n```\n**使用IoDH方法结合二者优点**\n由于静态单例对象没有作为Singleton的成员变量直接初始化, 当调用`getInstance()`方法的时候, 会加载内部类HolderClass, 其中的static 由Java虚拟机保证线程安全性, 这样就结合了`饿汉式单例模式的线程安全`和`懒汉式单例模式的延迟加载`\n\n```java\n//Initialization on Demand Holder\nclass Singleton {\n\tprivate Singleton() {\n\t}\n\t\n\tprivate static class HolderClass {\n            private final static Singleton instance = new Singleton();\n\t}\n\t\n\tpublic static Singleton getInstance() {\n\t    return HolderClass.instance;\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t    Singleton s1, s2; \n        s1 = Singleton.getInstance();\n\t    s2 = Singleton.getInstance();\n\t    System.out.println(s1==s2);\n\t}\n}\n```\n@2019年7月13日19:07:46 设计模式暂时到这里, 去写写代码吧@\n\n### 7月14日\n```\n复用类看了一部分, 目前还差final部分\n```\n@2019年7月14日09:43:46@\n\n下午看了看大创项目的实现, 选择了高德地图api. 中午的时候太困了 搞得我没有仔细看\n目前决定采用[动态延展路径](https://lbs.amap.com/api/amap-ui/demos/amap-ui-pathsimplifier/expand-path)  解决问题, path由ajax 异步获取更新.\n#### 小插曲-Java List深浅拷贝\n```java\n@Service(\"droneStatusService\")\npublic class DroneStatusServiceImpl implements DroneStatusService {\n\n    private Logger logger = LoggerFactory.getLogger(DroneStatusServiceImpl.class);\n\n    private List<DroneStatus> droneStatusList = new ArrayList<>();\n/**删除其他代码**/\n    @Override\n    public List<DroneStatus> listDroneStatus() {\n        List<DroneStatus> theDroneStatusList = droneStatusList;\n\t\tdroneStatusList.clear(); /**这样导致了我的return list一直为空**/\n        logger.info(\"清除一次信息list共\"+theDroneStatusList.size()+\"条\");\n\n        return theDroneStatusList;\n    }\n}\n```\n第一印象这样写, 排查方法就是想到了关于Java引用的部分.\n对于list的拷贝 `遍历循环复制`和`List的构造方法`和`list.addAll()`以及`System.arraycopy()` 这些全部是`浅复制`他们指向了同一片内存区域\n\n深复制的实现方法另实体类 实现Cloneable接口 重写clone方法\n```java\n@Override\npublic Object clone() {\n\tEntity entity = null;\n\ttry {\n\t\tentity = (Entity)  super.clone();\n\t} catch (CloneNotSupportedException e) {\n\t\te.printStackTrace();\n\t}\n\treturn entity;\n}\n```\n\n然后我写了一个工具类\n```java\npublic static List<Entity> deepCopy(List<Entity> originList) {\n\tList<Entity> entityList = new ArrayList<>();\n\tfor(Entity entity : originList) {\n\t\tentityList.add((Entity) entity.clone());\n\t}\n\n\treturn entityList;\n}\n```\n通过这个工具类实现深复制\n\t\n `IDEA CTRL+ALT+T`收获这个快捷键\n![](https://i.bmp.ovh/imgs/2019/07/9fe10225fe9a52a5.png)\n@2019年7月14日17:47:23@\n\n大创先告一段落了, 等和他们对接吧, 基本功能显示路径已经做好了.\n@2019年7月14日20:29:30@\n复用类看完了\n@2019年7月14日21:14:12@\n\n### 7月15日\n把GGO通关了, 游戏就告一段落了.\n\n### 7月16日\n```\n多态\n```\n把编程思想-多态看一下吧\n\n多态这里怎么说呢, 重要的是思想吧, 自己没用过太多, 都是一些框架需要\n@2019年7月16日08:42:35@\n\n把书里的内容过了一遍, 怎么感觉不是很实用. 但是也说了一些小问题. 继承这种东西, 自己代码里都没有用太多.\n@2019年7月16日09:25:47@\n\n改了一部分BUG, 小软件的开机启动设置修改了下, 貌似可以了.\n@2019年7月16日17:39:40@\n\n### 7月17日\n上午收拾了下,  下午的话休息了休息, 晚上去吃了顿好的, 收拾回家的东西\n\n### 7月18日\n上午坐了一上午的车, 下午到了北京, 然后把电脑的内存条换上了(现在是16G的内存了, 够用了). **难受的是, 光带了鼠标没有带鼠标的接收器!!!!!!!(我以为插件可以代替接收器, 结果插线也得要接收器... 算了吧)**\n\n#### 下午继续看了一部分 云收藏的源码看到了这个下面一个函数\n```java\npublic static void main(String[] args) {\n\tSystem.out.println(getMessage(\"1\", \"2\", \"3\", \"4\"));\n}\n\npublic static String getMessage(String template, String... keys) {\n\tint count = 0;\n\tStringBuilder templateBuilder = new StringBuilder(template);\n\tfor (String key : keys) {\n\t\ttemplateBuilder.append(key);\n\t}\n\ttemplate = templateBuilder.toString();\n\treturn template;\n}\n```\n重点不是函数的功能, 而是`String...`这不是写错了. 我去网上查了下, 这样这个函数就可以接受多个参数了\n`getMessage(\"template\", \"a\", \"b\", \"c\")` 接受参数后用 增强for循环以此取出就好\n\n`是从Java 5开始，Java语言对方法参数支持一种新写法，叫可变长度参数列表`\n\n正好在这里去搜集下每次Java更新, 所提供的新特性\n\n#### JDK5 新特性\n\n#自动装箱与拆箱\n```Java\nInteger a = new Integer(10); \n//这个问题不大\nInteger b = 100; //这里就把一个int自动转成了 integer类型(自动装箱)\n//这里用到了 Integer的 valueOf()方法 实现的自动装箱\nb += 100; //b = b + 100; 用intValue()来自动拆箱\n//实现方式 b = Integer.valueOf(b.intValue() + 200); \n```\n\n#枚举类型\n```Java\nswitch \n// switch可以 switch枚举类型\n```\n\n#静态导入\n```Java\nimport static java.lang.Math.pow; \n//静态导入的必须是静态方法\nSystem.out.println(Math.pow(2, 3)); //未使用静态导入\nSystem.out.println(pow(2, 3)); //使用静态导入\n```\n\n#可变参数\n```Java\n//可以在方法参数的类型中 加入三个`...`, 这样在方法体内可以使用for的增强循环来获得传入的多个参数.\npublic static void main(String[] args) {\n\tSystem.out.println(getMessage(\"1\", \"2\", \"3\", \"4\"));\n}\n\npublic static String getMessage(String template, String... keys) {\n\tint count = 0;\n\tStringBuilder templateBuilder = new StringBuilder(template);\n\tfor (String key : keys) {\n\t\ttemplateBuilder.append(key);\n\t}\n\ttemplate = templateBuilder.toString();\n\treturn template;\n}\n```\n\n#增强for循环\n#泛型 (Generic Type)\n#内省\n\n\n#### JDK6 新特性\n\n#Desktop类和SystemTray类\n第一个`Desktop`类\n可以用来打开系统默认浏览器浏览指定的URL\n打开系统默认邮件客户端给指定的邮箱发邮件\n用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件)\n用系统默认的打印机打印文档\n第二个`SystemTray`类\n可以用来在系统托盘区创建一个托盘程序.\nJava的UI方面就不写太多了\n\n@2019年7月18日20:47:07@\n\n#### Springboot配置文件\n在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式\n其中{profile}对应你的环境标识\n\n下面列举三个文件\n`application-dev.properties`：开发环境\n`application-test.properties`：测试环境\n`application-prod.properties`：生产环境\n至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。\n`spring.profiles.active=dev`\n\n### 7月19日\n今天的话在北京待了一天, 去看了看北方最大的漫展IDO, 怎么说呢比我想象的要小一点, 不过比徐州那个好太多了. 以后有机会的话就去南方了.\n\n## 7.20-7.26\n```\n<接口, 内部类, 持有对象>\n---七个结构型模式\n- 适配器模式\n- 桥接模式\n- 组合模式\n- 外观模式\n```\n\n### 7月20日\n今天还是胳膊有些疼, 昨天拿的东西不少, 背的也不少.走的路也不少.....\n@2019年7月20日19:39:08@\n\n现在来看一些东西吧. 上个寒假在家里留了一本Java编程思想.\n\n### 7月21日\n写了个新的小项目, 正好来练练手. 新项目单独列出一篇博客.\n\n### 7月22日\n在家里午觉睡不着我凑, 改下小项目的问题.\n@去看一下设计模式吧@\n\n#### 适配器模式\n这个设计模式怎么说呢, 挺简单的.\n就是 新建一个适配器类Adapter  引用一个需要适配的类Adaptee 这个类实现客户端的接口Target\n\n这样客户端直接调用接口 相关转换工作在接口中完成.\n\n## 7.27-8.02\n\n```\n<类型信息, 泛型>\n- 装饰模式\n- 享元模式(略过)\n- 代理模式\n```\n\n### 7月28日\n从7.23-7.25 写了个小项目, 失物招领的后端. \n总的来说有 \n#### 统一反应类型\n将所有的返回结果, 写在一个类中\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951.png)\n\n预先定义的异常信息, 则使用了enum\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952.png)\n\n封装反回数据, 使用Object\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953.png)\n\n这样处理后就可以\n```java\nreturn new ResponseData(ExceptionMsg.DEL_FAILED);\n\nreturn new ResponseData(ExceptionMsg.DEL_FAILED);\n\nreturn  new ResponseData(ExceptionMsg.SUCCESS, lostAndFoundInfo);\n```\n\n来统一返回类型\n\n#### Spring Jpa的方便\n\n配置完毕后, 去编写相应的实体类\n```yml\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/lostandfound?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8&useSSL=true\nspring.datasource.username=root\nspring.datasource.password=root\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\nspring.jpa.properties.hibernate.hbm2ddl.auto=update\n\n# create：只要每次加载 Hibernate 时就都会删除上一次生成的表，然后根据 model 类再重新来生成新表. \n# create-drop：每次加载 Hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭，表就自动删除。\n# update：最常用的属性，第一次加载 Hibernate 时根据 model 类会自动建立起表的结构（前提是先建立# # 好数据库），以后加载 Hibernate 时根据 model 类自动更新表结构，即使表结构改变了，但表中的行仍然存在，不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。\n#validate ：每次加载 Hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n        \n```\n```java\n@Entity //这里可以通过value属性指定表名, 如果不指定则为类名\npublic class User {\n\n    @Id\n    @GeneratedValue //默认情况下会创建新表来存储id位置, 如果指定 strategy= GenerationType.IDENTITY 则会在一张表中存储位置id\n    private Long id;\n    @Column(nullable = false， unique = true)\n    private String userName;\n    @Column(nullable = false)\n    private String passWord;\n    @Column(nullable = false， unique = true)\n    private String email;\n    @Column(nullable = true， unique = true)\n    private String nickName;\n    @Column(nullable = false)\n    private String regTime;\n    //省略 getter settet 方法、构造方法  在这里getter setter 影响 Controller 的 return的内容. 有get方法才会在json中含有该项, 如果不想让该项出现在json中 则不需要写对应的get方法\n}\n```\n\n最后编写实体类对应的repository接口 继承 JpaRepository<model, Long>\n\n就可使用自带的一些方法.\n\n#### 去继续学习吧\n\n<接口, 内部类, 持有对象>\n\n重写Readable导致的bug.\n再Main方法里产生随机单词, 导致异常`BufferOverflowException` , 首先思考的是每次调用`read()`方法应该会传入一个新的`CharBuffer`吧(实际并不是, 后面说)\n\n\n```java\n// Main.java\npublic static void main(String[] args) {\n\n\tScanner scanner = new Scanner(new RandomWords(100000));\n\n\twhile (scanner.hasNext()) {\n\t\tSystem.out.println(scanner.next());\n\t}\n}\n\n// RandomWords.java\npublic class RandomWords implements Readable {\n\n\tprivate static Random random = new Random(100);\n\n\tprivate static final char[] CAPITALS =\n\t\t\t\"ABCDEFGHIGKLMNOPQRSTUVWXYZ\".toCharArray();\n\n\tprivate static final char[] LOWERS =\n\t\t\t\"abcdefghigklmnopqrstuvwxyz\".toCharArray();\n\t\n\n\tprivate int count;\n\n\tpublic RandomWords(int count) {\n\t\tthis.count = count;\n\t}\n\n\t@Override\n\tpublic int read(CharBuffer cb) throws IOException {\n\t\tif(count-- == 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);\n\n\t\tint maxCount = 4;\n\n\t\tfor (int i = 0; i < maxCount; i++) {\n\t\t\tcb.append(LOWERS[random.nextInt(LOWERS.length)]);\n\n\t\t\t//System.out.println(cb.limit() + \" - \" + cb.position());\n\t\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);\n\n\t\t}\n\n\t\tcb.append(\" \");\n\t\treturn 10;\n\t}\n}\n```\n\n来到报错位置, 这一段是CharBuffer源码里的部分, 发现是由于position >= limit导致的异常, 然后查找得到这两个值得获取方法position()和limit();\n```java\nfinal int nextPutIndex() {                          // package-private\n\tif (position >= limit)\n\t\tthrow new BufferOverflowException();\n\treturn position++;\n}\n```\n在RandomWords.java代码加入 `System.out.println(cb.limit() + \" - \" + cb.position());` 位置见上文注释代码\n\n经过打印发现\n```\nAyAvFkNuM\n1024 - 1002\n1024 - 1004\n1024 - 1006\n1024 - 1008\nRcEsZqFwO\n1024 - 1012\n1024 - 1014\n1024 - 1016\n1024 - 1018\nHxEsXaStX\n1024 - 1022\n1024 - 1024\n```\nposition属性并没有随着每次调用read() 方法重置, 所以每次调用read()方法传入的是同一个 `CharBuffer`. 回到Scanner源码\n```java\n//Scanner.java\n\n//通过查找找到调用read()方法的地方\n\nprivate void readInput() {\n        if (buf.limit() == buf.capacity())\n            makeSpace();\n\n        // Prepare to receive data\n        int p = buf.position();\n        buf.position(buf.limit());\n        buf.limit(buf.capacity());\n\n        int n = 0;\n        try { //这里调用了source.read()  source就是构造方法传入的在RandomWords对象\n            n = source.read(buf);\n        } catch (IOException ioe) {\n            lastException = ioe;\n            n = -1;\n        }\n\n        if (n == -1) {\n            sourceClosed = true;\n            needInput = false;\n        }\n\n        if (n > 0)\n            needInput = false;\n\n        // Restore current position and limit for reading\n        buf.limit(buf.position());\n        buf.position(p);\n    }\n```\n\n发现其传入了`buf`参数, 查找`buf`来到\n```java\nprivate Scanner(Readable source, Pattern pattern) {\n\tassert source != null : \"source should not be null\";\n\tassert pattern != null : \"pattern should not be null\";\n\tthis.source = source;\n\tdelimPattern = pattern;\n\tbuf = CharBuffer.allocate(BUFFER_SIZE);\n\tbuf.limit(0);\n\tmatcher = delimPattern.matcher(buf);\n\tmatcher.useTransparentBounds(true);\n\tmatcher.useAnchoringBounds(false);\n\tuseLocale(Locale.getDefault(Locale.Category.FORMAT));\n}\n```\n发现是这个构造方法 对buf进行的赋值, 而\t`Scanner(Readable source)`这个构造方法也只是调用的上一个构造方法.\n\n所以问题解决了, 由于我是在一开始就实例化了一个`Scanner对象`. 导致传入`read()`方法的`buf`都是同一个 才导致的上文报错.\n\n@2019年7月28日19:18:23@\n\n囫囵吞枣的看完了接口\n看了一部分内部类. 感觉很没有实感..\n联系的太少了, 对他所说的没有感到`原来如此`\n\n### 7月29日-8月2日\n\n又写了一个二手交易的后台, 马上今天是八月二号, 这个假期也过了小一半了. \n\n最近也看了看大数据相关的, 等这几天多看看关于大数据的, 也许我会选大数据专业emmm\n@2019年8月2日20:22:20@\n去看看ElasticSearch吧, 二手交易还差一个搜索\n\n\n设置ip地址\n关闭防火墙\n关闭保护\n删除映射管理文件\n关机-->克隆四台电脑\n@2019年8月2日23:42:36@\n\n\n## 8.3-8.9\n\n### 8月3日\n\n大数据相关的删掉了, 移动到了单独的一篇博客\n\n### 8月4日\n\n大数据相关的删掉了, 移动到了单独的一篇博客\n\n### 8月8日\n\n继续学习大数据相关内容, 刷了一道算法题.待会看看Java IO流\n\n*暑期计划就到此了, 自己对于将来从事什么, 还是有些迷茫, 还是多去刷刷算法题目, 找找自己的路再走吧*","slug":"学习记录-大一暑假","published":1,"updated":"2020-03-14T10:40:33.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucve001u8cuo5j2zfcz0","content":"<div class=\"alert-red\">では、ゲームを始(はじ)めましょう</div>\n\n<p>自己与研究生无缘了, 不过嘛, 是好是坏我也不知道, 现在也只能多学点技术, 去工作了, 这个暑假很重要, 所以将会每天记录下.</p>\n<p><a href=\"https://imgurl.org/\" target=\"_blank\" rel=\"noopener\">在线图床</a><br><a href=\"https://blog.csdn.net/lovelion/article/details/17517213\" target=\"_blank\" rel=\"noopener\">设计模式主要学习</a><br>设计模式次要补充 – head first java 设计模式</p>\n<a id=\"more\"></a>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/4.png\" alt=\"\"><br>总结一下这个暑假都干了什么, 马上就要开学了.<br>七月十三日到七月十九日, 这是第一周了.这一周伴随着到处参观, 收货很少了. 那时我还在主用Java, 主要的是学习了一些设计模式, 这一周的时间对我学习C++ 帮助也是有的. 暑假学习设计模式也是出于换语言的考虑.<br>第一天(七月十三日)可以说是看的最多的了解了什么是耦合和解耦, 一些简单的设计模式(简单工厂, 工厂方法, 抽象工厂, 单例模式).<br>第二天(七月十四日) 开始初步试验大创项目的实现, 当时遇到一个BUG, 我需要返回一个东西, 但我还是需要返回后将他删除, 首先就是将他”复制了一份”, 然后删除, 却发现返回去的都是空的,了解到了Java如何进行深拷贝.<br>七月十六日看了下Java编程思想的多态部分, 然后主要时间修改网络助手的开机启动设置, 这样开机启动设置就没有问题了.<br>七月十七日收拾家伙, 休息了休息准备回家, 结果虽然我确认了好几次自己有没有带全家伙, 鼠标笔记本都带上了,<br>七月十八日到达北京去我姐那里暂住了, 结果发现我…..光带回了一个鼠标, 鼠标的接收器还在USB分线器上(吐血) 然后开始了一个开源项目的阅读. 云收藏(SpringBoot框架). 发现了自己没有看懂的东西(Stirng …), 就去了解下JDK从5-8每次更新加入的内容,了解到那个叫做可变参数需要搭配增强for循环使用<br>七月十九日-七月二十日我终于实现了自己理想….怎么说呢北方最大的漫展依然没有我想象的大, 等我有机会既定要去一次南方</p>\n<p>七月二十一日到七月二十七日写了个后端练手(一个失物招领) . 使用了丝袜哥写Api文档, SpringJpa作为持久层? 这几天放松了玩了几天游戏可惜了.<br>七月二十八日总结两个小项目比较靠近项目的地方, 统一返回类型, 预定义数据, SpringJpa.<br>.学习了 接口 内部类 持有对象. 通过查看源码解决了一个Bug,<br>七月二十九日到八月二日 编写二手交易后台.</p>\n<p>想去了解下大数据相关内容<br>八月三日到八月九日 看了下关于大数据的内容, 并不是很感兴趣.<br>八月十日到八月十五日 主要是写算法题目, 然后寻找自己是佛要从事游戏服务器编程<br>八月十六日到八月二十四日 上午复习高数, 下午看C++<br>@2019年8月24日18:21:07@</p>\n<h2 id=\"大纲\"><a href=\"#大纲\" class=\"headerlink\" title=\"大纲\"></a>大纲</h2><p>设计模式不求多, 但求会用, 极大概率调整设计模式的学习.<br>此外需要刷一些常用的算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7.13-7.19</span><br><span class=\"line\">&lt;复用类, 多态&gt;</span><br><span class=\"line\">---六个创建型模式</span><br><span class=\"line\">- 简单工厂模式</span><br><span class=\"line\">- 工厂方法模式</span><br><span class=\"line\">- 抽象工厂模式</span><br><span class=\"line\">- 单例模式</span><br><span class=\"line\">- 原型模式(略过)</span><br><span class=\"line\">- 建造者模式(略过)</span><br><span class=\"line\">7.20-7.26</span><br><span class=\"line\">&lt;接口, 内部类, 持有对象&gt;</span><br><span class=\"line\">---七个结构型模式</span><br><span class=\"line\">- 适配器模式</span><br><span class=\"line\">- 桥接模式</span><br><span class=\"line\">- 组合模式</span><br><span class=\"line\">- 外观模式</span><br><span class=\"line\">7.27-8.02</span><br><span class=\"line\">&lt;类型信息, 泛型&gt;</span><br><span class=\"line\">- 装饰模式</span><br><span class=\"line\">- 享元模式(略过)</span><br><span class=\"line\">- 代理模式</span><br><span class=\"line\">8.03-8.09</span><br><span class=\"line\">&lt;数组, 容器深入研究&gt;</span><br><span class=\"line\">---十一个行为型模式</span><br><span class=\"line\">- 职责链模式</span><br><span class=\"line\">- 命令模式</span><br><span class=\"line\">- 解释器模式(略过)</span><br><span class=\"line\">- 迭代器模式</span><br><span class=\"line\">- 中介者模式(略过)</span><br><span class=\"line\">- 备忘录模式(略过)</span><br><span class=\"line\">- 观察者模式</span><br><span class=\"line\">8.10-8.16</span><br><span class=\"line\">&lt;IO, 枚举类型&gt;</span><br><span class=\"line\">- 状态模式</span><br><span class=\"line\">- 策略模式</span><br><span class=\"line\">- 模板方法模式</span><br><span class=\"line\">- 访问者模(略过)</span><br><span class=\"line\">8.17-8.23</span><br><span class=\"line\">&lt;注解, 并发&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"では、ゲームを始-はじ-めましょう\"><a href=\"#では、ゲームを始-はじ-めましょう\" class=\"headerlink\" title=\"では、ゲームを始(はじ)めましょう\"></a>では、ゲームを始(はじ)めましょう</h1><h2 id=\"7-13-7-19\"><a href=\"#7-13-7-19\" class=\"headerlink\" title=\"7.13-7.19\"></a>7.13-7.19</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7.13-7.19</span><br><span class=\"line\">&lt;复用类, 多态&gt;</span><br><span class=\"line\">---六个创建型模式</span><br><span class=\"line\">- 简单工厂模式</span><br><span class=\"line\">- 工厂方法模式</span><br><span class=\"line\">- 抽象工厂模式</span><br><span class=\"line\">- 单例模式</span><br></pre></td></tr></table></figure>\n<h3 id=\"7月13日\"><a href=\"#7月13日\" class=\"headerlink\" title=\"7月13日\"></a>7月13日</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 简单工厂模式</span><br><span class=\"line\">- 工厂方法模式</span><br><span class=\"line\">- 抽象工厂模式</span><br><span class=\"line\">- 单例模式</span><br></pre></td></tr></table></figure>\n\n<p>2019年7月13日12:21:17<br>上午参观参观参观…… 重置了下, 这个暑期表格.今天开始第一天的打卡.下午还有参观, 然后就可以开始学了</p>\n<p>下午有b站血族直播<br>下午看了一个项目, 自己不会的还是太多,,,,,, 给了源码都看不太懂.<br>还是先继续看几个设计模式吧, 设计模式目前想的是, 了解大概, 等到时用到了再去详细学习</p>\n<h4 id=\"耦合与解耦\"><a href=\"#耦合与解耦\" class=\"headerlink\" title=\"耦合与解耦\"></a>耦合与解耦</h4><p>耦合: 两个或两个以上的体系之间互相结合, 互相影响, 产生的一个联合起来解决问题的体系.<br>这种体系, 不利于修改, 修改一个体系可能会影响到另一个体系, 使得另一个体系需要做出修改.<br>解耦: 将体系之间的联系降到最低, 各司其职, 修改本身的时候, 不需要去动其他的体系</p>\n<h4 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h4><p>简单工厂模式不属于GoF 23种设计模式<br>通过设计一个父类(产品类), 由他派生出多个子类(具体产品类), 通过一个工厂类, 提供给工厂类生产方法不同的参数, 由工厂类return相应的子类, 由父类接受.</p>\n<p>解决问题: 通过工厂类, 只需要记住参数, 就可以产生相应的子类,<br>存在问题: 不符合开闭原则, 每次产生新的产品, 都需要去修改相应的工厂生产方法.</p>\n<h4 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h4><p>与简单工厂有些相似之处: 均存在一个产品父类和多个产品子类.<br>不同之处在于 工厂方法模式, 设置了工厂父类, 通过派生出不同的工厂子类来return相应的子类.</p>\n<p>解决问题: 解决了简单工厂模式的开闭原则, 每次产生新的产品, 只需要派生一个相应的子类即可<br>存在问题: 系统中由于新产品的产生, 类的个数将会成对增加, 会有更多的类需要处理</p>\n<h4 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h4><p>抽象工厂模式解决了工厂方法模式某些情况下 导致的类成对增加情况<br>一个抽象工厂里包含了这个”工厂”的所有产品–这对应了一个产品族<br>可以派生出多个工厂来实现多品牌产品–形成了一个等级结构<br><img src=\"https://img-blog.csdn.net/20130713162941328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"引用自上文博客\"></p>\n<h4 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h4><p>这个模式理解起来很容易, 但是效果却十分的不错, 之前用过一次所以详细写一下.<br><strong>饿汉式单例模式</strong><br>饿汉式单例模式 无延迟加载 不需要解决多线程问题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span> singletonpattern.Connect</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span></span></span><br><span class=\"line\"><span class=\"comment\"> * 饿汉式单例模式 无延迟加载 不需要解决多线程问题</span></span><br><span class=\"line\"><span class=\"comment\"> * Author lsmg</span></span><br><span class=\"line\"><span class=\"comment\"> * Date 2019/5/21 13:25</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Connect instance = <span class=\"keyword\">new</span> Connect();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Connect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connect <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>懒汉式单例模式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> singletonpattern;</span><br><span class=\"line\">懒汉式单例模式 实现了延迟加载,但需要解决多线程问题</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span> singletonpattern.Connect1_2</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span> TODO</span></span><br><span class=\"line\"><span class=\"comment\"> * 懒汉式单例模式 实现了延迟加载,但需要解决多线程问题</span></span><br><span class=\"line\"><span class=\"comment\"> * Author lsmg</span></span><br><span class=\"line\"><span class=\"comment\"> * Date 2019/5/21 13:30</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connect1_2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Connect1_2  connect1_2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Connect1_2</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这种方式会造成多线程访问的时候实例化多个对象</span></span><br><span class=\"line\"><span class=\"comment\">//    public  static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        return connect1_2;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这种方式虽然确保了只有一个线程进入, 但是降低了多线程的性能</span></span><br><span class=\"line\"><span class=\"comment\">//    public synchronized static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        return connect1_2;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这种方式需要在private \"volatile\" static singletonpattern.Connect1_2 connect1_2 这样同样降低效率</span></span><br><span class=\"line\"><span class=\"comment\">//    public synchronized static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//            synchronized (singletonpattern.Connect1_2.class)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                    connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class=\"line\"><span class=\"comment\">//                &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        return connect1_2;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用IoDH方法结合二者优点</strong><br>由于静态单例对象没有作为Singleton的成员变量直接初始化, 当调用<code>getInstance()</code>方法的时候, 会加载内部类HolderClass, 其中的static 由Java虚拟机保证线程安全性, 这样就结合了<code>饿汉式单例模式的线程安全</code>和<code>懒汉式单例模式的延迟加载</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Initialization on Demand Holder</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HolderClass</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> HolderClass.instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">\t    Singleton s1, s2; </span><br><span class=\"line\">        s1 = Singleton.getInstance();</span><br><span class=\"line\">\t    s2 = Singleton.getInstance();</span><br><span class=\"line\">\t    System.out.println(s1==s2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@2019年7月13日19:07:46 设计模式暂时到这里, 去写写代码吧@</p>\n<h3 id=\"7月14日\"><a href=\"#7月14日\" class=\"headerlink\" title=\"7月14日\"></a>7月14日</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">复用类看了一部分, 目前还差final部分</span><br></pre></td></tr></table></figure>\n<p>@2019年7月14日09:43:46@</p>\n<p>下午看了看大创项目的实现, 选择了高德地图api. 中午的时候太困了 搞得我没有仔细看<br>目前决定采用<a href=\"https://lbs.amap.com/api/amap-ui/demos/amap-ui-pathsimplifier/expand-path\" target=\"_blank\" rel=\"noopener\">动态延展路径</a>  解决问题, path由ajax 异步获取更新.</p>\n<h4 id=\"小插曲-Java-List深浅拷贝\"><a href=\"#小插曲-Java-List深浅拷贝\" class=\"headerlink\" title=\"小插曲-Java List深浅拷贝\"></a>小插曲-Java List深浅拷贝</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span>(<span class=\"string\">\"droneStatusService\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DroneStatusServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">DroneStatusService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Logger logger = LoggerFactory.getLogger(DroneStatusServiceImpl<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;DroneStatus&gt; droneStatusList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">/**删除其他代码**/</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;DroneStatus&gt; <span class=\"title\">listDroneStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;DroneStatus&gt; theDroneStatusList = droneStatusList;</span><br><span class=\"line\">\t\tdroneStatusList.clear(); <span class=\"comment\">/**这样导致了我的return list一直为空**/</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">\"清除一次信息list共\"</span>+theDroneStatusList.size()+<span class=\"string\">\"条\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> theDroneStatusList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一印象这样写, 排查方法就是想到了关于Java引用的部分.<br>对于list的拷贝 <code>遍历循环复制</code>和<code>List的构造方法</code>和<code>list.addAll()</code>以及<code>System.arraycopy()</code> 这些全部是<code>浅复制</code>他们指向了同一片内存区域</p>\n<p>深复制的实现方法另实体类 实现Cloneable接口 重写clone方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tEntity entity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tentity = (Entity)  <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> entity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我写了一个工具类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Entity&gt; <span class=\"title\">deepCopy</span><span class=\"params\">(List&lt;Entity&gt; originList)</span> </span>&#123;</span><br><span class=\"line\">\tList&lt;Entity&gt; entityList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(Entity entity : originList) &#123;</span><br><span class=\"line\">\t\tentityList.add((Entity) entity.clone());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> entityList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这个工具类实现深复制</p>\n<p> <code>IDEA CTRL+ALT+T</code>收获这个快捷键<br><img src=\"https://i.bmp.ovh/imgs/2019/07/9fe10225fe9a52a5.png\" alt=\"\"><br>@2019年7月14日17:47:23@</p>\n<p>大创先告一段落了, 等和他们对接吧, 基本功能显示路径已经做好了.<br>@2019年7月14日20:29:30@<br>复用类看完了<br>@2019年7月14日21:14:12@</p>\n<h3 id=\"7月15日\"><a href=\"#7月15日\" class=\"headerlink\" title=\"7月15日\"></a>7月15日</h3><p>把GGO通关了, 游戏就告一段落了.</p>\n<h3 id=\"7月16日\"><a href=\"#7月16日\" class=\"headerlink\" title=\"7月16日\"></a>7月16日</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多态</span><br></pre></td></tr></table></figure>\n<p>把编程思想-多态看一下吧</p>\n<p>多态这里怎么说呢, 重要的是思想吧, 自己没用过太多, 都是一些框架需要<br>@2019年7月16日08:42:35@</p>\n<p>把书里的内容过了一遍, 怎么感觉不是很实用. 但是也说了一些小问题. 继承这种东西, 自己代码里都没有用太多.<br>@2019年7月16日09:25:47@</p>\n<p>改了一部分BUG, 小软件的开机启动设置修改了下, 貌似可以了.<br>@2019年7月16日17:39:40@</p>\n<h3 id=\"7月17日\"><a href=\"#7月17日\" class=\"headerlink\" title=\"7月17日\"></a>7月17日</h3><p>上午收拾了下,  下午的话休息了休息, 晚上去吃了顿好的, 收拾回家的东西</p>\n<h3 id=\"7月18日\"><a href=\"#7月18日\" class=\"headerlink\" title=\"7月18日\"></a>7月18日</h3><p>上午坐了一上午的车, 下午到了北京, 然后把电脑的内存条换上了(现在是16G的内存了, 够用了). <strong>难受的是, 光带了鼠标没有带鼠标的接收器!!!!!!!(我以为插件可以代替接收器, 结果插线也得要接收器… 算了吧)</strong></p>\n<h4 id=\"下午继续看了一部分-云收藏的源码看到了这个下面一个函数\"><a href=\"#下午继续看了一部分-云收藏的源码看到了这个下面一个函数\" class=\"headerlink\" title=\"下午继续看了一部分 云收藏的源码看到了这个下面一个函数\"></a>下午继续看了一部分 云收藏的源码看到了这个下面一个函数</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\tSystem.out.println(getMessage(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\"4\"</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getMessage</span><span class=\"params\">(String template, String... keys)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tStringBuilder templateBuilder = <span class=\"keyword\">new</span> StringBuilder(template);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">\t\ttemplateBuilder.append(key);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttemplate = templateBuilder.toString();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> template;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重点不是函数的功能, 而是<code>String...</code>这不是写错了. 我去网上查了下, 这样这个函数就可以接受多个参数了<br><code>getMessage(&quot;template&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code> 接受参数后用 增强for循环以此取出就好</p>\n<p><code>是从Java 5开始，Java语言对方法参数支持一种新写法，叫可变长度参数列表</code></p>\n<p>正好在这里去搜集下每次Java更新, 所提供的新特性</p>\n<h4 id=\"JDK5-新特性\"><a href=\"#JDK5-新特性\" class=\"headerlink\" title=\"JDK5 新特性\"></a>JDK5 新特性</h4><p>#自动装箱与拆箱</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"keyword\">new</span> Integer(<span class=\"number\">10</span>); </span><br><span class=\"line\"><span class=\"comment\">//这个问题不大</span></span><br><span class=\"line\">Integer b = <span class=\"number\">100</span>; <span class=\"comment\">//这里就把一个int自动转成了 integer类型(自动装箱)</span></span><br><span class=\"line\"><span class=\"comment\">//这里用到了 Integer的 valueOf()方法 实现的自动装箱</span></span><br><span class=\"line\">b += <span class=\"number\">100</span>; <span class=\"comment\">//b = b + 100; 用intValue()来自动拆箱</span></span><br><span class=\"line\"><span class=\"comment\">//实现方式 b = Integer.valueOf(b.intValue() + 200);</span></span><br></pre></td></tr></table></figure>\n\n<p>#枚举类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> </span><br><span class=\"line\"><span class=\"comment\">// switch可以 switch枚举类型</span></span><br></pre></td></tr></table></figure>\n\n<p>#静态导入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> java.lang.Math.pow; </span><br><span class=\"line\"><span class=\"comment\">//静态导入的必须是静态方法</span></span><br><span class=\"line\">System.out.println(Math.pow(<span class=\"number\">2</span>, <span class=\"number\">3</span>)); <span class=\"comment\">//未使用静态导入</span></span><br><span class=\"line\">System.out.println(pow(<span class=\"number\">2</span>, <span class=\"number\">3</span>)); <span class=\"comment\">//使用静态导入</span></span><br></pre></td></tr></table></figure>\n\n<p>#可变参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以在方法参数的类型中 加入三个`...`, 这样在方法体内可以使用for的增强循环来获得传入的多个参数.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\tSystem.out.println(getMessage(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\"4\"</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getMessage</span><span class=\"params\">(String template, String... keys)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tStringBuilder templateBuilder = <span class=\"keyword\">new</span> StringBuilder(template);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">\t\ttemplateBuilder.append(key);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttemplate = templateBuilder.toString();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> template;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>#增强for循环<br>#泛型 (Generic Type)<br>#内省</p>\n<h4 id=\"JDK6-新特性\"><a href=\"#JDK6-新特性\" class=\"headerlink\" title=\"JDK6 新特性\"></a>JDK6 新特性</h4><p>#Desktop类和SystemTray类<br>第一个<code>Desktop</code>类<br>可以用来打开系统默认浏览器浏览指定的URL<br>打开系统默认邮件客户端给指定的邮箱发邮件<br>用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件)<br>用系统默认的打印机打印文档<br>第二个<code>SystemTray</code>类<br>可以用来在系统托盘区创建一个托盘程序.<br>Java的UI方面就不写太多了</p>\n<p>@2019年7月18日20:47:07@</p>\n<h4 id=\"Springboot配置文件\"><a href=\"#Springboot配置文件\" class=\"headerlink\" title=\"Springboot配置文件\"></a>Springboot配置文件</h4><p>在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式<br>其中{profile}对应你的环境标识</p>\n<p>下面列举三个文件<br><code>application-dev.properties</code>：开发环境<br><code>application-test.properties</code>：测试环境<br><code>application-prod.properties</code>：生产环境<br>至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。<br><code>spring.profiles.active=dev</code></p>\n<h3 id=\"7月19日\"><a href=\"#7月19日\" class=\"headerlink\" title=\"7月19日\"></a>7月19日</h3><p>今天的话在北京待了一天, 去看了看北方最大的漫展IDO, 怎么说呢比我想象的要小一点, 不过比徐州那个好太多了. 以后有机会的话就去南方了.</p>\n<h2 id=\"7-20-7-26\"><a href=\"#7-20-7-26\" class=\"headerlink\" title=\"7.20-7.26\"></a>7.20-7.26</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;接口, 内部类, 持有对象&gt;</span><br><span class=\"line\">---七个结构型模式</span><br><span class=\"line\">- 适配器模式</span><br><span class=\"line\">- 桥接模式</span><br><span class=\"line\">- 组合模式</span><br><span class=\"line\">- 外观模式</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7月20日\"><a href=\"#7月20日\" class=\"headerlink\" title=\"7月20日\"></a>7月20日</h3><p>今天还是胳膊有些疼, 昨天拿的东西不少, 背的也不少.走的路也不少…..<br>@2019年7月20日19:39:08@</p>\n<p>现在来看一些东西吧. 上个寒假在家里留了一本Java编程思想.</p>\n<h3 id=\"7月21日\"><a href=\"#7月21日\" class=\"headerlink\" title=\"7月21日\"></a>7月21日</h3><p>写了个新的小项目, 正好来练练手. 新项目单独列出一篇博客.</p>\n<h3 id=\"7月22日\"><a href=\"#7月22日\" class=\"headerlink\" title=\"7月22日\"></a>7月22日</h3><p>在家里午觉睡不着我凑, 改下小项目的问题.<br>@去看一下设计模式吧@</p>\n<h4 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h4><p>这个设计模式怎么说呢, 挺简单的.<br>就是 新建一个适配器类Adapter  引用一个需要适配的类Adaptee 这个类实现客户端的接口Target</p>\n<p>这样客户端直接调用接口 相关转换工作在接口中完成.</p>\n<h2 id=\"7-27-8-02\"><a href=\"#7-27-8-02\" class=\"headerlink\" title=\"7.27-8.02\"></a>7.27-8.02</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;类型信息, 泛型&gt;</span><br><span class=\"line\">- 装饰模式</span><br><span class=\"line\">- 享元模式(略过)</span><br><span class=\"line\">- 代理模式</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7月28日\"><a href=\"#7月28日\" class=\"headerlink\" title=\"7月28日\"></a>7月28日</h3><p>从7.23-7.25 写了个小项目, 失物招领的后端.<br>总的来说有 </p>\n<h4 id=\"统一反应类型\"><a href=\"#统一反应类型\" class=\"headerlink\" title=\"统一反应类型\"></a>统一反应类型</h4><p>将所有的返回结果, 写在一个类中</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951.png\" alt=\"\"></p>\n<p>预先定义的异常信息, 则使用了enum</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952.png\" alt=\"\"></p>\n<p>封装反回数据, 使用Object</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953.png\" alt=\"\"></p>\n<p>这样处理后就可以</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseData(ExceptionMsg.DEL_FAILED);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseData(ExceptionMsg.DEL_FAILED);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> ResponseData(ExceptionMsg.SUCCESS, lostAndFoundInfo);</span><br></pre></td></tr></table></figure>\n\n<p>来统一返回类型</p>\n<h4 id=\"Spring-Jpa的方便\"><a href=\"#Spring-Jpa的方便\" class=\"headerlink\" title=\"Spring Jpa的方便\"></a>Spring Jpa的方便</h4><p>配置完毕后, 去编写相应的实体类</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/lostandfound?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class=\"line\"><span class=\"string\">spring.datasource.username=root</span></span><br><span class=\"line\"><span class=\"string\">spring.datasource.password=root</span></span><br><span class=\"line\"><span class=\"string\">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># create：只要每次加载 Hibernate 时就都会删除上一次生成的表，然后根据 model 类再重新来生成新表. </span></span><br><span class=\"line\"><span class=\"comment\"># create-drop：每次加载 Hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭，表就自动删除。</span></span><br><span class=\"line\"><span class=\"comment\"># update：最常用的属性，第一次加载 Hibernate 时根据 model 类会自动建立起表的结构（前提是先建立# # 好数据库），以后加载 Hibernate 时根据 model 类自动更新表结构，即使表结构改变了，但表中的行仍然存在，不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。</span></span><br><span class=\"line\"><span class=\"comment\">#validate ：每次加载 Hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</span></span><br><span class=\"line\"><span class=\"string\">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span> <span class=\"comment\">//这里可以通过value属性指定表名, 如果不指定则为类名</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span> <span class=\"comment\">//默认情况下会创建新表来存储id位置, 如果指定 strategy= GenerationType.IDENTITY 则会在一张表中存储位置id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>， unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String passWord;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>， unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String email;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">true</span>， unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String nickName;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String regTime;</span><br><span class=\"line\">    <span class=\"comment\">//省略 getter settet 方法、构造方法  在这里getter setter 影响 Controller 的 return的内容. 有get方法才会在json中含有该项, 如果不想让该项出现在json中 则不需要写对应的get方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后编写实体类对应的repository接口 继承 JpaRepository&lt;model, Long&gt;</p>\n<p>就可使用自带的一些方法.</p>\n<h4 id=\"去继续学习吧\"><a href=\"#去继续学习吧\" class=\"headerlink\" title=\"去继续学习吧\"></a>去继续学习吧</h4><p>&lt;接口, 内部类, 持有对象&gt;</p>\n<p>重写Readable导致的bug.<br>再Main方法里产生随机单词, 导致异常<code>BufferOverflowException</code> , 首先思考的是每次调用<code>read()</code>方法应该会传入一个新的<code>CharBuffer</code>吧(实际并不是, 后面说)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tScanner scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> RandomWords(<span class=\"number\">100000</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(scanner.next());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RandomWords.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWords</span> <span class=\"keyword\">implements</span> <span class=\"title\">Readable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random random = <span class=\"keyword\">new</span> Random(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] CAPITALS =</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"ABCDEFGHIGKLMNOPQRSTUVWXYZ\"</span>.toCharArray();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] LOWERS =</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"abcdefghigklmnopqrstuvwxyz\"</span>.toCharArray();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RandomWords</span><span class=\"params\">(<span class=\"keyword\">int</span> count)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.count = count;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(CharBuffer cb)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(count-- == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> maxCount = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxCount; i++) &#123;</span><br><span class=\"line\">\t\t\tcb.append(LOWERS[random.nextInt(LOWERS.length)]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//System.out.println(cb.limit() + \" - \" + cb.position());</span></span><br><span class=\"line\">\t\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcb.append(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来到报错位置, 这一段是CharBuffer源码里的部分, 发现是由于position &gt;= limit导致的异常, 然后查找得到这两个值得获取方法position()和limit();</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">nextPutIndex</span><span class=\"params\">()</span> </span>&#123;                          <span class=\"comment\">// package-private</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (position &gt;= limit)</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BufferOverflowException();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> position++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在RandomWords.java代码加入 <code>System.out.println(cb.limit() + &quot; - &quot; + cb.position());</code> 位置见上文注释代码</p>\n<p>经过打印发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AyAvFkNuM</span><br><span class=\"line\">1024 - 1002</span><br><span class=\"line\">1024 - 1004</span><br><span class=\"line\">1024 - 1006</span><br><span class=\"line\">1024 - 1008</span><br><span class=\"line\">RcEsZqFwO</span><br><span class=\"line\">1024 - 1012</span><br><span class=\"line\">1024 - 1014</span><br><span class=\"line\">1024 - 1016</span><br><span class=\"line\">1024 - 1018</span><br><span class=\"line\">HxEsXaStX</span><br><span class=\"line\">1024 - 1022</span><br><span class=\"line\">1024 - 1024</span><br></pre></td></tr></table></figure>\n<p>position属性并没有随着每次调用read() 方法重置, 所以每次调用read()方法传入的是同一个 <code>CharBuffer</code>. 回到Scanner源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Scanner.java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过查找找到调用read()方法的地方</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readInput</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buf.limit() == buf.capacity())</span><br><span class=\"line\">            makeSpace();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Prepare to receive data</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = buf.position();</span><br><span class=\"line\">        buf.position(buf.limit());</span><br><span class=\"line\">        buf.limit(buf.capacity());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123; <span class=\"comment\">//这里调用了source.read()  source就是构造方法传入的在RandomWords对象</span></span><br><span class=\"line\">            n = source.read(buf);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            lastException = ioe;</span><br><span class=\"line\">            n = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            sourceClosed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            needInput = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            needInput = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Restore current position and limit for reading</span></span><br><span class=\"line\">        buf.limit(buf.position());</span><br><span class=\"line\">        buf.position(p);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现其传入了<code>buf</code>参数, 查找<code>buf</code>来到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Scanner</span><span class=\"params\">(Readable source, Pattern pattern)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">assert</span> source != <span class=\"keyword\">null</span> : <span class=\"string\">\"source should not be null\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">assert</span> pattern != <span class=\"keyword\">null</span> : <span class=\"string\">\"pattern should not be null\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.source = source;</span><br><span class=\"line\">\tdelimPattern = pattern;</span><br><span class=\"line\">\tbuf = CharBuffer.allocate(BUFFER_SIZE);</span><br><span class=\"line\">\tbuf.limit(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tmatcher = delimPattern.matcher(buf);</span><br><span class=\"line\">\tmatcher.useTransparentBounds(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\tmatcher.useAnchoringBounds(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\tuseLocale(Locale.getDefault(Locale.Category.FORMAT));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发现是这个构造方法 对buf进行的赋值, 而    <code>Scanner(Readable source)</code>这个构造方法也只是调用的上一个构造方法.</p>\n<p>所以问题解决了, 由于我是在一开始就实例化了一个<code>Scanner对象</code>. 导致传入<code>read()</code>方法的<code>buf</code>都是同一个 才导致的上文报错.</p>\n<p>@2019年7月28日19:18:23@</p>\n<p>囫囵吞枣的看完了接口<br>看了一部分内部类. 感觉很没有实感..<br>联系的太少了, 对他所说的没有感到<code>原来如此</code></p>\n<h3 id=\"7月29日-8月2日\"><a href=\"#7月29日-8月2日\" class=\"headerlink\" title=\"7月29日-8月2日\"></a>7月29日-8月2日</h3><p>又写了一个二手交易的后台, 马上今天是八月二号, 这个假期也过了小一半了. </p>\n<p>最近也看了看大数据相关的, 等这几天多看看关于大数据的, 也许我会选大数据专业emmm<br>@2019年8月2日20:22:20@<br>去看看ElasticSearch吧, 二手交易还差一个搜索</p>\n<p>设置ip地址<br>关闭防火墙<br>关闭保护<br>删除映射管理文件<br>关机–&gt;克隆四台电脑<br>@2019年8月2日23:42:36@</p>\n<h2 id=\"8-3-8-9\"><a href=\"#8-3-8-9\" class=\"headerlink\" title=\"8.3-8.9\"></a>8.3-8.9</h2><h3 id=\"8月3日\"><a href=\"#8月3日\" class=\"headerlink\" title=\"8月3日\"></a>8月3日</h3><p>大数据相关的删掉了, 移动到了单独的一篇博客</p>\n<h3 id=\"8月4日\"><a href=\"#8月4日\" class=\"headerlink\" title=\"8月4日\"></a>8月4日</h3><p>大数据相关的删掉了, 移动到了单独的一篇博客</p>\n<h3 id=\"8月8日\"><a href=\"#8月8日\" class=\"headerlink\" title=\"8月8日\"></a>8月8日</h3><p>继续学习大数据相关内容, 刷了一道算法题.待会看看Java IO流</p>\n<p><em>暑期计划就到此了, 自己对于将来从事什么, 还是有些迷茫, 还是多去刷刷算法题目, 找找自己的路再走吧</em></p>\n","site":{"data":{}},"excerpt":"<div class=\"alert-red\">では、ゲームを始(はじ)めましょう</div>\n\n<p>自己与研究生无缘了, 不过嘛, 是好是坏我也不知道, 现在也只能多学点技术, 去工作了, 这个暑假很重要, 所以将会每天记录下.</p>\n<p><a href=\"https://imgurl.org/\" target=\"_blank\" rel=\"noopener\">在线图床</a><br><a href=\"https://blog.csdn.net/lovelion/article/details/17517213\" target=\"_blank\" rel=\"noopener\">设计模式主要学习</a><br>设计模式次要补充 – head first java 设计模式</p>","more":"<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E4%B8%8E%E6%80%BB%E7%BB%93/4.png\" alt=\"\"><br>总结一下这个暑假都干了什么, 马上就要开学了.<br>七月十三日到七月十九日, 这是第一周了.这一周伴随着到处参观, 收货很少了. 那时我还在主用Java, 主要的是学习了一些设计模式, 这一周的时间对我学习C++ 帮助也是有的. 暑假学习设计模式也是出于换语言的考虑.<br>第一天(七月十三日)可以说是看的最多的了解了什么是耦合和解耦, 一些简单的设计模式(简单工厂, 工厂方法, 抽象工厂, 单例模式).<br>第二天(七月十四日) 开始初步试验大创项目的实现, 当时遇到一个BUG, 我需要返回一个东西, 但我还是需要返回后将他删除, 首先就是将他”复制了一份”, 然后删除, 却发现返回去的都是空的,了解到了Java如何进行深拷贝.<br>七月十六日看了下Java编程思想的多态部分, 然后主要时间修改网络助手的开机启动设置, 这样开机启动设置就没有问题了.<br>七月十七日收拾家伙, 休息了休息准备回家, 结果虽然我确认了好几次自己有没有带全家伙, 鼠标笔记本都带上了,<br>七月十八日到达北京去我姐那里暂住了, 结果发现我…..光带回了一个鼠标, 鼠标的接收器还在USB分线器上(吐血) 然后开始了一个开源项目的阅读. 云收藏(SpringBoot框架). 发现了自己没有看懂的东西(Stirng …), 就去了解下JDK从5-8每次更新加入的内容,了解到那个叫做可变参数需要搭配增强for循环使用<br>七月十九日-七月二十日我终于实现了自己理想….怎么说呢北方最大的漫展依然没有我想象的大, 等我有机会既定要去一次南方</p>\n<p>七月二十一日到七月二十七日写了个后端练手(一个失物招领) . 使用了丝袜哥写Api文档, SpringJpa作为持久层? 这几天放松了玩了几天游戏可惜了.<br>七月二十八日总结两个小项目比较靠近项目的地方, 统一返回类型, 预定义数据, SpringJpa.<br>.学习了 接口 内部类 持有对象. 通过查看源码解决了一个Bug,<br>七月二十九日到八月二日 编写二手交易后台.</p>\n<p>想去了解下大数据相关内容<br>八月三日到八月九日 看了下关于大数据的内容, 并不是很感兴趣.<br>八月十日到八月十五日 主要是写算法题目, 然后寻找自己是佛要从事游戏服务器编程<br>八月十六日到八月二十四日 上午复习高数, 下午看C++<br>@2019年8月24日18:21:07@</p>\n<h2 id=\"大纲\"><a href=\"#大纲\" class=\"headerlink\" title=\"大纲\"></a>大纲</h2><p>设计模式不求多, 但求会用, 极大概率调整设计模式的学习.<br>此外需要刷一些常用的算法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7.13-7.19</span><br><span class=\"line\">&lt;复用类, 多态&gt;</span><br><span class=\"line\">---六个创建型模式</span><br><span class=\"line\">- 简单工厂模式</span><br><span class=\"line\">- 工厂方法模式</span><br><span class=\"line\">- 抽象工厂模式</span><br><span class=\"line\">- 单例模式</span><br><span class=\"line\">- 原型模式(略过)</span><br><span class=\"line\">- 建造者模式(略过)</span><br><span class=\"line\">7.20-7.26</span><br><span class=\"line\">&lt;接口, 内部类, 持有对象&gt;</span><br><span class=\"line\">---七个结构型模式</span><br><span class=\"line\">- 适配器模式</span><br><span class=\"line\">- 桥接模式</span><br><span class=\"line\">- 组合模式</span><br><span class=\"line\">- 外观模式</span><br><span class=\"line\">7.27-8.02</span><br><span class=\"line\">&lt;类型信息, 泛型&gt;</span><br><span class=\"line\">- 装饰模式</span><br><span class=\"line\">- 享元模式(略过)</span><br><span class=\"line\">- 代理模式</span><br><span class=\"line\">8.03-8.09</span><br><span class=\"line\">&lt;数组, 容器深入研究&gt;</span><br><span class=\"line\">---十一个行为型模式</span><br><span class=\"line\">- 职责链模式</span><br><span class=\"line\">- 命令模式</span><br><span class=\"line\">- 解释器模式(略过)</span><br><span class=\"line\">- 迭代器模式</span><br><span class=\"line\">- 中介者模式(略过)</span><br><span class=\"line\">- 备忘录模式(略过)</span><br><span class=\"line\">- 观察者模式</span><br><span class=\"line\">8.10-8.16</span><br><span class=\"line\">&lt;IO, 枚举类型&gt;</span><br><span class=\"line\">- 状态模式</span><br><span class=\"line\">- 策略模式</span><br><span class=\"line\">- 模板方法模式</span><br><span class=\"line\">- 访问者模(略过)</span><br><span class=\"line\">8.17-8.23</span><br><span class=\"line\">&lt;注解, 并发&gt;</span><br></pre></td></tr></table></figure>\n<h1 id=\"では、ゲームを始-はじ-めましょう\"><a href=\"#では、ゲームを始-はじ-めましょう\" class=\"headerlink\" title=\"では、ゲームを始(はじ)めましょう\"></a>では、ゲームを始(はじ)めましょう</h1><h2 id=\"7-13-7-19\"><a href=\"#7-13-7-19\" class=\"headerlink\" title=\"7.13-7.19\"></a>7.13-7.19</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">7.13-7.19</span><br><span class=\"line\">&lt;复用类, 多态&gt;</span><br><span class=\"line\">---六个创建型模式</span><br><span class=\"line\">- 简单工厂模式</span><br><span class=\"line\">- 工厂方法模式</span><br><span class=\"line\">- 抽象工厂模式</span><br><span class=\"line\">- 单例模式</span><br></pre></td></tr></table></figure>\n<h3 id=\"7月13日\"><a href=\"#7月13日\" class=\"headerlink\" title=\"7月13日\"></a>7月13日</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 简单工厂模式</span><br><span class=\"line\">- 工厂方法模式</span><br><span class=\"line\">- 抽象工厂模式</span><br><span class=\"line\">- 单例模式</span><br></pre></td></tr></table></figure>\n\n<p>2019年7月13日12:21:17<br>上午参观参观参观…… 重置了下, 这个暑期表格.今天开始第一天的打卡.下午还有参观, 然后就可以开始学了</p>\n<p>下午有b站血族直播<br>下午看了一个项目, 自己不会的还是太多,,,,,, 给了源码都看不太懂.<br>还是先继续看几个设计模式吧, 设计模式目前想的是, 了解大概, 等到时用到了再去详细学习</p>\n<h4 id=\"耦合与解耦\"><a href=\"#耦合与解耦\" class=\"headerlink\" title=\"耦合与解耦\"></a>耦合与解耦</h4><p>耦合: 两个或两个以上的体系之间互相结合, 互相影响, 产生的一个联合起来解决问题的体系.<br>这种体系, 不利于修改, 修改一个体系可能会影响到另一个体系, 使得另一个体系需要做出修改.<br>解耦: 将体系之间的联系降到最低, 各司其职, 修改本身的时候, 不需要去动其他的体系</p>\n<h4 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h4><p>简单工厂模式不属于GoF 23种设计模式<br>通过设计一个父类(产品类), 由他派生出多个子类(具体产品类), 通过一个工厂类, 提供给工厂类生产方法不同的参数, 由工厂类return相应的子类, 由父类接受.</p>\n<p>解决问题: 通过工厂类, 只需要记住参数, 就可以产生相应的子类,<br>存在问题: 不符合开闭原则, 每次产生新的产品, 都需要去修改相应的工厂生产方法.</p>\n<h4 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h4><p>与简单工厂有些相似之处: 均存在一个产品父类和多个产品子类.<br>不同之处在于 工厂方法模式, 设置了工厂父类, 通过派生出不同的工厂子类来return相应的子类.</p>\n<p>解决问题: 解决了简单工厂模式的开闭原则, 每次产生新的产品, 只需要派生一个相应的子类即可<br>存在问题: 系统中由于新产品的产生, 类的个数将会成对增加, 会有更多的类需要处理</p>\n<h4 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h4><p>抽象工厂模式解决了工厂方法模式某些情况下 导致的类成对增加情况<br>一个抽象工厂里包含了这个”工厂”的所有产品–这对应了一个产品族<br>可以派生出多个工厂来实现多品牌产品–形成了一个等级结构<br><img src=\"https://img-blog.csdn.net/20130713162941328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTG92ZUxpb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"引用自上文博客\"></p>\n<h4 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h4><p>这个模式理解起来很容易, 但是效果却十分的不错, 之前用过一次所以详细写一下.<br><strong>饿汉式单例模式</strong><br>饿汉式单例模式 无延迟加载 不需要解决多线程问题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span> singletonpattern.Connect</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span></span></span><br><span class=\"line\"><span class=\"comment\"> * 饿汉式单例模式 无延迟加载 不需要解决多线程问题</span></span><br><span class=\"line\"><span class=\"comment\"> * Author lsmg</span></span><br><span class=\"line\"><span class=\"comment\"> * Date 2019/5/21 13:25</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Connect instance = <span class=\"keyword\">new</span> Connect();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Connect</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Connect <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>懒汉式单例模式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> singletonpattern;</span><br><span class=\"line\">懒汉式单例模式 实现了延迟加载,但需要解决多线程问题</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@ClassName</span> singletonpattern.Connect1_2</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Description</span> TODO</span></span><br><span class=\"line\"><span class=\"comment\"> * 懒汉式单例模式 实现了延迟加载,但需要解决多线程问题</span></span><br><span class=\"line\"><span class=\"comment\"> * Author lsmg</span></span><br><span class=\"line\"><span class=\"comment\"> * Date 2019/5/21 13:30</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Version</span> 1.0</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connect1_2</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Connect1_2  connect1_2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Connect1_2</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这种方式会造成多线程访问的时候实例化多个对象</span></span><br><span class=\"line\"><span class=\"comment\">//    public  static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        return connect1_2;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这种方式虽然确保了只有一个线程进入, 但是降低了多线程的性能</span></span><br><span class=\"line\"><span class=\"comment\">//    public synchronized static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//            connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        return connect1_2;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这种方式需要在private \"volatile\" static singletonpattern.Connect1_2 connect1_2 这样同样降低效率</span></span><br><span class=\"line\"><span class=\"comment\">//    public synchronized static singletonpattern.Connect1_2 getInstance()&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//            synchronized (singletonpattern.Connect1_2.class)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                if(connect1_2 == null)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//                    connect1_2 = new singletonpattern.Connect1_2();</span></span><br><span class=\"line\"><span class=\"comment\">//                &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">//        return connect1_2;</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br></pre></td></tr></table></figure>\n<p><strong>使用IoDH方法结合二者优点</strong><br>由于静态单例对象没有作为Singleton的成员变量直接初始化, 当调用<code>getInstance()</code>方法的时候, 会加载内部类HolderClass, 其中的static 由Java虚拟机保证线程安全性, 这样就结合了<code>饿汉式单例模式的线程安全</code>和<code>懒汉式单例模式的延迟加载</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Initialization on Demand Holder</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HolderClass</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> HolderClass.instance;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">\t    Singleton s1, s2; </span><br><span class=\"line\">        s1 = Singleton.getInstance();</span><br><span class=\"line\">\t    s2 = Singleton.getInstance();</span><br><span class=\"line\">\t    System.out.println(s1==s2);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@2019年7月13日19:07:46 设计模式暂时到这里, 去写写代码吧@</p>\n<h3 id=\"7月14日\"><a href=\"#7月14日\" class=\"headerlink\" title=\"7月14日\"></a>7月14日</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">复用类看了一部分, 目前还差final部分</span><br></pre></td></tr></table></figure>\n<p>@2019年7月14日09:43:46@</p>\n<p>下午看了看大创项目的实现, 选择了高德地图api. 中午的时候太困了 搞得我没有仔细看<br>目前决定采用<a href=\"https://lbs.amap.com/api/amap-ui/demos/amap-ui-pathsimplifier/expand-path\" target=\"_blank\" rel=\"noopener\">动态延展路径</a>  解决问题, path由ajax 异步获取更新.</p>\n<h4 id=\"小插曲-Java-List深浅拷贝\"><a href=\"#小插曲-Java-List深浅拷贝\" class=\"headerlink\" title=\"小插曲-Java List深浅拷贝\"></a>小插曲-Java List深浅拷贝</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span>(<span class=\"string\">\"droneStatusService\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DroneStatusServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">DroneStatusService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Logger logger = LoggerFactory.getLogger(DroneStatusServiceImpl<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;DroneStatus&gt; droneStatusList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">/**删除其他代码**/</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;DroneStatus&gt; <span class=\"title\">listDroneStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        List&lt;DroneStatus&gt; theDroneStatusList = droneStatusList;</span><br><span class=\"line\">\t\tdroneStatusList.clear(); <span class=\"comment\">/**这样导致了我的return list一直为空**/</span></span><br><span class=\"line\">        logger.info(<span class=\"string\">\"清除一次信息list共\"</span>+theDroneStatusList.size()+<span class=\"string\">\"条\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> theDroneStatusList;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>第一印象这样写, 排查方法就是想到了关于Java引用的部分.<br>对于list的拷贝 <code>遍历循环复制</code>和<code>List的构造方法</code>和<code>list.addAll()</code>以及<code>System.arraycopy()</code> 这些全部是<code>浅复制</code>他们指向了同一片内存区域</p>\n<p>深复制的实现方法另实体类 实现Cloneable接口 重写clone方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\tEntity entity = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\tentity = (Entity)  <span class=\"keyword\">super</span>.clone();</span><br><span class=\"line\">\t&#125; <span class=\"keyword\">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class=\"line\">\t\te.printStackTrace();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> entity;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后我写了一个工具类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Entity&gt; <span class=\"title\">deepCopy</span><span class=\"params\">(List&lt;Entity&gt; originList)</span> </span>&#123;</span><br><span class=\"line\">\tList&lt;Entity&gt; entityList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(Entity entity : originList) &#123;</span><br><span class=\"line\">\t\tentityList.add((Entity) entity.clone());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> entityList;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过这个工具类实现深复制</p>\n<p> <code>IDEA CTRL+ALT+T</code>收获这个快捷键<br><img src=\"https://i.bmp.ovh/imgs/2019/07/9fe10225fe9a52a5.png\" alt=\"\"><br>@2019年7月14日17:47:23@</p>\n<p>大创先告一段落了, 等和他们对接吧, 基本功能显示路径已经做好了.<br>@2019年7月14日20:29:30@<br>复用类看完了<br>@2019年7月14日21:14:12@</p>\n<h3 id=\"7月15日\"><a href=\"#7月15日\" class=\"headerlink\" title=\"7月15日\"></a>7月15日</h3><p>把GGO通关了, 游戏就告一段落了.</p>\n<h3 id=\"7月16日\"><a href=\"#7月16日\" class=\"headerlink\" title=\"7月16日\"></a>7月16日</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多态</span><br></pre></td></tr></table></figure>\n<p>把编程思想-多态看一下吧</p>\n<p>多态这里怎么说呢, 重要的是思想吧, 自己没用过太多, 都是一些框架需要<br>@2019年7月16日08:42:35@</p>\n<p>把书里的内容过了一遍, 怎么感觉不是很实用. 但是也说了一些小问题. 继承这种东西, 自己代码里都没有用太多.<br>@2019年7月16日09:25:47@</p>\n<p>改了一部分BUG, 小软件的开机启动设置修改了下, 貌似可以了.<br>@2019年7月16日17:39:40@</p>\n<h3 id=\"7月17日\"><a href=\"#7月17日\" class=\"headerlink\" title=\"7月17日\"></a>7月17日</h3><p>上午收拾了下,  下午的话休息了休息, 晚上去吃了顿好的, 收拾回家的东西</p>\n<h3 id=\"7月18日\"><a href=\"#7月18日\" class=\"headerlink\" title=\"7月18日\"></a>7月18日</h3><p>上午坐了一上午的车, 下午到了北京, 然后把电脑的内存条换上了(现在是16G的内存了, 够用了). <strong>难受的是, 光带了鼠标没有带鼠标的接收器!!!!!!!(我以为插件可以代替接收器, 结果插线也得要接收器… 算了吧)</strong></p>\n<h4 id=\"下午继续看了一部分-云收藏的源码看到了这个下面一个函数\"><a href=\"#下午继续看了一部分-云收藏的源码看到了这个下面一个函数\" class=\"headerlink\" title=\"下午继续看了一部分 云收藏的源码看到了这个下面一个函数\"></a>下午继续看了一部分 云收藏的源码看到了这个下面一个函数</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\tSystem.out.println(getMessage(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\"4\"</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getMessage</span><span class=\"params\">(String template, String... keys)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tStringBuilder templateBuilder = <span class=\"keyword\">new</span> StringBuilder(template);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">\t\ttemplateBuilder.append(key);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttemplate = templateBuilder.toString();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> template;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>重点不是函数的功能, 而是<code>String...</code>这不是写错了. 我去网上查了下, 这样这个函数就可以接受多个参数了<br><code>getMessage(&quot;template&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</code> 接受参数后用 增强for循环以此取出就好</p>\n<p><code>是从Java 5开始，Java语言对方法参数支持一种新写法，叫可变长度参数列表</code></p>\n<p>正好在这里去搜集下每次Java更新, 所提供的新特性</p>\n<h4 id=\"JDK5-新特性\"><a href=\"#JDK5-新特性\" class=\"headerlink\" title=\"JDK5 新特性\"></a>JDK5 新特性</h4><p>#自动装箱与拆箱</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer a = <span class=\"keyword\">new</span> Integer(<span class=\"number\">10</span>); </span><br><span class=\"line\"><span class=\"comment\">//这个问题不大</span></span><br><span class=\"line\">Integer b = <span class=\"number\">100</span>; <span class=\"comment\">//这里就把一个int自动转成了 integer类型(自动装箱)</span></span><br><span class=\"line\"><span class=\"comment\">//这里用到了 Integer的 valueOf()方法 实现的自动装箱</span></span><br><span class=\"line\">b += <span class=\"number\">100</span>; <span class=\"comment\">//b = b + 100; 用intValue()来自动拆箱</span></span><br><span class=\"line\"><span class=\"comment\">//实现方式 b = Integer.valueOf(b.intValue() + 200);</span></span><br></pre></td></tr></table></figure>\n\n<p>#枚举类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> </span><br><span class=\"line\"><span class=\"comment\">// switch可以 switch枚举类型</span></span><br></pre></td></tr></table></figure>\n\n<p>#静态导入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> java.lang.Math.pow; </span><br><span class=\"line\"><span class=\"comment\">//静态导入的必须是静态方法</span></span><br><span class=\"line\">System.out.println(Math.pow(<span class=\"number\">2</span>, <span class=\"number\">3</span>)); <span class=\"comment\">//未使用静态导入</span></span><br><span class=\"line\">System.out.println(pow(<span class=\"number\">2</span>, <span class=\"number\">3</span>)); <span class=\"comment\">//使用静态导入</span></span><br></pre></td></tr></table></figure>\n\n<p>#可变参数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可以在方法参数的类型中 加入三个`...`, 这样在方法体内可以使用for的增强循环来获得传入的多个参数.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\tSystem.out.println(getMessage(<span class=\"string\">\"1\"</span>, <span class=\"string\">\"2\"</span>, <span class=\"string\">\"3\"</span>, <span class=\"string\">\"4\"</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">getMessage</span><span class=\"params\">(String template, String... keys)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">\tStringBuilder templateBuilder = <span class=\"keyword\">new</span> StringBuilder(template);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (String key : keys) &#123;</span><br><span class=\"line\">\t\ttemplateBuilder.append(key);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ttemplate = templateBuilder.toString();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> template;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>#增强for循环<br>#泛型 (Generic Type)<br>#内省</p>\n<h4 id=\"JDK6-新特性\"><a href=\"#JDK6-新特性\" class=\"headerlink\" title=\"JDK6 新特性\"></a>JDK6 新特性</h4><p>#Desktop类和SystemTray类<br>第一个<code>Desktop</code>类<br>可以用来打开系统默认浏览器浏览指定的URL<br>打开系统默认邮件客户端给指定的邮箱发邮件<br>用默认应用程序打开或编辑文件(比如,用记事本打开以txt为后缀名的文件)<br>用系统默认的打印机打印文档<br>第二个<code>SystemTray</code>类<br>可以用来在系统托盘区创建一个托盘程序.<br>Java的UI方面就不写太多了</p>\n<p>@2019年7月18日20:47:07@</p>\n<h4 id=\"Springboot配置文件\"><a href=\"#Springboot配置文件\" class=\"headerlink\" title=\"Springboot配置文件\"></a>Springboot配置文件</h4><p>在Spring Boot中多环境配置文件名需要满足application-{profile}.properties的格式<br>其中{profile}对应你的环境标识</p>\n<p>下面列举三个文件<br><code>application-dev.properties</code>：开发环境<br><code>application-test.properties</code>：测试环境<br><code>application-prod.properties</code>：生产环境<br>至于哪个具体的配置文件会被加载，需要在application.properties文件中通过spring.profiles.active属性来设置，其值对应{profile}值。<br><code>spring.profiles.active=dev</code></p>\n<h3 id=\"7月19日\"><a href=\"#7月19日\" class=\"headerlink\" title=\"7月19日\"></a>7月19日</h3><p>今天的话在北京待了一天, 去看了看北方最大的漫展IDO, 怎么说呢比我想象的要小一点, 不过比徐州那个好太多了. 以后有机会的话就去南方了.</p>\n<h2 id=\"7-20-7-26\"><a href=\"#7-20-7-26\" class=\"headerlink\" title=\"7.20-7.26\"></a>7.20-7.26</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;接口, 内部类, 持有对象&gt;</span><br><span class=\"line\">---七个结构型模式</span><br><span class=\"line\">- 适配器模式</span><br><span class=\"line\">- 桥接模式</span><br><span class=\"line\">- 组合模式</span><br><span class=\"line\">- 外观模式</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7月20日\"><a href=\"#7月20日\" class=\"headerlink\" title=\"7月20日\"></a>7月20日</h3><p>今天还是胳膊有些疼, 昨天拿的东西不少, 背的也不少.走的路也不少…..<br>@2019年7月20日19:39:08@</p>\n<p>现在来看一些东西吧. 上个寒假在家里留了一本Java编程思想.</p>\n<h3 id=\"7月21日\"><a href=\"#7月21日\" class=\"headerlink\" title=\"7月21日\"></a>7月21日</h3><p>写了个新的小项目, 正好来练练手. 新项目单独列出一篇博客.</p>\n<h3 id=\"7月22日\"><a href=\"#7月22日\" class=\"headerlink\" title=\"7月22日\"></a>7月22日</h3><p>在家里午觉睡不着我凑, 改下小项目的问题.<br>@去看一下设计模式吧@</p>\n<h4 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h4><p>这个设计模式怎么说呢, 挺简单的.<br>就是 新建一个适配器类Adapter  引用一个需要适配的类Adaptee 这个类实现客户端的接口Target</p>\n<p>这样客户端直接调用接口 相关转换工作在接口中完成.</p>\n<h2 id=\"7-27-8-02\"><a href=\"#7-27-8-02\" class=\"headerlink\" title=\"7.27-8.02\"></a>7.27-8.02</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;类型信息, 泛型&gt;</span><br><span class=\"line\">- 装饰模式</span><br><span class=\"line\">- 享元模式(略过)</span><br><span class=\"line\">- 代理模式</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7月28日\"><a href=\"#7月28日\" class=\"headerlink\" title=\"7月28日\"></a>7月28日</h3><p>从7.23-7.25 写了个小项目, 失物招领的后端.<br>总的来说有 </p>\n<h4 id=\"统一反应类型\"><a href=\"#统一反应类型\" class=\"headerlink\" title=\"统一反应类型\"></a>统一反应类型</h4><p>将所有的返回结果, 写在一个类中</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%951.png\" alt=\"\"></p>\n<p>预先定义的异常信息, 则使用了enum</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%952.png\" alt=\"\"></p>\n<p>封装反回数据, 使用Object</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%953.png\" alt=\"\"></p>\n<p>这样处理后就可以</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseData(ExceptionMsg.DEL_FAILED);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseData(ExceptionMsg.DEL_FAILED);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span>  <span class=\"keyword\">new</span> ResponseData(ExceptionMsg.SUCCESS, lostAndFoundInfo);</span><br></pre></td></tr></table></figure>\n\n<p>来统一返回类型</p>\n<h4 id=\"Spring-Jpa的方便\"><a href=\"#Spring-Jpa的方便\" class=\"headerlink\" title=\"Spring Jpa的方便\"></a>Spring Jpa的方便</h4><p>配置完毕后, 去编写相应的实体类</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/lostandfound?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span></span><br><span class=\"line\"><span class=\"string\">spring.datasource.username=root</span></span><br><span class=\"line\"><span class=\"string\">spring.datasource.password=root</span></span><br><span class=\"line\"><span class=\"string\">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># create：只要每次加载 Hibernate 时就都会删除上一次生成的表，然后根据 model 类再重新来生成新表. </span></span><br><span class=\"line\"><span class=\"comment\"># create-drop：每次加载 Hibernate 时根据 model 类生成表，但是 sessionFactory 一关闭，表就自动删除。</span></span><br><span class=\"line\"><span class=\"comment\"># update：最常用的属性，第一次加载 Hibernate 时根据 model 类会自动建立起表的结构（前提是先建立# # 好数据库），以后加载 Hibernate 时根据 model 类自动更新表结构，即使表结构改变了，但表中的行仍然存在，不会删除以前的行。要注意的是当部署到服务器后，表结构是不会被马上建立起来的，是要等应用第一次运行起来后才会。</span></span><br><span class=\"line\"><span class=\"comment\">#validate ：每次加载 Hibernate 时，验证创建数据库表结构，只会和数据库中的表进行比较，不会创建新表，但是会插入新值。</span></span><br><span class=\"line\"><span class=\"string\">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span> <span class=\"comment\">//这里可以通过value属性指定表名, 如果不指定则为类名</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span> <span class=\"comment\">//默认情况下会创建新表来存储id位置, 如果指定 strategy= GenerationType.IDENTITY 则会在一张表中存储位置id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>， unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String userName;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String passWord;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>， unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String email;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">true</span>， unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String nickName;</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String regTime;</span><br><span class=\"line\">    <span class=\"comment\">//省略 getter settet 方法、构造方法  在这里getter setter 影响 Controller 的 return的内容. 有get方法才会在json中含有该项, 如果不想让该项出现在json中 则不需要写对应的get方法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后编写实体类对应的repository接口 继承 JpaRepository&lt;model, Long&gt;</p>\n<p>就可使用自带的一些方法.</p>\n<h4 id=\"去继续学习吧\"><a href=\"#去继续学习吧\" class=\"headerlink\" title=\"去继续学习吧\"></a>去继续学习吧</h4><p>&lt;接口, 内部类, 持有对象&gt;</p>\n<p>重写Readable导致的bug.<br>再Main方法里产生随机单词, 导致异常<code>BufferOverflowException</code> , 首先思考的是每次调用<code>read()</code>方法应该会传入一个新的<code>CharBuffer</code>吧(实际并不是, 后面说)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tScanner scanner = <span class=\"keyword\">new</span> Scanner(<span class=\"keyword\">new</span> RandomWords(<span class=\"number\">100000</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (scanner.hasNext()) &#123;</span><br><span class=\"line\">\t\tSystem.out.println(scanner.next());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// RandomWords.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomWords</span> <span class=\"keyword\">implements</span> <span class=\"title\">Readable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Random random = <span class=\"keyword\">new</span> Random(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] CAPITALS =</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"ABCDEFGHIGKLMNOPQRSTUVWXYZ\"</span>.toCharArray();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">char</span>[] LOWERS =</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"abcdefghigklmnopqrstuvwxyz\"</span>.toCharArray();</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">RandomWords</span><span class=\"params\">(<span class=\"keyword\">int</span> count)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.count = count;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">(CharBuffer cb)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(count-- == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> maxCount = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxCount; i++) &#123;</span><br><span class=\"line\">\t\t\tcb.append(LOWERS[random.nextInt(LOWERS.length)]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"comment\">//System.out.println(cb.limit() + \" - \" + cb.position());</span></span><br><span class=\"line\">\t\t\tcb.append(CAPITALS[random.nextInt(CAPITALS.length)]);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tcb.append(<span class=\"string\">\" \"</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来到报错位置, 这一段是CharBuffer源码里的部分, 发现是由于position &gt;= limit导致的异常, 然后查找得到这两个值得获取方法position()和limit();</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">nextPutIndex</span><span class=\"params\">()</span> </span>&#123;                          <span class=\"comment\">// package-private</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (position &gt;= limit)</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BufferOverflowException();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> position++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在RandomWords.java代码加入 <code>System.out.println(cb.limit() + &quot; - &quot; + cb.position());</code> 位置见上文注释代码</p>\n<p>经过打印发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AyAvFkNuM</span><br><span class=\"line\">1024 - 1002</span><br><span class=\"line\">1024 - 1004</span><br><span class=\"line\">1024 - 1006</span><br><span class=\"line\">1024 - 1008</span><br><span class=\"line\">RcEsZqFwO</span><br><span class=\"line\">1024 - 1012</span><br><span class=\"line\">1024 - 1014</span><br><span class=\"line\">1024 - 1016</span><br><span class=\"line\">1024 - 1018</span><br><span class=\"line\">HxEsXaStX</span><br><span class=\"line\">1024 - 1022</span><br><span class=\"line\">1024 - 1024</span><br></pre></td></tr></table></figure>\n<p>position属性并没有随着每次调用read() 方法重置, 所以每次调用read()方法传入的是同一个 <code>CharBuffer</code>. 回到Scanner源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Scanner.java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//通过查找找到调用read()方法的地方</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readInput</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buf.limit() == buf.capacity())</span><br><span class=\"line\">            makeSpace();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Prepare to receive data</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> p = buf.position();</span><br><span class=\"line\">        buf.position(buf.limit());</span><br><span class=\"line\">        buf.limit(buf.capacity());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123; <span class=\"comment\">//这里调用了source.read()  source就是构造方法传入的在RandomWords对象</span></span><br><span class=\"line\">            n = source.read(buf);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            lastException = ioe;</span><br><span class=\"line\">            n = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            sourceClosed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            needInput = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            needInput = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Restore current position and limit for reading</span></span><br><span class=\"line\">        buf.limit(buf.position());</span><br><span class=\"line\">        buf.position(p);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>发现其传入了<code>buf</code>参数, 查找<code>buf</code>来到</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Scanner</span><span class=\"params\">(Readable source, Pattern pattern)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">assert</span> source != <span class=\"keyword\">null</span> : <span class=\"string\">\"source should not be null\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">assert</span> pattern != <span class=\"keyword\">null</span> : <span class=\"string\">\"pattern should not be null\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.source = source;</span><br><span class=\"line\">\tdelimPattern = pattern;</span><br><span class=\"line\">\tbuf = CharBuffer.allocate(BUFFER_SIZE);</span><br><span class=\"line\">\tbuf.limit(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tmatcher = delimPattern.matcher(buf);</span><br><span class=\"line\">\tmatcher.useTransparentBounds(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\tmatcher.useAnchoringBounds(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">\tuseLocale(Locale.getDefault(Locale.Category.FORMAT));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>发现是这个构造方法 对buf进行的赋值, 而    <code>Scanner(Readable source)</code>这个构造方法也只是调用的上一个构造方法.</p>\n<p>所以问题解决了, 由于我是在一开始就实例化了一个<code>Scanner对象</code>. 导致传入<code>read()</code>方法的<code>buf</code>都是同一个 才导致的上文报错.</p>\n<p>@2019年7月28日19:18:23@</p>\n<p>囫囵吞枣的看完了接口<br>看了一部分内部类. 感觉很没有实感..<br>联系的太少了, 对他所说的没有感到<code>原来如此</code></p>\n<h3 id=\"7月29日-8月2日\"><a href=\"#7月29日-8月2日\" class=\"headerlink\" title=\"7月29日-8月2日\"></a>7月29日-8月2日</h3><p>又写了一个二手交易的后台, 马上今天是八月二号, 这个假期也过了小一半了. </p>\n<p>最近也看了看大数据相关的, 等这几天多看看关于大数据的, 也许我会选大数据专业emmm<br>@2019年8月2日20:22:20@<br>去看看ElasticSearch吧, 二手交易还差一个搜索</p>\n<p>设置ip地址<br>关闭防火墙<br>关闭保护<br>删除映射管理文件<br>关机–&gt;克隆四台电脑<br>@2019年8月2日23:42:36@</p>\n<h2 id=\"8-3-8-9\"><a href=\"#8-3-8-9\" class=\"headerlink\" title=\"8.3-8.9\"></a>8.3-8.9</h2><h3 id=\"8月3日\"><a href=\"#8月3日\" class=\"headerlink\" title=\"8月3日\"></a>8月3日</h3><p>大数据相关的删掉了, 移动到了单独的一篇博客</p>\n<h3 id=\"8月4日\"><a href=\"#8月4日\" class=\"headerlink\" title=\"8月4日\"></a>8月4日</h3><p>大数据相关的删掉了, 移动到了单独的一篇博客</p>\n<h3 id=\"8月8日\"><a href=\"#8月8日\" class=\"headerlink\" title=\"8月8日\"></a>8月8日</h3><p>继续学习大数据相关内容, 刷了一道算法题.待会看看Java IO流</p>\n<p><em>暑期计划就到此了, 自己对于将来从事什么, 还是有些迷茫, 还是多去刷刷算法题目, 找找自己的路再走吧</em></p>"},{"title":"联机打砖块","date":"2020-02-17T14:49:56.000Z","_content":"这篇博客写的有点晚了, 自己的打砖块 已经写了一个段落了. 不过问题不大.\n\n重要的部分还在后面, 目前还没写到\n\n# 前言\n因为自己发现需要多做一些项目, 然后逐渐的丰富这些项目 来学习. 希望不断地提升自己, 让自己离鹅厂越来越近. 同时写博客能够让我了解得更深刻\n\n在看到知乎`日撸代码100行`的一篇推荐博客\n\n[UE4的C++教程汇总 - 日撸代码100行的文章 - 知乎](https://zhuanlan.zhihu.com/p/92422059)\n找到了那个油管的游戏制作.\n\n[这个连接-Unreal Engine 4 Tutorials](https://www.youtube.com/playlist?list=PLZhNP5qJ2IA0KK3ddSl2JWEL8jOcGe6xY)\n选择了一个游戏-打砖块\n\n那个小游戏还是很简单的 也学到了不少的东西. 不过我想了想 我既然是做游戏服务器, 我为什么不把打砖块修改成联机版打砖块??   不对!!!!我想把那个博主发布的我喜欢的游戏都改成联机版. 然后慢慢丰富游戏前端和后端的功能, 想到这里 我晚上失眠了.... 越想越兴奋.\n\n自己的话 注意下代码复用. 尤其是后端的代码. 每次把经常用的代码块抽出来 然后总结出一个自己的框架?库?\n\n# 联机的实现\n```c++\n// a.h\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\nbool CreateSocket(const FString IPStr, int32 Port);\n\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\nbool SendMessage(FString Msg);\n\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\nFString RecvMessage();\n\nFString StringFromUint8Array(TArray<uint8> Array);\n\nFIPv4Address Ip;\n\nFSocket* ClientFd;\n\n// a.cpp\nbool ANetActor::CreateSocket(const FString IPStr, int32 Port)\n{\n\t// 将字符串ip转换为点分十进制ip\n\tFIPv4Address::Parse(IPStr, Ip);\n\n\t// 将十进制ip 转化成网络地址\n\tTSharedPtr<FInternetAddr> addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateInternetAddr();\n\taddr->SetIp(Ip.Value);\n\taddr->SetPort(Port);\n\n\t// 创建TCP Socket 文件描述符\n\tClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateSocket(NAME_Stream, TEXT(\"TCP SOCKET\"), false);\n\n\t\n\tif (ClientFd->Connect(*addr))\n\t{\n\t\t// 连接成功\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Connect success!\"));\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\t// 连接失败\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Connect failed!\"));\n\t\treturn false;\n\t}\n}\n\nbool ANetActor::SendMessage(FString Msg)\n{\n\t//后面直接传送json数据\n\tTCHAR* SeriallizedMsg = Msg.GetCharArray().GetData();\n\tint32 MsgSize = FCString::Strlen(SeriallizedMsg);\n\tint32 Send = 0;\n\n\tif (ClientFd->Send((uint8*)TCHAR_TO_UTF8(SeriallizedMsg), MsgSize, Send))\n\t{\n\t\tUE_LOG(LogTemp, Log, TEXT(\"MsgSend-Success->%s\"), *Msg);\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Log, TEXT(\"MsgSend-Failed->%s\"), *Msg);\n\t\treturn false;\n\t}\n}\n\nFString ANetActor::RecvMessage()\n{\n\tif (!ClientFd)\n\t{\n\t\treturn \"\";\n\t}\n\n\tTArray<uint8> RecvData;\n\tuint32 Size;\n\tuint32 Element = 0;\n\n\twhile (ClientFd->HasPendingData(Size))\n\t{\n\t\tRecvData.Init(Element, FMath::Min(Size, 65507u)); // 65535 - 20 Ip头 - 8 Tcp头\n\t\tint32 Read = 0;\n\t\tClientFd->Recv(RecvData.GetData(), RecvData.Num(), Read);\n\t}\n\n\tif (RecvData.Num() <= 0)\n\t{\n\t\treturn \"\";\n\t}\n\n\tconst FString RecvJsonString = StringFromUint8Array(RecvData);\n\tUE_LOG(LogTemp, Log, TEXT(\"MsgRecv-Success->%s\"), *RecvJsonString);\n\n\treturn RecvJsonString;\n}\n```\n蓝图连接\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F/%E6%89%93%E7%A0%96%E5%9D%97/socket%E8%93%9D%E5%9B%BE.png)\n\n这样就能连接到TCP的后台了","source":"_posts/小游戏-联机打砖块.md","raw":"---\ntitle: 联机打砖块\ndate: 2020-02-17 22:49:56\ntags:\n  - 小游戏\n\ncategories:\n  - 小游戏\n---\n这篇博客写的有点晚了, 自己的打砖块 已经写了一个段落了. 不过问题不大.\n\n重要的部分还在后面, 目前还没写到\n\n# 前言\n因为自己发现需要多做一些项目, 然后逐渐的丰富这些项目 来学习. 希望不断地提升自己, 让自己离鹅厂越来越近. 同时写博客能够让我了解得更深刻\n\n在看到知乎`日撸代码100行`的一篇推荐博客\n\n[UE4的C++教程汇总 - 日撸代码100行的文章 - 知乎](https://zhuanlan.zhihu.com/p/92422059)\n找到了那个油管的游戏制作.\n\n[这个连接-Unreal Engine 4 Tutorials](https://www.youtube.com/playlist?list=PLZhNP5qJ2IA0KK3ddSl2JWEL8jOcGe6xY)\n选择了一个游戏-打砖块\n\n那个小游戏还是很简单的 也学到了不少的东西. 不过我想了想 我既然是做游戏服务器, 我为什么不把打砖块修改成联机版打砖块??   不对!!!!我想把那个博主发布的我喜欢的游戏都改成联机版. 然后慢慢丰富游戏前端和后端的功能, 想到这里 我晚上失眠了.... 越想越兴奋.\n\n自己的话 注意下代码复用. 尤其是后端的代码. 每次把经常用的代码块抽出来 然后总结出一个自己的框架?库?\n\n# 联机的实现\n```c++\n// a.h\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\nbool CreateSocket(const FString IPStr, int32 Port);\n\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\nbool SendMessage(FString Msg);\n\nUFUNCTION(BlueprintCallable, Category = \"TCP Network\")\nFString RecvMessage();\n\nFString StringFromUint8Array(TArray<uint8> Array);\n\nFIPv4Address Ip;\n\nFSocket* ClientFd;\n\n// a.cpp\nbool ANetActor::CreateSocket(const FString IPStr, int32 Port)\n{\n\t// 将字符串ip转换为点分十进制ip\n\tFIPv4Address::Parse(IPStr, Ip);\n\n\t// 将十进制ip 转化成网络地址\n\tTSharedPtr<FInternetAddr> addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateInternetAddr();\n\taddr->SetIp(Ip.Value);\n\taddr->SetPort(Port);\n\n\t// 创建TCP Socket 文件描述符\n\tClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateSocket(NAME_Stream, TEXT(\"TCP SOCKET\"), false);\n\n\t\n\tif (ClientFd->Connect(*addr))\n\t{\n\t\t// 连接成功\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Connect success!\"));\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\t// 连接失败\n\t\tUE_LOG(LogTemp, Warning, TEXT(\"Connect failed!\"));\n\t\treturn false;\n\t}\n}\n\nbool ANetActor::SendMessage(FString Msg)\n{\n\t//后面直接传送json数据\n\tTCHAR* SeriallizedMsg = Msg.GetCharArray().GetData();\n\tint32 MsgSize = FCString::Strlen(SeriallizedMsg);\n\tint32 Send = 0;\n\n\tif (ClientFd->Send((uint8*)TCHAR_TO_UTF8(SeriallizedMsg), MsgSize, Send))\n\t{\n\t\tUE_LOG(LogTemp, Log, TEXT(\"MsgSend-Success->%s\"), *Msg);\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tUE_LOG(LogTemp, Log, TEXT(\"MsgSend-Failed->%s\"), *Msg);\n\t\treturn false;\n\t}\n}\n\nFString ANetActor::RecvMessage()\n{\n\tif (!ClientFd)\n\t{\n\t\treturn \"\";\n\t}\n\n\tTArray<uint8> RecvData;\n\tuint32 Size;\n\tuint32 Element = 0;\n\n\twhile (ClientFd->HasPendingData(Size))\n\t{\n\t\tRecvData.Init(Element, FMath::Min(Size, 65507u)); // 65535 - 20 Ip头 - 8 Tcp头\n\t\tint32 Read = 0;\n\t\tClientFd->Recv(RecvData.GetData(), RecvData.Num(), Read);\n\t}\n\n\tif (RecvData.Num() <= 0)\n\t{\n\t\treturn \"\";\n\t}\n\n\tconst FString RecvJsonString = StringFromUint8Array(RecvData);\n\tUE_LOG(LogTemp, Log, TEXT(\"MsgRecv-Success->%s\"), *RecvJsonString);\n\n\treturn RecvJsonString;\n}\n```\n蓝图连接\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F/%E6%89%93%E7%A0%96%E5%9D%97/socket%E8%93%9D%E5%9B%BE.png)\n\n这样就能连接到TCP的后台了","slug":"小游戏-联机打砖块","published":1,"updated":"2020-02-19T14:35:22.496Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvf001y8cuo9yv89ftp","content":"<p>这篇博客写的有点晚了, 自己的打砖块 已经写了一个段落了. 不过问题不大.</p>\n<p>重要的部分还在后面, 目前还没写到</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>因为自己发现需要多做一些项目, 然后逐渐的丰富这些项目 来学习. 希望不断地提升自己, 让自己离鹅厂越来越近. 同时写博客能够让我了解得更深刻</p>\n<p>在看到知乎<code>日撸代码100行</code>的一篇推荐博客</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/92422059\" target=\"_blank\" rel=\"noopener\">UE4的C++教程汇总 - 日撸代码100行的文章 - 知乎</a><br>找到了那个油管的游戏制作.</p>\n<p><a href=\"https://www.youtube.com/playlist?list=PLZhNP5qJ2IA0KK3ddSl2JWEL8jOcGe6xY\" target=\"_blank\" rel=\"noopener\">这个连接-Unreal Engine 4 Tutorials</a><br>选择了一个游戏-打砖块</p>\n<p>那个小游戏还是很简单的 也学到了不少的东西. 不过我想了想 我既然是做游戏服务器, 我为什么不把打砖块修改成联机版打砖块??   不对!!!!我想把那个博主发布的我喜欢的游戏都改成联机版. 然后慢慢丰富游戏前端和后端的功能, 想到这里 我晚上失眠了…. 越想越兴奋.</p>\n<p>自己的话 注意下代码复用. 尤其是后端的代码. 每次把经常用的代码块抽出来 然后总结出一个自己的框架?库?</p>\n<h1 id=\"联机的实现\"><a href=\"#联机的实现\" class=\"headerlink\" title=\"联机的实现\"></a>联机的实现</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.h</span></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">CreateSocket</span><span class=\"params\">(<span class=\"keyword\">const</span> FString IPStr, int32 Port)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SendMessage</span><span class=\"params\">(FString Msg)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\"><span class=\"function\">FString <span class=\"title\">RecvMessage</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">FString <span class=\"title\">StringFromUint8Array</span><span class=\"params\">(TArray&lt;uint8&gt; Array)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">FIPv4Address Ip;</span><br><span class=\"line\"></span><br><span class=\"line\">FSocket* ClientFd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ANetActor::CreateSocket</span><span class=\"params\">(<span class=\"keyword\">const</span> FString IPStr, int32 Port)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将字符串ip转换为点分十进制ip</span></span><br><span class=\"line\">\tFIPv4Address::Parse(IPStr, Ip);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 将十进制ip 转化成网络地址</span></span><br><span class=\"line\">\tTSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();</span><br><span class=\"line\">\taddr-&gt;SetIp(Ip.Value);</span><br><span class=\"line\">\taddr-&gt;SetPort(Port);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建TCP Socket 文件描述符</span></span><br><span class=\"line\">\tClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class=\"string\">\"TCP SOCKET\"</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ClientFd-&gt;Connect(*addr))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 连接成功</span></span><br><span class=\"line\">\t\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"string\">\"Connect success!\"</span>));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 连接失败</span></span><br><span class=\"line\">\t\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"string\">\"Connect failed!\"</span>));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ANetActor::SendMessage</span><span class=\"params\">(FString Msg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//后面直接传送json数据</span></span><br><span class=\"line\">\tTCHAR* SeriallizedMsg = Msg.GetCharArray().GetData();</span><br><span class=\"line\">\tint32 MsgSize = FCString::Strlen(SeriallizedMsg);</span><br><span class=\"line\">\tint32 Send = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ClientFd-&gt;Send((uint8*)TCHAR_TO_UTF8(SeriallizedMsg), MsgSize, Send))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tUE_LOG(LogTemp, Log, TEXT(<span class=\"string\">\"MsgSend-Success-&gt;%s\"</span>), *Msg);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tUE_LOG(LogTemp, Log, TEXT(<span class=\"string\">\"MsgSend-Failed-&gt;%s\"</span>), *Msg);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">FString <span class=\"title\">ANetActor::RecvMessage</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ClientFd)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTArray&lt;uint8&gt; RecvData;</span><br><span class=\"line\">\tuint32 Size;</span><br><span class=\"line\">\tuint32 Element = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ClientFd-&gt;HasPendingData(Size))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tRecvData.Init(Element, FMath::Min(Size, <span class=\"number\">65507u</span>)); <span class=\"comment\">// 65535 - 20 Ip头 - 8 Tcp头</span></span><br><span class=\"line\">\t\tint32 Read = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tClientFd-&gt;Recv(RecvData.GetData(), RecvData.Num(), Read);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (RecvData.Num() &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> FString RecvJsonString = StringFromUint8Array(RecvData);</span><br><span class=\"line\">\tUE_LOG(LogTemp, Log, TEXT(<span class=\"string\">\"MsgRecv-Success-&gt;%s\"</span>), *RecvJsonString);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> RecvJsonString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>蓝图连接<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F/%E6%89%93%E7%A0%96%E5%9D%97/socket%E8%93%9D%E5%9B%BE.png\" alt=\"\"></p>\n<p>这样就能连接到TCP的后台了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这篇博客写的有点晚了, 自己的打砖块 已经写了一个段落了. 不过问题不大.</p>\n<p>重要的部分还在后面, 目前还没写到</p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>因为自己发现需要多做一些项目, 然后逐渐的丰富这些项目 来学习. 希望不断地提升自己, 让自己离鹅厂越来越近. 同时写博客能够让我了解得更深刻</p>\n<p>在看到知乎<code>日撸代码100行</code>的一篇推荐博客</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/92422059\" target=\"_blank\" rel=\"noopener\">UE4的C++教程汇总 - 日撸代码100行的文章 - 知乎</a><br>找到了那个油管的游戏制作.</p>\n<p><a href=\"https://www.youtube.com/playlist?list=PLZhNP5qJ2IA0KK3ddSl2JWEL8jOcGe6xY\" target=\"_blank\" rel=\"noopener\">这个连接-Unreal Engine 4 Tutorials</a><br>选择了一个游戏-打砖块</p>\n<p>那个小游戏还是很简单的 也学到了不少的东西. 不过我想了想 我既然是做游戏服务器, 我为什么不把打砖块修改成联机版打砖块??   不对!!!!我想把那个博主发布的我喜欢的游戏都改成联机版. 然后慢慢丰富游戏前端和后端的功能, 想到这里 我晚上失眠了…. 越想越兴奋.</p>\n<p>自己的话 注意下代码复用. 尤其是后端的代码. 每次把经常用的代码块抽出来 然后总结出一个自己的框架?库?</p>\n<h1 id=\"联机的实现\"><a href=\"#联机的实现\" class=\"headerlink\" title=\"联机的实现\"></a>联机的实现</h1><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a.h</span></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">CreateSocket</span><span class=\"params\">(<span class=\"keyword\">const</span> FString IPStr, int32 Port)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SendMessage</span><span class=\"params\">(FString Msg)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">UFUNCTION(BlueprintCallable, Category = <span class=\"string\">\"TCP Network\"</span>)</span><br><span class=\"line\"><span class=\"function\">FString <span class=\"title\">RecvMessage</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">FString <span class=\"title\">StringFromUint8Array</span><span class=\"params\">(TArray&lt;uint8&gt; Array)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">FIPv4Address Ip;</span><br><span class=\"line\"></span><br><span class=\"line\">FSocket* ClientFd;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ANetActor::CreateSocket</span><span class=\"params\">(<span class=\"keyword\">const</span> FString IPStr, int32 Port)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 将字符串ip转换为点分十进制ip</span></span><br><span class=\"line\">\tFIPv4Address::Parse(IPStr, Ip);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 将十进制ip 转化成网络地址</span></span><br><span class=\"line\">\tTSharedPtr&lt;FInternetAddr&gt; addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateInternetAddr();</span><br><span class=\"line\">\taddr-&gt;SetIp(Ip.Value);</span><br><span class=\"line\">\taddr-&gt;SetPort(Port);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 创建TCP Socket 文件描述符</span></span><br><span class=\"line\">\tClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)-&gt;CreateSocket(NAME_Stream, TEXT(<span class=\"string\">\"TCP SOCKET\"</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ClientFd-&gt;Connect(*addr))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 连接成功</span></span><br><span class=\"line\">\t\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"string\">\"Connect success!\"</span>));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 连接失败</span></span><br><span class=\"line\">\t\tUE_LOG(LogTemp, Warning, TEXT(<span class=\"string\">\"Connect failed!\"</span>));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ANetActor::SendMessage</span><span class=\"params\">(FString Msg)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//后面直接传送json数据</span></span><br><span class=\"line\">\tTCHAR* SeriallizedMsg = Msg.GetCharArray().GetData();</span><br><span class=\"line\">\tint32 MsgSize = FCString::Strlen(SeriallizedMsg);</span><br><span class=\"line\">\tint32 Send = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (ClientFd-&gt;Send((uint8*)TCHAR_TO_UTF8(SeriallizedMsg), MsgSize, Send))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tUE_LOG(LogTemp, Log, TEXT(<span class=\"string\">\"MsgSend-Success-&gt;%s\"</span>), *Msg);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tUE_LOG(LogTemp, Log, TEXT(<span class=\"string\">\"MsgSend-Failed-&gt;%s\"</span>), *Msg);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">FString <span class=\"title\">ANetActor::RecvMessage</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!ClientFd)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tTArray&lt;uint8&gt; RecvData;</span><br><span class=\"line\">\tuint32 Size;</span><br><span class=\"line\">\tuint32 Element = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (ClientFd-&gt;HasPendingData(Size))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tRecvData.Init(Element, FMath::Min(Size, <span class=\"number\">65507u</span>)); <span class=\"comment\">// 65535 - 20 Ip头 - 8 Tcp头</span></span><br><span class=\"line\">\t\tint32 Read = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tClientFd-&gt;Recv(RecvData.GetData(), RecvData.Num(), Read);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (RecvData.Num() &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> FString RecvJsonString = StringFromUint8Array(RecvData);</span><br><span class=\"line\">\tUE_LOG(LogTemp, Log, TEXT(<span class=\"string\">\"MsgRecv-Success-&gt;%s\"</span>), *RecvJsonString);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> RecvJsonString;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>蓝图连接<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F/%E6%89%93%E7%A0%96%E5%9D%97/socket%E8%93%9D%E5%9B%BE.png\" alt=\"\"></p>\n<p>这样就能连接到TCP的后台了</p>\n"},{"title":"大二寒假及下学期学习记录","date":"2020-02-01T09:30:32.000Z","_content":"\n现在是`2020年2月1日17:32:50` 寒假过半? 目前还不知道寒假什么时候开学. 为了自己能够前往心目中的公司, 学习是必不可少的.\n学习的同时 应该要注意总结, 防止一天或者一周下来白忙活\n我们寒假开始是一月九号 到我开始寒假学习的一月二十三号 这些天没有学习用来玩了, 好在后面拾了回来\n从二十三号到现在二月一号, 每天学习的长度和质量总算是在慢慢上升\n距离下一个寒假只剩下一年的时间了, 需要更加的努力, 为了大三暑假能够进入心中的公司 大三寒假的实习必不可少了. 加倍努力吧\n\n这篇博客的标题起初是`大二寒假学习记录`后来改成了`大二寒假及下学期学习记录`寒假的学习必不可少, 下学期更要抓紧时间了.\n\n# 二月\n## 一日2020年2月1日17:39:59\n\n前几天把博客从我自己的服务器迁移到了coding上, 方便以后我乱搞服务器, 现在服务器上没有重要的内容了\n至于实际的学习方面, 我开始整理我的博客[主要是这篇](https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/)这篇现在算告一段落了, 主要是把自己以前学过的用一用. 空洞的写下api\n理解不是很深刻.[这两天修改的这一篇](https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/). 第二篇自己缺少的东西很多, 由于当时学习到了后面实在是学不下去了.\n所以现在把后面的部分重新写了一下. 高级部分的线程和进程的部分 实在是太走马观花. 等我顺序学到了 再多写一些例子\n\n今天的话, 练习了下poll系统调用, 写了一个poll的demo, 然后是整理了下信号的部分, 信号这里整理的依然很少 平时用到的不多, 需要多加使用\n主要是定时器这里了 定时器把原来的内容删掉了 从新写目前只写完了socket定时\n\n接下来打算还是多写一些项目 多思考一些 等我整理完了高级部分 就准备去看开源项目?每次看开源项目都感觉自己差的太多, 不知道从哪里看起\n所以搭配着别人的笔记学习下看源码. 当然看源码之前还是要会大概的使用. 高级部分自然包括了libevent的使用部分\n\n跑去写项目了\n\n## 二日2020年2月2日18:03:23\n\n罪过罪过, 昨天晚上十一点半 玩了一把军团TD 结果玩到了十二点半 ..... 最后一点半才睡觉\n今天早上小十一点才起床.\n我依稀记得我八点被闹钟叫起来emm 然后想着定八点半的闹钟 再睡一会, 结果闹钟没定我就睡着了.\n\n起来后整理了整理吃了午饭, 就下午小一点了, 打开高级部分 学习`信号SIGALRM定时`\n\n代码量就400行 一直到我写今天的博客 才算完工\n\n**先写一下遇到的一个问题吧**\n首先表现出来的是`超时后 服务器没有断开连接`\n然后我去打断点, 发现不是定时器链表部分的问题. 是定时信号没有触发`epoll_wait`.\n这里我看了下代码, 发现定时器没有启动加上了`alarm(5)`, 我本意是理解了书上的代码 再去自己写, 结果还是理解的不深刻, 竟然丢了启动定时器的函数.\n然后我又运行了下`发现还是没有运行到`\n然后发现`epoll_wait 返回-1 设置EINTR`, 后来查阅了下说是被信号处理器中断, 思考可能是与IDE下断点有关??????\n最后发现自己没有把信号的管道添加到`epollfd`中再一细看发现丢了关于信号管道的四行代码...\n\n这个问题应该是很容易排查. 事后感觉应该这样思考\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/epoll%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.png)\n以后尽量总结正确的思考模式, 虽然不知道有没有用 但要试一试.\n\n**项目收获方面**\n虽然这个项目只有400多行代码, 但我自己是绝对写不出来的. 只能尽量总结书上代码的好处\n1. 首先肯定是使用alarm超时产生信号SIGALRM来触发回调函数 实现定时\n2. 信号回调函数, 没有直接去触发定时器tick函数, 而是通过一个管道传到了epollfd中, 然后从epollfd的函数中触发相关的if 再去调用tick函数\n```c++\nvoid timer_handler() //真正的生效部分\n{\n    timer_lst.tick();\n    alarm(TIMESLOT);\n}\nvoid sig_handler(int sig)\n{\n    int save_errno = errno;\n    int msg = sig;\n    send(pipefd[1], (char*)&msg, 1, 0); // pipefd[0]注册进了epoll中 接受到来的信号\n    errno = save_errno;\n}\n\nvoid addsig(int sig)// 信号添加\n{\n    struct sigaction sa{};\n    sa.sa_flags |= SA_RESTART;\n    sa.sa_handler = sig_handler;\n    sigfillset(&sa.sa_mask);\n    exit_if(sigaction(sig, &sa, nullptr) == -1, \"add sig error\");\n}\n\nchar signals[1024]; // 信号接收, 可能存在多个信号 所以用返回的字节数来逐个取出信号\nret = recv(sockfd, signals, sizeof(signals), 0); 取出后使用switch来分离信号\n```\n3. 将大部分常量 #define\n大概只能总结出这一些来了, 完整的代码我贴在github上吧\n\n## 五日 2020年2月6日09:16:23\n三和四号 基本都在玩FF14, 发现自己并不是玩游戏了, 感觉被FF14玩了, 就是那种感觉累了不想玩了, 但却离自己定的小目标远 然后坚持\nemm 其实感觉这个时候应该下游戏.\n想想自己这大学一年半玩过的游戏 血族我算是玩的时间最长的大概前前后后我玩了五年, 应该是上半年把 我弃坑了. 游戏后面太氪了, 不得不退游了.\n后面崩三啥的也玩过, 发现自己并不适合肝的游戏. 最近一个月入坑了fgo, 开始的几个星期还是玩的累了, 自己太肝了, 最近这几天感觉休闲了不少, \n心态也正常了, 所以暂且会玩一玩.\n\n主要还是后面这些吧, 我发现自己逐渐有了一个念头: 累了就去玩会游戏, 就去看会直播, 刷刷B站. 后来我感觉这些浪费时间就去搜索了一下\n**玩游戏算浪费时间吗**, 刚才去找了下. 没找到我之前看过的那篇. 结论就是为什么自己不是累了就去小睡一下, 或者看看书,再或者刷刷新的科技圈\n长长见识? 自己尝试了看书, 发现自己并不是太抗拒. 以后试试把.\n\n最后自己作为一个想开发游戏的人, 总感觉不玩游戏是不合适的, 但要玩的适度, 毕竟自己还有一年的时间就要找寒假实习, 为了自己的大三暑假进入大厂打下基础.\n平衡好才是上策.\n\n接下文, 我发现自己有点?(自信点把点去掉)好高骛远了, 好高骛远会消磨一个人的兴趣和信心. 最终决定不做什么大游戏, 不研究什么框架, 先用自己所会的写一个小游戏,\n一是为了试着重新拾起兴趣, 二是如果只学而不去写项目, 没有太大收获的\n\n昨天一天都是策划和编写一个游戏, 游戏逻辑十分的简单. 猜数字 初期的流程图我大概画了下, 姑且算作第一版吧 下面放出来, 我后面可以逐渐丰富这个东西 加上日志登录\n断线重连等等功能.感觉还是可以的~~ 尽管逻辑很简单.\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%B5%81%E7%A8%8B1.png)\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%911.png)\n\n听说在写代码前规划好, 可以更好地组织代码, 昨天尝试了下感觉还不错. 我在写代码前把游戏的流程图画了一下, 然后标上了哪里会有什么数据交互,\n之后我去写了数据包头格式\n**头部**\n\n| 偏移量 | 长度 | 含义\n| --- | --- | --- |\n| 0 | 4 | 封包总大小 |\n| 4 | 2 | 头部长度 |\n| 6 | 2 | 操作码 |\n\n**操作码**\n\n| 代码 | 含义 | 数据格式 |\n| --- | --- | --- |\n| 00 | 登录 | |\n| 01 | 桌位信息(服务器发送桌位列表) | [1000-0-4][1001-0-4] |\n| 02 | 桌位操作信息(客户端加入 退出桌位) | 1000 |\n| 03 | 服务器桌位操作信息反馈(加入退出成功1 加入退出失败0) | 1 |\n| 04 | 准备 | 无 |\n| 05 | 取消准备 | 无 |\n| 06 | 服务器广播桌位信息 | 4[11][10][00][00] (桌位总数, 有人1 准备1) |\n| A1 | 服务器广播游戏开始 | 空 |\n| A2 | 服务器下发轮到的客户端 | 空 |\n| A3 | 客户端发送猜测的数字 | 50 |\n| A4 | 服务器发送猜测数字反馈 (数据合理1, 数据非法0) | 1 |\n| A5 | 服务器广播游戏状态 | 50-0-75[A][B] (A玩家猜出50 当前范围 0到75 B玩家准备) |\n\n然后草拟了一下 用到的类 用到的数据结构 分几个类 怎么联系起来, 最终我才去写代码, 感觉比一边写\n一边想要好不少. 写的过程中也发现了一些问题\n1. `EPOLLRDHUP`这个绑定在listenfd还是newfd?? 如果是newfd还能理解下原理, listenfd就有点理解不了.(试了下, 是newfd)\n2. \n```c++\nFoo *a;\nFoos b[3];\nb[1] = *a;\n// 修改a不会影响b[1], 这个问题听到过, 自己真正试了试才发现如此\n```\n\n姑且昨天的就补上这些吧. 今天打算把游戏的服务器跑起来\n\n## 六日 2020年2月6日22:12:36\n忙忙碌碌的一天就又要结束了. 今天一天把剩下的一部分逻辑代码写了一部分. 主要是写自定义协议的序列化和反序列化. 起初打算\n用char* body 来存储, 按照上面定义的格式传输. 后来一想, 这样我就不就是在原地打转吗. 就去网上找了找相关的代码, 看看别人怎么写的\n\n主要是看的这一篇博客[手把手教你实现自定义的应用层协议](https://blog.csdn.net/ACb0y/article/details/61421006)\n看了之后收获不少. 收获总结在下面吧\n\n1. 两个头文件互相include\n\t这个是今天了解的最奇葩的一个问题, 如果两个头文件互相include 会出问题. 这个明天开一篇 采坑博客\n\t与此连带的还有class 前置声明, 再者可以到编译相关的问题\n2. 今天了解了一下CMAKE和MAKE的区别和联系, 总算知道了为啥好多安装的时候先cmake 再 make\n3. 还是关于CMAKE 稍微整理了点CMAKE的使用. 随用随整理, 目前不打算一次性整理太多\n4. Git操作不熟练. 我本地写好了代码文件, commit 然后从服务器pull了一个仅包含readme的仓库, 然后reset\n\t自己写的代码文件全没了, 只剩下README.md 还好之前整理过reflog, 明天也需要在整理下\n5. 安装了jsoncpp, 亿图图示等一些软件. 写了下关于字节对齐的问题. 亿图图示目前感觉挺不错\n\n代码方面的收获 主要就是看的那篇博客学到的.\n1. 首先就是学会了自定了协议 序列化和反序列化怎么写 代码更美. 虽然可能我看的博客可能不是最好的, \n\t但对我目前来说足够美了, 不过写一遍远远不够.\n2. 学到了巧妙地对 `uint8_t*`类型的指针(指向流数据缓冲区)转换成`uint16_t*`等指针类型, 进行解引用 得到原本的数据, 然后对\n\t `uint8_t*`类型的指针`+2`就可以跳过一个`uint16_t`, 虽然这些能够理解, 但实际应用这是第一次\n3. 对于如何更好的组织一个数据结构 有了更深的体会.\n4. 使用vector来存储剩余的包字节, 相比使用一个定长数组进行strcpy 方便了不少\n5. 使用erase擦除也是第一次实际应用\n6. 更好的使用指针\n\n定一下明天的任务吧, 试运行\n1. 定义游戏的json格式, 把所有的json都定义出来 √\n2. 游戏完成度达到能够正确解析包并分发到合理的部分即可 √\n3. 写一遍采坑博客-头文件互相引用 √\n4. 针对今天Git遇到的文件 在做研究下√\n5. 简单学习下jsoncpp的使用√\n\n## 七日 2020年2月7日10:14:53\n2020年2月7日10:14:53\n今天博客写的格外早, 主要是又遇到一个奇葩问题(其实是我自己使用有误)\n我昨天最后发现代码跑不起来, 就没有管, 今天看了下跑不起来是因为`未定义引用`\n好吧, 未定义引用, 我检查了一下发现不对啊, 我加上了\n`target_link_libraries(Guess -ljsoncpp network game)`\n我当时是这样写的, 结果就是报错`未定义引用`, 然后我把报错的部分另开一个项目放进去\n运行起来没问题?????.\n然后我把报错的代码放在我项目的main文件中, 结果原来的报错也消失了 main中的也没报错?????\n最后阴差阳错发现这个博客[初入职常见问题：gcc编译时对’xxxx’未定义的引用](https://blog.csdn.net/qq_33249383/article/details/88908218). 我发现其中的一段话\n```\n这个主要的原因是gcc编译的时候，各个文件依赖顺序的问题。\n在gcc编译的时候，如果文件a依赖于文件b，那么编译的时候必须把a放前面，b放后面。\n例如:在main.c中使用了pthread库相关函数，那么编译的时候必须是main.c在前，-lpthread在后。 gcc main.c -lpthread -o a.out 。\n```\n虽然使用的是cmake然后make 不确定编译器, 但我感觉应该试一试. 因为我的软件是编译`network.a`的时候报错,\n结果我改成了如下\n`target_link_libraries(Guess network game -ljsoncpp)`\n发现报错消失了......\n\n以前一直没有在意这里的顺序问题. 现在知道了问题所在 去搜索target_link_libraries顺序问题\n找到了一堆解释 哎....\n\n2020年2月7日18:10:20\n终于把头文件互相引用给搞明白了, 感觉这篇博客写的还可以吧, 就发到了[csdn上面](https://blog.csdn.net/qq_26790181/article/details/104213520),自己的博客上也会发的. 就先这样吧\n今天的第三项任务完成了, 概第四项任务了Git\n\n2020年2月7日22:17:41\n今天的任务完成了 还发现一个联系git的网站... 真的是纯偶然发现的[这个](https://learngitbranching.js.org/)\n大创那里今天看了下文档 找了找模板 还可以吧 明天的话\n\n1. 游戏把服务器端写完 一半\n2. 把找到的大创模板改到springboot上面去  后续再套\n3. 练习并搞懂两道中等算法题目\n4. 在有时间的话把牛客整理了\n\n## 八日九日 2020年2月9日18:04:35\n简单写下吧, 昨天 不小心挂彩了, 还好运气还好, 没有太大的伤, 不然特别时期真的难搞.\n不幸中的万幸\n\n今天一天都没写代码 或许明天会好一些把\n\n# 十日 \n2020年2月10日10:02:22\n今天问题不大了, 继续写游戏的服务器\n写完服务器后, 做算法题吧\n\n# 十四日\n昨天基本问题就不大了, 眼睛周围青了一圈成了大熊猫, 经过四天的休息 看东西倒是不流眼泪了.\n今天的话, 实际的学习方面有\n\n终于自己还是要找开源项目看看了, 不过今天2020年2月14日17:08:40头脑不是很清醒, 中午没有睡好. 看了个大概就没看了\n[nginx剖析](https://tengine.taobao.org/book/chapter_02.html)\n\n偶尔发现了一本书, 这不就是我想要看的吗!!!!!!, 准备看这本书 这本书从输入网址到网页返回都很详细的写了写\n![](https://pic2.zhimg.com/v2-1336c859990173751b77ad9eb4318602_r.jpg)\n\n# 十五日\n理论上大二寒假就要过完了. 昨天晚上想了很多\n\n先说一下游戏把: 感觉自己不喜欢玩手机游戏了, 手机游戏非肝即氪 自己没有时间去肝游戏, 肝游戏不会给你工作, 自己没有钱去氪金, 自己又非.抱着这种念头时间长了, 自己对游戏更加提不起兴趣了. 而我又想去做游戏, 一个不想玩游戏的人能做游戏吗? 虽说我的不想玩是在各种因素长时间影响下形成的.\n\n\n再说下我对编程吧: 怎么说呢, 我在大二上学期的上半学期之前, 都很喜欢写代码的, 我能在电脑前面坐上一整天. 后来我对代码提不起兴趣了. 原因的话昨天晚上整理了下.\n1. 目的不同了: 我在大二上学期的上半学期之前(包括大一整个学期)都是抱着解决某个问题去写软件的, 说起来是为自己写代码?首先就是我学的Javaweb为了解决校园网登录难的问题, 我用Java写一个客户端, 同时配上了后台和下载站(用的阿里云的OSS). 我记得的那段时间真的快乐. 后面我又为解决手动签到的问题, 做了个签到软件, 也是如此.------后来我学习的目的就是为了增进自己的知识(目的只有一个--进入大公司), 变成了为了学而学(之所以为了学而学是感觉时间真的有限, 我想在大三暑假能够实习, 我只有一年半的时间), 而不是之前, 通过做自己喜欢的东西不会了就去补一补. 长时间这样学习我大二上整个学期一个正经的项目都没有, 长时间为了学而学消磨了我的兴趣??\n2. 我发现我现在好像失去了对编程的乐趣, 现在写项目总想写出更优的结构, 总想写出大项目, 然而我的能力不足. 想实现和无法实现的思想一直持续着, 也是消磨的原因之一? 我现在在想我是不是期初就对linux服务器不感兴趣? 可我感觉当初自己确实想去的, 我想着游戏行业的人员兴趣基本相同, 能够一起做游戏,一边骂着策划脑洞一边做2333, 而不是做自己不喜欢的网站后端, 我发现目前自己都是一个人学习, 一个人做着, 何谈团队的乐趣?\n\n\n症状就如上了, 自己也得想想办法了.\n1. 首要任务找个人(找个团队)一起做游戏吧, 自己一个人的话, 说不上我向往的一起写代码的氛围\n2. 找到团队之后, 就能通过一边做游戏一边学习自己的不足了\n3. 我长时间的学习, 做不出自己满意的项目也是原因之一吧.\n4. 手机游戏的话, 暂时不去玩网游了. 我自己更适合单机? 找人做独立游戏?? emm不错\n\n# 十六日\n爆肝学习了一天3dmax , 现在是会基本的操作 能够完成一些简单的建模了.\n\n从B站找个那个课程也是很不错\n[3Dmax2018零基础入门教程（第一，二，三，四，五阶段）](https://www.bilibili.com/video/av18210293/)\n\n一天的事件我就从 P0看到了\tP51 过得很快, 但感觉掌握的还能接受\n\n-----\n|按键|功能|\n|---|---|\n|||\n|shift|绘制直线|\n|删除键|可以回退一次|\n|||\n|W|移动|\n|E|旋转|\n|R|缩放|\n|||\n|F3|线框显示模式|\n|F4|实体+线框限时模式|\n|||\n|Shift|按住可以复制|\n|||\n|Alt+T+A|阵列|\n|Alt+T+M|镜像|\n|Alt+A+对齐|\n|Shitf+I|间隔工具|\n|||\n|Ctrl+X|专家模式, 隐藏所有多余的东西 获得最大的空间|\n|Alt+X|半透明显示|\n|Ctrl+Shift+X|变换虚拟体显示切换 可以看到变换虚拟体的明显变化|\n|O|自适应降级|\n\n**编辑样条线->顶点**\n优化 在线上添加点\n焊接 连接两点\n自动焊接 两点在距离之内自动焊接\n\n**车削修改器**\n将二维图形 指定一个轴然后旋转 得到立体图形\n\n**可编辑多边形**\n*细分曲面*\n迭代次数2-3\n无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)\n*细分置换-经常使用置换网格WSM修改器*\n需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图\n*绘制变形-未学-用于雕刻地形*\n**倒角剖面和扫描的区别**\n1. 结合点不同\n2. 倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓\n3. 倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.\n\n------\n\n好了暑假也算是结束了\n\n哦对了 我还在做一个游戏 从YouTube上看到一个打砖块游戏.\n这只是开始, 因为我是做服务器的所以我要把游戏改成双人联机哒!!!!目前进展还不错\n\n我打算模仿一个知乎大佬在知乎更新下专栏? 貌似可以诶\n\n网上讲解服务器的不少 讲解客户端的不少  讲解一套的就少了\n\n好了博客整理下 寒假结束了","source":"_posts/学习记录-大二寒假.md","raw":"---\ntitle: 大二寒假及下学期学习记录\ndate: 2020-02-01 17:30:32\ncategories:\n  - 学习记录\n---\n\n现在是`2020年2月1日17:32:50` 寒假过半? 目前还不知道寒假什么时候开学. 为了自己能够前往心目中的公司, 学习是必不可少的.\n学习的同时 应该要注意总结, 防止一天或者一周下来白忙活\n我们寒假开始是一月九号 到我开始寒假学习的一月二十三号 这些天没有学习用来玩了, 好在后面拾了回来\n从二十三号到现在二月一号, 每天学习的长度和质量总算是在慢慢上升\n距离下一个寒假只剩下一年的时间了, 需要更加的努力, 为了大三暑假能够进入心中的公司 大三寒假的实习必不可少了. 加倍努力吧\n\n这篇博客的标题起初是`大二寒假学习记录`后来改成了`大二寒假及下学期学习记录`寒假的学习必不可少, 下学期更要抓紧时间了.\n\n# 二月\n## 一日2020年2月1日17:39:59\n\n前几天把博客从我自己的服务器迁移到了coding上, 方便以后我乱搞服务器, 现在服务器上没有重要的内容了\n至于实际的学习方面, 我开始整理我的博客[主要是这篇](https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/)这篇现在算告一段落了, 主要是把自己以前学过的用一用. 空洞的写下api\n理解不是很深刻.[这两天修改的这一篇](https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/). 第二篇自己缺少的东西很多, 由于当时学习到了后面实在是学不下去了.\n所以现在把后面的部分重新写了一下. 高级部分的线程和进程的部分 实在是太走马观花. 等我顺序学到了 再多写一些例子\n\n今天的话, 练习了下poll系统调用, 写了一个poll的demo, 然后是整理了下信号的部分, 信号这里整理的依然很少 平时用到的不多, 需要多加使用\n主要是定时器这里了 定时器把原来的内容删掉了 从新写目前只写完了socket定时\n\n接下来打算还是多写一些项目 多思考一些 等我整理完了高级部分 就准备去看开源项目?每次看开源项目都感觉自己差的太多, 不知道从哪里看起\n所以搭配着别人的笔记学习下看源码. 当然看源码之前还是要会大概的使用. 高级部分自然包括了libevent的使用部分\n\n跑去写项目了\n\n## 二日2020年2月2日18:03:23\n\n罪过罪过, 昨天晚上十一点半 玩了一把军团TD 结果玩到了十二点半 ..... 最后一点半才睡觉\n今天早上小十一点才起床.\n我依稀记得我八点被闹钟叫起来emm 然后想着定八点半的闹钟 再睡一会, 结果闹钟没定我就睡着了.\n\n起来后整理了整理吃了午饭, 就下午小一点了, 打开高级部分 学习`信号SIGALRM定时`\n\n代码量就400行 一直到我写今天的博客 才算完工\n\n**先写一下遇到的一个问题吧**\n首先表现出来的是`超时后 服务器没有断开连接`\n然后我去打断点, 发现不是定时器链表部分的问题. 是定时信号没有触发`epoll_wait`.\n这里我看了下代码, 发现定时器没有启动加上了`alarm(5)`, 我本意是理解了书上的代码 再去自己写, 结果还是理解的不深刻, 竟然丢了启动定时器的函数.\n然后我又运行了下`发现还是没有运行到`\n然后发现`epoll_wait 返回-1 设置EINTR`, 后来查阅了下说是被信号处理器中断, 思考可能是与IDE下断点有关??????\n最后发现自己没有把信号的管道添加到`epollfd`中再一细看发现丢了关于信号管道的四行代码...\n\n这个问题应该是很容易排查. 事后感觉应该这样思考\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/epoll%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.png)\n以后尽量总结正确的思考模式, 虽然不知道有没有用 但要试一试.\n\n**项目收获方面**\n虽然这个项目只有400多行代码, 但我自己是绝对写不出来的. 只能尽量总结书上代码的好处\n1. 首先肯定是使用alarm超时产生信号SIGALRM来触发回调函数 实现定时\n2. 信号回调函数, 没有直接去触发定时器tick函数, 而是通过一个管道传到了epollfd中, 然后从epollfd的函数中触发相关的if 再去调用tick函数\n```c++\nvoid timer_handler() //真正的生效部分\n{\n    timer_lst.tick();\n    alarm(TIMESLOT);\n}\nvoid sig_handler(int sig)\n{\n    int save_errno = errno;\n    int msg = sig;\n    send(pipefd[1], (char*)&msg, 1, 0); // pipefd[0]注册进了epoll中 接受到来的信号\n    errno = save_errno;\n}\n\nvoid addsig(int sig)// 信号添加\n{\n    struct sigaction sa{};\n    sa.sa_flags |= SA_RESTART;\n    sa.sa_handler = sig_handler;\n    sigfillset(&sa.sa_mask);\n    exit_if(sigaction(sig, &sa, nullptr) == -1, \"add sig error\");\n}\n\nchar signals[1024]; // 信号接收, 可能存在多个信号 所以用返回的字节数来逐个取出信号\nret = recv(sockfd, signals, sizeof(signals), 0); 取出后使用switch来分离信号\n```\n3. 将大部分常量 #define\n大概只能总结出这一些来了, 完整的代码我贴在github上吧\n\n## 五日 2020年2月6日09:16:23\n三和四号 基本都在玩FF14, 发现自己并不是玩游戏了, 感觉被FF14玩了, 就是那种感觉累了不想玩了, 但却离自己定的小目标远 然后坚持\nemm 其实感觉这个时候应该下游戏.\n想想自己这大学一年半玩过的游戏 血族我算是玩的时间最长的大概前前后后我玩了五年, 应该是上半年把 我弃坑了. 游戏后面太氪了, 不得不退游了.\n后面崩三啥的也玩过, 发现自己并不适合肝的游戏. 最近一个月入坑了fgo, 开始的几个星期还是玩的累了, 自己太肝了, 最近这几天感觉休闲了不少, \n心态也正常了, 所以暂且会玩一玩.\n\n主要还是后面这些吧, 我发现自己逐渐有了一个念头: 累了就去玩会游戏, 就去看会直播, 刷刷B站. 后来我感觉这些浪费时间就去搜索了一下\n**玩游戏算浪费时间吗**, 刚才去找了下. 没找到我之前看过的那篇. 结论就是为什么自己不是累了就去小睡一下, 或者看看书,再或者刷刷新的科技圈\n长长见识? 自己尝试了看书, 发现自己并不是太抗拒. 以后试试把.\n\n最后自己作为一个想开发游戏的人, 总感觉不玩游戏是不合适的, 但要玩的适度, 毕竟自己还有一年的时间就要找寒假实习, 为了自己的大三暑假进入大厂打下基础.\n平衡好才是上策.\n\n接下文, 我发现自己有点?(自信点把点去掉)好高骛远了, 好高骛远会消磨一个人的兴趣和信心. 最终决定不做什么大游戏, 不研究什么框架, 先用自己所会的写一个小游戏,\n一是为了试着重新拾起兴趣, 二是如果只学而不去写项目, 没有太大收获的\n\n昨天一天都是策划和编写一个游戏, 游戏逻辑十分的简单. 猜数字 初期的流程图我大概画了下, 姑且算作第一版吧 下面放出来, 我后面可以逐渐丰富这个东西 加上日志登录\n断线重连等等功能.感觉还是可以的~~ 尽管逻辑很简单.\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%B5%81%E7%A8%8B1.png)\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%911.png)\n\n听说在写代码前规划好, 可以更好地组织代码, 昨天尝试了下感觉还不错. 我在写代码前把游戏的流程图画了一下, 然后标上了哪里会有什么数据交互,\n之后我去写了数据包头格式\n**头部**\n\n| 偏移量 | 长度 | 含义\n| --- | --- | --- |\n| 0 | 4 | 封包总大小 |\n| 4 | 2 | 头部长度 |\n| 6 | 2 | 操作码 |\n\n**操作码**\n\n| 代码 | 含义 | 数据格式 |\n| --- | --- | --- |\n| 00 | 登录 | |\n| 01 | 桌位信息(服务器发送桌位列表) | [1000-0-4][1001-0-4] |\n| 02 | 桌位操作信息(客户端加入 退出桌位) | 1000 |\n| 03 | 服务器桌位操作信息反馈(加入退出成功1 加入退出失败0) | 1 |\n| 04 | 准备 | 无 |\n| 05 | 取消准备 | 无 |\n| 06 | 服务器广播桌位信息 | 4[11][10][00][00] (桌位总数, 有人1 准备1) |\n| A1 | 服务器广播游戏开始 | 空 |\n| A2 | 服务器下发轮到的客户端 | 空 |\n| A3 | 客户端发送猜测的数字 | 50 |\n| A4 | 服务器发送猜测数字反馈 (数据合理1, 数据非法0) | 1 |\n| A5 | 服务器广播游戏状态 | 50-0-75[A][B] (A玩家猜出50 当前范围 0到75 B玩家准备) |\n\n然后草拟了一下 用到的类 用到的数据结构 分几个类 怎么联系起来, 最终我才去写代码, 感觉比一边写\n一边想要好不少. 写的过程中也发现了一些问题\n1. `EPOLLRDHUP`这个绑定在listenfd还是newfd?? 如果是newfd还能理解下原理, listenfd就有点理解不了.(试了下, 是newfd)\n2. \n```c++\nFoo *a;\nFoos b[3];\nb[1] = *a;\n// 修改a不会影响b[1], 这个问题听到过, 自己真正试了试才发现如此\n```\n\n姑且昨天的就补上这些吧. 今天打算把游戏的服务器跑起来\n\n## 六日 2020年2月6日22:12:36\n忙忙碌碌的一天就又要结束了. 今天一天把剩下的一部分逻辑代码写了一部分. 主要是写自定义协议的序列化和反序列化. 起初打算\n用char* body 来存储, 按照上面定义的格式传输. 后来一想, 这样我就不就是在原地打转吗. 就去网上找了找相关的代码, 看看别人怎么写的\n\n主要是看的这一篇博客[手把手教你实现自定义的应用层协议](https://blog.csdn.net/ACb0y/article/details/61421006)\n看了之后收获不少. 收获总结在下面吧\n\n1. 两个头文件互相include\n\t这个是今天了解的最奇葩的一个问题, 如果两个头文件互相include 会出问题. 这个明天开一篇 采坑博客\n\t与此连带的还有class 前置声明, 再者可以到编译相关的问题\n2. 今天了解了一下CMAKE和MAKE的区别和联系, 总算知道了为啥好多安装的时候先cmake 再 make\n3. 还是关于CMAKE 稍微整理了点CMAKE的使用. 随用随整理, 目前不打算一次性整理太多\n4. Git操作不熟练. 我本地写好了代码文件, commit 然后从服务器pull了一个仅包含readme的仓库, 然后reset\n\t自己写的代码文件全没了, 只剩下README.md 还好之前整理过reflog, 明天也需要在整理下\n5. 安装了jsoncpp, 亿图图示等一些软件. 写了下关于字节对齐的问题. 亿图图示目前感觉挺不错\n\n代码方面的收获 主要就是看的那篇博客学到的.\n1. 首先就是学会了自定了协议 序列化和反序列化怎么写 代码更美. 虽然可能我看的博客可能不是最好的, \n\t但对我目前来说足够美了, 不过写一遍远远不够.\n2. 学到了巧妙地对 `uint8_t*`类型的指针(指向流数据缓冲区)转换成`uint16_t*`等指针类型, 进行解引用 得到原本的数据, 然后对\n\t `uint8_t*`类型的指针`+2`就可以跳过一个`uint16_t`, 虽然这些能够理解, 但实际应用这是第一次\n3. 对于如何更好的组织一个数据结构 有了更深的体会.\n4. 使用vector来存储剩余的包字节, 相比使用一个定长数组进行strcpy 方便了不少\n5. 使用erase擦除也是第一次实际应用\n6. 更好的使用指针\n\n定一下明天的任务吧, 试运行\n1. 定义游戏的json格式, 把所有的json都定义出来 √\n2. 游戏完成度达到能够正确解析包并分发到合理的部分即可 √\n3. 写一遍采坑博客-头文件互相引用 √\n4. 针对今天Git遇到的文件 在做研究下√\n5. 简单学习下jsoncpp的使用√\n\n## 七日 2020年2月7日10:14:53\n2020年2月7日10:14:53\n今天博客写的格外早, 主要是又遇到一个奇葩问题(其实是我自己使用有误)\n我昨天最后发现代码跑不起来, 就没有管, 今天看了下跑不起来是因为`未定义引用`\n好吧, 未定义引用, 我检查了一下发现不对啊, 我加上了\n`target_link_libraries(Guess -ljsoncpp network game)`\n我当时是这样写的, 结果就是报错`未定义引用`, 然后我把报错的部分另开一个项目放进去\n运行起来没问题?????.\n然后我把报错的代码放在我项目的main文件中, 结果原来的报错也消失了 main中的也没报错?????\n最后阴差阳错发现这个博客[初入职常见问题：gcc编译时对’xxxx’未定义的引用](https://blog.csdn.net/qq_33249383/article/details/88908218). 我发现其中的一段话\n```\n这个主要的原因是gcc编译的时候，各个文件依赖顺序的问题。\n在gcc编译的时候，如果文件a依赖于文件b，那么编译的时候必须把a放前面，b放后面。\n例如:在main.c中使用了pthread库相关函数，那么编译的时候必须是main.c在前，-lpthread在后。 gcc main.c -lpthread -o a.out 。\n```\n虽然使用的是cmake然后make 不确定编译器, 但我感觉应该试一试. 因为我的软件是编译`network.a`的时候报错,\n结果我改成了如下\n`target_link_libraries(Guess network game -ljsoncpp)`\n发现报错消失了......\n\n以前一直没有在意这里的顺序问题. 现在知道了问题所在 去搜索target_link_libraries顺序问题\n找到了一堆解释 哎....\n\n2020年2月7日18:10:20\n终于把头文件互相引用给搞明白了, 感觉这篇博客写的还可以吧, 就发到了[csdn上面](https://blog.csdn.net/qq_26790181/article/details/104213520),自己的博客上也会发的. 就先这样吧\n今天的第三项任务完成了, 概第四项任务了Git\n\n2020年2月7日22:17:41\n今天的任务完成了 还发现一个联系git的网站... 真的是纯偶然发现的[这个](https://learngitbranching.js.org/)\n大创那里今天看了下文档 找了找模板 还可以吧 明天的话\n\n1. 游戏把服务器端写完 一半\n2. 把找到的大创模板改到springboot上面去  后续再套\n3. 练习并搞懂两道中等算法题目\n4. 在有时间的话把牛客整理了\n\n## 八日九日 2020年2月9日18:04:35\n简单写下吧, 昨天 不小心挂彩了, 还好运气还好, 没有太大的伤, 不然特别时期真的难搞.\n不幸中的万幸\n\n今天一天都没写代码 或许明天会好一些把\n\n# 十日 \n2020年2月10日10:02:22\n今天问题不大了, 继续写游戏的服务器\n写完服务器后, 做算法题吧\n\n# 十四日\n昨天基本问题就不大了, 眼睛周围青了一圈成了大熊猫, 经过四天的休息 看东西倒是不流眼泪了.\n今天的话, 实际的学习方面有\n\n终于自己还是要找开源项目看看了, 不过今天2020年2月14日17:08:40头脑不是很清醒, 中午没有睡好. 看了个大概就没看了\n[nginx剖析](https://tengine.taobao.org/book/chapter_02.html)\n\n偶尔发现了一本书, 这不就是我想要看的吗!!!!!!, 准备看这本书 这本书从输入网址到网页返回都很详细的写了写\n![](https://pic2.zhimg.com/v2-1336c859990173751b77ad9eb4318602_r.jpg)\n\n# 十五日\n理论上大二寒假就要过完了. 昨天晚上想了很多\n\n先说一下游戏把: 感觉自己不喜欢玩手机游戏了, 手机游戏非肝即氪 自己没有时间去肝游戏, 肝游戏不会给你工作, 自己没有钱去氪金, 自己又非.抱着这种念头时间长了, 自己对游戏更加提不起兴趣了. 而我又想去做游戏, 一个不想玩游戏的人能做游戏吗? 虽说我的不想玩是在各种因素长时间影响下形成的.\n\n\n再说下我对编程吧: 怎么说呢, 我在大二上学期的上半学期之前, 都很喜欢写代码的, 我能在电脑前面坐上一整天. 后来我对代码提不起兴趣了. 原因的话昨天晚上整理了下.\n1. 目的不同了: 我在大二上学期的上半学期之前(包括大一整个学期)都是抱着解决某个问题去写软件的, 说起来是为自己写代码?首先就是我学的Javaweb为了解决校园网登录难的问题, 我用Java写一个客户端, 同时配上了后台和下载站(用的阿里云的OSS). 我记得的那段时间真的快乐. 后面我又为解决手动签到的问题, 做了个签到软件, 也是如此.------后来我学习的目的就是为了增进自己的知识(目的只有一个--进入大公司), 变成了为了学而学(之所以为了学而学是感觉时间真的有限, 我想在大三暑假能够实习, 我只有一年半的时间), 而不是之前, 通过做自己喜欢的东西不会了就去补一补. 长时间这样学习我大二上整个学期一个正经的项目都没有, 长时间为了学而学消磨了我的兴趣??\n2. 我发现我现在好像失去了对编程的乐趣, 现在写项目总想写出更优的结构, 总想写出大项目, 然而我的能力不足. 想实现和无法实现的思想一直持续着, 也是消磨的原因之一? 我现在在想我是不是期初就对linux服务器不感兴趣? 可我感觉当初自己确实想去的, 我想着游戏行业的人员兴趣基本相同, 能够一起做游戏,一边骂着策划脑洞一边做2333, 而不是做自己不喜欢的网站后端, 我发现目前自己都是一个人学习, 一个人做着, 何谈团队的乐趣?\n\n\n症状就如上了, 自己也得想想办法了.\n1. 首要任务找个人(找个团队)一起做游戏吧, 自己一个人的话, 说不上我向往的一起写代码的氛围\n2. 找到团队之后, 就能通过一边做游戏一边学习自己的不足了\n3. 我长时间的学习, 做不出自己满意的项目也是原因之一吧.\n4. 手机游戏的话, 暂时不去玩网游了. 我自己更适合单机? 找人做独立游戏?? emm不错\n\n# 十六日\n爆肝学习了一天3dmax , 现在是会基本的操作 能够完成一些简单的建模了.\n\n从B站找个那个课程也是很不错\n[3Dmax2018零基础入门教程（第一，二，三，四，五阶段）](https://www.bilibili.com/video/av18210293/)\n\n一天的事件我就从 P0看到了\tP51 过得很快, 但感觉掌握的还能接受\n\n-----\n|按键|功能|\n|---|---|\n|||\n|shift|绘制直线|\n|删除键|可以回退一次|\n|||\n|W|移动|\n|E|旋转|\n|R|缩放|\n|||\n|F3|线框显示模式|\n|F4|实体+线框限时模式|\n|||\n|Shift|按住可以复制|\n|||\n|Alt+T+A|阵列|\n|Alt+T+M|镜像|\n|Alt+A+对齐|\n|Shitf+I|间隔工具|\n|||\n|Ctrl+X|专家模式, 隐藏所有多余的东西 获得最大的空间|\n|Alt+X|半透明显示|\n|Ctrl+Shift+X|变换虚拟体显示切换 可以看到变换虚拟体的明显变化|\n|O|自适应降级|\n\n**编辑样条线->顶点**\n优化 在线上添加点\n焊接 连接两点\n自动焊接 两点在距离之内自动焊接\n\n**车削修改器**\n将二维图形 指定一个轴然后旋转 得到立体图形\n\n**可编辑多边形**\n*细分曲面*\n迭代次数2-3\n无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)\n*细分置换-经常使用置换网格WSM修改器*\n需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图\n*绘制变形-未学-用于雕刻地形*\n**倒角剖面和扫描的区别**\n1. 结合点不同\n2. 倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓\n3. 倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.\n\n------\n\n好了暑假也算是结束了\n\n哦对了 我还在做一个游戏 从YouTube上看到一个打砖块游戏.\n这只是开始, 因为我是做服务器的所以我要把游戏改成双人联机哒!!!!目前进展还不错\n\n我打算模仿一个知乎大佬在知乎更新下专栏? 貌似可以诶\n\n网上讲解服务器的不少 讲解客户端的不少  讲解一套的就少了\n\n好了博客整理下 寒假结束了","slug":"学习记录-大二寒假","published":1,"updated":"2020-03-14T10:40:21.181Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvh00218cuo8yiahvxf","content":"<p>现在是<code>2020年2月1日17:32:50</code> 寒假过半? 目前还不知道寒假什么时候开学. 为了自己能够前往心目中的公司, 学习是必不可少的.<br>学习的同时 应该要注意总结, 防止一天或者一周下来白忙活<br>我们寒假开始是一月九号 到我开始寒假学习的一月二十三号 这些天没有学习用来玩了, 好在后面拾了回来<br>从二十三号到现在二月一号, 每天学习的长度和质量总算是在慢慢上升<br>距离下一个寒假只剩下一年的时间了, 需要更加的努力, 为了大三暑假能够进入心中的公司 大三寒假的实习必不可少了. 加倍努力吧</p>\n<p>这篇博客的标题起初是<code>大二寒假学习记录</code>后来改成了<code>大二寒假及下学期学习记录</code>寒假的学习必不可少, 下学期更要抓紧时间了.</p>\n<h1 id=\"二月\"><a href=\"#二月\" class=\"headerlink\" title=\"二月\"></a>二月</h1><h2 id=\"一日2020年2月1日17-39-59\"><a href=\"#一日2020年2月1日17-39-59\" class=\"headerlink\" title=\"一日2020年2月1日17:39:59\"></a>一日2020年2月1日17:39:59</h2><p>前几天把博客从我自己的服务器迁移到了coding上, 方便以后我乱搞服务器, 现在服务器上没有重要的内容了<br>至于实际的学习方面, 我开始整理我的博客<a href=\"https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/\">主要是这篇</a>这篇现在算告一段落了, 主要是把自己以前学过的用一用. 空洞的写下api<br>理解不是很深刻.<a href=\"https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/\">这两天修改的这一篇</a>. 第二篇自己缺少的东西很多, 由于当时学习到了后面实在是学不下去了.<br>所以现在把后面的部分重新写了一下. 高级部分的线程和进程的部分 实在是太走马观花. 等我顺序学到了 再多写一些例子</p>\n<p>今天的话, 练习了下poll系统调用, 写了一个poll的demo, 然后是整理了下信号的部分, 信号这里整理的依然很少 平时用到的不多, 需要多加使用<br>主要是定时器这里了 定时器把原来的内容删掉了 从新写目前只写完了socket定时</p>\n<p>接下来打算还是多写一些项目 多思考一些 等我整理完了高级部分 就准备去看开源项目?每次看开源项目都感觉自己差的太多, 不知道从哪里看起<br>所以搭配着别人的笔记学习下看源码. 当然看源码之前还是要会大概的使用. 高级部分自然包括了libevent的使用部分</p>\n<p>跑去写项目了</p>\n<h2 id=\"二日2020年2月2日18-03-23\"><a href=\"#二日2020年2月2日18-03-23\" class=\"headerlink\" title=\"二日2020年2月2日18:03:23\"></a>二日2020年2月2日18:03:23</h2><p>罪过罪过, 昨天晚上十一点半 玩了一把军团TD 结果玩到了十二点半 ….. 最后一点半才睡觉<br>今天早上小十一点才起床.<br>我依稀记得我八点被闹钟叫起来emm 然后想着定八点半的闹钟 再睡一会, 结果闹钟没定我就睡着了.</p>\n<p>起来后整理了整理吃了午饭, 就下午小一点了, 打开高级部分 学习<code>信号SIGALRM定时</code></p>\n<p>代码量就400行 一直到我写今天的博客 才算完工</p>\n<p><strong>先写一下遇到的一个问题吧</strong><br>首先表现出来的是<code>超时后 服务器没有断开连接</code><br>然后我去打断点, 发现不是定时器链表部分的问题. 是定时信号没有触发<code>epoll_wait</code>.<br>这里我看了下代码, 发现定时器没有启动加上了<code>alarm(5)</code>, 我本意是理解了书上的代码 再去自己写, 结果还是理解的不深刻, 竟然丢了启动定时器的函数.<br>然后我又运行了下<code>发现还是没有运行到</code><br>然后发现<code>epoll_wait 返回-1 设置EINTR</code>, 后来查阅了下说是被信号处理器中断, 思考可能是与IDE下断点有关??????<br>最后发现自己没有把信号的管道添加到<code>epollfd</code>中再一细看发现丢了关于信号管道的四行代码…</p>\n<p>这个问题应该是很容易排查. 事后感觉应该这样思考<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/epoll%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.png\" alt=\"\"><br>以后尽量总结正确的思考模式, 虽然不知道有没有用 但要试一试.</p>\n<p><strong>项目收获方面</strong><br>虽然这个项目只有400多行代码, 但我自己是绝对写不出来的. 只能尽量总结书上代码的好处</p>\n<ol>\n<li>首先肯定是使用alarm超时产生信号SIGALRM来触发回调函数 实现定时</li>\n<li>信号回调函数, 没有直接去触发定时器tick函数, 而是通过一个管道传到了epollfd中, 然后从epollfd的函数中触发相关的if 再去调用tick函数<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">timer_handler</span><span class=\"params\">()</span> <span class=\"comment\">//真正的生效部分</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    timer_lst.tick();</span><br><span class=\"line\">    alarm(TIMESLOT);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sig_handler</span><span class=\"params\">(<span class=\"keyword\">int</span> sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> save_errno = errno;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> msg = sig;</span><br><span class=\"line\">    send(pipefd[<span class=\"number\">1</span>], (<span class=\"keyword\">char</span>*)&amp;msg, <span class=\"number\">1</span>, <span class=\"number\">0</span>); <span class=\"comment\">// pipefd[0]注册进了epoll中 接受到来的信号</span></span><br><span class=\"line\">    errno = save_errno;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addsig</span><span class=\"params\">(<span class=\"keyword\">int</span> sig)</span><span class=\"comment\">// 信号添加</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">sa</span>&#123;</span>&#125;;</span><br><span class=\"line\">    sa.sa_flags |= SA_RESTART;</span><br><span class=\"line\">    sa.sa_handler = sig_handler;</span><br><span class=\"line\">    sigfillset(&amp;sa.sa_mask);</span><br><span class=\"line\">    exit_if(sigaction(sig, &amp;sa, <span class=\"literal\">nullptr</span>) == <span class=\"number\">-1</span>, <span class=\"string\">\"add sig error\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> signals[<span class=\"number\">1024</span>]; <span class=\"comment\">// 信号接收, 可能存在多个信号 所以用返回的字节数来逐个取出信号</span></span><br><span class=\"line\">ret = recv(sockfd, signals, <span class=\"keyword\">sizeof</span>(signals), <span class=\"number\">0</span>); 取出后使用<span class=\"keyword\">switch</span>来分离信号</span><br></pre></td></tr></table></figure></li>\n<li>将大部分常量 #define<br>大概只能总结出这一些来了, 完整的代码我贴在github上吧</li>\n</ol>\n<h2 id=\"五日-2020年2月6日09-16-23\"><a href=\"#五日-2020年2月6日09-16-23\" class=\"headerlink\" title=\"五日 2020年2月6日09:16:23\"></a>五日 2020年2月6日09:16:23</h2><p>三和四号 基本都在玩FF14, 发现自己并不是玩游戏了, 感觉被FF14玩了, 就是那种感觉累了不想玩了, 但却离自己定的小目标远 然后坚持<br>emm 其实感觉这个时候应该下游戏.<br>想想自己这大学一年半玩过的游戏 血族我算是玩的时间最长的大概前前后后我玩了五年, 应该是上半年把 我弃坑了. 游戏后面太氪了, 不得不退游了.<br>后面崩三啥的也玩过, 发现自己并不适合肝的游戏. 最近一个月入坑了fgo, 开始的几个星期还是玩的累了, 自己太肝了, 最近这几天感觉休闲了不少,<br>心态也正常了, 所以暂且会玩一玩.</p>\n<p>主要还是后面这些吧, 我发现自己逐渐有了一个念头: 累了就去玩会游戏, 就去看会直播, 刷刷B站. 后来我感觉这些浪费时间就去搜索了一下<br><strong>玩游戏算浪费时间吗</strong>, 刚才去找了下. 没找到我之前看过的那篇. 结论就是为什么自己不是累了就去小睡一下, 或者看看书,再或者刷刷新的科技圈<br>长长见识? 自己尝试了看书, 发现自己并不是太抗拒. 以后试试把.</p>\n<p>最后自己作为一个想开发游戏的人, 总感觉不玩游戏是不合适的, 但要玩的适度, 毕竟自己还有一年的时间就要找寒假实习, 为了自己的大三暑假进入大厂打下基础.<br>平衡好才是上策.</p>\n<p>接下文, 我发现自己有点?(自信点把点去掉)好高骛远了, 好高骛远会消磨一个人的兴趣和信心. 最终决定不做什么大游戏, 不研究什么框架, 先用自己所会的写一个小游戏,<br>一是为了试着重新拾起兴趣, 二是如果只学而不去写项目, 没有太大收获的</p>\n<p>昨天一天都是策划和编写一个游戏, 游戏逻辑十分的简单. 猜数字 初期的流程图我大概画了下, 姑且算作第一版吧 下面放出来, 我后面可以逐渐丰富这个东西 加上日志登录<br>断线重连等等功能.感觉还是可以的~~ 尽管逻辑很简单.<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%B5%81%E7%A8%8B1.png\" alt=\"\"><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%911.png\" alt=\"\"></p>\n<p>听说在写代码前规划好, 可以更好地组织代码, 昨天尝试了下感觉还不错. 我在写代码前把游戏的流程图画了一下, 然后标上了哪里会有什么数据交互,<br>之后我去写了数据包头格式<br><strong>头部</strong></p>\n<table>\n<thead>\n<tr>\n<th>偏移量</th>\n<th>长度</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>4</td>\n<td>封包总大小</td>\n</tr>\n<tr>\n<td>4</td>\n<td>2</td>\n<td>头部长度</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2</td>\n<td>操作码</td>\n</tr>\n</tbody></table>\n<p><strong>操作码</strong></p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n<th>数据格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>00</td>\n<td>登录</td>\n<td></td>\n</tr>\n<tr>\n<td>01</td>\n<td>桌位信息(服务器发送桌位列表)</td>\n<td>[1000-0-4][1001-0-4]</td>\n</tr>\n<tr>\n<td>02</td>\n<td>桌位操作信息(客户端加入 退出桌位)</td>\n<td>1000</td>\n</tr>\n<tr>\n<td>03</td>\n<td>服务器桌位操作信息反馈(加入退出成功1 加入退出失败0)</td>\n<td>1</td>\n</tr>\n<tr>\n<td>04</td>\n<td>准备</td>\n<td>无</td>\n</tr>\n<tr>\n<td>05</td>\n<td>取消准备</td>\n<td>无</td>\n</tr>\n<tr>\n<td>06</td>\n<td>服务器广播桌位信息</td>\n<td>4[11][10][00][00] (桌位总数, 有人1 准备1)</td>\n</tr>\n<tr>\n<td>A1</td>\n<td>服务器广播游戏开始</td>\n<td>空</td>\n</tr>\n<tr>\n<td>A2</td>\n<td>服务器下发轮到的客户端</td>\n<td>空</td>\n</tr>\n<tr>\n<td>A3</td>\n<td>客户端发送猜测的数字</td>\n<td>50</td>\n</tr>\n<tr>\n<td>A4</td>\n<td>服务器发送猜测数字反馈 (数据合理1, 数据非法0)</td>\n<td>1</td>\n</tr>\n<tr>\n<td>A5</td>\n<td>服务器广播游戏状态</td>\n<td>50-0-75[A][B] (A玩家猜出50 当前范围 0到75 B玩家准备)</td>\n</tr>\n</tbody></table>\n<p>然后草拟了一下 用到的类 用到的数据结构 分几个类 怎么联系起来, 最终我才去写代码, 感觉比一边写<br>一边想要好不少. 写的过程中也发现了一些问题</p>\n<ol>\n<li><code>EPOLLRDHUP</code>这个绑定在listenfd还是newfd?? 如果是newfd还能理解下原理, listenfd就有点理解不了.(试了下, 是newfd)</li>\n<li><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo *a;</span><br><span class=\"line\">Foos b[<span class=\"number\">3</span>];</span><br><span class=\"line\">b[<span class=\"number\">1</span>] = *a;</span><br><span class=\"line\"><span class=\"comment\">// 修改a不会影响b[1], 这个问题听到过, 自己真正试了试才发现如此</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>姑且昨天的就补上这些吧. 今天打算把游戏的服务器跑起来</p>\n<h2 id=\"六日-2020年2月6日22-12-36\"><a href=\"#六日-2020年2月6日22-12-36\" class=\"headerlink\" title=\"六日 2020年2月6日22:12:36\"></a>六日 2020年2月6日22:12:36</h2><p>忙忙碌碌的一天就又要结束了. 今天一天把剩下的一部分逻辑代码写了一部分. 主要是写自定义协议的序列化和反序列化. 起初打算<br>用char* body 来存储, 按照上面定义的格式传输. 后来一想, 这样我就不就是在原地打转吗. 就去网上找了找相关的代码, 看看别人怎么写的</p>\n<p>主要是看的这一篇博客<a href=\"https://blog.csdn.net/ACb0y/article/details/61421006\" target=\"_blank\" rel=\"noopener\">手把手教你实现自定义的应用层协议</a><br>看了之后收获不少. 收获总结在下面吧</p>\n<ol>\n<li>两个头文件互相include<br> 这个是今天了解的最奇葩的一个问题, 如果两个头文件互相include 会出问题. 这个明天开一篇 采坑博客<br> 与此连带的还有class 前置声明, 再者可以到编译相关的问题</li>\n<li>今天了解了一下CMAKE和MAKE的区别和联系, 总算知道了为啥好多安装的时候先cmake 再 make</li>\n<li>还是关于CMAKE 稍微整理了点CMAKE的使用. 随用随整理, 目前不打算一次性整理太多</li>\n<li>Git操作不熟练. 我本地写好了代码文件, commit 然后从服务器pull了一个仅包含readme的仓库, 然后reset<br> 自己写的代码文件全没了, 只剩下README.md 还好之前整理过reflog, 明天也需要在整理下</li>\n<li>安装了jsoncpp, 亿图图示等一些软件. 写了下关于字节对齐的问题. 亿图图示目前感觉挺不错</li>\n</ol>\n<p>代码方面的收获 主要就是看的那篇博客学到的.</p>\n<ol>\n<li>首先就是学会了自定了协议 序列化和反序列化怎么写 代码更美. 虽然可能我看的博客可能不是最好的,<br> 但对我目前来说足够美了, 不过写一遍远远不够.</li>\n<li>学到了巧妙地对 <code>uint8_t*</code>类型的指针(指向流数据缓冲区)转换成<code>uint16_t*</code>等指针类型, 进行解引用 得到原本的数据, 然后对<br>  <code>uint8_t*</code>类型的指针<code>+2</code>就可以跳过一个<code>uint16_t</code>, 虽然这些能够理解, 但实际应用这是第一次</li>\n<li>对于如何更好的组织一个数据结构 有了更深的体会.</li>\n<li>使用vector来存储剩余的包字节, 相比使用一个定长数组进行strcpy 方便了不少</li>\n<li>使用erase擦除也是第一次实际应用</li>\n<li>更好的使用指针</li>\n</ol>\n<p>定一下明天的任务吧, 试运行</p>\n<ol>\n<li>定义游戏的json格式, 把所有的json都定义出来 √</li>\n<li>游戏完成度达到能够正确解析包并分发到合理的部分即可 √</li>\n<li>写一遍采坑博客-头文件互相引用 √</li>\n<li>针对今天Git遇到的文件 在做研究下√</li>\n<li>简单学习下jsoncpp的使用√</li>\n</ol>\n<h2 id=\"七日-2020年2月7日10-14-53\"><a href=\"#七日-2020年2月7日10-14-53\" class=\"headerlink\" title=\"七日 2020年2月7日10:14:53\"></a>七日 2020年2月7日10:14:53</h2><p>2020年2月7日10:14:53<br>今天博客写的格外早, 主要是又遇到一个奇葩问题(其实是我自己使用有误)<br>我昨天最后发现代码跑不起来, 就没有管, 今天看了下跑不起来是因为<code>未定义引用</code><br>好吧, 未定义引用, 我检查了一下发现不对啊, 我加上了<br><code>target_link_libraries(Guess -ljsoncpp network game)</code><br>我当时是这样写的, 结果就是报错<code>未定义引用</code>, 然后我把报错的部分另开一个项目放进去<br>运行起来没问题?????.<br>然后我把报错的代码放在我项目的main文件中, 结果原来的报错也消失了 main中的也没报错?????<br>最后阴差阳错发现这个博客<a href=\"https://blog.csdn.net/qq_33249383/article/details/88908218\" target=\"_blank\" rel=\"noopener\">初入职常见问题：gcc编译时对’xxxx’未定义的引用</a>. 我发现其中的一段话</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个主要的原因是gcc编译的时候，各个文件依赖顺序的问题。</span><br><span class=\"line\">在gcc编译的时候，如果文件a依赖于文件b，那么编译的时候必须把a放前面，b放后面。</span><br><span class=\"line\">例如:在main.c中使用了pthread库相关函数，那么编译的时候必须是main.c在前，-lpthread在后。 gcc main.c -lpthread -o a.out 。</span><br></pre></td></tr></table></figure>\n<p>虽然使用的是cmake然后make 不确定编译器, 但我感觉应该试一试. 因为我的软件是编译<code>network.a</code>的时候报错,<br>结果我改成了如下<br><code>target_link_libraries(Guess network game -ljsoncpp)</code><br>发现报错消失了……</p>\n<p>以前一直没有在意这里的顺序问题. 现在知道了问题所在 去搜索target_link_libraries顺序问题<br>找到了一堆解释 哎….</p>\n<p>2020年2月7日18:10:20<br>终于把头文件互相引用给搞明白了, 感觉这篇博客写的还可以吧, 就发到了<a href=\"https://blog.csdn.net/qq_26790181/article/details/104213520\" target=\"_blank\" rel=\"noopener\">csdn上面</a>,自己的博客上也会发的. 就先这样吧<br>今天的第三项任务完成了, 概第四项任务了Git</p>\n<p>2020年2月7日22:17:41<br>今天的任务完成了 还发现一个联系git的网站… 真的是纯偶然发现的<a href=\"https://learngitbranching.js.org/\" target=\"_blank\" rel=\"noopener\">这个</a><br>大创那里今天看了下文档 找了找模板 还可以吧 明天的话</p>\n<ol>\n<li>游戏把服务器端写完 一半</li>\n<li>把找到的大创模板改到springboot上面去  后续再套</li>\n<li>练习并搞懂两道中等算法题目</li>\n<li>在有时间的话把牛客整理了</li>\n</ol>\n<h2 id=\"八日九日-2020年2月9日18-04-35\"><a href=\"#八日九日-2020年2月9日18-04-35\" class=\"headerlink\" title=\"八日九日 2020年2月9日18:04:35\"></a>八日九日 2020年2月9日18:04:35</h2><p>简单写下吧, 昨天 不小心挂彩了, 还好运气还好, 没有太大的伤, 不然特别时期真的难搞.<br>不幸中的万幸</p>\n<p>今天一天都没写代码 或许明天会好一些把</p>\n<h1 id=\"十日\"><a href=\"#十日\" class=\"headerlink\" title=\"十日\"></a>十日</h1><p>2020年2月10日10:02:22<br>今天问题不大了, 继续写游戏的服务器<br>写完服务器后, 做算法题吧</p>\n<h1 id=\"十四日\"><a href=\"#十四日\" class=\"headerlink\" title=\"十四日\"></a>十四日</h1><p>昨天基本问题就不大了, 眼睛周围青了一圈成了大熊猫, 经过四天的休息 看东西倒是不流眼泪了.<br>今天的话, 实际的学习方面有</p>\n<p>终于自己还是要找开源项目看看了, 不过今天2020年2月14日17:08:40头脑不是很清醒, 中午没有睡好. 看了个大概就没看了<br><a href=\"https://tengine.taobao.org/book/chapter_02.html\" target=\"_blank\" rel=\"noopener\">nginx剖析</a></p>\n<p>偶尔发现了一本书, 这不就是我想要看的吗!!!!!!, 准备看这本书 这本书从输入网址到网页返回都很详细的写了写<br><img src=\"https://pic2.zhimg.com/v2-1336c859990173751b77ad9eb4318602_r.jpg\" alt=\"\"></p>\n<h1 id=\"十五日\"><a href=\"#十五日\" class=\"headerlink\" title=\"十五日\"></a>十五日</h1><p>理论上大二寒假就要过完了. 昨天晚上想了很多</p>\n<p>先说一下游戏把: 感觉自己不喜欢玩手机游戏了, 手机游戏非肝即氪 自己没有时间去肝游戏, 肝游戏不会给你工作, 自己没有钱去氪金, 自己又非.抱着这种念头时间长了, 自己对游戏更加提不起兴趣了. 而我又想去做游戏, 一个不想玩游戏的人能做游戏吗? 虽说我的不想玩是在各种因素长时间影响下形成的.</p>\n<p>再说下我对编程吧: 怎么说呢, 我在大二上学期的上半学期之前, 都很喜欢写代码的, 我能在电脑前面坐上一整天. 后来我对代码提不起兴趣了. 原因的话昨天晚上整理了下.</p>\n<ol>\n<li>目的不同了: 我在大二上学期的上半学期之前(包括大一整个学期)都是抱着解决某个问题去写软件的, 说起来是为自己写代码?首先就是我学的Javaweb为了解决校园网登录难的问题, 我用Java写一个客户端, 同时配上了后台和下载站(用的阿里云的OSS). 我记得的那段时间真的快乐. 后面我又为解决手动签到的问题, 做了个签到软件, 也是如此.——后来我学习的目的就是为了增进自己的知识(目的只有一个–进入大公司), 变成了为了学而学(之所以为了学而学是感觉时间真的有限, 我想在大三暑假能够实习, 我只有一年半的时间), 而不是之前, 通过做自己喜欢的东西不会了就去补一补. 长时间这样学习我大二上整个学期一个正经的项目都没有, 长时间为了学而学消磨了我的兴趣??</li>\n<li>我发现我现在好像失去了对编程的乐趣, 现在写项目总想写出更优的结构, 总想写出大项目, 然而我的能力不足. 想实现和无法实现的思想一直持续着, 也是消磨的原因之一? 我现在在想我是不是期初就对linux服务器不感兴趣? 可我感觉当初自己确实想去的, 我想着游戏行业的人员兴趣基本相同, 能够一起做游戏,一边骂着策划脑洞一边做2333, 而不是做自己不喜欢的网站后端, 我发现目前自己都是一个人学习, 一个人做着, 何谈团队的乐趣?</li>\n</ol>\n<p>症状就如上了, 自己也得想想办法了.</p>\n<ol>\n<li>首要任务找个人(找个团队)一起做游戏吧, 自己一个人的话, 说不上我向往的一起写代码的氛围</li>\n<li>找到团队之后, 就能通过一边做游戏一边学习自己的不足了</li>\n<li>我长时间的学习, 做不出自己满意的项目也是原因之一吧.</li>\n<li>手机游戏的话, 暂时不去玩网游了. 我自己更适合单机? 找人做独立游戏?? emm不错</li>\n</ol>\n<h1 id=\"十六日\"><a href=\"#十六日\" class=\"headerlink\" title=\"十六日\"></a>十六日</h1><p>爆肝学习了一天3dmax , 现在是会基本的操作 能够完成一些简单的建模了.</p>\n<p>从B站找个那个课程也是很不错<br><a href=\"https://www.bilibili.com/video/av18210293/\" target=\"_blank\" rel=\"noopener\">3Dmax2018零基础入门教程（第一，二，三，四，五阶段）</a></p>\n<p>一天的事件我就从 P0看到了    P51 过得很快, 但感觉掌握的还能接受</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>按键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shift</td>\n<td>绘制直线</td>\n</tr>\n<tr>\n<td>删除键</td>\n<td>可以回退一次</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>W</td>\n<td>移动</td>\n</tr>\n<tr>\n<td>E</td>\n<td>旋转</td>\n</tr>\n<tr>\n<td>R</td>\n<td>缩放</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>F3</td>\n<td>线框显示模式</td>\n</tr>\n<tr>\n<td>F4</td>\n<td>实体+线框限时模式</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Shift</td>\n<td>按住可以复制</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Alt+T+A</td>\n<td>阵列</td>\n</tr>\n<tr>\n<td>Alt+T+M</td>\n<td>镜像</td>\n</tr>\n<tr>\n<td>Alt+A+对齐</td>\n<td></td>\n</tr>\n<tr>\n<td>Shitf+I</td>\n<td>间隔工具</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Ctrl+X</td>\n<td>专家模式, 隐藏所有多余的东西 获得最大的空间</td>\n</tr>\n<tr>\n<td>Alt+X</td>\n<td>半透明显示</td>\n</tr>\n<tr>\n<td>Ctrl+Shift+X</td>\n<td>变换虚拟体显示切换 可以看到变换虚拟体的明显变化</td>\n</tr>\n<tr>\n<td>O</td>\n<td>自适应降级</td>\n</tr>\n</tbody></table>\n<p><strong>编辑样条线-&gt;顶点</strong><br>优化 在线上添加点<br>焊接 连接两点<br>自动焊接 两点在距离之内自动焊接</p>\n<p><strong>车削修改器</strong><br>将二维图形 指定一个轴然后旋转 得到立体图形</p>\n<p><strong>可编辑多边形</strong><br><em>细分曲面</em><br>迭代次数2-3<br>无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)<br><em>细分置换-经常使用置换网格WSM修改器</em><br>需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图<br><em>绘制变形-未学-用于雕刻地形</em><br><strong>倒角剖面和扫描的区别</strong></p>\n<ol>\n<li>结合点不同</li>\n<li>倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓</li>\n<li>倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.</li>\n</ol>\n<hr>\n<p>好了暑假也算是结束了</p>\n<p>哦对了 我还在做一个游戏 从YouTube上看到一个打砖块游戏.<br>这只是开始, 因为我是做服务器的所以我要把游戏改成双人联机哒!!!!目前进展还不错</p>\n<p>我打算模仿一个知乎大佬在知乎更新下专栏? 貌似可以诶</p>\n<p>网上讲解服务器的不少 讲解客户端的不少  讲解一套的就少了</p>\n<p>好了博客整理下 寒假结束了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>现在是<code>2020年2月1日17:32:50</code> 寒假过半? 目前还不知道寒假什么时候开学. 为了自己能够前往心目中的公司, 学习是必不可少的.<br>学习的同时 应该要注意总结, 防止一天或者一周下来白忙活<br>我们寒假开始是一月九号 到我开始寒假学习的一月二十三号 这些天没有学习用来玩了, 好在后面拾了回来<br>从二十三号到现在二月一号, 每天学习的长度和质量总算是在慢慢上升<br>距离下一个寒假只剩下一年的时间了, 需要更加的努力, 为了大三暑假能够进入心中的公司 大三寒假的实习必不可少了. 加倍努力吧</p>\n<p>这篇博客的标题起初是<code>大二寒假学习记录</code>后来改成了<code>大二寒假及下学期学习记录</code>寒假的学习必不可少, 下学期更要抓紧时间了.</p>\n<h1 id=\"二月\"><a href=\"#二月\" class=\"headerlink\" title=\"二月\"></a>二月</h1><h2 id=\"一日2020年2月1日17-39-59\"><a href=\"#一日2020年2月1日17-39-59\" class=\"headerlink\" title=\"一日2020年2月1日17:39:59\"></a>一日2020年2月1日17:39:59</h2><p>前几天把博客从我自己的服务器迁移到了coding上, 方便以后我乱搞服务器, 现在服务器上没有重要的内容了<br>至于实际的学习方面, 我开始整理我的博客<a href=\"https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E5%88%9D%E7%BA%A7%E9%83%A8%E5%88%86/\">主要是这篇</a>这篇现在算告一段落了, 主要是把自己以前学过的用一用. 空洞的写下api<br>理解不是很深刻.<a href=\"https://blog.lsmg.xyz/2019/08/CPP-Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/\">这两天修改的这一篇</a>. 第二篇自己缺少的东西很多, 由于当时学习到了后面实在是学不下去了.<br>所以现在把后面的部分重新写了一下. 高级部分的线程和进程的部分 实在是太走马观花. 等我顺序学到了 再多写一些例子</p>\n<p>今天的话, 练习了下poll系统调用, 写了一个poll的demo, 然后是整理了下信号的部分, 信号这里整理的依然很少 平时用到的不多, 需要多加使用<br>主要是定时器这里了 定时器把原来的内容删掉了 从新写目前只写完了socket定时</p>\n<p>接下来打算还是多写一些项目 多思考一些 等我整理完了高级部分 就准备去看开源项目?每次看开源项目都感觉自己差的太多, 不知道从哪里看起<br>所以搭配着别人的笔记学习下看源码. 当然看源码之前还是要会大概的使用. 高级部分自然包括了libevent的使用部分</p>\n<p>跑去写项目了</p>\n<h2 id=\"二日2020年2月2日18-03-23\"><a href=\"#二日2020年2月2日18-03-23\" class=\"headerlink\" title=\"二日2020年2月2日18:03:23\"></a>二日2020年2月2日18:03:23</h2><p>罪过罪过, 昨天晚上十一点半 玩了一把军团TD 结果玩到了十二点半 ….. 最后一点半才睡觉<br>今天早上小十一点才起床.<br>我依稀记得我八点被闹钟叫起来emm 然后想着定八点半的闹钟 再睡一会, 结果闹钟没定我就睡着了.</p>\n<p>起来后整理了整理吃了午饭, 就下午小一点了, 打开高级部分 学习<code>信号SIGALRM定时</code></p>\n<p>代码量就400行 一直到我写今天的博客 才算完工</p>\n<p><strong>先写一下遇到的一个问题吧</strong><br>首先表现出来的是<code>超时后 服务器没有断开连接</code><br>然后我去打断点, 发现不是定时器链表部分的问题. 是定时信号没有触发<code>epoll_wait</code>.<br>这里我看了下代码, 发现定时器没有启动加上了<code>alarm(5)</code>, 我本意是理解了书上的代码 再去自己写, 结果还是理解的不深刻, 竟然丢了启动定时器的函数.<br>然后我又运行了下<code>发现还是没有运行到</code><br>然后发现<code>epoll_wait 返回-1 设置EINTR</code>, 后来查阅了下说是被信号处理器中断, 思考可能是与IDE下断点有关??????<br>最后发现自己没有把信号的管道添加到<code>epollfd</code>中再一细看发现丢了关于信号管道的四行代码…</p>\n<p>这个问题应该是很容易排查. 事后感觉应该这样思考<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/epoll%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5.png\" alt=\"\"><br>以后尽量总结正确的思考模式, 虽然不知道有没有用 但要试一试.</p>\n<p><strong>项目收获方面</strong><br>虽然这个项目只有400多行代码, 但我自己是绝对写不出来的. 只能尽量总结书上代码的好处</p>\n<ol>\n<li>首先肯定是使用alarm超时产生信号SIGALRM来触发回调函数 实现定时</li>\n<li>信号回调函数, 没有直接去触发定时器tick函数, 而是通过一个管道传到了epollfd中, 然后从epollfd的函数中触发相关的if 再去调用tick函数<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">timer_handler</span><span class=\"params\">()</span> <span class=\"comment\">//真正的生效部分</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    timer_lst.tick();</span><br><span class=\"line\">    alarm(TIMESLOT);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sig_handler</span><span class=\"params\">(<span class=\"keyword\">int</span> sig)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> save_errno = errno;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> msg = sig;</span><br><span class=\"line\">    send(pipefd[<span class=\"number\">1</span>], (<span class=\"keyword\">char</span>*)&amp;msg, <span class=\"number\">1</span>, <span class=\"number\">0</span>); <span class=\"comment\">// pipefd[0]注册进了epoll中 接受到来的信号</span></span><br><span class=\"line\">    errno = save_errno;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addsig</span><span class=\"params\">(<span class=\"keyword\">int</span> sig)</span><span class=\"comment\">// 信号添加</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">sa</span>&#123;</span>&#125;;</span><br><span class=\"line\">    sa.sa_flags |= SA_RESTART;</span><br><span class=\"line\">    sa.sa_handler = sig_handler;</span><br><span class=\"line\">    sigfillset(&amp;sa.sa_mask);</span><br><span class=\"line\">    exit_if(sigaction(sig, &amp;sa, <span class=\"literal\">nullptr</span>) == <span class=\"number\">-1</span>, <span class=\"string\">\"add sig error\"</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">char</span> signals[<span class=\"number\">1024</span>]; <span class=\"comment\">// 信号接收, 可能存在多个信号 所以用返回的字节数来逐个取出信号</span></span><br><span class=\"line\">ret = recv(sockfd, signals, <span class=\"keyword\">sizeof</span>(signals), <span class=\"number\">0</span>); 取出后使用<span class=\"keyword\">switch</span>来分离信号</span><br></pre></td></tr></table></figure></li>\n<li>将大部分常量 #define<br>大概只能总结出这一些来了, 完整的代码我贴在github上吧</li>\n</ol>\n<h2 id=\"五日-2020年2月6日09-16-23\"><a href=\"#五日-2020年2月6日09-16-23\" class=\"headerlink\" title=\"五日 2020年2月6日09:16:23\"></a>五日 2020年2月6日09:16:23</h2><p>三和四号 基本都在玩FF14, 发现自己并不是玩游戏了, 感觉被FF14玩了, 就是那种感觉累了不想玩了, 但却离自己定的小目标远 然后坚持<br>emm 其实感觉这个时候应该下游戏.<br>想想自己这大学一年半玩过的游戏 血族我算是玩的时间最长的大概前前后后我玩了五年, 应该是上半年把 我弃坑了. 游戏后面太氪了, 不得不退游了.<br>后面崩三啥的也玩过, 发现自己并不适合肝的游戏. 最近一个月入坑了fgo, 开始的几个星期还是玩的累了, 自己太肝了, 最近这几天感觉休闲了不少,<br>心态也正常了, 所以暂且会玩一玩.</p>\n<p>主要还是后面这些吧, 我发现自己逐渐有了一个念头: 累了就去玩会游戏, 就去看会直播, 刷刷B站. 后来我感觉这些浪费时间就去搜索了一下<br><strong>玩游戏算浪费时间吗</strong>, 刚才去找了下. 没找到我之前看过的那篇. 结论就是为什么自己不是累了就去小睡一下, 或者看看书,再或者刷刷新的科技圈<br>长长见识? 自己尝试了看书, 发现自己并不是太抗拒. 以后试试把.</p>\n<p>最后自己作为一个想开发游戏的人, 总感觉不玩游戏是不合适的, 但要玩的适度, 毕竟自己还有一年的时间就要找寒假实习, 为了自己的大三暑假进入大厂打下基础.<br>平衡好才是上策.</p>\n<p>接下文, 我发现自己有点?(自信点把点去掉)好高骛远了, 好高骛远会消磨一个人的兴趣和信心. 最终决定不做什么大游戏, 不研究什么框架, 先用自己所会的写一个小游戏,<br>一是为了试着重新拾起兴趣, 二是如果只学而不去写项目, 没有太大收获的</p>\n<p>昨天一天都是策划和编写一个游戏, 游戏逻辑十分的简单. 猜数字 初期的流程图我大概画了下, 姑且算作第一版吧 下面放出来, 我后面可以逐渐丰富这个东西 加上日志登录<br>断线重连等等功能.感觉还是可以的~~ 尽管逻辑很简单.<br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%B5%81%E7%A8%8B1.png\" alt=\"\"><br><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F-%E7%8C%9C%E6%95%B0%E5%AD%97/%E6%B8%B8%E6%88%8F%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%911.png\" alt=\"\"></p>\n<p>听说在写代码前规划好, 可以更好地组织代码, 昨天尝试了下感觉还不错. 我在写代码前把游戏的流程图画了一下, 然后标上了哪里会有什么数据交互,<br>之后我去写了数据包头格式<br><strong>头部</strong></p>\n<table>\n<thead>\n<tr>\n<th>偏移量</th>\n<th>长度</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0</td>\n<td>4</td>\n<td>封包总大小</td>\n</tr>\n<tr>\n<td>4</td>\n<td>2</td>\n<td>头部长度</td>\n</tr>\n<tr>\n<td>6</td>\n<td>2</td>\n<td>操作码</td>\n</tr>\n</tbody></table>\n<p><strong>操作码</strong></p>\n<table>\n<thead>\n<tr>\n<th>代码</th>\n<th>含义</th>\n<th>数据格式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>00</td>\n<td>登录</td>\n<td></td>\n</tr>\n<tr>\n<td>01</td>\n<td>桌位信息(服务器发送桌位列表)</td>\n<td>[1000-0-4][1001-0-4]</td>\n</tr>\n<tr>\n<td>02</td>\n<td>桌位操作信息(客户端加入 退出桌位)</td>\n<td>1000</td>\n</tr>\n<tr>\n<td>03</td>\n<td>服务器桌位操作信息反馈(加入退出成功1 加入退出失败0)</td>\n<td>1</td>\n</tr>\n<tr>\n<td>04</td>\n<td>准备</td>\n<td>无</td>\n</tr>\n<tr>\n<td>05</td>\n<td>取消准备</td>\n<td>无</td>\n</tr>\n<tr>\n<td>06</td>\n<td>服务器广播桌位信息</td>\n<td>4[11][10][00][00] (桌位总数, 有人1 准备1)</td>\n</tr>\n<tr>\n<td>A1</td>\n<td>服务器广播游戏开始</td>\n<td>空</td>\n</tr>\n<tr>\n<td>A2</td>\n<td>服务器下发轮到的客户端</td>\n<td>空</td>\n</tr>\n<tr>\n<td>A3</td>\n<td>客户端发送猜测的数字</td>\n<td>50</td>\n</tr>\n<tr>\n<td>A4</td>\n<td>服务器发送猜测数字反馈 (数据合理1, 数据非法0)</td>\n<td>1</td>\n</tr>\n<tr>\n<td>A5</td>\n<td>服务器广播游戏状态</td>\n<td>50-0-75[A][B] (A玩家猜出50 当前范围 0到75 B玩家准备)</td>\n</tr>\n</tbody></table>\n<p>然后草拟了一下 用到的类 用到的数据结构 分几个类 怎么联系起来, 最终我才去写代码, 感觉比一边写<br>一边想要好不少. 写的过程中也发现了一些问题</p>\n<ol>\n<li><code>EPOLLRDHUP</code>这个绑定在listenfd还是newfd?? 如果是newfd还能理解下原理, listenfd就有点理解不了.(试了下, 是newfd)</li>\n<li><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo *a;</span><br><span class=\"line\">Foos b[<span class=\"number\">3</span>];</span><br><span class=\"line\">b[<span class=\"number\">1</span>] = *a;</span><br><span class=\"line\"><span class=\"comment\">// 修改a不会影响b[1], 这个问题听到过, 自己真正试了试才发现如此</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<p>姑且昨天的就补上这些吧. 今天打算把游戏的服务器跑起来</p>\n<h2 id=\"六日-2020年2月6日22-12-36\"><a href=\"#六日-2020年2月6日22-12-36\" class=\"headerlink\" title=\"六日 2020年2月6日22:12:36\"></a>六日 2020年2月6日22:12:36</h2><p>忙忙碌碌的一天就又要结束了. 今天一天把剩下的一部分逻辑代码写了一部分. 主要是写自定义协议的序列化和反序列化. 起初打算<br>用char* body 来存储, 按照上面定义的格式传输. 后来一想, 这样我就不就是在原地打转吗. 就去网上找了找相关的代码, 看看别人怎么写的</p>\n<p>主要是看的这一篇博客<a href=\"https://blog.csdn.net/ACb0y/article/details/61421006\" target=\"_blank\" rel=\"noopener\">手把手教你实现自定义的应用层协议</a><br>看了之后收获不少. 收获总结在下面吧</p>\n<ol>\n<li>两个头文件互相include<br> 这个是今天了解的最奇葩的一个问题, 如果两个头文件互相include 会出问题. 这个明天开一篇 采坑博客<br> 与此连带的还有class 前置声明, 再者可以到编译相关的问题</li>\n<li>今天了解了一下CMAKE和MAKE的区别和联系, 总算知道了为啥好多安装的时候先cmake 再 make</li>\n<li>还是关于CMAKE 稍微整理了点CMAKE的使用. 随用随整理, 目前不打算一次性整理太多</li>\n<li>Git操作不熟练. 我本地写好了代码文件, commit 然后从服务器pull了一个仅包含readme的仓库, 然后reset<br> 自己写的代码文件全没了, 只剩下README.md 还好之前整理过reflog, 明天也需要在整理下</li>\n<li>安装了jsoncpp, 亿图图示等一些软件. 写了下关于字节对齐的问题. 亿图图示目前感觉挺不错</li>\n</ol>\n<p>代码方面的收获 主要就是看的那篇博客学到的.</p>\n<ol>\n<li>首先就是学会了自定了协议 序列化和反序列化怎么写 代码更美. 虽然可能我看的博客可能不是最好的,<br> 但对我目前来说足够美了, 不过写一遍远远不够.</li>\n<li>学到了巧妙地对 <code>uint8_t*</code>类型的指针(指向流数据缓冲区)转换成<code>uint16_t*</code>等指针类型, 进行解引用 得到原本的数据, 然后对<br>  <code>uint8_t*</code>类型的指针<code>+2</code>就可以跳过一个<code>uint16_t</code>, 虽然这些能够理解, 但实际应用这是第一次</li>\n<li>对于如何更好的组织一个数据结构 有了更深的体会.</li>\n<li>使用vector来存储剩余的包字节, 相比使用一个定长数组进行strcpy 方便了不少</li>\n<li>使用erase擦除也是第一次实际应用</li>\n<li>更好的使用指针</li>\n</ol>\n<p>定一下明天的任务吧, 试运行</p>\n<ol>\n<li>定义游戏的json格式, 把所有的json都定义出来 √</li>\n<li>游戏完成度达到能够正确解析包并分发到合理的部分即可 √</li>\n<li>写一遍采坑博客-头文件互相引用 √</li>\n<li>针对今天Git遇到的文件 在做研究下√</li>\n<li>简单学习下jsoncpp的使用√</li>\n</ol>\n<h2 id=\"七日-2020年2月7日10-14-53\"><a href=\"#七日-2020年2月7日10-14-53\" class=\"headerlink\" title=\"七日 2020年2月7日10:14:53\"></a>七日 2020年2月7日10:14:53</h2><p>2020年2月7日10:14:53<br>今天博客写的格外早, 主要是又遇到一个奇葩问题(其实是我自己使用有误)<br>我昨天最后发现代码跑不起来, 就没有管, 今天看了下跑不起来是因为<code>未定义引用</code><br>好吧, 未定义引用, 我检查了一下发现不对啊, 我加上了<br><code>target_link_libraries(Guess -ljsoncpp network game)</code><br>我当时是这样写的, 结果就是报错<code>未定义引用</code>, 然后我把报错的部分另开一个项目放进去<br>运行起来没问题?????.<br>然后我把报错的代码放在我项目的main文件中, 结果原来的报错也消失了 main中的也没报错?????<br>最后阴差阳错发现这个博客<a href=\"https://blog.csdn.net/qq_33249383/article/details/88908218\" target=\"_blank\" rel=\"noopener\">初入职常见问题：gcc编译时对’xxxx’未定义的引用</a>. 我发现其中的一段话</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这个主要的原因是gcc编译的时候，各个文件依赖顺序的问题。</span><br><span class=\"line\">在gcc编译的时候，如果文件a依赖于文件b，那么编译的时候必须把a放前面，b放后面。</span><br><span class=\"line\">例如:在main.c中使用了pthread库相关函数，那么编译的时候必须是main.c在前，-lpthread在后。 gcc main.c -lpthread -o a.out 。</span><br></pre></td></tr></table></figure>\n<p>虽然使用的是cmake然后make 不确定编译器, 但我感觉应该试一试. 因为我的软件是编译<code>network.a</code>的时候报错,<br>结果我改成了如下<br><code>target_link_libraries(Guess network game -ljsoncpp)</code><br>发现报错消失了……</p>\n<p>以前一直没有在意这里的顺序问题. 现在知道了问题所在 去搜索target_link_libraries顺序问题<br>找到了一堆解释 哎….</p>\n<p>2020年2月7日18:10:20<br>终于把头文件互相引用给搞明白了, 感觉这篇博客写的还可以吧, 就发到了<a href=\"https://blog.csdn.net/qq_26790181/article/details/104213520\" target=\"_blank\" rel=\"noopener\">csdn上面</a>,自己的博客上也会发的. 就先这样吧<br>今天的第三项任务完成了, 概第四项任务了Git</p>\n<p>2020年2月7日22:17:41<br>今天的任务完成了 还发现一个联系git的网站… 真的是纯偶然发现的<a href=\"https://learngitbranching.js.org/\" target=\"_blank\" rel=\"noopener\">这个</a><br>大创那里今天看了下文档 找了找模板 还可以吧 明天的话</p>\n<ol>\n<li>游戏把服务器端写完 一半</li>\n<li>把找到的大创模板改到springboot上面去  后续再套</li>\n<li>练习并搞懂两道中等算法题目</li>\n<li>在有时间的话把牛客整理了</li>\n</ol>\n<h2 id=\"八日九日-2020年2月9日18-04-35\"><a href=\"#八日九日-2020年2月9日18-04-35\" class=\"headerlink\" title=\"八日九日 2020年2月9日18:04:35\"></a>八日九日 2020年2月9日18:04:35</h2><p>简单写下吧, 昨天 不小心挂彩了, 还好运气还好, 没有太大的伤, 不然特别时期真的难搞.<br>不幸中的万幸</p>\n<p>今天一天都没写代码 或许明天会好一些把</p>\n<h1 id=\"十日\"><a href=\"#十日\" class=\"headerlink\" title=\"十日\"></a>十日</h1><p>2020年2月10日10:02:22<br>今天问题不大了, 继续写游戏的服务器<br>写完服务器后, 做算法题吧</p>\n<h1 id=\"十四日\"><a href=\"#十四日\" class=\"headerlink\" title=\"十四日\"></a>十四日</h1><p>昨天基本问题就不大了, 眼睛周围青了一圈成了大熊猫, 经过四天的休息 看东西倒是不流眼泪了.<br>今天的话, 实际的学习方面有</p>\n<p>终于自己还是要找开源项目看看了, 不过今天2020年2月14日17:08:40头脑不是很清醒, 中午没有睡好. 看了个大概就没看了<br><a href=\"https://tengine.taobao.org/book/chapter_02.html\" target=\"_blank\" rel=\"noopener\">nginx剖析</a></p>\n<p>偶尔发现了一本书, 这不就是我想要看的吗!!!!!!, 准备看这本书 这本书从输入网址到网页返回都很详细的写了写<br><img src=\"https://pic2.zhimg.com/v2-1336c859990173751b77ad9eb4318602_r.jpg\" alt=\"\"></p>\n<h1 id=\"十五日\"><a href=\"#十五日\" class=\"headerlink\" title=\"十五日\"></a>十五日</h1><p>理论上大二寒假就要过完了. 昨天晚上想了很多</p>\n<p>先说一下游戏把: 感觉自己不喜欢玩手机游戏了, 手机游戏非肝即氪 自己没有时间去肝游戏, 肝游戏不会给你工作, 自己没有钱去氪金, 自己又非.抱着这种念头时间长了, 自己对游戏更加提不起兴趣了. 而我又想去做游戏, 一个不想玩游戏的人能做游戏吗? 虽说我的不想玩是在各种因素长时间影响下形成的.</p>\n<p>再说下我对编程吧: 怎么说呢, 我在大二上学期的上半学期之前, 都很喜欢写代码的, 我能在电脑前面坐上一整天. 后来我对代码提不起兴趣了. 原因的话昨天晚上整理了下.</p>\n<ol>\n<li>目的不同了: 我在大二上学期的上半学期之前(包括大一整个学期)都是抱着解决某个问题去写软件的, 说起来是为自己写代码?首先就是我学的Javaweb为了解决校园网登录难的问题, 我用Java写一个客户端, 同时配上了后台和下载站(用的阿里云的OSS). 我记得的那段时间真的快乐. 后面我又为解决手动签到的问题, 做了个签到软件, 也是如此.——后来我学习的目的就是为了增进自己的知识(目的只有一个–进入大公司), 变成了为了学而学(之所以为了学而学是感觉时间真的有限, 我想在大三暑假能够实习, 我只有一年半的时间), 而不是之前, 通过做自己喜欢的东西不会了就去补一补. 长时间这样学习我大二上整个学期一个正经的项目都没有, 长时间为了学而学消磨了我的兴趣??</li>\n<li>我发现我现在好像失去了对编程的乐趣, 现在写项目总想写出更优的结构, 总想写出大项目, 然而我的能力不足. 想实现和无法实现的思想一直持续着, 也是消磨的原因之一? 我现在在想我是不是期初就对linux服务器不感兴趣? 可我感觉当初自己确实想去的, 我想着游戏行业的人员兴趣基本相同, 能够一起做游戏,一边骂着策划脑洞一边做2333, 而不是做自己不喜欢的网站后端, 我发现目前自己都是一个人学习, 一个人做着, 何谈团队的乐趣?</li>\n</ol>\n<p>症状就如上了, 自己也得想想办法了.</p>\n<ol>\n<li>首要任务找个人(找个团队)一起做游戏吧, 自己一个人的话, 说不上我向往的一起写代码的氛围</li>\n<li>找到团队之后, 就能通过一边做游戏一边学习自己的不足了</li>\n<li>我长时间的学习, 做不出自己满意的项目也是原因之一吧.</li>\n<li>手机游戏的话, 暂时不去玩网游了. 我自己更适合单机? 找人做独立游戏?? emm不错</li>\n</ol>\n<h1 id=\"十六日\"><a href=\"#十六日\" class=\"headerlink\" title=\"十六日\"></a>十六日</h1><p>爆肝学习了一天3dmax , 现在是会基本的操作 能够完成一些简单的建模了.</p>\n<p>从B站找个那个课程也是很不错<br><a href=\"https://www.bilibili.com/video/av18210293/\" target=\"_blank\" rel=\"noopener\">3Dmax2018零基础入门教程（第一，二，三，四，五阶段）</a></p>\n<p>一天的事件我就从 P0看到了    P51 过得很快, 但感觉掌握的还能接受</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th>按键</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>shift</td>\n<td>绘制直线</td>\n</tr>\n<tr>\n<td>删除键</td>\n<td>可以回退一次</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>W</td>\n<td>移动</td>\n</tr>\n<tr>\n<td>E</td>\n<td>旋转</td>\n</tr>\n<tr>\n<td>R</td>\n<td>缩放</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>F3</td>\n<td>线框显示模式</td>\n</tr>\n<tr>\n<td>F4</td>\n<td>实体+线框限时模式</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Shift</td>\n<td>按住可以复制</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Alt+T+A</td>\n<td>阵列</td>\n</tr>\n<tr>\n<td>Alt+T+M</td>\n<td>镜像</td>\n</tr>\n<tr>\n<td>Alt+A+对齐</td>\n<td></td>\n</tr>\n<tr>\n<td>Shitf+I</td>\n<td>间隔工具</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Ctrl+X</td>\n<td>专家模式, 隐藏所有多余的东西 获得最大的空间</td>\n</tr>\n<tr>\n<td>Alt+X</td>\n<td>半透明显示</td>\n</tr>\n<tr>\n<td>Ctrl+Shift+X</td>\n<td>变换虚拟体显示切换 可以看到变换虚拟体的明显变化</td>\n</tr>\n<tr>\n<td>O</td>\n<td>自适应降级</td>\n</tr>\n</tbody></table>\n<p><strong>编辑样条线-&gt;顶点</strong><br>优化 在线上添加点<br>焊接 连接两点<br>自动焊接 两点在距离之内自动焊接</p>\n<p><strong>车削修改器</strong><br>将二维图形 指定一个轴然后旋转 得到立体图形</p>\n<p><strong>可编辑多边形</strong><br><em>细分曲面</em><br>迭代次数2-3<br>无需子层级修改后 可以勾选 等值线显示(勾选后 显示真实的渲染线? 不勾选显得线条少 利于编辑子层面)<br><em>细分置换-经常使用置换网格WSM修改器</em><br>需要给立体图形 设置好材质球 材质球需要置换这个属性的贴图<br><em>绘制变形-未学-用于雕刻地形</em><br><strong>倒角剖面和扫描的区别</strong></p>\n<ol>\n<li>结合点不同</li>\n<li>倒角剖面不能用三维轮廓, 扫描可以使用三维轮廓</li>\n<li>倒角剖面不能将 图形包含图形(一个圆中再画一个圆) 的图形作为剖面,扫描可以.</li>\n</ol>\n<hr>\n<p>好了暑假也算是结束了</p>\n<p>哦对了 我还在做一个游戏 从YouTube上看到一个打砖块游戏.<br>这只是开始, 因为我是做服务器的所以我要把游戏改成双人联机哒!!!!目前进展还不错</p>\n<p>我打算模仿一个知乎大佬在知乎更新下专栏? 貌似可以诶</p>\n<p>网上讲解服务器的不少 讲解客户端的不少  讲解一套的就少了</p>\n<p>好了博客整理下 寒假结束了</p>\n"},{"title":"GDB调试","date":"2020-03-14T07:09:20.000Z","_content":"\nhttps://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\n\n对多线程的支持\nset follow-fork-mode [parent|child]\nset detach-on-fork [on|off]\n\n| follow-fork-mode | detach-on-fork | 说明 |\n| --- | --- | --- |\n| parent | on | 只调试主进程 |\n| child | on | 只调试子进程 |\n| parent | off | 同时调试父子进程, gdb跟踪父进程, 子进程阻塞在fork位置 |\n| child | off | 同上 gdb跟踪子进程, 父进程阻塞 |\n\n进程间切换\n| 命令 | 功能 |\n| --- | --- |\n| info inferiors | 查询正在调试的进程 |\n| inferior \\<number> | 切换进程 |\n\n\n| 运行命令 | 缩写 | 功能 |\n| --- | --- | --- |\n| run | r | 运行程序 |\n| continue | c | 继续执行到下有一个断点处 |\n| next | n | 单步跟踪, 不进入函数 |\n| step | s | 会进入函数 |\n| until | | 运行程序直到退出循环体 |\n| until + 行号 | | 运行至某行 |\n| finish | | 运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回以及参数等信息 |\n| call 函数(参数) | | 调试程序中的可见参数, 并传递参数 |\n| quit | q | 退出 |\n\n| 设置断点 | 缩写 | 功能 |\n| --- | --- |--- |\n| break n | b n | 在第n行设置断点, b xx.cpp:500(xx.cpp文件第500行) |\n| b fn if a>b | | 在函数f 或者行号n 设置条件断点 |\n| break func | b func | 在函数func()的入口处设置断点 |\n| delete 断点号n | | 删除第n个断点 |\n| disable 断点号n | | 暂停第n个断点 |\n| enable 断点号n | | 开始第n的断点 |\n| clear 行号n | | 清除第n行的断点 |\n| info b | | 显示断点设置情况 |\n| delete breakpoints | | 清除所有断点 |\n\n| 查看源代码 | 缩写 | 功能 |\n| --- | --- | --- |\n| list | l | 默认显示10行 |\n| list 行号 | | 以行号为中心的前后十行代码 |\n| list 函数名 | | 列出函数名所在函数的代码 |\n| list | | 不带参数, 接着上一次的list命令输出下边的内容 |\n\n| 打印表达式 | 功能 |\n| --- | --- |\n| print p | |\n| p a | 显示a的值 |\n| p ++a | a的值 |\n| p func(22) | 以整数22作为参数调用 后打印 |\n| p func(a) | 将变量a作为参数 |\n| display 表达式 | 每次单步运行后就打印表达式的值 |\n| watch 表达式 | 设置检视点, 一旦被监视的表达式值改变就强行终止正在被调试的程序 |\n| whatis | 查询变量或函数 |\n| info function | 查询函数 |\n| info local | 显示当前堆栈页的所有变量 |\n\n\n| 查询运行信息 | 功能 |\n| --- | --- |\n| where/bt | 当前运行的堆栈列表 |\n| bt backtrace | 显示当前的调用堆栈 |\n| up/down | 改变堆栈的显示深度 |\n| set args [args]| 指定程序运行参数 |\n| show args| 查看程序参数 |\n| info program | 查看程序是否运行, 进程号, 被暂停原因 |","source":"_posts/操作系统-GDB调试.md","raw":"---\ntitle: GDB调试\ndate: 2020-03-14 15:09:20\ncategories: \n- 操作系统\ntags:\n- GDB调试\n---\n\nhttps://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\n\n对多线程的支持\nset follow-fork-mode [parent|child]\nset detach-on-fork [on|off]\n\n| follow-fork-mode | detach-on-fork | 说明 |\n| --- | --- | --- |\n| parent | on | 只调试主进程 |\n| child | on | 只调试子进程 |\n| parent | off | 同时调试父子进程, gdb跟踪父进程, 子进程阻塞在fork位置 |\n| child | off | 同上 gdb跟踪子进程, 父进程阻塞 |\n\n进程间切换\n| 命令 | 功能 |\n| --- | --- |\n| info inferiors | 查询正在调试的进程 |\n| inferior \\<number> | 切换进程 |\n\n\n| 运行命令 | 缩写 | 功能 |\n| --- | --- | --- |\n| run | r | 运行程序 |\n| continue | c | 继续执行到下有一个断点处 |\n| next | n | 单步跟踪, 不进入函数 |\n| step | s | 会进入函数 |\n| until | | 运行程序直到退出循环体 |\n| until + 行号 | | 运行至某行 |\n| finish | | 运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回以及参数等信息 |\n| call 函数(参数) | | 调试程序中的可见参数, 并传递参数 |\n| quit | q | 退出 |\n\n| 设置断点 | 缩写 | 功能 |\n| --- | --- |--- |\n| break n | b n | 在第n行设置断点, b xx.cpp:500(xx.cpp文件第500行) |\n| b fn if a>b | | 在函数f 或者行号n 设置条件断点 |\n| break func | b func | 在函数func()的入口处设置断点 |\n| delete 断点号n | | 删除第n个断点 |\n| disable 断点号n | | 暂停第n个断点 |\n| enable 断点号n | | 开始第n的断点 |\n| clear 行号n | | 清除第n行的断点 |\n| info b | | 显示断点设置情况 |\n| delete breakpoints | | 清除所有断点 |\n\n| 查看源代码 | 缩写 | 功能 |\n| --- | --- | --- |\n| list | l | 默认显示10行 |\n| list 行号 | | 以行号为中心的前后十行代码 |\n| list 函数名 | | 列出函数名所在函数的代码 |\n| list | | 不带参数, 接着上一次的list命令输出下边的内容 |\n\n| 打印表达式 | 功能 |\n| --- | --- |\n| print p | |\n| p a | 显示a的值 |\n| p ++a | a的值 |\n| p func(22) | 以整数22作为参数调用 后打印 |\n| p func(a) | 将变量a作为参数 |\n| display 表达式 | 每次单步运行后就打印表达式的值 |\n| watch 表达式 | 设置检视点, 一旦被监视的表达式值改变就强行终止正在被调试的程序 |\n| whatis | 查询变量或函数 |\n| info function | 查询函数 |\n| info local | 显示当前堆栈页的所有变量 |\n\n\n| 查询运行信息 | 功能 |\n| --- | --- |\n| where/bt | 当前运行的堆栈列表 |\n| bt backtrace | 显示当前的调用堆栈 |\n| up/down | 改变堆栈的显示深度 |\n| set args [args]| 指定程序运行参数 |\n| show args| 查看程序参数 |\n| info program | 查看程序是否运行, 进程号, 被暂停原因 |","slug":"操作系统-GDB调试","published":1,"updated":"2020-03-17T08:39:20.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvj00258cuo52fl1spy","content":"<p><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\" target=\"_blank\" rel=\"noopener\">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p>\n<p>对多线程的支持<br>set follow-fork-mode [parent|child]<br>set detach-on-fork [on|off]</p>\n<table>\n<thead>\n<tr>\n<th>follow-fork-mode</th>\n<th>detach-on-fork</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>parent</td>\n<td>on</td>\n<td>只调试主进程</td>\n</tr>\n<tr>\n<td>child</td>\n<td>on</td>\n<td>只调试子进程</td>\n</tr>\n<tr>\n<td>parent</td>\n<td>off</td>\n<td>同时调试父子进程, gdb跟踪父进程, 子进程阻塞在fork位置</td>\n</tr>\n<tr>\n<td>child</td>\n<td>off</td>\n<td>同上 gdb跟踪子进程, 父进程阻塞</td>\n</tr>\n</tbody></table>\n<p>进程间切换<br>| 命令 | 功能 |<br>| — | — |<br>| info inferiors | 查询正在调试的进程 |<br>| inferior &lt;number&gt; | 切换进程 |</p>\n<table>\n<thead>\n<tr>\n<th>运行命令</th>\n<th>缩写</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>run</td>\n<td>r</td>\n<td>运行程序</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>c</td>\n<td>继续执行到下有一个断点处</td>\n</tr>\n<tr>\n<td>next</td>\n<td>n</td>\n<td>单步跟踪, 不进入函数</td>\n</tr>\n<tr>\n<td>step</td>\n<td>s</td>\n<td>会进入函数</td>\n</tr>\n<tr>\n<td>until</td>\n<td></td>\n<td>运行程序直到退出循环体</td>\n</tr>\n<tr>\n<td>until + 行号</td>\n<td></td>\n<td>运行至某行</td>\n</tr>\n<tr>\n<td>finish</td>\n<td></td>\n<td>运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回以及参数等信息</td>\n</tr>\n<tr>\n<td>call 函数(参数)</td>\n<td></td>\n<td>调试程序中的可见参数, 并传递参数</td>\n</tr>\n<tr>\n<td>quit</td>\n<td>q</td>\n<td>退出</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>设置断点</th>\n<th>缩写</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>break n</td>\n<td>b n</td>\n<td>在第n行设置断点, b xx.cpp:500(xx.cpp文件第500行)</td>\n</tr>\n<tr>\n<td>b fn if a&gt;b</td>\n<td></td>\n<td>在函数f 或者行号n 设置条件断点</td>\n</tr>\n<tr>\n<td>break func</td>\n<td>b func</td>\n<td>在函数func()的入口处设置断点</td>\n</tr>\n<tr>\n<td>delete 断点号n</td>\n<td></td>\n<td>删除第n个断点</td>\n</tr>\n<tr>\n<td>disable 断点号n</td>\n<td></td>\n<td>暂停第n个断点</td>\n</tr>\n<tr>\n<td>enable 断点号n</td>\n<td></td>\n<td>开始第n的断点</td>\n</tr>\n<tr>\n<td>clear 行号n</td>\n<td></td>\n<td>清除第n行的断点</td>\n</tr>\n<tr>\n<td>info b</td>\n<td></td>\n<td>显示断点设置情况</td>\n</tr>\n<tr>\n<td>delete breakpoints</td>\n<td></td>\n<td>清除所有断点</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查看源代码</th>\n<th>缩写</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>list</td>\n<td>l</td>\n<td>默认显示10行</td>\n</tr>\n<tr>\n<td>list 行号</td>\n<td></td>\n<td>以行号为中心的前后十行代码</td>\n</tr>\n<tr>\n<td>list 函数名</td>\n<td></td>\n<td>列出函数名所在函数的代码</td>\n</tr>\n<tr>\n<td>list</td>\n<td></td>\n<td>不带参数, 接着上一次的list命令输出下边的内容</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>打印表达式</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>print p</td>\n<td></td>\n</tr>\n<tr>\n<td>p a</td>\n<td>显示a的值</td>\n</tr>\n<tr>\n<td>p ++a</td>\n<td>a的值</td>\n</tr>\n<tr>\n<td>p func(22)</td>\n<td>以整数22作为参数调用 后打印</td>\n</tr>\n<tr>\n<td>p func(a)</td>\n<td>将变量a作为参数</td>\n</tr>\n<tr>\n<td>display 表达式</td>\n<td>每次单步运行后就打印表达式的值</td>\n</tr>\n<tr>\n<td>watch 表达式</td>\n<td>设置检视点, 一旦被监视的表达式值改变就强行终止正在被调试的程序</td>\n</tr>\n<tr>\n<td>whatis</td>\n<td>查询变量或函数</td>\n</tr>\n<tr>\n<td>info function</td>\n<td>查询函数</td>\n</tr>\n<tr>\n<td>info local</td>\n<td>显示当前堆栈页的所有变量</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查询运行信息</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>where/bt</td>\n<td>当前运行的堆栈列表</td>\n</tr>\n<tr>\n<td>bt backtrace</td>\n<td>显示当前的调用堆栈</td>\n</tr>\n<tr>\n<td>up/down</td>\n<td>改变堆栈的显示深度</td>\n</tr>\n<tr>\n<td>set args [args]</td>\n<td>指定程序运行参数</td>\n</tr>\n<tr>\n<td>show args</td>\n<td>查看程序参数</td>\n</tr>\n<tr>\n<td>info program</td>\n<td>查看程序是否运行, 进程号, 被暂停原因</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html\" target=\"_blank\" rel=\"noopener\">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html</a></p>\n<p>对多线程的支持<br>set follow-fork-mode [parent|child]<br>set detach-on-fork [on|off]</p>\n<table>\n<thead>\n<tr>\n<th>follow-fork-mode</th>\n<th>detach-on-fork</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>parent</td>\n<td>on</td>\n<td>只调试主进程</td>\n</tr>\n<tr>\n<td>child</td>\n<td>on</td>\n<td>只调试子进程</td>\n</tr>\n<tr>\n<td>parent</td>\n<td>off</td>\n<td>同时调试父子进程, gdb跟踪父进程, 子进程阻塞在fork位置</td>\n</tr>\n<tr>\n<td>child</td>\n<td>off</td>\n<td>同上 gdb跟踪子进程, 父进程阻塞</td>\n</tr>\n</tbody></table>\n<p>进程间切换<br>| 命令 | 功能 |<br>| — | — |<br>| info inferiors | 查询正在调试的进程 |<br>| inferior &lt;number&gt; | 切换进程 |</p>\n<table>\n<thead>\n<tr>\n<th>运行命令</th>\n<th>缩写</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>run</td>\n<td>r</td>\n<td>运行程序</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>c</td>\n<td>继续执行到下有一个断点处</td>\n</tr>\n<tr>\n<td>next</td>\n<td>n</td>\n<td>单步跟踪, 不进入函数</td>\n</tr>\n<tr>\n<td>step</td>\n<td>s</td>\n<td>会进入函数</td>\n</tr>\n<tr>\n<td>until</td>\n<td></td>\n<td>运行程序直到退出循环体</td>\n</tr>\n<tr>\n<td>until + 行号</td>\n<td></td>\n<td>运行至某行</td>\n</tr>\n<tr>\n<td>finish</td>\n<td></td>\n<td>运行程序, 直到当前函数完成返回, 并打印函数返回时的堆栈地址和返回以及参数等信息</td>\n</tr>\n<tr>\n<td>call 函数(参数)</td>\n<td></td>\n<td>调试程序中的可见参数, 并传递参数</td>\n</tr>\n<tr>\n<td>quit</td>\n<td>q</td>\n<td>退出</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>设置断点</th>\n<th>缩写</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>break n</td>\n<td>b n</td>\n<td>在第n行设置断点, b xx.cpp:500(xx.cpp文件第500行)</td>\n</tr>\n<tr>\n<td>b fn if a&gt;b</td>\n<td></td>\n<td>在函数f 或者行号n 设置条件断点</td>\n</tr>\n<tr>\n<td>break func</td>\n<td>b func</td>\n<td>在函数func()的入口处设置断点</td>\n</tr>\n<tr>\n<td>delete 断点号n</td>\n<td></td>\n<td>删除第n个断点</td>\n</tr>\n<tr>\n<td>disable 断点号n</td>\n<td></td>\n<td>暂停第n个断点</td>\n</tr>\n<tr>\n<td>enable 断点号n</td>\n<td></td>\n<td>开始第n的断点</td>\n</tr>\n<tr>\n<td>clear 行号n</td>\n<td></td>\n<td>清除第n行的断点</td>\n</tr>\n<tr>\n<td>info b</td>\n<td></td>\n<td>显示断点设置情况</td>\n</tr>\n<tr>\n<td>delete breakpoints</td>\n<td></td>\n<td>清除所有断点</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查看源代码</th>\n<th>缩写</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>list</td>\n<td>l</td>\n<td>默认显示10行</td>\n</tr>\n<tr>\n<td>list 行号</td>\n<td></td>\n<td>以行号为中心的前后十行代码</td>\n</tr>\n<tr>\n<td>list 函数名</td>\n<td></td>\n<td>列出函数名所在函数的代码</td>\n</tr>\n<tr>\n<td>list</td>\n<td></td>\n<td>不带参数, 接着上一次的list命令输出下边的内容</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>打印表达式</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>print p</td>\n<td></td>\n</tr>\n<tr>\n<td>p a</td>\n<td>显示a的值</td>\n</tr>\n<tr>\n<td>p ++a</td>\n<td>a的值</td>\n</tr>\n<tr>\n<td>p func(22)</td>\n<td>以整数22作为参数调用 后打印</td>\n</tr>\n<tr>\n<td>p func(a)</td>\n<td>将变量a作为参数</td>\n</tr>\n<tr>\n<td>display 表达式</td>\n<td>每次单步运行后就打印表达式的值</td>\n</tr>\n<tr>\n<td>watch 表达式</td>\n<td>设置检视点, 一旦被监视的表达式值改变就强行终止正在被调试的程序</td>\n</tr>\n<tr>\n<td>whatis</td>\n<td>查询变量或函数</td>\n</tr>\n<tr>\n<td>info function</td>\n<td>查询函数</td>\n</tr>\n<tr>\n<td>info local</td>\n<td>显示当前堆栈页的所有变量</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查询运行信息</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>where/bt</td>\n<td>当前运行的堆栈列表</td>\n</tr>\n<tr>\n<td>bt backtrace</td>\n<td>显示当前的调用堆栈</td>\n</tr>\n<tr>\n<td>up/down</td>\n<td>改变堆栈的显示深度</td>\n</tr>\n<tr>\n<td>set args [args]</td>\n<td>指定程序运行参数</td>\n</tr>\n<tr>\n<td>show args</td>\n<td>查看程序参数</td>\n</tr>\n<tr>\n<td>info program</td>\n<td>查看程序是否运行, 进程号, 被暂停原因</td>\n</tr>\n</tbody></table>\n"},{"title":"Linux的使用","date":"2020-03-17T04:29:20.000Z","_content":"\n| 命令 | 功能 |\n| --- | --- |\n| cp -r | 复制目录 |\n| cd - | 切换到上一个工作目录 |\n\n\n| 查找 | 功能 |\n| --- | --- |\n| find ./ -name \"core*\" | xargs file | 搜寻目录或文件 |\n| find ./ -name '*.o' | 查找目标文件夹是否有obj文件 |\n| find ./ -name \"*.o\" \\| xargs rm -f | 递归删除当前目录所有obj文件 |\n\n\n| 查看文件内容 | 功能 | 一般用法|\n| --- | --- | --- |\n| cat -n | 显示的同时显示行号 | 使用管道 ls \\| cat -n |\n| head -10 filename | 查看前十行 | |\n| tail -10 failname | 查看后十行 ||\n| diff file1 file2 | 查看文件差别 ||\n| tail -f filename | 动态显示文本的最新信息 ||\n\n\n| 给文件增加别名 | 功能 |\n| ln a b | 创建硬链接, 删除一个另一个仍能使用 |\n| ln -s a b | 创建符号链接(软连接) 删除源后另一个无法使用 |\n\n\n命令行快捷键\nCtl-U   删除光标到行首的所有字符 `$ 1111 222  --> $ `\nCtl-W   删除光标到前边最近一个空格之间的字符 `$ 1111 222 --> $ 1111`","source":"_posts/操作系统-Linux使用.md","raw":"---\ntitle: Linux的使用\ndate: 2020-03-17 12:29:20\ncategories: \n- 操作系统\ntags:\n- Linux\n---\n\n| 命令 | 功能 |\n| --- | --- |\n| cp -r | 复制目录 |\n| cd - | 切换到上一个工作目录 |\n\n\n| 查找 | 功能 |\n| --- | --- |\n| find ./ -name \"core*\" | xargs file | 搜寻目录或文件 |\n| find ./ -name '*.o' | 查找目标文件夹是否有obj文件 |\n| find ./ -name \"*.o\" \\| xargs rm -f | 递归删除当前目录所有obj文件 |\n\n\n| 查看文件内容 | 功能 | 一般用法|\n| --- | --- | --- |\n| cat -n | 显示的同时显示行号 | 使用管道 ls \\| cat -n |\n| head -10 filename | 查看前十行 | |\n| tail -10 failname | 查看后十行 ||\n| diff file1 file2 | 查看文件差别 ||\n| tail -f filename | 动态显示文本的最新信息 ||\n\n\n| 给文件增加别名 | 功能 |\n| ln a b | 创建硬链接, 删除一个另一个仍能使用 |\n| ln -s a b | 创建符号链接(软连接) 删除源后另一个无法使用 |\n\n\n命令行快捷键\nCtl-U   删除光标到行首的所有字符 `$ 1111 222  --> $ `\nCtl-W   删除光标到前边最近一个空格之间的字符 `$ 1111 222 --> $ 1111`","slug":"操作系统-Linux使用","published":1,"updated":"2020-03-17T04:56:16.103Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvk00278cuo603acrpu","content":"<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cp -r</td>\n<td>复制目录</td>\n</tr>\n<tr>\n<td>cd -</td>\n<td>切换到上一个工作目录</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查找</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>find ./ -name “core*”</td>\n<td>xargs file</td>\n</tr>\n<tr>\n<td>find ./ -name ‘*.o’</td>\n<td>查找目标文件夹是否有obj文件</td>\n</tr>\n<tr>\n<td>find ./ -name “*.o” | xargs rm -f</td>\n<td>递归删除当前目录所有obj文件</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查看文件内容</th>\n<th>功能</th>\n<th>一般用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cat -n</td>\n<td>显示的同时显示行号</td>\n<td>使用管道 ls | cat -n</td>\n</tr>\n<tr>\n<td>head -10 filename</td>\n<td>查看前十行</td>\n<td></td>\n</tr>\n<tr>\n<td>tail -10 failname</td>\n<td>查看后十行</td>\n<td></td>\n</tr>\n<tr>\n<td>diff file1 file2</td>\n<td>查看文件差别</td>\n<td></td>\n</tr>\n<tr>\n<td>tail -f filename</td>\n<td>动态显示文本的最新信息</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>| 给文件增加别名 | 功能 |<br>| ln a b | 创建硬链接, 删除一个另一个仍能使用 |<br>| ln -s a b | 创建符号链接(软连接) 删除源后另一个无法使用 |</p>\n<p>命令行快捷键<br>Ctl-U   删除光标到行首的所有字符 <code>$ 1111 222  --&gt; $</code><br>Ctl-W   删除光标到前边最近一个空格之间的字符 <code>$ 1111 222 --&gt; $ 1111</code></p>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cp -r</td>\n<td>复制目录</td>\n</tr>\n<tr>\n<td>cd -</td>\n<td>切换到上一个工作目录</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查找</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>find ./ -name “core*”</td>\n<td>xargs file</td>\n</tr>\n<tr>\n<td>find ./ -name ‘*.o’</td>\n<td>查找目标文件夹是否有obj文件</td>\n</tr>\n<tr>\n<td>find ./ -name “*.o” | xargs rm -f</td>\n<td>递归删除当前目录所有obj文件</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>查看文件内容</th>\n<th>功能</th>\n<th>一般用法</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cat -n</td>\n<td>显示的同时显示行号</td>\n<td>使用管道 ls | cat -n</td>\n</tr>\n<tr>\n<td>head -10 filename</td>\n<td>查看前十行</td>\n<td></td>\n</tr>\n<tr>\n<td>tail -10 failname</td>\n<td>查看后十行</td>\n<td></td>\n</tr>\n<tr>\n<td>diff file1 file2</td>\n<td>查看文件差别</td>\n<td></td>\n</tr>\n<tr>\n<td>tail -f filename</td>\n<td>动态显示文本的最新信息</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>| 给文件增加别名 | 功能 |<br>| ln a b | 创建硬链接, 删除一个另一个仍能使用 |<br>| ln -s a b | 创建符号链接(软连接) 删除源后另一个无法使用 |</p>\n<p>命令行快捷键<br>Ctl-U   删除光标到行首的所有字符 <code>$ 1111 222  --&gt; $</code><br>Ctl-W   删除光标到前边最近一个空格之间的字符 <code>$ 1111 222 --&gt; $ 1111</code></p>\n"},{"title":"csapp笔记","date":"2020-03-14T07:09:20.000Z","_content":"\n选择性阅读\n\n# 第十二章 并发编程\n","source":"_posts/操作系统-csapp.md","raw":"---\ntitle: csapp笔记\ndate: 2020-03-14 15:09:20\ncategories: \n- 操作系统\ntags:\n- csapp\n---\n\n选择性阅读\n\n# 第十二章 并发编程\n","slug":"操作系统-csapp","published":1,"updated":"2020-03-14T10:15:31.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvl002a8cuofekng33n","content":"<p>选择性阅读</p>\n<h1 id=\"第十二章-并发编程\"><a href=\"#第十二章-并发编程\" class=\"headerlink\" title=\"第十二章 并发编程\"></a>第十二章 并发编程</h1>","site":{"data":{}},"excerpt":"","more":"<p>选择性阅读</p>\n<h1 id=\"第十二章-并发编程\"><a href=\"#第十二章-并发编程\" class=\"headerlink\" title=\"第十二章 并发编程\"></a>第十二章 并发编程</h1>"},{"title":"Mysql基本使用","date":"2020-03-06T07:25:28.000Z","_content":"\n# 安装和配置\nUbuntu18.04 安装 mysql5.7\n```shell\nsudo apt update\nsudo apt-get install mysql-server\n```\n\n安装完毕后\n```shell\n# 打开shell管理程序\nsudo mysql\n\n# 123456 换成你自己的密码\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';\n\n# 刷新一下\nFLUSH PRIVILEGES;\n\n# 退出\nexit\n\n# 登录测试\nmysql -uroot -p # 回车 后输入自己的密码再次回车\n```","source":"_posts/数据库-Mysql-Mysql基本使用.md","raw":"---\ntitle: Mysql基本使用\ntags:\n  - Mysql\ncategories:\n  - 数据库\n  - Mysql\ndate: 2020-03-06 15:25:28\n---\n\n# 安装和配置\nUbuntu18.04 安装 mysql5.7\n```shell\nsudo apt update\nsudo apt-get install mysql-server\n```\n\n安装完毕后\n```shell\n# 打开shell管理程序\nsudo mysql\n\n# 123456 换成你自己的密码\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';\n\n# 刷新一下\nFLUSH PRIVILEGES;\n\n# 退出\nexit\n\n# 登录测试\nmysql -uroot -p # 回车 后输入自己的密码再次回车\n```","slug":"数据库-Mysql-Mysql基本使用","published":1,"updated":"2020-03-06T07:59:36.342Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvm002e8cuo6nbc38kk","content":"<h1 id=\"安装和配置\"><a href=\"#安装和配置\" class=\"headerlink\" title=\"安装和配置\"></a>安装和配置</h1><p>Ubuntu18.04 安装 mysql5.7</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure>\n\n<p>安装完毕后</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 打开shell管理程序</span></span><br><span class=\"line\">sudo mysql</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 123456 换成你自己的密码</span></span><br><span class=\"line\">ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 刷新一下</span></span><br><span class=\"line\">FLUSH PRIVILEGES;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 退出</span></span><br><span class=\"line\">exit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 登录测试</span></span><br><span class=\"line\">mysql -uroot -p # 回车 后输入自己的密码再次回车</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"安装和配置\"><a href=\"#安装和配置\" class=\"headerlink\" title=\"安装和配置\"></a>安装和配置</h1><p>Ubuntu18.04 安装 mysql5.7</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt update</span><br><span class=\"line\">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure>\n\n<p>安装完毕后</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 打开shell管理程序</span></span><br><span class=\"line\">sudo mysql</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 123456 换成你自己的密码</span></span><br><span class=\"line\">ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 刷新一下</span></span><br><span class=\"line\">FLUSH PRIVILEGES;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 退出</span></span><br><span class=\"line\">exit</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 登录测试</span></span><br><span class=\"line\">mysql -uroot -p # 回车 后输入自己的密码再次回车</span><br></pre></td></tr></table></figure>"},{"title":"游戏知识-腾讯游戏学院-如何进入游戏开发行业","date":"2019-12-22T12:50:02.000Z","_content":"\n由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面\n[想做游戏吗？如何开始我的游戏开发职业生涯](https://gameinstitute.qq.com/course/detail/10156)\n<!--more-->\n做游戏不会重复做同样的工作, 项目不同\n\n","source":"_posts/游戏知识-腾讯游戏学院-如何进入游戏开发行业.md","raw":"---\ntitle: 游戏知识-腾讯游戏学院-如何进入游戏开发行业\ntags:\n  - 腾讯游戏学院\ncategories:\n  - 游戏知识\n  - 腾讯游戏学院\ndate: 2019-12-22 20:50:02\n---\n\n由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面\n[想做游戏吗？如何开始我的游戏开发职业生涯](https://gameinstitute.qq.com/course/detail/10156)\n<!--more-->\n做游戏不会重复做同样的工作, 项目不同\n\n","slug":"游戏知识-腾讯游戏学院-如何进入游戏开发行业","published":1,"updated":"2020-03-05T14:04:56.802Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvn002h8cuo5x5gb7k4","content":"<p>由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面<br><a href=\"https://gameinstitute.qq.com/course/detail/10156\" target=\"_blank\" rel=\"noopener\">想做游戏吗？如何开始我的游戏开发职业生涯</a></p>\n<a id=\"more\"></a>\n<p>做游戏不会重复做同样的工作, 项目不同</p>\n","site":{"data":{}},"excerpt":"<p>由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面<br><a href=\"https://gameinstitute.qq.com/course/detail/10156\" target=\"_blank\" rel=\"noopener\">想做游戏吗？如何开始我的游戏开发职业生涯</a></p>","more":"<p>做游戏不会重复做同样的工作, 项目不同</p>"},{"title":"权限管理","date":"2020-03-14T07:09:20.000Z","_content":"\n`drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs`\n档案权限类型\n连接数\n档案拥有者\n档案所属群组\n档案容量\n档案最后被修改时间\n档名\n\n文件类型和权限\n`drwxr-xr-x`\n\n第一位 d 表明档案类型是 目录\n\n| 字符 | 含义 |\n| --- | --- |\n| d | 目录 |\n| - | 文件 |\n| \\| | 链接文件 |\n| b | 设备文件中可供存储的周边设备, 可随机读取设备 |\n| c | 序列号设备, 如键盘鼠标, 一次性读取设备 |\n\n\n后面每三位一组 为`rwx`的组合 分别代表 `读`, `写`, `执行`\n三组 第一组`文件拥有者权限` 第二组`群组中账号权限` 第三组`非本人且没有加入本群组的其他账号权限`\n\n第三部分表示这个文件的`拥有者账号`\n第四部分表示这个文件`所属群组`\n\n相关命令\n-chgrp 改变文件所属群组\n-chown 改变文件拥有者\n-chmod 改变文件权限\n\n","source":"_posts/操作系统-权限相关.md","raw":"---\ntitle: 权限管理\ndate: 2020-03-14 15:09:20\ncategories: \n- 操作系统\ntags:\n- 权限管理\n---\n\n`drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs`\n档案权限类型\n连接数\n档案拥有者\n档案所属群组\n档案容量\n档案最后被修改时间\n档名\n\n文件类型和权限\n`drwxr-xr-x`\n\n第一位 d 表明档案类型是 目录\n\n| 字符 | 含义 |\n| --- | --- |\n| d | 目录 |\n| - | 文件 |\n| \\| | 链接文件 |\n| b | 设备文件中可供存储的周边设备, 可随机读取设备 |\n| c | 序列号设备, 如键盘鼠标, 一次性读取设备 |\n\n\n后面每三位一组 为`rwx`的组合 分别代表 `读`, `写`, `执行`\n三组 第一组`文件拥有者权限` 第二组`群组中账号权限` 第三组`非本人且没有加入本群组的其他账号权限`\n\n第三部分表示这个文件的`拥有者账号`\n第四部分表示这个文件`所属群组`\n\n相关命令\n-chgrp 改变文件所属群组\n-chown 改变文件拥有者\n-chmod 改变文件权限\n\n","slug":"操作系统-权限相关","published":1,"updated":"2020-03-14T10:14:04.755Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvn002k8cuo5nh7ca2j","content":"<p><code>drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs</code><br>档案权限类型<br>连接数<br>档案拥有者<br>档案所属群组<br>档案容量<br>档案最后被修改时间<br>档名</p>\n<p>文件类型和权限<br><code>drwxr-xr-x</code></p>\n<p>第一位 d 表明档案类型是 目录</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>d</td>\n<td>目录</td>\n</tr>\n<tr>\n<td>-</td>\n<td>文件</td>\n</tr>\n<tr>\n<td>|</td>\n<td>链接文件</td>\n</tr>\n<tr>\n<td>b</td>\n<td>设备文件中可供存储的周边设备, 可随机读取设备</td>\n</tr>\n<tr>\n<td>c</td>\n<td>序列号设备, 如键盘鼠标, 一次性读取设备</td>\n</tr>\n</tbody></table>\n<p>后面每三位一组 为<code>rwx</code>的组合 分别代表 <code>读</code>, <code>写</code>, <code>执行</code><br>三组 第一组<code>文件拥有者权限</code> 第二组<code>群组中账号权限</code> 第三组<code>非本人且没有加入本群组的其他账号权限</code></p>\n<p>第三部分表示这个文件的<code>拥有者账号</code><br>第四部分表示这个文件<code>所属群组</code></p>\n<p>相关命令<br>-chgrp 改变文件所属群组<br>-chown 改变文件拥有者<br>-chmod 改变文件权限</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>drwxr-xr-x | 3 | root | root | 4096 | Mar  2 20:26 | .vs</code><br>档案权限类型<br>连接数<br>档案拥有者<br>档案所属群组<br>档案容量<br>档案最后被修改时间<br>档名</p>\n<p>文件类型和权限<br><code>drwxr-xr-x</code></p>\n<p>第一位 d 表明档案类型是 目录</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>d</td>\n<td>目录</td>\n</tr>\n<tr>\n<td>-</td>\n<td>文件</td>\n</tr>\n<tr>\n<td>|</td>\n<td>链接文件</td>\n</tr>\n<tr>\n<td>b</td>\n<td>设备文件中可供存储的周边设备, 可随机读取设备</td>\n</tr>\n<tr>\n<td>c</td>\n<td>序列号设备, 如键盘鼠标, 一次性读取设备</td>\n</tr>\n</tbody></table>\n<p>后面每三位一组 为<code>rwx</code>的组合 分别代表 <code>读</code>, <code>写</code>, <code>执行</code><br>三组 第一组<code>文件拥有者权限</code> 第二组<code>群组中账号权限</code> 第三组<code>非本人且没有加入本群组的其他账号权限</code></p>\n<p>第三部分表示这个文件的<code>拥有者账号</code><br>第四部分表示这个文件<code>所属群组</code></p>\n<p>相关命令<br>-chgrp 改变文件所属群组<br>-chown 改变文件拥有者<br>-chmod 改变文件权限</p>\n"},{"title":"MongoDB基本使用","date":"2019-10-13T11:25:28.000Z","_content":"![](https://docs.mongodb.com/images/mongodb-logo.png)\n<!--more-->\n\n# 服务器相关\n## 基础概念\n在mongodb中基本的概念是文档、集合、数据库\n- 数据库\n一个mongodb中可以建立多个数据库。\n- 集合\n集合就是 MongoDB 文档组 集合处于数据库中 文档处于集合中\n- 文档\n文档是一组键值(key-value)对(即 BSON)\n文档对应数据记录的行\n\n## 安装驱动到Centos\n\n**升级cmake**\n```shell\nwget https://cmake.org/files/v3.6/cmake-3.6.2.tar.gz    \ntar xvf cmake-3.6.2.tar.gz && cd cmake-3.6.2/\n./bootstrap\n\ngmake\ngmake install（需要在su命令下执行，或者直接使用root账户安装）\n/usr/local/bin/cmake --version\n\nyum remove cmake -y\nln -s /usr/local/bin/cmake /usr/bin/\ncmake --version\n```\n**安装**\n\n[官方文档](https://mongoc.org/libmongoc/current/installing.html)\n## 安装驱动到Centos\n```\nyum install gcc-c++\n\nyum install clang\n\n# 安装boost\nyum -y install gcc-c++ python-devel bzip2-devel zlib-devel\ntar zxvf 安装包\nsudo ./bootstrap.sh --prefix=/usr/local/boost\nsudo ./b2 install\n进入 目录下的tools/build\nsudo ./bootstrap.sh\nsudo ./b2 install --prefix=/usr/local/boost\n\nwget https://cmake.org/files/v3.5/cmake-3.5.2.tar.gz\ntar -zxvf cmake-3.5.2.tar.gz\ncd cmake-3.5.2\n./bootstrap\ngmake\ngmake install\n\n# 删除原来cmake版本，建立软连接，测试\nyum remove cmake -y\nln -s /usr/local/bin/cmake /usr/bin/\ncmake --version\n\n# 安装pip\nyum install python-pip\npip install --upgrade pip\n\n# 安装py3\nhttps://segmentfault.com/a/1190000015628625\n```\n\n## 安装到Ubuntu 18.04\n[整理自官方文档](https://docs.mongodb.com/manual/administration/install-on-linux/)\n\n- 导入公共秘钥, 另你的系统\"信任\"下面的包\n```shell\nwget -qO - https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -\n```\n这一步需要显示OK\n- 导入第三方MongoDB源\n```shell\necho \"deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list\n```\n- 导入源之后更新\n```shell\nsudo apt-get update\n```\n- 安装MongoDB稳定版本包(我安装的时候稳定版本为4.2)\n```shell\nsudo apt-get install -y mongodb-org=4.2.0 mongodb-org-server=4.2.0 mongodb-org-shell=4.2.0 mongodb-org-mongos=4.2.0 mongodb-org-tools=4.2.0\n```\n- 禁用apt-get自动更新MongoDB\n```shell\necho \"mongodb-org hold\" | sudo dpkg --set-selections\necho \"mongodb-org-server hold\" | sudo dpkg --set-selections\necho \"mongodb-org-shell hold\" | sudo dpkg --set-selections\necho \"mongodb-org-mongos hold\" | sudo dpkg --set-selections\necho \"mongodb-org-tools hold\" | sudo dpkg --set-selections\n```\n## 基础shell操作\n**启动 关闭 重启**\n`sudo service mongod start(stop\\restart)`\n\n*启动成功标志*\n日志文件`/var/log/mongodb/mongod.log`中显示`waiting for connections on port 27017`\n\n**进入交互式命令行**\n`mongo`\n\n**指定端口运行 默认27017**\n`mongo --port 28015`\n\n**非安装机通过shell连接安装机**\n[直连](https://docs.mongodb.com/manual/mongo/#mongodb-instance-on-a-remote-host)\n[带登录验证](https://docs.mongodb.com/manual/mongo/#mongodb-instance-with-authentication)\n\n---\n\n**显示你正在使用的数据库**\n`db`\n**切换数据库**\n`use <database>`\n\n### CRUD\n\n**C**\n\n*插入一个文档*\n`db.collection.insertOne()` \n这里的collection代指的一个集合, 集合的名字可以自定义如果集合并不存在你的数据库中 则自动创建这个集合.\n```shell\ndb.inventory.insertOne(\n   { item: \"canvas\", qty: 100, tags: [\"cotton\"]}\n)\n```\n---\n*插入多个文档*\n`db.inventory.insertMany()`\n```shell\ndb.inventory.insertMany([\n   { item: \"journal\", qty: 25, tags: [\"blank\", \"red\"]},\n   { item: \"mat\", qty: 85, tags: [\"gray\"]},\n   { item: \"mousepad\", qty: 25, tags: [\"gel\", \"blue\"]}\n])\n```\n---\n*插入任意项的文档*\n`db.collection.insert()`\n\n---\n*_id项*\n每一个文档都有自己独一的id 如果插入文档的时候没有指定则会生成随机的`_id`\n```shell\n{ \"_id\" : ObjectId(\"5da325520e80dfd9258a29be\"), \"x\" : 1 }\n```\n可以通过在插入的时候指定`\"_id\": xxxx`来自定义id\n\n[额外的方法](https://docs.mongodb.com/manual/reference/insert-methods/#additional-methods-for-inserts)\n\n\n**R**\n`db.collection.find({ item: \"canvas\" })`\n[拦截器-](https://docs.mongodb.com/manual/core/document/#document-query-filter)在collection中查找含有`item: \"canvas\"`的文档, 并打印\n如果不含`{ item: \"canvas\" }`则代表打印所有的文档\n\n`db.collection.find({status: {$in: [ \"A\", \"D\" ]}})` \n`status: {$in: [ \"A\", \"D\" ]}`意为A, D不在此status中\n\n`db.inventory.find( { status: \"A\", qty: { $lt: 30 } } )`\n`qty: { $lt: 30 }`意为此qty的值少于30\n\n`db.inventory.find( { $or: [ { status: \"A\" }, { qty: { $lt: 30 } } ] } )`\n`{$or: [{ status: \"A\" }, { qty: { $lt: 30 }}]}`符合二者之一\n\n\n[2019年10月13日21:58:24 - 开头](https://docs.mongodb.com/manual/tutorial/query-embedded-documents/)\n\n# C++ Driver\n[照着官方文档安装了下](https://mongocxx.org/mongocxx-v3/installation/)\n期间遇到了两个坑一个是我没有安装Git导致提示无法克隆\n还有就是最后阶段我没安装pkg-config 导致的无法找到头文件\n\n接下来看一些简单的教程\n## CRUD\n```c++\n#include <cstdint>\n#include <iostream>\n#include <vector>\n#include <bsoncxx/json.hpp>\n#include <mongocxx/client.hpp>\n#include <mongocxx/stdx.hpp>\n#include <mongocxx/uri.hpp>\n#include <bsoncxx/builder/stream/helpers.hpp>\n#include <mongocxx/instance.hpp>\n#include <bsoncxx/builder/stream/document.hpp>\n\nusing bsoncxx::builder::stream::close_array;\nusing bsoncxx::builder::stream::close_document;\nusing bsoncxx::builder::stream::document;\nusing bsoncxx::builder::stream::finalize;\nusing bsoncxx::builder::stream::open_array;\nusing bsoncxx::builder::stream::open_document;\n\n\nvoid insert(mongocxx::collection coll_test)\n{\n\tauto builder = document{};\n\n\tbsoncxx::document::value doc_value = builder\n\t\t\t<< \"name\" << \"Lsmg\"\n\t\t\t<< \"type\" << \"Lemon\"\n\t\t\t<< \"count\" << 1\n\t\t\t<< \"versions\" << open_array\n\t\t\t<< \"v3.2\" << \"v3.0\" << \"v2.6\"\n\t\t\t<< close_array\n\t\t\t<< \"info\" << open_document\n\t\t\t<< \"x\" << 203\n\t\t\t<< \"y\" << 102\n\t\t\t<< close_document\n\t\t\t<< finalize;\n\n\tbsoncxx::document::view view_test = doc_value.view();\n\n\t// 打印插入内容制定key的value\n\tstd::string name = view_test[\"name\"].get_utf8().value.to_string();\n\tstd::cout << name << std::endl;\n\n\t// 获取插入ID\n\tauto result = coll_test.insert_one(view_test);\n\tstd::string id1 = result->inserted_id().get_oid().value.to_string();\n\tstd::cout << id1 << std::endl;\n\n}\n\nvoid insert_many(mongocxx::collection coll_test)\n{\n\t// 插入多个\n\tstd::vector<bsoncxx::document::value> documents;\n\tdocuments.reserve(10);\n\tfor (int i = 0; i < 10; ++i)\n\t{\n\t\tdocuments.push_back(document{} << \"i\" << i << finalize);\n\t}\n\tauto result = coll_test.insert_many(documents);\n\n\t// 获取多个的返回ID\n\tauto id_maps = result->inserted_ids();\n\tfor (auto iter : id_maps)\n\t{\n\t\tstd::cout << iter.second.get_oid().value.to_string() << std::endl;\n\t}\n\n}\n\nvoid find(mongocxx::collection coll_test)\n{\n\t// 查询\n\tmongocxx::cursor cursor = coll_test.find({});\n\tfor (auto doc : cursor)\n\t{\n\t\tstd::cout << bsoncxx::to_json(doc) << \"\\n\";\n\t}\n}\n\n\nvoid update_one(mongocxx::collection coll_test)\n{\n\tcoll_test.update_one(document{} << \"i\" << 9 << finalize,\n\t\t\tdocument{} << \"$set\" << open_document <<\n\t\t\t\"i\" << 110 << close_document << finalize);\n}\n\nvoid update_many(mongocxx::collection coll_test)\n{\n\n\tcoll_test.update_many(document{} << \"i\" << open_document <<\n\t\t\t\t\t           \"$lt\" << 8 << close_document << finalize,\n\t\t\tdocument{} << \"$inc\" << open_document <<\n\t\t\t\t\t           \"i\" << 100 << close_document << finalize);\n}\n\nvoid delete_one(mongocxx::collection coll_test)\n{\n\tcoll_test.delete_one(document{} << \"i\" << 110 << finalize);\n}\n\nvoid delete_many(mongocxx::collection coll_test)\n{\n\t// 删除存在 i： 0 的文档\n\tcoll_test.delete_many(document{} << \"i\" << 0 << finalize);\n\n\t/*\n\t * (>) 大于 - $gt\n\t * (<) 小于 - $lt\n\t * (>=) 大于等于 - $gte\n\t * (<= ) 小于等于 - $lte\n\t * */\n\n\t// 删除 i大于3小于8的文档\n\tcoll_test.delete_many(document{} << \"i\" << open_document <<\n\t                                 \"$gt\" << 0 <<\n\t                                 \"$lt\" << 200 <<\n\t                                 close_document << finalize);\n}\n\nvoid create_index(mongocxx::collection coll_test)\n{\n\n\t// 1 代表生序 -1代表降序\n\tauto index_specification = document{} << \"i\" << -1 << finalize;\n\n\t// move的本质就是帮助编译器选择重载函数, 告诉编译器\"请尽量把此参数当做右值来处理\"\n\tcoll_test.create_index(std::move(index_specification));\n}\n\nint main()\n{\n\tmongocxx::instance instance{};\n\tmongocxx::client client{mongocxx::uri{}};\n\n\tmongocxx::database db = client[\"mydb\"];\n\tmongocxx::collection coll_test = db[\"test\"];\n\n\tcreate_index(coll_test);\n\n\tfind(coll_test);\n\n\n\texit(0);\n}\n```\n## 线程安全相关\n不能同时对一个client的多个线程同时操作.\n同时只能有一个线程对一个client操作, 包括对`mongocxx::client`的`mongocxx::client_session`, `mongocxx::database, mongocxx::collection`, and `mongocxx::cursor`同样如此\n\n简单解决可以通过用同一个`mongocxx::uri`生成多个`mongocxx::client`来解决这个问题\n\n最好的解决方法用`mongocxx::uri`生成一个`mongocxx::pool` 通过`mongocxx::pool`的`acquire()`来获取操作的client\n官方demo如下\n```c++\nmongocxx::instance instance{};\nmongocxx::pool pool{mongocxx::uri{}};\n\nauto threadfunc = [](mongocxx::client& client, std::string dbname) {\n  auto col = client[dbname][\"col\"].insert_one({});\n};\n\n// Great! Using the pool allows the clients to be synchronized while sharing only one\n// background monitoring thread.\nstd::thread t1 ([&]() {\n  auto c = pool.acquire();\n  threadfunc(*c, \"db1\");\n  threadfunc(*c, \"db2\");\n});\n\nstd::thread t2 ([&]() {\n  auto c = pool.acquire();\n  threadfunc(*c, \"db2\");\n  threadfunc(*c, \"db1\");\n});\n\nt1.join();\nt2.join();\n```\n\n关于fork的安全性\n`Neither a mongocxx::client or a mongocxx::pool can be safely copied when forking. Because of this, any client or pool must be created after forking, not before.`\n\n官方建议使用`mongocxx::pool`而不是`mongocxx::client` 即使你的应用只有一个线程\n`mongocxx::client` 每60S会检查一次自己监控的cluster, 使用前者会有专门的线程来进行检查而且是10S一次\n\n`mongocxx::pool`可以用于多线程中, 也能用来创建客户端. 然而每个`mongocxx::client`只能被一个线程使用`最大默认为100 最小默认为0`\n\n## BSON\n**Document Builders**\n一共提供了三个接口来创建文档\n官网上提到`这三个接口会得到同样的结果, 选择哪个完全是由于美学`\n\n*“One-off” builder functions*\n```c++\nusing bsoncxx::builder::basic::kvp;\n// { \"hello\": \"world\" }\nbsoncxx::document::value document = bsoncxx::builder::basic::make_document(kvp(\"hello\", \"world\"));\n```\n\n*Basic builder*\n```c++\nusing bsoncxx::builder::basic::kvp;\n// { \"hello\" : \"world\" }\nbsoncxx::builder::basic::document basic_builder{};\nbasic_builder.append(kvp(\"hello\", \"world\"));\nbsoncxx::document::value document = basic_builder.extract();\n\n// basic::document builds a BSON document.\nauto doc = builder::basic::document{};\n// 通过使用kvp(k, v) 来 append 键值对 to a document \nusing bsoncxx::builder::basic::kvp;\n\ndoc.append(k, v); // 插入一般的键值对\n// 对于k一般为string\n// 对于v则包含多种情况 可以使用 bsoncxx::types命名空间里的如下类型\nstruct b_eod;\nstruct b_double; // types::b_double{3.14159}\nstruct b_utf8;\nstruct b_document;\nstruct b_array;\nstruct b_binary;\nstruct b_undefined;\nstruct b_oid;\nstruct b_bool; // types::b_bool{false}\nstruct b_date; \nstruct b_null;\nstruct b_regex;\nstruct b_dbpointer;\nstruct b_code;\nstruct b_symbol;\nstruct b_codewscope;\nstruct b_int32;\nstruct b_timestamp;\nstruct b_int64;\nstruct b_decimal128;\nstruct b_minkey;\nstruct b_maxkey;\n\n// 插入k v (v是数组)\narr.append(\"hello\");\narr.append(false, types::b_bool{true}, types::b_double{1.234});\n\n// We can get a view of the resulting bson by calling view()\nauto v = doc.view();\n\n// Use 'v' so we don't get compiler warnings.\nreturn v.empty() ? EXIT_FAILURE : EXIT_SUCCESS;\n```\n\n*Stream builder*\n我现在最喜欢的方法, 不过官方不建议这样, 因为需要保持这个流不被重新初始化, 这样在跨行生成的时候有困难.\n官方建议使用上面的两个方法\n```c++\n// { \"hello\" : \"world\" }\nusing bsoncxx::builder::stream;\nbsoncxx::document::value document = stream::document{} << \"hello\" << \"world\" << stream::finalize;\n\n// 此外还有\nusing builder::stream::open_document; // {\nusing builder::stream::close_document;// }\nusing builder::stream::open_array; // [\nusing builder::stream::close_array;// ]\n```\n\n**Building arrays**\n```c++\n// [ 1, 2, 3 ]\n\nconst auto elements = {1, 2, 3};\nauto array_builder = bsoncxx::builder::basic::array{};\n\nfor (const auto& element : elements) {\n    array_builder.append(element);\n}\n```\n通过使用lambda来构建 k, v (v是数组)\n```c++\n// { \"foo\" : [ 1, 2, 3 ] }\n\nusing bsoncxx::builder::basic::kvp;\nusing bsoncxx::builder::basic::sub_array;\n\nconst auto elements = {1, 2, 3};\nauto doc = bsoncxx::builder::basic::document{};\ndoc.append(kvp(\"foo\", [&elements](sub_array child) {\n    for (const auto& element : elements) {\n        child.append(element);\n    }\n}));\n```\n\n通过使用流来生成\n```c++\n// { \"subdocs\" : [ { \"key\" : 1 }, { \"key\" : 2 }, { \"key\" : 3 } ], \"another_key\" : 42 }\nusing namespace bsoncxx;\n\nbuilder::stream::document builder{};\n\nauto in_array = builder << \"subdocs\" << builder::stream::open_array;\nfor (auto&& e : {1, 2, 3}) {\n    in_array = in_array << builder::stream::open_document << \"key\" << e\n                        << builder::stream::close_document;\n}\nauto after_array = in_array << builder::stream::close_array;\n\nafter_array << \"another_key\" << 42;\n\ndocument::value doc = after_array << builder::stream::finalize;\n\nstd::cout << to_json(doc) << std::endl;\n```","source":"_posts/数据库-MongoDB-MongoDB基本使用.md","raw":"---\ntitle: MongoDB基本使用\ntags:\n  - MongoDB\ncategories:\n  - 数据库\n  - MongoDB\ndate: 2019-10-13 19:25:28\n---\n![](https://docs.mongodb.com/images/mongodb-logo.png)\n<!--more-->\n\n# 服务器相关\n## 基础概念\n在mongodb中基本的概念是文档、集合、数据库\n- 数据库\n一个mongodb中可以建立多个数据库。\n- 集合\n集合就是 MongoDB 文档组 集合处于数据库中 文档处于集合中\n- 文档\n文档是一组键值(key-value)对(即 BSON)\n文档对应数据记录的行\n\n## 安装驱动到Centos\n\n**升级cmake**\n```shell\nwget https://cmake.org/files/v3.6/cmake-3.6.2.tar.gz    \ntar xvf cmake-3.6.2.tar.gz && cd cmake-3.6.2/\n./bootstrap\n\ngmake\ngmake install（需要在su命令下执行，或者直接使用root账户安装）\n/usr/local/bin/cmake --version\n\nyum remove cmake -y\nln -s /usr/local/bin/cmake /usr/bin/\ncmake --version\n```\n**安装**\n\n[官方文档](https://mongoc.org/libmongoc/current/installing.html)\n## 安装驱动到Centos\n```\nyum install gcc-c++\n\nyum install clang\n\n# 安装boost\nyum -y install gcc-c++ python-devel bzip2-devel zlib-devel\ntar zxvf 安装包\nsudo ./bootstrap.sh --prefix=/usr/local/boost\nsudo ./b2 install\n进入 目录下的tools/build\nsudo ./bootstrap.sh\nsudo ./b2 install --prefix=/usr/local/boost\n\nwget https://cmake.org/files/v3.5/cmake-3.5.2.tar.gz\ntar -zxvf cmake-3.5.2.tar.gz\ncd cmake-3.5.2\n./bootstrap\ngmake\ngmake install\n\n# 删除原来cmake版本，建立软连接，测试\nyum remove cmake -y\nln -s /usr/local/bin/cmake /usr/bin/\ncmake --version\n\n# 安装pip\nyum install python-pip\npip install --upgrade pip\n\n# 安装py3\nhttps://segmentfault.com/a/1190000015628625\n```\n\n## 安装到Ubuntu 18.04\n[整理自官方文档](https://docs.mongodb.com/manual/administration/install-on-linux/)\n\n- 导入公共秘钥, 另你的系统\"信任\"下面的包\n```shell\nwget -qO - https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -\n```\n这一步需要显示OK\n- 导入第三方MongoDB源\n```shell\necho \"deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list\n```\n- 导入源之后更新\n```shell\nsudo apt-get update\n```\n- 安装MongoDB稳定版本包(我安装的时候稳定版本为4.2)\n```shell\nsudo apt-get install -y mongodb-org=4.2.0 mongodb-org-server=4.2.0 mongodb-org-shell=4.2.0 mongodb-org-mongos=4.2.0 mongodb-org-tools=4.2.0\n```\n- 禁用apt-get自动更新MongoDB\n```shell\necho \"mongodb-org hold\" | sudo dpkg --set-selections\necho \"mongodb-org-server hold\" | sudo dpkg --set-selections\necho \"mongodb-org-shell hold\" | sudo dpkg --set-selections\necho \"mongodb-org-mongos hold\" | sudo dpkg --set-selections\necho \"mongodb-org-tools hold\" | sudo dpkg --set-selections\n```\n## 基础shell操作\n**启动 关闭 重启**\n`sudo service mongod start(stop\\restart)`\n\n*启动成功标志*\n日志文件`/var/log/mongodb/mongod.log`中显示`waiting for connections on port 27017`\n\n**进入交互式命令行**\n`mongo`\n\n**指定端口运行 默认27017**\n`mongo --port 28015`\n\n**非安装机通过shell连接安装机**\n[直连](https://docs.mongodb.com/manual/mongo/#mongodb-instance-on-a-remote-host)\n[带登录验证](https://docs.mongodb.com/manual/mongo/#mongodb-instance-with-authentication)\n\n---\n\n**显示你正在使用的数据库**\n`db`\n**切换数据库**\n`use <database>`\n\n### CRUD\n\n**C**\n\n*插入一个文档*\n`db.collection.insertOne()` \n这里的collection代指的一个集合, 集合的名字可以自定义如果集合并不存在你的数据库中 则自动创建这个集合.\n```shell\ndb.inventory.insertOne(\n   { item: \"canvas\", qty: 100, tags: [\"cotton\"]}\n)\n```\n---\n*插入多个文档*\n`db.inventory.insertMany()`\n```shell\ndb.inventory.insertMany([\n   { item: \"journal\", qty: 25, tags: [\"blank\", \"red\"]},\n   { item: \"mat\", qty: 85, tags: [\"gray\"]},\n   { item: \"mousepad\", qty: 25, tags: [\"gel\", \"blue\"]}\n])\n```\n---\n*插入任意项的文档*\n`db.collection.insert()`\n\n---\n*_id项*\n每一个文档都有自己独一的id 如果插入文档的时候没有指定则会生成随机的`_id`\n```shell\n{ \"_id\" : ObjectId(\"5da325520e80dfd9258a29be\"), \"x\" : 1 }\n```\n可以通过在插入的时候指定`\"_id\": xxxx`来自定义id\n\n[额外的方法](https://docs.mongodb.com/manual/reference/insert-methods/#additional-methods-for-inserts)\n\n\n**R**\n`db.collection.find({ item: \"canvas\" })`\n[拦截器-](https://docs.mongodb.com/manual/core/document/#document-query-filter)在collection中查找含有`item: \"canvas\"`的文档, 并打印\n如果不含`{ item: \"canvas\" }`则代表打印所有的文档\n\n`db.collection.find({status: {$in: [ \"A\", \"D\" ]}})` \n`status: {$in: [ \"A\", \"D\" ]}`意为A, D不在此status中\n\n`db.inventory.find( { status: \"A\", qty: { $lt: 30 } } )`\n`qty: { $lt: 30 }`意为此qty的值少于30\n\n`db.inventory.find( { $or: [ { status: \"A\" }, { qty: { $lt: 30 } } ] } )`\n`{$or: [{ status: \"A\" }, { qty: { $lt: 30 }}]}`符合二者之一\n\n\n[2019年10月13日21:58:24 - 开头](https://docs.mongodb.com/manual/tutorial/query-embedded-documents/)\n\n# C++ Driver\n[照着官方文档安装了下](https://mongocxx.org/mongocxx-v3/installation/)\n期间遇到了两个坑一个是我没有安装Git导致提示无法克隆\n还有就是最后阶段我没安装pkg-config 导致的无法找到头文件\n\n接下来看一些简单的教程\n## CRUD\n```c++\n#include <cstdint>\n#include <iostream>\n#include <vector>\n#include <bsoncxx/json.hpp>\n#include <mongocxx/client.hpp>\n#include <mongocxx/stdx.hpp>\n#include <mongocxx/uri.hpp>\n#include <bsoncxx/builder/stream/helpers.hpp>\n#include <mongocxx/instance.hpp>\n#include <bsoncxx/builder/stream/document.hpp>\n\nusing bsoncxx::builder::stream::close_array;\nusing bsoncxx::builder::stream::close_document;\nusing bsoncxx::builder::stream::document;\nusing bsoncxx::builder::stream::finalize;\nusing bsoncxx::builder::stream::open_array;\nusing bsoncxx::builder::stream::open_document;\n\n\nvoid insert(mongocxx::collection coll_test)\n{\n\tauto builder = document{};\n\n\tbsoncxx::document::value doc_value = builder\n\t\t\t<< \"name\" << \"Lsmg\"\n\t\t\t<< \"type\" << \"Lemon\"\n\t\t\t<< \"count\" << 1\n\t\t\t<< \"versions\" << open_array\n\t\t\t<< \"v3.2\" << \"v3.0\" << \"v2.6\"\n\t\t\t<< close_array\n\t\t\t<< \"info\" << open_document\n\t\t\t<< \"x\" << 203\n\t\t\t<< \"y\" << 102\n\t\t\t<< close_document\n\t\t\t<< finalize;\n\n\tbsoncxx::document::view view_test = doc_value.view();\n\n\t// 打印插入内容制定key的value\n\tstd::string name = view_test[\"name\"].get_utf8().value.to_string();\n\tstd::cout << name << std::endl;\n\n\t// 获取插入ID\n\tauto result = coll_test.insert_one(view_test);\n\tstd::string id1 = result->inserted_id().get_oid().value.to_string();\n\tstd::cout << id1 << std::endl;\n\n}\n\nvoid insert_many(mongocxx::collection coll_test)\n{\n\t// 插入多个\n\tstd::vector<bsoncxx::document::value> documents;\n\tdocuments.reserve(10);\n\tfor (int i = 0; i < 10; ++i)\n\t{\n\t\tdocuments.push_back(document{} << \"i\" << i << finalize);\n\t}\n\tauto result = coll_test.insert_many(documents);\n\n\t// 获取多个的返回ID\n\tauto id_maps = result->inserted_ids();\n\tfor (auto iter : id_maps)\n\t{\n\t\tstd::cout << iter.second.get_oid().value.to_string() << std::endl;\n\t}\n\n}\n\nvoid find(mongocxx::collection coll_test)\n{\n\t// 查询\n\tmongocxx::cursor cursor = coll_test.find({});\n\tfor (auto doc : cursor)\n\t{\n\t\tstd::cout << bsoncxx::to_json(doc) << \"\\n\";\n\t}\n}\n\n\nvoid update_one(mongocxx::collection coll_test)\n{\n\tcoll_test.update_one(document{} << \"i\" << 9 << finalize,\n\t\t\tdocument{} << \"$set\" << open_document <<\n\t\t\t\"i\" << 110 << close_document << finalize);\n}\n\nvoid update_many(mongocxx::collection coll_test)\n{\n\n\tcoll_test.update_many(document{} << \"i\" << open_document <<\n\t\t\t\t\t           \"$lt\" << 8 << close_document << finalize,\n\t\t\tdocument{} << \"$inc\" << open_document <<\n\t\t\t\t\t           \"i\" << 100 << close_document << finalize);\n}\n\nvoid delete_one(mongocxx::collection coll_test)\n{\n\tcoll_test.delete_one(document{} << \"i\" << 110 << finalize);\n}\n\nvoid delete_many(mongocxx::collection coll_test)\n{\n\t// 删除存在 i： 0 的文档\n\tcoll_test.delete_many(document{} << \"i\" << 0 << finalize);\n\n\t/*\n\t * (>) 大于 - $gt\n\t * (<) 小于 - $lt\n\t * (>=) 大于等于 - $gte\n\t * (<= ) 小于等于 - $lte\n\t * */\n\n\t// 删除 i大于3小于8的文档\n\tcoll_test.delete_many(document{} << \"i\" << open_document <<\n\t                                 \"$gt\" << 0 <<\n\t                                 \"$lt\" << 200 <<\n\t                                 close_document << finalize);\n}\n\nvoid create_index(mongocxx::collection coll_test)\n{\n\n\t// 1 代表生序 -1代表降序\n\tauto index_specification = document{} << \"i\" << -1 << finalize;\n\n\t// move的本质就是帮助编译器选择重载函数, 告诉编译器\"请尽量把此参数当做右值来处理\"\n\tcoll_test.create_index(std::move(index_specification));\n}\n\nint main()\n{\n\tmongocxx::instance instance{};\n\tmongocxx::client client{mongocxx::uri{}};\n\n\tmongocxx::database db = client[\"mydb\"];\n\tmongocxx::collection coll_test = db[\"test\"];\n\n\tcreate_index(coll_test);\n\n\tfind(coll_test);\n\n\n\texit(0);\n}\n```\n## 线程安全相关\n不能同时对一个client的多个线程同时操作.\n同时只能有一个线程对一个client操作, 包括对`mongocxx::client`的`mongocxx::client_session`, `mongocxx::database, mongocxx::collection`, and `mongocxx::cursor`同样如此\n\n简单解决可以通过用同一个`mongocxx::uri`生成多个`mongocxx::client`来解决这个问题\n\n最好的解决方法用`mongocxx::uri`生成一个`mongocxx::pool` 通过`mongocxx::pool`的`acquire()`来获取操作的client\n官方demo如下\n```c++\nmongocxx::instance instance{};\nmongocxx::pool pool{mongocxx::uri{}};\n\nauto threadfunc = [](mongocxx::client& client, std::string dbname) {\n  auto col = client[dbname][\"col\"].insert_one({});\n};\n\n// Great! Using the pool allows the clients to be synchronized while sharing only one\n// background monitoring thread.\nstd::thread t1 ([&]() {\n  auto c = pool.acquire();\n  threadfunc(*c, \"db1\");\n  threadfunc(*c, \"db2\");\n});\n\nstd::thread t2 ([&]() {\n  auto c = pool.acquire();\n  threadfunc(*c, \"db2\");\n  threadfunc(*c, \"db1\");\n});\n\nt1.join();\nt2.join();\n```\n\n关于fork的安全性\n`Neither a mongocxx::client or a mongocxx::pool can be safely copied when forking. Because of this, any client or pool must be created after forking, not before.`\n\n官方建议使用`mongocxx::pool`而不是`mongocxx::client` 即使你的应用只有一个线程\n`mongocxx::client` 每60S会检查一次自己监控的cluster, 使用前者会有专门的线程来进行检查而且是10S一次\n\n`mongocxx::pool`可以用于多线程中, 也能用来创建客户端. 然而每个`mongocxx::client`只能被一个线程使用`最大默认为100 最小默认为0`\n\n## BSON\n**Document Builders**\n一共提供了三个接口来创建文档\n官网上提到`这三个接口会得到同样的结果, 选择哪个完全是由于美学`\n\n*“One-off” builder functions*\n```c++\nusing bsoncxx::builder::basic::kvp;\n// { \"hello\": \"world\" }\nbsoncxx::document::value document = bsoncxx::builder::basic::make_document(kvp(\"hello\", \"world\"));\n```\n\n*Basic builder*\n```c++\nusing bsoncxx::builder::basic::kvp;\n// { \"hello\" : \"world\" }\nbsoncxx::builder::basic::document basic_builder{};\nbasic_builder.append(kvp(\"hello\", \"world\"));\nbsoncxx::document::value document = basic_builder.extract();\n\n// basic::document builds a BSON document.\nauto doc = builder::basic::document{};\n// 通过使用kvp(k, v) 来 append 键值对 to a document \nusing bsoncxx::builder::basic::kvp;\n\ndoc.append(k, v); // 插入一般的键值对\n// 对于k一般为string\n// 对于v则包含多种情况 可以使用 bsoncxx::types命名空间里的如下类型\nstruct b_eod;\nstruct b_double; // types::b_double{3.14159}\nstruct b_utf8;\nstruct b_document;\nstruct b_array;\nstruct b_binary;\nstruct b_undefined;\nstruct b_oid;\nstruct b_bool; // types::b_bool{false}\nstruct b_date; \nstruct b_null;\nstruct b_regex;\nstruct b_dbpointer;\nstruct b_code;\nstruct b_symbol;\nstruct b_codewscope;\nstruct b_int32;\nstruct b_timestamp;\nstruct b_int64;\nstruct b_decimal128;\nstruct b_minkey;\nstruct b_maxkey;\n\n// 插入k v (v是数组)\narr.append(\"hello\");\narr.append(false, types::b_bool{true}, types::b_double{1.234});\n\n// We can get a view of the resulting bson by calling view()\nauto v = doc.view();\n\n// Use 'v' so we don't get compiler warnings.\nreturn v.empty() ? EXIT_FAILURE : EXIT_SUCCESS;\n```\n\n*Stream builder*\n我现在最喜欢的方法, 不过官方不建议这样, 因为需要保持这个流不被重新初始化, 这样在跨行生成的时候有困难.\n官方建议使用上面的两个方法\n```c++\n// { \"hello\" : \"world\" }\nusing bsoncxx::builder::stream;\nbsoncxx::document::value document = stream::document{} << \"hello\" << \"world\" << stream::finalize;\n\n// 此外还有\nusing builder::stream::open_document; // {\nusing builder::stream::close_document;// }\nusing builder::stream::open_array; // [\nusing builder::stream::close_array;// ]\n```\n\n**Building arrays**\n```c++\n// [ 1, 2, 3 ]\n\nconst auto elements = {1, 2, 3};\nauto array_builder = bsoncxx::builder::basic::array{};\n\nfor (const auto& element : elements) {\n    array_builder.append(element);\n}\n```\n通过使用lambda来构建 k, v (v是数组)\n```c++\n// { \"foo\" : [ 1, 2, 3 ] }\n\nusing bsoncxx::builder::basic::kvp;\nusing bsoncxx::builder::basic::sub_array;\n\nconst auto elements = {1, 2, 3};\nauto doc = bsoncxx::builder::basic::document{};\ndoc.append(kvp(\"foo\", [&elements](sub_array child) {\n    for (const auto& element : elements) {\n        child.append(element);\n    }\n}));\n```\n\n通过使用流来生成\n```c++\n// { \"subdocs\" : [ { \"key\" : 1 }, { \"key\" : 2 }, { \"key\" : 3 } ], \"another_key\" : 42 }\nusing namespace bsoncxx;\n\nbuilder::stream::document builder{};\n\nauto in_array = builder << \"subdocs\" << builder::stream::open_array;\nfor (auto&& e : {1, 2, 3}) {\n    in_array = in_array << builder::stream::open_document << \"key\" << e\n                        << builder::stream::close_document;\n}\nauto after_array = in_array << builder::stream::close_array;\n\nafter_array << \"another_key\" << 42;\n\ndocument::value doc = after_array << builder::stream::finalize;\n\nstd::cout << to_json(doc) << std::endl;\n```","slug":"数据库-MongoDB-MongoDB基本使用","published":1,"updated":"2020-03-06T07:54:04.325Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvo002o8cuo7ei03my6","content":"<p><img src=\"https://docs.mongodb.com/images/mongodb-logo.png\" alt=\"\"></p>\n<a id=\"more\"></a>\n\n<h1 id=\"服务器相关\"><a href=\"#服务器相关\" class=\"headerlink\" title=\"服务器相关\"></a>服务器相关</h1><h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><p>在mongodb中基本的概念是文档、集合、数据库</p>\n<ul>\n<li>数据库<br>一个mongodb中可以建立多个数据库。</li>\n<li>集合<br>集合就是 MongoDB 文档组 集合处于数据库中 文档处于集合中</li>\n<li>文档<br>文档是一组键值(key-value)对(即 BSON)<br>文档对应数据记录的行</li>\n</ul>\n<h2 id=\"安装驱动到Centos\"><a href=\"#安装驱动到Centos\" class=\"headerlink\" title=\"安装驱动到Centos\"></a>安装驱动到Centos</h2><p><strong>升级cmake</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://cmake.org/files/v3.6/cmake-3.6.2.tar.gz    </span><br><span class=\"line\">tar xvf cmake-3.6.2.tar.gz &amp;&amp; cd cmake-3.6.2/</span><br><span class=\"line\">./bootstrap</span><br><span class=\"line\"></span><br><span class=\"line\">gmake</span><br><span class=\"line\">gmake install（需要在su命令下执行，或者直接使用root账户安装）</span><br><span class=\"line\">/usr/local/bin/cmake --version</span><br><span class=\"line\"></span><br><span class=\"line\">yum remove cmake -y</span><br><span class=\"line\">ln -s /usr/local/bin/cmake /usr/bin/</span><br><span class=\"line\">cmake --version</span><br></pre></td></tr></table></figure>\n<p><strong>安装</strong></p>\n<p><a href=\"https://mongoc.org/libmongoc/current/installing.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h2 id=\"安装驱动到Centos-1\"><a href=\"#安装驱动到Centos-1\" class=\"headerlink\" title=\"安装驱动到Centos\"></a>安装驱动到Centos</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install gcc-c++</span><br><span class=\"line\"></span><br><span class=\"line\">yum install clang</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装boost</span><br><span class=\"line\">yum -y install gcc-c++ python-devel bzip2-devel zlib-devel</span><br><span class=\"line\">tar zxvf 安装包</span><br><span class=\"line\">sudo .&#x2F;bootstrap.sh --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;boost</span><br><span class=\"line\">sudo .&#x2F;b2 install</span><br><span class=\"line\">进入 目录下的tools&#x2F;build</span><br><span class=\"line\">sudo .&#x2F;bootstrap.sh</span><br><span class=\"line\">sudo .&#x2F;b2 install --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;boost</span><br><span class=\"line\"></span><br><span class=\"line\">wget https:&#x2F;&#x2F;cmake.org&#x2F;files&#x2F;v3.5&#x2F;cmake-3.5.2.tar.gz</span><br><span class=\"line\">tar -zxvf cmake-3.5.2.tar.gz</span><br><span class=\"line\">cd cmake-3.5.2</span><br><span class=\"line\">.&#x2F;bootstrap</span><br><span class=\"line\">gmake</span><br><span class=\"line\">gmake install</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除原来cmake版本，建立软连接，测试</span><br><span class=\"line\">yum remove cmake -y</span><br><span class=\"line\">ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;cmake &#x2F;usr&#x2F;bin&#x2F;</span><br><span class=\"line\">cmake --version</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装pip</span><br><span class=\"line\">yum install python-pip</span><br><span class=\"line\">pip install --upgrade pip</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装py3</span><br><span class=\"line\">https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000015628625</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装到Ubuntu-18-04\"><a href=\"#安装到Ubuntu-18-04\" class=\"headerlink\" title=\"安装到Ubuntu 18.04\"></a>安装到Ubuntu 18.04</h2><p><a href=\"https://docs.mongodb.com/manual/administration/install-on-linux/\" target=\"_blank\" rel=\"noopener\">整理自官方文档</a></p>\n<ul>\n<li>导入公共秘钥, 另你的系统”信任”下面的包<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO - https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -</span><br></pre></td></tr></table></figure>\n这一步需要显示OK</li>\n<li>导入第三方MongoDB源<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list</span><br></pre></td></tr></table></figure></li>\n<li>导入源之后更新<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure></li>\n<li>安装MongoDB稳定版本包(我安装的时候稳定版本为4.2)<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install -y mongodb-org=4.2.0 mongodb-org-server=4.2.0 mongodb-org-shell=4.2.0 mongodb-org-mongos=4.2.0 mongodb-org-tools=4.2.0</span><br></pre></td></tr></table></figure></li>\n<li>禁用apt-get自动更新MongoDB<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"mongodb-org hold\" | sudo dpkg --set-selections</span><br><span class=\"line\">echo \"mongodb-org-server hold\" | sudo dpkg --set-selections</span><br><span class=\"line\">echo \"mongodb-org-shell hold\" | sudo dpkg --set-selections</span><br><span class=\"line\">echo \"mongodb-org-mongos hold\" | sudo dpkg --set-selections</span><br><span class=\"line\">echo \"mongodb-org-tools hold\" | sudo dpkg --set-selections</span><br></pre></td></tr></table></figure>\n<h2 id=\"基础shell操作\"><a href=\"#基础shell操作\" class=\"headerlink\" title=\"基础shell操作\"></a>基础shell操作</h2></li>\n</ul>\n<p><strong>启动 关闭 重启</strong><br><code>sudo service mongod start(stop\\restart)</code></p>\n<p><em>启动成功标志</em><br>日志文件<code>/var/log/mongodb/mongod.log</code>中显示<code>waiting for connections on port 27017</code></p>\n<p><strong>进入交互式命令行</strong><br><code>mongo</code></p>\n<p><strong>指定端口运行 默认27017</strong><br><code>mongo --port 28015</code></p>\n<p><strong>非安装机通过shell连接安装机</strong><br><a href=\"https://docs.mongodb.com/manual/mongo/#mongodb-instance-on-a-remote-host\" target=\"_blank\" rel=\"noopener\">直连</a><br><a href=\"https://docs.mongodb.com/manual/mongo/#mongodb-instance-with-authentication\" target=\"_blank\" rel=\"noopener\">带登录验证</a></p>\n<hr>\n<p><strong>显示你正在使用的数据库</strong><br><code>db</code><br><strong>切换数据库</strong><br><code>use &lt;database&gt;</code></p>\n<h3 id=\"CRUD\"><a href=\"#CRUD\" class=\"headerlink\" title=\"CRUD\"></a>CRUD</h3><p><strong>C</strong></p>\n<p><em>插入一个文档</em><br><code>db.collection.insertOne()</code><br>这里的collection代指的一个集合, 集合的名字可以自定义如果集合并不存在你的数据库中 则自动创建这个集合.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.inventory.insertOne(</span><br><span class=\"line\">   &#123; item: \"canvas\", qty: 100, tags: [\"cotton\"]&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<hr>\n<p><em>插入多个文档</em><br><code>db.inventory.insertMany()</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.inventory.insertMany([</span><br><span class=\"line\">   &#123; item: \"journal\", qty: 25, tags: [\"blank\", \"red\"]&#125;,</span><br><span class=\"line\">   &#123; item: \"mat\", qty: 85, tags: [\"gray\"]&#125;,</span><br><span class=\"line\">   &#123; item: \"mousepad\", qty: 25, tags: [\"gel\", \"blue\"]&#125;</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n<hr>\n<p><em>插入任意项的文档</em><br><code>db.collection.insert()</code></p>\n<hr>\n<p><em>_id项</em><br>每一个文档都有自己独一的id 如果插入文档的时候没有指定则会生成随机的<code>_id</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; \"_id\" : ObjectId(\"5da325520e80dfd9258a29be\"), \"x\" : 1 &#125;</span><br></pre></td></tr></table></figure>\n<p>可以通过在插入的时候指定<code>&quot;_id&quot;: xxxx</code>来自定义id</p>\n<p><a href=\"https://docs.mongodb.com/manual/reference/insert-methods/#additional-methods-for-inserts\" target=\"_blank\" rel=\"noopener\">额外的方法</a></p>\n<p><strong>R</strong><br><code>db.collection.find({ item: &quot;canvas&quot; })</code><br><a href=\"https://docs.mongodb.com/manual/core/document/#document-query-filter\" target=\"_blank\" rel=\"noopener\">拦截器-</a>在collection中查找含有<code>item: &quot;canvas&quot;</code>的文档, 并打印<br>如果不含<code>{ item: &quot;canvas&quot; }</code>则代表打印所有的文档</p>\n<p><code>db.collection.find({status: {$in: [ &quot;A&quot;, &quot;D&quot; ]}})</code><br><code>status: {$in: [ &quot;A&quot;, &quot;D&quot; ]}</code>意为A, D不在此status中</p>\n<p><code>db.inventory.find( { status: &quot;A&quot;, qty: { $lt: 30 } } )</code><br><code>qty: { $lt: 30 }</code>意为此qty的值少于30</p>\n<p><code>db.inventory.find( { $or: [ { status: &quot;A&quot; }, { qty: { $lt: 30 } } ] } )</code><br><code>{$or: [{ status: &quot;A&quot; }, { qty: { $lt: 30 }}]}</code>符合二者之一</p>\n<p><a href=\"https://docs.mongodb.com/manual/tutorial/query-embedded-documents/\" target=\"_blank\" rel=\"noopener\">2019年10月13日21:58:24 - 开头</a></p>\n<h1 id=\"C-Driver\"><a href=\"#C-Driver\" class=\"headerlink\" title=\"C++ Driver\"></a>C++ Driver</h1><p><a href=\"https://mongocxx.org/mongocxx-v3/installation/\" target=\"_blank\" rel=\"noopener\">照着官方文档安装了下</a><br>期间遇到了两个坑一个是我没有安装Git导致提示无法克隆<br>还有就是最后阶段我没安装pkg-config 导致的无法找到头文件</p>\n<p>接下来看一些简单的教程</p>\n<h2 id=\"CRUD-1\"><a href=\"#CRUD-1\" class=\"headerlink\" title=\"CRUD\"></a>CRUD</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdint&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bsoncxx/json.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mongocxx/client.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mongocxx/stdx.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mongocxx/uri.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bsoncxx/builder/stream/helpers.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mongocxx/instance.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bsoncxx/builder/stream/document.hpp&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::stream::close_array;</span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::stream::close_document;</span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::stream::document;</span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::stream::finalize;</span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::stream::open_array;</span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::stream::open_document;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> builder = document&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbsoncxx::document::value doc_value = builder</span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"name\"</span> &lt;&lt; <span class=\"string\">\"Lsmg\"</span></span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"type\"</span> &lt;&lt; <span class=\"string\">\"Lemon\"</span></span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"count\"</span> &lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"versions\"</span> &lt;&lt; open_array</span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"v3.2\"</span> &lt;&lt; <span class=\"string\">\"v3.0\"</span> &lt;&lt; <span class=\"string\">\"v2.6\"</span></span><br><span class=\"line\">\t\t\t&lt;&lt; close_array</span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"info\"</span> &lt;&lt; open_document</span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"x\"</span> &lt;&lt; <span class=\"number\">203</span></span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"y\"</span> &lt;&lt; <span class=\"number\">102</span></span><br><span class=\"line\">\t\t\t&lt;&lt; close_document</span><br><span class=\"line\">\t\t\t&lt;&lt; finalize;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbsoncxx::document::view view_test = doc_value.view();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 打印插入内容制定key的value</span></span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name = view_test[<span class=\"string\">\"name\"</span>].get_utf8().value.to_string();</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 获取插入ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> result = coll_test.insert_one(view_test);</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> id1 = result-&gt;inserted_id().get_oid().value.to_string();</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; id1 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_many</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 插入多个</span></span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;bsoncxx::document::value&gt; documents;</span><br><span class=\"line\">\tdocuments.reserve(<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdocuments.push_back(document&#123;&#125; &lt;&lt; <span class=\"string\">\"i\"</span> &lt;&lt; i &lt;&lt; finalize);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> result = coll_test.insert_many(documents);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 获取多个的返回ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> id_maps = result-&gt;inserted_ids();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> iter : id_maps)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; iter.second.get_oid().value.to_string() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 查询</span></span><br><span class=\"line\">\tmongocxx::<span class=\"built_in\">cursor</span> <span class=\"built_in\">cursor</span> = coll_test.<span class=\"built_in\">find</span>(&#123;&#125;);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> doc : <span class=\"built_in\">cursor</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; bsoncxx::to_json(doc) &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update_one</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcoll_test.update_one(document&#123;&#125; &lt;&lt; <span class=\"string\">\"i\"</span> &lt;&lt; <span class=\"number\">9</span> &lt;&lt; finalize,</span><br><span class=\"line\">\t\t\tdocument&#123;&#125; &lt;&lt; <span class=\"string\">\"$set\"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"i\"</span> &lt;&lt; <span class=\"number\">110</span> &lt;&lt; close_document &lt;&lt; finalize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update_many</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcoll_test.update_many(document&#123;&#125; &lt;&lt; <span class=\"string\">\"i\"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class=\"line\">\t\t\t\t\t           <span class=\"string\">\"$lt\"</span> &lt;&lt; <span class=\"number\">8</span> &lt;&lt; close_document &lt;&lt; finalize,</span><br><span class=\"line\">\t\t\tdocument&#123;&#125; &lt;&lt; <span class=\"string\">\"$inc\"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class=\"line\">\t\t\t\t\t           <span class=\"string\">\"i\"</span> &lt;&lt; <span class=\"number\">100</span> &lt;&lt; close_document &lt;&lt; finalize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete_one</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcoll_test.delete_one(document&#123;&#125; &lt;&lt; <span class=\"string\">\"i\"</span> &lt;&lt; <span class=\"number\">110</span> &lt;&lt; finalize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete_many</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 删除存在 i： 0 的文档</span></span><br><span class=\"line\">\tcoll_test.delete_many(document&#123;&#125; &lt;&lt; <span class=\"string\">\"i\"</span> &lt;&lt; <span class=\"number\">0</span> &lt;&lt; finalize);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * (&gt;) 大于 - $gt</span></span><br><span class=\"line\"><span class=\"comment\">\t * (&lt;) 小于 - $lt</span></span><br><span class=\"line\"><span class=\"comment\">\t * (&gt;=) 大于等于 - $gte</span></span><br><span class=\"line\"><span class=\"comment\">\t * (&lt;= ) 小于等于 - $lte</span></span><br><span class=\"line\"><span class=\"comment\">\t * */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 删除 i大于3小于8的文档</span></span><br><span class=\"line\">\tcoll_test.delete_many(document&#123;&#125; &lt;&lt; <span class=\"string\">\"i\"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class=\"line\">\t                                 <span class=\"string\">\"$gt\"</span> &lt;&lt; <span class=\"number\">0</span> &lt;&lt;</span><br><span class=\"line\">\t                                 <span class=\"string\">\"$lt\"</span> &lt;&lt; <span class=\"number\">200</span> &lt;&lt;</span><br><span class=\"line\">\t                                 close_document &lt;&lt; finalize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">create_index</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 1 代表生序 -1代表降序</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> index_specification = document&#123;&#125; &lt;&lt; <span class=\"string\">\"i\"</span> &lt;&lt; <span class=\"number\">-1</span> &lt;&lt; finalize;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// move的本质就是帮助编译器选择重载函数, 告诉编译器\"请尽量把此参数当做右值来处理\"</span></span><br><span class=\"line\">\tcoll_test.create_index(<span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(index_specification));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tmongocxx::instance instance&#123;&#125;;</span><br><span class=\"line\">\tmongocxx::client client&#123;mongocxx::uri&#123;&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmongocxx::database db = client[<span class=\"string\">\"mydb\"</span>];</span><br><span class=\"line\">\tmongocxx::collection coll_test = db[<span class=\"string\">\"test\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\tcreate_index(coll_test);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">find</span>(coll_test);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程安全相关\"><a href=\"#线程安全相关\" class=\"headerlink\" title=\"线程安全相关\"></a>线程安全相关</h2><p>不能同时对一个client的多个线程同时操作.<br>同时只能有一个线程对一个client操作, 包括对<code>mongocxx::client</code>的<code>mongocxx::client_session</code>, <code>mongocxx::database, mongocxx::collection</code>, and <code>mongocxx::cursor</code>同样如此</p>\n<p>简单解决可以通过用同一个<code>mongocxx::uri</code>生成多个<code>mongocxx::client</code>来解决这个问题</p>\n<p>最好的解决方法用<code>mongocxx::uri</code>生成一个<code>mongocxx::pool</code> 通过<code>mongocxx::pool</code>的<code>acquire()</code>来获取操作的client<br>官方demo如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongocxx::instance instance&#123;&#125;;</span><br><span class=\"line\">mongocxx::pool pool&#123;mongocxx::uri&#123;&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> threadfunc = [](mongocxx::client&amp; client, <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> dbname) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> col = client[dbname][<span class=\"string\">\"col\"</span>].insert_one(&#123;&#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Great! Using the pool allows the clients to be synchronized while sharing only one</span></span><br><span class=\"line\"><span class=\"comment\">// background monitoring thread.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::thread <span class=\"title\">t1</span> <span class=\"params\">([&amp;]() &#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">auto</span> c = pool.acquire();</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  threadfunc(*c, <span class=\"string\">\"db1\"</span>);</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  threadfunc(*c, <span class=\"string\">\"db2\"</span>);</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">&#125;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::thread <span class=\"title\">t2</span> <span class=\"params\">([&amp;]() &#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">auto</span> c = pool.acquire();</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  threadfunc(*c, <span class=\"string\">\"db2\"</span>);</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  threadfunc(*c, <span class=\"string\">\"db1\"</span>);</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">&#125;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">t1.join();</span><br><span class=\"line\">t2.join();</span><br></pre></td></tr></table></figure>\n\n<p>关于fork的安全性<br><code>Neither a mongocxx::client or a mongocxx::pool can be safely copied when forking. Because of this, any client or pool must be created after forking, not before.</code></p>\n<p>官方建议使用<code>mongocxx::pool</code>而不是<code>mongocxx::client</code> 即使你的应用只有一个线程<br><code>mongocxx::client</code> 每60S会检查一次自己监控的cluster, 使用前者会有专门的线程来进行检查而且是10S一次</p>\n<p><code>mongocxx::pool</code>可以用于多线程中, 也能用来创建客户端. 然而每个<code>mongocxx::client</code>只能被一个线程使用<code>最大默认为100 最小默认为0</code></p>\n<h2 id=\"BSON\"><a href=\"#BSON\" class=\"headerlink\" title=\"BSON\"></a>BSON</h2><p><strong>Document Builders</strong><br>一共提供了三个接口来创建文档<br>官网上提到<code>这三个接口会得到同样的结果, 选择哪个完全是由于美学</code></p>\n<p><em>“One-off” builder functions</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::basic::kvp;</span><br><span class=\"line\"><span class=\"comment\">// &#123; \"hello\": \"world\" &#125;</span></span><br><span class=\"line\">bsoncxx::document::value document = bsoncxx::builder::basic::make_document(kvp(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>));</span><br></pre></td></tr></table></figure>\n\n<p><em>Basic builder</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::basic::kvp;</span><br><span class=\"line\"><span class=\"comment\">// &#123; \"hello\" : \"world\" &#125;</span></span><br><span class=\"line\">bsoncxx::builder::basic::document basic_builder&#123;&#125;;</span><br><span class=\"line\">basic_builder.append(kvp(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>));</span><br><span class=\"line\">bsoncxx::document::value document = basic_builder.extract();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// basic::document builds a BSON document.</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> doc = builder::basic::document&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 通过使用kvp(k, v) 来 append 键值对 to a document </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::basic::kvp;</span><br><span class=\"line\"></span><br><span class=\"line\">doc.append(k, v); <span class=\"comment\">// 插入一般的键值对</span></span><br><span class=\"line\"><span class=\"comment\">// 对于k一般为string</span></span><br><span class=\"line\"><span class=\"comment\">// 对于v则包含多种情况 可以使用 bsoncxx::types命名空间里的如下类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_eod</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_double</span>;</span> <span class=\"comment\">// types::b_double&#123;3.14159&#125;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_utf8</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_document</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_array</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_binary</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_undefined</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_oid</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_bool</span>;</span> <span class=\"comment\">// types::b_bool&#123;false&#125;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_date</span>;</span> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_null</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_regex</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_dbpointer</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_code</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_symbol</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_codewscope</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_int32</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_timestamp</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_int64</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_decimal128</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_minkey</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_maxkey</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入k v (v是数组)</span></span><br><span class=\"line\">arr.append(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">arr.append(<span class=\"literal\">false</span>, types::b_bool&#123;<span class=\"literal\">true</span>&#125;, types::b_double&#123;<span class=\"number\">1.234</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We can get a view of the resulting bson by calling view()</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> v = doc.view();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Use 'v' so we don't get compiler warnings.</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> v.empty() ? EXIT_FAILURE : EXIT_SUCCESS;</span><br></pre></td></tr></table></figure>\n\n<p><em>Stream builder</em><br>我现在最喜欢的方法, 不过官方不建议这样, 因为需要保持这个流不被重新初始化, 这样在跨行生成的时候有困难.<br>官方建议使用上面的两个方法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &#123; \"hello\" : \"world\" &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::stream;</span><br><span class=\"line\">bsoncxx::document::value document = stream::document&#123;&#125; &lt;&lt; <span class=\"string\">\"hello\"</span> &lt;&lt; <span class=\"string\">\"world\"</span> &lt;&lt; stream::finalize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此外还有</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> builder::stream::open_document; <span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> builder::stream::close_document;<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> builder::stream::open_array; <span class=\"comment\">// [</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> builder::stream::close_array;<span class=\"comment\">// ]</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Building arrays</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [ 1, 2, 3 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> elements = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> array_builder = bsoncxx::builder::basic::<span class=\"built_in\">array</span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; element : elements) &#123;</span><br><span class=\"line\">    array_builder.append(element);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过使用lambda来构建 k, v (v是数组)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &#123; \"foo\" : [ 1, 2, 3 ] &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::basic::kvp;</span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::basic::sub_array;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> elements = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> doc = bsoncxx::builder::basic::document&#123;&#125;;</span><br><span class=\"line\">doc.append(kvp(<span class=\"string\">\"foo\"</span>, [&amp;elements](sub_array child) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; element : elements) &#123;</span><br><span class=\"line\">        child.append(element);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<p>通过使用流来生成</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &#123; \"subdocs\" : [ &#123; \"key\" : 1 &#125;, &#123; \"key\" : 2 &#125;, &#123; \"key\" : 3 &#125; ], \"another_key\" : 42 &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> bsoncxx;</span><br><span class=\"line\"></span><br><span class=\"line\">builder::stream::document builder&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> in_array = builder &lt;&lt; <span class=\"string\">\"subdocs\"</span> &lt;&lt; builder::stream::open_array;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp;&amp; e : &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;) &#123;</span><br><span class=\"line\">    in_array = in_array &lt;&lt; builder::stream::open_document &lt;&lt; <span class=\"string\">\"key\"</span> &lt;&lt; e</span><br><span class=\"line\">                        &lt;&lt; builder::stream::close_document;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> after_array = in_array &lt;&lt; builder::stream::close_array;</span><br><span class=\"line\"></span><br><span class=\"line\">after_array &lt;&lt; <span class=\"string\">\"another_key\"</span> &lt;&lt; <span class=\"number\">42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">document::value doc = after_array &lt;&lt; builder::stream::finalize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; to_json(doc) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p><img src=\"https://docs.mongodb.com/images/mongodb-logo.png\" alt=\"\"></p>","more":"<h1 id=\"服务器相关\"><a href=\"#服务器相关\" class=\"headerlink\" title=\"服务器相关\"></a>服务器相关</h1><h2 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h2><p>在mongodb中基本的概念是文档、集合、数据库</p>\n<ul>\n<li>数据库<br>一个mongodb中可以建立多个数据库。</li>\n<li>集合<br>集合就是 MongoDB 文档组 集合处于数据库中 文档处于集合中</li>\n<li>文档<br>文档是一组键值(key-value)对(即 BSON)<br>文档对应数据记录的行</li>\n</ul>\n<h2 id=\"安装驱动到Centos\"><a href=\"#安装驱动到Centos\" class=\"headerlink\" title=\"安装驱动到Centos\"></a>安装驱动到Centos</h2><p><strong>升级cmake</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://cmake.org/files/v3.6/cmake-3.6.2.tar.gz    </span><br><span class=\"line\">tar xvf cmake-3.6.2.tar.gz &amp;&amp; cd cmake-3.6.2/</span><br><span class=\"line\">./bootstrap</span><br><span class=\"line\"></span><br><span class=\"line\">gmake</span><br><span class=\"line\">gmake install（需要在su命令下执行，或者直接使用root账户安装）</span><br><span class=\"line\">/usr/local/bin/cmake --version</span><br><span class=\"line\"></span><br><span class=\"line\">yum remove cmake -y</span><br><span class=\"line\">ln -s /usr/local/bin/cmake /usr/bin/</span><br><span class=\"line\">cmake --version</span><br></pre></td></tr></table></figure>\n<p><strong>安装</strong></p>\n<p><a href=\"https://mongoc.org/libmongoc/current/installing.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n<h2 id=\"安装驱动到Centos-1\"><a href=\"#安装驱动到Centos-1\" class=\"headerlink\" title=\"安装驱动到Centos\"></a>安装驱动到Centos</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install gcc-c++</span><br><span class=\"line\"></span><br><span class=\"line\">yum install clang</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装boost</span><br><span class=\"line\">yum -y install gcc-c++ python-devel bzip2-devel zlib-devel</span><br><span class=\"line\">tar zxvf 安装包</span><br><span class=\"line\">sudo .&#x2F;bootstrap.sh --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;boost</span><br><span class=\"line\">sudo .&#x2F;b2 install</span><br><span class=\"line\">进入 目录下的tools&#x2F;build</span><br><span class=\"line\">sudo .&#x2F;bootstrap.sh</span><br><span class=\"line\">sudo .&#x2F;b2 install --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;boost</span><br><span class=\"line\"></span><br><span class=\"line\">wget https:&#x2F;&#x2F;cmake.org&#x2F;files&#x2F;v3.5&#x2F;cmake-3.5.2.tar.gz</span><br><span class=\"line\">tar -zxvf cmake-3.5.2.tar.gz</span><br><span class=\"line\">cd cmake-3.5.2</span><br><span class=\"line\">.&#x2F;bootstrap</span><br><span class=\"line\">gmake</span><br><span class=\"line\">gmake install</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除原来cmake版本，建立软连接，测试</span><br><span class=\"line\">yum remove cmake -y</span><br><span class=\"line\">ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;cmake &#x2F;usr&#x2F;bin&#x2F;</span><br><span class=\"line\">cmake --version</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装pip</span><br><span class=\"line\">yum install python-pip</span><br><span class=\"line\">pip install --upgrade pip</span><br><span class=\"line\"></span><br><span class=\"line\"># 安装py3</span><br><span class=\"line\">https:&#x2F;&#x2F;segmentfault.com&#x2F;a&#x2F;1190000015628625</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"安装到Ubuntu-18-04\"><a href=\"#安装到Ubuntu-18-04\" class=\"headerlink\" title=\"安装到Ubuntu 18.04\"></a>安装到Ubuntu 18.04</h2><p><a href=\"https://docs.mongodb.com/manual/administration/install-on-linux/\" target=\"_blank\" rel=\"noopener\">整理自官方文档</a></p>\n<ul>\n<li>导入公共秘钥, 另你的系统”信任”下面的包<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget -qO - https://www.mongodb.org/static/pgp/server-4.2.asc | sudo apt-key add -</span><br></pre></td></tr></table></figure>\n这一步需要显示OK</li>\n<li>导入第三方MongoDB源<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/4.2 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.2.list</span><br></pre></td></tr></table></figure></li>\n<li>导入源之后更新<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br></pre></td></tr></table></figure></li>\n<li>安装MongoDB稳定版本包(我安装的时候稳定版本为4.2)<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install -y mongodb-org=4.2.0 mongodb-org-server=4.2.0 mongodb-org-shell=4.2.0 mongodb-org-mongos=4.2.0 mongodb-org-tools=4.2.0</span><br></pre></td></tr></table></figure></li>\n<li>禁用apt-get自动更新MongoDB<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"mongodb-org hold\" | sudo dpkg --set-selections</span><br><span class=\"line\">echo \"mongodb-org-server hold\" | sudo dpkg --set-selections</span><br><span class=\"line\">echo \"mongodb-org-shell hold\" | sudo dpkg --set-selections</span><br><span class=\"line\">echo \"mongodb-org-mongos hold\" | sudo dpkg --set-selections</span><br><span class=\"line\">echo \"mongodb-org-tools hold\" | sudo dpkg --set-selections</span><br></pre></td></tr></table></figure>\n<h2 id=\"基础shell操作\"><a href=\"#基础shell操作\" class=\"headerlink\" title=\"基础shell操作\"></a>基础shell操作</h2></li>\n</ul>\n<p><strong>启动 关闭 重启</strong><br><code>sudo service mongod start(stop\\restart)</code></p>\n<p><em>启动成功标志</em><br>日志文件<code>/var/log/mongodb/mongod.log</code>中显示<code>waiting for connections on port 27017</code></p>\n<p><strong>进入交互式命令行</strong><br><code>mongo</code></p>\n<p><strong>指定端口运行 默认27017</strong><br><code>mongo --port 28015</code></p>\n<p><strong>非安装机通过shell连接安装机</strong><br><a href=\"https://docs.mongodb.com/manual/mongo/#mongodb-instance-on-a-remote-host\" target=\"_blank\" rel=\"noopener\">直连</a><br><a href=\"https://docs.mongodb.com/manual/mongo/#mongodb-instance-with-authentication\" target=\"_blank\" rel=\"noopener\">带登录验证</a></p>\n<hr>\n<p><strong>显示你正在使用的数据库</strong><br><code>db</code><br><strong>切换数据库</strong><br><code>use &lt;database&gt;</code></p>\n<h3 id=\"CRUD\"><a href=\"#CRUD\" class=\"headerlink\" title=\"CRUD\"></a>CRUD</h3><p><strong>C</strong></p>\n<p><em>插入一个文档</em><br><code>db.collection.insertOne()</code><br>这里的collection代指的一个集合, 集合的名字可以自定义如果集合并不存在你的数据库中 则自动创建这个集合.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.inventory.insertOne(</span><br><span class=\"line\">   &#123; item: \"canvas\", qty: 100, tags: [\"cotton\"]&#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<hr>\n<p><em>插入多个文档</em><br><code>db.inventory.insertMany()</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.inventory.insertMany([</span><br><span class=\"line\">   &#123; item: \"journal\", qty: 25, tags: [\"blank\", \"red\"]&#125;,</span><br><span class=\"line\">   &#123; item: \"mat\", qty: 85, tags: [\"gray\"]&#125;,</span><br><span class=\"line\">   &#123; item: \"mousepad\", qty: 25, tags: [\"gel\", \"blue\"]&#125;</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n<hr>\n<p><em>插入任意项的文档</em><br><code>db.collection.insert()</code></p>\n<hr>\n<p><em>_id项</em><br>每一个文档都有自己独一的id 如果插入文档的时候没有指定则会生成随机的<code>_id</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; \"_id\" : ObjectId(\"5da325520e80dfd9258a29be\"), \"x\" : 1 &#125;</span><br></pre></td></tr></table></figure>\n<p>可以通过在插入的时候指定<code>&quot;_id&quot;: xxxx</code>来自定义id</p>\n<p><a href=\"https://docs.mongodb.com/manual/reference/insert-methods/#additional-methods-for-inserts\" target=\"_blank\" rel=\"noopener\">额外的方法</a></p>\n<p><strong>R</strong><br><code>db.collection.find({ item: &quot;canvas&quot; })</code><br><a href=\"https://docs.mongodb.com/manual/core/document/#document-query-filter\" target=\"_blank\" rel=\"noopener\">拦截器-</a>在collection中查找含有<code>item: &quot;canvas&quot;</code>的文档, 并打印<br>如果不含<code>{ item: &quot;canvas&quot; }</code>则代表打印所有的文档</p>\n<p><code>db.collection.find({status: {$in: [ &quot;A&quot;, &quot;D&quot; ]}})</code><br><code>status: {$in: [ &quot;A&quot;, &quot;D&quot; ]}</code>意为A, D不在此status中</p>\n<p><code>db.inventory.find( { status: &quot;A&quot;, qty: { $lt: 30 } } )</code><br><code>qty: { $lt: 30 }</code>意为此qty的值少于30</p>\n<p><code>db.inventory.find( { $or: [ { status: &quot;A&quot; }, { qty: { $lt: 30 } } ] } )</code><br><code>{$or: [{ status: &quot;A&quot; }, { qty: { $lt: 30 }}]}</code>符合二者之一</p>\n<p><a href=\"https://docs.mongodb.com/manual/tutorial/query-embedded-documents/\" target=\"_blank\" rel=\"noopener\">2019年10月13日21:58:24 - 开头</a></p>\n<h1 id=\"C-Driver\"><a href=\"#C-Driver\" class=\"headerlink\" title=\"C++ Driver\"></a>C++ Driver</h1><p><a href=\"https://mongocxx.org/mongocxx-v3/installation/\" target=\"_blank\" rel=\"noopener\">照着官方文档安装了下</a><br>期间遇到了两个坑一个是我没有安装Git导致提示无法克隆<br>还有就是最后阶段我没安装pkg-config 导致的无法找到头文件</p>\n<p>接下来看一些简单的教程</p>\n<h2 id=\"CRUD-1\"><a href=\"#CRUD-1\" class=\"headerlink\" title=\"CRUD\"></a>CRUD</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdint&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bsoncxx/json.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mongocxx/client.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mongocxx/stdx.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mongocxx/uri.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bsoncxx/builder/stream/helpers.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mongocxx/instance.hpp&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bsoncxx/builder/stream/document.hpp&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::stream::close_array;</span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::stream::close_document;</span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::stream::document;</span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::stream::finalize;</span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::stream::open_array;</span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::stream::open_document;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> builder = document&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbsoncxx::document::value doc_value = builder</span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"name\"</span> &lt;&lt; <span class=\"string\">\"Lsmg\"</span></span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"type\"</span> &lt;&lt; <span class=\"string\">\"Lemon\"</span></span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"count\"</span> &lt;&lt; <span class=\"number\">1</span></span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"versions\"</span> &lt;&lt; open_array</span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"v3.2\"</span> &lt;&lt; <span class=\"string\">\"v3.0\"</span> &lt;&lt; <span class=\"string\">\"v2.6\"</span></span><br><span class=\"line\">\t\t\t&lt;&lt; close_array</span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"info\"</span> &lt;&lt; open_document</span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"x\"</span> &lt;&lt; <span class=\"number\">203</span></span><br><span class=\"line\">\t\t\t&lt;&lt; <span class=\"string\">\"y\"</span> &lt;&lt; <span class=\"number\">102</span></span><br><span class=\"line\">\t\t\t&lt;&lt; close_document</span><br><span class=\"line\">\t\t\t&lt;&lt; finalize;</span><br><span class=\"line\"></span><br><span class=\"line\">\tbsoncxx::document::view view_test = doc_value.view();</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 打印插入内容制定key的value</span></span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> name = view_test[<span class=\"string\">\"name\"</span>].get_utf8().value.to_string();</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; name &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 获取插入ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> result = coll_test.insert_one(view_test);</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> id1 = result-&gt;inserted_id().get_oid().value.to_string();</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; id1 &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert_many</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 插入多个</span></span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;bsoncxx::document::value&gt; documents;</span><br><span class=\"line\">\tdocuments.reserve(<span class=\"number\">10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdocuments.push_back(document&#123;&#125; &lt;&lt; <span class=\"string\">\"i\"</span> &lt;&lt; i &lt;&lt; finalize);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> result = coll_test.insert_many(documents);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 获取多个的返回ID</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> id_maps = result-&gt;inserted_ids();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> iter : id_maps)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; iter.second.get_oid().value.to_string() &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">find</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 查询</span></span><br><span class=\"line\">\tmongocxx::<span class=\"built_in\">cursor</span> <span class=\"built_in\">cursor</span> = coll_test.<span class=\"built_in\">find</span>(&#123;&#125;);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> doc : <span class=\"built_in\">cursor</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; bsoncxx::to_json(doc) &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update_one</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcoll_test.update_one(document&#123;&#125; &lt;&lt; <span class=\"string\">\"i\"</span> &lt;&lt; <span class=\"number\">9</span> &lt;&lt; finalize,</span><br><span class=\"line\">\t\t\tdocument&#123;&#125; &lt;&lt; <span class=\"string\">\"$set\"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"i\"</span> &lt;&lt; <span class=\"number\">110</span> &lt;&lt; close_document &lt;&lt; finalize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">update_many</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcoll_test.update_many(document&#123;&#125; &lt;&lt; <span class=\"string\">\"i\"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class=\"line\">\t\t\t\t\t           <span class=\"string\">\"$lt\"</span> &lt;&lt; <span class=\"number\">8</span> &lt;&lt; close_document &lt;&lt; finalize,</span><br><span class=\"line\">\t\t\tdocument&#123;&#125; &lt;&lt; <span class=\"string\">\"$inc\"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class=\"line\">\t\t\t\t\t           <span class=\"string\">\"i\"</span> &lt;&lt; <span class=\"number\">100</span> &lt;&lt; close_document &lt;&lt; finalize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete_one</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tcoll_test.delete_one(document&#123;&#125; &lt;&lt; <span class=\"string\">\"i\"</span> &lt;&lt; <span class=\"number\">110</span> &lt;&lt; finalize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete_many</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 删除存在 i： 0 的文档</span></span><br><span class=\"line\">\tcoll_test.delete_many(document&#123;&#125; &lt;&lt; <span class=\"string\">\"i\"</span> &lt;&lt; <span class=\"number\">0</span> &lt;&lt; finalize);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t * (&gt;) 大于 - $gt</span></span><br><span class=\"line\"><span class=\"comment\">\t * (&lt;) 小于 - $lt</span></span><br><span class=\"line\"><span class=\"comment\">\t * (&gt;=) 大于等于 - $gte</span></span><br><span class=\"line\"><span class=\"comment\">\t * (&lt;= ) 小于等于 - $lte</span></span><br><span class=\"line\"><span class=\"comment\">\t * */</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 删除 i大于3小于8的文档</span></span><br><span class=\"line\">\tcoll_test.delete_many(document&#123;&#125; &lt;&lt; <span class=\"string\">\"i\"</span> &lt;&lt; open_document &lt;&lt;</span><br><span class=\"line\">\t                                 <span class=\"string\">\"$gt\"</span> &lt;&lt; <span class=\"number\">0</span> &lt;&lt;</span><br><span class=\"line\">\t                                 <span class=\"string\">\"$lt\"</span> &lt;&lt; <span class=\"number\">200</span> &lt;&lt;</span><br><span class=\"line\">\t                                 close_document &lt;&lt; finalize);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">create_index</span><span class=\"params\">(mongocxx::collection coll_test)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 1 代表生序 -1代表降序</span></span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> index_specification = document&#123;&#125; &lt;&lt; <span class=\"string\">\"i\"</span> &lt;&lt; <span class=\"number\">-1</span> &lt;&lt; finalize;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// move的本质就是帮助编译器选择重载函数, 告诉编译器\"请尽量把此参数当做右值来处理\"</span></span><br><span class=\"line\">\tcoll_test.create_index(<span class=\"built_in\">std</span>::<span class=\"built_in\">move</span>(index_specification));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tmongocxx::instance instance&#123;&#125;;</span><br><span class=\"line\">\tmongocxx::client client&#123;mongocxx::uri&#123;&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tmongocxx::database db = client[<span class=\"string\">\"mydb\"</span>];</span><br><span class=\"line\">\tmongocxx::collection coll_test = db[<span class=\"string\">\"test\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\tcreate_index(coll_test);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">find</span>(coll_test);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"线程安全相关\"><a href=\"#线程安全相关\" class=\"headerlink\" title=\"线程安全相关\"></a>线程安全相关</h2><p>不能同时对一个client的多个线程同时操作.<br>同时只能有一个线程对一个client操作, 包括对<code>mongocxx::client</code>的<code>mongocxx::client_session</code>, <code>mongocxx::database, mongocxx::collection</code>, and <code>mongocxx::cursor</code>同样如此</p>\n<p>简单解决可以通过用同一个<code>mongocxx::uri</code>生成多个<code>mongocxx::client</code>来解决这个问题</p>\n<p>最好的解决方法用<code>mongocxx::uri</code>生成一个<code>mongocxx::pool</code> 通过<code>mongocxx::pool</code>的<code>acquire()</code>来获取操作的client<br>官方demo如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongocxx::instance instance&#123;&#125;;</span><br><span class=\"line\">mongocxx::pool pool&#123;mongocxx::uri&#123;&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> threadfunc = [](mongocxx::client&amp; client, <span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> dbname) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> col = client[dbname][<span class=\"string\">\"col\"</span>].insert_one(&#123;&#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Great! Using the pool allows the clients to be synchronized while sharing only one</span></span><br><span class=\"line\"><span class=\"comment\">// background monitoring thread.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::thread <span class=\"title\">t1</span> <span class=\"params\">([&amp;]() &#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">auto</span> c = pool.acquire();</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  threadfunc(*c, <span class=\"string\">\"db1\"</span>);</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  threadfunc(*c, <span class=\"string\">\"db2\"</span>);</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">&#125;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">std</span>::thread <span class=\"title\">t2</span> <span class=\"params\">([&amp;]() &#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"keyword\">auto</span> c = pool.acquire();</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  threadfunc(*c, <span class=\"string\">\"db2\"</span>);</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  threadfunc(*c, <span class=\"string\">\"db1\"</span>);</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">&#125;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">t1.join();</span><br><span class=\"line\">t2.join();</span><br></pre></td></tr></table></figure>\n\n<p>关于fork的安全性<br><code>Neither a mongocxx::client or a mongocxx::pool can be safely copied when forking. Because of this, any client or pool must be created after forking, not before.</code></p>\n<p>官方建议使用<code>mongocxx::pool</code>而不是<code>mongocxx::client</code> 即使你的应用只有一个线程<br><code>mongocxx::client</code> 每60S会检查一次自己监控的cluster, 使用前者会有专门的线程来进行检查而且是10S一次</p>\n<p><code>mongocxx::pool</code>可以用于多线程中, 也能用来创建客户端. 然而每个<code>mongocxx::client</code>只能被一个线程使用<code>最大默认为100 最小默认为0</code></p>\n<h2 id=\"BSON\"><a href=\"#BSON\" class=\"headerlink\" title=\"BSON\"></a>BSON</h2><p><strong>Document Builders</strong><br>一共提供了三个接口来创建文档<br>官网上提到<code>这三个接口会得到同样的结果, 选择哪个完全是由于美学</code></p>\n<p><em>“One-off” builder functions</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::basic::kvp;</span><br><span class=\"line\"><span class=\"comment\">// &#123; \"hello\": \"world\" &#125;</span></span><br><span class=\"line\">bsoncxx::document::value document = bsoncxx::builder::basic::make_document(kvp(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>));</span><br></pre></td></tr></table></figure>\n\n<p><em>Basic builder</em></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::basic::kvp;</span><br><span class=\"line\"><span class=\"comment\">// &#123; \"hello\" : \"world\" &#125;</span></span><br><span class=\"line\">bsoncxx::builder::basic::document basic_builder&#123;&#125;;</span><br><span class=\"line\">basic_builder.append(kvp(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>));</span><br><span class=\"line\">bsoncxx::document::value document = basic_builder.extract();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// basic::document builds a BSON document.</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> doc = builder::basic::document&#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 通过使用kvp(k, v) 来 append 键值对 to a document </span></span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::basic::kvp;</span><br><span class=\"line\"></span><br><span class=\"line\">doc.append(k, v); <span class=\"comment\">// 插入一般的键值对</span></span><br><span class=\"line\"><span class=\"comment\">// 对于k一般为string</span></span><br><span class=\"line\"><span class=\"comment\">// 对于v则包含多种情况 可以使用 bsoncxx::types命名空间里的如下类型</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_eod</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_double</span>;</span> <span class=\"comment\">// types::b_double&#123;3.14159&#125;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_utf8</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_document</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_array</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_binary</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_undefined</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_oid</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_bool</span>;</span> <span class=\"comment\">// types::b_bool&#123;false&#125;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_date</span>;</span> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_null</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_regex</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_dbpointer</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_code</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_symbol</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_codewscope</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_int32</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_timestamp</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_int64</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_decimal128</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_minkey</span>;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">b_maxkey</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入k v (v是数组)</span></span><br><span class=\"line\">arr.append(<span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\">arr.append(<span class=\"literal\">false</span>, types::b_bool&#123;<span class=\"literal\">true</span>&#125;, types::b_double&#123;<span class=\"number\">1.234</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// We can get a view of the resulting bson by calling view()</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> v = doc.view();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Use 'v' so we don't get compiler warnings.</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> v.empty() ? EXIT_FAILURE : EXIT_SUCCESS;</span><br></pre></td></tr></table></figure>\n\n<p><em>Stream builder</em><br>我现在最喜欢的方法, 不过官方不建议这样, 因为需要保持这个流不被重新初始化, 这样在跨行生成的时候有困难.<br>官方建议使用上面的两个方法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &#123; \"hello\" : \"world\" &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::stream;</span><br><span class=\"line\">bsoncxx::document::value document = stream::document&#123;&#125; &lt;&lt; <span class=\"string\">\"hello\"</span> &lt;&lt; <span class=\"string\">\"world\"</span> &lt;&lt; stream::finalize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 此外还有</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> builder::stream::open_document; <span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> builder::stream::close_document;<span class=\"comment\">// &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> builder::stream::open_array; <span class=\"comment\">// [</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> builder::stream::close_array;<span class=\"comment\">// ]</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Building arrays</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [ 1, 2, 3 ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> elements = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> array_builder = bsoncxx::builder::basic::<span class=\"built_in\">array</span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; element : elements) &#123;</span><br><span class=\"line\">    array_builder.append(element);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过使用lambda来构建 k, v (v是数组)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &#123; \"foo\" : [ 1, 2, 3 ] &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::basic::kvp;</span><br><span class=\"line\"><span class=\"keyword\">using</span> bsoncxx::builder::basic::sub_array;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">auto</span> elements = &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> doc = bsoncxx::builder::basic::document&#123;&#125;;</span><br><span class=\"line\">doc.append(kvp(<span class=\"string\">\"foo\"</span>, [&amp;elements](sub_array child) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; element : elements) &#123;</span><br><span class=\"line\">        child.append(element);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<p>通过使用流来生成</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// &#123; \"subdocs\" : [ &#123; \"key\" : 1 &#125;, &#123; \"key\" : 2 &#125;, &#123; \"key\" : 3 &#125; ], \"another_key\" : 42 &#125;</span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> bsoncxx;</span><br><span class=\"line\"></span><br><span class=\"line\">builder::stream::document builder&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> in_array = builder &lt;&lt; <span class=\"string\">\"subdocs\"</span> &lt;&lt; builder::stream::open_array;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp;&amp; e : &#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>&#125;) &#123;</span><br><span class=\"line\">    in_array = in_array &lt;&lt; builder::stream::open_document &lt;&lt; <span class=\"string\">\"key\"</span> &lt;&lt; e</span><br><span class=\"line\">                        &lt;&lt; builder::stream::close_document;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> after_array = in_array &lt;&lt; builder::stream::close_array;</span><br><span class=\"line\"></span><br><span class=\"line\">after_array &lt;&lt; <span class=\"string\">\"another_key\"</span> &lt;&lt; <span class=\"number\">42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">document::value doc = after_array &lt;&lt; builder::stream::finalize;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; to_json(doc) &lt;&lt; <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br></pre></td></tr></table></figure>"},{"title":"数据结构指针简答应用","date":"2020-03-03T02:38:28.000Z","top":90,"_content":"为了压缩长度. 所有空行都删掉了\n# 哈希表\n\n## 哈希表建立快速索引, 一遍和两遍哈希的使用\nhttps://leetcode.com/problems/two-sum\n题目很简单\n```\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n```\n不是最差... 也差不多了 最简单粗暴的形式 O(n2) O(1)\n```c++\nvector<int> twoSum(vector<int>& nums, int target)\n{\n\tfor (int i = 0; i < nums.size(); ++i)\n\t{\n\t\t// 答案肯定是一个小数和一个大数 相加, 直接往后找 测试用例应该是排好序的\n\t\tfor (int j = i + 1; j < nums.size(); ++j)\n\t\t{\n\t\t\tif (nums[i] + nums[j] == target)\n\t\t\t{\n\t\t\t\treturn vector<int>{i, j};\n\t\t\t}\n\t\t}\n\t}\n\treturn vector<int>{0, 1};\n}\n```\n两遍哈希 由于需要更快的找到 vector中某个元素的下标, 非常适合哈希表来做\n先放入哈希表中, 再寻找自己所需要的值是否存在以及下标 O(n) O(n)\n```c++\nvector<int> twoSum(vector<int>& nums, int target)\n{\n\tunordered_map<int, int> the_map;\n\tfor (int i = 0; i < nums.size(); ++i)\n\t{\n\t\tthe_map.insert({nums[i], i});\n\t}\n\t\n\tfor (int i = 0; i < nums.size(); ++i)\n\t{\n\t\tauto search = the_map.find(target - nums[i]);\n\t\t// unordered_map<int, int>::iterator search = the_map.find(target - nums[i]);\n\t\t\n\t\tif (search != the_map.end())\n\t\t{\n\t\t\tif (search->second == i)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn vector<int>{i, search->second};\n\t\t}\n\t}\n\treturn vector<int>{0, 0};\n}\n```\n一遍哈希, 既然是要在表中查找到需要数 还需要判断是否同一个数\n干脆直接在插入前就进行查找\n```c++\nvector<int> twoSum(vector<int>& nums, int target)\n{\n\tunordered_map<int, int> the_map;\n\tfor (int i = 0; i < nums.size(); ++i)\n\t{\n\t\tauto search = the_map.find(target - nums[i]);\n\t\tif (search != the_map.end())\n\t\t{\n\t\t\treturn vector<int>{i, search->second};\n\t\t}\n\t\tthe_map.insert({nums[i], i});\n\t}\n\treturn vector<int>{0, 0};\n}\n```\n## flag的使用\n```\n给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n\n在构造过程中，请注意区分大小写。比如 \"Aa\" 不能当做一个回文字符串。\n\n注意:\n假设字符串的长度不会超过 1010。\n\n输入:\n\"abccccdd\"\n\n输出:\n7\n\n解释:\n我们可以构造的最长的回文串是\"dccaccd\", 它的长度是 7。\n```\n\n这个开始我这样写的, 因为需要\n在有奇数字母个数的时候 需要额外 结果+1\n没有奇数字母个数 结果不需要额外 +1\n```c++\nint longestPalindrome(string s)\n{\n\tint letter[68]{};\n\n\tfor (int i = 0; i < s.size(); ++i)\n\t{\n\t\tletter[s[i] - 65]++;\n\t}\n\tint sum = 0;\n\tint oddnum = 0;\n\tfor (int i = 0; i < 68; ++i)\n\t{\n\t\tint num = letter[i];\n\t\tsum += num;\n\t\tif (num %2 == 1)\n\t\t{\n\t\t\toddnum++;\n\t\t}\n\t}\n\tsum -= oddnum;\n\t// 通过额外的一个if判断 是否存在奇数\n\tif (oddnum > 0)\n\t{\n\t\tsum++;\n\t}\n\treturn sum;\n\n\n\tint sum = 0;\n\tint oddnum = 0;\n\t// 设置这个flag 代码少了一个if 实际用途有没有.... 感觉这个思想是可以的\n\tint flag = 0;\n\tfor (int i = 0; i < 68; ++i)\n\t{\n\t\tint num = letter[i];\n\t\tsum += num;\n\t\tif (num %2 == 1)\n\t\t{\n\t\t\toddnum++;\n\t\t\tflag = 1;\n\t\t}\n\t}\n\tsum -= oddnum;\n\treturn sum + flag;\n}\n```\n\n\n# 双指针操作\n\n## 双指针左右逼近-数学问题\nhttps://leetcode.com/problems/container-with-most-water/\n\n存水量 = a(宽) * b(长);\n\n从a最大的时候开始, 如果想要获得更大的存水量, 只能减少a, 增加b\n\n使用两个指针 一个指向最左边 一个指向最右边\n\n这就有了移动哪个指针的问题, 为了得到更长的b 只能移动指向较短b的指针\n\n```c++\nint maxArea(vector<int>& height)\n{\n    int max = 0;   \n    vector<int>::const_iterator left = height.begin();\n    vector<int>::const_iterator right = height.end() - 1;\n    while (left < right)\n    {\n        int temp = min(*left, *right) * (right - left);\n        if (temp > max)\n        {\n            max = temp;\n        }\n        // 移动较短边\n        if (*left <= *right)\n        {\n            left++;\n        }\n        else\n        {\n            right--;\n        }\n    }\n    return max;\n}\n```\n## 合并排序数组-双指针操作 拷贝到临时数组和直接写到原数组\nhttps://leetcode-cn.com/problems/sorted-merge-lcci/\n给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。\n初始化 A 和 B 的元素数量分别为 m 和 n。\n```c++\n输入:\nA = [1,2,3,0,0,0], m = 3\nB = [2,5,6],       n = 3\n\n输出: [1,2,2,3,5,6]\n```\n第一次太惨了, 看来我算法需要加倍的联系啊. 先不说考虑很久\n```c++\nvoid merge(vector<int>& A, int m, vector<int>& B, int n)\n{\n\tif (n == 0)\n\t{\n\t\treturn;\n\t}\n\tint temp = 0;\n\t// 这里的 m + n就有点问题, 后面会空转 改为m + temp合适\n\tfor (int i = 0; i < m + n; ++i)\n\t{\n\t\tif (A.at(i) < B.at(temp))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tA.insert(A.begin() + i, B.at(temp++));\n\t\tif (temp == n)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\n\tif (temp < n)\n\t{\n\t\tA.insert(A.begin() + m + temp, B.begin() + temp, B.end());\n\t}\n\tA.erase(A.begin() + n + m, A.end());\n}\n```\n使用插入再删除, 本身这个方法就不是很好. 后来看题解有双指针, 就去试了下. 这样需要额外的空间\n如果直接正序的修改A的值, 可能会导致A的值被覆盖掉.\n那么倒序呢? 倒序放上最大的值 就不会覆盖掉A中未读取的值了 继续修改\n```c++\nvoid merge(vector<int>& A, int m, vector<int>& B, int n)\n{\n\tint sorted[m + n];\n\tauto a = A.begin();\n\tauto b = B.begin();\n\tint index = 0;\n\twhile (index != m + n)\n\t{\n\t\tif (a - A.begin() == m)\n\t\t{\n\t\t\tsorted[index++] = *b++;\n\t\t}\n\t\telse if (b - B.begin() == n)\n\t\t{\n\t\t\tsorted[index++] = *a++;\n\t\t}\n\t\telse if (*a < *b)\n\t\t{\n\t\t\tsorted[index++] = *a++;\n\t\t}\n\t\telse if (*a == *b)\n\t\t{\n\t\t\tsorted[index++] = *a++;\n\t\t\tsorted[index++] = *b++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsorted[index++] = *b++;\n\t\t}\n\t}\n\tfor (int i = 0; i < m + n; ++i)\n\t{\n\t\tA[i] = sorted[i];\n\t}\n\t\n}\n```\n改正后的代码如下\n```c++\nvoid merge(vector<int>& A, int m, vector<int>& B, int n)\n{\n\tint index = m + n - 1;\n\tint a = m - 1;\n\tint b = n - 1;\n\twhile (index >= 0)\n\t{\n\t\tif (a == -1)\n\t\t{\n\t\t\tA[index--] = B[b--];\n\t\t}\n\t\telse if (b == -1)\n\t\t{\n\t\t\tA[index--] = A[a--];\n\t\t}\n\t\telse if (A[a] > B[b])\n\t\t{\n\t\t\tA[index--] = A[a--];\n\t\t}\n\t\telse if (A[a] == B[b])\n\t\t{\n\t\t\tA[index--] = A[a--];\n\t\t\tA[index--] = B[b--];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA[index--] = B[b--];\n\t\t}\n\t}\t\n}\n```\n\n## Plus One-临时插入 如果无效则删除\nhttps://leetcode.com/problems/plus-one/\n给定一个数组, [1, 2, 3]代表123 给这个数字+1 返回数组形式\n```c++\nInput: [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\n```\n\n```c++\nvector<int> plusOne(vector<int>& digits)\n{\n\t// insert zero in case of like this [9]\n\tdigits.insert(digits.begin(), 0);\n\t\t\n\tauto end = digits.end() - 1;\n\t\n\t*end += 1;\n\twhile(*end == 10)\n\t{\n\t\t*end = 0;\n\t\t*(--end) += 1;\n\t}\n\t\n\t// if the zero is useless delete it\n\tif (digits[0] == 0)\n\t{\n\t\tdigits.erase(digits.begin(), digits.begin() + 1);\n\t}\n\treturn digits;\n}\n```\n\n## 谨记无符号踩坑\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/\n\n这个的代码就不贴出来了, 我也没有偷懒 没有!!!\n\n这个主要是记录下 无符号值的使用\n\n充实了我的CPP踩坑记的文章\n\n# string\n## 反向迭代器\nGiven a string s consists of upper/lower-case alphabets and empty space characters ' ', \nreturn the length of last word (last word means the last appearing word if we loop from left to right) in the string.\nIf the last word does not exist, return 0.\n```c++\nInput: \"Hello World\"\nOutput: 5\n```\n...出了问题 这个题目刚才写的解析全没了...... 只能保存下改正完的答案了\n赶紧下载了一个vscode来用用\n```c++\nint lengthOfLastWord(string s)\n{\n\tint len = 0;\n\tint sub = s.length() - 1;\n\twhile((sub >= 0) && (s[sub] == ' '))\n\t{\n\t\tsub--;\n\t}\n\twhile (sub >= 0 && (s[sub] != ' '))\n\t{\n\t\tsub--;\n\t\tlen++;\n\t}\n\treturn len;\n}\n```\n\n迭代器的使用\n```c++\nint lengthOfLastWord(string s)\n{\n\tauto it = s.rbegin(), piv = s.rbegin();\n\tfor(;it != s.rend() && *it == ' '; it++, piv = it);\n\tfor(;it != s.rend() && *it != ' '; it++);\n\treturn it - piv;\n}\n```\n\n# 位运算\n\n## a^a^b = b\nGiven a non-empty array of integers, every element appears twice except for one. Find that single one.\n```c+\nInput: [2,2,1]\nOutput: 1\n\nInput: [4,1,2,1,2]\nOutput: 4\n```\n\n这个题目上来寻找单独的数字, 我直接就sort然后遍历一次, 找到单个的数字.\n我以为这样就很快了, 结果看了下排名. 啪啪啪的打脸\n```c++\nint singleNumber(vector<int>& nums)\n{\n\tif (nums.size() <= 2)\n\t{\n\t\treturn nums[0];\n\t}\n\tsort(nums.begin(), nums.end());\n\tfor (int i = 0; i < nums.size() - 2; i = i + 2)\n\t{\n\t\tif (nums[i] != nums[i + 1])\n\t\t{\n\t\t\treturn nums[i];\n\t\t}\n\t}\n\treturn nums[nums.size() - 1];\n}\n```\n\n既然打败了40%的人, 就去看看更快的解法把. 首先我看到了就是这个\n我只想说.... 位运算6666, 没想到异或可以这样用\n`a^0 = a`  `a^a = 0` `a^a^b = b` \n```c++\nint singleNumber(vector<int>& nums)\n{\n\tint ret = 0;\n\tfor (int n : nums)\n\t{\n\t\tret ^= n;\n\t}\n\treturn ret;\n}\n```\n\n还有哈希表做法, 应该是利用的哈希表快速索引, 我也是才知道map范围for循环是pair不是iter auto不能用太多\n```c++\nint singleNumber(vector<int>& nums)\n{\n\tunordered_map<int, int> map;\n\tfor (int n : nums)\n\t{\n\t\tmap[n]++;\n\t}\n\t\n\tfor (pair<int, int> n : map)\n\t{\n\t\tif (n.second == 1)\n\t\t{\n\t\t\treturn n.first;\n\t\t}\n\t}\n\treturn -1;\n}\n```\n\n# List\n## 链表环判断双指针赛跑 单一体现key-set\nhttps://leetcode.com/problems/linked-list-cycle/\nhttps://leetcode.com/problems/linked-list-cycle-ii/\n\n\n大意就是判断一个链表是否有环, 因为之前在那本小灰上看到过. 脑子中首先想的两个指针赛跑.\n\n快的指针一次走两步, 慢的一次走一步. 快的终将会追上慢的, 如果碰到了nullptr就返回false\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head)\n    {    \n        if (head == nullptr)\n        {\n            return false;\n        }\n        \n        ListNode *walk = head;\n        ListNode *run = head;\n        while (run->next != nullptr)\n        {\n            walk = walk->next;\n            if (run->next->next != nullptr)\n            {\n                run = run->next->next;\n            }\n            else\n            {\n                return false;\n            }\n            if (walk == run)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n修改了一下, 感觉下面的代码要好一些?\n\n```c++\nbool hasCycle(ListNode *head)\n{    \n\tif ((head == nullptr) || (head->next == nullptr))\n\t{\n\t\treturn false;\n\t}\n\t\n\tListNode *walk = head;\n\tListNode *run = head->next;\n\twhile (walk != run)\n\t{\n\t\tif ((run == nullptr) || (run->next == nullptr))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\twalk = walk->next;\n\t\trun = run->next->next;\n\t}\n\treturn true;\n}\n```\n\n既然是要保证访问过的单一, 就是用set了\n\n```c++\nbool hasCycle(ListNode *head)\n{ \n\tset<ListNode*> hashset{};\t\n\twhile (head != nullptr)\n\t{\n\t\tif (hashset.count(head) != 0)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\thashset.insert(head);\n\t\t\n\t\thead = head->next;\n\t}\n\treturn false;\n}\n```\n","source":"_posts/算法90-算法刷题记录-数据结构简单应用.md","raw":"---\ntitle: 数据结构指针简答应用\ndate: 2020-03-03 10:38:28\ntags:\ncategories:\n - 算法\n - 算法刷题记录\ntop: 90\n---\n为了压缩长度. 所有空行都删掉了\n# 哈希表\n\n## 哈希表建立快速索引, 一遍和两遍哈希的使用\nhttps://leetcode.com/problems/two-sum\n题目很简单\n```\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n```\n不是最差... 也差不多了 最简单粗暴的形式 O(n2) O(1)\n```c++\nvector<int> twoSum(vector<int>& nums, int target)\n{\n\tfor (int i = 0; i < nums.size(); ++i)\n\t{\n\t\t// 答案肯定是一个小数和一个大数 相加, 直接往后找 测试用例应该是排好序的\n\t\tfor (int j = i + 1; j < nums.size(); ++j)\n\t\t{\n\t\t\tif (nums[i] + nums[j] == target)\n\t\t\t{\n\t\t\t\treturn vector<int>{i, j};\n\t\t\t}\n\t\t}\n\t}\n\treturn vector<int>{0, 1};\n}\n```\n两遍哈希 由于需要更快的找到 vector中某个元素的下标, 非常适合哈希表来做\n先放入哈希表中, 再寻找自己所需要的值是否存在以及下标 O(n) O(n)\n```c++\nvector<int> twoSum(vector<int>& nums, int target)\n{\n\tunordered_map<int, int> the_map;\n\tfor (int i = 0; i < nums.size(); ++i)\n\t{\n\t\tthe_map.insert({nums[i], i});\n\t}\n\t\n\tfor (int i = 0; i < nums.size(); ++i)\n\t{\n\t\tauto search = the_map.find(target - nums[i]);\n\t\t// unordered_map<int, int>::iterator search = the_map.find(target - nums[i]);\n\t\t\n\t\tif (search != the_map.end())\n\t\t{\n\t\t\tif (search->second == i)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn vector<int>{i, search->second};\n\t\t}\n\t}\n\treturn vector<int>{0, 0};\n}\n```\n一遍哈希, 既然是要在表中查找到需要数 还需要判断是否同一个数\n干脆直接在插入前就进行查找\n```c++\nvector<int> twoSum(vector<int>& nums, int target)\n{\n\tunordered_map<int, int> the_map;\n\tfor (int i = 0; i < nums.size(); ++i)\n\t{\n\t\tauto search = the_map.find(target - nums[i]);\n\t\tif (search != the_map.end())\n\t\t{\n\t\t\treturn vector<int>{i, search->second};\n\t\t}\n\t\tthe_map.insert({nums[i], i});\n\t}\n\treturn vector<int>{0, 0};\n}\n```\n## flag的使用\n```\n给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。\n\n在构造过程中，请注意区分大小写。比如 \"Aa\" 不能当做一个回文字符串。\n\n注意:\n假设字符串的长度不会超过 1010。\n\n输入:\n\"abccccdd\"\n\n输出:\n7\n\n解释:\n我们可以构造的最长的回文串是\"dccaccd\", 它的长度是 7。\n```\n\n这个开始我这样写的, 因为需要\n在有奇数字母个数的时候 需要额外 结果+1\n没有奇数字母个数 结果不需要额外 +1\n```c++\nint longestPalindrome(string s)\n{\n\tint letter[68]{};\n\n\tfor (int i = 0; i < s.size(); ++i)\n\t{\n\t\tletter[s[i] - 65]++;\n\t}\n\tint sum = 0;\n\tint oddnum = 0;\n\tfor (int i = 0; i < 68; ++i)\n\t{\n\t\tint num = letter[i];\n\t\tsum += num;\n\t\tif (num %2 == 1)\n\t\t{\n\t\t\toddnum++;\n\t\t}\n\t}\n\tsum -= oddnum;\n\t// 通过额外的一个if判断 是否存在奇数\n\tif (oddnum > 0)\n\t{\n\t\tsum++;\n\t}\n\treturn sum;\n\n\n\tint sum = 0;\n\tint oddnum = 0;\n\t// 设置这个flag 代码少了一个if 实际用途有没有.... 感觉这个思想是可以的\n\tint flag = 0;\n\tfor (int i = 0; i < 68; ++i)\n\t{\n\t\tint num = letter[i];\n\t\tsum += num;\n\t\tif (num %2 == 1)\n\t\t{\n\t\t\toddnum++;\n\t\t\tflag = 1;\n\t\t}\n\t}\n\tsum -= oddnum;\n\treturn sum + flag;\n}\n```\n\n\n# 双指针操作\n\n## 双指针左右逼近-数学问题\nhttps://leetcode.com/problems/container-with-most-water/\n\n存水量 = a(宽) * b(长);\n\n从a最大的时候开始, 如果想要获得更大的存水量, 只能减少a, 增加b\n\n使用两个指针 一个指向最左边 一个指向最右边\n\n这就有了移动哪个指针的问题, 为了得到更长的b 只能移动指向较短b的指针\n\n```c++\nint maxArea(vector<int>& height)\n{\n    int max = 0;   \n    vector<int>::const_iterator left = height.begin();\n    vector<int>::const_iterator right = height.end() - 1;\n    while (left < right)\n    {\n        int temp = min(*left, *right) * (right - left);\n        if (temp > max)\n        {\n            max = temp;\n        }\n        // 移动较短边\n        if (*left <= *right)\n        {\n            left++;\n        }\n        else\n        {\n            right--;\n        }\n    }\n    return max;\n}\n```\n## 合并排序数组-双指针操作 拷贝到临时数组和直接写到原数组\nhttps://leetcode-cn.com/problems/sorted-merge-lcci/\n给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。\n初始化 A 和 B 的元素数量分别为 m 和 n。\n```c++\n输入:\nA = [1,2,3,0,0,0], m = 3\nB = [2,5,6],       n = 3\n\n输出: [1,2,2,3,5,6]\n```\n第一次太惨了, 看来我算法需要加倍的联系啊. 先不说考虑很久\n```c++\nvoid merge(vector<int>& A, int m, vector<int>& B, int n)\n{\n\tif (n == 0)\n\t{\n\t\treturn;\n\t}\n\tint temp = 0;\n\t// 这里的 m + n就有点问题, 后面会空转 改为m + temp合适\n\tfor (int i = 0; i < m + n; ++i)\n\t{\n\t\tif (A.at(i) < B.at(temp))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tA.insert(A.begin() + i, B.at(temp++));\n\t\tif (temp == n)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\n\tif (temp < n)\n\t{\n\t\tA.insert(A.begin() + m + temp, B.begin() + temp, B.end());\n\t}\n\tA.erase(A.begin() + n + m, A.end());\n}\n```\n使用插入再删除, 本身这个方法就不是很好. 后来看题解有双指针, 就去试了下. 这样需要额外的空间\n如果直接正序的修改A的值, 可能会导致A的值被覆盖掉.\n那么倒序呢? 倒序放上最大的值 就不会覆盖掉A中未读取的值了 继续修改\n```c++\nvoid merge(vector<int>& A, int m, vector<int>& B, int n)\n{\n\tint sorted[m + n];\n\tauto a = A.begin();\n\tauto b = B.begin();\n\tint index = 0;\n\twhile (index != m + n)\n\t{\n\t\tif (a - A.begin() == m)\n\t\t{\n\t\t\tsorted[index++] = *b++;\n\t\t}\n\t\telse if (b - B.begin() == n)\n\t\t{\n\t\t\tsorted[index++] = *a++;\n\t\t}\n\t\telse if (*a < *b)\n\t\t{\n\t\t\tsorted[index++] = *a++;\n\t\t}\n\t\telse if (*a == *b)\n\t\t{\n\t\t\tsorted[index++] = *a++;\n\t\t\tsorted[index++] = *b++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsorted[index++] = *b++;\n\t\t}\n\t}\n\tfor (int i = 0; i < m + n; ++i)\n\t{\n\t\tA[i] = sorted[i];\n\t}\n\t\n}\n```\n改正后的代码如下\n```c++\nvoid merge(vector<int>& A, int m, vector<int>& B, int n)\n{\n\tint index = m + n - 1;\n\tint a = m - 1;\n\tint b = n - 1;\n\twhile (index >= 0)\n\t{\n\t\tif (a == -1)\n\t\t{\n\t\t\tA[index--] = B[b--];\n\t\t}\n\t\telse if (b == -1)\n\t\t{\n\t\t\tA[index--] = A[a--];\n\t\t}\n\t\telse if (A[a] > B[b])\n\t\t{\n\t\t\tA[index--] = A[a--];\n\t\t}\n\t\telse if (A[a] == B[b])\n\t\t{\n\t\t\tA[index--] = A[a--];\n\t\t\tA[index--] = B[b--];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tA[index--] = B[b--];\n\t\t}\n\t}\t\n}\n```\n\n## Plus One-临时插入 如果无效则删除\nhttps://leetcode.com/problems/plus-one/\n给定一个数组, [1, 2, 3]代表123 给这个数字+1 返回数组形式\n```c++\nInput: [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\n```\n\n```c++\nvector<int> plusOne(vector<int>& digits)\n{\n\t// insert zero in case of like this [9]\n\tdigits.insert(digits.begin(), 0);\n\t\t\n\tauto end = digits.end() - 1;\n\t\n\t*end += 1;\n\twhile(*end == 10)\n\t{\n\t\t*end = 0;\n\t\t*(--end) += 1;\n\t}\n\t\n\t// if the zero is useless delete it\n\tif (digits[0] == 0)\n\t{\n\t\tdigits.erase(digits.begin(), digits.begin() + 1);\n\t}\n\treturn digits;\n}\n```\n\n## 谨记无符号踩坑\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock/\n\n这个的代码就不贴出来了, 我也没有偷懒 没有!!!\n\n这个主要是记录下 无符号值的使用\n\n充实了我的CPP踩坑记的文章\n\n# string\n## 反向迭代器\nGiven a string s consists of upper/lower-case alphabets and empty space characters ' ', \nreturn the length of last word (last word means the last appearing word if we loop from left to right) in the string.\nIf the last word does not exist, return 0.\n```c++\nInput: \"Hello World\"\nOutput: 5\n```\n...出了问题 这个题目刚才写的解析全没了...... 只能保存下改正完的答案了\n赶紧下载了一个vscode来用用\n```c++\nint lengthOfLastWord(string s)\n{\n\tint len = 0;\n\tint sub = s.length() - 1;\n\twhile((sub >= 0) && (s[sub] == ' '))\n\t{\n\t\tsub--;\n\t}\n\twhile (sub >= 0 && (s[sub] != ' '))\n\t{\n\t\tsub--;\n\t\tlen++;\n\t}\n\treturn len;\n}\n```\n\n迭代器的使用\n```c++\nint lengthOfLastWord(string s)\n{\n\tauto it = s.rbegin(), piv = s.rbegin();\n\tfor(;it != s.rend() && *it == ' '; it++, piv = it);\n\tfor(;it != s.rend() && *it != ' '; it++);\n\treturn it - piv;\n}\n```\n\n# 位运算\n\n## a^a^b = b\nGiven a non-empty array of integers, every element appears twice except for one. Find that single one.\n```c+\nInput: [2,2,1]\nOutput: 1\n\nInput: [4,1,2,1,2]\nOutput: 4\n```\n\n这个题目上来寻找单独的数字, 我直接就sort然后遍历一次, 找到单个的数字.\n我以为这样就很快了, 结果看了下排名. 啪啪啪的打脸\n```c++\nint singleNumber(vector<int>& nums)\n{\n\tif (nums.size() <= 2)\n\t{\n\t\treturn nums[0];\n\t}\n\tsort(nums.begin(), nums.end());\n\tfor (int i = 0; i < nums.size() - 2; i = i + 2)\n\t{\n\t\tif (nums[i] != nums[i + 1])\n\t\t{\n\t\t\treturn nums[i];\n\t\t}\n\t}\n\treturn nums[nums.size() - 1];\n}\n```\n\n既然打败了40%的人, 就去看看更快的解法把. 首先我看到了就是这个\n我只想说.... 位运算6666, 没想到异或可以这样用\n`a^0 = a`  `a^a = 0` `a^a^b = b` \n```c++\nint singleNumber(vector<int>& nums)\n{\n\tint ret = 0;\n\tfor (int n : nums)\n\t{\n\t\tret ^= n;\n\t}\n\treturn ret;\n}\n```\n\n还有哈希表做法, 应该是利用的哈希表快速索引, 我也是才知道map范围for循环是pair不是iter auto不能用太多\n```c++\nint singleNumber(vector<int>& nums)\n{\n\tunordered_map<int, int> map;\n\tfor (int n : nums)\n\t{\n\t\tmap[n]++;\n\t}\n\t\n\tfor (pair<int, int> n : map)\n\t{\n\t\tif (n.second == 1)\n\t\t{\n\t\t\treturn n.first;\n\t\t}\n\t}\n\treturn -1;\n}\n```\n\n# List\n## 链表环判断双指针赛跑 单一体现key-set\nhttps://leetcode.com/problems/linked-list-cycle/\nhttps://leetcode.com/problems/linked-list-cycle-ii/\n\n\n大意就是判断一个链表是否有环, 因为之前在那本小灰上看到过. 脑子中首先想的两个指针赛跑.\n\n快的指针一次走两步, 慢的一次走一步. 快的终将会追上慢的, 如果碰到了nullptr就返回false\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head)\n    {    \n        if (head == nullptr)\n        {\n            return false;\n        }\n        \n        ListNode *walk = head;\n        ListNode *run = head;\n        while (run->next != nullptr)\n        {\n            walk = walk->next;\n            if (run->next->next != nullptr)\n            {\n                run = run->next->next;\n            }\n            else\n            {\n                return false;\n            }\n            if (walk == run)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n修改了一下, 感觉下面的代码要好一些?\n\n```c++\nbool hasCycle(ListNode *head)\n{    \n\tif ((head == nullptr) || (head->next == nullptr))\n\t{\n\t\treturn false;\n\t}\n\t\n\tListNode *walk = head;\n\tListNode *run = head->next;\n\twhile (walk != run)\n\t{\n\t\tif ((run == nullptr) || (run->next == nullptr))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\twalk = walk->next;\n\t\trun = run->next->next;\n\t}\n\treturn true;\n}\n```\n\n既然是要保证访问过的单一, 就是用set了\n\n```c++\nbool hasCycle(ListNode *head)\n{ \n\tset<ListNode*> hashset{};\t\n\twhile (head != nullptr)\n\t{\n\t\tif (hashset.count(head) != 0)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\thashset.insert(head);\n\t\t\n\t\thead = head->next;\n\t}\n\treturn false;\n}\n```\n","slug":"算法90-算法刷题记录-数据结构简单应用","published":1,"updated":"2020-03-19T09:01:15.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvp002r8cuobwsb4tc3","content":"<p>为了压缩长度. 所有空行都删掉了</p>\n<h1 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h1><h2 id=\"哈希表建立快速索引-一遍和两遍哈希的使用\"><a href=\"#哈希表建立快速索引-一遍和两遍哈希的使用\" class=\"headerlink\" title=\"哈希表建立快速索引, 一遍和两遍哈希的使用\"></a>哈希表建立快速索引, 一遍和两遍哈希的使用</h2><p><a href=\"https://leetcode.com/problems/two-sum\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/two-sum</a><br>题目很简单</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class=\"line\"></span><br><span class=\"line\">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class=\"line\">return [0, 1].</span><br></pre></td></tr></table></figure>\n<p>不是最差… 也差不多了 最简单粗暴的形式 O(n2) O(1)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 答案肯定是一个小数和一个大数 相加, 直接往后找 测试用例应该是排好序的</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.<span class=\"built_in\">size</span>(); ++j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (nums[i] + nums[j] == target)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;i, j&#125;;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>两遍哈希 由于需要更快的找到 vector中某个元素的下标, 非常适合哈希表来做<br>先放入哈希表中, 再寻找自己所需要的值是否存在以及下标 O(n) O(n)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; the_map;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tthe_map.insert(&#123;nums[i], i&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> search = the_map.<span class=\"built_in\">find</span>(target - nums[i]);</span><br><span class=\"line\">\t\t<span class=\"comment\">// unordered_map&lt;int, int&gt;::iterator search = the_map.find(target - nums[i]);</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (search != the_map.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (search-&gt;second == i)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;i, search-&gt;second&#125;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一遍哈希, 既然是要在表中查找到需要数 还需要判断是否同一个数<br>干脆直接在插入前就进行查找</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; the_map;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> search = the_map.<span class=\"built_in\">find</span>(target - nums[i]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (search != the_map.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;i, search-&gt;second&#125;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tthe_map.insert(&#123;nums[i], i&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"flag的使用\"><a href=\"#flag的使用\" class=\"headerlink\" title=\"flag的使用\"></a>flag的使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</span><br><span class=\"line\"></span><br><span class=\"line\">在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。</span><br><span class=\"line\"></span><br><span class=\"line\">注意:</span><br><span class=\"line\">假设字符串的长度不会超过 1010。</span><br><span class=\"line\"></span><br><span class=\"line\">输入:</span><br><span class=\"line\">&quot;abccccdd&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">7</span><br><span class=\"line\"></span><br><span class=\"line\">解释:</span><br><span class=\"line\">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure>\n\n<p>这个开始我这样写的, 因为需要<br>在有奇数字母个数的时候 需要额外 结果+1<br>没有奇数字母个数 结果不需要额外 +1</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> letter[<span class=\"number\">68</span>]&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tletter[s[i] - <span class=\"number\">65</span>]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> oddnum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">68</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> num = letter[i];</span><br><span class=\"line\">\t\tsum += num;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num %<span class=\"number\">2</span> == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\toddnum++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsum -= oddnum;</span><br><span class=\"line\">\t<span class=\"comment\">// 通过额外的一个if判断 是否存在奇数</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (oddnum &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsum++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> oddnum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置这个flag 代码少了一个if 实际用途有没有.... 感觉这个思想是可以的</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">68</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> num = letter[i];</span><br><span class=\"line\">\t\tsum += num;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num %<span class=\"number\">2</span> == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\toddnum++;</span><br><span class=\"line\">\t\t\tflag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsum -= oddnum;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum + flag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"双指针操作\"><a href=\"#双指针操作\" class=\"headerlink\" title=\"双指针操作\"></a>双指针操作</h1><h2 id=\"双指针左右逼近-数学问题\"><a href=\"#双指针左右逼近-数学问题\" class=\"headerlink\" title=\"双指针左右逼近-数学问题\"></a>双指针左右逼近-数学问题</h2><p><a href=\"https://leetcode.com/problems/container-with-most-water/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/container-with-most-water/</a></p>\n<p>存水量 = a(宽) * b(长);</p>\n<p>从a最大的时候开始, 如果想要获得更大的存水量, 只能减少a, 增加b</p>\n<p>使用两个指针 一个指向最左边 一个指向最右边</p>\n<p>这就有了移动哪个指针的问题, 为了得到更长的b 只能移动指向较短b的指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; <span class=\"built_in\">height</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">max</span> = <span class=\"number\">0</span>;   </span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::const_iterator left = <span class=\"built_in\">height</span>.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::const_iterator right = <span class=\"built_in\">height</span>.<span class=\"built_in\">end</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = <span class=\"built_in\">min</span>(*left, *right) * (right - left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp &gt; <span class=\"built_in\">max</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">max</span> = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 移动较短边</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*left &lt;= *right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"合并排序数组-双指针操作-拷贝到临时数组和直接写到原数组\"><a href=\"#合并排序数组-双指针操作-拷贝到临时数组和直接写到原数组\" class=\"headerlink\" title=\"合并排序数组-双指针操作 拷贝到临时数组和直接写到原数组\"></a>合并排序数组-双指针操作 拷贝到临时数组和直接写到原数组</h2><p><a href=\"https://leetcode-cn.com/problems/sorted-merge-lcci/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/sorted-merge-lcci/</a><br>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。<br>初始化 A 和 B 的元素数量分别为 m 和 n。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">A = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>], m = <span class=\"number\">3</span></span><br><span class=\"line\">B = [<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>],       n = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">输出: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br></pre></td></tr></table></figure>\n<p>第一次太惨了, 看来我算法需要加倍的联系啊. 先不说考虑很久</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"keyword\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 这里的 m + n就有点问题, 后面会空转 改为m + temp合适</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m + n; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (A.at(i) &lt; B.at(temp))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tA.insert(A.<span class=\"built_in\">begin</span>() + i, B.at(temp++));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp == n)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (temp &lt; n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tA.insert(A.<span class=\"built_in\">begin</span>() + m + temp, B.<span class=\"built_in\">begin</span>() + temp, B.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tA.erase(A.<span class=\"built_in\">begin</span>() + n + m, A.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用插入再删除, 本身这个方法就不是很好. 后来看题解有双指针, 就去试了下. 这样需要额外的空间<br>如果直接正序的修改A的值, 可能会导致A的值被覆盖掉.<br>那么倒序呢? 倒序放上最大的值 就不会覆盖掉A中未读取的值了 继续修改</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"keyword\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sorted[m + n];</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> a = A.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> b = B.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (index != m + n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a - A.<span class=\"built_in\">begin</span>() == m)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tsorted[index++] = *b++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (b - B.<span class=\"built_in\">begin</span>() == n)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tsorted[index++] = *a++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (*a &lt; *b)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tsorted[index++] = *a++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (*a == *b)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tsorted[index++] = *a++;</span><br><span class=\"line\">\t\t\tsorted[index++] = *b++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tsorted[index++] = *b++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m + n; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tA[i] = sorted[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>改正后的代码如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"keyword\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = m + n - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (index &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tA[index--] = B[b--];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (b == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tA[index--] = A[a--];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (A[a] &gt; B[b])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tA[index--] = A[a--];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (A[a] == B[b])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tA[index--] = A[a--];</span><br><span class=\"line\">\t\t\tA[index--] = B[b--];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tA[index--] = B[b--];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Plus-One-临时插入-如果无效则删除\"><a href=\"#Plus-One-临时插入-如果无效则删除\" class=\"headerlink\" title=\"Plus One-临时插入 如果无效则删除\"></a>Plus One-临时插入 如果无效则删除</h2><p><a href=\"https://leetcode.com/problems/plus-one/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/plus-one/</a><br>给定一个数组, [1, 2, 3]代表123 给这个数字+1 返回数组形式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">Output: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">Explanation: The <span class=\"built_in\">array</span> represents the integer <span class=\"number\">123.</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">plusOne</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; digits)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// insert zero in case of like this [9]</span></span><br><span class=\"line\">\tdigits.insert(digits.<span class=\"built_in\">begin</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> <span class=\"built_in\">end</span> = digits.<span class=\"built_in\">end</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t*<span class=\"built_in\">end</span> += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(*<span class=\"built_in\">end</span> == <span class=\"number\">10</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t*<span class=\"built_in\">end</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t*(--<span class=\"built_in\">end</span>) += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// if the zero is useless delete it</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (digits[<span class=\"number\">0</span>] == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdigits.erase(digits.<span class=\"built_in\">begin</span>(), digits.<span class=\"built_in\">begin</span>() + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"谨记无符号踩坑\"><a href=\"#谨记无符号踩坑\" class=\"headerlink\" title=\"谨记无符号踩坑\"></a>谨记无符号踩坑</h2><p><a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p>\n<p>这个的代码就不贴出来了, 我也没有偷懒 没有!!!</p>\n<p>这个主要是记录下 无符号值的使用</p>\n<p>充实了我的CPP踩坑记的文章</p>\n<h1 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h1><h2 id=\"反向迭代器\"><a href=\"#反向迭代器\" class=\"headerlink\" title=\"反向迭代器\"></a>反向迭代器</h2><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘,<br>return the length of last word (last word means the last appearing word if we loop from left to right) in the string.<br>If the last word does not exist, return 0.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">Output: <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>…出了问题 这个题目刚才写的解析全没了…… 只能保存下改正完的答案了<br>赶紧下载了一个vscode来用用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sub = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>((sub &gt;= <span class=\"number\">0</span>) &amp;&amp; (s[sub] == <span class=\"string\">' '</span>))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsub--;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (sub &gt;= <span class=\"number\">0</span> &amp;&amp; (s[sub] != <span class=\"string\">' '</span>))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsub--;</span><br><span class=\"line\">\t\tlen++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>迭代器的使用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> it = s.rbegin(), piv = s.rbegin();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;it != s.rend() &amp;&amp; *it == <span class=\"string\">' '</span>; it++, piv = it);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;it != s.rend() &amp;&amp; *it != <span class=\"string\">' '</span>; it++);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> it - piv;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h1><h2 id=\"a-a-b-b\"><a href=\"#a-a-b-b\" class=\"headerlink\" title=\"a^a^b = b\"></a>a^a^b = b</h2><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [2,2,1]</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\"></span><br><span class=\"line\">Input: [4,1,2,1,2]</span><br><span class=\"line\">Output: 4</span><br></pre></td></tr></table></figure>\n\n<p>这个题目上来寻找单独的数字, 我直接就sort然后遍历一次, 找到单个的数字.<br>我以为这样就很快了, 结果看了下排名. 啪啪啪的打脸</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (nums.<span class=\"built_in\">size</span>() &lt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsort(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>() - <span class=\"number\">2</span>; i = i + <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nums[i] != nums[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nums[nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>既然打败了40%的人, 就去看看更快的解法把. 首先我看到了就是这个<br>我只想说…. 位运算6666, 没想到异或可以这样用<br><code>a^0 = a</code>  <code>a^a = 0</code> <code>a^a^b = b</code> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n : nums)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tret ^= n;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有哈希表做法, 应该是利用的哈希表快速索引, 我也是才知道map范围for循环是pair不是iter auto不能用太多</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; <span class=\"built_in\">map</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n : nums)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">map</span>[n]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; n : <span class=\"built_in\">map</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (n.second == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n.first;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h1><h2 id=\"链表环判断双指针赛跑-单一体现key-set\"><a href=\"#链表环判断双指针赛跑-单一体现key-set\" class=\"headerlink\" title=\"链表环判断双指针赛跑 单一体现key-set\"></a>链表环判断双指针赛跑 单一体现key-set</h2><p><a href=\"https://leetcode.com/problems/linked-list-cycle/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/linked-list-cycle/</a><br><a href=\"https://leetcode.com/problems/linked-list-cycle-ii/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/linked-list-cycle-ii/</a></p>\n<p>大意就是判断一个链表是否有环, 因为之前在那本小灰上看到过. 脑子中首先想的两个指针赛跑.</p>\n<p>快的指针一次走两步, 慢的一次走一步. 快的终将会追上慢的, 如果碰到了nullptr就返回false</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode *walk = head;</span><br><span class=\"line\">        ListNode *<span class=\"built_in\">run</span> = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">run</span>-&gt;next != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            walk = walk-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">run</span>-&gt;next-&gt;next != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">run</span> = <span class=\"built_in\">run</span>-&gt;next-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (walk == <span class=\"built_in\">run</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>修改了一下, 感觉下面的代码要好一些?</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;    </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((head == <span class=\"literal\">nullptr</span>) || (head-&gt;next == <span class=\"literal\">nullptr</span>))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tListNode *walk = head;</span><br><span class=\"line\">\tListNode *<span class=\"built_in\">run</span> = head-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (walk != <span class=\"built_in\">run</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((<span class=\"built_in\">run</span> == <span class=\"literal\">nullptr</span>) || (<span class=\"built_in\">run</span>-&gt;next == <span class=\"literal\">nullptr</span>))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\twalk = walk-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"built_in\">run</span> = <span class=\"built_in\">run</span>-&gt;next-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>既然是要保证访问过的单一, 就是用set了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">\t<span class=\"built_in\">set</span>&lt;ListNode*&gt; hashset&#123;&#125;;\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (head != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (hashset.count(head) != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\thashset.insert(head);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\thead = head-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>为了压缩长度. 所有空行都删掉了</p>\n<h1 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h1><h2 id=\"哈希表建立快速索引-一遍和两遍哈希的使用\"><a href=\"#哈希表建立快速索引-一遍和两遍哈希的使用\" class=\"headerlink\" title=\"哈希表建立快速索引, 一遍和两遍哈希的使用\"></a>哈希表建立快速索引, 一遍和两遍哈希的使用</h2><p><a href=\"https://leetcode.com/problems/two-sum\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/two-sum</a><br>题目很简单</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class=\"line\"></span><br><span class=\"line\">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class=\"line\">return [0, 1].</span><br></pre></td></tr></table></figure>\n<p>不是最差… 也差不多了 最简单粗暴的形式 O(n2) O(1)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 答案肯定是一个小数和一个大数 相加, 直接往后找 测试用例应该是排好序的</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.<span class=\"built_in\">size</span>(); ++j)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (nums[i] + nums[j] == target)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;i, j&#125;;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>两遍哈希 由于需要更快的找到 vector中某个元素的下标, 非常适合哈希表来做<br>先放入哈希表中, 再寻找自己所需要的值是否存在以及下标 O(n) O(n)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; the_map;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tthe_map.insert(&#123;nums[i], i&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> search = the_map.<span class=\"built_in\">find</span>(target - nums[i]);</span><br><span class=\"line\">\t\t<span class=\"comment\">// unordered_map&lt;int, int&gt;::iterator search = the_map.find(target - nums[i]);</span></span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (search != the_map.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (search-&gt;second == i)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;i, search-&gt;second&#125;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一遍哈希, 既然是要在表中查找到需要数 还需要判断是否同一个数<br>干脆直接在插入前就进行查找</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums, <span class=\"keyword\">int</span> target)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; the_map;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">auto</span> search = the_map.<span class=\"built_in\">find</span>(target - nums[i]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (search != the_map.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;i, search-&gt;second&#125;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tthe_map.insert(&#123;nums[i], i&#125;);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"flag的使用\"><a href=\"#flag的使用\" class=\"headerlink\" title=\"flag的使用\"></a>flag的使用</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</span><br><span class=\"line\"></span><br><span class=\"line\">在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。</span><br><span class=\"line\"></span><br><span class=\"line\">注意:</span><br><span class=\"line\">假设字符串的长度不会超过 1010。</span><br><span class=\"line\"></span><br><span class=\"line\">输入:</span><br><span class=\"line\">&quot;abccccdd&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">7</span><br><span class=\"line\"></span><br><span class=\"line\">解释:</span><br><span class=\"line\">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure>\n\n<p>这个开始我这样写的, 因为需要<br>在有奇数字母个数的时候 需要额外 结果+1<br>没有奇数字母个数 结果不需要额外 +1</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> letter[<span class=\"number\">68</span>]&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tletter[s[i] - <span class=\"number\">65</span>]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> oddnum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">68</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> num = letter[i];</span><br><span class=\"line\">\t\tsum += num;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num %<span class=\"number\">2</span> == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\toddnum++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsum -= oddnum;</span><br><span class=\"line\">\t<span class=\"comment\">// 通过额外的一个if判断 是否存在奇数</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (oddnum &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsum++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> oddnum = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 设置这个flag 代码少了一个if 实际用途有没有.... 感觉这个思想是可以的</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">68</span>; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> num = letter[i];</span><br><span class=\"line\">\t\tsum += num;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (num %<span class=\"number\">2</span> == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\toddnum++;</span><br><span class=\"line\">\t\t\tflag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsum -= oddnum;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum + flag;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"双指针操作\"><a href=\"#双指针操作\" class=\"headerlink\" title=\"双指针操作\"></a>双指针操作</h1><h2 id=\"双指针左右逼近-数学问题\"><a href=\"#双指针左右逼近-数学问题\" class=\"headerlink\" title=\"双指针左右逼近-数学问题\"></a>双指针左右逼近-数学问题</h2><p><a href=\"https://leetcode.com/problems/container-with-most-water/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/container-with-most-water/</a></p>\n<p>存水量 = a(宽) * b(长);</p>\n<p>从a最大的时候开始, 如果想要获得更大的存水量, 只能减少a, 增加b</p>\n<p>使用两个指针 一个指向最左边 一个指向最右边</p>\n<p>这就有了移动哪个指针的问题, 为了得到更长的b 只能移动指向较短b的指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">maxArea</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; <span class=\"built_in\">height</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">max</span> = <span class=\"number\">0</span>;   </span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::const_iterator left = <span class=\"built_in\">height</span>.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;::const_iterator right = <span class=\"built_in\">height</span>.<span class=\"built_in\">end</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (left &lt; right)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = <span class=\"built_in\">min</span>(*left, *right) * (right - left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (temp &gt; <span class=\"built_in\">max</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">max</span> = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 移动较短边</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*left &lt;= *right)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">max</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"合并排序数组-双指针操作-拷贝到临时数组和直接写到原数组\"><a href=\"#合并排序数组-双指针操作-拷贝到临时数组和直接写到原数组\" class=\"headerlink\" title=\"合并排序数组-双指针操作 拷贝到临时数组和直接写到原数组\"></a>合并排序数组-双指针操作 拷贝到临时数组和直接写到原数组</h2><p><a href=\"https://leetcode-cn.com/problems/sorted-merge-lcci/\" target=\"_blank\" rel=\"noopener\">https://leetcode-cn.com/problems/sorted-merge-lcci/</a><br>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。<br>初始化 A 和 B 的元素数量分别为 m 和 n。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">A = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>], m = <span class=\"number\">3</span></span><br><span class=\"line\">B = [<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>],       n = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">输出: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br></pre></td></tr></table></figure>\n<p>第一次太惨了, 看来我算法需要加倍的联系啊. 先不说考虑很久</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"keyword\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"comment\">// 这里的 m + n就有点问题, 后面会空转 改为m + temp合适</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m + n; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (A.at(i) &lt; B.at(temp))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tA.insert(A.<span class=\"built_in\">begin</span>() + i, B.at(temp++));</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (temp == n)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (temp &lt; n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tA.insert(A.<span class=\"built_in\">begin</span>() + m + temp, B.<span class=\"built_in\">begin</span>() + temp, B.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tA.erase(A.<span class=\"built_in\">begin</span>() + n + m, A.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用插入再删除, 本身这个方法就不是很好. 后来看题解有双指针, 就去试了下. 这样需要额外的空间<br>如果直接正序的修改A的值, 可能会导致A的值被覆盖掉.<br>那么倒序呢? 倒序放上最大的值 就不会覆盖掉A中未读取的值了 继续修改</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"keyword\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sorted[m + n];</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> a = A.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> b = B.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (index != m + n)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a - A.<span class=\"built_in\">begin</span>() == m)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tsorted[index++] = *b++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (b - B.<span class=\"built_in\">begin</span>() == n)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tsorted[index++] = *a++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (*a &lt; *b)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tsorted[index++] = *a++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (*a == *b)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tsorted[index++] = *a++;</span><br><span class=\"line\">\t\t\tsorted[index++] = *b++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tsorted[index++] = *b++;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m + n; ++i)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tA[i] = sorted[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>改正后的代码如下</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; A, <span class=\"keyword\">int</span> m, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; B, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> index = m + n - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = m - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (index &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (a == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tA[index--] = B[b--];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (b == <span class=\"number\">-1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tA[index--] = A[a--];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (A[a] &gt; B[b])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tA[index--] = A[a--];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (A[a] == B[b])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tA[index--] = A[a--];</span><br><span class=\"line\">\t\t\tA[index--] = B[b--];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tA[index--] = B[b--];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Plus-One-临时插入-如果无效则删除\"><a href=\"#Plus-One-临时插入-如果无效则删除\" class=\"headerlink\" title=\"Plus One-临时插入 如果无效则删除\"></a>Plus One-临时插入 如果无效则删除</h2><p><a href=\"https://leetcode.com/problems/plus-one/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/plus-one/</a><br>给定一个数组, [1, 2, 3]代表123 给这个数字+1 返回数组形式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">Output: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">Explanation: The <span class=\"built_in\">array</span> represents the integer <span class=\"number\">123.</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">plusOne</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; digits)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// insert zero in case of like this [9]</span></span><br><span class=\"line\">\tdigits.insert(digits.<span class=\"built_in\">begin</span>(), <span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> <span class=\"built_in\">end</span> = digits.<span class=\"built_in\">end</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t*<span class=\"built_in\">end</span> += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(*<span class=\"built_in\">end</span> == <span class=\"number\">10</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t*<span class=\"built_in\">end</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t*(--<span class=\"built_in\">end</span>) += <span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// if the zero is useless delete it</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (digits[<span class=\"number\">0</span>] == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tdigits.erase(digits.<span class=\"built_in\">begin</span>(), digits.<span class=\"built_in\">begin</span>() + <span class=\"number\">1</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"谨记无符号踩坑\"><a href=\"#谨记无符号踩坑\" class=\"headerlink\" title=\"谨记无符号踩坑\"></a>谨记无符号踩坑</h2><p><a href=\"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/best-time-to-buy-and-sell-stock/</a></p>\n<p>这个的代码就不贴出来了, 我也没有偷懒 没有!!!</p>\n<p>这个主要是记录下 无符号值的使用</p>\n<p>充实了我的CPP踩坑记的文章</p>\n<h1 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h1><h2 id=\"反向迭代器\"><a href=\"#反向迭代器\" class=\"headerlink\" title=\"反向迭代器\"></a>反向迭代器</h2><p>Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘,<br>return the length of last word (last word means the last appearing word if we loop from left to right) in the string.<br>If the last word does not exist, return 0.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: <span class=\"string\">\"Hello World\"</span></span><br><span class=\"line\">Output: <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>…出了问题 这个题目刚才写的解析全没了…… 只能保存下改正完的答案了<br>赶紧下载了一个vscode来用用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> sub = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>((sub &gt;= <span class=\"number\">0</span>) &amp;&amp; (s[sub] == <span class=\"string\">' '</span>))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsub--;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (sub &gt;= <span class=\"number\">0</span> &amp;&amp; (s[sub] != <span class=\"string\">' '</span>))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tsub--;</span><br><span class=\"line\">\t\tlen++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>迭代器的使用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lengthOfLastWord</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> it = s.rbegin(), piv = s.rbegin();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;it != s.rend() &amp;&amp; *it == <span class=\"string\">' '</span>; it++, piv = it);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;it != s.rend() &amp;&amp; *it != <span class=\"string\">' '</span>; it++);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> it - piv;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h1><h2 id=\"a-a-b-b\"><a href=\"#a-a-b-b\" class=\"headerlink\" title=\"a^a^b = b\"></a>a^a^b = b</h2><p>Given a non-empty array of integers, every element appears twice except for one. Find that single one.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input: [2,2,1]</span><br><span class=\"line\">Output: 1</span><br><span class=\"line\"></span><br><span class=\"line\">Input: [4,1,2,1,2]</span><br><span class=\"line\">Output: 4</span><br></pre></td></tr></table></figure>\n\n<p>这个题目上来寻找单独的数字, 我直接就sort然后遍历一次, 找到单个的数字.<br>我以为这样就很快了, 结果看了下排名. 啪啪啪的打脸</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (nums.<span class=\"built_in\">size</span>() &lt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsort(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>() - <span class=\"number\">2</span>; i = i + <span class=\"number\">2</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (nums[i] != nums[i + <span class=\"number\">1</span>])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> nums[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> nums[nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>既然打败了40%的人, 就去看看更快的解法把. 首先我看到了就是这个<br>我只想说…. 位运算6666, 没想到异或可以这样用<br><code>a^0 = a</code>  <code>a^a = 0</code> <code>a^a^b = b</code> </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n : nums)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tret ^= n;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有哈希表做法, 应该是利用的哈希表快速索引, 我也是才知道map范围for循环是pair不是iter auto不能用太多</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">unordered_map</span>&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; <span class=\"built_in\">map</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> n : nums)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">map</span>[n]++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (pair&lt;<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>&gt; n : <span class=\"built_in\">map</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (n.second == <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> n.first;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h1><h2 id=\"链表环判断双指针赛跑-单一体现key-set\"><a href=\"#链表环判断双指针赛跑-单一体现key-set\" class=\"headerlink\" title=\"链表环判断双指针赛跑 单一体现key-set\"></a>链表环判断双指针赛跑 单一体现key-set</h2><p><a href=\"https://leetcode.com/problems/linked-list-cycle/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/linked-list-cycle/</a><br><a href=\"https://leetcode.com/problems/linked-list-cycle-ii/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/linked-list-cycle-ii/</a></p>\n<p>大意就是判断一个链表是否有环, 因为之前在那本小灰上看到过. 脑子中首先想的两个指针赛跑.</p>\n<p>快的指针一次走两步, 慢的一次走一步. 快的终将会追上慢的, 如果碰到了nullptr就返回false</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode *next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;    </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        ListNode *walk = head;</span><br><span class=\"line\">        ListNode *<span class=\"built_in\">run</span> = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"built_in\">run</span>-&gt;next != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            walk = walk-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">run</span>-&gt;next-&gt;next != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">run</span> = <span class=\"built_in\">run</span>-&gt;next-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (walk == <span class=\"built_in\">run</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>修改了一下, 感觉下面的代码要好一些?</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;    </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((head == <span class=\"literal\">nullptr</span>) || (head-&gt;next == <span class=\"literal\">nullptr</span>))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tListNode *walk = head;</span><br><span class=\"line\">\tListNode *<span class=\"built_in\">run</span> = head-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (walk != <span class=\"built_in\">run</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> ((<span class=\"built_in\">run</span> == <span class=\"literal\">nullptr</span>) || (<span class=\"built_in\">run</span>-&gt;next == <span class=\"literal\">nullptr</span>))</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\twalk = walk-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"built_in\">run</span> = <span class=\"built_in\">run</span>-&gt;next-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>既然是要保证访问过的单一, 就是用set了</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode *head)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; </span><br><span class=\"line\">\t<span class=\"built_in\">set</span>&lt;ListNode*&gt; hashset&#123;&#125;;\t</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (head != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (hashset.count(head) != <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\thashset.insert(head);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\thead = head-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"球球","date":"2020-03-05T13:50:02.000Z","_content":"\n[休闲: 球球](https://gameinstitute.qq.com/course/detail/10110)\n\nP2P 模式........ 好吧没有采用基本模式\n采用了变种, 从客户端中选取主客户端 局域网游戏会采用\n\n\n**状态同步**\nMMO用的多, 断线重连简单 直接返回状态\n\n收到命令集 计算后 返回结果 防作弊 服务器压力大 包量大\n\n预表现emm\n\n\n**帧同步**\n服务器广播客户端发送的指令集, 断线重连需要补上丢失的帧\n\n预表现emm\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E8%AF%BE%E5%A0%82/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AF%B9%E6%AF%94.png)\n\n航标\n终于知道游戏瞬移是怎么回事了\n\n影子追随\n\n心跳包矫正时间 获取延迟等等\n\n\n王者 帧同步.\n\n守望先锋 16ms一个包\n\nRTT网络延迟\n\n预表现","source":"_posts/游戏知识-腾讯游戏学院-球球.md","raw":"---\ntitle: 球球\ntags:\n  - 腾讯游戏学院\ncategories:\n  - 游戏知识\n  - 服务器\ndate: 2020-03-05 21:50:02\n---\n\n[休闲: 球球](https://gameinstitute.qq.com/course/detail/10110)\n\nP2P 模式........ 好吧没有采用基本模式\n采用了变种, 从客户端中选取主客户端 局域网游戏会采用\n\n\n**状态同步**\nMMO用的多, 断线重连简单 直接返回状态\n\n收到命令集 计算后 返回结果 防作弊 服务器压力大 包量大\n\n预表现emm\n\n\n**帧同步**\n服务器广播客户端发送的指令集, 断线重连需要补上丢失的帧\n\n预表现emm\n\n![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E8%AF%BE%E5%A0%82/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AF%B9%E6%AF%94.png)\n\n航标\n终于知道游戏瞬移是怎么回事了\n\n影子追随\n\n心跳包矫正时间 获取延迟等等\n\n\n王者 帧同步.\n\n守望先锋 16ms一个包\n\nRTT网络延迟\n\n预表现","slug":"游戏知识-腾讯游戏学院-球球","published":1,"updated":"2020-03-05T14:42:14.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvt002v8cuo3e4i4jbz","content":"<p><a href=\"https://gameinstitute.qq.com/course/detail/10110\" target=\"_blank\" rel=\"noopener\">休闲: 球球</a></p>\n<p>P2P 模式…….. 好吧没有采用基本模式<br>采用了变种, 从客户端中选取主客户端 局域网游戏会采用</p>\n<p><strong>状态同步</strong><br>MMO用的多, 断线重连简单 直接返回状态</p>\n<p>收到命令集 计算后 返回结果 防作弊 服务器压力大 包量大</p>\n<p>预表现emm</p>\n<p><strong>帧同步</strong><br>服务器广播客户端发送的指令集, 断线重连需要补上丢失的帧</p>\n<p>预表现emm</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E8%AF%BE%E5%A0%82/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AF%B9%E6%AF%94.png\" alt=\"\"></p>\n<p>航标<br>终于知道游戏瞬移是怎么回事了</p>\n<p>影子追随</p>\n<p>心跳包矫正时间 获取延迟等等</p>\n<p>王者 帧同步.</p>\n<p>守望先锋 16ms一个包</p>\n<p>RTT网络延迟</p>\n<p>预表现</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://gameinstitute.qq.com/course/detail/10110\" target=\"_blank\" rel=\"noopener\">休闲: 球球</a></p>\n<p>P2P 模式…….. 好吧没有采用基本模式<br>采用了变种, 从客户端中选取主客户端 局域网游戏会采用</p>\n<p><strong>状态同步</strong><br>MMO用的多, 断线重连简单 直接返回状态</p>\n<p>收到命令集 计算后 返回结果 防作弊 服务器压力大 包量大</p>\n<p>预表现emm</p>\n<p><strong>帧同步</strong><br>服务器广播客户端发送的指令集, 断线重连需要补上丢失的帧</p>\n<p>预表现emm</p>\n<p><img src=\"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E8%85%BE%E8%AE%AF%E6%B8%B8%E6%88%8F%E8%AF%BE%E5%A0%82/%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AF%B9%E6%AF%94.png\" alt=\"\"></p>\n<p>航标<br>终于知道游戏瞬移是怎么回事了</p>\n<p>影子追随</p>\n<p>心跳包矫正时间 获取延迟等等</p>\n<p>王者 帧同步.</p>\n<p>守望先锋 16ms一个包</p>\n<p>RTT网络延迟</p>\n<p>预表现</p>\n"},{"title":"算法","date":"2020-03-03T02:38:28.000Z","top":91,"_content":"# 动态规划\n## 贪心 动态规划\nhttps://leetcode.com/problems/jump-game/\n\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you are able to reach the last index.\n```c++\nExample 1:\nInput: [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\nInput: [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum\n             jump length is 0, which makes it impossible to reach the last index.\n```\n这是我LeetCode第一道中等难度算法, 刚上来不知道怎么做. 然后瞟了一眼题解说是动态规划问题.我就去查了下动态规划的问题解法\n\n[什么是动态规划（Dynamic Programming）？动态规划的意义是什么？ - 阮行止的回答 - 知乎](https://www.zhihu.com/question/23995189/answer/613096905)\n\n**贪心**\n这样算是有了个初步了解, 不过我上来先用了贪心... 因为简单一些, 动态规划暂时没有想到怎么解.\n结果运行时间超过 11%的人好吧 最坏的时间复杂度应该是O(n!)... 最优O(n)\n```c++\nbool canJump(vector<int>& nums)\n{\n    int sum_step = nums.size();\n    int now_sub = sum_step - 1;\n    int min_sub = now_sub;\n    \n    bool jumpout = true;\n    \n    while (true)\n    {\n        for (int i = now_sub - 1; i >= 0; --i)\n        {\n            if (nums[i] >= (now_sub - i))\n            {\n                min_sub = i;\n                jumpout = false;\n            }\n        }\n        now_sub = min_sub;\n        if (jumpout)\n        {\n            return now_sub == 0;\n        }\n        jumpout = true;\n    }\n}\n```\n我看了下题解的贪婪算法... 我的应该也是贪婪的一种. 不过题解的贪婪更加快.\n我的想法是从顶开始 每次遍历找到`最低的能跳过来的一层` 然后再从`最低的能跳过来的一层`遍历.直到到不能再跳就返回当前是不是底层\n\n题解的解法粗略看就是差在了第一个if的判断条件, 我判断的当前的层, 题解判断的`最低的能跳过来的一层`题解的解法是`能跳则跳` 我的解法是`跳最少的次数` 实际上针对此题`能跳则跳`就好\n```c++\nbool canJump(vector<int>& nums)\n{\n    int now_sub = nums.size() - 1;\n    int min_sub = now_sub;\n    for (int i = now_sub - 1; i >= 0; --i)\n    {\n        if (nums[i] + i >= min_sub)\n        {\n            min_sub = i;    \n        }\n    }  \n    return min_sub == 0;\n}\n```\n然后我猜测绝对有一道题输出最少的跳跃次数, 没想到真有. 结果试了下时间超限.....\n理论上我第一种解法能够完成emmm, 不过先不管那道题目了.\n\n**递归回溯**\n```c++\nbool canJumpFromPosition(int position, vector<int> &nums)\n{\n    if (position == nums.size() - 1)\n    {\n        return true;\n    }\n    \n    int max_position = min(position + nums[position], (int)nums.size() - 1);\n    // for (int i = max_position; i > position; --i)\n    for (int i = position + 1; i <= max_position; ++i)\n    {\n        if (canJumpFromPosition(i, nums))\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nbool canJump(vector<int>& nums)\n{\n    return canJumpFromPosition(0, nums);\n}\n```\n上面这种方法思考起来简单些, 你只要知道递归的条件是什么\n\n递归到什么时候返回值来回溯\n\n这个题目, 你只要在当前位置不断跳到所有能去的位置, 然后递归下去. 直到你的位置到了尾部就返回true, 或者你不能再跳返回false. 自然时间超限了\n\n上面的解法, 还有优化的空间. 因为这个是从左到右依次进行, 然而实际上从越远的地方进行更容易到达尾部. 所以可以修改for的判断条件在图中注释部分\n\n**动态规划 自上而下**\n```c++\nenum Index {UNKNOW, GOOD, BAD};\nIndex *memo;\n\nbool canJumpFromPosition(int position, vector<int> &nums)\n{\n    if (memo[position] != UNKNOW)\n    {\n        return memo[position] == GOOD;\n    }\n    \n    int max_position = min(position + nums[position], (int)nums.size() - 1);\n    for (int i = max_position; i > position; --i)\n    {\n        if (canJumpFromPosition(i, nums))\n        {\n            memo[position] = GOOD;\n            return true;\n        }\n    }\n    \n    memo[position] = BAD;\n    return false;\n}\n\nbool canJump(vector<int>& nums)\n{\n    memo = new Index[nums.size()]{};\n    memo[nums.size() - 1] = GOOD;\n    return canJumpFromPosition(0, nums);\n}\n```\n之前的方法中, 仔细想想就会发现 会有很多的下标被多次调用, 尽管那个下标是无法到达结尾的. 怎么解决呢? 当然是保存状态了, 每次递归结束后就标记当前的下标能不能到达. 之后遇到被标记的下标就能直接返回\n\n然而现在的时间复杂度依然高达 O(n^2)\n\n**自下而上的动态规划**\n\n通过消除递归的方式, 消除递归的一个好方法就是颠倒顺序. 上面那是从左到右向右跳, 这次我们从右向左向右跳, 就能更容易的知道知道某个下标是`GOOD`还是`BAD`了, 因为离最右端更近了.\n\n时间复杂度依然是O(n^2)\n```c++\nenum Index {UNKNOW, GOOD, BAD};\nIndex *memo;\n\nbool canJump(vector<int>& nums)\n{\n    memo = new Index[nums.size()]{};\n    memo[nums.size() - 1] = GOOD;\n    \n    for (int i = nums.size() - 2; i >= 0; --i)\n    {\n        int furthest_jump = min(nums[i] + i, (int)nums.size() - 1);\n        for (int j = i + 1; j <= furthest_jump; ++j)\n        {\n            if (memo[j] == GOOD)\n            {\n                memo[i] = GOOD;\n                break;\n            }\n        }\n    }\n    return memo[0] == GOOD;\n}\n```","source":"_posts/算法91-算法刷题记录-算法.md","raw":"---\ntitle: 算法\ndate: 2020-03-03 10:38:28\ntags:\ncategories:\n - 算法\n - 算法刷题记录\ntop: 91\n---\n# 动态规划\n## 贪心 动态规划\nhttps://leetcode.com/problems/jump-game/\n\nGiven an array of non-negative integers, you are initially positioned at the first index of the array.\nEach element in the array represents your maximum jump length at that position.\nDetermine if you are able to reach the last index.\n```c++\nExample 1:\nInput: [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\nExample 2:\nInput: [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum\n             jump length is 0, which makes it impossible to reach the last index.\n```\n这是我LeetCode第一道中等难度算法, 刚上来不知道怎么做. 然后瞟了一眼题解说是动态规划问题.我就去查了下动态规划的问题解法\n\n[什么是动态规划（Dynamic Programming）？动态规划的意义是什么？ - 阮行止的回答 - 知乎](https://www.zhihu.com/question/23995189/answer/613096905)\n\n**贪心**\n这样算是有了个初步了解, 不过我上来先用了贪心... 因为简单一些, 动态规划暂时没有想到怎么解.\n结果运行时间超过 11%的人好吧 最坏的时间复杂度应该是O(n!)... 最优O(n)\n```c++\nbool canJump(vector<int>& nums)\n{\n    int sum_step = nums.size();\n    int now_sub = sum_step - 1;\n    int min_sub = now_sub;\n    \n    bool jumpout = true;\n    \n    while (true)\n    {\n        for (int i = now_sub - 1; i >= 0; --i)\n        {\n            if (nums[i] >= (now_sub - i))\n            {\n                min_sub = i;\n                jumpout = false;\n            }\n        }\n        now_sub = min_sub;\n        if (jumpout)\n        {\n            return now_sub == 0;\n        }\n        jumpout = true;\n    }\n}\n```\n我看了下题解的贪婪算法... 我的应该也是贪婪的一种. 不过题解的贪婪更加快.\n我的想法是从顶开始 每次遍历找到`最低的能跳过来的一层` 然后再从`最低的能跳过来的一层`遍历.直到到不能再跳就返回当前是不是底层\n\n题解的解法粗略看就是差在了第一个if的判断条件, 我判断的当前的层, 题解判断的`最低的能跳过来的一层`题解的解法是`能跳则跳` 我的解法是`跳最少的次数` 实际上针对此题`能跳则跳`就好\n```c++\nbool canJump(vector<int>& nums)\n{\n    int now_sub = nums.size() - 1;\n    int min_sub = now_sub;\n    for (int i = now_sub - 1; i >= 0; --i)\n    {\n        if (nums[i] + i >= min_sub)\n        {\n            min_sub = i;    \n        }\n    }  \n    return min_sub == 0;\n}\n```\n然后我猜测绝对有一道题输出最少的跳跃次数, 没想到真有. 结果试了下时间超限.....\n理论上我第一种解法能够完成emmm, 不过先不管那道题目了.\n\n**递归回溯**\n```c++\nbool canJumpFromPosition(int position, vector<int> &nums)\n{\n    if (position == nums.size() - 1)\n    {\n        return true;\n    }\n    \n    int max_position = min(position + nums[position], (int)nums.size() - 1);\n    // for (int i = max_position; i > position; --i)\n    for (int i = position + 1; i <= max_position; ++i)\n    {\n        if (canJumpFromPosition(i, nums))\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nbool canJump(vector<int>& nums)\n{\n    return canJumpFromPosition(0, nums);\n}\n```\n上面这种方法思考起来简单些, 你只要知道递归的条件是什么\n\n递归到什么时候返回值来回溯\n\n这个题目, 你只要在当前位置不断跳到所有能去的位置, 然后递归下去. 直到你的位置到了尾部就返回true, 或者你不能再跳返回false. 自然时间超限了\n\n上面的解法, 还有优化的空间. 因为这个是从左到右依次进行, 然而实际上从越远的地方进行更容易到达尾部. 所以可以修改for的判断条件在图中注释部分\n\n**动态规划 自上而下**\n```c++\nenum Index {UNKNOW, GOOD, BAD};\nIndex *memo;\n\nbool canJumpFromPosition(int position, vector<int> &nums)\n{\n    if (memo[position] != UNKNOW)\n    {\n        return memo[position] == GOOD;\n    }\n    \n    int max_position = min(position + nums[position], (int)nums.size() - 1);\n    for (int i = max_position; i > position; --i)\n    {\n        if (canJumpFromPosition(i, nums))\n        {\n            memo[position] = GOOD;\n            return true;\n        }\n    }\n    \n    memo[position] = BAD;\n    return false;\n}\n\nbool canJump(vector<int>& nums)\n{\n    memo = new Index[nums.size()]{};\n    memo[nums.size() - 1] = GOOD;\n    return canJumpFromPosition(0, nums);\n}\n```\n之前的方法中, 仔细想想就会发现 会有很多的下标被多次调用, 尽管那个下标是无法到达结尾的. 怎么解决呢? 当然是保存状态了, 每次递归结束后就标记当前的下标能不能到达. 之后遇到被标记的下标就能直接返回\n\n然而现在的时间复杂度依然高达 O(n^2)\n\n**自下而上的动态规划**\n\n通过消除递归的方式, 消除递归的一个好方法就是颠倒顺序. 上面那是从左到右向右跳, 这次我们从右向左向右跳, 就能更容易的知道知道某个下标是`GOOD`还是`BAD`了, 因为离最右端更近了.\n\n时间复杂度依然是O(n^2)\n```c++\nenum Index {UNKNOW, GOOD, BAD};\nIndex *memo;\n\nbool canJump(vector<int>& nums)\n{\n    memo = new Index[nums.size()]{};\n    memo[nums.size() - 1] = GOOD;\n    \n    for (int i = nums.size() - 2; i >= 0; --i)\n    {\n        int furthest_jump = min(nums[i] + i, (int)nums.size() - 1);\n        for (int j = i + 1; j <= furthest_jump; ++j)\n        {\n            if (memo[j] == GOOD)\n            {\n                memo[i] = GOOD;\n                break;\n            }\n        }\n    }\n    return memo[0] == GOOD;\n}\n```","slug":"算法91-算法刷题记录-算法","published":1,"updated":"2020-03-19T08:44:16.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvu002y8cuo5fk45uia","content":"<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"贪心-动态规划\"><a href=\"#贪心-动态规划\" class=\"headerlink\" title=\"贪心 动态规划\"></a>贪心 动态规划</h2><p><a href=\"https://leetcode.com/problems/jump-game/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/jump-game/</a></p>\n<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.<br>Each element in the array represents your maximum jump length at that position.<br>Determine if you are able to reach the last index.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example <span class=\"number\">1</span>:</span><br><span class=\"line\">Input: [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">Output: <span class=\"literal\">true</span></span><br><span class=\"line\">Explanation: Jump <span class=\"number\">1</span> <span class=\"built_in\">step</span> from index <span class=\"number\">0</span> to <span class=\"number\">1</span>, then <span class=\"number\">3</span> steps to the last index.</span><br><span class=\"line\"></span><br><span class=\"line\">Example <span class=\"number\">2</span>:</span><br><span class=\"line\">Input: [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">Output: <span class=\"literal\">false</span></span><br><span class=\"line\">Explanation: You will always arrive at index <span class=\"number\">3</span> no matter what. Its maximum</span><br><span class=\"line\">             jump length is <span class=\"number\">0</span>, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure>\n<p>这是我LeetCode第一道中等难度算法, 刚上来不知道怎么做. 然后瞟了一眼题解说是动态规划问题.我就去查了下动态规划的问题解法</p>\n<p><a href=\"https://www.zhihu.com/question/23995189/answer/613096905\" target=\"_blank\" rel=\"noopener\">什么是动态规划（Dynamic Programming）？动态规划的意义是什么？ - 阮行止的回答 - 知乎</a></p>\n<p><strong>贪心</strong><br>这样算是有了个初步了解, 不过我上来先用了贪心… 因为简单一些, 动态规划暂时没有想到怎么解.<br>结果运行时间超过 11%的人好吧 最坏的时间复杂度应该是O(n!)… 最优O(n)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum_step = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> now_sub = sum_step - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min_sub = now_sub;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> jumpout = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = now_sub - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &gt;= (now_sub - i))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                min_sub = i;</span><br><span class=\"line\">                jumpout = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        now_sub = min_sub;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jumpout)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> now_sub == <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        jumpout = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我看了下题解的贪婪算法… 我的应该也是贪婪的一种. 不过题解的贪婪更加快.<br>我的想法是从顶开始 每次遍历找到<code>最低的能跳过来的一层</code> 然后再从<code>最低的能跳过来的一层</code>遍历.直到到不能再跳就返回当前是不是底层</p>\n<p>题解的解法粗略看就是差在了第一个if的判断条件, 我判断的当前的层, 题解判断的<code>最低的能跳过来的一层</code>题解的解法是<code>能跳则跳</code> 我的解法是<code>跳最少的次数</code> 实际上针对此题<code>能跳则跳</code>就好</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> now_sub = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min_sub = now_sub;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = now_sub - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] + i &gt;= min_sub)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            min_sub = i;    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> min_sub == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我猜测绝对有一道题输出最少的跳跃次数, 没想到真有. 结果试了下时间超限…..<br>理论上我第一种解法能够完成emmm, 不过先不管那道题目了.</p>\n<p><strong>递归回溯</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJumpFromPosition</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">position</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">position</span> == nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_position = <span class=\"built_in\">min</span>(<span class=\"built_in\">position</span> + nums[<span class=\"built_in\">position</span>], (<span class=\"keyword\">int</span>)nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// for (int i = max_position; i &gt; position; --i)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"built_in\">position</span> + <span class=\"number\">1</span>; i &lt;= max_position; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canJumpFromPosition(i, nums))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> canJumpFromPosition(<span class=\"number\">0</span>, nums);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这种方法思考起来简单些, 你只要知道递归的条件是什么</p>\n<p>递归到什么时候返回值来回溯</p>\n<p>这个题目, 你只要在当前位置不断跳到所有能去的位置, 然后递归下去. 直到你的位置到了尾部就返回true, 或者你不能再跳返回false. 自然时间超限了</p>\n<p>上面的解法, 还有优化的空间. 因为这个是从左到右依次进行, 然而实际上从越远的地方进行更容易到达尾部. 所以可以修改for的判断条件在图中注释部分</p>\n<p><strong>动态规划 自上而下</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Index &#123;UNKNOW, GOOD, BAD&#125;;</span><br><span class=\"line\">Index *memo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJumpFromPosition</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">position</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memo[<span class=\"built_in\">position</span>] != UNKNOW)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo[<span class=\"built_in\">position</span>] == GOOD;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_position = <span class=\"built_in\">min</span>(<span class=\"built_in\">position</span> + nums[<span class=\"built_in\">position</span>], (<span class=\"keyword\">int</span>)nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = max_position; i &gt; <span class=\"built_in\">position</span>; --i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canJumpFromPosition(i, nums))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            memo[<span class=\"built_in\">position</span>] = GOOD;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    memo[<span class=\"built_in\">position</span>] = BAD;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    memo = <span class=\"keyword\">new</span> Index[nums.<span class=\"built_in\">size</span>()]&#123;&#125;;</span><br><span class=\"line\">    memo[nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>] = GOOD;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> canJumpFromPosition(<span class=\"number\">0</span>, nums);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之前的方法中, 仔细想想就会发现 会有很多的下标被多次调用, 尽管那个下标是无法到达结尾的. 怎么解决呢? 当然是保存状态了, 每次递归结束后就标记当前的下标能不能到达. 之后遇到被标记的下标就能直接返回</p>\n<p>然而现在的时间复杂度依然高达 O(n^2)</p>\n<p><strong>自下而上的动态规划</strong></p>\n<p>通过消除递归的方式, 消除递归的一个好方法就是颠倒顺序. 上面那是从左到右向右跳, 这次我们从右向左向右跳, 就能更容易的知道知道某个下标是<code>GOOD</code>还是<code>BAD</code>了, 因为离最右端更近了.</p>\n<p>时间复杂度依然是O(n^2)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Index &#123;UNKNOW, GOOD, BAD&#125;;</span><br><span class=\"line\">Index *memo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    memo = <span class=\"keyword\">new</span> Index[nums.<span class=\"built_in\">size</span>()]&#123;&#125;;</span><br><span class=\"line\">    memo[nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>] = GOOD;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> furthest_jump = <span class=\"built_in\">min</span>(nums[i] + i, (<span class=\"keyword\">int</span>)nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt;= furthest_jump; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (memo[j] == GOOD)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                memo[i] = GOOD;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memo[<span class=\"number\">0</span>] == GOOD;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h2 id=\"贪心-动态规划\"><a href=\"#贪心-动态规划\" class=\"headerlink\" title=\"贪心 动态规划\"></a>贪心 动态规划</h2><p><a href=\"https://leetcode.com/problems/jump-game/\" target=\"_blank\" rel=\"noopener\">https://leetcode.com/problems/jump-game/</a></p>\n<p>Given an array of non-negative integers, you are initially positioned at the first index of the array.<br>Each element in the array represents your maximum jump length at that position.<br>Determine if you are able to reach the last index.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example <span class=\"number\">1</span>:</span><br><span class=\"line\">Input: [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">Output: <span class=\"literal\">true</span></span><br><span class=\"line\">Explanation: Jump <span class=\"number\">1</span> <span class=\"built_in\">step</span> from index <span class=\"number\">0</span> to <span class=\"number\">1</span>, then <span class=\"number\">3</span> steps to the last index.</span><br><span class=\"line\"></span><br><span class=\"line\">Example <span class=\"number\">2</span>:</span><br><span class=\"line\">Input: [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">Output: <span class=\"literal\">false</span></span><br><span class=\"line\">Explanation: You will always arrive at index <span class=\"number\">3</span> no matter what. Its maximum</span><br><span class=\"line\">             jump length is <span class=\"number\">0</span>, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure>\n<p>这是我LeetCode第一道中等难度算法, 刚上来不知道怎么做. 然后瞟了一眼题解说是动态规划问题.我就去查了下动态规划的问题解法</p>\n<p><a href=\"https://www.zhihu.com/question/23995189/answer/613096905\" target=\"_blank\" rel=\"noopener\">什么是动态规划（Dynamic Programming）？动态规划的意义是什么？ - 阮行止的回答 - 知乎</a></p>\n<p><strong>贪心</strong><br>这样算是有了个初步了解, 不过我上来先用了贪心… 因为简单一些, 动态规划暂时没有想到怎么解.<br>结果运行时间超过 11%的人好吧 最坏的时间复杂度应该是O(n!)… 最优O(n)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum_step = nums.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> now_sub = sum_step - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min_sub = now_sub;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">bool</span> jumpout = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = now_sub - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &gt;= (now_sub - i))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                min_sub = i;</span><br><span class=\"line\">                jumpout = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        now_sub = min_sub;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jumpout)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> now_sub == <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        jumpout = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我看了下题解的贪婪算法… 我的应该也是贪婪的一种. 不过题解的贪婪更加快.<br>我的想法是从顶开始 每次遍历找到<code>最低的能跳过来的一层</code> 然后再从<code>最低的能跳过来的一层</code>遍历.直到到不能再跳就返回当前是不是底层</p>\n<p>题解的解法粗略看就是差在了第一个if的判断条件, 我判断的当前的层, 题解判断的<code>最低的能跳过来的一层</code>题解的解法是<code>能跳则跳</code> 我的解法是<code>跳最少的次数</code> 实际上针对此题<code>能跳则跳</code>就好</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> now_sub = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min_sub = now_sub;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = now_sub - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[i] + i &gt;= min_sub)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            min_sub = i;    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> min_sub == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后我猜测绝对有一道题输出最少的跳跃次数, 没想到真有. 结果试了下时间超限…..<br>理论上我第一种解法能够完成emmm, 不过先不管那道题目了.</p>\n<p><strong>递归回溯</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJumpFromPosition</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">position</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">position</span> == nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_position = <span class=\"built_in\">min</span>(<span class=\"built_in\">position</span> + nums[<span class=\"built_in\">position</span>], (<span class=\"keyword\">int</span>)nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"comment\">// for (int i = max_position; i &gt; position; --i)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"built_in\">position</span> + <span class=\"number\">1</span>; i &lt;= max_position; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canJumpFromPosition(i, nums))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> canJumpFromPosition(<span class=\"number\">0</span>, nums);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这种方法思考起来简单些, 你只要知道递归的条件是什么</p>\n<p>递归到什么时候返回值来回溯</p>\n<p>这个题目, 你只要在当前位置不断跳到所有能去的位置, 然后递归下去. 直到你的位置到了尾部就返回true, 或者你不能再跳返回false. 自然时间超限了</p>\n<p>上面的解法, 还有优化的空间. 因为这个是从左到右依次进行, 然而实际上从越远的地方进行更容易到达尾部. 所以可以修改for的判断条件在图中注释部分</p>\n<p><strong>动态规划 自上而下</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Index &#123;UNKNOW, GOOD, BAD&#125;;</span><br><span class=\"line\">Index *memo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJumpFromPosition</span><span class=\"params\">(<span class=\"keyword\">int</span> <span class=\"built_in\">position</span>, <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; &amp;nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memo[<span class=\"built_in\">position</span>] != UNKNOW)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> memo[<span class=\"built_in\">position</span>] == GOOD;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span> max_position = <span class=\"built_in\">min</span>(<span class=\"built_in\">position</span> + nums[<span class=\"built_in\">position</span>], (<span class=\"keyword\">int</span>)nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = max_position; i &gt; <span class=\"built_in\">position</span>; --i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (canJumpFromPosition(i, nums))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            memo[<span class=\"built_in\">position</span>] = GOOD;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    memo[<span class=\"built_in\">position</span>] = BAD;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    memo = <span class=\"keyword\">new</span> Index[nums.<span class=\"built_in\">size</span>()]&#123;&#125;;</span><br><span class=\"line\">    memo[nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>] = GOOD;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> canJumpFromPosition(<span class=\"number\">0</span>, nums);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之前的方法中, 仔细想想就会发现 会有很多的下标被多次调用, 尽管那个下标是无法到达结尾的. 怎么解决呢? 当然是保存状态了, 每次递归结束后就标记当前的下标能不能到达. 之后遇到被标记的下标就能直接返回</p>\n<p>然而现在的时间复杂度依然高达 O(n^2)</p>\n<p><strong>自下而上的动态规划</strong></p>\n<p>通过消除递归的方式, 消除递归的一个好方法就是颠倒顺序. 上面那是从左到右向右跳, 这次我们从右向左向右跳, 就能更容易的知道知道某个下标是<code>GOOD</code>还是<code>BAD</code>了, 因为离最右端更近了.</p>\n<p>时间复杂度依然是O(n^2)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Index &#123;UNKNOW, GOOD, BAD&#125;;</span><br><span class=\"line\">Index *memo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">canJump</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; nums)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    memo = <span class=\"keyword\">new</span> Index[nums.<span class=\"built_in\">size</span>()]&#123;&#125;;</span><br><span class=\"line\">    memo[nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>] = GOOD;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; --i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> furthest_jump = <span class=\"built_in\">min</span>(nums[i] + i, (<span class=\"keyword\">int</span>)nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt;= furthest_jump; ++j)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (memo[j] == GOOD)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                memo[i] = GOOD;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> memo[<span class=\"number\">0</span>] == GOOD;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"算法分类学习","date":"2020-03-03T02:38:28.000Z","top":92,"img":"https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E5%B0%81%E9%9D%A2.png","_content":"","source":"_posts/算法92-算法理论-算法分类学习.md","raw":"---\ntitle: 算法分类学习\ndate: 2020-03-03 10:38:28\ntags:\ncategories:\n - 算法\n - 算法理论\ntop: 92\nimg: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E5%85%A5%E9%97%A8%E7%BB%8F%E5%85%B8%E5%B0%81%E9%9D%A2.png\n---\n","slug":"算法92-算法理论-算法分类学习","published":1,"updated":"2020-03-17T03:56:20.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvv00328cuoaac89x9q","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"游戏知识-服务器-服务器通信","date":"2019-12-22T12:50:02.000Z","_content":"\n由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面\n[服务器通信](https://gameinstitute.qq.com/course/detail/10096)\n<!--more-->\n# 概述\n作业型-单纯多个client对一个server .. 比如我开始写过的聊天室程序\n\n# CS通信\nDNS协议-基于UDP协议\n\nTCP\n面向连接的可靠的有时序性的-流式协议\n窗口管理\n流量控制\n数据确认\nUDP\n无连接不保证可靠性的无法保证时序-报文协议\n\nQQ-CS\n网络状况较好-UDP????-好吧还是处理了\n网络状况差-TCP\n大文件-TCP-TCP适合大文件交互, 因为他保持连接流式协议~\n\n微信-CS\n前台运行-TCP长连接\n后台运行-TCP短连接\n查看文章-HTTP(TCP短连接)\n\nQQ-早期产品, 花最少的前~榨干性能\n微信-腾讯后期产品\n\n----------------\n字符串\n自定义\nProtobuf\n\n序列化反序列化.\n\nUDP协议-不要让单个包的数据量超过1K, 否则会由于分片等 导致一个大包一旦一个分片失败就都失败\n\n存在的问题\n1. 客户端和服务端数据一直对不上\n可能是字节序的问题 - 字节序转换(网络字节数传送)\n2. 服务器发送的数据延迟-小包\nNAGLE算法-小包并不是立即发送-等存多了在一起发送-可以禁用掉~~\n3. 数据较大或者网络波动\n发送缓冲区慢了.. 适当加大发送缓冲区\n\n非阻塞IO\nO_NONBLOCK\n多路复用\nselect\npoll\nepoll\n\n# SS通信\nTCP-最常用\nUDP-非关键数据-日志服务-内网通信网络状况好可以超过MTU\n非SOCKET通信-进程间通信?-管道-信号-共享内存-信息队列-文件..","source":"_posts/游戏知识-服务器-服务器通信.md","raw":"---\ntitle: 游戏知识-服务器-服务器通信\ntags:\n  - 腾讯游戏学院\ncategories:\n  - 游戏知识\n  - 服务器\ndate: 2019-12-22 20:50:02\n---\n\n由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面\n[服务器通信](https://gameinstitute.qq.com/course/detail/10096)\n<!--more-->\n# 概述\n作业型-单纯多个client对一个server .. 比如我开始写过的聊天室程序\n\n# CS通信\nDNS协议-基于UDP协议\n\nTCP\n面向连接的可靠的有时序性的-流式协议\n窗口管理\n流量控制\n数据确认\nUDP\n无连接不保证可靠性的无法保证时序-报文协议\n\nQQ-CS\n网络状况较好-UDP????-好吧还是处理了\n网络状况差-TCP\n大文件-TCP-TCP适合大文件交互, 因为他保持连接流式协议~\n\n微信-CS\n前台运行-TCP长连接\n后台运行-TCP短连接\n查看文章-HTTP(TCP短连接)\n\nQQ-早期产品, 花最少的前~榨干性能\n微信-腾讯后期产品\n\n----------------\n字符串\n自定义\nProtobuf\n\n序列化反序列化.\n\nUDP协议-不要让单个包的数据量超过1K, 否则会由于分片等 导致一个大包一旦一个分片失败就都失败\n\n存在的问题\n1. 客户端和服务端数据一直对不上\n可能是字节序的问题 - 字节序转换(网络字节数传送)\n2. 服务器发送的数据延迟-小包\nNAGLE算法-小包并不是立即发送-等存多了在一起发送-可以禁用掉~~\n3. 数据较大或者网络波动\n发送缓冲区慢了.. 适当加大发送缓冲区\n\n非阻塞IO\nO_NONBLOCK\n多路复用\nselect\npoll\nepoll\n\n# SS通信\nTCP-最常用\nUDP-非关键数据-日志服务-内网通信网络状况好可以超过MTU\n非SOCKET通信-进程间通信?-管道-信号-共享内存-信息队列-文件..","slug":"游戏知识-服务器-服务器通信","published":1,"updated":"2020-03-05T14:04:59.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck80wucvv00348cuo3iqxg03s","content":"<p>由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面<br><a href=\"https://gameinstitute.qq.com/course/detail/10096\" target=\"_blank\" rel=\"noopener\">服务器通信</a></p>\n<a id=\"more\"></a>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>作业型-单纯多个client对一个server .. 比如我开始写过的聊天室程序</p>\n<h1 id=\"CS通信\"><a href=\"#CS通信\" class=\"headerlink\" title=\"CS通信\"></a>CS通信</h1><p>DNS协议-基于UDP协议</p>\n<p>TCP<br>面向连接的可靠的有时序性的-流式协议<br>窗口管理<br>流量控制<br>数据确认<br>UDP<br>无连接不保证可靠性的无法保证时序-报文协议</p>\n<p>QQ-CS<br>网络状况较好-UDP????-好吧还是处理了<br>网络状况差-TCP<br>大文件-TCP-TCP适合大文件交互, 因为他保持连接流式协议~</p>\n<p>微信-CS<br>前台运行-TCP长连接<br>后台运行-TCP短连接<br>查看文章-HTTP(TCP短连接)</p>\n<p>QQ-早期产品, 花最少的前~榨干性能<br>微信-腾讯后期产品</p>\n<hr>\n<p>字符串<br>自定义<br>Protobuf</p>\n<p>序列化反序列化.</p>\n<p>UDP协议-不要让单个包的数据量超过1K, 否则会由于分片等 导致一个大包一旦一个分片失败就都失败</p>\n<p>存在的问题</p>\n<ol>\n<li>客户端和服务端数据一直对不上<br>可能是字节序的问题 - 字节序转换(网络字节数传送)</li>\n<li>服务器发送的数据延迟-小包<br>NAGLE算法-小包并不是立即发送-等存多了在一起发送-可以禁用掉~~</li>\n<li>数据较大或者网络波动<br>发送缓冲区慢了.. 适当加大发送缓冲区</li>\n</ol>\n<p>非阻塞IO<br>O_NONBLOCK<br>多路复用<br>select<br>poll<br>epoll</p>\n<h1 id=\"SS通信\"><a href=\"#SS通信\" class=\"headerlink\" title=\"SS通信\"></a>SS通信</h1><p>TCP-最常用<br>UDP-非关键数据-日志服务-内网通信网络状况好可以超过MTU<br>非SOCKET通信-进程间通信?-管道-信号-共享内存-信息队列-文件..</p>\n","site":{"data":{}},"excerpt":"<p>由于自己了解的实在是不足, 所以来腾讯游戏课堂来学习一些架构之类的东西 来完善自己的知识面<br><a href=\"https://gameinstitute.qq.com/course/detail/10096\" target=\"_blank\" rel=\"noopener\">服务器通信</a></p>","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>作业型-单纯多个client对一个server .. 比如我开始写过的聊天室程序</p>\n<h1 id=\"CS通信\"><a href=\"#CS通信\" class=\"headerlink\" title=\"CS通信\"></a>CS通信</h1><p>DNS协议-基于UDP协议</p>\n<p>TCP<br>面向连接的可靠的有时序性的-流式协议<br>窗口管理<br>流量控制<br>数据确认<br>UDP<br>无连接不保证可靠性的无法保证时序-报文协议</p>\n<p>QQ-CS<br>网络状况较好-UDP????-好吧还是处理了<br>网络状况差-TCP<br>大文件-TCP-TCP适合大文件交互, 因为他保持连接流式协议~</p>\n<p>微信-CS<br>前台运行-TCP长连接<br>后台运行-TCP短连接<br>查看文章-HTTP(TCP短连接)</p>\n<p>QQ-早期产品, 花最少的前~榨干性能<br>微信-腾讯后期产品</p>\n<hr>\n<p>字符串<br>自定义<br>Protobuf</p>\n<p>序列化反序列化.</p>\n<p>UDP协议-不要让单个包的数据量超过1K, 否则会由于分片等 导致一个大包一旦一个分片失败就都失败</p>\n<p>存在的问题</p>\n<ol>\n<li>客户端和服务端数据一直对不上<br>可能是字节序的问题 - 字节序转换(网络字节数传送)</li>\n<li>服务器发送的数据延迟-小包<br>NAGLE算法-小包并不是立即发送-等存多了在一起发送-可以禁用掉~~</li>\n<li>数据较大或者网络波动<br>发送缓冲区慢了.. 适当加大发送缓冲区</li>\n</ol>\n<p>非阻塞IO<br>O_NONBLOCK<br>多路复用<br>select<br>poll<br>epoll</p>\n<h1 id=\"SS通信\"><a href=\"#SS通信\" class=\"headerlink\" title=\"SS通信\"></a>SS通信</h1><p>TCP-最常用<br>UDP-非关键数据-日志服务-内网通信网络状况好可以超过MTU<br>非SOCKET通信-进程间通信?-管道-信号-共享内存-信息队列-文件..</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck80wucui00018cuo02ut25o2","category_id":"ck80wucun00078cuo7wp858la","_id":"ck80wucus000h8cuo0s8m9yvr"},{"post_id":"ck80wucul00058cuo4u6qbbla","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucux000s8cuodcavfn0t"},{"post_id":"ck80wucul00058cuo4u6qbbla","category_id":"ck80wucus000g8cuog9ned79a","_id":"ck80wucuy000v8cuo59jxd34c"},{"post_id":"ck80wucud00008cuocrbjh7rs","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucuz000y8cuo0he7gyij"},{"post_id":"ck80wucud00008cuocrbjh7rs","category_id":"ck80wucus000g8cuog9ned79a","_id":"ck80wucv000108cuo5y857c3c"},{"post_id":"ck80wucum00068cuodc45f0mp","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucv100128cuo20ctey9d"},{"post_id":"ck80wucum00068cuodc45f0mp","category_id":"ck80wucus000g8cuog9ned79a","_id":"ck80wucv200158cuodsmx57xw"},{"post_id":"ck80wucun00088cuo7xmu9zv1","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucv300188cuoedlh1vh4"},{"post_id":"ck80wucun00088cuo7xmu9zv1","category_id":"ck80wucuz000x8cuo2ysec6so","_id":"ck80wucv4001a8cuo0fkgfuek"},{"post_id":"ck80wucup000b8cuo552n01tf","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucv5001c8cuo028r1dj9"},{"post_id":"ck80wucup000b8cuo552n01tf","category_id":"ck80wucuz000x8cuo2ysec6so","_id":"ck80wucv6001f8cuo89106ki7"},{"post_id":"ck80wucuq000d8cuocc1x1mot","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucv8001j8cuo7h1d248c"},{"post_id":"ck80wucuq000d8cuocc1x1mot","category_id":"ck80wucv300178cuogf0x9vg4","_id":"ck80wucvb001m8cuo1eya7cc7"},{"post_id":"ck80wucuk00038cuobsgk65yh","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucvc001p8cuo8tmx9t1h"},{"post_id":"ck80wucuk00038cuobsgk65yh","category_id":"ck80wucv300178cuogf0x9vg4","_id":"ck80wucvd001s8cuohdrc47dv"},{"post_id":"ck80wucur000f8cuo828i6kya","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucve001w8cuo9ytd80uj"},{"post_id":"ck80wucur000f8cuo828i6kya","category_id":"ck80wucuz000x8cuo2ysec6so","_id":"ck80wucvh001z8cuo8wbid4fb"},{"post_id":"ck80wucut000i8cuo5zfb4zsx","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucvi00238cuo9ewqa3dq"},{"post_id":"ck80wucut000i8cuo5zfb4zsx","category_id":"ck80wucuz000x8cuo2ysec6so","_id":"ck80wucvj00268cuo11rb0d20"},{"post_id":"ck80wucuu000k8cuo3tc92b6d","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucvl00298cuo1nfp5rht"},{"post_id":"ck80wucuu000k8cuo3tc92b6d","category_id":"ck80wucuz000x8cuo2ysec6so","_id":"ck80wucvl002c8cuoadwdgqyk"},{"post_id":"ck80wucuv000n8cuo7n5x6ic1","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucvm002f8cuo2pjqdtwa"},{"post_id":"ck80wucuv000n8cuo7n5x6ic1","category_id":"ck80wucuz000x8cuo2ysec6so","_id":"ck80wucvn002i8cuo0qjj0tcw"},{"post_id":"ck80wucuw000p8cuoccmfcael","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucvo002m8cuoenny79er"},{"post_id":"ck80wucuw000p8cuoccmfcael","category_id":"ck80wucvk00288cuo48gw8jrg","_id":"ck80wucvp002p8cuo8rte8ckl"},{"post_id":"ck80wucux000t8cuo9c0gd3eu","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucvt002t8cuo3gp4e6rp"},{"post_id":"ck80wucux000t8cuo9c0gd3eu","category_id":"ck80wucvm002g8cuoh3kv9di4","_id":"ck80wucvt002w8cuoaynd6a9p"},{"post_id":"ck80wucuy000w8cuo2kya8bag","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucvu00318cuo33xg8jyb"},{"post_id":"ck80wucuy000w8cuo2kya8bag","category_id":"ck80wucvo002n8cuo6nin6m5v","_id":"ck80wucvv00338cuo9trgekix"},{"post_id":"ck80wucuz000z8cuof3dtaft2","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucvw00388cuo38py3h11"},{"post_id":"ck80wucuz000z8cuof3dtaft2","category_id":"ck80wucvm002g8cuoh3kv9di4","_id":"ck80wucvw00398cuogx0i64iy"},{"post_id":"ck80wucv000118cuofk1f02at","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucvx003c8cuo5pkehibk"},{"post_id":"ck80wucv000118cuofk1f02at","category_id":"ck80wucvo002n8cuo6nin6m5v","_id":"ck80wucvx003e8cuo9uz6exl1"},{"post_id":"ck80wucv100148cuohr5m0z61","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucvy003h8cuog2n4hk81"},{"post_id":"ck80wucv100148cuohr5m0z61","category_id":"ck80wucvo002n8cuo6nin6m5v","_id":"ck80wucvy003j8cuo0o9ag7zd"},{"post_id":"ck80wucv200168cuo6flwhfqk","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucvz003m8cuoao9i9rz7"},{"post_id":"ck80wucv200168cuo6flwhfqk","category_id":"ck80wucvo002n8cuo6nin6m5v","_id":"ck80wucw0003o8cuo05cbgm8y"},{"post_id":"ck80wucv400198cuofwqt72c2","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucw0003r8cuo6ky08936"},{"post_id":"ck80wucv400198cuofwqt72c2","category_id":"ck80wucvo002n8cuo6nin6m5v","_id":"ck80wucw0003t8cuo9yer97cq"},{"post_id":"ck80wucv4001b8cuo5p365m1y","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucw1003v8cuoamxe1ule"},{"post_id":"ck80wucv4001b8cuo5p365m1y","category_id":"ck80wucvo002n8cuo6nin6m5v","_id":"ck80wucw1003x8cuo7qenhatp"},{"post_id":"ck80wucv5001d8cuohltv7tl6","category_id":"ck80wucuj00028cuo4yid11ki","_id":"ck80wucw1003y8cuobhrieu7x"},{"post_id":"ck80wucv5001d8cuohltv7tl6","category_id":"ck80wucvo002n8cuo6nin6m5v","_id":"ck80wucw200408cuo6maf72b2"},{"post_id":"ck80wucvb001n8cuo0vz77kmc","category_id":"ck80wucw200428cuohyg84u1x","_id":"ck80wucw300458cuo9lm472io"},{"post_id":"ck80wucve001u8cuo5j2zfcz0","category_id":"ck80wucw200428cuohyg84u1x","_id":"ck80wucw300478cuo3ig39sln"},{"post_id":"ck80wucvf001y8cuo9yv89ftp","category_id":"ck80wucw300468cuocqx4hlsw","_id":"ck80wucw4004a8cuo9dg80ctv"},{"post_id":"ck80wucvh00218cuo8yiahvxf","category_id":"ck80wucw200428cuohyg84u1x","_id":"ck80wucw4004b8cuogtdc8a3p"},{"post_id":"ck80wucvj00258cuo52fl1spy","category_id":"ck80wucw400498cuo7pd7dvm1","_id":"ck80wucw4004e8cuo8wzxew1o"},{"post_id":"ck80wucvk00278cuo603acrpu","category_id":"ck80wucw400498cuo7pd7dvm1","_id":"ck80wucw5004g8cuo3jc74awq"},{"post_id":"ck80wucvl002a8cuofekng33n","category_id":"ck80wucw400498cuo7pd7dvm1","_id":"ck80wucw5004h8cuo36zz11ap"},{"post_id":"ck80wucvn002k8cuo5nh7ca2j","category_id":"ck80wucw400498cuo7pd7dvm1","_id":"ck80wucw6004m8cuoexu2hihv"},{"post_id":"ck80wucv6001g8cuofgtqhs9i","category_id":"ck80wucw1003u8cuofhznac2s","_id":"ck80wucw9004u8cuofdhqg4b4"},{"post_id":"ck80wucv6001g8cuofgtqhs9i","category_id":"ck80wucw8004r8cuofsmaaxvk","_id":"ck80wucw9004v8cuoac2a9gpx"},{"post_id":"ck80wucv7001h8cuobf6fao1y","category_id":"ck80wucw1003u8cuofhznac2s","_id":"ck80wucw9004w8cuobwcbdnr0"},{"post_id":"ck80wucv7001h8cuobf6fao1y","category_id":"ck80wucw8004r8cuofsmaaxvk","_id":"ck80wucw9004y8cuofsnyezhv"},{"post_id":"ck80wucva001l8cuo3as7688r","category_id":"ck80wucw200418cuoetcp1xcm","_id":"ck80wucwa00508cuod8i89ggz"},{"post_id":"ck80wucva001l8cuo3as7688r","category_id":"ck80wucw9004t8cuo9yes6yud","_id":"ck80wucwa00518cuo9dbu80az"},{"post_id":"ck80wucvc001q8cuocnno52bu","category_id":"ck80wucw1003u8cuofhznac2s","_id":"ck80wucwa00528cuoc6w0fb57"},{"post_id":"ck80wucvc001q8cuocnno52bu","category_id":"ck80wucw8004r8cuofsmaaxvk","_id":"ck80wucwa00548cuoan3e958g"},{"post_id":"ck80wucvm002e8cuo6nbc38kk","category_id":"ck80wucw5004f8cuogeli5bsm","_id":"ck80wucwa00558cuoe02ad1ep"},{"post_id":"ck80wucvm002e8cuo6nbc38kk","category_id":"ck80wucwa004z8cuo3xuuficg","_id":"ck80wucwb00578cuoebp46f7t"},{"post_id":"ck80wucvn002h8cuo5x5gb7k4","category_id":"ck80wucw5004i8cuoagzdhqw4","_id":"ck80wucwb00588cuobq63e5tl"},{"post_id":"ck80wucvn002h8cuo5x5gb7k4","category_id":"ck80wucwa00538cuo67ms56vx","_id":"ck80wucwb005a8cuo7tpac9ko"},{"post_id":"ck80wucvo002o8cuo7ei03my6","category_id":"ck80wucw5004f8cuogeli5bsm","_id":"ck80wucwb005b8cuo1dut2x02"},{"post_id":"ck80wucvo002o8cuo7ei03my6","category_id":"ck80wucwa00568cuoekmofe3e","_id":"ck80wucwb005d8cuoetr34asj"},{"post_id":"ck80wucvp002r8cuobwsb4tc3","category_id":"ck80wucw6004l8cuoe8suc7bq","_id":"ck80wucwb005e8cuoedj0ck7x"},{"post_id":"ck80wucvp002r8cuobwsb4tc3","category_id":"ck80wucwb00598cuoc4vsde7k","_id":"ck80wucwc005g8cuo5lqfbk5m"},{"post_id":"ck80wucvt002v8cuo3e4i4jbz","category_id":"ck80wucw5004i8cuoagzdhqw4","_id":"ck80wucwc005i8cuo7as02ilt"},{"post_id":"ck80wucvt002v8cuo3e4i4jbz","category_id":"ck80wucwb005c8cuocnwph8f5","_id":"ck80wucwc005j8cuo2krk9hun"},{"post_id":"ck80wucvu002y8cuo5fk45uia","category_id":"ck80wucw6004l8cuoe8suc7bq","_id":"ck80wucwd005k8cuoarmz3i5q"},{"post_id":"ck80wucvu002y8cuo5fk45uia","category_id":"ck80wucwb00598cuoc4vsde7k","_id":"ck80wucwd005m8cuoc37hcfbb"},{"post_id":"ck80wucvv00328cuoaac89x9q","category_id":"ck80wucw6004l8cuoe8suc7bq","_id":"ck80wucwd005n8cuo4bp2htan"},{"post_id":"ck80wucvv00328cuoaac89x9q","category_id":"ck80wucwc005h8cuo5db0hn05","_id":"ck80wucwe005o8cuo3d118ntp"},{"post_id":"ck80wucvv00348cuo3iqxg03s","category_id":"ck80wucw5004i8cuoagzdhqw4","_id":"ck80wucwe005p8cuob8i6cahu"},{"post_id":"ck80wucvv00348cuo3iqxg03s","category_id":"ck80wucwb005c8cuocnwph8f5","_id":"ck80wucwe005q8cuo2s5880n3"}],"PostTag":[{"post_id":"ck80wucui00018cuo02ut25o2","tag_id":"ck80wucul00048cuoc18d5mpo","_id":"ck80wucuo000a8cuogko99qc7"},{"post_id":"ck80wucuk00038cuobsgk65yh","tag_id":"ck80wucuo00098cuo5nmu03g1","_id":"ck80wucuu000l8cuo5xsnbhlp"},{"post_id":"ck80wucuk00038cuobsgk65yh","tag_id":"ck80wucur000e8cuo4ss3f3lt","_id":"ck80wucuw000o8cuo3w3rc872"},{"post_id":"ck80wucuq000d8cuocc1x1mot","tag_id":"ck80wucuo00098cuo5nmu03g1","_id":"ck80wucux000q8cuobax5fv09"},{"post_id":"ck80wucuq000d8cuocc1x1mot","tag_id":"ck80wucur000e8cuo4ss3f3lt","_id":"ck80wucuy000u8cuocupm4iyg"},{"post_id":"ck80wucv6001g8cuofgtqhs9i","tag_id":"ck80wucv8001k8cuoan73czt5","_id":"ck80wucvd001t8cuodzbf5hpt"},{"post_id":"ck80wucvc001q8cuocnno52bu","tag_id":"ck80wucv8001k8cuoan73czt5","_id":"ck80wucvf001x8cuohg6ibi8n"},{"post_id":"ck80wucv7001h8cuobf6fao1y","tag_id":"ck80wucv8001k8cuoan73czt5","_id":"ck80wucvh00208cuo2hile84w"},{"post_id":"ck80wucvf001y8cuo9yv89ftp","tag_id":"ck80wucvj00248cuo6qj29560","_id":"ck80wucvm002d8cuohkkydsyf"},{"post_id":"ck80wucvj00258cuo52fl1spy","tag_id":"ck80wucvl002b8cuo0lk29udx","_id":"ck80wucvo002l8cuo0kti0tg0"},{"post_id":"ck80wucvk00278cuo603acrpu","tag_id":"ck80wucvn002j8cuo8aiycok5","_id":"ck80wucvt002s8cuogrrf6ere"},{"post_id":"ck80wucvl002a8cuofekng33n","tag_id":"ck80wucvp002q8cuo2xat1r5q","_id":"ck80wucvu002z8cuo7jhhfy5c"},{"post_id":"ck80wucvm002e8cuo6nbc38kk","tag_id":"ck80wucvu002x8cuo7dd575gb","_id":"ck80wucvw00368cuodryp7g7d"},{"post_id":"ck80wucvn002h8cuo5x5gb7k4","tag_id":"ck80wucvw00358cuoengf6p6t","_id":"ck80wucvx003d8cuo7n6w5uzo"},{"post_id":"ck80wucvn002k8cuo5nh7ca2j","tag_id":"ck80wucvx003a8cuoa5j0gi38","_id":"ck80wucvy003i8cuo7lsa91ac"},{"post_id":"ck80wucvo002o8cuo7ei03my6","tag_id":"ck80wucvx003f8cuo0od59omt","_id":"ck80wucw0003n8cuoarxxhbh7"},{"post_id":"ck80wucvt002v8cuo3e4i4jbz","tag_id":"ck80wucvw00358cuoengf6p6t","_id":"ck80wucw0003s8cuodzsddgo2"},{"post_id":"ck80wucvv00348cuo3iqxg03s","tag_id":"ck80wucvw00358cuoengf6p6t","_id":"ck80wucw1003w8cuohnu34t9e"}],"Tag":[{"name":"3DMAX","_id":"ck80wucul00048cuoc18d5mpo"},{"name":"CPP踩坑记","_id":"ck80wucuo00098cuo5nmu03g1"},{"name":"CPP","_id":"ck80wucur000e8cuo4ss3f3lt"},{"name":"Git操作","_id":"ck80wucv8001k8cuoan73czt5"},{"name":"小游戏","_id":"ck80wucvj00248cuo6qj29560"},{"name":"GDB调试","_id":"ck80wucvl002b8cuo0lk29udx"},{"name":"Linux","_id":"ck80wucvn002j8cuo8aiycok5"},{"name":"csapp","_id":"ck80wucvp002q8cuo2xat1r5q"},{"name":"Mysql","_id":"ck80wucvu002x8cuo7dd575gb"},{"name":"腾讯游戏学院","_id":"ck80wucvw00358cuoengf6p6t"},{"name":"权限管理","_id":"ck80wucvx003a8cuoa5j0gi38"},{"name":"MongoDB","_id":"ck80wucvx003f8cuo0od59omt"}]}}