---
title: 大三寒假学习记录
date: 2021-02-23 22:43:32
categories:
  - 假期学习记录
---

# 2021年2月1日-3日

**动态规划问题**

编辑距离

最长递增子序列

俄罗斯套娃信封

最大子序和

最长公共子序列

# 2021年2月4日22:46:59

今天把博客整理了下分类

继续学习的动态规划算法两道题目 

[583\. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/) 

[712\. 两个字符串的最小ASCII删除和](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/)


2021年2月4日23:26:37 https://learngitbranching.js.org/?locale=zh_CN 学习Git的挺不错的网站 练习一遍


# 2021年2月5日11:18:56

上次改了改项目的BUG, 发布了1.1 release版本

继续算法

[516\. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

整了一大下午 没想到是memcpy 的问题总算解决了虚拟机代码无法运行的问题

# 2021年2月20日

C++ 拷贝构造函数和赋值运算符 https://www.cnblogs.com/wangguchangqing/p/6141743.html


allocate deallocate 
malloc free
new delete

STL allocate deallocate constructor deconstructor
std allocate


我理解的右值引用、移动语义和完美转发 https://www.jianshu.com/p/d19fc8447eaa


![内存布局](https://uploadfiles.nowcoder.com/images/20190313/311436_1552467921124_13956548C4BB199139A2744C39350272)


TODO 异步回调 sync

TODO 聊聊同步、异步、阻塞与非阻塞 https://my.oschina.net/xianggao/blog/661085


|| 多线程 | 多进程 |
|---| --- | --- |
| 同步 | mutex线程锁, 条件变量, 信号量(生产者消费者)| PV操作 |
| 数据共享 | | 共享内存, 消息队列, 管道,|

信号量可以设置多个初始资源 等多个初始资源消耗完毕后才会sleep

条件变量则是直接sleep等待一个个或者全部唤醒

https://blog.csdn.net/linraise/article/details/12979473


# 2021年2月22日 - AC5

更加的透彻 https://codinfox.github.io/dev/2014/06/03/move-semantic-perfect-forward/

## 移动语义和完美转发

**移动构造函数**
可以将源对象中的高消耗资源 转移到 新的对象中

而使用拷贝构造函数会导致生成两份高消耗资源 造成浪费

**左值 右值**
能够取到地址的为左值 否则是右值

**std::move std::forward**
move将一个左值T转换为右值 以此来调用对象的移动构造函数 转移内部资源, 否则由于T是左值将会调用拷贝构造函数 生成新的资源 浪费旧的资源

forward左值依然为左值 右值转换为右值. 当一个参数传入右值形参的时候 函数的实参实际为左值 使用forward可以将函数实参转换原本的右值

而当传入左值的时候forward转换后依旧是左值

**void Foo(const int&)**
在没有其他重载的情况下, `const int&`可以接收左值也可以接收右值  如果去掉`const`则只能接收右值


每个线程都是如何启动的, 各个线程的作用. 线程间的数据交互方式

TODO unique_lock  lock_guard scope_lock lock 等的作用

条件变量虚假唤醒

整理了jsoncpp的代码明天看

# 2021年2月23日 - AC5

https://github.com/HiganFish/jsoncpp1.9.4-learn jsoncpp代码阅读

## lower_bound + insert 比 find + insert 要高性能

insert会利用lower_bound的返回值

而find则没有此效果 总是需要进行O(log N)的查找位置

```c++
EventLoop* EventLoopThread::Start()
{
	thread_.Start();

	EventLoop* loop = nullptr;
	{
		MutexGuardLock guard(mutex_);
		while (loop_ == nullptr)
		{
			cond_.Wait();
		}
		loop = loop_;  // 为了等线程创建完毕后 才返回 否则这个函数只有第一句 线程未创建完毕就返回了
	}
	return loop;
}

void EventLoopThread::ThreadFunc()
{
	EventLoop loop;
	{
		MutexGuardLock guard(mutex_);
		loop_ = &loop;
		cond_.WakeUpOne();
	}
}
```

# 2021年2月24日

## typename and class in template

```c++
class D
{
public:
	typedef int INT;
};

template <class T> // mingw中和 template <typename T> 完全等效 必须在 T::INT 前加typename
class D1
{
public:
	T::INT i1; // error: need 'typename' before 'T::INT' because 'T' is a dependent scope
	typename T::INT i2; // true
};

int main()
{
	D1<D> d_1;
}
```



额外发现
```c++
template <class T>
class A
{
public:
	T t_;
};

template <class T>
class A1 : public A<T>
{
public:
	A1()
	{
		// t_ = 1;
		this->t_ = 1; // 这里需要使用this指针访问
		A<T>::t_ = 1; // 可读性更好
	}
};
```

## 二段名字查找
1. 第一段: 模板定义阶段  在被定义时 只在模板中有独立的名字(和模板参数无关) 参与查找
2. 第二段: 模板类实例化  非独立的名字参与查找

**以成员变量为例 成员函数同理**
1. 在第一阶段, 首先处理A1遇到了`class A1 : public A<T>`. 此时父类`A<T>`依赖于模板参数 属于非独立 不参与查找
2. 在之后遇到了`t_`这个变量, 由于没有查找基类 这里便认为`t_`是一个非成员变量
3. 第二阶段这时候才处理`A<T>` 虽然这时已经`可以知道t_是一个成员变量`但是第一阶段编译器已经认定了`t_`是一个非成员变量
4. 而对于一个非成员变量 编译器认为不需要去基类中查找, 所以就报错无法找到

1. 使用this之后在第一阶段, 编译器就被明确的告知`t_`是一个成员变量
2. 然后第二阶段, 编译器就会去基类中查找这个成员变量. 



https://www.cnblogs.com/onepixel/articles/7674659.html


# 2021年2月25日 - AC1

开学了坐了一天车

A了一道题-_-


# 2021年2月26日 - AC6

偶然看到了一道面试题, 问的是如何从2.5亿数字中找到重复的数字

https://leetcode-cn.com/circle/discuss/6TtGra/

大佬云集..


TODO likely宏和__builtin_expect编译器函数性能评测

TODO string_view https://cloud.tencent.com/developer/article/1479005

TODO
```c++
void (TcpConnection::*fp)(const std::string_view&) = &TcpConnection::SendInLoop;
			loop_->RunInLoop(std::bind(fp, 
					this,
					std::string(data, length))); // OK

TcpConnection::SendInLoop;
			loop_->RunInLoop(std::bind(&TcpConnection::SendInLoop, 
					this,
					std::string(data, length))); // ERROR ???

loop_->RunInLoop([this, str = std::string(data, length)]()
			{
				RunInLoop(str);
			}); // HOW TO FIX ERROR ???
```

TODO make_unique make_shared

Warning: File "xxx" has modification time yyy s in the future

mutable

```c++
std::vector<EventLoopFunction> pending_func;
{
	/**
		* 减少锁持有的时间
		*/
	MutexLockGuard guard(pending_func_mutex_);
	pending_func.swap(pending_func_);
}
```


## Linux下查看进程线程数

```shell
lsof -Ptn -i tcp:4100 # -P 不解析port -n 不解析主机名 会解决lsof卡gethostbyaddr -t 只显示pid

pid=$(lsof -Pnt -i tcp:4100)

cat /proc/$pid/status | grep Threads
	Threads:	5

top -Hp $pid
	107344 root      20   0  334464   6780   5192 S   0.0   0.2   0:00.74 LiveBroadcastSe                                         
	107361 root      20   0  334464   6780   5192 S   0.0   0.2   0:23.11 LiveBroadcastSe                                         
	107362 root      20   0  334464   6780   5192 S   0.0   0.2   0:00.70 LiveBroadcastSe                                         
	107363 root      20   0  334464   6780   5192 S   0.0   0.2   0:04.76 LiveBroadcastSe                                         
	107364 root      20   0  334464   6780   5192 S   0.0   0.2   0:04.79 LiveBroadcastS

pstree -p $pid
	LiveBroadcastSe(107344)─┬─{LiveBroadcastSe}(107361)
							├─{LiveBroadcastSe}(107362)
							├─{LiveBroadcastSe}(107363)
							└─{LiveBroadcastSe}(107364)

```