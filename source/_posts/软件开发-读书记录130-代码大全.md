---
title: 代码大全
tags:
  - null
categories:
  - 软件开发
  - 读书记录
date: 2020-05-13 21:19:39

top: 130
img: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%E5%B0%81%E9%9D%A2.png
---
距离上次什么时候写博客已经记不清了, 看了眼GitHub备份记录 已经25天了. 这25天我咕了吗? 咕是不可能咕的. 这段时间我终于做出了第一个UE4比较完善的联机游戏.
学习了更多的muduo自己的mongo也更加完善. 学而不思则罔,思而不学则殆. 只看书写博客不写代码可不行.

技术类书籍慢慢开始看了, mongo写的时间不短了.  代码大全听说是神书? 来粗读看看吧

# 第六章 可以工作的类
使用ADT 可以实现隐藏细节, 改动不会影响到整个程序.

这点感受还是有些的. 前两天自己写VPN(目前项目暂停了)的时候, 有个Buffer类, Buffer类的核心是libevent的evbuff, 我直接使用Get方法Get到这个evbuff的指针, 然后在外部进行操作.
起初这样只是图简单吧, 也想到了这样会写出烂代码. 后面改动核心evbuff的时候, 发现太麻烦了, 最终改成了几个简单的接口 Append Clear等, 对外隐藏了内部是什么缓冲结构


has a  ---- 组合 包含
is a ---- 集成 epoll(select) is a mutiplexing


只有一个实例的类是值得怀疑的, 同样只有一个派生类的基类也是值得怀疑的

拷贝对象优先使用深拷贝

创建类的原因
- 为现实世界中的对象建模
- 为抽象的对象建模 形状类是抽象的 不过圆 正方形等都是真实存在的
- 降低复杂度 一个类创建结束后, 你就可以忘掉其中的细节 使用接口即可
- 隔离复杂度
- 隐藏实现细节 限制变动的影响范围 隐藏全局数据
- 让参数传递更加舒畅 成员变量 
- 复用代码


# 第七章 高质量的子程序

创建子程序的正当理由
- 降低复杂度
一个子程序编写完毕后, 应该可以忘记其中的细节
- 引入中间,易懂的抽象
避免代码重复  从大块的代码中抽取子程序
- 隐藏顺序 如果某两行代码有特定的执行顺序, 可以考虑抽取出来. 感觉这里可以推广到Mutex lock后忘记unlock 或者 Buffer中读取数据后 忘记移动指针?
- 提高可移植性 这点看项目了


似乎过于简单没有必要写成子程序, 当然也要看情况了
- 这里我感觉最深的还是 两行或者三行经常调用的程序, 如果重复写多次 最终告知你需要修改的时候 那可真是灾难性的消息. 实例的话: 增加参数校验等等


准确的使用对仗词

|        |          |
| ------ | -------- |
| add    | remove   |
| begin  | end      |
| create | destory  |
| next   | previous |
| start  | stop     |


如何使用子程序参数
- 按照输入-修改-输出的顺序排列参数
- 如果几个子程序都是用了类似的一些参数, 应该让这些参数的排列顺序一致
- 使用所有的参数, 删去未使用到的参数
- 不要把子程序的参数用做工作变量

设置函数的返回值
- 检查所有可能的返回路径, 在函数开头设置默认返回 只一个不错的选择(muduo中见到了)
- 老生常谈的不要返回局部对象的引用或者指针


少使用宏吧 inline和typedef 不香吗

# 第八章 防御式编程
~~防御式编程并不是说让你在编程时保持 "防备批评或攻击" 的态度~~

子程序不应该因为传入错误数据而被破坏
- 检查所有源自外部数据的值
- 检查子程序所有输入参数的值
- 决定如何处理错误的输入数据

使用错误处理代码来处理与其发生的状况, 使用断言来处理绝不应该发生的状况


错误处理技术 其他感觉... 用不到吧 现在不记录了
- 返回中立值 最简单的方法, 继续执行操作并简单的返回一个没有危害的数值. 数值计算-返回0 字符串返回空串 指针返回空指针
- 日志打印
- 关闭程序


隔离程序
两块相对独立的代码块 在交互函数见进行参数校验 过滤掉一个模块传来的非法参数

辅助调试的代码.....
我现在就遇到一个bug 还不知道怎么修改 与多线程有关的问题 排查真难-2020年5月18日13:11:43


决定产品最终发布的时候应该保留多少防御内容
防御内容越多消耗的性能越多

# 第九章 伪代码的编程过程