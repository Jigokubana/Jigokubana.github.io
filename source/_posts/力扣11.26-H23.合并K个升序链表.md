---
title: 力扣11.26-H23.合并K个升序链表
tags:
  - 递归分治
categories:
  - 算法
  - 力扣每日一题
date: 2020-11-26 16:25:02
---
# 合并K个升序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

示例 1：
```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```
示例 2：
```
输入：lists = []
输出：[]
```
示例 3：
```
输入：lists = [[]]
输出：[]
```
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/merge-k-sorted-lists
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 代码1

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:

    ListNode* Merge(const vector<ListNode*>& lists, int left, int right)
    {
        if (right - left <= 1)
        {
            return lists[left];
        }
        else if (right - left == 2)
        {
            ListNode* node1 = lists[left];
            ListNode* node2 = lists[left + 1];

            if (!node1)
            {
                return node2;
            }
            else if (!node2)
            {
                return node1;
            }

            ListNode* head = new ListNode;
            ListNode* node = head;

            if (node1->val <= node2->val)
            {
                head->val = node1->val;
                node1 = node1->next;
            }
            else
            {
                head->val = node2->val;
                node2 = node2->next;
            }

            while (node1 != nullptr || node2 != nullptr)
            {
                if (!node1 || (node2 && node2->val <= node1->val))
                {
                    node->next = new ListNode(node2->val);
                    node = node->next;
                    node2 = node2->next;
                }
                else if (node2 == nullptr || (node1 && node1->val < node2->val))
                {
                    node->next = new ListNode(node1->val);
                    node = node->next;
                    node1 = node1->next;
                }
            }

            return head;
        }
        else
        {
            int mid = (left + right) >> 1;
            ListNode* node1 = Merge(lists, left, mid);
            ListNode* node2 = Merge(lists, mid, right);
            ListNode* result = Merge({ node1, node2 }, 0, 2);
            return result;
        }
    }

    ListNode* mergeKLists(vector<ListNode*>& lists)
    {
        if (lists.empty())
        {
            return nullptr;
        }
        return Merge(lists, 0, lists.size());
    }
};
```

思路的话比较简单 使用分治和递归. 将若干个`ListNode*`的合并的最终分解为 两两合并. 然后将合并结果再两两合并

第一版代码 我甚至没有delete临时用的指针... 有内存泄漏的问题  最终提交后 `Time-33%`.... 好吧

仔细想了下部分地方不需要这么多的拷贝 直接复用已有的`ListNode*`就行

## 代码2

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

class Solution {
public:

    ListNode* Merge(const vector<ListNode*>& lists, int left, int right)
    {
        if (right - left <= 1)
        {
            return lists[left];
        }
        else if (right - left == 2) // 主要改动从这里开始
        {
            ListNode* node1 = lists[left];
            ListNode* node2 = lists[left + 1];

            if (!node1)
            {
                return node2;
            }
            else if (!node2)
            {
                return node1;
            }

            ListNode* head;
            if (node1->val <= node2->val)
            {
                head = node1;
                node1 = node1->next;
            }
            else
            {
                head = node2;
                node2 = node2->next;
            }

            ListNode* node = head;

            while (node1 != nullptr || node2 != nullptr)
            {
                if (!node1) // 同时在`node1`或`node2`为空的时候 直接append 避免额外的扫描
                {
                    node->next = node2;
                    break;
                }
                else if (!node2)
                {
                    node->next = node1;
                    break;
                }
                else
                {
                    if (node2->val <= node1->val)
                    {
                        node->next = node2;
                        node = node->next;

                        node2 = node2->next;
                    }
                    else
                    {
                        node->next = node1;
                        node = node->next;

                        node1 = node1->next;
                    }
                }
            }

            return head;
        }
        else
        {
            int mid = (left + right) >> 1;
            ListNode* node1 = Merge(lists, left, mid);
            ListNode* node2 = Merge(lists, mid, right);
            ListNode* result = Merge({ node1, node2 }, 0, 2);
            return result;
        }
    }

    ListNode* mergeKLists(vector<ListNode*>& lists)
    {
        if (lists.empty())
        {
            return nullptr;
        }
        return Merge(lists, 0, lists.size());
    }
};
```

这次改动去掉了所有的new 因为直接复用已有的ListNode即可 同时在`node1`或`node2`为空的时候 直接append 避免额外的扫描

从`Time-33%`变化到了`Time-67%`  

## 样例代码

```c++
class Solution {
public:
    // 合并两个有序链表
    ListNode* merge(ListNode* p1, ListNode* p2){ // 合并
        if(!p1) return p2;
        if(!p2) return p1;
        if(p1->val <= p2->val){
            p1->next = merge(p1->next, p2);
            return p1;
        }else{
            p2->next = merge(p1, p2->next);
            return p2;
        }
    }

    ListNode* merge(vector<ListNode*>& lists, int start, int end){ // 负责拆分和合并
        if(start == end) return lists[start];
        int mid = (start + end) / 2;
        ListNode* l1 = merge(lists, start, mid);
        ListNode* l2 = merge(lists, mid+1, end);
        return merge(l1, l2);
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.size() == 0) return nullptr;
        return merge(lists, 0, lists.size()-1);
    }
};
```

这代码太精简了...