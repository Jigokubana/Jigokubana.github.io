---
title: 力扣2.2-H72.编辑距离
tags:
  - 动态规划
categories:
  - 算法
  - 力扣每日一题
date: 2021-2-2 22:10:02
---

# [72\. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

Difficulty: **困难**


给你两个单词 `word1` 和 `word2`，请你计算出将 `word1` 转换成 `word2`所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

*   插入一个字符
*   删除一个字符
*   替换一个字符

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

**提示：**

*   `0 <= word1.length, word2.length <= 500`
*   `word1` 和 `word2` 由小写英文字母组成

## Solution 回溯

```c++
class Solution {
public:

    int min_time = INT_MAX;

    int minDistance(string word1, string word2)
    {
        minDistance(word1, word2, 0, 0, 0);
        return min_time;
    }

    void minDistance(string word1, string word2, int ws1, int ws2, int time)
    {
        if (time >= min_time)
        {
            return;
        }

        if (ws2 == word2.length() || ws1 == word1.length())
        {
            for (int i = 0; i < min(ws1, ws2); ++i)
            {
                if (word1[i] != word2[i])
                {
                    return;
                }
            }
            time += word1.length() > word2.length() ? word1.length() - word2.length() :  word2.length() - word1.length();
            if (time < min_time)
            {
                min_time = time;
            }
        }
        else
        {
            if (word1[ws1] == word2[ws2])
            {
                minDistance(word1, word2, ws1 + 1, ws2 + 1, time);
            }
            else
            {
                char back = word1[ws1];
                word1[ws1] = word2[ws2];
                minDistance(word1, word2, ws1 + 1, ws2 + 1, time + 1);
                word1[ws1] = back;
                
                string back_str = word1;
                word1.erase(ws1, 1);
                minDistance(word1, word2, ws1, ws2, time + 1);
                word1 = back_str;

                word1.insert(ws1, 1, word2[ws2]);
                minDistance(word1, word2, ws1 + 1, ws2 + 1, time + 1);
            }
        }
    }
};
```

## Solution DP备忘录

```c++
​class Solution {
public:

    map<string, int> bwl;
    int minDistance(string word1, string word2)
    {
        return minDistance(word1, word2, word1.length() - 1, word2.length() - 1);
    }

    int minDistance(const string& word1, const string& word2, int ws1, int ws2)
    {
        if (ws1 == -1) return ws2 + 1;
        if (ws2 == -1) return ws1 + 1;

        string key = to_string(ws1) + "#" + to_string(ws2);
        if (bwl.find(key) != bwl.end())
        {
            return bwl[key];
        }

        if (word1[ws1] == word2[ws2])
        {
            bwl[key] = minDistance(word1, word2, ws1 - 1, ws2 - 1);
        }
        else
        {
            bwl[key] = min({
                minDistance(word1, word2, ws1, ws2 - 1), // 插入
                minDistance(word1, word2, ws1 - 1, ws2 - 1), // 替换
                minDistance(word1, word2, ws1 - 1, ws2) // 删除
            }) + 1;
        }

        return bwl[key];
    }
};
```

## Solution DP Table

```c++
class Solution {
public:

    int minDistance(string word1, string word2)
    {
        int dp[word1.length() + 1][word2.length() + 1];

        dp[0][0] = 0;
        for (int i = 1; i <= word2.length(); ++i)
        {
            dp[0][i]  = i;
        }
        for (int i = 1; i <= word1.length(); ++i)
        {
            dp[i][0] = i;
        }

        for (int ws1 = 1; ws1 <= word1.length(); ++ws1)
        {
            for (int ws2 = 1; ws2 <= word2.length(); ++ws2)
            {
                if (word1[ws1 - 1] == word2[ws2 - 1])
                {
                    dp[ws1][ws2] = dp[ws1 - 1][ws2 - 1];
                }
                else
                {
                    dp[ws1][ws2] = min({
                        dp[ws1 - 1][ws2 - 1],
                        dp[ws1][ws2 - 1],
                        dp[ws1 - 1][ws2]
                    }) + 1;
                }
            }
        }
        return dp[word1.length()][word2.length()];
    }
};
```

## 总结

使用回溯法的代码超时了, 而且回溯解法里面对字符串进行了实打实的修改

从回溯法转向DP备忘录优化了一个参数 使用返回值返回答案而不是单独的time参数. DP备忘录由于使用了递归所以使用的空间大, 效率也低 

观察DP备忘录
`dp[ws1][ws2]`只跟`dp[ws1-1][ws2-1]`, `dp[ws1][ws2-1]`和`dp[ws1-1][ws2]`有关进而自然的转向DP Table

Dp Table这里数组一般都需要多开一行+一列 对应代码里面的`length()+1`, 否则下标0含有两层意思 一是空串时长度为0 二是非空串是含有0这个有效下标

所以将非空串的下标改为从1开始