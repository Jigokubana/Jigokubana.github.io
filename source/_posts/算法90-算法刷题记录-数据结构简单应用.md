---
title: 数据结构指针简答应用
date: 2020-03-03 10:38:28
tags:
categories:
 - 算法
 - 算法刷题记录
top: 90
---
为了压缩长度. 所有空行都删掉了
# 哈希表

## 哈希表建立快速索引, 一遍和两遍哈希的使用
https://leetcode.com/problems/two-sum
题目很简单
```
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```
不是最差... 也差不多了 最简单粗暴的形式 O(n2) O(1)
```c++
vector<int> twoSum(vector<int>& nums, int target)
{
	for (int i = 0; i < nums.size(); ++i)
	{
		// 答案肯定是一个小数和一个大数 相加, 直接往后找 测试用例应该是排好序的
		for (int j = i + 1; j < nums.size(); ++j)
		{
			if (nums[i] + nums[j] == target)
			{
				return vector<int>{i, j};
			}
		}
	}
	return vector<int>{0, 1};
}
```
两遍哈希 由于需要更快的找到 vector中某个元素的下标, 非常适合哈希表来做
先放入哈希表中, 再寻找自己所需要的值是否存在以及下标 O(n) O(n)
```c++
vector<int> twoSum(vector<int>& nums, int target)
{
	unordered_map<int, int> the_map;
	for (int i = 0; i < nums.size(); ++i)
	{
		the_map.insert({nums[i], i});
	}
	
	for (int i = 0; i < nums.size(); ++i)
	{
		auto search = the_map.find(target - nums[i]);
		// unordered_map<int, int>::iterator search = the_map.find(target - nums[i]);
		
		if (search != the_map.end())
		{
			if (search->second == i)
			{
				continue;
			}
			return vector<int>{i, search->second};
		}
	}
	return vector<int>{0, 0};
}
```
一遍哈希, 既然是要在表中查找到需要数 还需要判断是否同一个数
干脆直接在插入前就进行查找
```c++
vector<int> twoSum(vector<int>& nums, int target)
{
	unordered_map<int, int> the_map;
	for (int i = 0; i < nums.size(); ++i)
	{
		auto search = the_map.find(target - nums[i]);
		if (search != the_map.end())
		{
			return vector<int>{i, search->second};
		}
		the_map.insert({nums[i], i});
	}
	return vector<int>{0, 0};
}
```
## flag的使用
```
给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。

注意:
假设字符串的长度不会超过 1010。

输入:
"abccccdd"

输出:
7

解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

这个开始我这样写的, 因为需要
在有奇数字母个数的时候 需要额外 结果+1
没有奇数字母个数 结果不需要额外 +1
```c++
int longestPalindrome(string s)
{
	int letter[68]{};

	for (int i = 0; i < s.size(); ++i)
	{
		letter[s[i] - 65]++;
	}
	int sum = 0;
	int oddnum = 0;
	for (int i = 0; i < 68; ++i)
	{
		int num = letter[i];
		sum += num;
		if (num %2 == 1)
		{
			oddnum++;
		}
	}
	sum -= oddnum;
	// 通过额外的一个if判断 是否存在奇数
	if (oddnum > 0)
	{
		sum++;
	}
	return sum;


	int sum = 0;
	int oddnum = 0;
	// 设置这个flag 代码少了一个if 实际用途有没有.... 感觉这个思想是可以的
	int flag = 0;
	for (int i = 0; i < 68; ++i)
	{
		int num = letter[i];
		sum += num;
		if (num %2 == 1)
		{
			oddnum++;
			flag = 1;
		}
	}
	sum -= oddnum;
	return sum + flag;
}
```


# 双指针操作

## 双指针左右逼近-数学问题
https://leetcode.com/problems/container-with-most-water/

存水量 = a(宽) * b(长);

从a最大的时候开始, 如果想要获得更大的存水量, 只能减少a, 增加b

使用两个指针 一个指向最左边 一个指向最右边

这就有了移动哪个指针的问题, 为了得到更长的b 只能移动指向较短b的指针

```c++
int maxArea(vector<int>& height)
{
    int max = 0;   
    vector<int>::const_iterator left = height.begin();
    vector<int>::const_iterator right = height.end() - 1;
    while (left < right)
    {
        int temp = min(*left, *right) * (right - left);
        if (temp > max)
        {
            max = temp;
        }
        // 移动较短边
        if (*left <= *right)
        {
            left++;
        }
        else
        {
            right--;
        }
    }
    return max;
}
```
## 合并排序数组-双指针操作 拷贝到临时数组和直接写到原数组
https://leetcode-cn.com/problems/sorted-merge-lcci/
给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。
初始化 A 和 B 的元素数量分别为 m 和 n。
```c++
输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```
第一次太惨了, 看来我算法需要加倍的联系啊. 先不说考虑很久
```c++
void merge(vector<int>& A, int m, vector<int>& B, int n)
{
	if (n == 0)
	{
		return;
	}
	int temp = 0;
	// 这里的 m + n就有点问题, 后面会空转 改为m + temp合适
	for (int i = 0; i < m + n; ++i)
	{
		if (A.at(i) < B.at(temp))
		{
			continue;
		}
		A.insert(A.begin() + i, B.at(temp++));
		if (temp == n)
		{
			break;
		}
	
	if (temp < n)
	{
		A.insert(A.begin() + m + temp, B.begin() + temp, B.end());
	}
	A.erase(A.begin() + n + m, A.end());
}
```
使用插入再删除, 本身这个方法就不是很好. 后来看题解有双指针, 就去试了下. 这样需要额外的空间
如果直接正序的修改A的值, 可能会导致A的值被覆盖掉.
那么倒序呢? 倒序放上最大的值 就不会覆盖掉A中未读取的值了 继续修改
```c++
void merge(vector<int>& A, int m, vector<int>& B, int n)
{
	int sorted[m + n];
	auto a = A.begin();
	auto b = B.begin();
	int index = 0;
	while (index != m + n)
	{
		if (a - A.begin() == m)
		{
			sorted[index++] = *b++;
		}
		else if (b - B.begin() == n)
		{
			sorted[index++] = *a++;
		}
		else if (*a < *b)
		{
			sorted[index++] = *a++;
		}
		else if (*a == *b)
		{
			sorted[index++] = *a++;
			sorted[index++] = *b++;
		}
		else
		{
			sorted[index++] = *b++;
		}
	}
	for (int i = 0; i < m + n; ++i)
	{
		A[i] = sorted[i];
	}
	
}
```
改正后的代码如下
```c++
void merge(vector<int>& A, int m, vector<int>& B, int n)
{
	int index = m + n - 1;
	int a = m - 1;
	int b = n - 1;
	while (index >= 0)
	{
		if (a == -1)
		{
			A[index--] = B[b--];
		}
		else if (b == -1)
		{
			A[index--] = A[a--];
		}
		else if (A[a] > B[b])
		{
			A[index--] = A[a--];
		}
		else if (A[a] == B[b])
		{
			A[index--] = A[a--];
			A[index--] = B[b--];
		}
		else
		{
			A[index--] = B[b--];
		}
	}	
}
```

## Plus One-临时插入 如果无效则删除
https://leetcode.com/problems/plus-one/
给定一个数组, [1, 2, 3]代表123 给这个数字+1 返回数组形式
```c++
Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
```

```c++
vector<int> plusOne(vector<int>& digits)
{
	// insert zero in case of like this [9]
	digits.insert(digits.begin(), 0);
		
	auto end = digits.end() - 1;
	
	*end += 1;
	while(*end == 10)
	{
		*end = 0;
		*(--end) += 1;
	}
	
	// if the zero is useless delete it
	if (digits[0] == 0)
	{
		digits.erase(digits.begin(), digits.begin() + 1);
	}
	return digits;
}
```

## 谨记无符号踩坑
https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

这个的代码就不贴出来了, 我也没有偷懒 没有!!!

这个主要是记录下 无符号值的使用

充实了我的CPP踩坑记的文章

## 数组排序降低复杂度 通过排序去重
三数之和
https://leetcode-cn.com/problems/3sum/

```c++
vector<vector<int>> threeSum(vector<int>& nums)
{
	vector<vector<int>> result;
	if (nums.size() <= 2)
	{
		return result;
	}
	sort(nums.begin(), nums.end());
	int i = 0;
	while (i < nums.size() - 2)
	{
		if (nums[i] > 0)
		{
			break;
		}
		int left = i + 1;
		int right = nums.size() - 1;
		int target = -nums[i];
		while (left < right)
		{
			int sum = nums[left] + nums[right];
			if (sum == target)
			{
				result.push_back({nums[i], nums[left], nums[right]});
				while ((left < right) && (nums[left] == nums[left + 1]))
				{
					left++;
				}
				while ((left < right) && (nums[right] == nums[right - 1]))
				{
					right--;
				}
				left++;
				right--;
			}
			else if (sum < target)
			{
				left++;
			}
			else
			{
				right--;
			}
		}
		while ((i < nums.size() - 2) && (nums[i] == nums[i + 1]))
		{
			i++;
		}
		i++;
	}
	return result;
}
```

## 数组排序降复杂度 单一结果保存应放在循环外
https://leetcode-cn.com/problems/3sum-closest/submissions/

这是我第一道自己做的 而且第一次提交就对的中等题目 QAQ
也是受了之前三数之和的启发
```c++
int threeSumClosest(vector<int>& nums, int target)
{
	if (nums.size() <= 2)
	{
		return 0;
	}
	sort(nums.begin(), nums.end());
	
	// 这两个保存结果用的 我最开始放在了for里面, 最后用
	// map自动按key排序选出最小的abs然后取出originsum
	// 结果应该是放在for外面就好 这个题目就这一个逻辑简单结果
	int absminsum = INT_MAX;
	int originsum = 0;
	for (int i = 0; i < nums.size() - 2; ++i)
	{
		int singel = nums[i];
		int left = i + 1;
		int right = nums.size() - 1;

		while (left < right)
		{
			int sum = singel + nums[left] + nums[right];
			int temp = sum - target;
			if (temp < 0)
			{
				if (-temp < absminsum)
				{
					absminsum = -temp;
					originsum = sum;
				}
				left++;
			}
			else if (temp == 0)
			{
				return sum;
			}
			else
			{
				if (temp <= absminsum)
				{
					absminsum = temp;
					originsum = sum;
				}
				right--;
			}
		}
		while ((i < nums.size() -3) && (nums[i + 1] == nums[i]))
		{
			i++;
		}
	}
	return originsum;
}
```


# string
## 反向迭代器
Given a string s consists of upper/lower-case alphabets and empty space characters ' ', 
return the length of last word (last word means the last appearing word if we loop from left to right) in the string.
If the last word does not exist, return 0.
```c++
Input: "Hello World"
Output: 5
```
...出了问题 这个题目刚才写的解析全没了...... 只能保存下改正完的答案了
赶紧下载了一个vscode来用用
```c++
int lengthOfLastWord(string s)
{
	int len = 0;
	int sub = s.length() - 1;
	while((sub >= 0) && (s[sub] == ' '))
	{
		sub--;
	}
	while (sub >= 0 && (s[sub] != ' '))
	{
		sub--;
		len++;
	}
	return len;
}
```

迭代器的使用
```c++
int lengthOfLastWord(string s)
{
	auto it = s.rbegin(), piv = s.rbegin();
	for(;it != s.rend() && *it == ' '; it++, piv = it);
	for(;it != s.rend() && *it != ' '; it++);
	return it - piv;
}
```
## atoi flag灵性的初始值, 优先级, -INT_MIN > INT_MAX
https://leetcode-cn.com/problems/string-to-integer-atoi/submissions/
```c++
int myAtoi(string str)
{
	char *begin = &str[0];
	char *end = &str[str.size()];
	while (*begin == ' ')
	{
		begin++;
	}
	if (begin == end)
	{
		return 0;
	}
	// 默认给1 很灵性 在*begin是+的时候少一次赋值 开头就是数字的情况不用在写一次else
	int flag = 1; 
	if (*begin == '-')
	{
		flag = -1;
		begin++;
	}
	else if (*begin == '+')
	{
		begin++;
	}
	int result = 0;
	while ((begin < end) && (*begin >= '0') && (*begin <= '9'))
	{
		if (result > INT_MAX / 10 || (result == INT_MAX / 10 && (*begin - '0') > INT_MAX % 10))
		{
			return INT_MAX;
		}
		if (result < INT_MIN / 10 || (result == INT_MIN / 10 && (*begin - '0') > -(INT_MIN % 10))) // 这里要有括号 -INT_MIN > INT_MAX
		{
			return INT_MIN;
		}
		// 每步都乘一次flag也不错, 方便判断INTMAX和INTMIN
		result = result * 10 + flag * (*begin - '0'); 
		begin++;
	}
	return result;
}
```
# 位运算

## a^a^b = b
Given a non-empty array of integers, every element appears twice except for one. Find that single one.
```c+
Input: [2,2,1]
Output: 1

Input: [4,1,2,1,2]
Output: 4
```

这个题目上来寻找单独的数字, 我直接就sort然后遍历一次, 找到单个的数字.
我以为这样就很快了, 结果看了下排名. 啪啪啪的打脸
```c++
int singleNumber(vector<int>& nums)
{
	if (nums.size() <= 2)
	{
		return nums[0];
	}
	sort(nums.begin(), nums.end());
	for (int i = 0; i < nums.size() - 2; i = i + 2)
	{
		if (nums[i] != nums[i + 1])
		{
			return nums[i];
		}
	}
	return nums[nums.size() - 1];
}
```

既然打败了40%的人, 就去看看更快的解法把. 首先我看到了就是这个
我只想说.... 位运算6666, 没想到异或可以这样用
`a^0 = a`  `a^a = 0` `a^a^b = b` 
```c++
int singleNumber(vector<int>& nums)
{
	int ret = 0;
	for (int n : nums)
	{
		ret ^= n;
	}
	return ret;
}
```

还有哈希表做法, 应该是利用的哈希表快速索引, 我也是才知道map范围for循环是pair不是iter auto不能用太多
```c++
int singleNumber(vector<int>& nums)
{
	unordered_map<int, int> map;
	for (int n : nums)
	{
		map[n]++;
	}
	
	for (pair<int, int> n : map)
	{
		if (n.second == 1)
		{
			return n.first;
		}
	}
	return -1;
}
```

# List
## 链表环判断双指针赛跑 单一体现key-set
https://leetcode.com/problems/linked-list-cycle/
https://leetcode.com/problems/linked-list-cycle-ii/


大意就是判断一个链表是否有环, 因为之前在那本小灰上看到过. 脑子中首先想的两个指针赛跑.

快的指针一次走两步, 慢的一次走一步. 快的终将会追上慢的, 如果碰到了nullptr就返回false
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head)
    {    
        if (head == nullptr)
        {
            return false;
        }
        
        ListNode *walk = head;
        ListNode *run = head;
        while (run->next != nullptr)
        {
            walk = walk->next;
            if (run->next->next != nullptr)
            {
                run = run->next->next;
            }
            else
            {
                return false;
            }
            if (walk == run)
            {
                return true;
            }
        }
        return false;
    }
};
```

修改了一下, 感觉下面的代码要好一些?

```c++
bool hasCycle(ListNode *head)
{    
	if ((head == nullptr) || (head->next == nullptr))
	{
		return false;
	}
	
	ListNode *walk = head;
	ListNode *run = head->next;
	while (walk != run)
	{
		if ((run == nullptr) || (run->next == nullptr))
		{
			return false;
		}
		
		walk = walk->next;
		run = run->next->next;
	}
	return true;
}
```

既然是要保证访问过的单一, 就是用set了

```c++
bool hasCycle(ListNode *head)
{ 
	set<ListNode*> hashset{};	
	while (head != nullptr)
	{
		if (hashset.count(head) != 0)
		{
			return true;
		}
		hashset.insert(head);
		
		head = head->next;
	}
	return false;
}
```

# stack
## 括号匹配 哈希表用作条件匹配
```c++
bool valid(char ca, char cb)
{
	if (ca == '(')
	{
		return cb == ')';
	}
	if (ca == '[')
	{
		return cb == ']';
	}
	if (ca == '{')
	{
		return cb == '}';
	}
	return false;
}

bool isValid(string s)
{
	if (s.empty())
	{
		return true;
	}
	if (s.size() % 2 != 0)
	{
		return false;
	}
	stack<char> brackets;
	for (int i = 0; i < s.size(); ++i)
	{
		char temp = '\0';
		// 在空容器上调用 back 导致未定义行为。
		if (brackets.size() > 0)
		{
			temp = brackets.top();
		}
		if (valid(temp, s[i]))
		{
			brackets.pop();
		}
		else
		{
			brackets.push(s[i]);
		}
	}
	return brackets.empty();
}
```
上面是我第一次提交的方法, 然而可以使用哈希表. 使代码看起来更简单些
下面使用哈希表扩展性更加好
```c++
bool isValid(string s)
{
	if (s.empty())
	{
		return true;
	}
	if (s.size() % 2 != 0)
	{
		return false;
	}
	unordered_map<char, int> bracket_map{{'(', 1}, {'[', 2}, {'{', 3}, 
	{')', 4}, {']', 5}, {'}', 6}};

	stack<int> brackets;
	for (int i = 0; i < s.size(); ++i)
	{
		int flag = bracket_map[s[i]];
		if (flag <= 3)
		{
			brackets.push(flag);
		}
		else if (!brackets.empty() && (flag - 3) == brackets.top())
		{
			brackets.pop();
		}
		else
		{
			brackets.push(flag);
		}
	}
	return brackets.empty();
}
```