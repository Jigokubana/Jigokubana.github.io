---
title: 力扣12.3-N1143.最长公共子序列
tags:
  - 动态规划
categories:
  - 力扣每日一题
date: 2020-12-3 16:25:02
---

# 最长公共子序列

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

 

示例 1:
```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。
```
示例 2:
```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。
```
示例 3:
```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。
```

提示:
```
1 <= text1.length <= 1000
1 <= text2.length <= 1000
输入的字符串只含有小写英文字符。
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-common-subsequence
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 代码1
```c++
    int longest(const std::string& text1, const std::string& text2, 
        int text1_sub, int text2_sub)
    {
        if (text1_sub >= text1.length() || text2_sub >= text2.length())
        {
            return 0;
        }
        if (text1[text1_sub] == text2[text2_sub])
        {
            return 1 + longest(text1, text2, text1_sub + 1, text2_sub + 1);
        }
        else
        {
            return max(longest(text1, text2, text1_sub + 1, text2_sub), 
                        longest(text1, text2, text1_sub, text2_sub + 1));
        }
    }

    int longestCommonSubsequence(string text1, string text2)
    {
        return longest(text1, text2, 0, 0);
    }
```

最简单的思路 然而会超时

## 代码2 动态规划

```c++
int longestCommonSubsequence(string text1, string text2)
    {
        int result[1005][1005]{};

        for (int i1 = 0; i1 < text1.length(); ++i1)
        {
            for (int i2 = 0; i2 < text2.length(); ++i2)
            {
                if (text1[i1] == text2[i2])
                {
                    result[i1 + 1][i2 + 1] = result[i1][i2] + 1;
                }
                else
                {
                    result[i1 + 1][i2 + 1] = max(result[i1][i2 + 1], result[i1 + 1][i2]);
                }
            }
        }
        return result[text1.length()][text2.length()];
    }
```

设text1和text2的解是T

- 如果text1和text2的最后两个字符相等, 则T的最后一个字符也是这个字符

这样 text1和text2分别去掉最后一个字符后, T去掉最后一个字符后的T1 是前面两个新字符串的最长公共子序列

- 如果最后两个字符不同, 则T可能是text1去掉最后一个字符后和text2的最长公共子序列 也可能是text2去掉最后一个字符后和text1的最长公共子序列

这个可以循环下去, 直到最后两个字符相等 转入上方过程


由于存在多种可能便需要设置result数组存储中间结果`result[i][j]`是text1前i个字符和text2前j个字符的最长公共子序列长度

数组填充方式 为上方描述的逆过程. 

- 如果i1 i2所指字符相同 `result[i][j]`结果是`result[i - 1][j - 1] + 1`
表示的是text1前i-1字符和text2前j-1字符最长公共子序列 加上 这个相同的字符 得到前i和前j的最长公共子序列

- 如果所指字符不同则`result[i][j]`可能是`result[i][j - 1]` 也可能是`result[i][j - 1]`取最大值
表示的是前ij的最长公共子序列是 text1前i字符和text2前j-1字符最长公共子序列 或者是 前i-1和前j的最长公共子序列

最终得到结果`result[text1.length()][text2.length()]` 表示前length1和前length2的最长公共子序列