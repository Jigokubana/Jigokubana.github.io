---
title: 联机打砖块
date: 2020-02-17 22:49:56
tags:
  - 小游戏

categories:
  - 小游戏
---
这篇博客写的有点晚了, 自己的打砖块 已经写了一个段落了. 不过问题不大.

重要的部分还在后面, 目前还没写到

# 前言
因为自己发现需要多做一些项目, 然后逐渐的丰富这些项目 来学习. 希望不断地提升自己, 让自己离鹅厂越来越近. 同时写博客能够让我了解得更深刻

在看到知乎`日撸代码100行`的一篇推荐博客

[UE4的C++教程汇总 - 日撸代码100行的文章 - 知乎](https://zhuanlan.zhihu.com/p/92422059)
找到了那个油管的游戏制作.

[这个连接-Unreal Engine 4 Tutorials](https://www.youtube.com/playlist?list=PLZhNP5qJ2IA0KK3ddSl2JWEL8jOcGe6xY)
选择了一个游戏-打砖块

那个小游戏还是很简单的 也学到了不少的东西. 不过我想了想 我既然是做游戏服务器, 我为什么不把打砖块修改成联机版打砖块??   不对!!!!我想把那个博主发布的我喜欢的游戏都改成联机版. 然后慢慢丰富游戏前端和后端的功能, 想到这里 我晚上失眠了.... 越想越兴奋.

自己的话 注意下代码复用. 尤其是后端的代码. 每次把经常用的代码块抽出来 然后总结出一个自己的框架?库?

# 联机的实现
```c++
// a.h
UFUNCTION(BlueprintCallable, Category = "TCP Network")
bool CreateSocket(const FString IPStr, int32 Port);

UFUNCTION(BlueprintCallable, Category = "TCP Network")
bool SendMessage(FString Msg);

UFUNCTION(BlueprintCallable, Category = "TCP Network")
FString RecvMessage();

FString StringFromUint8Array(TArray<uint8> Array);

FIPv4Address Ip;

FSocket* ClientFd;

// a.cpp
bool ANetActor::CreateSocket(const FString IPStr, int32 Port)
{
	// 将字符串ip转换为点分十进制ip
	FIPv4Address::Parse(IPStr, Ip);

	// 将十进制ip 转化成网络地址
	TSharedPtr<FInternetAddr> addr = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateInternetAddr();
	addr->SetIp(Ip.Value);
	addr->SetPort(Port);

	// 创建TCP Socket 文件描述符
	ClientFd = ISocketSubsystem::Get(PLATFORM_SOCKETSUBSYSTEM)->CreateSocket(NAME_Stream, TEXT("TCP SOCKET"), false);

	
	if (ClientFd->Connect(*addr))
	{
		// 连接成功
		UE_LOG(LogTemp, Warning, TEXT("Connect success!"));
		return true;
	}
	else
	{
		// 连接失败
		UE_LOG(LogTemp, Warning, TEXT("Connect failed!"));
		return false;
	}
}

bool ANetActor::SendMessage(FString Msg)
{
	//后面直接传送json数据
	TCHAR* SeriallizedMsg = Msg.GetCharArray().GetData();
	int32 MsgSize = FCString::Strlen(SeriallizedMsg);
	int32 Send = 0;

	if (ClientFd->Send((uint8*)TCHAR_TO_UTF8(SeriallizedMsg), MsgSize, Send))
	{
		UE_LOG(LogTemp, Log, TEXT("MsgSend-Success->%s"), *Msg);
		return true;
	}
	else
	{
		UE_LOG(LogTemp, Log, TEXT("MsgSend-Failed->%s"), *Msg);
		return false;
	}
}

FString ANetActor::RecvMessage()
{
	if (!ClientFd)
	{
		return "";
	}

	TArray<uint8> RecvData;
	uint32 Size;
	uint32 Element = 0;

	while (ClientFd->HasPendingData(Size))
	{
		RecvData.Init(Element, FMath::Min(Size, 65507u)); // 65535 - 20 Ip头 - 8 Tcp头
		int32 Read = 0;
		ClientFd->Recv(RecvData.GetData(), RecvData.Num(), Read);
	}

	if (RecvData.Num() <= 0)
	{
		return "";
	}

	const FString RecvJsonString = StringFromUint8Array(RecvData);
	UE_LOG(LogTemp, Log, TEXT("MsgRecv-Success->%s"), *RecvJsonString);

	return RecvJsonString;
}
```
蓝图连接
![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%B0%8F%E6%B8%B8%E6%88%8F/%E6%89%93%E7%A0%96%E5%9D%97/socket%E8%93%9D%E5%9B%BE.png)

这样就能连接到TCP的后台了