---
title: 力扣11.25-N34.在排序数组中查找元素的第一个和最后一个位置
tags:
  - 递归分治
categories:
  - 算法
  - 力扣每日一题
date: 2020-11-25 18:50:02
---

# N34.在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 [-1, -1]。

示例 1:
```
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
```
示例 2:
```
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]
```
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 代码1
```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target)
    {
        int left = 0;
        int right = nums.size();

        while (left < right)
        {
            int sub = (right + left) >> 1;
            if (target == nums[sub])
            {
                int l_sub, r_sub;
                for (l_sub = sub - 1; l_sub >=0 && nums[l_sub] == target; --l_sub)
                {
                   
                }
                for (r_sub = sub + 1; r_sub <= nums.size() - 1 && nums[r_sub] == target; ++r_sub)
                {
                    
                }
                return {l_sub + 1, r_sub - 1};
            }
            else if (target < nums[sub])
            {
                right = sub;
            }
            else
            {
                left = sub + 1;
            }
        }

        return {-1, -1};
    }
};
```

思路使用二分搜索找到目标元素 然后想左右扩散寻找边界

# 剑指 Offer 53 - I. 在排序数组中查找数字 I

统计一个数字在排序数组中出现的次数。

 

示例 1:
```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```
示例 2:
```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 代码1

```c++
class Solution {
public:
    int search(vector<int>& nums, int target)
    {
        int left = 0;
        int right = nums.size();

        while (left < right)
        {
            int sub = (right + left) >> 1;
            if (target == nums[sub])
            {
                int result = 1;
                for (int l_sub = sub - 1; l_sub >=0 && nums[l_sub] == target; --l_sub)
                {
                    ++result;
                }
                for (int r_sub = sub + 1; r_sub <= nums.size() - 1 && nums[r_sub] == target; ++r_sub)
                {
                    ++result;
                }
                return result;
            }
            else if (target < nums[sub])
            {
                right = sub;
            }
            else
            {
                left = sub + 1;
            }
        }

        return 0;
    }
};
```

思路同上, 返回值不同