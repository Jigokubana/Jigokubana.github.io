---
title: LeetCode简单算法
date: 2020-03-03 10:38:28
tags:
categories:
 - 算法
 - 简单算法
top: 90
---
由于国内LeetCode解题时间有点微妙, 基本题目只在英文版做

为了压缩长度. 所有空行都删掉了
# unordered_map

## Two Sum-哈希表建立快速索引, 一遍和两遍哈希的使用
https://leetcode.com/problems/two-sum
题目很简单
```
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```
不是最差... 也差不多了 最简单粗暴的形式 O(n2) O(1)
```c++
vector<int> twoSum(vector<int>& nums, int target)
{
	for (int i = 0; i < nums.size(); ++i)
	{
		// 答案肯定是一个小数和一个大数 相加, 直接往后找 测试用例应该是排好序的
		for (int j = i + 1; j < nums.size(); ++j)
		{
			if (nums[i] + nums[j] == target)
			{
				return vector<int>{i, j};
			}
		}
	}
	return vector<int>{0, 1};
}
```
两遍哈希 由于需要更快的找到 vector中某个元素的下标, 非常适合哈希表来做
先放入哈希表中, 再寻找自己所需要的值是否存在以及下标 O(n) O(n)
```c++
vector<int> twoSum(vector<int>& nums, int target)
{
	unordered_map<int, int> the_map;
	for (int i = 0; i < nums.size(); ++i)
	{
		the_map.insert({nums[i], i});
	}
	
	for (int i = 0; i < nums.size(); ++i)
	{
		auto search = the_map.find(target - nums[i]);
		// unordered_map<int, int>::iterator search = the_map.find(target - nums[i]);
		
		if (search != the_map.end())
		{
			if (search->second == i)
			{
				continue;
			}
			return vector<int>{i, search->second};
		}
	}
	return vector<int>{0, 0};
}
```
一遍哈希, 既然是要在表中查找到需要数 还需要判断是否同一个数
干脆直接在插入前就进行查找
```c++
vector<int> twoSum(vector<int>& nums, int target)
{
	unordered_map<int, int> the_map;
	for (int i = 0; i < nums.size(); ++i)
	{
		auto search = the_map.find(target - nums[i]);
		if (search != the_map.end())
		{
			return vector<int>{i, search->second};
		}
		the_map.insert({nums[i], i});
	}
	return vector<int>{0, 0};
}
```

# Vector

## 合并排序的数组-双指针操作 拷贝到临时数组和直接写到原数组
https://leetcode-cn.com/problems/sorted-merge-lcci/
给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。
初始化 A 和 B 的元素数量分别为 m 和 n。
```c++
输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```
第一次太惨了, 看来我算法需要加倍的联系啊. 先不说考虑很久
```c++
void merge(vector<int>& A, int m, vector<int>& B, int n)
{
	if (n == 0)
	{
		return;
	}
	int temp = 0;
	// 这里的 m + n就有点问题, 后面会空转 改为m + temp合适
	for (int i = 0; i < m + n; ++i)
	{
		if (A.at(i) < B.at(temp))
		{
			continue;
		}
		A.insert(A.begin() + i, B.at(temp++));
		if (temp == n)
		{
			break;
		}
	
	if (temp < n)
	{
		A.insert(A.begin() + m + temp, B.begin() + temp, B.end());
	}
	A.erase(A.begin() + n + m, A.end());
}
```
使用插入再删除, 本身这个方法就不是很好. 后来看题解有双指针, 就去试了下. 这样需要额外的空间
如果直接正序的修改A的值, 可能会导致A的值被覆盖掉.
那么倒序呢? 倒序放上最大的值 就不会覆盖掉A中未读取的值了 继续修改
```c++
void merge(vector<int>& A, int m, vector<int>& B, int n)
{
	int sorted[m + n];
	auto a = A.begin();
	auto b = B.begin();
	int index = 0;
	while (index != m + n)
	{
		if (a - A.begin() == m)
		{
			sorted[index++] = *b++;
		}
		else if (b - B.begin() == n)
		{
			sorted[index++] = *a++;
		}
		else if (*a < *b)
		{
			sorted[index++] = *a++;
		}
		else if (*a == *b)
		{
			sorted[index++] = *a++;
			sorted[index++] = *b++;
		}
		else
		{
			sorted[index++] = *b++;
		}
	}
	for (int i = 0; i < m + n; ++i)
	{
		A[i] = sorted[i];
	}
	
}
```
改正后的代码如下
```c++
void merge(vector<int>& A, int m, vector<int>& B, int n)
{
	int index = m + n - 1;
	int a = m - 1;
	int b = n - 1;
	while (index >= 0)
	{
		if (a == -1)
		{
			A[index--] = B[b--];
		}
		else if (b == -1)
		{
			A[index--] = A[a--];
		}
		else if (A[a] > B[b])
		{
			A[index--] = A[a--];
		}
		else if (A[a] == B[b])
		{
			A[index--] = A[a--];
			A[index--] = B[b--];
		}
		else
		{
			A[index--] = B[b--];
		}
	}	
}
```

## Plus One-临时插入 如果无效则删除
https://leetcode.com/problems/plus-one/
给定一个数组, [1, 2, 3]代表123 给这个数字+1 返回数组形式
```c++
Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
```

```c++
vector<int> plusOne(vector<int>& digits)
{
	// insert zero in case of like this [9]
	digits.insert(digits.begin(), 0);
		
	auto end = digits.end() - 1;
	
	*end += 1;
	while(*end == 10)
	{
		*end = 0;
		*(--end) += 1;
	}
	
	// if the zero is useless delete it
	if (digits[0] == 0)
	{
		digits.erase(digits.begin(), digits.begin() + 1);
	}
	return digits;
}
```

## Best Time to Buy and Sell Stock
https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

这个的代码就不贴出来了, 我也没有偷懒 没有!!!

这个主要是记录下 无符号值的使用

充实了我的CPP踩坑记的文章

# string
## Length of Last Word-反向迭代器
Given a string s consists of upper/lower-case alphabets and empty space characters ' ', 
return the length of last word (last word means the last appearing word if we loop from left to right) in the string.
If the last word does not exist, return 0.
```c++
Input: "Hello World"
Output: 5
```
...出了问题 这个题目刚才写的解析全没了...... 只能保存下改正完的答案了
赶紧下载了一个vscode来用用
```c++
int lengthOfLastWord(string s)
{
	int len = 0;
	int sub = s.length() - 1;
	while((sub >= 0) && (s[sub] == ' '))
	{
		sub--;
	}
	while (sub >= 0 && (s[sub] != ' '))
	{
		sub--;
		len++;
	}
	return len;
}
```

迭代器的使用
```c++
int lengthOfLastWord(string s)
{
	auto it = s.rbegin(), piv = s.rbegin();
	for(;it != s.rend() && *it == ' '; it++, piv = it);
	for(;it != s.rend() && *it != ' '; it++);
	return it - piv;
}
```

# 位运算

## Single Number- a^a^b = b
Given a non-empty array of integers, every element appears twice except for one. Find that single one.
```c+
Input: [2,2,1]
Output: 1

Input: [4,1,2,1,2]
Output: 4
```

这个题目上来寻找单独的数字, 我直接就sort然后遍历一次, 找到单个的数字.
我以为这样就很快了, 结果看了下排名. 啪啪啪的打脸
```c++
int singleNumber(vector<int>& nums)
{
	if (nums.size() <= 2)
	{
		return nums[0];
	}
	sort(nums.begin(), nums.end());
	for (int i = 0; i < nums.size() - 2; i = i + 2)
	{
		if (nums[i] != nums[i + 1])
		{
			return nums[i];
		}
	}
	return nums[nums.size() - 1];
}
```

既然打败了40%的人, 就去看看更快的解法把. 首先我看到了就是这个
我只想说.... 位运算6666, 没想到异或可以这样用
`a^0 = a`  `a^a = 0` `a^a^b = b` 
```c++
int singleNumber(vector<int>& nums)
{
	int ret = 0;
	for (int n : nums)
	{
		ret ^= n;
	}
	return ret;
}
```

还有哈希表做法, 应该是利用的哈希表快速索引, 我也是才知道map范围for循环是pair不是iter auto不能用太多
```c++
int singleNumber(vector<int>& nums)
{
	unordered_map<int, int> map;
	for (int n : nums)
	{
		map[n]++;
	}
	
	for (pair<int, int> n : map)
	{
		if (n.second == 1)
		{
			return n.first;
		}
	}
	return -1;
}
```