---
title: LeetCode中等算法
date: 2020-03-03 10:38:28
tags:
categories:
 - 算法
 - 中等算法
top: 91
---
# Jump Game-动态规划 贪婪
https://leetcode.com/problems/jump-game/

Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Determine if you are able to reach the last index.
```c++
Example 1:
Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.

Example 2:
Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.
```
这是我LeetCode第一道中等难度算法, 刚上来不知道怎么做. 然后瞟了一眼题解说是动态规划问题.我就去查了下动态规划的问题解法

[什么是动态规划（Dynamic Programming）？动态规划的意义是什么？ - 阮行止的回答 - 知乎](https://www.zhihu.com/question/23995189/answer/613096905)

**贪心**
这样算是有了个初步了解, 不过我上来先用了贪心... 因为简单一些, 动态规划暂时没有想到怎么解.
结果运行时间超过 11%的人好吧 最坏的时间复杂度应该是O(n!)... 最优O(n)
```c++
bool canJump(vector<int>& nums)
{
    int sum_step = nums.size();
    int now_sub = sum_step - 1;
    int min_sub = now_sub;
    
    bool jumpout = true;
    
    while (true)
    {
        for (int i = now_sub - 1; i >= 0; --i)
        {
            if (nums[i] >= (now_sub - i))
            {
                min_sub = i;
                jumpout = false;
            }
        }
        now_sub = min_sub;
        if (jumpout)
        {
            return now_sub == 0;
        }
        jumpout = true;
    }
}
```
我看了下题解的贪婪算法... 我的应该也是贪婪的一种. 不过题解的贪婪更加快.
我的想法是从顶开始 每次遍历找到`最低的能跳过来的一层` 然后再从`最低的能跳过来的一层`遍历.直到到不能再跳就返回当前是不是底层

题解的解法粗略看就是差在了第一个if的判断条件, 我判断的当前的层, 题解判断的`最低的能跳过来的一层`题解的解法是`能跳则跳` 我的解法是`跳最少的次数` 实际上针对此题`能跳则跳`就好
```c++
bool canJump(vector<int>& nums)
{
    int now_sub = nums.size() - 1;
    int min_sub = now_sub;
    for (int i = now_sub - 1; i >= 0; --i)
    {
        if (nums[i] + i >= min_sub)
        {
            min_sub = i;    
        }
    }  
    return min_sub == 0;
}
```
然后我猜测绝对有一道题输出最少的跳跃次数, 没想到真有. 结果试了下时间超限.....
理论上我第一种解法能够完成emmm, 不过先不管那道题目了.

**递归回溯**
```c++
bool canJumpFromPosition(int position, vector<int> &nums)
{
    if (position == nums.size() - 1)
    {
        return true;
    }
    
    int max_position = min(position + nums[position], (int)nums.size() - 1);
    // for (int i = max_position; i > position; --i)
    for (int i = position + 1; i <= max_position; ++i)
    {
        if (canJumpFromPosition(i, nums))
        {
            return true;
        }
    }
    
    return false;
}

bool canJump(vector<int>& nums)
{
    return canJumpFromPosition(0, nums);
}
```
上面这种方法思考起来简单些, 你只要知道递归的条件是什么

递归到什么时候返回值来回溯

这个题目, 你只要在当前位置不断跳到所有能去的位置, 然后递归下去. 直到你的位置到了尾部就返回true, 或者你不能再跳返回false. 自然时间超限了

上面的解法, 还有优化的空间. 因为这个是从左到右依次进行, 然而实际上从越远的地方进行更容易到达尾部. 所以可以修改for的判断条件在图中注释部分

**动态规划 自上而下**
```c++
enum Index {UNKNOW, GOOD, BAD};
Index *memo;

bool canJumpFromPosition(int position, vector<int> &nums)
{
    if (memo[position] != UNKNOW)
    {
        return memo[position] == GOOD;
    }
    
    int max_position = min(position + nums[position], (int)nums.size() - 1);
    for (int i = max_position; i > position; --i)
    {
        if (canJumpFromPosition(i, nums))
        {
            memo[position] = GOOD;
            return true;
        }
    }
    
    memo[position] = BAD;
    return false;
}

bool canJump(vector<int>& nums)
{
    memo = new Index[nums.size()]{};
    memo[nums.size() - 1] = GOOD;
    return canJumpFromPosition(0, nums);
}
```
之前的方法中, 仔细想想就会发现 会有很多的下标被多次调用, 尽管那个下标是无法到达结尾的. 怎么解决呢? 当然是保存状态了, 每次递归结束后就标记当前的下标能不能到达. 之后遇到被标记的下标就能直接返回

然而现在的时间复杂度依然高达 O(n^2)

**自下而上的动态规划**

通过消除递归的方式, 消除递归的一个好方法就是颠倒顺序. 上面那是从左到右向右跳, 这次我们从右向左向右跳, 就能更容易的知道知道某个下标是`GOOD`还是`BAD`了, 因为离最右端更近了.

时间复杂度依然是O(n^2)
```c++
enum Index {UNKNOW, GOOD, BAD};
Index *memo;

bool canJump(vector<int>& nums)
{
    memo = new Index[nums.size()]{};
    memo[nums.size() - 1] = GOOD;
    
    for (int i = nums.size() - 2; i >= 0; --i)
    {
        int furthest_jump = min(nums[i] + i, (int)nums.size() - 1);
        for (int j = i + 1; j <= furthest_jump; ++j)
        {
            if (memo[j] == GOOD)
            {
                memo[i] = GOOD;
                break;
            }
        }
    }
    return memo[0] == GOOD;
}
```