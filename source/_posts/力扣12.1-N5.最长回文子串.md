---
title: 力扣12.1-N5.最长回文子串
tags:
  - 中心扩散
categories:
  - 算法
  - 力扣每日一题
date: 2020-12-1 16:25:02
---
# 最长回文子串

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：
```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```
示例 2：
```
输入: "cbbd"
输出: "bb"
```
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-palindromic-substring
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 代码1 - 中心扩散法

```c++
class Solution {
public:
    string longestPalindrome(string s)
    {
        /* 开头老套路 先处理了最简单的输入*/
        if (s.length() <= 1)
        {
            return s;
        }

        /* 记录最大长度*/
        int max_len = 0;

        /* 记录最大长度子串的开始下标 用于return时的substr 解决拷贝问题*/
        int result_begin_sub = 0;
        int i = 0;
        while (i < s.length())
        {
            int l_begin = i, r_begin = i;
            
            /* 从当前下标开始 找到最长的相同字符子串*/
            /* lbegin指向此子串的开始字符 rbegin指向结尾字符*/
            while (r_begin < s.length() - 1 && s[r_begin + 1] == s[i])
            {
                r_begin++;
            }
            /* 更新下标 减少循环次数*/
            i = r_begin + 1;

            /* 向左右两侧遍历 相同字符则 向左移动lbegin 向右移动rbegin*/
            do
            {
                l_begin--;
                r_begin++;
            }
            while (l_begin >=0 && r_begin < s.length() && s[l_begin] == s[r_begin]);
            
            /* 更新最大长度*/
            int len = r_begin - l_begin - 1;
            if (len > max_len)
            {
                max_len = len;
                result_begin_sub = l_begin + 1;
            }
        }

        return s.substr(result_begin_sub, max_len);
    }
};
```

遍历字符串 从当前循环开始下标找到最长的相同字符子串 如a 或 bb 或 ccc

然后向左右两侧遍历 如果左右字符相同 继续遍历 最终得到两个下标

左下标指向当前最大回文子串的左边一个字符 右下标指向右边一个字符

这样就得到了子串的开始下标和长度 更新最大长度 继续遍历