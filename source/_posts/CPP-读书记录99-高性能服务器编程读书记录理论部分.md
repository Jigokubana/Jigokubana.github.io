---
title: Linux高性能服务器-理论部分
tags:
  - null
categories:
  - CPP
  - 服务器编程-书籍记录
date: 2020-03-06 22:53:00
top: 99
img: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg
---
距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.
半年后开始准备补上这四章

2020年7月16日12:37:33

大二暑假了, 准备把这本书没读完的部分 读完 整理下已读的部分
基础理论部分, 由于已经上完了计算机网络这门课, 另出了一篇博客. 这里就不详细写了
主要整理后面的内容分




# 第一章 TCP/IP协议族
## TCP/IP协议族体系结构和主要协议
协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接

![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg)

不同层次之间, 通过接口互相交流, 这样方便了各层次的修改

**应用层**
负责处理应用程序的逻辑

**表示层**
定义了数据的格式及加密

**会话层**
它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的

**传输层**
为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.
此层存在两大协议TCP协议和UDP协议
TCP协议(Transmission Control Protocol 传输控制协议)
- 为应用层提供`可靠的, 面向连接, 基于流的服务`
- 通过`超时重传`和`数据确认`等确保数据正常送达.
- TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器
```
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```


UPD协议(User Datagram Protocol 用户数据报协议)
- 为应用层提供`不可靠的, 无连接的, 基于数据报的服务`
- 一般需要自己处理`数据确认`和`超时重传`的问题
- 通信两者不存储状态, 每次发送都需要指定地址信息. `有自己的长度`
```
 0      7 8     15 16    23 24    31
+--------+--------+--------+--------+
|     Source      |   Destination   |
|      Port       |      Port       |
+--------+--------+--------+--------+
|                 |                 |
|     Length      |    Checksum     |
+--------+--------+--------+--------+
|
|          data octets ...
+---------------- ...

    User Datagram Header Format
```



**网络层**
实现了数据包的选路和转发.  只有数据包到不了目标地址, 就`下一跳`(hop by hop), 选择最近的.
*IP协议(Internet Protocol)* 以及 *ICMP协议(Internet Control Message Protocol)* 
后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)

**数据链路层**
实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.
存在两个协议 *ARP协议(Address Resolve Protocol, 地址解析协议)*. 还有*RARP(Reverse ~, 逆地址解析协议)*.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议*ARP欺骗, 可能与这个有关, 目前不去学习*

**封装**
上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.
被TCP封装的数据成为 `TCP报文段`
- 内核部分发送成功后删除数据

被UDP封装的数据成为 `UDP数据报`
- 发送后即删除

再经IP封装后成为`IP数据报`
最后经过数据链路层封装后为 `帧`

以太网最大数据帧1518字节 抛去14头部 帧尾4校验
MTU: 帧的最大传输单元 一般为1500字节
MSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头 - 20TCP头 还有额外的40字节可选部分

**ARP**
ARP协议能实现任意网络层地址到任意物理地址的转换

# 第二章 IP协议详解
IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一
IP协议为上层协议提供无状态, 无连接, 不可靠的服务

IP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制

当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装

![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png)


路由机制


![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png)


给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤
- 查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步
- 查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到....... 否则下一步
- 选择默认路由项, 通常意味着下一跳路由是网关


# 第三章 TCP协议详解

Tcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.

UDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断

ISN-初始序号值
32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移
32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答

ACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为`确认报文段`
PSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间
RST标志: 要求对方重新建立连接 携带......`复位报文段`
SYN标志: 标志请求建立一个连接 携带......`同步报文段`
FIN标志: 通知对方本端连接要关闭了, 携带..`结束报文段`

16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据
16位校验和: `可靠传输的重要保障`发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验`TCP头部`和`数据部分`

额外参数之窗口扩大因子, TCP连接初始化时, 双方使用该选项协商通告窗口的扩大因子. 
通告窗口大小是16位即最大65535字节, 但实际会比这个要大
假设通告窗口大小为N, 扩大因子是M(位移数, 0-14) 实际通告窗口大小为 N*2^M, 或者称为N左移M位


**TCP连接的建立和关闭**

```s
# 同步报文段 需要占用一个序号值

10:19:15.870206 IP localhost.46836 > localhost.8222: Flags [S], seq 559157932, win 43690, options [mss 65495,sackOK,TS val 2968784041 ecr 0,nop,wscale 7], length 0
10:19:15.870219 IP localhost.8222 > localhost.46836: Flags [S.], seq 900113542, ack 559157933, win 43690, options [mss 65495,sackOK,TS val 2968784041 ecr 2968784041,nop,wscale 7], length 0
10:19:15.870228 IP localhost.46836 > localhost.8222: Flags [.], ack 1, win 342, options [nop,nop,TS val 2968784041 ecr 2968784041], length 0

10:19:18.113588 IP localhost.46836 > localhost.8222: Flags [F.], seq 1, ack 1, win 342, options [nop,nop,TS val 2968786284 ecr 2968784041], length 0
# 由于被动方没有数据要发送同时发送了 FIN ACK 
10:19:18.113664 IP localhost.8222 > localhost.46836: Flags [F.], seq 1, ack 2, win 342, options [nop,nop,TS val 2968786284 ecr 2968786284], length 0
10:19:18.113678 IP localhost.46836 > localhost.8222: Flags [.], ack 2, win 342, options [nop,nop,TS val 2968786284 ecr 2968786284], length 0


# 完整序号
10:31:15.259169 IP localhost.46944 > localhost.8222: Flags [S], seq 898081536, win 43690, options [mss 65495,sackOK,TS val 2969503401 ecr 0,nop,wscale 7], length 0
10:31:15.259180 IP localhost.8222 > localhost.46944: Flags [S.], seq 3168567292, ack 898081537, win 43690, options [mss 65495,sackOK,TS val 2969503401 ecr 2969503401,nop,wscale 7], length 0
10:31:15.259190 IP localhost.46944 > localhost.8222: Flags [.], ack 3168567293, win 342, options [nop,nop,TS val 2969503401 ecr 2969503401], length 0

10:31:17.144633 IP localhost.46944 > localhost.8222: Flags [F.], seq 898081537, ack 3168567293, win 342, options [nop,nop,TS val 2969505287 ecr 2969503401], length 0
10:31:17.144800 IP localhost.8222 > localhost.46944: Flags [F.], seq 3168567293, ack 898081538, win 342, options [nop,nop,TS val 2969505287 ecr 2969505287], length 0
10:31:17.144814 IP localhost.46944 > localhost.8222: Flags [.], ack 3168567294, win 342, options [nop,nop,TS val 2969505287 ecr 2969505287], length 0

```

**TCP超时重传**
TCP服务必须能够进行超时重传
这就需要为每个TCP报文段维护一个重传定时器, 发送时启动
如果超时后依然没有收到回复则进行重发 并重置定时器

超时时间 0.2 0.4 0.8 1.6 3.2 单位是秒, 类似TCP超时重连
重传最多次数 默认15

**拥塞控制**
提高网络利用率, 降低丢包率 保证网络资源对每条数据流的公平性 --拥塞控制

# 第四章TCP/IP通信案例

上游服务器: 一个HTTP请求可能被多个代理服务器转发, 后面的服务器称为前面的服务器的上游服务器

正向代理服务器: 要求客户端自己设置代理服务器的地址, 客户将每次请求都直接发送到该代理服务器,并由代理服务器来请求目标资源
反向代理服务器: 被设置在服务器端, 客户端无需进行设置. 用代理服务器接收网络上的请求, 然后将请求转发给内网上的服务器, 并将从内部服务器上得到的结果返回给客户端, 代理服务器对外表现为一个真正的服务器.
