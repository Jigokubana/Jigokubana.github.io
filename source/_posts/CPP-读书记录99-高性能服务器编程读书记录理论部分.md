---
title: Linux高性能服务器-理论部分
tags:
  - null
categories:
  - CPP
  - 服务器编程-书籍记录
date: 2020-03-06 22:53:00
top: 99
img: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E5%8D%9A%E5%AE%A2%E5%B0%81%E9%9D%A2/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B.jpg
---
距离我开始读这本书已经过去了半年了, 真是时光飞逝. 当初跳过了前四章.
半年后开始准备补上这四章

# 第一章 TCP/IP协议族
## TCP/IP协议族体系结构和主要协议
协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接

![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg)

![](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=3a1768f4c6fc1e17e9b284632bf99d66/0dd7912397dda144d48ab350bbb7d0a20df48655.jpg)

同样七层是osi参考模型, 简化后得到四层
不同层次之间, 通过接口互相交流, 这样方便了各层次的修改

**应用层**
负责处理应用程序的逻辑

**表示层**
定义了数据的格式及加密

**会话层**
它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的

**传输层**
为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.
此层存在两大协议TCP协议和UDP协议
TCP协议(Transmission Control Protocol 传输控制协议)
- 为应用层提供`可靠的, 面向连接, 基于流的服务`
- 通过`超时重传`和`数据确认`等确保数据正常送达.
- TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器
UPD协议(User Datagram Protocol 用户数据报协议)
- 为应用层提供`不可靠的, 无连接的, 基于数据报的服务`
- 一般需要自己处理`数据确认`和`超时重传`的问题
- 通信两者不存储状态, 每次发送都需要指定地址信息. `有自己的长度`

**网络层**
实现了数据包的选路和转发.  只有数据包到不了目标地址, 就`下一跳`(hop by hop), 选择最近的.
*IP协议(Internet Protocol)* 以及 *ICMP协议(Internet Control Message Protocol)* 
后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)

**数据链路层**
实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.
存在两个协议 *ARP协议(Address Resolve Protocol, 地址解析协议)*. 还有*RARP(Reverse ~, 逆地址解析协议)*.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议*ARP欺骗, 可能与这个有关, 目前不去学习*

**封装**
上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.
被TCP封装的数据成为 `TCP报文段`
- 内核部分发送成功后删除数据

被UDP封装的数据成为 `UDP数据报`
- 发送后即删除

再经IP封装后成为`IP数据报`
最后经过数据链路层封装后为 `帧`

以太网最大数据帧1518字节 抛去14头部 帧尾4校验
MTU: 帧的最大传输单元 一般为1500字节
MSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头-20TCP头 还有额外的40字节可选部分

**ARP**
ARP协议能实现任意网络层地址到任意物理地址的转换

# 第二章 IP协议详解
IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一
IP协议为上层协议提供无状态, 无连接, 不可靠的服务

IP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制

当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装

![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png)


路由机制


![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png)


给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤
- 查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步
- 查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到....... 否则下一步
- 选择默认路由项, 通常意味着下一跳路由是网关


# 第三章 TCP协议详解

Tcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.

UDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断

ISN-初始序号值
32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移
32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答???(可以顺带发送?)

ACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为`确认报文段`
PSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间
RST标志: 要求对方重新建立连接 携带......`复位报文段`
SYN标志: 标志请求建立一个连接 携带......`同步报文段`
FIN标志: 通知对方本端连接要关闭了, 携带..`结束报文段`

16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据
16位校验和: `可靠传输的重要保障`发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验`TCP头部`和`数据部分`


**TCP连接的建立和关闭**

```s
# 三次握手
# 客户端发送请求连接 ISN=seq + 0 = 3683340920
# mss 最大数据载量1460
IP 192.168.80.1.7467 > ubuntu.8000: 
Flags [S], seq 3683340920, win 64240, 
options [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0

# 同意客户端连接
# ack = 客户端发送 seq + 1
# 同时发送服务端的seq
IP ubuntu.8000 > 192.168.80.1.7467: 
Flags [S.], seq 938535101, ack 3683340921, win 64240, 
options [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0

# 虽然这个报文段没有字节 但由于是同步报文段 需要占用一个序号值
# 这里是tcpdump的处理 ack显示相对值 即 3683340921 - 3683340920 = 1
IP 192.168.80.1.7467 > ubuntu.8000: 
Flags [.], ack 1, win 4106, length 0


# 包含FIN标志 说明要求结束连接 也需要占用一个序号值
IP 192.168.80.1.7467 > ubuntu.8000: 
Flags [F.], seq 1, ack 1, win 4106, length 0

# 服务端确认关闭连接
IP ubuntu.8000 > 192.168.80.1.7467: 
Flags [.], ack 2, win 502, length 0

# 服务端发送关闭连接
IP ubuntu.8000 > 192.168.80.1.7467: 
Flags [F.], seq 1, ack 2, win 4105, length 0

# 客户端确认
IP 192.168.80.1.7467 > ubuntu.8000: 
Flags [.], ack 2, win 503, length 0
```