---
title: 字节对齐
date: 2020-02-06 11:38:08
tags:
categories:
  - CPP
img: https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png
---

**解释**
现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特 定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。--百度百科

**原因**
各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐.其他平台可能没有这种情况
但是最常见的是如果不按照适合其平台要求对 数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。--百度百科


```c++
struct Foo
{
    char foo1;
    int foo2;
    short foo3;
}

sizeof(Foo) = 12
sizeof(char) + sizeof(int) + sizeof(short) = 7
```
说明内存中并不是连续存储的这三个变量;

```c++
Foo foo1{'1', 2, 3};
write(fd, &foo1, sizeof(foo1));
```
// hexdump 查看
0000000 5631 0000 0002 0000 0003 0000
对应图示如下
![](https://lsmg-img.oss-cn-beijing.aliyuncs.com/%E6%9D%82%E9%A1%B9/%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90.png)

第一字节 0x31 正好是 '1' *蓝色区域*

第二三四字节 为填充 *红色区域*
因为sizeof(int)=4所以foo2的偏移量是四的倍数 , 故需要填充三个字节 3+1 = 4

第五六七八字节 0x02对应2 *灰色区域*

没有填充是因为sizeof(short)=2所以foo3的偏移量是2的倍数 由于偏移量是8 所以不需要填充

第九十字节 0x03 对应3

第十一十二字节填充*黑色区域*
因为此结构中最大的sizeof()=4所以需要将字节数对齐到4的倍数 目前10字节 所以需要填充2字节到
12字节满足四的倍数