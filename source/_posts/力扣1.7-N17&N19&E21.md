---
title: 力扣1.7-N17&N19&E21
tags:
  - 二叉树
categories:
  - 算法
  - 力扣每日一题
date: 2021-1-7 16:21:02
---

# [17\. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

Difficulty: **中等**


给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)

**示例:**

```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

**说明:**  
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。


## Solution1

```c++
​class Solution {
public:
    vector<string> letterCombinations(string digits)
    {
        vector<string> result;
        if (digits.empty())
        {
            
        }
        else
        {
            solve(digits, 0, "", result);
        }
        return result;
    }

    void solve(const string& digits, int sub, string temp, vector<string>& result)
    {
        if (sub == digits.size())
        {
            result.push_back(temp);
        }
        else
        {
            char begin = (digits[sub] - '2') * 3 + 'a';
            switch (digits[sub])
            {
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                {
                    for (int i = 0; i < 3; ++i)
                    {
                        char a = begin + i;
                        solve(digits, sub + 1, temp + a, result);
                    }
                    break;
                }
                case '7':
                {
                    for (int i = 0; i < 4; ++i)
                    {
                        char a = begin + i;
                        solve(digits, sub + 1, temp + a, result);
                    }
                    break;
                }
                case '8':
                {
                    begin += 1;
                    for (int i = 0; i < 3; ++i)
                    {
                        char a = begin + i;
                        solve(digits, sub + 1, temp + a, result);
                    }
                    break;
                }
                case '9':
                {
                    begin += 1;
                    for (int i = 0; i < 4; ++i)
                    {
                        char a = begin + i;
                        solve(digits, sub + 1, temp + a, result);
                    }
                    break;
                }
            }
        }
    }
};
```

# [19\. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

Difficulty: **中等**


给定一个链表，删除链表的倒数第 _n _个节点，并且返回链表的头结点。

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```

**说明：**

给定的 _n_ 保证是有效的。

**进阶：**

你能尝试使用一趟扫描实现吗？


## Solution1

```c++
​/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n)
    {
        if (!head)
        {
            return nullptr;
        }

        ListNode* node = head;
        ListNode* temp = node;
        ListNode* last_temp = nullptr;
        
        int now_sub = 0;

        while (node->next)
        {
            if (now_sub == n - 1)
            {
                last_temp = temp;
                temp = temp->next;
                node = node->next;
            }
            else
            {
                node = node->next;
                now_sub++;
            }
        }

        if (temp == head)
        {
            head = head->next;
        }
        else
        {
            last_temp->next = temp->next;
        }
        return head;
    }
};
```

# [21\. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

Difficulty: **简单**


将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**

```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**

```
输入：l1 = [], l2 = [0]
输出：[0]
```

**提示：**

*   两个链表的节点数目范围是 `[0, 50]`
*   `-100 <= Node.val <= 100`
*   `l1` 和 `l2` 均按 **非递减顺序** 排列


## Solution1

```c++
​/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)
    {
        if (!l1)
        {
            return l2;
        }
        if (!l2)
        {
            return l1;
        }

        ListNode* head = nullptr;
        if (l1->val < l2->val)
        {
            head = l1;
            l1 = l1->next;
        }
        else
        {
            head = l2;
            l2 = l2->next;
        }
        ListNode* temp = head;

        while (l1 || l2)
        {
            if (!l1)
            {
                temp->next = l2;
                break;
            }
            else if (!l2)
            {
                temp->next = l1;
                break;
            }
            else
            {
                if (l1->val < l2->val)
                {
                    temp->next = l1;
                    l1 = l1->next;
                }
                else
                {
                    temp->next = l2;
                    l2 = l2->next;
                }
                temp = temp->next;
            }
        }
        return head;
    }
};
```