---
title: 力扣1.2-N654.最大二叉树
tags:
  - 二叉树
categories:
  - 力扣每日一题
date: 2021-1-2 16:21:02
---

# [654\. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

Difficulty: **中等**


给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

1.  二叉树的根是数组中的最大元素。
2.  左子树是通过数组中最大值左边部分构造出的最大二叉树。
3.  右子树是通过数组中最大值右边部分构造出的最大二叉树。

通过给定的数组构建最大二叉树，并且输出这个树的根节点。

**示例 ：**

```
输入：[3,2,1,6,0,5]
输出：返回下面这棵树的根节点：

      6
    /   \
   3     5
    \    / 
     2  0   
       \
        1
```

**提示：**

1.  给定的数组的大小在 [1, 1000] 之间。


## 代码1
```c++
class Solution {
public:

    int GetMaxSub(vector<int>& nums, int left, int right)
    {
        int result = left;

        for (int i = left + 1; i < right; ++i)
        {
            if (nums[i] > nums[result])
            {
                result = i;
            }
        }

        return result;
    }

    TreeNode* constructMaximumBinaryTree(vector<int>& nums)
    {
        int max_sub = GetMaxSub(nums, 0, nums.size());

        TreeNode* root = new TreeNode(nums[max_sub]);

        ConstructMaximumBinaryTree(nums, 0, max_sub, nums.size(), root);

        return root;
    }

    void ConstructMaximumBinaryTree(vector<int>& nums, int left, int mid, int right, TreeNode* root)
    {
        if (left < mid)
        {
            int l_max = GetMaxSub(nums, left, mid);
            root->left = new TreeNode(nums[l_max]);
            ConstructMaximumBinaryTree(nums, left, l_max, mid, root->left);
        }
        
        if (mid + 1 < right)
        {
            int r_max = GetMaxSub(nums, mid + 1, right);
            root->right = new TreeNode(nums[r_max]);
            ConstructMaximumBinaryTree(nums, mid + 1, r_max, right, root->right);
        }
    }
};
```

自己的第一个思路就是通过ConstructMaximumBinaryTree给传入的root节点构造左子树和右子树

然后递归的给root的左子树和右子树构造子树

每次传入left mid right将数组切分为两段 左段构造root的左子树 右段构造root的右子树

## 代码2
```c++
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums)
    {
        return constructMaximumBinaryTree(nums, 0, nums.size());
    }

    TreeNode* constructMaximumBinaryTree(vector<int>& nums, int left, int right)
    {
        if (left + 1 > right)
        {
            return nullptr;
        }

        int max_sub = left;
        for (int i = left + 1; i < right; ++i)
        {
            if (nums[i] > nums[max_sub])
            {
                max_sub = i;
            }
        }

        TreeNode* node = new TreeNode(nums[max_sub]);
        node->left = constructMaximumBinaryTree(nums, left, max_sub);
        node->right = constructMaximumBinaryTree(nums, max_sub + 1, right);

        return node;
    }
};
```

题解的答案更加的简洁每次的constructMaximumBinaryTree仅负责构造一个节点返回回去成为左节点或者右节点

同时给构造出的节点赋值左节点和右节点.

相对我的代码构造左节点和右节点 这里淡化了左右节点的区别. 通过传入的参数即可知道是左右节点然后赋值给left right


