---
title: 力扣11.24-N3.无重复字符的最长子串
tags:
  - 递归分治
categories:
  - 力扣每日一题
date: 2020-11-24 18:50:02
---

# N3.无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:
```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
示例 2:
```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```
示例 3:
```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 代码1
```c++
class Solution {
public:
int lengthOfLongestSubstring(string s)
{
    bool char_flag[128]; // 记录字符是否出现过
    int char_sub[128]; // 记录字符下标
    memset(char_flag, false, sizeof char_flag);
    int max_result = 0;
    int begin_sub = 0;

    int sub = 0;
    while (sub < s.length())
    {
        char current_char = s[sub];

        if (char_flag[current_char])
        {
            if (sub - begin_sub > max_result)
            {
                max_result = sub - begin_sub;
            }

            for (int i = begin_sub; i < char_sub[current_char]; ++i)
            {
                char_flag[s[i]] = false;
            }
            begin_sub = char_sub[current_char] + 1;
            char_sub[current_char] = sub;
        }
        else
        {
            char_sub[current_char] = sub;
            char_flag[current_char] = true;
        }

        sub++;
        if (sub == s.length())
        {
            if (sub - begin_sub > max_result)
            {
                max_result = sub - begin_sub;
            }
        }

    }

    return max_result;
}
};
```

思路是按顺序读取char, 如果没有出现过则标记出现记录下标.

如果出现了则用当前下标减去开始下标判断是否更长来记录, 同时更新开始下标为重复字符的下标后一个字符下标.

移动开始下标后 需要取消 新开始标记和旧开始标记之前的char标记


## 样例代码

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s)
    {
        int heap[128] = {0};
        int res = 0;
        for(int i = 0, j = 0; j < s.size(); ++j)
        {
            heap[s[j]]++; // 标记字符出现
            while(heap[s[j]] > 1) // 再次出现
            {
              /*
              开始符号标记下标 向前滑动 1 将开始下标的字符滑动出去
              如果滑出去的字符是本次遇到的重复字符 则继续 否则一直滑动到重复字符位置
              */
                heap[s[i]]--;
                i++;
            }
            res = max(res, j - i + 1);
        }
        return res;
    }
};
```

首先看上去 代码就非常的短 我的写了40行而这个仅有10行

## 改进

我的虽然不是一次滑动一个字符 而是滑动一步到位. 但是仍需要一个for循环来去掉滑出的字符. 所以同样例代码思想.

所以没有必要一次滑动到位, 反正for循环需要执行就在for之中慢慢滑动. `这样可以省去记录字符出现的下标`

我字符出现记录使用的bool数组然而使用`int数组却能包含更多的信息`.

我原版代码需要额外判定一次是否到了尾部, 当最后一个字符没有重复的时候 循环就结束了.